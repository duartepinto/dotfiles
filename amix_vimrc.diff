diff --git a/sources_non_forked/ack.vim/.gitignore b/sources_non_forked/ack.vim/.gitignore
deleted file mode 100644
index 6e92f57..0000000
--- a/sources_non_forked/ack.vim/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-tags
diff --git a/sources_non_forked/ack.vim/LICENSE b/sources_non_forked/ack.vim/LICENSE
deleted file mode 100644
index 056ea36..0000000
--- a/sources_non_forked/ack.vim/LICENSE
+++ /dev/null
@@ -1,89 +0,0 @@
-ack.vim is distributed under the same license terms as Vim itself, which you
-can find in full with `:help license` within Vim, or copied in full herein.
-
-Copyright (c) 2007-2015 Antoine Imbert <antoine.imbert+ackvim@gmail.com>
-                        and contributors.
-
-Maintainers may be contacted via GitHub Issues at:
-
-   https://github.com/mileszs/ack.vim/issues
-
-
-VIM LICENSE
-
-I)  There are no restrictions on distributing unmodified copies of Vim except
-    that they must include this license text.  You can also distribute
-    unmodified parts of Vim, likewise unrestricted except that they must
-    include this license text.  You are also allowed to include executables
-    that you made from the unmodified Vim sources, plus your own usage
-    examples and Vim scripts.
-
-II) It is allowed to distribute a modified (or extended) version of Vim,
-    including executables and/or source code, when the following four
-    conditions are met:
-    1) This license text must be included unmodified.
-    2) The modified Vim must be distributed in one of the following five ways:
-       a) If you make changes to Vim yourself, you must clearly describe in
-	  the distribution how to contact you.  When the maintainer asks you
-	  (in any way) for a copy of the modified Vim you distributed, you
-	  must make your changes, including source code, available to the
-	  maintainer without fee.  The maintainer reserves the right to
-	  include your changes in the official version of Vim.  What the
-	  maintainer will do with your changes and under what license they
-	  will be distributed is negotiable.  If there has been no negotiation
-	  then this license, or a later version, also applies to your changes.
-	  The current maintainer is Bram Moolenaar <Bram@vim.org>.  If this
-	  changes it will be announced in appropriate places (most likely
-	  vim.sf.net, www.vim.org and/or comp.editors).  When it is completely
-	  impossible to contact the maintainer, the obligation to send him
-	  your changes ceases.  Once the maintainer has confirmed that he has
-	  received your changes they will not have to be sent again.
-       b) If you have received a modified Vim that was distributed as
-	  mentioned under a) you are allowed to further distribute it
-	  unmodified, as mentioned at I).  If you make additional changes the
-	  text under a) applies to those changes.
-       c) Provide all the changes, including source code, with every copy of
-	  the modified Vim you distribute.  This may be done in the form of a
-	  context diff.  You can choose what license to use for new code you
-	  add.  The changes and their license must not restrict others from
-	  making their own changes to the official version of Vim.
-       d) When you have a modified Vim which includes changes as mentioned
-	  under c), you can distribute it without the source code for the
-	  changes if the following three conditions are met:
-	  - The license that applies to the changes permits you to distribute
-	    the changes to the Vim maintainer without fee or restriction, and
-	    permits the Vim maintainer to include the changes in the official
-	    version of Vim without fee or restriction.
-	  - You keep the changes for at least three years after last
-	    distributing the corresponding modified Vim.  When the maintainer
-	    or someone who you distributed the modified Vim to asks you (in
-	    any way) for the changes within this period, you must make them
-	    available to him.
-	  - You clearly describe in the distribution how to contact you.  This
-	    contact information must remain valid for at least three years
-	    after last distributing the corresponding modified Vim, or as long
-	    as possible.
-       e) When the GNU General Public License (GPL) applies to the changes,
-	  you can distribute the modified Vim under the GNU GPL version 2 or
-	  any later version.
-    3) A message must be added, at least in the output of the ":version"
-       command and in the intro screen, such that the user of the modified Vim
-       is able to see that it was modified.  When distributing as mentioned
-       under 2)e) adding the message is only required for as far as this does
-       not conflict with the license used for the changes.
-    4) The contact information as required under 2)a) and 2)d) must not be
-       removed or changed, except that the person himself can make
-       corrections.
-
-III) If you distribute a modified version of Vim, you are encouraged to use
-     the Vim license for your changes and make them available to the
-     maintainer, including the source code.  The preferred way to do this is
-     by e-mail or by uploading the files to a server and e-mailing the URL.
-     If the number of changes is small (e.g., a modified Makefile) e-mailing a
-     context diff will do.  The e-mail address to be used is
-     <maintainer@vim.org>
-
-IV)  It is not allowed to remove this license from the distribution of the Vim
-     sources, parts of it or from a modified version.  You may use this
-     license for previous Vim releases instead of the license that they came
-     with, at your option.
diff --git a/sources_non_forked/ack.vim/README.md b/sources_non_forked/ack.vim/README.md
deleted file mode 100644
index 378fc3e..0000000
--- a/sources_non_forked/ack.vim/README.md
+++ /dev/null
@@ -1,163 +0,0 @@
-# ack.vim
-
-Run your favorite search tool from Vim, with an enhanced results list.
-
-This plugin was designed as a Vim frontend for the programmer's search tool
-[ack]. ack can be used as a replacement for 99% of the uses of `grep`. The
-plugin allows you to search with ack from within Vim and shows the results in a
-split window.
-
-But here's a little secret for the Vim-seasoned: it's just a light wrapper for
-Vim's [grepprg] and the [quickfix] window for match results. This makes it easy
-to integrate with your own Vim configuration and use existing knowledge of core
-features. It also means the plugin is flexible to use with other search tools.
-
-[grepprg]: http://vimdoc.sourceforge.net/htmldoc/options.html#'grepprg'
-[quickfix]: http://vimdoc.sourceforge.net/htmldoc/quickfix.html#quickfix
-
-## Installation
-
-### ack
-
-You will need ack (>= 2.0), of course. To install it follow the
-[manual](http://beyondgrep.com/install/).
-
-### The Plugin
-
-It is recommended to use one of the popular plugin managers for Vim. There are
-many and you probably already have a preferred one, but a few examples for your
-copy-and-paste convenience:
-
-#### Pathogen
-
-    $ git clone https://github.com/mileszs/ack.vim.git ~/.vim/bundle/ack.vim
-
-#### Vundle
-
-```vim
-Plugin 'mileszs/ack.vim'
-```
-
-#### NeoBundle
-
-```vim
-NeoBundle 'mileszs/ack.vim'
-```
-
-#### Manual (not recommended)
-
-[Download][releases] the plugin and extract it in `~/.vim/` (or
-`%PROGRAMFILES%/Vim/vimfiles` on Windows).
-
-## Usage
-
-    :Ack [options] {pattern} [{directories}]
-
-Search recursively in `{directories}` (which defaults to the current directory)
-for the `{pattern}`.
-
-Files containing the search term will be listed in the quickfix window, along
-with the line number of the occurrence, once for each occurrence. `<Enter>` on
-a line in this window will open the file and place the cursor on the matching
-line.
-
-Just like where you use `:grep`, `:grepadd`, `:lgrep`, and :`lgrepadd`, you can
-use `:Ack`, `:AckAdd`, `:LAck`, and `:LAckAdd` respectively. (See `:help Ack`
-after installing, or [`doc/ack.txt`][doc] in the repo, for more information.)
-
-For more ack help see [ack documentation](http://beyondgrep.com/documentation/).
-
-[doc]: https://github.com/mileszs/ack.vim/blob/master/doc/ack.txt
-
-### Keyboard Shortcuts
-
-The quickfix results window is augmented with these convenience mappings:
-
-    ?    a quick summary of these keys, repeat to close
-    o    to open (same as Enter)
-    O    to open and close the quickfix window
-    go   to preview file, open but maintain focus on ack.vim results
-    t    to open in new tab
-    T    to open in new tab without moving to it
-    h    to open in horizontal split
-    H    to open in horizontal split, keeping focus on the results
-    v    to open in vertical split
-    gv   to open in vertical split, keeping focus on the results
-    q    to close the quickfix window
-
-### Gotchas
-
-To search for a pattern that contains whitespace, you need to enclose the
-pattern in single quotes. For example: `:Ack 'foo bar'` to search for
-'foo bar'.
-
-Some characters have special meaning, and need to be escaped in your search
-pattern. For instance, `#`. You need to escape it with `:Ack '\\\#define
-foo'` to search for '#define foo'. See [issue #5].
-
-[issue #5]: https://github.com/mileszs/ack.vim/issues/5
-
-## Possibly FAQ
-
-#### Can I use `ag` ([The Silver Searcher]) with this?
-
-Absolutely, and probably other tools if their output is similar or you can
-write a pattern match for it--just set `g:ackprg`. If you like, you can fall
-back to Ack in case you use your vimrc on a system without Ag available:
-
-```vim
-if executable('ag')
-  let g:ackprg = 'ag --vimgrep'
-endif
-```
-
-Since Ack is quite portable you might check a copy of it into your dotfiles
-repository in `~/bin` so you'll nearly always have it available.
-
-#### What's the difference from ag.vim?
-
-Well... not a lot really.
-
-Present maintainer, yours truly, [kind of wishes they never forked][sadface],
-contributes to both, and wouldn't mind seeing them merged again. ag.vim got a
-nice code clean-up (which ack.vim is now hopefully getting), and ack.vim picked
-up a few features that haven't made their way to ag.vim, like `:AckWindow`,
-optional background search execution with [vim-dispatch], and auto-previewing.
-
-#### I don't want to jump to the first result automatically. ####
-
-Use `:Ack!`, with bang. If you want this behavior most of the time, you might
-like an abbreviation or mapping in your personal config, something like these:
-
-```vim
-cnoreabbrev Ack Ack!
-nnoremap <Leader>a :Ack!<Space>
-```
-
-Most of the `:[L]Ack*` commands support this. Note that this behavior follows
-the convention of Vim's built-in `:grep` and `:make` commands.
-
-[The Silver Searcher]: https://github.com/ggreer/the_silver_searcher
-[sadface]: https://github.com/mileszs/ack.vim/commit/d97090fb502d40229e6976dfec0e06636ba227d5#commitcomment-5771145
-
-## Changelog
-
-Please see [the GitHub releases page][releases].
-
-## Credits
-
-This plugin is derived from Antoine Imbert's blog post [ack and Vim
-Integration][] (in particular, the function in the update to the post). [Miles
-Sterrett][mileszs] packaged it up as a plugin and documented it in Vim's help
-format, and since then [many contributors][contributors] have submitted
-enhancements and fixes.
-
-And of course, where would we be without [ack]. And, you know, Vim.
-
-[ack and Vim Integration]: http://blog.ant0ine.com/typepad/2007/03/ack-and-vim-integration.html
-[mileszs]: https://github.com/mileszs
-[contributors]: https://github.com/mileszs/ack.vim/graphs/contributors
-[ack]: http://beyondgrep.com/
-
-[vim-dispatch]: https://github.com/tpope/vim-dispatch
-[releases]: https://github.com/mileszs/ack.vim/releases
diff --git a/sources_non_forked/ack.vim/autoload/ack.vim b/sources_non_forked/ack.vim/autoload/ack.vim
deleted file mode 100644
index b6afdba..0000000
--- a/sources_non_forked/ack.vim/autoload/ack.vim
+++ /dev/null
@@ -1,246 +0,0 @@
-if exists('g:autoloaded_ack') || &cp
-  finish
-endif
-
-if exists('g:ack_use_dispatch')
-  if g:ack_use_dispatch && !exists(':Dispatch')
-    call s:Warn('Dispatch not loaded! Falling back to g:ack_use_dispatch = 0.')
-    let g:ack_use_dispatch = 0
-  endif
-else
-  let g:ack_use_dispatch = 0
-endif
-
-"-----------------------------------------------------------------------------
-" Public API
-"-----------------------------------------------------------------------------
-
-function! ack#Ack(cmd, args) "{{{
-  call s:Init(a:cmd)
-  redraw
-
-  " Local values that we'll temporarily set as options when searching
-  let l:grepprg = g:ackprg
-  let l:grepformat = '%f:%l:%c:%m,%f:%l:%m'  " Include column number
-
-  " Strip some options that are meaningless for path search and set match
-  " format accordingly.
-  if s:SearchingFilepaths()
-    let l:grepprg = substitute(l:grepprg, '-H\|--column', '', 'g')
-    let l:grepformat = '%f'
-  endif
-
-  " Check user policy for blank searches
-  if empty(a:args)
-    if !g:ack_use_cword_for_empty_search
-      echo "No regular expression found."
-      return
-    endif
-  endif
-
-  " If no pattern is provided, search for the word under the cursor
-  let l:grepargs = empty(a:args) ? expand("<cword>") : a:args . join(a:000, ' ')
-
-  "Bypass search if cursor is on blank string
-  if l:grepargs == ""
-    echo "No regular expression found."
-    return
-  endif
-
-  " NOTE: we escape special chars, but not everything using shellescape to
-  "       allow for passing arguments etc
-  let l:escaped_args = escape(l:grepargs, '|#%')
-
-  echo "Searching ..."
-
-  if g:ack_use_dispatch
-    call s:SearchWithDispatch(l:grepprg, l:escaped_args, l:grepformat)
-  else
-    call s:SearchWithGrep(a:cmd, l:grepprg, l:escaped_args, l:grepformat)
-  endif
-
-  " Dispatch has no callback mechanism currently, we just have to display the
-  " list window early and wait for it to populate :-/
-  call ack#ShowResults()
-  call s:Highlight(l:grepargs)
-endfunction "}}}
-
-function! ack#AckFromSearch(cmd, args) "{{{
-  let search = getreg('/')
-  " translate vim regular expression to perl regular expression.
-  let search = substitute(search, '\(\\<\|\\>\)', '\\b', 'g')
-  call ack#Ack(a:cmd, '"' . search . '" ' . a:args)
-endfunction "}}}
-
-function! ack#AckHelp(cmd, args) "{{{
-  let args = a:args . ' ' . s:GetDocLocations()
-  call ack#Ack(a:cmd, args)
-endfunction "}}}
-
-function! ack#AckWindow(cmd, args) "{{{
-  let files = tabpagebuflist()
-
-  " remove duplicated filenames (files appearing in more than one window)
-  let files = filter(copy(sort(files)), 'index(files,v:val,v:key+1)==-1')
-  call map(files, "bufname(v:val)")
-
-  " remove unnamed buffers as quickfix (empty strings before shellescape)
-  call filter(files, 'v:val != ""')
-
-  " expand to full path (avoid problems with cd/lcd in au QuickFixCmdPre)
-  let files = map(files, "shellescape(fnamemodify(v:val, ':p'))")
-  let args = a:args . ' ' . join(files)
-
-  call ack#Ack(a:cmd, args)
-endfunction "}}}
-
-function! ack#ShowResults() "{{{
-  let l:handler = s:UsingLocList() ? g:ack_lhandler : g:ack_qhandler
-  execute l:handler
-  call s:ApplyMappings()
-  redraw!
-endfunction "}}}
-
-"-----------------------------------------------------------------------------
-" Private API
-"-----------------------------------------------------------------------------
-
-function! s:ApplyMappings() "{{{
-  if !s:UsingListMappings() || &filetype != 'qf'
-    return
-  endif
-
-  let l:wintype = s:UsingLocList() ? 'l' : 'c'
-  let l:closemap = ':' . l:wintype . 'close<CR>'
-  let g:ack_mappings.q = l:closemap
-
-  nnoremap <buffer> <silent> ? :call <SID>QuickHelp()<CR>
-
-  if g:ack_autoclose
-    " We just map the 'go' and 'gv' mappings to close on autoclose, wtf?
-    for key_map in items(g:ack_mappings)
-      execute printf("nnoremap <buffer> <silent> %s %s", get(key_map, 0), get(key_map, 1) . l:closemap)
-    endfor
-
-    execute "nnoremap <buffer> <silent> <CR> <CR>" . l:closemap
-  else
-    for key_map in items(g:ack_mappings)
-      execute printf("nnoremap <buffer> <silent> %s %s", get(key_map, 0), get(key_map, 1))
-    endfor
-  endif
-
-  if exists("g:ackpreview") " if auto preview in on, remap j and k keys
-    nnoremap <buffer> <silent> j j<CR><C-W><C-P>
-    nnoremap <buffer> <silent> k k<CR><C-W><C-P>
-    nmap <buffer> <silent> <Down> j
-    nmap <buffer> <silent> <Up> k
-  endif
-endfunction "}}}
-
-function! s:GetDocLocations() "{{{
-  let dp = ''
-  for p in split(&rtp, ',')
-    let p = p . '/doc/'
-    if isdirectory(p)
-      let dp = p . '*.txt ' . dp
-    endif
-  endfor
-
-  return dp
-endfunction "}}}
-
-function! s:Highlight(args) "{{{
-  if !g:ackhighlight
-    return
-  endif
-
-  let @/ = matchstr(a:args, "\\v(-)\@<!(\<)\@<=\\w+|['\"]\\zs.{-}\\ze['\"]")
-  call feedkeys(":let &hlsearch=1 \| echo \<CR>", "n")
-endfunction "}}}
-
-" Initialize state for an :Ack* or :LAck* search
-function! s:Init(cmd) "{{{
-  let s:searching_filepaths = (a:cmd =~# '-g$') ? 1 : 0
-  let s:using_loclist       = (a:cmd =~# '^l') ? 1 : 0
-
-  if g:ack_use_dispatch && s:using_loclist
-    call s:Warn('Dispatch does not support location lists! Proceeding with quickfix...')
-    let s:using_loclist = 0
-  endif
-endfunction "}}}
-
-function! s:QuickHelp() "{{{
-  execute 'edit' globpath(&rtp, 'doc/ack_quick_help.txt')
-
-  silent normal gg
-  setlocal buftype=nofile bufhidden=hide nobuflisted
-  setlocal nomodifiable noswapfile
-  setlocal filetype=help
-  setlocal nonumber norelativenumber nowrap
-  setlocal foldmethod=diff foldlevel=20
-
-  nnoremap <buffer> <silent> ? :q!<CR>:call ack#ShowResults()<CR>
-endfunction "}}}
-
-function! s:SearchWithDispatch(grepprg, grepargs, grepformat) "{{{
-  let l:makeprg_bak     = &l:makeprg
-  let l:errorformat_bak = &l:errorformat
-
-  " We don't execute a :grep command for Dispatch, so add -g here instead
-  if s:SearchingFilepaths()
-    let l:grepprg = a:grepprg . ' -g'
-  else
-    let l:grepprg = a:grepprg
-  endif
-
-  try
-    let &l:makeprg     = l:grepprg . ' ' . a:grepargs
-    let &l:errorformat = a:grepformat
-
-    Make
-  finally
-    let &l:makeprg     = l:makeprg_bak
-    let &l:errorformat = l:errorformat_bak
-  endtry
-endfunction "}}}
-
-function! s:SearchWithGrep(grepcmd, grepprg, grepargs, grepformat) "{{{
-  let l:grepprg_bak    = &l:grepprg
-  let l:grepformat_bak = &grepformat
-
-  try
-    let &l:grepprg  = a:grepprg
-    let &grepformat = a:grepformat
-
-    silent execute a:grepcmd a:grepargs
-  finally
-    let &l:grepprg  = l:grepprg_bak
-    let &grepformat = l:grepformat_bak
-  endtry
-endfunction "}}}
-
-" Are we finding matching files, not lines? (the -g option -- :AckFile)
-function! s:SearchingFilepaths() "{{{
-  return get(s:, 'searching_filepaths', 0)
-endfunction "}}}
-
-" Predicate for whether mappings are enabled for list type of current search.
-function! s:UsingListMappings() "{{{
-  if s:UsingLocList()
-    return g:ack_apply_lmappings
-  else
-    return g:ack_apply_qmappings
-  endif
-endfunction "}}}
-
-" Were we invoked with a :LAck command?
-function! s:UsingLocList() "{{{
-  return get(s:, 'using_loclist', 0)
-endfunction "}}}
-
-function! s:Warn(msg) "{{{
-  echohl WarningMsg | echomsg 'Ack: ' . a:msg | echohl None
-endf "}}}
-
-let g:autoloaded_ack = 1
-" vim:set et sw=2 ts=2 tw=78 fdm=marker
diff --git a/sources_non_forked/ack.vim/doc/ack.txt b/sources_non_forked/ack.vim/doc/ack.txt
deleted file mode 100644
index 22e884b..0000000
--- a/sources_non_forked/ack.vim/doc/ack.txt
+++ /dev/null
@@ -1,315 +0,0 @@
-*ack.txt*   Plugin that integrates ack with Vim
-
-==============================================================================
-Author:  Antoine Imbert <antoine.imbert+ackvim@gmail.com>         *ack-author*
-License: Same terms as Vim itself (see |license|)
-
-This plugin is only available if 'compatible' is not set.
-
-{Vi does not have any of this}
-
-==============================================================================
-INTRODUCTION                                                             *ack*
-
-This plugin is a front for the Perl module App::Ack.  Ack can be used as a
-replacement for grep.  This plugin will allow you to run ack from vim, and
-shows the results in a split window.
-
-:Ack[!] [options] {pattern} [{directory}]                               *:Ack*
-
-    Search recursively in {directory} (which defaults to the current
-    directory) for the {pattern}.  Behaves just like the |:grep| command, but
-    will open the |Quickfix| window for you. If [!] is not given the first
-    occurrence is jumped to.
-
-:AckAdd [options] {pattern} [{directory}]                            *:AckAdd*
-
-    Just like |:Ack|, but instead of making a new list, the matches are
-    appended to the current |quickfix| list.
-
-:AckFromSearch [{directory}]                                  *:AckFromSearch*
-
-    Just like |:Ack| but the pattern is from previous search.
-
-:LAck [options] {pattern} [{directory}]                                *:LAck*
-
-    Just like |:Ack| but instead of the |quickfix| list, matches are placed in
-    the current |location-list|.
-
-:LAckAdd [options] {pattern} [{directory}]                          *:LAckAdd*
-
-    Just like |:AckAdd| but instead of the |quickfix| list, matches are added
-    to the current |location-list|
-
-:AckFile [options] {pattern} [{directory}]                          *:AckFile*
-
-    Search recursively in {directory} (which defaults to the current
-    directory) for filenames matching the {pattern}.  Behaves just like the
-    |:grep| command, but will open the |Quickfix| window for you.
-
-:AckHelp[!] [options] {pattern}                                      *:AckHelp*
-
-    Search vim documentation files for the {pattern}.  Behaves just like the
-    |:Ack| command, but searches only vim documentation .txt files
-
-:LAckHelp [options] {pattern}                                        *:LAckHelp*
-
-    Just like |:AckHelp| but instead of the |quickfix| list, matches are placed
-    in the current |location-list|.
-
-:AckWindow[!] [options] {pattern}                                 *:AckWindow*
-
-    Search all buffers visible in the screen (current tab page only) files for
-    the {pattern}.
-
-:LAckWindow [options] {pattern}                                   *:LAckWindow*
-
-    Just like |:AckWindow| but instead of the |quickfix| list, matches are
-    placed in the current |location-list|.
-
-Files containing the search term will be listed in the split window, along
-with the line number of the occurrence, once for each occurrence.  <Enter> on
-a line in this window will open the file, and place the cursor on the matching
-line.
-
-Note that if you are using Dispatch.vim with |g:ack_use_dispatch|, location
-lists are not supported, because Dispatch does not support them at this time.
-`:LAck` versions of commands above will give a warning and proceed to use the
-quickfix list instead.
-
-See http://beyondgrep.com/ for more information on searching with ack.
-
-
-==============================================================================
-CONFIGURATION                                              *ack-configuration*
-
-                                                                    *g:ackprg*
-g:ackprg
-Default for ubuntu: "ack-grep"
-Default for other systems: "ack"
-
-Use this option to specify the search command and its default arguments.
-
-Example:
->
-        let g:ackprg = "ag --vimgrep"
-<
-                                                       *g:ack_default_options*
-g:ack_default_options
-Default: " -s -H --nocolor --nogroup --column"
-
-Use this option to specify the default arguments given to `ack`. This is only
-used if |g:ackprg| has not been customized from the default--if you are using
-a custom search program instead of Ack, set your preferred options in
-|g:ackprg|.
-
-NOTE: This option may be deprecated in the future. ~
-
-Example:
->
-        let g:ack_default_options =
-              \ " -s -H --nocolor --nogroup --column --smart-case --follow"
-<
-                                                       *g:ack_apply_qmappings*
-g:ack_apply_qmappings
-Default: 1
-
-This option enables mappings on the |quickfix| window.
-
-                                                       *g:ack_apply_lmappings*
-g:ack_apply_lmappings
-Default: 1
-
-This option enables mappings on |location-list| windows.
-
-                                                              *g:ack_mappings*
-g:ack_mappings
-Default: {
-      \ "t": "<C-W><CR><C-W>T",
-      \ "T": "<C-W><CR><C-W>TgT<C-W>j",
-      \ "o": "<CR>",
-      \ "O": "<CR><C-W><C-W>:ccl<CR>",
-      \ "go": "<CR><C-W>j",
-      \ "h": "<C-W><CR><C-W>K",
-      \ "H": "<C-W><CR><C-W>K<C-W>b",
-      \ "v": "<C-W><CR><C-W>H<C-W>b<C-W>J<C-W>t",
-      \ "gv": "<C-W><CR><C-W>H<C-W>b<C-W>J" }
-
-This option list all maps create on quickfix/Location list window.
-
-Example, if you want to open the result in the middle of the screen:
->
-        let g:ack_mappings = { "o": "<CR>zz" }
-<
-                                                              *g:ack_qhandler*
-g:ack_qhandler
-Default: "botright copen"
-
-Command to open the quickview window.
-
-If you want to open a quickview window with 30 lines you can do:
->
-        let g:ack_qhandler = "botright copen 30"
-<
-                                                              *g:ack_lhandler*
-g:ack_lhandler
-Default: "botright lopen"
-
-Command to open the Location list window.
-
-If you want to open a Location list window with 30 lines you can do:
->
-        let g:ack_lhandler = "botright lopen 30"
-<
-                                                              *g:ackhighlight*
-g:ackhighlight
-Default: 0
-
-Use this option to highlight the searched term.
-
-Example:
->
-        let g:ackhighlight = 1
-<
-                                                             *g:ack_autoclose*
-g:ack_autoclose
-Default: 0
-
-Use this option to specify whether to close the quickfix window after
-using any of the shortcuts.
-
-Example:
->
-        let g:ack_autoclose = 1
-<
-                                                      *g:ack_autofold_results*
-g:ack_autofold_results
-Default: 0
-
-Use this option to fold the results in quickfix by file name. Only the current
-fold will be open by default and while you press 'j' and 'k' to move between the
-results if you hit other fold the last one will be closed and the current will
-be open.
-
-Example:
->
-        let g:ack_autofold_results = 1
-<
-                                                                *g:ackpreview*
-g:ackpreview
-Default: 0
-
-Use this option to automagically open the file with 'j' or 'k'.
-
-Example:
->
-        let g:ackpreview = 1
-<
-                                                          *g:ack_use_dispatch*
-g:ack_use_dispatch
-Default: 0
-
-Use this option to use vim-dispatch to run searches in the background, with a
-variety of execution backends for different systems.
-
-Due to limitations in Dispatch at this time, location lists are unsupported
-and result windows will appear before results are ready. Still, these may be
-acceptable tradeoffs for very large projects where searches are slow.
-
-Example:
->
-        let g:ack_use_dispatch = 1
-<
-                                             *g:ack_use_cword_for_empty_search*
-g:ack_use_cword_for_empty_search
-Default: 1
-
-Use this option to enable blank searches to run against the word under the
-cursor. When this option is not set, blank searches will only output an error
-message.
-
-Example:
->
-        let g:ack_use_cword_for_empty_search = 0
-<
-==============================================================================
-MAPPINGS                                                        *ack-mappings*
-
-The following keyboard shortcuts are available in the |quickfix| and
-|location-list| windows:
-
-?                   display a quick summary of these mappings.
-
-o                   open file (same as Enter).
-
-O                   open file and close the quickfix window.
-
-go                  preview file (open but maintain focus on ack.vim results).
-
-t                   open in a new tab.
-
-T                   open in new tab without moving to it.
-
-h                   open in horizontal split.
-
-H                   open in horizontal split, keeping focus on the results.
-
-v                   open in vertical split.
-
-gv                  open in vertical split, keeping focus on the results.
-
-q                   close the quickfix window.
-
-To adjust these, see |g:ack_mappings|.
-
-==============================================================================
-Ignoring files                                                    *ack-ignore*
-
-If you're using this plugin with ag, The Silver Searcher, bear in mind that:
-
-    - It ignores file patterns from your .gitignore and .hgignore.
-
-    - If there are other files in your source repository you don't wish to
-      search, you can add their patterns to an .agignore file.
-
-==============================================================================
-ISSUES AND FAQ                                            *ack-issues-and-faq*
-
-I don't want to jump to the first result automatically.~
-
-    Use `:Ack!`, with bang. If you want this behavior most of the time, you
-    might like an abbreviation or mapping in your personal config, something
-    like these:
->
-        cnoreabbrev Ack Ack!
-        nnoremap <Leader>a :Ack!<Space>
-<
-    Most of the `:[L]Ack*` commands support this. Note that this behavior
-    follows the convention of Vim's built-in |:grep| and |:make| commands.
-
-I use NERDTree and opening ack.vim results in a vertical split displacing it.~
-
-    You are probably using NERDTree with its default alignment at the left
-    side of the window. Set these custom mappings in your vimrc to work around
-    this:
->
-        let g:ack_mappings = {
-              \  'v':  '<C-W><CR><C-W>L<C-W>p<C-W>J<C-W>p',
-              \ 'gv': '<C-W><CR><C-W>L<C-W>p<C-W>J' }
-<
-    This solution will be improved in the future.
-
-Results show a mix of relative and absolute paths, making them hard to read.~
-
-    This is a quirk of Vim that can happen with plain |:vimgrep| too. You can
-    try this in your vimrc to work around it:
->
-        autocmd BufAdd * exe "cd" fnameescape(getcwd())
-<
-    but for some users this may be disruptive to their Vim workflow. For more
-    details, see:
-
-        http://vi.stackexchange.com/a/4816/7174
-        https://github.com/mileszs/ack.vim/issues/143
-
-vim:set et sw=4 ts=4 tw=78:
diff --git a/sources_non_forked/ack.vim/doc/ack_quick_help.txt b/sources_non_forked/ack.vim/doc/ack_quick_help.txt
deleted file mode 100644
index 94306a0..0000000
--- a/sources_non_forked/ack.vim/doc/ack_quick_help.txt
+++ /dev/null
@@ -1,15 +0,0 @@
-====  ack.vim quick help ===============
-
-  *?:*  a quick summary of these keys, repeat to close
-  *o:*  to open (same as Enter)
-  *O:*  to open and close the quickfix window
- *go:*  to preview file, open but maintain focus on ack.vim results
-  *t:*  to open in new tab
-  *T:*  to open in new tab without moving to it
-  *h:*  to open in horizontal split
-  *H:*  to open in horizontal split, keeping focus on the results
-  *v:*  to open in vertical split
- *gv:*  to open in vertical split, keeping focus on the results
-  *q:*  to close the quickfix window
-
-========================================
diff --git a/sources_non_forked/ack.vim/ftplugin/qf.vim b/sources_non_forked/ack.vim/ftplugin/qf.vim
deleted file mode 100644
index 27564fa..0000000
--- a/sources_non_forked/ack.vim/ftplugin/qf.vim
+++ /dev/null
@@ -1,9 +0,0 @@
-if exists("g:ack_autofold_results") && g:ack_autofold_results
-  setlocal foldlevel=0
-  setlocal foldmethod=expr
-  setlocal foldexpr=matchstr(getline(v:lnum),'^[^\|]\\+')==#matchstr(getline(v:lnum+1),'^[^\|]\\+')?1:'<1'
-  setlocal foldenable
-  setlocal foldclose=all
-  setlocal foldopen=all
-  nnoremap <buffer> j jzz
-endif
diff --git a/sources_non_forked/ack.vim/plugin/ack.vim b/sources_non_forked/ack.vim/plugin/ack.vim
deleted file mode 100644
index 202ae2e..0000000
--- a/sources_non_forked/ack.vim/plugin/ack.vim
+++ /dev/null
@@ -1,83 +0,0 @@
-if exists('g:loaded_ack') || &cp
-  finish
-endif
-
-if !exists("g:ack_default_options")
-  let g:ack_default_options = " -s -H --nopager --nocolor --nogroup --column"
-endif
-
-" Location of the ack utility
-if !exists("g:ackprg")
-  if executable('ack-grep')
-    let g:ackprg = "ack-grep"
-  elseif executable('ack')
-    let g:ackprg = "ack"
-  else
-    finish
-  endif
-  let g:ackprg .= g:ack_default_options
-endif
-
-if !exists("g:ack_apply_qmappings")
-  let g:ack_apply_qmappings = !exists("g:ack_qhandler")
-endif
-
-if !exists("g:ack_apply_lmappings")
-  let g:ack_apply_lmappings = !exists("g:ack_lhandler")
-endif
-
-let s:ack_mappings = {
-      \ "t": "<C-W><CR><C-W>T",
-      \ "T": "<C-W><CR><C-W>TgT<C-W>j",
-      \ "o": "<CR>",
-      \ "O": "<CR><C-W>p<C-W>c",
-      \ "go": "<CR><C-W>p",
-      \ "h": "<C-W><CR><C-W>K",
-      \ "H": "<C-W><CR><C-W>K<C-W>b",
-      \ "v": "<C-W><CR><C-W>H<C-W>b<C-W>J<C-W>t",
-      \ "gv": "<C-W><CR><C-W>H<C-W>b<C-W>J" }
-
-if exists("g:ack_mappings")
-  let g:ack_mappings = extend(s:ack_mappings, g:ack_mappings)
-else
-  let g:ack_mappings = s:ack_mappings
-endif
-
-if !exists("g:ack_qhandler")
-  let g:ack_qhandler = "botright copen"
-endif
-
-if !exists("g:ack_lhandler")
-  let g:ack_lhandler = "botright lopen"
-endif
-
-if !exists("g:ackhighlight")
-  let g:ackhighlight = 0
-endif
-
-if !exists("g:ack_autoclose")
-  let g:ack_autoclose = 0
-endif
-
-if !exists("g:ack_autofold_results")
-  let g:ack_autofold_results = 0
-endif
-
-if !exists("g:ack_use_cword_for_empty_search")
-  let g:ack_use_cword_for_empty_search = 1
-endif
-
-command! -bang -nargs=* -complete=file Ack           call ack#Ack('grep<bang>', <q-args>)
-command! -bang -nargs=* -complete=file AckAdd        call ack#Ack('grepadd<bang>', <q-args>)
-command! -bang -nargs=* -complete=file AckFromSearch call ack#AckFromSearch('grep<bang>', <q-args>)
-command! -bang -nargs=* -complete=file LAck          call ack#Ack('lgrep<bang>', <q-args>)
-command! -bang -nargs=* -complete=file LAckAdd       call ack#Ack('lgrepadd<bang>', <q-args>)
-command! -bang -nargs=* -complete=file AckFile       call ack#Ack('grep<bang> -g', <q-args>)
-command! -bang -nargs=* -complete=help AckHelp       call ack#AckHelp('grep<bang>', <q-args>)
-command! -bang -nargs=* -complete=help LAckHelp      call ack#AckHelp('lgrep<bang>', <q-args>)
-command! -bang -nargs=*                AckWindow     call ack#AckWindow('grep<bang>', <q-args>)
-command! -bang -nargs=*                LAckWindow    call ack#AckWindow('lgrep<bang>', <q-args>)
-
-let g:loaded_ack = 1
-
-" vim:set et sw=2 ts=2 tw=78 fdm=marker
diff --git a/sources_non_forked/ale/LICENSE b/sources_non_forked/ale/LICENSE
deleted file mode 100644
index f8f3524..0000000
--- a/sources_non_forked/ale/LICENSE
+++ /dev/null
@@ -1,22 +0,0 @@
-Copyright (c) 2016-2019, w0rp <devw0rp@gmail.com>
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-1. Redistributions of source code must retain the above copyright notice, this
-   list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright notice,
-   this list of conditions and the following disclaimer in the documentation
-   and/or other materials provided with the distribution.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff --git a/sources_non_forked/ale/ale_linters/ada/gcc.vim b/sources_non_forked/ale/ale_linters/ada/gcc.vim
deleted file mode 100644
index 87496b8..0000000
--- a/sources_non_forked/ale/ale_linters/ada/gcc.vim
+++ /dev/null
@@ -1,54 +0,0 @@
-" Author: Martino Pilia <martino.pilia@gmail.com>
-" Description: Lint Ada files with GCC
-
-call ale#Set('ada_gcc_executable', 'gcc')
-
-" -gnatwa: activate most optional warnings
-" -gnatq: try semantic analysis even if syntax errors have been found
-call ale#Set('ada_gcc_options', '-gnatwa -gnatq')
-
-function! ale_linters#ada#gcc#GetCommand(buffer) abort
-    " Build a suitable output file name. The output file is specified because
-    " the .ali file may be created even if no code generation is attempted.
-    " The output file name must match the source file name (except for the
-    " extension), so here we cannot use the null file as output.
-    let l:tmp_dir = fnamemodify(ale#command#CreateDirectory(a:buffer), ':p')
-    let l:out_file = l:tmp_dir . fnamemodify(bufname(a:buffer), ':t:r') . '.o'
-
-    " -gnatc: Check syntax and semantics only (no code generation attempted)
-    return '%e -x ada -c -gnatc'
-    \   . ' -o ' . ale#Escape(l:out_file)
-    \   . ' -I ' . ale#Escape(fnamemodify(bufname(a:buffer), ':p:h'))
-    \   . ale#Pad(ale#Var(a:buffer, 'ada_gcc_options'))
-    \   . ' %t'
-endfunction
-
-" For the message format please refer to:
-"   https://gcc.gnu.org/onlinedocs/gnat_ugn/Output-and-Error-Message-Control.html
-"   https://gcc.gnu.org/onlinedocs/gnat_ugn/Warning-Message-Control.html
-function! ale_linters#ada#gcc#Handle(buffer, lines) abort
-    " Error format: <filename>:<lnum>:<col>: <text>
-    " Warning format: <filename>:<lnum>:<col>: warning: <text>
-    let l:re = '\v(.+):([0-9]+):([0-9]+):\s+(warning:)?\s*(.+)\s*'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:re)
-        call add(l:output, {
-        \   'bufnr': a:buffer,
-        \   'lnum': str2nr(l:match[2]),
-        \   'col': str2nr(l:match[3]),
-        \   'type': l:match[4] is# 'warning:' ? 'W' : 'E',
-        \   'text': l:match[5],
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('ada', {
-\   'name': 'gcc',
-\   'output_stream': 'stderr',
-\   'executable': {b -> ale#Var(b, 'ada_gcc_executable')},
-\   'command': function('ale_linters#ada#gcc#GetCommand'),
-\   'callback': 'ale_linters#ada#gcc#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/ansible/ansible_lint.vim b/sources_non_forked/ale/ale_linters/ansible/ansible_lint.vim
deleted file mode 100644
index c4affa3..0000000
--- a/sources_non_forked/ale/ale_linters/ansible/ansible_lint.vim
+++ /dev/null
@@ -1,56 +0,0 @@
-" Author: Bjorn Neergaard <bjorn@neersighted.com>
-" Description: ansible-lint for ansible-yaml files
-
-call ale#Set('ansible_ansible_lint_executable', 'ansible-lint')
-
-function! ale_linters#ansible#ansible_lint#GetExecutable(buffer) abort
-    return ale#Var(a:buffer, 'ansible_ansible_lint_executable')
-endfunction
-
-function! ale_linters#ansible#ansible_lint#Handle(buffer, lines) abort
-    for l:line in a:lines[:10]
-        if match(l:line, '^Traceback') >= 0
-            return [{
-            \   'lnum': 1,
-            \   'text': 'An exception was thrown. See :ALEDetail',
-            \   'detail': join(a:lines, "\n"),
-            \}]
-        endif
-    endfor
-
-    " Matches patterns line the following:
-    "
-    " test.yml:35: [EANSIBLE0002] Trailing whitespace
-    let l:pattern = '\v^([a-zA-Z]?:?[^:]+):(\d+):?(\d+)?: \[?([[:alnum:]]+)\]? (.*)$'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        let l:code = l:match[4]
-
-        if l:code is# 'EANSIBLE0002'
-        \&& !ale#Var(a:buffer, 'warn_about_trailing_whitespace')
-            " Skip warnings for trailing whitespace if the option is off.
-            continue
-        endif
-
-        if ale#path#IsBufferPath(a:buffer, l:match[1])
-            call add(l:output, {
-            \   'lnum': l:match[2] + 0,
-            \   'col': l:match[3] + 0,
-            \   'text': l:match[5],
-            \   'code': l:code,
-            \   'type': l:code[:0] is# 'E' ? 'E' : 'W',
-            \})
-        endif
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('ansible', {
-\   'name': 'ansible_lint',
-\   'aliases': ['ansible', 'ansible-lint'],
-\   'executable': function('ale_linters#ansible#ansible_lint#GetExecutable'),
-\   'command': '%e -p %t',
-\   'callback': 'ale_linters#ansible#ansible_lint#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/apiblueprint/drafter.vim b/sources_non_forked/ale/ale_linters/apiblueprint/drafter.vim
deleted file mode 100644
index 5d40c53..0000000
--- a/sources_non_forked/ale/ale_linters/apiblueprint/drafter.vim
+++ /dev/null
@@ -1,38 +0,0 @@
-" Author: nametake https://nametake.github.io
-" Description: apiblueprint parser
-
-function! ale_linters#apiblueprint#drafter#HandleErrors(buffer, lines) abort
-    " Matches patterns line the following:
-    "
-    " warning: (3)  unable to parse response signature, expected 'response [<HTTP status code>] [(<media type>)]'; line 4, column 3k - line 4, column 22
-    " warning: (10)  message-body asset is expected to be a pre-formatted code block, separate it by a newline and indent every of its line by 12 spaces or 3 tabs; line 30, column 5 - line 30, column 9; line 31, column 9 - line 31, column 14; line 32, column 9 - line 32, column 14
-    let l:pattern = '\(^.*\): (\d\+)  \(.\{-\}\); line \(\d\+\), column \(\d\+\) - line \d\+, column \d\+\(.*; line \d\+, column \d\+ - line \(\d\+\), column \(\d\+\)\)\{-\}$'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines[2:], l:pattern)
-        let l:item = {
-        \   'type': l:match[1] is# 'warning' ? 'W' : 'E',
-        \   'text': l:match[2],
-        \   'lnum': l:match[3] + 0,
-        \   'col': l:match[4] + 0,
-        \}
-
-        if l:match[5] isnot# ''
-            let l:item.end_lnum = l:match[6] + 0
-            let l:item.end_col = l:match[7] + 0
-        endif
-
-        call add(l:output, l:item)
-    endfor
-
-    return l:output
-endfunction
-
-
-call ale#linter#Define('apiblueprint', {
-\   'name': 'drafter',
-\   'output_stream': 'stderr',
-\   'executable': 'drafter',
-\   'command': 'drafter --use-line-num --validate',
-\   'callback': 'ale_linters#apiblueprint#drafter#HandleErrors',
-\})
diff --git a/sources_non_forked/ale/ale_linters/asciidoc/alex.vim b/sources_non_forked/ale/ale_linters/asciidoc/alex.vim
deleted file mode 100644
index 97976b2..0000000
--- a/sources_non_forked/ale/ale_linters/asciidoc/alex.vim
+++ /dev/null
@@ -1,4 +0,0 @@
-" Author: Johannes Wienke <languitar@semipol.de>
-" Description: alex for asciidoc files
-
-call ale#handlers#alex#DefineLinter('asciidoc', '--text')
diff --git a/sources_non_forked/ale/ale_linters/asciidoc/proselint.vim b/sources_non_forked/ale/ale_linters/asciidoc/proselint.vim
deleted file mode 100644
index b636c06..0000000
--- a/sources_non_forked/ale/ale_linters/asciidoc/proselint.vim
+++ /dev/null
@@ -1,9 +0,0 @@
-" Author: Daniel M. Capella https://github.com/polyzen
-" Description: proselint for AsciiDoc files
-
-call ale#linter#Define('asciidoc', {
-\   'name': 'proselint',
-\   'executable': 'proselint',
-\   'command': 'proselint %t',
-\   'callback': 'ale#handlers#unix#HandleAsWarning',
-\})
diff --git a/sources_non_forked/ale/ale_linters/asciidoc/redpen.vim b/sources_non_forked/ale/ale_linters/asciidoc/redpen.vim
deleted file mode 100644
index 819e385..0000000
--- a/sources_non_forked/ale/ale_linters/asciidoc/redpen.vim
+++ /dev/null
@@ -1,9 +0,0 @@
-" Author: rhysd https://rhysd.github.io
-" Description: Redpen, a proofreading tool (http://redpen.cc)
-
-call ale#linter#Define('asciidoc', {
-\   'name': 'redpen',
-\   'executable': 'redpen',
-\   'command': 'redpen -f asciidoc -r json %t',
-\   'callback': 'ale#handlers#redpen#HandleRedpenOutput',
-\})
diff --git a/sources_non_forked/ale/ale_linters/asciidoc/textlint.vim b/sources_non_forked/ale/ale_linters/asciidoc/textlint.vim
deleted file mode 100644
index 308a3a2..0000000
--- a/sources_non_forked/ale/ale_linters/asciidoc/textlint.vim
+++ /dev/null
@@ -1,9 +0,0 @@
-" Author: TANIGUCHI Masaya <ta2gch@gmail.com>
-" Description: textlint for AsciiDoc files
-
-call ale#linter#Define('asciidoc', {
-\   'name': 'textlint',
-\   'executable': function('ale#handlers#textlint#GetExecutable'),
-\   'command': function('ale#handlers#textlint#GetCommand'),
-\   'callback': 'ale#handlers#textlint#HandleTextlintOutput',
-\})
diff --git a/sources_non_forked/ale/ale_linters/asciidoc/vale.vim b/sources_non_forked/ale/ale_linters/asciidoc/vale.vim
deleted file mode 100644
index b3cf454..0000000
--- a/sources_non_forked/ale/ale_linters/asciidoc/vale.vim
+++ /dev/null
@@ -1,9 +0,0 @@
-" Author: Jeff Kreeftmeijer https://github.com/jeffkreeftmeijer
-" Description: vale for AsciiDoc files
-
-call ale#linter#Define('asciidoc', {
-\   'name': 'vale',
-\   'executable': 'vale',
-\   'command': 'vale --output=line %t',
-\   'callback': 'ale#handlers#unix#HandleAsWarning',
-\})
diff --git a/sources_non_forked/ale/ale_linters/asciidoc/writegood.vim b/sources_non_forked/ale/ale_linters/asciidoc/writegood.vim
deleted file mode 100644
index a29b7e9..0000000
--- a/sources_non_forked/ale/ale_linters/asciidoc/writegood.vim
+++ /dev/null
@@ -1,4 +0,0 @@
-" Author: Sumner Evans <sumner.evans98@gmail.com>
-" Description: write-good for AsciiDoc files
-
-call ale#handlers#writegood#DefineLinter('asciidoc')
diff --git a/sources_non_forked/ale/ale_linters/asm/gcc.vim b/sources_non_forked/ale/ale_linters/asm/gcc.vim
deleted file mode 100644
index eecab6e..0000000
--- a/sources_non_forked/ale/ale_linters/asm/gcc.vim
+++ /dev/null
@@ -1,37 +0,0 @@
-" Author: Lucas Kolstad <lkolstad@uw.edu>
-" Description: gcc linter for asm files
-
-call ale#Set('asm_gcc_executable', 'gcc')
-call ale#Set('asm_gcc_options', '-Wall')
-
-function! ale_linters#asm#gcc#GetCommand(buffer) abort
-    " `-o /dev/null` or `-o null` is needed to catch all errors,
-    " -fsyntax-only doesn't catch everything.
-    return '%e -x assembler'
-    \   . ' -o ' . g:ale#util#nul_file
-    \   . '-iquote ' . ale#Escape(fnamemodify(bufname(a:buffer), ':p:h'))
-    \   . ' ' . ale#Var(a:buffer, 'asm_gcc_options') . ' -'
-endfunction
-
-function! ale_linters#asm#gcc#Handle(buffer, lines) abort
-    let l:pattern = '^.\+:\(\d\+\): \([^:]\+\): \(.\+\)$'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        call add(l:output, {
-        \ 'lnum': l:match[1] + 0,
-        \ 'type': l:match[2] =~? 'error' ? 'E' : 'W',
-        \ 'text': l:match[3],
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('asm', {
-\    'name': 'gcc',
-\    'output_stream': 'stderr',
-\    'executable': {b -> ale#Var(b, 'asm_gcc_executable')},
-\    'command': function('ale_linters#asm#gcc#GetCommand'),
-\    'callback': 'ale_linters#asm#gcc#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/awk/gawk.vim b/sources_non_forked/ale/ale_linters/awk/gawk.vim
deleted file mode 100644
index f795c57..0000000
--- a/sources_non_forked/ale/ale_linters/awk/gawk.vim
+++ /dev/null
@@ -1,22 +0,0 @@
-" Author: kmarc <korondi.mark@gmail.com>
-" Description: This file adds support for using GNU awk with sripts.
-
-call ale#Set('awk_gawk_executable', 'gawk')
-call ale#Set('awk_gawk_options', '')
-
-function! ale_linters#awk#gawk#GetCommand(buffer) abort
-    " note the --source 'BEGIN ...' is to prevent
-    " gawk from attempting to execute the body of the script
-    " it is linting.
-    return '%e --source ' . ale#Escape('BEGIN { exit } END { exit 1 }')
-    \   .  ale#Pad(ale#Var(a:buffer, 'awk_gawk_options'))
-    \   . ' -f %t --lint /dev/null'
-endfunction
-
-call ale#linter#Define('awk', {
-\   'name': 'gawk',
-\   'executable': {b -> ale#Var(b, 'awk_gawk_executable')},
-\   'command': function('ale_linters#awk#gawk#GetCommand'),
-\   'callback': 'ale#handlers#gawk#HandleGawkFormat',
-\   'output_stream': 'both'
-\})
diff --git a/sources_non_forked/ale/ale_linters/bats/shellcheck.vim b/sources_non_forked/ale/ale_linters/bats/shellcheck.vim
deleted file mode 100644
index 5c2a0ea..0000000
--- a/sources_non_forked/ale/ale_linters/bats/shellcheck.vim
+++ /dev/null
@@ -1,4 +0,0 @@
-" Author: Ian2020 <https://github.com/Ian2020>
-" Description: shellcheck linter for bats scripts.
-
-call ale#handlers#shellcheck#DefineLinter('bats')
diff --git a/sources_non_forked/ale/ale_linters/bib/bibclean.vim b/sources_non_forked/ale/ale_linters/bib/bibclean.vim
deleted file mode 100644
index 9056a9c..0000000
--- a/sources_non_forked/ale/ale_linters/bib/bibclean.vim
+++ /dev/null
@@ -1,75 +0,0 @@
-" Author: Horacio Sanson - https://github.com/hsanson
-" Description: Support for bibclean linter for BibTeX files.
-
-call ale#Set('bib_bibclean_executable', 'bibclean')
-
-function! ale_linters#bib#bibclean#GetCommand(buffer) abort
-    let l:executable = ale#Var(a:buffer, 'bib_bibclean_executable')
-
-    return ale#Escape(l:executable) . ' -file-position '
-endfunction
-
-function! ale_linters#bib#bibclean#get_type(str) abort
-    if a:str is# '??'
-        return 'E'
-    else
-        return 'W'
-    endif
-endfunction
-
-function! ale_linters#bib#bibclean#match_msg(line) abort
-    return matchlist(a:line, '^\(.*\) "stdin", line \(.*\): \(.*\)$')
-endfunction
-
-function! ale_linters#bib#bibclean#match_entry(line) abort
-    return matchlist(a:line, 'Entry   input byte=.* line=\(.*\) column=\(.*\) output .*$')
-endfunction
-
-function! ale_linters#bib#bibclean#match_value(line) abort
-    return matchlist(a:line, 'Value   input byte=.* line=\(.*\) column=\(.*\) output .*$')
-endfunction
-
-function! ale_linters#bib#bibclean#Handle(buffer, lines) abort
-    let l:output = []
-
-    let l:type = 'E'
-    let l:msg  = ''
-
-    for l:line in a:lines
-        if empty(l:msg)
-            let l:mlist = ale_linters#bib#bibclean#match_msg(l:line)
-
-            if !empty(l:mlist)
-                let l:msg = l:mlist[3]
-                let l:type = ale_linters#bib#bibclean#get_type(l:mlist[1])
-            endif
-        else
-            if l:type is# 'E'
-                let l:mlist = ale_linters#bib#bibclean#match_entry(l:line)
-            else
-                let l:mlist = ale_linters#bib#bibclean#match_value(l:line)
-            endif
-
-            if !empty(l:mlist)
-                call add(l:output, {
-                \ 'lnum': l:mlist[1],
-                \ 'col': l:mlist[2],
-                \ 'text': l:msg,
-                \ 'type': l:type
-                \})
-
-                let l:msg = ''
-            endif
-        endif
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('bib', {
-\   'name': 'bibclean',
-\   'executable': {b -> ale#Var(b, 'bib_bibclean_executable')},
-\   'command': function('ale_linters#bib#bibclean#GetCommand'),
-\   'output_stream': 'stderr',
-\   'callback': 'ale_linters#bib#bibclean#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/c/ccls.vim b/sources_non_forked/ale/ale_linters/c/ccls.vim
deleted file mode 100644
index 9e3dafe..0000000
--- a/sources_non_forked/ale/ale_linters/c/ccls.vim
+++ /dev/null
@@ -1,14 +0,0 @@
-" Author: Ye Jingchen <ye.jingchen@gmail.com>, Ben Falconer <ben@falconers.me.uk>, jtalowell <jtalowell@protonmail.com>
-" Description: A language server for C
-
-call ale#Set('c_ccls_executable', 'ccls')
-call ale#Set('c_ccls_init_options', {})
-
-call ale#linter#Define('c', {
-\   'name': 'ccls',
-\   'lsp': 'stdio',
-\   'executable': {b -> ale#Var(b, 'c_ccls_executable')},
-\   'command': '%e',
-\   'project_root': function('ale#handlers#ccls#GetProjectRoot'),
-\   'initialization_options': {b -> ale#Var(b, 'c_ccls_init_options')},
-\})
diff --git a/sources_non_forked/ale/ale_linters/c/clang.vim b/sources_non_forked/ale/ale_linters/c/clang.vim
deleted file mode 100644
index 681101f..0000000
--- a/sources_non_forked/ale/ale_linters/c/clang.vim
+++ /dev/null
@@ -1,24 +0,0 @@
-" Author: Masahiro H https://github.com/mshr-h
-" Description: clang linter for c files
-
-call ale#Set('c_clang_executable', 'clang')
-call ale#Set('c_clang_options', '-std=c11 -Wall')
-
-function! ale_linters#c#clang#GetCommand(buffer, output) abort
-    let l:cflags = ale#c#GetCFlags(a:buffer, a:output)
-
-    " -iquote with the directory the file is in makes #include work for
-    "  headers in the same directory.
-    return '%e -S -x c -fsyntax-only'
-    \   . ' -iquote ' . ale#Escape(fnamemodify(bufname(a:buffer), ':p:h'))
-    \   . ale#Pad(l:cflags)
-    \   . ale#Pad(ale#Var(a:buffer, 'c_clang_options')) . ' -'
-endfunction
-
-call ale#linter#Define('c', {
-\   'name': 'clang',
-\   'output_stream': 'stderr',
-\   'executable': {b -> ale#Var(b, 'c_clang_executable')},
-\   'command': {b -> ale#c#RunMakeCommand(b, function('ale_linters#c#clang#GetCommand'))},
-\   'callback': 'ale#handlers#gcc#HandleGCCFormatWithIncludes',
-\})
diff --git a/sources_non_forked/ale/ale_linters/c/clangd.vim b/sources_non_forked/ale/ale_linters/c/clangd.vim
deleted file mode 100644
index c42d449..0000000
--- a/sources_non_forked/ale/ale_linters/c/clangd.vim
+++ /dev/null
@@ -1,22 +0,0 @@
-" Author: Andrey Melentyev <andrey.melentyev@protonmail.com>
-" Description: Clangd language server
-
-call ale#Set('c_clangd_executable', 'clangd')
-call ale#Set('c_clangd_options', '')
-call ale#Set('c_build_dir', '')
-
-function! ale_linters#c#clangd#GetCommand(buffer) abort
-    let l:build_dir = ale#c#GetBuildDirectory(a:buffer)
-
-    return '%e'
-    \    . ale#Pad(ale#Var(a:buffer, 'c_clangd_options'))
-    \    . (!empty(l:build_dir) ? ' -compile-commands-dir=' . ale#Escape(l:build_dir) : '')
-endfunction
-
-call ale#linter#Define('c', {
-\   'name': 'clangd',
-\   'lsp': 'stdio',
-\   'executable': {b -> ale#Var(b, 'c_clangd_executable')},
-\   'command': function('ale_linters#c#clangd#GetCommand'),
-\   'project_root': function('ale#c#FindProjectRoot'),
-\})
diff --git a/sources_non_forked/ale/ale_linters/c/clangtidy.vim b/sources_non_forked/ale/ale_linters/c/clangtidy.vim
deleted file mode 100644
index 553cc23..0000000
--- a/sources_non_forked/ale/ale_linters/c/clangtidy.vim
+++ /dev/null
@@ -1,52 +0,0 @@
-" Author: vdeurzen <tim@kompiler.org>, w0rp <devw0rp@gmail.com>,
-" gagbo <gagbobada@gmail.com>, Andrej Radovic <r.andrej@gmail.com>
-" Description: clang-tidy linter for c files
-
-call ale#Set('c_clangtidy_executable', 'clang-tidy')
-" Set this option to check the checks clang-tidy will apply.
-" The number of checks that can be applied to C files is limited in contrast to
-" C++
-"
-" Consult the check list in clang-tidy's documentation:
-" http://clang.llvm.org/extra/clang-tidy/checks/list.html
-
-call ale#Set('c_clangtidy_checks', [])
-" Set this option to manually set some options for clang-tidy to use as compile
-" flags.
-" This will disable compile_commands.json detection.
-call ale#Set('c_clangtidy_options', '')
-" Set this option to manually set options for clang-tidy directly.
-call ale#Set('c_clangtidy_extra_options', '')
-call ale#Set('c_build_dir', '')
-
-function! ale_linters#c#clangtidy#GetCommand(buffer, output) abort
-    let l:checks = join(ale#Var(a:buffer, 'c_clangtidy_checks'), ',')
-    let l:build_dir = ale#c#GetBuildDirectory(a:buffer)
-    let l:options = ''
-
-    " Get the extra options if we couldn't find a build directory.
-    if empty(l:build_dir)
-        let l:options = ale#Var(a:buffer, 'c_clangtidy_options')
-        let l:cflags = ale#c#GetCFlags(a:buffer, a:output)
-        let l:options .= !empty(l:options) ? ale#Pad(l:cflags) : l:cflags
-    endif
-
-    " Get the options to pass directly to clang-tidy
-    let l:extra_options = ale#Var(a:buffer, 'c_clangtidy_extra_options')
-
-    return '%e'
-    \   . (!empty(l:checks) ? ' -checks=' . ale#Escape(l:checks) : '')
-    \   . (!empty(l:extra_options) ? ' ' . ale#Escape(l:extra_options) : '')
-    \   . ' %s'
-    \   . (!empty(l:build_dir) ? ' -p ' . ale#Escape(l:build_dir) : '')
-    \   . (!empty(l:options) ? ' -- ' . l:options : '')
-endfunction
-
-call ale#linter#Define('c', {
-\   'name': 'clangtidy',
-\   'output_stream': 'stdout',
-\   'executable': {b -> ale#Var(b, 'c_clangtidy_executable')},
-\   'command': {b -> ale#c#RunMakeCommand(b, function('ale_linters#c#clangtidy#GetCommand'))},
-\   'callback': 'ale#handlers#gcc#HandleGCCFormat',
-\   'lint_file': 1,
-\})
diff --git a/sources_non_forked/ale/ale_linters/c/cppcheck.vim b/sources_non_forked/ale/ale_linters/c/cppcheck.vim
deleted file mode 100644
index 309b285..0000000
--- a/sources_non_forked/ale/ale_linters/c/cppcheck.vim
+++ /dev/null
@@ -1,28 +0,0 @@
-" Author: Bart Libert <bart.libert@gmail.com>
-" Description: cppcheck linter for c files
-
-call ale#Set('c_cppcheck_executable', 'cppcheck')
-call ale#Set('c_cppcheck_options', '--enable=style')
-
-function! ale_linters#c#cppcheck#GetCommand(buffer) abort
-    let l:cd_command = ale#handlers#cppcheck#GetCdCommand(a:buffer)
-    let l:compile_commands_option = ale#handlers#cppcheck#GetCompileCommandsOptions(a:buffer)
-    let l:buffer_path_include = empty(l:compile_commands_option)
-    \   ? ale#handlers#cppcheck#GetBufferPathIncludeOptions(a:buffer)
-    \   : ''
-
-    return l:cd_command
-    \   . '%e -q --language=c'
-    \   . ale#Pad(l:compile_commands_option)
-    \   . ale#Pad(ale#Var(a:buffer, 'c_cppcheck_options'))
-    \   . l:buffer_path_include
-    \   . ' %t'
-endfunction
-
-call ale#linter#Define('c', {
-\   'name': 'cppcheck',
-\   'output_stream': 'both',
-\   'executable': {b -> ale#Var(b, 'c_cppcheck_executable')},
-\   'command': function('ale_linters#c#cppcheck#GetCommand'),
-\   'callback': 'ale#handlers#cppcheck#HandleCppCheckFormat',
-\})
diff --git a/sources_non_forked/ale/ale_linters/c/cquery.vim b/sources_non_forked/ale/ale_linters/c/cquery.vim
deleted file mode 100644
index ff0f34a..0000000
--- a/sources_non_forked/ale/ale_linters/c/cquery.vim
+++ /dev/null
@@ -1,30 +0,0 @@
-" Author: Ben Falconer <ben@falconers.me.uk>, jtalowell <jtalowell@protonmail.com>
-" Description: A language server for C
-
-call ale#Set('c_cquery_executable', 'cquery')
-call ale#Set('c_cquery_cache_directory', expand('~/.cache/cquery'))
-
-function! ale_linters#c#cquery#GetProjectRoot(buffer) abort
-    " Try to find cquery configuration files first.
-    let l:config = ale#path#FindNearestFile(a:buffer, '.cquery')
-
-    if !empty(l:config)
-        return fnamemodify(l:config, ':h')
-    endif
-
-    " Fall back on default project root detection.
-    return ale#c#FindProjectRoot(a:buffer)
-endfunction
-
-function! ale_linters#c#cquery#GetInitializationOptions(buffer) abort
-    return {'cacheDirectory': ale#Var(a:buffer, 'c_cquery_cache_directory')}
-endfunction
-
-call ale#linter#Define('c', {
-\   'name': 'cquery',
-\   'lsp': 'stdio',
-\   'executable': {b -> ale#Var(b, 'c_cquery_executable')},
-\   'command': '%e',
-\   'project_root': function('ale_linters#c#cquery#GetProjectRoot'),
-\   'initialization_options': function('ale_linters#c#cquery#GetInitializationOptions'),
-\})
diff --git a/sources_non_forked/ale/ale_linters/c/flawfinder.vim b/sources_non_forked/ale/ale_linters/c/flawfinder.vim
deleted file mode 100644
index 53c3671..0000000
--- a/sources_non_forked/ale/ale_linters/c/flawfinder.vim
+++ /dev/null
@@ -1,25 +0,0 @@
-" Author: Christian Gibbons <cgibbons@gmu.edu>
-" Description: flawfinder linter for c files
-
-call ale#Set('c_flawfinder_executable', 'flawfinder')
-call ale#Set('c_flawfinder_options', '')
-call ale#Set('c_flawfinder_minlevel', 1)
-call ale#Set('c_flawfinder_error_severity', 6)
-
-function! ale_linters#c#flawfinder#GetCommand(buffer) abort
-    " Set the minimum vulnerability level for flawfinder to bother with
-    let l:minlevel = ' --minlevel=' . ale#Var(a:buffer, 'c_flawfinder_minlevel')
-
-    return '%e -CDQS'
-    \  . ale#Pad(ale#Var(a:buffer, 'c_flawfinder_options'))
-    \  . l:minlevel
-    \  . ' %t'
-endfunction
-
-call ale#linter#Define('c', {
-\  'name': 'flawfinder',
-\  'output_stream': 'stdout',
-\  'executable': {b -> ale#Var(b, 'c_flawfinder_executable')},
-\  'command': function('ale_linters#c#flawfinder#GetCommand'),
-\  'callback': 'ale#handlers#flawfinder#HandleFlawfinderFormat',
-\})
diff --git a/sources_non_forked/ale/ale_linters/c/gcc.vim b/sources_non_forked/ale/ale_linters/c/gcc.vim
deleted file mode 100644
index 1df1018..0000000
--- a/sources_non_forked/ale/ale_linters/c/gcc.vim
+++ /dev/null
@@ -1,28 +0,0 @@
-" Author: w0rp <devw0rp@gmail.com>
-" Description: gcc linter for c files
-
-call ale#Set('c_gcc_executable', 'gcc')
-call ale#Set('c_gcc_options', '-std=c11 -Wall')
-
-function! ale_linters#c#gcc#GetCommand(buffer, output) abort
-    let l:cflags = ale#c#GetCFlags(a:buffer, a:output)
-
-    " -iquote with the directory the file is in makes #include work for
-    "  headers in the same directory.
-    "
-    " `-o /dev/null` or `-o null` is needed to catch all errors,
-    " -fsyntax-only doesn't catch everything.
-    return '%e -S -x c'
-    \   . ' -o ' . g:ale#util#nul_file
-    \   . ' -iquote ' . ale#Escape(fnamemodify(bufname(a:buffer), ':p:h'))
-    \   . ale#Pad(l:cflags)
-    \   . ale#Pad(ale#Var(a:buffer, 'c_gcc_options')) . ' -'
-endfunction
-
-call ale#linter#Define('c', {
-\   'name': 'gcc',
-\   'output_stream': 'stderr',
-\   'executable': {b -> ale#Var(b, 'c_gcc_executable')},
-\   'command': {b -> ale#c#RunMakeCommand(b, function('ale_linters#c#gcc#GetCommand'))},
-\   'callback': 'ale#handlers#gcc#HandleGCCFormatWithIncludes',
-\})
diff --git a/sources_non_forked/ale/ale_linters/chef/cookstyle.vim b/sources_non_forked/ale/ale_linters/chef/cookstyle.vim
deleted file mode 100644
index 50bae2a..0000000
--- a/sources_non_forked/ale/ale_linters/chef/cookstyle.vim
+++ /dev/null
@@ -1,54 +0,0 @@
-" Author: Raphael Hoegger - https://github.com/pfuender
-" Description: Cookstyle (RuboCop based), a code style analyzer for Ruby files
-
-call ale#Set('chef_cookstyle_executable', 'cookstyle')
-call ale#Set('chef_cookstyle_options', '')
-
-function! ale_linters#chef#cookstyle#GetCommand(buffer) abort
-    let l:options = ale#Var(a:buffer, 'chef_cookstyle_options')
-
-    return '%e' . ale#Pad(escape(l:options, '~')) . ' --force-exclusion --format json --stdin ' . ' %s'
-endfunction
-
-function! ale_linters#chef#cookstyle#Handle(buffer, lines) abort
-    if len(a:lines) == 0
-        return []
-    endif
-
-    let l:errors = ale#util#FuzzyJSONDecode(a:lines[0], {})
-
-    if !has_key(l:errors, 'summary')
-    \|| l:errors['summary']['offense_count'] == 0
-    \|| empty(l:errors['files'])
-        return []
-    endif
-
-    let l:output = []
-
-    for l:error in l:errors['files'][0]['offenses']
-        let l:start_col = str2nr(l:error['location']['start_column'])
-        let l:end_col = str2nr(l:error['location']['last_column'])
-
-        if !l:end_col
-            let l:end_col = l:start_col + 1
-        endif
-
-        call add(l:output, {
-        \   'lnum': str2nr(l:error['location']['line']),
-        \   'col': l:start_col,
-        \   'end_col': l:end_col,
-        \   'code': l:error['cop_name'],
-        \   'text': l:error['message'],
-        \   'type': l:error['severity'] is? 'convention' ? 'W' : 'E',
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('chef', {
-\   'name': 'cookstyle',
-\   'executable': {b -> ale#Var(b, 'chef_cookstyle_executable')},
-\   'command': function('ale_linters#chef#cookstyle#GetCommand'),
-\   'callback': 'ale_linters#chef#cookstyle#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/chef/foodcritic.vim b/sources_non_forked/ale/ale_linters/chef/foodcritic.vim
deleted file mode 100644
index 48beba7..0000000
--- a/sources_non_forked/ale/ale_linters/chef/foodcritic.vim
+++ /dev/null
@@ -1,41 +0,0 @@
-" Author: Edward Larkey <edwlarkey@mac.com>
-" Author: Jose Junior <jose.junior@gmail.com>
-" Author: w0rp <devw0rp@gmail.com>
-" Description: This file adds the foodcritic linter for Chef files.
-
-call ale#Set('chef_foodcritic_executable', 'foodcritic')
-call ale#Set('chef_foodcritic_options', '')
-
-function! ale_linters#chef#foodcritic#GetCommand(buffer) abort
-    let l:options = ale#Var(a:buffer, 'chef_foodcritic_options')
-
-    return '%e' . ale#Pad(escape(l:options, '~')) . ' %s'
-endfunction
-
-function! ale_linters#chef#foodcritic#Handle(buffer, lines) abort
-    " Matches patterns line the following:
-    "
-    " FC002: Avoid string interpolation where not required: httpd.rb:13
-    let l:pattern = '\v([^:]+): (.+): ([a-zA-Z]?:?[^:]+):(\d+)$'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        call add(l:output, {
-        \   'code': l:match[1],
-        \   'text': l:match[2],
-        \   'filename': l:match[3],
-        \   'lnum': l:match[4] + 0,
-        \   'type': 'W',
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('chef', {
-\   'name': 'foodcritic',
-\   'executable': {b -> ale#Var(b, 'chef_foodcritic_executable')},
-\   'command': function('ale_linters#chef#foodcritic#GetCommand'),
-\   'callback': 'ale_linters#chef#foodcritic#Handle',
-\   'lint_file': 1,
-\})
diff --git a/sources_non_forked/ale/ale_linters/clojure/clj_kondo.vim b/sources_non_forked/ale/ale_linters/clojure/clj_kondo.vim
deleted file mode 100644
index eb60ce7..0000000
--- a/sources_non_forked/ale/ale_linters/clojure/clj_kondo.vim
+++ /dev/null
@@ -1,34 +0,0 @@
-" Author: Masashi Iizuka <liquidz.uo@gmail.com>
-" Description: linter for clojure using clj-kondo https://github.com/borkdude/clj-kondo
-
-function! ale_linters#clojure#clj_kondo#HandleCljKondoFormat(buffer, lines) abort
-    " output format
-    " <filename>:<line>:<column>: <issue type>: <message>
-    let l:pattern = '\v^[a-zA-Z]?:?[^:]+:(\d+):(\d+):? ((Exception|error|warning): ?(.+))$'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        let l:type = 'E'
-
-        if l:match[4] is? 'warning'
-            let l:type = 'W'
-        endif
-
-        call add(l:output, {
-        \   'lnum': l:match[1] + 0,
-        \   'col': l:match[2] + 0,
-        \   'text': l:match[3],
-        \   'type': l:type,
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('clojure', {
-\   'name': 'clj-kondo',
-\   'output_stream': 'stdout',
-\   'executable': 'clj-kondo',
-\   'command': 'clj-kondo --cache --lint %t',
-\   'callback': 'ale_linters#clojure#clj_kondo#HandleCljKondoFormat',
-\})
diff --git a/sources_non_forked/ale/ale_linters/clojure/joker.vim b/sources_non_forked/ale/ale_linters/clojure/joker.vim
deleted file mode 100644
index 1f17cd3..0000000
--- a/sources_non_forked/ale/ale_linters/clojure/joker.vim
+++ /dev/null
@@ -1,34 +0,0 @@
-" Author: Nic West <nicwest@mailbox.org>
-" Description: linter for clojure using joker https://github.com/candid82/joker
-
-function! ale_linters#clojure#joker#HandleJokerFormat(buffer, lines) abort
-    " output format
-    " <filename>:<line>:<column>: <issue type>: <message>
-    let l:pattern = '\v^[a-zA-Z]?:?[^:]+:(\d+):(\d+):? ((Read error|Parse error|Parse warning|Exception): ?(.+))$'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        let l:type = 'E'
-
-        if l:match[4] is? 'Parse warning'
-            let l:type = 'W'
-        endif
-
-        call add(l:output, {
-        \   'lnum': l:match[1] + 0,
-        \   'col': l:match[2] + 0,
-        \   'text': l:match[3],
-        \   'type': l:type,
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('clojure', {
-\   'name': 'joker',
-\   'output_stream': 'stderr',
-\   'executable': 'joker',
-\   'command': 'joker --working-dir %s --lint %t',
-\   'callback': 'ale_linters#clojure#joker#HandleJokerFormat',
-\})
diff --git a/sources_non_forked/ale/ale_linters/cloudformation/cfn_python_lint.vim b/sources_non_forked/ale/ale_linters/cloudformation/cfn_python_lint.vim
deleted file mode 100644
index d0ac7b2..0000000
--- a/sources_non_forked/ale/ale_linters/cloudformation/cfn_python_lint.vim
+++ /dev/null
@@ -1,35 +0,0 @@
-" Author: Yasuhiro Kiyota <yasuhiroki.duck@gmail.com>
-" Description: Support cfn-python-lint for AWS Cloudformation template file
-
-function! ale_linters#cloudformation#cfn_python_lint#Handle(buffer, lines) abort
-    " Matches patterns line the following:
-    "
-    " sample.template.yaml:96:7:96:15:E3012:Property Resources/Sample/Properties/FromPort should be of type Integer
-    let l:pattern = '\v^(.*):(\d+):(\d+):(\d+):(\d+):([[:alnum:]]+):(.*)$'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        let l:code = l:match[6]
-
-        if ale#path#IsBufferPath(a:buffer, l:match[1])
-            call add(l:output, {
-            \   'lnum': l:match[2],
-            \   'col': l:match[3],
-            \   'end_lnum': l:match[4],
-            \   'end_col': l:match[5],
-            \   'code': l:code,
-            \   'type': l:code[:0] is# 'E' ? 'E' : 'W',
-            \   'text': l:match[7]
-            \})
-        endif
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('cloudformation', {
-\   'name': 'cloudformation',
-\   'executable': 'cfn-lint',
-\   'command': 'cfn-lint --template %t --format parseable',
-\   'callback': 'ale_linters#cloudformation#cfn_python_lint#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/cmake/cmakelint.vim b/sources_non_forked/ale/ale_linters/cmake/cmakelint.vim
deleted file mode 100644
index d955a26..0000000
--- a/sources_non_forked/ale/ale_linters/cmake/cmakelint.vim
+++ /dev/null
@@ -1,24 +0,0 @@
-" Author: Kenneth Benzie <k.benzie83@gmail.com>
-" Description: cmakelint for cmake files
-
-let g:ale_cmake_cmakelint_executable =
-\   get(g:, 'ale_cmake_cmakelint_executable', 'cmakelint')
-
-let g:ale_cmake_cmakelint_options =
-\   get(g:, 'ale_cmake_cmakelint_options', '')
-
-function! ale_linters#cmake#cmakelint#Executable(buffer) abort
-    return ale#Var(a:buffer, 'cmake_cmakelint_executable')
-endfunction
-
-function! ale_linters#cmake#cmakelint#Command(buffer) abort
-    return ale_linters#cmake#cmakelint#Executable(a:buffer)
-    \   . ' ' . ale#Var(a:buffer, 'cmake_cmakelint_options') . ' %t'
-endfunction
-
-call ale#linter#Define('cmake', {
-\   'name': 'cmakelint',
-\   'executable': function('ale_linters#cmake#cmakelint#Executable'),
-\   'command': function('ale_linters#cmake#cmakelint#Command'),
-\   'callback': 'ale#handlers#unix#HandleAsWarning',
-\})
diff --git a/sources_non_forked/ale/ale_linters/coffee/coffee.vim b/sources_non_forked/ale/ale_linters/coffee/coffee.vim
deleted file mode 100644
index 8e89163..0000000
--- a/sources_non_forked/ale/ale_linters/coffee/coffee.vim
+++ /dev/null
@@ -1,23 +0,0 @@
-" Author: KabbAmine - https://github.com/KabbAmine
-" Description: Coffee for checking coffee files
-
-function! ale_linters#coffee#coffee#GetExecutable(buffer) abort
-    return ale#path#ResolveLocalPath(
-    \   a:buffer,
-    \   'node_modules/.bin/coffee',
-    \   'coffee'
-    \)
-endfunction
-
-function! ale_linters#coffee#coffee#GetCommand(buffer) abort
-    return ale_linters#coffee#coffee#GetExecutable(a:buffer)
-    \   . ' -cp -s'
-endfunction
-
-call ale#linter#Define('coffee', {
-\   'name': 'coffee',
-\   'executable': function('ale_linters#coffee#coffee#GetExecutable'),
-\   'command': function('ale_linters#coffee#coffee#GetCommand'),
-\   'output_stream': 'stderr',
-\   'callback': 'ale#handlers#gcc#HandleGCCFormat',
-\})
diff --git a/sources_non_forked/ale/ale_linters/coffee/coffeelint.vim b/sources_non_forked/ale/ale_linters/coffee/coffeelint.vim
deleted file mode 100644
index b7c85fa..0000000
--- a/sources_non_forked/ale/ale_linters/coffee/coffeelint.vim
+++ /dev/null
@@ -1,43 +0,0 @@
-" Author: Prashanth Chandra https://github.com/prashcr
-" Description: coffeelint linter for coffeescript files
-
-function! ale_linters#coffee#coffeelint#GetExecutable(buffer) abort
-    return ale#path#ResolveLocalPath(
-    \   a:buffer,
-    \   'node_modules/.bin/coffeelint',
-    \   'coffeelint'
-    \)
-endfunction
-
-function! ale_linters#coffee#coffeelint#GetCommand(buffer) abort
-    return ale_linters#coffee#coffeelint#GetExecutable(a:buffer)
-    \   . ' --stdin --reporter csv'
-endfunction
-
-function! ale_linters#coffee#coffeelint#Handle(buffer, lines) abort
-    " Matches patterns like the following:
-    "
-    " path,lineNumber,lineNumberEnd,level,message
-    " stdin,14,,error,Throwing strings is forbidden
-    "
-    " Note that we currently ignore lineNumberEnd for multiline errors
-    let l:pattern = 'stdin,\(\d\+\),\(\d*\),\(.\{-1,}\),\(.\+\)'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        call add(l:output, {
-        \   'lnum': str2nr(l:match[1]),
-        \   'type': l:match[3] is# 'error' ? 'E' : 'W',
-        \   'text': l:match[4],
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('coffee', {
-\   'name': 'coffeelint',
-\   'executable': function('ale_linters#coffee#coffeelint#GetExecutable'),
-\   'command': function('ale_linters#coffee#coffeelint#GetCommand'),
-\   'callback': 'ale_linters#coffee#coffeelint#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/cpp/ccls.vim b/sources_non_forked/ale/ale_linters/cpp/ccls.vim
deleted file mode 100644
index b265ff7..0000000
--- a/sources_non_forked/ale/ale_linters/cpp/ccls.vim
+++ /dev/null
@@ -1,14 +0,0 @@
-" Author: Ye Jingchen <ye.jingchen@gmail.com>, Ben Falconer <ben@falconers.me.uk>, jtalowell <jtalowell@protonmail.com>
-" Description: A language server for C++
-
-call ale#Set('cpp_ccls_executable', 'ccls')
-call ale#Set('cpp_ccls_init_options', {})
-
-call ale#linter#Define('cpp', {
-\   'name': 'ccls',
-\   'lsp': 'stdio',
-\   'executable': {b -> ale#Var(b, 'cpp_ccls_executable')},
-\   'command': '%e',
-\   'project_root': function('ale#handlers#ccls#GetProjectRoot'),
-\   'initialization_options': {b -> ale#Var(b, 'cpp_ccls_init_options')},
-\})
diff --git a/sources_non_forked/ale/ale_linters/cpp/clang.vim b/sources_non_forked/ale/ale_linters/cpp/clang.vim
deleted file mode 100644
index e48291e..0000000
--- a/sources_non_forked/ale/ale_linters/cpp/clang.vim
+++ /dev/null
@@ -1,24 +0,0 @@
-" Author: Tomota Nakamura <https://github.com/tomotanakamura>
-" Description: clang linter for cpp files
-
-call ale#Set('cpp_clang_executable', 'clang++')
-call ale#Set('cpp_clang_options', '-std=c++14 -Wall')
-
-function! ale_linters#cpp#clang#GetCommand(buffer, output) abort
-    let l:cflags = ale#c#GetCFlags(a:buffer, a:output)
-
-    " -iquote with the directory the file is in makes #include work for
-    "  headers in the same directory.
-    return '%e -S -x c++ -fsyntax-only'
-    \   . ' -iquote ' . ale#Escape(fnamemodify(bufname(a:buffer), ':p:h'))
-    \   . ale#Pad(l:cflags)
-    \   . ale#Pad(ale#Var(a:buffer, 'cpp_clang_options')) . ' -'
-endfunction
-
-call ale#linter#Define('cpp', {
-\   'name': 'clang',
-\   'output_stream': 'stderr',
-\   'executable': {b -> ale#Var(b, 'cpp_clang_executable')},
-\   'command': {b -> ale#c#RunMakeCommand(b, function('ale_linters#cpp#clang#GetCommand'))},
-\   'callback': 'ale#handlers#gcc#HandleGCCFormatWithIncludes',
-\})
diff --git a/sources_non_forked/ale/ale_linters/cpp/clangcheck.vim b/sources_non_forked/ale/ale_linters/cpp/clangcheck.vim
deleted file mode 100644
index 4cb0486..0000000
--- a/sources_non_forked/ale/ale_linters/cpp/clangcheck.vim
+++ /dev/null
@@ -1,35 +0,0 @@
-" Author: gagbo <gagbobada@gmail.com>
-" Description: clang-check linter for cpp files
-
-call ale#Set('cpp_clangcheck_executable', 'clang-check')
-call ale#Set('cpp_clangcheck_options', '')
-call ale#Set('c_build_dir', '')
-
-function! ale_linters#cpp#clangcheck#GetCommand(buffer) abort
-    let l:user_options = ale#Var(a:buffer, 'cpp_clangcheck_options')
-
-    " Try to find compilation database to link automatically
-    let l:build_dir = ale#Var(a:buffer, 'c_build_dir')
-
-    if empty(l:build_dir)
-        let [l:root, l:json_file] = ale#c#FindCompileCommands(a:buffer)
-        let l:build_dir = ale#path#Dirname(l:json_file)
-    endif
-
-    " The extra arguments in the command are used to prevent .plist files from
-    " being generated. These are only added if no build directory can be
-    " detected.
-    return '%e -analyze %s'
-    \   . (empty(l:build_dir) ? ' --extra-arg=-Xclang --extra-arg=-analyzer-output=text --extra-arg=-fno-color-diagnostics': '')
-    \   . ale#Pad(l:user_options)
-    \   . (!empty(l:build_dir) ? ' -p ' . ale#Escape(l:build_dir) : '')
-endfunction
-
-call ale#linter#Define('cpp', {
-\   'name': 'clangcheck',
-\   'output_stream': 'stderr',
-\   'executable': {b -> ale#Var(b, 'cpp_clangcheck_executable')},
-\   'command': function('ale_linters#cpp#clangcheck#GetCommand'),
-\   'callback': 'ale#handlers#gcc#HandleGCCFormat',
-\   'lint_file': 1,
-\})
diff --git a/sources_non_forked/ale/ale_linters/cpp/clangd.vim b/sources_non_forked/ale/ale_linters/cpp/clangd.vim
deleted file mode 100644
index 14f3fe5..0000000
--- a/sources_non_forked/ale/ale_linters/cpp/clangd.vim
+++ /dev/null
@@ -1,22 +0,0 @@
-" Author: Andrey Melentyev <andrey.melentyev@protonmail.com>
-" Description: Clangd language server
-
-call ale#Set('cpp_clangd_executable', 'clangd')
-call ale#Set('cpp_clangd_options', '')
-call ale#Set('c_build_dir', '')
-
-function! ale_linters#cpp#clangd#GetCommand(buffer) abort
-    let l:build_dir = ale#c#GetBuildDirectory(a:buffer)
-
-    return '%e'
-    \    . ale#Pad(ale#Var(a:buffer, 'cpp_clangd_options'))
-    \    . (!empty(l:build_dir) ? ' -compile-commands-dir=' . ale#Escape(l:build_dir) : '')
-endfunction
-
-call ale#linter#Define('cpp', {
-\   'name': 'clangd',
-\   'lsp': 'stdio',
-\   'executable': {b -> ale#Var(b, 'cpp_clangd_executable')},
-\   'command': function('ale_linters#cpp#clangd#GetCommand'),
-\   'project_root': function('ale#c#FindProjectRoot'),
-\})
diff --git a/sources_non_forked/ale/ale_linters/cpp/clangtidy.vim b/sources_non_forked/ale/ale_linters/cpp/clangtidy.vim
deleted file mode 100644
index 191b7b0..0000000
--- a/sources_non_forked/ale/ale_linters/cpp/clangtidy.vim
+++ /dev/null
@@ -1,46 +0,0 @@
-" Author: vdeurzen <tim@kompiler.org>, w0rp <devw0rp@gmail.com>,
-" gagbo <gagbobada@gmail.com>
-" Description: clang-tidy linter for cpp files
-
-call ale#Set('cpp_clangtidy_executable', 'clang-tidy')
-" Set this option to check the checks clang-tidy will apply.
-call ale#Set('cpp_clangtidy_checks', [])
-" Set this option to manually set some options for clang-tidy to use as compile
-" flags.
-" This will disable compile_commands.json detection.
-call ale#Set('cpp_clangtidy_options', '')
-" Set this option to manually set options for clang-tidy directly.
-call ale#Set('cpp_clangtidy_extra_options', '')
-call ale#Set('c_build_dir', '')
-
-function! ale_linters#cpp#clangtidy#GetCommand(buffer, output) abort
-    let l:checks = join(ale#Var(a:buffer, 'cpp_clangtidy_checks'), ',')
-    let l:build_dir = ale#c#GetBuildDirectory(a:buffer)
-    let l:options = ''
-
-    " Get the extra options if we couldn't find a build directory.
-    if empty(l:build_dir)
-        let l:options = ale#Var(a:buffer, 'cpp_clangtidy_options')
-        let l:cflags = ale#c#GetCFlags(a:buffer, a:output)
-        let l:options .= !empty(l:options) ? ale#Pad(l:cflags) : l:cflags
-    endif
-
-    " Get the options to pass directly to clang-tidy
-    let l:extra_options = ale#Var(a:buffer, 'cpp_clangtidy_extra_options')
-
-    return '%e'
-    \   . (!empty(l:checks) ? ' -checks=' . ale#Escape(l:checks) : '')
-    \   . (!empty(l:extra_options) ? ' ' . ale#Escape(l:extra_options) : '')
-    \   . ' %s'
-    \   . (!empty(l:build_dir) ? ' -p ' . ale#Escape(l:build_dir) : '')
-    \   . (!empty(l:options) ? ' -- ' . l:options : '')
-endfunction
-
-call ale#linter#Define('cpp', {
-\   'name': 'clangtidy',
-\   'output_stream': 'stdout',
-\   'executable': {b -> ale#Var(b, 'cpp_clangtidy_executable')},
-\   'command': {b -> ale#c#RunMakeCommand(b, function('ale_linters#cpp#clangtidy#GetCommand'))},
-\   'callback': 'ale#handlers#gcc#HandleGCCFormat',
-\   'lint_file': 1,
-\})
diff --git a/sources_non_forked/ale/ale_linters/cpp/clazy.vim b/sources_non_forked/ale/ale_linters/cpp/clazy.vim
deleted file mode 100644
index 9b29ac9..0000000
--- a/sources_non_forked/ale/ale_linters/cpp/clazy.vim
+++ /dev/null
@@ -1,32 +0,0 @@
-" Description: clazy linter for cpp files (clang-based and Qt-oriented)
-
-call ale#Set('cpp_clazy_executable', 'clazy-standalone')
-" Set this option to check the checks clazy will apply.
-call ale#Set('cpp_clazy_checks', ['level1'])
-" Set this option to manually set some options for clazy.
-" This will disable compile_commands.json detection.
-call ale#Set('cpp_clazy_options', '')
-call ale#Set('c_build_dir', '')
-
-function! ale_linters#cpp#clazy#GetCommand(buffer) abort
-    let l:checks = join(ale#Var(a:buffer, 'cpp_clazy_checks'), ',')
-    let l:build_dir = ale#c#GetBuildDirectory(a:buffer)
-
-    " Get the extra options if we couldn't find a build directory.
-    let l:options = ale#Var(a:buffer, 'cpp_clazy_options')
-
-    return '%e'
-    \   . (!empty(l:checks) ? ' -checks=' . ale#Escape(l:checks) : '')
-    \   . (!empty(l:build_dir) ? ' -p ' . ale#Escape(l:build_dir) : '')
-    \   . (!empty(l:options) ? ' ' . l:options : '')
-    \   . ' %s'
-endfunction
-
-call ale#linter#Define('cpp', {
-\   'name': 'clazy',
-\   'output_stream': 'stderr',
-\   'executable': {b -> ale#Var(b, 'cpp_clazy_executable')},
-\   'command': function('ale_linters#cpp#clazy#GetCommand'),
-\   'callback': 'ale#handlers#gcc#HandleGCCFormat',
-\   'lint_file': 1,
-\})
diff --git a/sources_non_forked/ale/ale_linters/cpp/cppcheck.vim b/sources_non_forked/ale/ale_linters/cpp/cppcheck.vim
deleted file mode 100644
index 7cd80db..0000000
--- a/sources_non_forked/ale/ale_linters/cpp/cppcheck.vim
+++ /dev/null
@@ -1,28 +0,0 @@
-" Author: Bart Libert <bart.libert@gmail.com>
-" Description: cppcheck linter for cpp files
-
-call ale#Set('cpp_cppcheck_executable', 'cppcheck')
-call ale#Set('cpp_cppcheck_options', '--enable=style')
-
-function! ale_linters#cpp#cppcheck#GetCommand(buffer) abort
-    let l:cd_command = ale#handlers#cppcheck#GetCdCommand(a:buffer)
-    let l:compile_commands_option = ale#handlers#cppcheck#GetCompileCommandsOptions(a:buffer)
-    let l:buffer_path_include = empty(l:compile_commands_option)
-    \   ? ale#handlers#cppcheck#GetBufferPathIncludeOptions(a:buffer)
-    \   : ''
-
-    return l:cd_command
-    \   . '%e -q --language=c++'
-    \   . ale#Pad(l:compile_commands_option)
-    \   . ale#Pad(ale#Var(a:buffer, 'cpp_cppcheck_options'))
-    \   . l:buffer_path_include
-    \   . ' %t'
-endfunction
-
-call ale#linter#Define('cpp', {
-\   'name': 'cppcheck',
-\   'output_stream': 'both',
-\   'executable': {b -> ale#Var(b, 'cpp_cppcheck_executable')},
-\   'command': function('ale_linters#cpp#cppcheck#GetCommand'),
-\   'callback': 'ale#handlers#cppcheck#HandleCppCheckFormat',
-\})
diff --git a/sources_non_forked/ale/ale_linters/cpp/cpplint.vim b/sources_non_forked/ale/ale_linters/cpp/cpplint.vim
deleted file mode 100644
index f1f6ce7..0000000
--- a/sources_non_forked/ale/ale_linters/cpp/cpplint.vim
+++ /dev/null
@@ -1,20 +0,0 @@
-" Author: Dawid Kurek https://github.com/dawikur
-" Description: cpplint for cpp files
-
-call ale#Set('cpp_cpplint_executable', 'cpplint')
-call ale#Set('cpp_cpplint_options', '')
-
-function! ale_linters#cpp#cpplint#GetCommand(buffer) abort
-    let l:options = ale#Var(a:buffer, 'cpp_cpplint_options')
-
-    return '%e' . ale#Pad(l:options) . ' %s'
-endfunction
-
-call ale#linter#Define('cpp', {
-\   'name': 'cpplint',
-\   'output_stream': 'stderr',
-\   'executable': {b -> ale#Var(b, 'cpp_cpplint_executable')},
-\   'command': function('ale_linters#cpp#cpplint#GetCommand'),
-\   'callback': 'ale#handlers#cpplint#HandleCppLintFormat',
-\   'lint_file': 1,
-\})
diff --git a/sources_non_forked/ale/ale_linters/cpp/cquery.vim b/sources_non_forked/ale/ale_linters/cpp/cquery.vim
deleted file mode 100644
index 2971cdc..0000000
--- a/sources_non_forked/ale/ale_linters/cpp/cquery.vim
+++ /dev/null
@@ -1,30 +0,0 @@
-" Author: Ben Falconer <ben@falconers.me.uk>
-" Description: A language server for C++
-
-call ale#Set('cpp_cquery_executable', 'cquery')
-call ale#Set('cpp_cquery_cache_directory', expand('~/.cache/cquery'))
-
-function! ale_linters#cpp#cquery#GetProjectRoot(buffer) abort
-    " Try to find cquery configuration files first.
-    let l:config = ale#path#FindNearestFile(a:buffer, '.cquery')
-
-    if !empty(l:config)
-        return fnamemodify(l:config, ':h')
-    endif
-
-    " Fall back on default project root detection.
-    return ale#c#FindProjectRoot(a:buffer)
-endfunction
-
-function! ale_linters#cpp#cquery#GetInitializationOptions(buffer) abort
-    return {'cacheDirectory': ale#Var(a:buffer, 'cpp_cquery_cache_directory')}
-endfunction
-
-call ale#linter#Define('cpp', {
-\   'name': 'cquery',
-\   'lsp': 'stdio',
-\   'executable': {b -> ale#Var(b, 'cpp_cquery_executable')},
-\   'command': '%e',
-\   'project_root': function('ale_linters#cpp#cquery#GetProjectRoot'),
-\   'initialization_options': function('ale_linters#cpp#cquery#GetInitializationOptions'),
-\})
diff --git a/sources_non_forked/ale/ale_linters/cpp/flawfinder.vim b/sources_non_forked/ale/ale_linters/cpp/flawfinder.vim
deleted file mode 100644
index 5bfdea2..0000000
--- a/sources_non_forked/ale/ale_linters/cpp/flawfinder.vim
+++ /dev/null
@@ -1,25 +0,0 @@
-" Author: Christian Gibbons <cgibbons@gmu.edu>
-" Description: flawfinder linter for c++ files
-
-call ale#Set('cpp_flawfinder_executable', 'flawfinder')
-call ale#Set('cpp_flawfinder_options', '')
-call ale#Set('cpp_flawfinder_minlevel', 1)
-call ale#Set('c_flawfinder_error_severity', 6)
-
-function! ale_linters#cpp#flawfinder#GetCommand(buffer) abort
-    " Set the minimum vulnerability level for flawfinder to bother with
-    let l:minlevel = ' --minlevel=' . ale#Var(a:buffer, 'cpp_flawfinder_minlevel')
-
-    return '%e -CDQS'
-    \  . ale#Var(a:buffer, 'cpp_flawfinder_options')
-    \  . l:minlevel
-    \  . ' %t'
-endfunction
-
-call ale#linter#Define('cpp', {
-\  'name': 'flawfinder',
-\  'output_stream': 'stdout',
-\  'executable': {b -> ale#Var(b, 'cpp_flawfinder_executable')},
-\  'command': function('ale_linters#cpp#flawfinder#GetCommand'),
-\  'callback': 'ale#handlers#flawfinder#HandleFlawfinderFormat',
-\})
diff --git a/sources_non_forked/ale/ale_linters/cpp/gcc.vim b/sources_non_forked/ale/ale_linters/cpp/gcc.vim
deleted file mode 100644
index 108d6d7..0000000
--- a/sources_non_forked/ale/ale_linters/cpp/gcc.vim
+++ /dev/null
@@ -1,29 +0,0 @@
-" Author: geam <mdelage@student.42.fr>
-" Description: gcc linter for cpp files
-"
-call ale#Set('cpp_gcc_executable', 'gcc')
-call ale#Set('cpp_gcc_options', '-std=c++14 -Wall')
-
-function! ale_linters#cpp#gcc#GetCommand(buffer, output) abort
-    let l:cflags = ale#c#GetCFlags(a:buffer, a:output)
-
-    " -iquote with the directory the file is in makes #include work for
-    "  headers in the same directory.
-    "
-    " `-o /dev/null` or `-o null` is needed to catch all errors,
-    " -fsyntax-only doesn't catch everything.
-    return '%e -S -x c++'
-    \   . ' -o ' . g:ale#util#nul_file
-    \   . ' -iquote ' . ale#Escape(fnamemodify(bufname(a:buffer), ':p:h'))
-    \   . ale#Pad(l:cflags)
-    \   . ale#Pad(ale#Var(a:buffer, 'cpp_gcc_options')) . ' -'
-endfunction
-
-call ale#linter#Define('cpp', {
-\   'name': 'gcc',
-\   'aliases': ['g++'],
-\   'output_stream': 'stderr',
-\   'executable': {b -> ale#Var(b, 'cpp_gcc_executable')},
-\   'command': {b -> ale#c#RunMakeCommand(b, function('ale_linters#cpp#gcc#GetCommand'))},
-\   'callback': 'ale#handlers#gcc#HandleGCCFormatWithIncludes',
-\})
diff --git a/sources_non_forked/ale/ale_linters/crystal/ameba.vim b/sources_non_forked/ale/ale_linters/crystal/ameba.vim
deleted file mode 100644
index 5dfc7f4..0000000
--- a/sources_non_forked/ale/ale_linters/crystal/ameba.vim
+++ /dev/null
@@ -1,57 +0,0 @@
-" Author: Harrison Bachrach - https://github.com/HarrisonB
-" Description: Ameba, a linter for crystal files
-
-call ale#Set('crystal_ameba_executable', 'bin/ameba')
-
-function! ale_linters#crystal#ameba#GetCommand(buffer) abort
-    let l:executable = ale#Var(a:buffer, 'crystal_ameba_executable')
-
-    return ale#Escape(l:executable)
-    \   . ' --format json '
-    \   .  ale#Escape(expand('#' . a:buffer . ':p'))
-endfunction
-
-" Handle output from ameba
-function! ale_linters#crystal#ameba#HandleAmebaOutput(buffer, lines) abort
-    if len(a:lines) == 0
-        return []
-    endif
-
-    let l:errors = ale#util#FuzzyJSONDecode(a:lines[0], {})
-
-    if !has_key(l:errors, 'summary')
-    \|| l:errors['summary']['issues_count'] == 0
-    \|| empty(l:errors['sources'])
-        return []
-    endif
-
-    let l:output = []
-
-    for l:error in l:errors['sources'][0]['issues']
-        let l:start_col = str2nr(l:error['location']['column'])
-        let l:end_col = str2nr(l:error['end_location']['column'])
-
-        if !l:end_col
-            let l:end_col = l:start_col + 1
-        endif
-
-        call add(l:output, {
-        \   'lnum': str2nr(l:error['location']['line']),
-        \   'col': l:start_col,
-        \   'end_col': l:end_col,
-        \   'code': l:error['rule_name'],
-        \   'text': l:error['message'],
-        \   'type': 'W',
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('crystal', {
-\   'name': 'ameba',
-\   'executable': {b -> ale#Var(b, 'crystal_ameba_executable')},
-\   'command': function('ale_linters#crystal#ameba#GetCommand'),
-\   'callback': 'ale_linters#crystal#ameba#HandleAmebaOutput',
-\   'lint_file': 1,
-\})
diff --git a/sources_non_forked/ale/ale_linters/crystal/crystal.vim b/sources_non_forked/ale/ale_linters/crystal/crystal.vim
deleted file mode 100644
index 8a905b1..0000000
--- a/sources_non_forked/ale/ale_linters/crystal/crystal.vim
+++ /dev/null
@@ -1,35 +0,0 @@
-" Author: Jordan Andree <https://github.com/jordanandree>, David Alexander <opensource@thelonelyghost.com>
-" Description: This file adds support for checking Crystal with crystal build
-
-function! ale_linters#crystal#crystal#Handle(buffer, lines) abort
-    let l:output = []
-
-    for l:error in ale#util#FuzzyJSONDecode(a:lines, [])
-        if !has_key(l:error, 'file')
-            continue
-        endif
-
-        call add(l:output, {
-        \   'lnum': l:error.line + 0,
-        \   'col': l:error.column + 0,
-        \   'text': l:error.message,
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-function! ale_linters#crystal#crystal#GetCommand(buffer) abort
-    return 'crystal build -f json --no-codegen --no-color -o '
-    \   . ale#Escape(g:ale#util#nul_file)
-    \   . ' %s'
-endfunction
-
-call ale#linter#Define('crystal', {
-\   'name': 'crystal',
-\   'executable': 'crystal',
-\   'output_stream': 'both',
-\   'lint_file': 1,
-\   'command': function('ale_linters#crystal#crystal#GetCommand'),
-\   'callback': 'ale_linters#crystal#crystal#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/cs/csc.vim b/sources_non_forked/ale/ale_linters/cs/csc.vim
deleted file mode 100644
index 308abc7..0000000
--- a/sources_non_forked/ale/ale_linters/cs/csc.vim
+++ /dev/null
@@ -1,95 +0,0 @@
-call ale#Set('cs_csc_options', '')
-call ale#Set('cs_csc_source', '')
-call ale#Set('cs_csc_assembly_path', [])
-call ale#Set('cs_csc_assemblies', [])
-
-function! s:GetWorkingDirectory(buffer) abort
-    let l:working_directory = ale#Var(a:buffer, 'cs_csc_source')
-
-    if !empty(l:working_directory)
-        return l:working_directory
-    endif
-
-    return expand('#' . a:buffer . ':p:h')
-endfunction
-
-function! ale_linters#cs#csc#GetCommand(buffer) abort
-    " Pass assembly paths via the -lib: parameter.
-    let l:path_list = ale#Var(a:buffer, 'cs_csc_assembly_path')
-
-    let l:lib_option = !empty(l:path_list)
-    \   ? '/lib:' . join(map(copy(l:path_list), 'ale#Escape(v:val)'), ',')
-    \   : ''
-
-    " Pass paths to DLL files via the -r: parameter.
-    let l:assembly_list = ale#Var(a:buffer, 'cs_csc_assemblies')
-
-    let l:r_option = !empty(l:assembly_list)
-    \   ? '/r:' . join(map(copy(l:assembly_list), 'ale#Escape(v:val)'), ',')
-    \   : ''
-
-    " register temporary module target file with ale
-    " register temporary module target file with ALE.
-    let l:out = ale#command#CreateFile(a:buffer)
-
-    " The code is compiled as a module and the output is redirected to a
-    " temporary file.
-    return ale#path#CdString(s:GetWorkingDirectory(a:buffer))
-    \    . 'csc /unsafe'
-    \    . ale#Pad(ale#Var(a:buffer, 'cs_csc_options'))
-    \    . ale#Pad(l:lib_option)
-    \    . ale#Pad(l:r_option)
-    \    . ' /out:' . l:out
-    \    . ' /t:module'
-    \    . ' /recurse:' . ale#Escape('*.cs')
-endfunction
-
-function! ale_linters#cs#csc#Handle(buffer, lines) abort
-    " Look for lines like the following.
-    "
-    " Tests.cs(12,29): error CSXXXX: ; expected
-    "
-    " NOTE: pattern also captures file name as linter compiles all
-    " files within the source tree rooted at the specified source
-    " path and not just the file loaded in the buffer
-    let l:patterns = [
-    \    '^\v(.+\.cs)\((\d+),(\d+)\)\:\s+([^ ]+)\s+([cC][sS][^ ]+):\s(.+)$',
-    \    '^\v([^ ]+)\s+([Cc][sS][^ ]+):\s+(.+)$',
-    \]
-    let l:output = []
-
-    let l:dir = s:GetWorkingDirectory(a:buffer)
-
-    for l:match in ale#util#GetMatches(a:lines, l:patterns)
-        if len(l:match) > 6 && strlen(l:match[5]) > 2 && l:match[5][:1] is? 'CS'
-            call add(l:output, {
-            \   'filename': ale#path#GetAbsPath(l:dir, l:match[1]),
-            \   'lnum': l:match[2] + 0,
-            \   'col': l:match[3] + 0,
-            \   'type': l:match[4] is# 'error' ? 'E' : 'W',
-            \   'code': l:match[5],
-            \   'text': l:match[6] ,
-            \})
-        elseif strlen(l:match[2]) > 2 && l:match[2][:1] is? 'CS'
-            call add(l:output, {
-            \   'filename':'<csc>',
-            \   'lnum': -1,
-            \   'col': -1,
-            \   'type': l:match[1] is# 'error' ? 'E' : 'W',
-            \   'code': l:match[2],
-            \   'text': l:match[3],
-            \})
-        endif
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('cs',{
-\   'name': 'csc',
-\   'output_stream': 'stdout',
-\   'executable': 'csc',
-\   'command': function('ale_linters#cs#csc#GetCommand'),
-\   'callback': 'ale_linters#cs#csc#Handle',
-\   'lint_file': 1
-\})
diff --git a/sources_non_forked/ale/ale_linters/cs/mcs.vim b/sources_non_forked/ale/ale_linters/cs/mcs.vim
deleted file mode 100644
index 1b373e7..0000000
--- a/sources_non_forked/ale/ale_linters/cs/mcs.vim
+++ /dev/null
@@ -1,37 +0,0 @@
-let g:ale_cs_mcs_options = get(g:, 'ale_cs_mcs_options', '')
-
-function! ale_linters#cs#mcs#GetCommand(buffer) abort
-    let l:options = ale#Var(a:buffer, 'cs_mcs_options')
-
-    return 'mcs -unsafe --parse'
-    \   . (!empty(l:options) ? ' ' . l:options : '')
-    \   . ' %t'
-endfunction
-
-function! ale_linters#cs#mcs#Handle(buffer, lines) abort
-    " Look for lines like the following.
-    "
-    " Tests.cs(12,29): error CSXXXX: ; expected
-    let l:pattern = '^\v(.+\.cs)\((\d+),(\d+)\)\: ([^ ]+) ([^ ]+): (.+)$'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        call add(l:output, {
-        \   'lnum': l:match[2] + 0,
-        \   'col': l:match[3] + 0,
-        \   'type': l:match[4] is# 'error' ? 'E' : 'W',
-        \   'code': l:match[5],
-        \   'text': l:match[6],
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('cs',{
-\   'name': 'mcs',
-\   'output_stream': 'stderr',
-\   'executable': 'mcs',
-\   'command': function('ale_linters#cs#mcs#GetCommand'),
-\   'callback': 'ale_linters#cs#mcs#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/cs/mcsc.vim b/sources_non_forked/ale/ale_linters/cs/mcsc.vim
deleted file mode 100644
index 0e4e566..0000000
--- a/sources_non_forked/ale/ale_linters/cs/mcsc.vim
+++ /dev/null
@@ -1,95 +0,0 @@
-call ale#Set('cs_mcsc_options', '')
-call ale#Set('cs_mcsc_source', '')
-call ale#Set('cs_mcsc_assembly_path', [])
-call ale#Set('cs_mcsc_assemblies', [])
-
-function! s:GetWorkingDirectory(buffer) abort
-    let l:working_directory = ale#Var(a:buffer, 'cs_mcsc_source')
-
-    if !empty(l:working_directory)
-        return l:working_directory
-    endif
-
-    return expand('#' . a:buffer . ':p:h')
-endfunction
-
-function! ale_linters#cs#mcsc#GetCommand(buffer) abort
-    " Pass assembly paths via the -lib: parameter.
-    let l:path_list = ale#Var(a:buffer, 'cs_mcsc_assembly_path')
-
-    let l:lib_option = !empty(l:path_list)
-    \   ? '-lib:' . join(map(copy(l:path_list), 'ale#Escape(v:val)'), ',')
-    \   : ''
-
-    " Pass paths to DLL files via the -r: parameter.
-    let l:assembly_list = ale#Var(a:buffer, 'cs_mcsc_assemblies')
-
-    let l:r_option = !empty(l:assembly_list)
-    \   ? '-r:' . join(map(copy(l:assembly_list), 'ale#Escape(v:val)'), ',')
-    \   : ''
-
-    " register temporary module target file with ale
-    " register temporary module target file with ALE.
-    let l:out = ale#command#CreateFile(a:buffer)
-
-    " The code is compiled as a module and the output is redirected to a
-    " temporary file.
-    return ale#path#CdString(s:GetWorkingDirectory(a:buffer))
-    \    . 'mcs -unsafe'
-    \    . ale#Pad(ale#Var(a:buffer, 'cs_mcsc_options'))
-    \    . ale#Pad(l:lib_option)
-    \    . ale#Pad(l:r_option)
-    \    . ' -out:' . l:out
-    \    . ' -t:module'
-    \    . ' -recurse:' . ale#Escape('*.cs')
-endfunction
-
-function! ale_linters#cs#mcsc#Handle(buffer, lines) abort
-    " Look for lines like the following.
-    "
-    " Tests.cs(12,29): error CSXXXX: ; expected
-    "
-    " NOTE: pattern also captures file name as linter compiles all
-    " files within the source tree rooted at the specified source
-    " path and not just the file loaded in the buffer
-    let l:patterns = [
-    \    '^\v(.+\.cs)\((\d+),(\d+)\)\:\s+([^ ]+)\s+([cC][sS][^ ]+):\s(.+)$',
-    \    '^\v([^ ]+)\s+([Cc][sS][^ ]+):\s+(.+)$',
-    \]
-    let l:output = []
-
-    let l:dir = s:GetWorkingDirectory(a:buffer)
-
-    for l:match in ale#util#GetMatches(a:lines, l:patterns)
-        if len(l:match) > 6 && strlen(l:match[5]) > 2 && l:match[5][:1] is? 'CS'
-            call add(l:output, {
-            \   'filename': ale#path#GetAbsPath(l:dir, l:match[1]),
-            \   'lnum': l:match[2] + 0,
-            \   'col': l:match[3] + 0,
-            \   'type': l:match[4] is# 'error' ? 'E' : 'W',
-            \   'code': l:match[5],
-            \   'text': l:match[6] ,
-            \})
-        elseif strlen(l:match[2]) > 2 && l:match[2][:1] is? 'CS'
-            call add(l:output, {
-            \   'filename':'<mcs>',
-            \   'lnum': -1,
-            \   'col': -1,
-            \   'type': l:match[1] is# 'error' ? 'E' : 'W',
-            \   'code': l:match[2],
-            \   'text': l:match[3],
-            \})
-        endif
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('cs',{
-\   'name': 'mcsc',
-\   'output_stream': 'stderr',
-\   'executable': 'mcs',
-\   'command': function('ale_linters#cs#mcsc#GetCommand'),
-\   'callback': 'ale_linters#cs#mcsc#Handle',
-\   'lint_file': 1
-\})
diff --git a/sources_non_forked/ale/ale_linters/css/csslint.vim b/sources_non_forked/ale/ale_linters/css/csslint.vim
deleted file mode 100644
index 50c21ce..0000000
--- a/sources_non_forked/ale/ale_linters/css/csslint.vim
+++ /dev/null
@@ -1,18 +0,0 @@
-" Author: w0rp <devw0rp@gmail.com>
-" Description: This file adds support for checking CSS code with csslint.
-
-function! ale_linters#css#csslint#GetCommand(buffer) abort
-    let l:csslintrc = ale#path#FindNearestFile(a:buffer, '.csslintrc')
-    let l:config_option = !empty(l:csslintrc)
-    \   ? '--config=' . ale#Escape(l:csslintrc)
-    \   : ''
-
-    return 'csslint --format=compact ' . l:config_option . ' %t'
-endfunction
-
-call ale#linter#Define('css', {
-\   'name': 'csslint',
-\   'executable': 'csslint',
-\   'command': function('ale_linters#css#csslint#GetCommand'),
-\   'callback': 'ale#handlers#css#HandleCSSLintFormat',
-\})
diff --git a/sources_non_forked/ale/ale_linters/css/fecs.vim b/sources_non_forked/ale/ale_linters/css/fecs.vim
deleted file mode 100644
index 511847c..0000000
--- a/sources_non_forked/ale/ale_linters/css/fecs.vim
+++ /dev/null
@@ -1,9 +0,0 @@
-" Author: harttle <yangjvn@126.com>
-" Description: fecs for CSS files
-
-call ale#linter#Define('css', {
-\   'name': 'fecs',
-\   'executable': function('ale#handlers#fecs#GetExecutable'),
-\   'command': function('ale#handlers#fecs#GetCommand'),
-\   'callback': 'ale#handlers#fecs#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/css/stylelint.vim b/sources_non_forked/ale/ale_linters/css/stylelint.vim
deleted file mode 100644
index 38cb0e0..0000000
--- a/sources_non_forked/ale/ale_linters/css/stylelint.vim
+++ /dev/null
@@ -1,19 +0,0 @@
-" Author: diartyz <diartyz@gmail.com>
-
-call ale#Set('css_stylelint_executable', 'stylelint')
-call ale#Set('css_stylelint_options', '')
-call ale#Set('css_stylelint_use_global', get(g:, 'ale_use_global_executables', 0))
-
-function! ale_linters#css#stylelint#GetCommand(buffer) abort
-    return '%e ' . ale#Pad(ale#Var(a:buffer, 'css_stylelint_options'))
-    \   . ' --stdin-filename %s'
-endfunction
-
-call ale#linter#Define('css', {
-\   'name': 'stylelint',
-\   'executable': {b -> ale#node#FindExecutable(b, 'css_stylelint', [
-\       'node_modules/.bin/stylelint',
-\   ])},
-\   'command': function('ale_linters#css#stylelint#GetCommand'),
-\   'callback': 'ale#handlers#css#HandleStyleLintFormat',
-\})
diff --git a/sources_non_forked/ale/ale_linters/cucumber/cucumber.vim b/sources_non_forked/ale/ale_linters/cucumber/cucumber.vim
deleted file mode 100644
index 0cfd815..0000000
--- a/sources_non_forked/ale/ale_linters/cucumber/cucumber.vim
+++ /dev/null
@@ -1,46 +0,0 @@
-" Author: Eddie Lebow https://github.com/elebow
-" Description: Cucumber, a BDD test tool
-
-function! ale_linters#cucumber#cucumber#GetCommand(buffer) abort
-    let l:features_dir = ale#path#FindNearestDirectory(a:buffer, 'features')
-
-    if !empty(l:features_dir)
-        let l:features_arg = '-r ' . ale#Escape(l:features_dir)
-    else
-        let l:features_arg = ''
-    endif
-
-    return 'cucumber --dry-run --quiet --strict --format=json '
-    \   . l:features_arg . ' %t'
-endfunction
-
-function! ale_linters#cucumber#cucumber#Handle(buffer, lines) abort
-    try
-        let l:json = ale#util#FuzzyJSONDecode(a:lines, {})[0]
-    catch
-        return []
-    endtry
-
-    let l:output = []
-
-    for l:element in get(l:json, 'elements', [])
-        for l:step in l:element['steps']
-            if l:step['result']['status'] is# 'undefined'
-                call add(l:output, {
-                \   'lnum': l:step['line'],
-                \   'code': 'E',
-                \   'text': 'Undefined step'
-                \})
-            endif
-        endfor
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('cucumber', {
-\   'name': 'cucumber',
-\   'executable': 'cucumber',
-\   'command': function('ale_linters#cucumber#cucumber#GetCommand'),
-\   'callback': 'ale_linters#cucumber#cucumber#Handle'
-\})
diff --git a/sources_non_forked/ale/ale_linters/cuda/nvcc.vim b/sources_non_forked/ale/ale_linters/cuda/nvcc.vim
deleted file mode 100644
index f3af07b..0000000
--- a/sources_non_forked/ale/ale_linters/cuda/nvcc.vim
+++ /dev/null
@@ -1,49 +0,0 @@
-" Author: blahgeek <i@blahgeek.com>
-" Description: NVCC linter for cuda files
-
-call ale#Set('cuda_nvcc_executable', 'nvcc')
-call ale#Set('cuda_nvcc_options', '-std=c++11')
-
-function! ale_linters#cuda#nvcc#GetCommand(buffer) abort
-    " Unused: use ale#util#nul_file
-    " let l:output_file = ale#util#Tempname() . '.ii'
-    " call ale#command#ManageFile(a:buffer, l:output_file)
-    return '%e -cuda'
-    \   . ale#Pad(ale#c#IncludeOptions(ale#c#FindLocalHeaderPaths(a:buffer)))
-    \   . ale#Pad(ale#Var(a:buffer, 'cuda_nvcc_options'))
-    \   . ' %s -o ' . g:ale#util#nul_file
-endfunction
-
-function! ale_linters#cuda#nvcc#HandleNVCCFormat(buffer, lines) abort
-    " Look for lines like the following.
-    "
-    " test.cu(8): error: argument of type "void *" is incompatible with parameter of type "int *"
-    let l:pattern = '\v^([^:\(\)]+):?\(?(\d+)\)?:(\d+)?:?\s*\w*\s*(error|warning): (.+)$'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        let l:item = {
-        \   'lnum': str2nr(l:match[2]),
-        \   'type': l:match[4] =~# 'error' ? 'E' : 'W',
-        \   'text': l:match[5],
-        \   'filename': fnamemodify(l:match[1], ':p'),
-        \}
-
-        if !empty(l:match[3])
-            let l:item.col = str2nr(l:match[3])
-        endif
-
-        call add(l:output, l:item)
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('cuda', {
-\   'name': 'nvcc',
-\   'output_stream': 'stderr',
-\   'executable': {b -> ale#Var(b, 'cuda_nvcc_executable')},
-\   'command': function('ale_linters#cuda#nvcc#GetCommand'),
-\   'callback': 'ale_linters#cuda#nvcc#HandleNVCCFormat',
-\   'lint_file': 1,
-\})
diff --git a/sources_non_forked/ale/ale_linters/cypher/cypher_lint.vim b/sources_non_forked/ale/ale_linters/cypher/cypher_lint.vim
deleted file mode 100644
index 408ddd6..0000000
--- a/sources_non_forked/ale/ale_linters/cypher/cypher_lint.vim
+++ /dev/null
@@ -1,26 +0,0 @@
-" Author: Francisco Lopes <francisco@oblita.com>
-" Description: Linting for Neo4j's Cypher
-
-function! ale_linters#cypher#cypher_lint#Handle(buffer, lines) abort
-    let l:pattern = '\v^([a-zA-Z]?:?[^:]+):(\d+):(\d+): (.*)$'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        call add(l:output, {
-        \   'lnum': l:match[2] + 0,
-        \   'col': l:match[3] + 0,
-        \   'text': l:match[4],
-        \   'type': 'E',
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('cypher', {
-\   'name': 'cypher_lint',
-\   'executable': 'cypher-lint',
-\   'command': 'cypher-lint',
-\   'output_stream': 'stderr',
-\   'callback': 'ale_linters#cypher#cypher_lint#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/d/dls.vim b/sources_non_forked/ale/ale_linters/d/dls.vim
deleted file mode 100644
index 78d1c15..0000000
--- a/sources_non_forked/ale/ale_linters/d/dls.vim
+++ /dev/null
@@ -1,22 +0,0 @@
-" Author: aurieh <me@aurieh.me>
-" Description: A Language Server implementation for D
-
-call ale#Set('d_dls_executable', 'dls')
-
-function! ale_linters#d#dls#GetExecutable(buffer) abort
-    return ale#Var(a:buffer, 'd_dls_executable')
-endfunction
-
-function! ale_linters#d#dls#FindProjectRoot(buffer) abort
-    " Note: this will return . if dub config is empty
-    " dls can run outside DUB projects just fine
-    return fnamemodify(ale#d#FindDUBConfig(a:buffer), ':h')
-endfunction
-
-call ale#linter#Define('d', {
-\   'name': 'dls',
-\   'lsp': 'stdio',
-\   'executable': function('ale_linters#d#dls#GetExecutable'),
-\   'command': function('ale_linters#d#dls#GetExecutable'),
-\   'project_root': function('ale_linters#d#dls#FindProjectRoot'),
-\})
diff --git a/sources_non_forked/ale/ale_linters/d/dmd.vim b/sources_non_forked/ale/ale_linters/d/dmd.vim
deleted file mode 100644
index 14461ae..0000000
--- a/sources_non_forked/ale/ale_linters/d/dmd.vim
+++ /dev/null
@@ -1,74 +0,0 @@
-" Author: w0rp <devw0rp@gmail.com>
-" Description: "dmd for D files"
-
-function! ale_linters#d#dmd#GetDUBCommand(buffer) abort
-    " If we can't run dub, then skip this command.
-    if !executable('dub')
-        " Returning an empty string skips to the DMD command.
-        return ''
-    endif
-
-    let l:dub_file = ale#d#FindDUBConfig(a:buffer)
-
-    if empty(l:dub_file)
-        return ''
-    endif
-
-    " To support older dub versions, we just change the directory to
-    " the directory where we found the dub config, and then run `dub describe`
-    " from that directory.
-    return 'cd ' . ale#Escape(fnamemodify(l:dub_file, ':h'))
-    \   . ' && dub describe --import-paths'
-endfunction
-
-function! ale_linters#d#dmd#RunDUBCommand(buffer) abort
-    let l:command = ale_linters#d#dmd#GetDUBCommand(a:buffer)
-
-    if empty(l:command)
-        " If we can't run DUB, just run DMD.
-        return ale_linters#d#dmd#DMDCommand(a:buffer, [], {})
-    endif
-
-    return ale#command#Run(a:buffer, l:command, function('ale_linters#d#dmd#DMDCommand'))
-endfunction
-
-function! ale_linters#d#dmd#DMDCommand(buffer, dub_output, meta) abort
-    let l:import_list = []
-
-    " Build a list of import paths generated from DUB, if available.
-    for l:line in a:dub_output
-        if !empty(l:line)
-            " The arguments must be '-Ifilename', not '-I filename'
-            call add(l:import_list, '-I' . ale#Escape(l:line))
-        endif
-    endfor
-
-    return 'dmd '. join(l:import_list) . ' -o- -wi -vcolumns -c %t'
-endfunction
-
-function! ale_linters#d#dmd#Handle(buffer, lines) abort
-    " Matches patterns lines like the following:
-    " /tmp/tmp.qclsa7qLP7/file.d(1): Error: function declaration without return type. (Note that constructors are always named 'this')
-    " /tmp/tmp.G1L5xIizvB.d(8,8): Error: module weak_reference is in file 'dstruct/weak_reference.d' which cannot be read
-    let l:pattern = '^[^(]\+(\([0-9]\+\)\,\?\([0-9]*\)): \([^:]\+\): \(.\+\)'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        call add(l:output, {
-        \   'lnum': l:match[1],
-        \   'col': l:match[2],
-        \   'type': l:match[3] is# 'Warning' ? 'W' : 'E',
-        \   'text': l:match[4],
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('d', {
-\   'name': 'dmd',
-\   'executable': 'dmd',
-\   'command': function('ale_linters#d#dmd#RunDUBCommand'),
-\   'callback': 'ale_linters#d#dmd#Handle',
-\   'output_stream': 'stderr',
-\})
diff --git a/sources_non_forked/ale/ale_linters/dafny/dafny.vim b/sources_non_forked/ale/ale_linters/dafny/dafny.vim
deleted file mode 100644
index b5b9067..0000000
--- a/sources_non_forked/ale/ale_linters/dafny/dafny.vim
+++ /dev/null
@@ -1,26 +0,0 @@
-" Author: Taylor Blau <me@ttaylorr.com>
-
-function! ale_linters#dafny#dafny#Handle(buffer, lines) abort
-    let l:pattern = '\v(.*)\((\d+),(\d+)\): (.*): (.*)'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        call add(l:output, {
-        \    'bufnr': a:buffer,
-        \    'col': l:match[3] + 0,
-        \    'lnum': l:match[2] + 0,
-        \    'text': l:match[5],
-        \    'type': l:match[4] =~# '^Error' ? 'E' : 'W'
-        \ })
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('dafny', {
-\    'name': 'dafny',
-\    'executable': 'dafny',
-\    'command': 'dafny %s /compile:0',
-\    'callback': 'ale_linters#dafny#dafny#Handle',
-\    'lint_file': 1,
-\ })
diff --git a/sources_non_forked/ale/ale_linters/dart/dartanalyzer.vim b/sources_non_forked/ale/ale_linters/dart/dartanalyzer.vim
deleted file mode 100644
index 0a4d974..0000000
--- a/sources_non_forked/ale/ale_linters/dart/dartanalyzer.vim
+++ /dev/null
@@ -1,36 +0,0 @@
-" Author: w0rp <devw0rp@gmail.com>
-" Description: Check Dart files with dartanalyzer
-
-call ale#Set('dart_dartanalyzer_executable', 'dartanalyzer')
-
-function! ale_linters#dart#dartanalyzer#GetCommand(buffer) abort
-    let l:path = ale#path#FindNearestFile(a:buffer, '.packages')
-
-    return '%e'
-    \   . (!empty(l:path) ? ' --packages ' . ale#Escape(l:path) : '')
-    \   . ' %s'
-endfunction
-
-function! ale_linters#dart#dartanalyzer#Handle(buffer, lines) abort
-    let l:pattern = '\v^  ([a-z]+) . (.+) at (.+):(\d+):(\d+) . (.+)$'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        call add(l:output, {
-        \   'type': l:match[1] is# 'error' ? 'E' : 'W',
-        \   'text': l:match[6] . ': ' . l:match[2],
-        \   'lnum': str2nr(l:match[4]),
-        \   'col': str2nr(l:match[5]),
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('dart', {
-\   'name': 'dartanalyzer',
-\   'executable': {b -> ale#Var(b, 'dart_dartanalyzer_executable')},
-\   'command': function('ale_linters#dart#dartanalyzer#GetCommand'),
-\   'callback': 'ale_linters#dart#dartanalyzer#Handle',
-\   'lint_file': 1,
-\})
diff --git a/sources_non_forked/ale/ale_linters/dart/language_server.vim b/sources_non_forked/ale/ale_linters/dart/language_server.vim
deleted file mode 100644
index d0e639c..0000000
--- a/sources_non_forked/ale/ale_linters/dart/language_server.vim
+++ /dev/null
@@ -1,20 +0,0 @@
-" Author: aurieh <me@aurieh.me>
-" Description: A language server for dart
-
-call ale#Set('dart_language_server_executable', 'dart_language_server')
-
-function! ale_linters#dart#language_server#GetProjectRoot(buffer) abort
-    " Note: pub only looks for pubspec.yaml, there's no point in adding
-    " support for pubspec.yml
-    let l:pubspec = ale#path#FindNearestFile(a:buffer, 'pubspec.yaml')
-
-    return !empty(l:pubspec) ? fnamemodify(l:pubspec, ':h:h') : ''
-endfunction
-
-call ale#linter#Define('dart', {
-\   'name': 'language_server',
-\   'lsp': 'stdio',
-\   'executable': {b -> ale#Var(b, 'dart_language_server_executable')},
-\   'command': '%e',
-\   'project_root': function('ale_linters#dart#language_server#GetProjectRoot'),
-\})
diff --git a/sources_non_forked/ale/ale_linters/dockerfile/dockerfile_lint.vim b/sources_non_forked/ale/ale_linters/dockerfile/dockerfile_lint.vim
deleted file mode 100644
index 0c0ad53..0000000
--- a/sources_non_forked/ale/ale_linters/dockerfile/dockerfile_lint.vim
+++ /dev/null
@@ -1,76 +0,0 @@
-" Author: Alexander Olofsson <alexander.olofsson@liu.se>
-
-call ale#Set('dockerfile_dockerfile_lint_executable', 'dockerfile_lint')
-call ale#Set('dockerfile_dockerfile_lint_options', '')
-
-function! ale_linters#dockerfile#dockerfile_lint#GetType(type) abort
-    if a:type is? 'error'
-        return 'E'
-    elseif a:type is? 'warn'
-        return 'W'
-    endif
-
-    return 'I'
-endfunction
-
-function! ale_linters#dockerfile#dockerfile_lint#Handle(buffer, lines) abort
-    try
-        let l:data = json_decode(join(a:lines, ''))
-    catch
-        return []
-    endtry
-
-    if empty(l:data)
-        " Should never happen, but it's better to be on the safe side
-        return []
-    endif
-
-    let l:messages = []
-
-    for l:type in ['error', 'warn', 'info']
-        for l:object in l:data[l:type]['data']
-            let l:line = get(l:object, 'line', -1)
-            let l:message = l:object['message']
-
-            let l:link = get(l:object, 'reference_url', '')
-
-            if type(l:link) == v:t_list
-                " Somehow, reference_url is returned as two-part list.
-                " Anchor markers in that list are sometimes duplicated.
-                " See https://github.com/projectatomic/dockerfile_lint/issues/134
-                let l:link = join(l:link, '')
-                let l:link = substitute(l:link, '##', '#', '')
-            endif
-
-            let l:detail = l:message
-
-            if get(l:object, 'description', 'None') isnot# 'None'
-                let l:detail .= "\n\n" . l:object['description']
-            endif
-
-            let l:detail .= "\n\n" . l:link
-
-            call add(l:messages, {
-            \   'lnum': l:line,
-            \   'text': l:message,
-            \   'type': ale_linters#dockerfile#dockerfile_lint#GetType(l:type),
-            \   'detail': l:detail,
-            \})
-        endfor
-    endfor
-
-    return l:messages
-endfunction
-
-function! ale_linters#dockerfile#dockerfile_lint#GetCommand(buffer) abort
-    return '%e' . ale#Pad(ale#Var(a:buffer, 'dockerfile_dockerfile_lint_options'))
-    \   . ' -p -j -f'
-    \   . ' %t'
-endfunction
-
-call ale#linter#Define('dockerfile', {
-\   'name': 'dockerfile_lint',
-\   'executable': {b -> ale#Var(b, 'dockerfile_dockerfile_lint_executable')},
-\   'command': function('ale_linters#dockerfile#dockerfile_lint#GetCommand'),
-\   'callback': 'ale_linters#dockerfile#dockerfile_lint#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/dockerfile/hadolint.vim b/sources_non_forked/ale/ale_linters/dockerfile/hadolint.vim
deleted file mode 100644
index e57cd76..0000000
--- a/sources_non_forked/ale/ale_linters/dockerfile/hadolint.vim
+++ /dev/null
@@ -1,99 +0,0 @@
-" Author: hauleth - https://github.com/hauleth
-
-" always, yes, never
-call ale#Set('dockerfile_hadolint_use_docker', 'never')
-call ale#Set('dockerfile_hadolint_docker_image', 'hadolint/hadolint')
-
-function! ale_linters#dockerfile#hadolint#Handle(buffer, lines) abort
-    " Matches patterns line the following:
-    "
-    " /dev/stdin:19 DL3001 Pipe chain should start with a raw value.
-    " /dev/stdin:19:3 unexpected thing
-    let l:pattern = '\v^/dev/stdin:(\d+):?(\d+)? ((DL|SC)(\d+) )?(.+)$'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        let l:lnum = 0
-        let l:colnum = 0
-
-        if l:match[1] isnot# ''
-            let l:lnum = l:match[1] + 0
-        endif
-
-        if l:match[2] isnot# ''
-            let l:colnum = l:match[2] + 0
-        endif
-
-        let l:type = 'W'
-        let l:text = l:match[6]
-        let l:detail = l:match[6]
-        let l:domain = 'https://github.com/hadolint/hadolint/wiki/'
-
-        if l:match[4] is# 'SC'
-            let l:domain = 'https://github.com/koalaman/shellcheck/wiki/'
-        endif
-
-        if l:match[5] isnot# ''
-            let l:code = l:match[4] . l:match[5]
-            let l:link = ' ( ' . l:domain . l:code . ' )'
-            let l:detail = l:code . l:link . "\n\n" . l:detail
-        else
-            let l:type = 'E'
-        endif
-
-        call add(l:output, {
-        \   'lnum': l:lnum,
-        \   'col': l:colnum,
-        \   'type': l:type,
-        \   'text': l:text,
-        \   'detail': l:detail
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-" This is a little different than the typical 'executable' callback.  We want
-" to afford the user the chance to say always use docker, never use docker,
-" and use docker if the hadolint executable is not present on the system.
-"
-" In the case of neither docker nor hadolint executables being present, it
-" really doesn't matter which we return -- either will have the effect of
-" 'nope, can't use this linter!'.
-
-function! ale_linters#dockerfile#hadolint#GetExecutable(buffer) abort
-    let l:use_docker = ale#Var(a:buffer, 'dockerfile_hadolint_use_docker')
-
-    " check for mandatory directives
-    if l:use_docker is# 'never'
-        return 'hadolint'
-    elseif l:use_docker is# 'always'
-        return 'docker'
-    endif
-
-    " if we reach here, we want to use 'hadolint' if present...
-    if executable('hadolint')
-        return 'hadolint'
-    endif
-
-    "... and 'docker' as a fallback.
-    return 'docker'
-endfunction
-
-function! ale_linters#dockerfile#hadolint#GetCommand(buffer) abort
-    let l:command = ale_linters#dockerfile#hadolint#GetExecutable(a:buffer)
-
-    if l:command is# 'docker'
-        return 'docker run --rm -i ' . ale#Var(a:buffer, 'dockerfile_hadolint_docker_image')
-    endif
-
-    return 'hadolint -'
-endfunction
-
-
-call ale#linter#Define('dockerfile', {
-\   'name': 'hadolint',
-\   'executable': function('ale_linters#dockerfile#hadolint#GetExecutable'),
-\   'command': function('ale_linters#dockerfile#hadolint#GetCommand'),
-\   'callback': 'ale_linters#dockerfile#hadolint#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/elixir/credo.vim b/sources_non_forked/ale/ale_linters/elixir/credo.vim
deleted file mode 100644
index 317ecab..0000000
--- a/sources_non_forked/ale/ale_linters/elixir/credo.vim
+++ /dev/null
@@ -1,63 +0,0 @@
-" Author: hauleth - https://github.com/hauleth
-
-function! ale_linters#elixir#credo#Handle(buffer, lines) abort
-    " Matches patterns line the following:
-    "
-    " lib/filename.ex:19:7: F: Pipe chain should start with a raw value.
-    let l:pattern = '\v:(\d+):?(\d+)?: (.): (.+)$'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        let l:type = l:match[3]
-        let l:text = l:match[4]
-
-        " Refactoring opportunities
-        if l:type is# 'F'
-            let l:type = 'W'
-        " Consistency
-        elseif l:type is# 'C'
-            let l:type = 'W'
-        " Software Design
-        elseif l:type is# 'D'
-            let l:type = 'I'
-        " Code Readability
-        elseif l:type is# 'R'
-            let l:type = 'I'
-        endif
-
-        call add(l:output, {
-        \   'bufnr': a:buffer,
-        \   'lnum': l:match[1] + 0,
-        \   'col': l:match[2] + 0,
-        \   'type': l:type,
-        \   'text': l:text,
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-function! ale_linters#elixir#credo#GetMode() abort
-    if get(g:, 'ale_elixir_credo_strict', 0)
-        return '--strict'
-    else
-        return 'suggest'
-    endif
-endfunction
-
-function! ale_linters#elixir#credo#GetCommand(buffer) abort
-    let l:project_root = ale#handlers#elixir#FindMixProjectRoot(a:buffer)
-    let l:mode = ale_linters#elixir#credo#GetMode()
-
-    return ale#path#CdString(l:project_root)
-    \ . 'mix help credo && '
-    \ . 'mix credo ' . ale_linters#elixir#credo#GetMode()
-    \ . ' --format=flycheck --read-from-stdin %s'
-endfunction
-
-call ale#linter#Define('elixir', {
-\   'name': 'credo',
-\   'executable': 'mix',
-\   'command': function('ale_linters#elixir#credo#GetCommand'),
-\   'callback': 'ale_linters#elixir#credo#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/elixir/dialyxir.vim b/sources_non_forked/ale/ale_linters/elixir/dialyxir.vim
deleted file mode 100644
index c7da775..0000000
--- a/sources_non_forked/ale/ale_linters/elixir/dialyxir.vim
+++ /dev/null
@@ -1,41 +0,0 @@
-" Author: Fran C. - https://github.com/franciscoj
-" Description: Add dialyzer support for elixir through dialyxir
-" https://github.com/jeremyjh/dialyxir
-
-function! ale_linters#elixir#dialyxir#Handle(buffer, lines) abort
-    " Matches patterns line the following:
-    "
-    " lib/filename.ex:19: Function fname/1 has no local return
-    let l:pattern = '\v(.+):(\d+): (.+)$'
-    let l:output = []
-    let l:type = 'W'
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        if bufname(a:buffer) == l:match[1]
-            call add(l:output, {
-            \   'bufnr': a:buffer,
-            \   'lnum': l:match[2] + 0,
-            \   'col': 0,
-            \   'type': l:type,
-            \   'text': l:match[3],
-            \})
-        endif
-    endfor
-
-    return l:output
-endfunction
-
-function! ale_linters#elixir#dialyxir#GetCommand(buffer) abort
-    let l:project_root = ale#handlers#elixir#FindMixProjectRoot(a:buffer)
-
-    return ale#path#CdString(l:project_root)
-    \ . ' mix help dialyzer && mix dialyzer'
-endfunction
-
-call ale#linter#Define('elixir', {
-\   'name': 'dialyxir',
-\   'executable': 'mix',
-\   'command': function('ale_linters#elixir#dialyxir#GetCommand'),
-\   'callback': 'ale_linters#elixir#dialyxir#Handle',
-\})
-
diff --git a/sources_non_forked/ale/ale_linters/elixir/dogma.vim b/sources_non_forked/ale/ale_linters/elixir/dogma.vim
deleted file mode 100644
index 1c72115..0000000
--- a/sources_non_forked/ale/ale_linters/elixir/dogma.vim
+++ /dev/null
@@ -1,45 +0,0 @@
-" Author: archseer - https://github.com/archSeer
-
-function! ale_linters#elixir#dogma#Handle(buffer, lines) abort
-    " Matches patterns line the following:
-    "
-    " lib/filename.ex:19:7: F: Pipe chain should start with a raw value.
-    let l:pattern = '\v:(\d+):?(\d+)?: (.): (.+)$'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        let l:type = l:match[3]
-        let l:text = l:match[4]
-
-        if l:type is# 'C'
-            let l:type = 'E'
-        elseif l:type is# 'R'
-            let l:type = 'W'
-        endif
-
-        call add(l:output, {
-        \   'bufnr': a:buffer,
-        \   'lnum': l:match[1] + 0,
-        \   'col': l:match[2] + 0,
-        \   'type': l:type,
-        \   'text': l:text,
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-function! ale_linters#elixir#dogma#GetCommand(buffer) abort
-    let l:project_root = ale#handlers#elixir#FindMixProjectRoot(a:buffer)
-
-    return ale#path#CdString(l:project_root)
-    \ . ' mix help dogma && mix dogma %s --format=flycheck'
-endfunction
-
-call ale#linter#Define('elixir', {
-\   'name': 'dogma',
-\   'executable': 'mix',
-\   'command': function('ale_linters#elixir#dogma#GetCommand'),
-\   'lint_file': 1,
-\   'callback': 'ale_linters#elixir#dogma#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/elixir/elixir_ls.vim b/sources_non_forked/ale/ale_linters/elixir/elixir_ls.vim
deleted file mode 100644
index d5517de..0000000
--- a/sources_non_forked/ale/ale_linters/elixir/elixir_ls.vim
+++ /dev/null
@@ -1,21 +0,0 @@
-" Author: Jon Parise <jon@indelible.org>
-" Description: ElixirLS integration (https://github.com/JakeBecker/elixir-ls)
-
-call ale#Set('elixir_elixir_ls_release', 'elixir-ls')
-call ale#Set('elixir_elixir_ls_config', {})
-
-function! ale_linters#elixir#elixir_ls#GetExecutable(buffer) abort
-    let l:dir = ale#path#Simplify(ale#Var(a:buffer, 'elixir_elixir_ls_release'))
-    let l:cmd = has('win32') ? '\language_server.bat' : '/language_server.sh'
-
-    return l:dir . l:cmd
-endfunction
-
-call ale#linter#Define('elixir', {
-\   'name': 'elixir-ls',
-\   'lsp': 'stdio',
-\   'executable': function('ale_linters#elixir#elixir_ls#GetExecutable'),
-\   'command': function('ale_linters#elixir#elixir_ls#GetExecutable'),
-\   'project_root': function('ale#handlers#elixir#FindMixUmbrellaRoot'),
-\   'lsp_config': {b -> ale#Var(b, 'elixir_elixir_ls_config')},
-\})
diff --git a/sources_non_forked/ale/ale_linters/elixir/mix.vim b/sources_non_forked/ale/ale_linters/elixir/mix.vim
deleted file mode 100644
index abf5d0a..0000000
--- a/sources_non_forked/ale/ale_linters/elixir/mix.vim
+++ /dev/null
@@ -1,52 +0,0 @@
-" Author: evnu - https://github.com/evnu
-" Author: colbydehart - https://github.com/colbydehart
-" Description: Mix compile checking for Elixir files
-
-function! ale_linters#elixir#mix#Handle(buffer, lines) abort
-    " Matches patterns like the following:
-    "
-    " Error format
-    " ** (CompileError) apps/sim/lib/sim/server.ex:87: undefined function update_in/4
-    "
-    " TODO: Warning format
-    " warning: variable "foobar" does not exist and is being expanded to "foobar()", please use parentheses to remove the ambiguity or change the variable name
-    let l:pattern = '\v\(([^\)]+Error)\) ([^:]+):([^:]+): (.+)$'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        let l:type = 'E'
-        let l:text = l:match[4]
-
-        call add(l:output, {
-        \   'bufnr': a:buffer,
-        \   'lnum': l:match[3] + 0,
-        \   'col': 0,
-        \   'type': l:type,
-        \   'text': l:text,
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-function! ale_linters#elixir#mix#GetCommand(buffer) abort
-    let l:project_root = ale#handlers#elixir#FindMixProjectRoot(a:buffer)
-
-    let l:temp_dir = ale#command#CreateDirectory(a:buffer)
-
-    let l:mix_build_path = has('win32')
-    \   ? 'set MIX_BUILD_PATH=' . ale#Escape(l:temp_dir) . ' &&'
-    \   : 'MIX_BUILD_PATH=' . ale#Escape(l:temp_dir)
-
-    return ale#path#CdString(l:project_root)
-    \ . l:mix_build_path
-    \ . ' mix compile %s'
-endfunction
-
-call ale#linter#Define('elixir', {
-\   'name': 'mix',
-\   'executable': 'mix',
-\   'command': function('ale_linters#elixir#mix#GetCommand'),
-\   'callback': 'ale_linters#elixir#mix#Handle',
-\   'lint_file': 1,
-\})
diff --git a/sources_non_forked/ale/ale_linters/elm/elm_ls.vim b/sources_non_forked/ale/ale_linters/elm/elm_ls.vim
deleted file mode 100644
index 2fa71ad..0000000
--- a/sources_non_forked/ale/ale_linters/elm/elm_ls.vim
+++ /dev/null
@@ -1,40 +0,0 @@
-" Author: antew - https://github.com/antew
-" Description: elm-language-server integration for elm (diagnostics, formatting, and more)
-
-call ale#Set('elm_ls_executable', 'elm-language-server')
-call ale#Set('elm_ls_use_global', get(g:, 'ale_use_global_executables', 1))
-
-" elm-language-server will search for local and global binaries, if empty
-call ale#Set('elm_ls_elm_path', '')
-call ale#Set('elm_ls_elm_format_path', '')
-call ale#Set('elm_ls_elm_test_path', '')
-call ale#Set('elm_ls_elm_analyse_trigger', 'change')
-
-function! elm_ls#GetRootDir(buffer) abort
-    let l:elm_json = ale#path#FindNearestFile(a:buffer, 'elm.json')
-
-    return !empty(l:elm_json) ? fnamemodify(l:elm_json, ':p:h') : ''
-endfunction
-
-function! elm_ls#GetOptions(buffer) abort
-    return {
-    \   'elmPath': ale#Var(a:buffer, 'elm_ls_elm_path'),
-    \   'elmFormatPath': ale#Var(a:buffer, 'elm_ls_elm_format_path'),
-    \   'elmTestPath': ale#Var(a:buffer, 'elm_ls_elm_test_path'),
-    \   'elmAnalyseTrigger': ale#Var(a:buffer, 'elm_ls_elm_analyse_trigger'),
-    \}
-endfunction
-
-call ale#linter#Define('elm', {
-\   'name': 'elm_ls',
-\   'lsp': 'stdio',
-\   'executable': {b -> ale#node#FindExecutable(b, 'elm_ls', [
-\       'node_modules/.bin/elm-language-server',
-\       'node_modules/.bin/elm-lsp',
-\       'elm-lsp'
-\   ])},
-\   'command': '%e --stdio',
-\   'project_root': function('elm_ls#GetRootDir'),
-\   'language': 'elm',
-\   'initialization_options': function('elm_ls#GetOptions')
-\})
diff --git a/sources_non_forked/ale/ale_linters/elm/make.vim b/sources_non_forked/ale/ale_linters/elm/make.vim
deleted file mode 100644
index 6b93257..0000000
--- a/sources_non_forked/ale/ale_linters/elm/make.vim
+++ /dev/null
@@ -1,240 +0,0 @@
-" Author: buffalocoder - https://github.com/buffalocoder, soywod - https://github.com/soywod, hecrj - https://github.com/hecrj
-" Description: Elm linting in Ale. Closely follows the Syntastic checker in https://github.com/ElmCast/elm-vim.
-
-call ale#Set('elm_make_executable', 'elm')
-call ale#Set('elm_make_use_global', get(g:, 'ale_use_global_executables', 0))
-
-function! ale_linters#elm#make#Handle(buffer, lines) abort
-    let l:output = []
-    let l:unparsed_lines = []
-
-    for l:line in a:lines
-        if l:line[0] is# '{'
-            " Elm 0.19
-            call ale_linters#elm#make#HandleElm019Line(l:line, l:output)
-        elseif l:line[0] is# '['
-            " Elm 0.18
-            call ale_linters#elm#make#HandleElm018Line(l:line, l:output)
-        elseif l:line isnot# 'Successfully generated /dev/null'
-            call add(l:unparsed_lines, l:line)
-        endif
-    endfor
-
-    if len(l:unparsed_lines) > 0
-        call add(l:output, {
-        \    'lnum': 1,
-        \    'type': 'E',
-        \    'text': l:unparsed_lines[0],
-        \    'detail': join(l:unparsed_lines, "\n")
-        \})
-    endif
-
-    return l:output
-endfunction
-
-function! ale_linters#elm#make#HandleElm019Line(line, output) abort
-    let l:report = json_decode(a:line)
-
-    if l:report.type is? 'error'
-        " General problem
-        let l:details = ale_linters#elm#make#ParseMessage(l:report.message)
-
-        if empty(l:report.path)
-            let l:report.path = 'Elm'
-        endif
-
-        if ale_linters#elm#make#FileIsBuffer(l:report.path)
-            call add(a:output, {
-            \    'lnum': 1,
-            \    'type': 'E',
-            \    'text': l:details,
-            \})
-        else
-            call add(a:output, {
-            \    'lnum': 1,
-            \    'type': 'E',
-            \    'text': l:report.path .' - '. l:details,
-            \    'detail': l:report.path ." ----------\n\n". l:details,
-            \})
-        endif
-    else
-        " Compilation errors
-        for l:error in l:report.errors
-            let l:file_is_buffer = ale_linters#elm#make#FileIsBuffer(l:error.path)
-
-            for l:problem in l:error.problems
-                let l:details = ale_linters#elm#make#ParseMessage(l:problem.message)
-
-                if l:file_is_buffer
-                    " Buffer module has problems
-                    call add(a:output, {
-                    \    'lnum': l:problem.region.start.line,
-                    \    'col': l:problem.region.start.column,
-                    \    'end_lnum': l:problem.region.end.line,
-                    \    'end_col': l:problem.region.end.column,
-                    \    'type': 'E',
-                    \    'text': l:details,
-                    \})
-                else
-                    " Imported module has problems
-                    let l:location = l:error.path .':'. l:problem.region.start.line
-                    call add(a:output, {
-                    \    'lnum': 1,
-                    \    'type': 'E',
-                    \    'text': l:location .' - '. l:details,
-                    \    'detail': l:location ." ----------\n\n". l:details,
-                    \})
-                endif
-            endfor
-        endfor
-    endif
-endfunction
-
-function! ale_linters#elm#make#HandleElm018Line(line, output) abort
-    let l:errors = json_decode(a:line)
-
-    for l:error in l:errors
-        let l:file_is_buffer = ale_linters#elm#make#FileIsBuffer(l:error.file)
-
-        if l:file_is_buffer
-            " Current buffer has problems
-            call add(a:output, {
-            \    'lnum': l:error.region.start.line,
-            \    'col': l:error.region.start.column,
-            \    'end_lnum': l:error.region.end.line,
-            \    'end_col': l:error.region.end.column,
-            \    'type': (l:error.type is? 'error') ? 'E' : 'W',
-            \    'text': l:error.overview,
-            \    'detail': l:error.overview . "\n\n" . l:error.details
-            \})
-        elseif l:error.type is? 'error'
-            " Imported module has errors
-            let l:location = l:error.file .':'. l:error.region.start.line
-
-            call add(a:output, {
-            \    'lnum': 1,
-            \    'type': 'E',
-            \    'text': l:location .' - '. l:error.overview,
-            \    'detail': l:location ." ----------\n\n". l:error.overview . "\n\n" . l:error.details
-            \})
-        endif
-    endfor
-endfunction
-
-function! ale_linters#elm#make#FileIsBuffer(path) abort
-    return ale#path#IsTempName(a:path)
-endfunction
-
-function! ale_linters#elm#make#ParseMessage(message) abort
-    return join(map(copy(a:message), 'ale_linters#elm#make#ParseMessageItem(v:val)'), '')
-endfunction
-
-function! ale_linters#elm#make#ParseMessageItem(item) abort
-    if type(a:item) is v:t_string
-        return a:item
-    else
-        return a:item.string
-    endif
-endfunction
-
-function! ale_linters#elm#make#GetPackageFile(buffer) abort
-    let l:elm_json = ale#path#FindNearestFile(a:buffer, 'elm.json')
-
-    if empty(l:elm_json)
-        " Fallback to Elm 0.18
-        let l:elm_json = ale#path#FindNearestFile(a:buffer, 'elm-package.json')
-    endif
-
-    return l:elm_json
-endfunction
-
-function! ale_linters#elm#make#IsVersionGte19(buffer) abort
-    let l:elm_json = ale_linters#elm#make#GetPackageFile(a:buffer)
-
-    if l:elm_json =~# '-package'
-        return 0
-    else
-        return 1
-    endif
-endfunction
-
-function! ale_linters#elm#make#GetRootDir(buffer) abort
-    let l:elm_json = ale_linters#elm#make#GetPackageFile(a:buffer)
-
-    if empty(l:elm_json)
-        return ''
-    else
-        return fnamemodify(l:elm_json, ':p:h')
-    endif
-endfunction
-
-function! ale_linters#elm#make#IsTest(buffer) abort
-    let l:root_dir = ale_linters#elm#make#GetRootDir(a:buffer)
-
-    if empty(l:root_dir)
-        return 0
-    endif
-
-    let l:tests_dir = join([l:root_dir, 'tests', ''], has('win32') ? '\' : '/')
-
-    let l:buffer_path = fnamemodify(bufname(a:buffer), ':p')
-
-    if stridx(l:buffer_path, l:tests_dir) == 0
-        return 1
-    else
-        return 0
-    endif
-endfunction
-
-" Return the command to execute the linter in the projects directory.
-" If it doesn't, then this will fail when imports are needed.
-function! ale_linters#elm#make#GetCommand(buffer) abort
-    let l:executable = ale_linters#elm#make#GetExecutable(a:buffer)
-    let l:root_dir = ale_linters#elm#make#GetRootDir(a:buffer)
-    let l:is_v19 = ale_linters#elm#make#IsVersionGte19(a:buffer)
-    let l:is_using_elm_test = l:executable =~# 'elm-test$'
-
-    if empty(l:root_dir)
-        let l:dir_set_cmd = ''
-    else
-        let l:dir_set_cmd = 'cd ' . ale#Escape(l:root_dir) . ' && '
-    endif
-
-    " elm-test needs to know the path of elm-make if elm isn't installed globally.
-    " https://github.com/rtfeldman/node-test-runner/blob/57728f10668f2d2ab3179e7e3208bcfa9a1f19aa/README.md#--compiler
-    if l:is_v19 && l:is_using_elm_test
-        let l:elm_make_executable = ale#node#FindExecutable(a:buffer, 'elm_make', ['node_modules/.bin/elm'])
-        let l:elm_test_compiler_flag = ' --compiler ' . l:elm_make_executable . ' '
-    else
-        let l:elm_test_compiler_flag = ' '
-    endif
-
-    " The elm compiler, at the time of this writing, uses '/dev/null' as
-    " a sort of flag to tell the compiler not to generate an output file,
-    " which is why this is hard coded here.
-    " Source: https://github.com/elm-lang/elm-compiler/blob/19d5a769b30ec0b2fc4475985abb4cd94cd1d6c3/builder/src/Generate/Output.hs#L253
-    return l:dir_set_cmd . '%e make --report=json --output=/dev/null' . l:elm_test_compiler_flag . '%t'
-endfunction
-
-function! ale_linters#elm#make#GetExecutable(buffer) abort
-    let l:is_test = ale_linters#elm#make#IsTest(a:buffer)
-    let l:is_v19 = ale_linters#elm#make#IsVersionGte19(a:buffer)
-
-    if l:is_test && l:is_v19
-        return ale#node#FindExecutable(
-        \   a:buffer,
-        \   'elm_make',
-        \   ['node_modules/.bin/elm-test', 'node_modules/.bin/elm']
-        \)
-    else
-        return ale#node#FindExecutable(a:buffer, 'elm_make', ['node_modules/.bin/elm'])
-    endif
-endfunction
-
-call ale#linter#Define('elm', {
-\   'name': 'make',
-\   'executable': function('ale_linters#elm#make#GetExecutable'),
-\   'output_stream': 'both',
-\   'command': function('ale_linters#elm#make#GetCommand'),
-\   'callback': 'ale_linters#elm#make#Handle'
-\})
diff --git a/sources_non_forked/ale/ale_linters/erlang/dialyzer.vim b/sources_non_forked/ale/ale_linters/erlang/dialyzer.vim
deleted file mode 100644
index 395647a..0000000
--- a/sources_non_forked/ale/ale_linters/erlang/dialyzer.vim
+++ /dev/null
@@ -1,93 +0,0 @@
-" Author: Autoine Gagne - https://github.com/AntoineGagne
-" Description: Define a checker that runs dialyzer on Erlang files.
-
-let g:ale_erlang_dialyzer_executable =
-\   get(g:, 'ale_erlang_dialyzer_executable', 'dialyzer')
-let g:ale_erlang_dialyzer_plt_file =
-\   get(g:, 'ale_erlang_dialyzer_plt_file', '')
-let g:ale_erlang_dialyzer_rebar3_profile =
-\   get(g:, 'ale_erlang_dialyzer_rebar3_profile', 'default')
-
-function! ale_linters#erlang#dialyzer#GetRebar3Profile(buffer) abort
-    return ale#Var(a:buffer, 'erlang_dialyzer_rebar3_profile')
-endfunction
-
-function! ale_linters#erlang#dialyzer#FindPlt(buffer) abort
-    let l:plt_file = ''
-    let l:rebar3_profile = ale_linters#erlang#dialyzer#GetRebar3Profile(a:buffer)
-    let l:plt_file_directory = ale#path#FindNearestDirectory(a:buffer, '_build/' . l:rebar3_profile)
-
-    if !empty(l:plt_file_directory)
-        let l:plt_file = globpath(l:plt_file_directory, '*_plt', 0, 1)
-    endif
-
-    if !empty(l:plt_file)
-        return l:plt_file[0]
-    endif
-
-    if !empty($REBAR_PLT_DIR)
-        return expand('$REBAR_PLT_DIR/dialyzer/plt')
-    endif
-
-    return expand('$HOME/.dialyzer_plt')
-endfunction
-
-function! ale_linters#erlang#dialyzer#GetPlt(buffer) abort
-    let l:plt_file = ale#Var(a:buffer, 'erlang_dialyzer_plt_file')
-
-    if !empty(l:plt_file)
-        return l:plt_file
-    endif
-
-    return ale_linters#erlang#dialyzer#FindPlt(a:buffer)
-endfunction
-
-function! ale_linters#erlang#dialyzer#GetExecutable(buffer) abort
-    return ale#Var(a:buffer, 'erlang_dialyzer_executable')
-endfunction
-
-function! ale_linters#erlang#dialyzer#GetCommand(buffer) abort
-    let l:command = ale#Escape(ale_linters#erlang#dialyzer#GetExecutable(a:buffer))
-    \   . ' -n'
-    \   . ' --plt ' . ale#Escape(ale_linters#erlang#dialyzer#GetPlt(a:buffer))
-    \   . ' -Wunmatched_returns'
-    \   . ' -Werror_handling'
-    \   . ' -Wrace_conditions'
-    \   . ' -Wunderspecs'
-    \   . ' %s'
-
-    return l:command
-endfunction
-
-function! ale_linters#erlang#dialyzer#Handle(buffer, lines) abort
-    " Match patterns like the following:
-    "
-    " erl_tidy_prv_fmt.erl:3: Callback info about the provider behaviour is not available
-    let l:pattern = '^\S\+:\(\d\+\): \(.\+\)$'
-    let l:output = []
-
-    for l:line in a:lines
-        let l:match = matchlist(l:line, l:pattern)
-
-        if len(l:match) != 0
-            let l:code = l:match[2]
-
-            call add(l:output, {
-            \   'lnum': str2nr(l:match[1]),
-            \   'lcol': 0,
-            \   'text': l:code,
-            \   'type': 'W'
-            \})
-        endif
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('erlang', {
-\   'name': 'dialyzer',
-\   'executable': function('ale_linters#erlang#dialyzer#GetExecutable'),
-\   'command': function('ale_linters#erlang#dialyzer#GetCommand'),
-\   'callback': function('ale_linters#erlang#dialyzer#Handle'),
-\   'lint_file': 1
-\})
diff --git a/sources_non_forked/ale/ale_linters/erlang/erlc.vim b/sources_non_forked/ale/ale_linters/erlang/erlc.vim
deleted file mode 100644
index a83bacc..0000000
--- a/sources_non_forked/ale/ale_linters/erlang/erlc.vim
+++ /dev/null
@@ -1,96 +0,0 @@
-" Author: Magnus Ottenklinger - https://github.com/evnu
-
-let g:ale_erlang_erlc_options = get(g:, 'ale_erlang_erlc_options', '')
-
-function! ale_linters#erlang#erlc#GetCommand(buffer) abort
-    let l:output_file = ale#util#Tempname()
-    call ale#command#ManageFile(a:buffer, l:output_file)
-
-    return 'erlc -o ' . ale#Escape(l:output_file)
-    \   . ' ' . ale#Var(a:buffer, 'erlang_erlc_options')
-    \   . ' %t'
-endfunction
-
-function! ale_linters#erlang#erlc#Handle(buffer, lines) abort
-    " Matches patterns like the following:
-    "
-    " error.erl:4: variable 'B' is unbound
-    " error.erl:3: Warning: function main/0 is unused
-    " error.erl:4: Warning: variable 'A' is unused
-    let l:pattern = '\v^([a-zA-Z]?:?[^:]+):(\d+): (Warning: )?(.+)$'
-
-    " parse_transforms are a special case. The error message does not indicate a location:
-    " error.erl: undefined parse transform 'some_parse_transform'
-    let l:pattern_parse_transform = '\v(undefined parse transform .*)$'
-    let l:output = []
-
-    let l:pattern_no_module_definition = '\v(no module definition)$'
-    let l:pattern_unused = '\v(.* is unused)$'
-
-    let l:is_hrl = fnamemodify(bufname(a:buffer), ':e') is# 'hrl'
-
-    for l:line in a:lines
-        let l:match = matchlist(l:line, l:pattern)
-
-        " Determine if the output indicates an error. We distinguish between two cases:
-        "
-        " 1) normal errors match l:pattern
-        " 2) parse_transform errors match l:pattern_parse_transform
-        "
-        " If none of the patterns above match, the line can be ignored
-        if len(l:match) == 0 " not a 'normal' warning or error
-            let l:match_parse_transform = matchlist(l:line, l:pattern_parse_transform)
-
-            if len(l:match_parse_transform) == 0 " also not a parse_transform error
-                continue
-            endif
-
-            call add(l:output, {
-            \   'bufnr': a:buffer,
-            \   'lnum': 0,
-            \   'col': 0,
-            \   'type': 'E',
-            \   'text': l:match_parse_transform[0],
-            \})
-
-            continue
-        endif
-
-        let l:line = l:match[2]
-        let l:warning_or_text = l:match[3]
-        let l:text = l:match[4]
-
-        " If this file is a header .hrl, ignore the following expected messages:
-        " - 'no module definition'
-        " - 'X is unused'
-        if l:is_hrl && (
-        \   match(l:text, l:pattern_no_module_definition) != -1
-        \   || match(l:text, l:pattern_unused) != -1
-        \)
-            continue
-        endif
-
-        if !empty(l:warning_or_text)
-            let l:type = 'W'
-        else
-            let l:type = 'E'
-        endif
-
-        call add(l:output, {
-        \   'bufnr': a:buffer,
-        \   'lnum': l:line,
-        \   'col': 0,
-        \   'type': l:type,
-        \   'text': l:text,
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('erlang', {
-\   'name': 'erlc',
-\   'executable': 'erlc',
-\   'command': function('ale_linters#erlang#erlc#GetCommand'),
-\   'callback': 'ale_linters#erlang#erlc#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/erlang/syntaxerl.vim b/sources_non_forked/ale/ale_linters/erlang/syntaxerl.vim
deleted file mode 100644
index 5d555a8..0000000
--- a/sources_non_forked/ale/ale_linters/erlang/syntaxerl.vim
+++ /dev/null
@@ -1,42 +0,0 @@
-" Author: Dmitri Vereshchagin <dmitri.vereshchagin@gmail.com>
-" Description: SyntaxErl linter for Erlang files
-
-call ale#Set('erlang_syntaxerl_executable', 'syntaxerl')
-
-function! ale_linters#erlang#syntaxerl#RunHelpCommand(buffer) abort
-    let l:executable = ale#Var(a:buffer, 'erlang_syntaxerl_executable')
-
-    return ale#command#Run(
-    \   a:buffer,
-    \   ale#Escape(l:executable) . ' -h',
-    \   function('ale_linters#erlang#syntaxerl#GetCommand'),
-    \)
-endfunction
-
-function! ale_linters#erlang#syntaxerl#GetCommand(buffer, output, meta) abort
-    let l:use_b_option = match(a:output, '\C\V-b, --base\>') > -1
-
-    return '%e' . (l:use_b_option ? ' -b %s %t' : ' %t')
-endfunction
-
-function! ale_linters#erlang#syntaxerl#Handle(buffer, lines) abort
-    let l:pattern = '\v\C:(\d+):( warning:)? (.+)'
-    let l:loclist = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        call add(l:loclist, {
-        \   'lnum': l:match[1] + 0,
-        \   'text': l:match[3],
-        \   'type': empty(l:match[2]) ? 'E' : 'W',
-        \})
-    endfor
-
-    return l:loclist
-endfunction
-
-call ale#linter#Define('erlang', {
-\   'name': 'syntaxerl',
-\   'executable': {b -> ale#Var(b, 'erlang_syntaxerl_executable')},
-\   'command': {b -> ale_linters#erlang#syntaxerl#RunHelpCommand(b)},
-\   'callback': 'ale_linters#erlang#syntaxerl#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/eruby/erb.vim b/sources_non_forked/ale/ale_linters/eruby/erb.vim
deleted file mode 100644
index f343832..0000000
--- a/sources_non_forked/ale/ale_linters/eruby/erb.vim
+++ /dev/null
@@ -1,25 +0,0 @@
-" Author: Matthias Guenther - https://wikimatze.de, Eddie Lebow https://github.com/elebow
-" Description: ERB from the Ruby standard library, for eruby/erb files
-
-function! ale_linters#eruby#erb#GetCommand(buffer) abort
-    let l:rails_root = ale#ruby#FindRailsRoot(a:buffer)
-
-    if empty(l:rails_root)
-        return 'erb -P -T - -x %t | ruby -c'
-    endif
-
-    " Rails-flavored eRuby does not comply with the standard as understood by
-    " ERB, so we'll have to do some substitution. This does not reduce the
-    " effectiveness of the linterthe translated code is still evaluated.
-    return 'ruby -r erb -e ' . ale#Escape('puts ERB.new($stdin.read.gsub(%{<%=},%{<%}), nil, %{-}).src') . '< %t | ruby -c'
-endfunction
-
-call ale#linter#Define('eruby', {
-\   'name': 'erb',
-\   'aliases': ['erubylint'],
-\   'executable': 'erb',
-\   'output_stream': 'stderr',
-\   'command': function('ale_linters#eruby#erb#GetCommand'),
-\   'callback': 'ale#handlers#ruby#HandleSyntaxErrors',
-\})
-
diff --git a/sources_non_forked/ale/ale_linters/eruby/erubi.vim b/sources_non_forked/ale/ale_linters/eruby/erubi.vim
deleted file mode 100644
index ddca3f6..0000000
--- a/sources_non_forked/ale/ale_linters/eruby/erubi.vim
+++ /dev/null
@@ -1,32 +0,0 @@
-" Author: Eddie Lebow https://github.com/elebow
-" Description: eruby checker using `erubi`
-
-function! ale_linters#eruby#erubi#GetCommand(buffer, output, meta) abort
-    let l:rails_root = ale#ruby#FindRailsRoot(a:buffer)
-
-    if !empty(a:output)
-        " The empty command in CheckErubi returns nothing if erubi runs and
-        " emits an error if erubi is not present
-        return ''
-    endif
-
-    if empty(l:rails_root)
-        return 'ruby -r erubi/capture_end -e ' . ale#Escape('puts Erubi::CaptureEndEngine.new($stdin.read).src') . '< %t | ruby -c'
-    endif
-
-    " Rails-flavored eRuby does not comply with the standard as understood by
-    " Erubi, so we'll have to do some substitution. This does not reduce the
-    " effectiveness of the linter---the translated code is still evaluated.
-    return 'ruby -r erubi/capture_end -e ' . ale#Escape('puts Erubi::CaptureEndEngine.new($stdin.read.gsub(%{<%=},%{<%}), nil, %{-}).src') . '< %t | ruby -c'
-endfunction
-
-call ale#linter#Define('eruby', {
-\   'name': 'erubi',
-\   'executable': 'ruby',
-\   'command': {buffer -> ale#command#Run(
-\       buffer,
-\       'ruby -r erubi/capture_end -e ' . ale#Escape('""'),
-\       function('ale_linters#eruby#erubi#GetCommand'),
-\   )},
-\   'callback': 'ale#handlers#ruby#HandleSyntaxErrors',
-\})
diff --git a/sources_non_forked/ale/ale_linters/eruby/erubis.vim b/sources_non_forked/ale/ale_linters/eruby/erubis.vim
deleted file mode 100644
index 755c580..0000000
--- a/sources_non_forked/ale/ale_linters/eruby/erubis.vim
+++ /dev/null
@@ -1,23 +0,0 @@
-" Author: Jake Zimmerman <jake@zimmerman.io>, Eddie Lebow https://github.com/elebow
-" Description: eruby checker using `erubis`, instead of `erb`
-
-function! ale_linters#eruby#erubis#GetCommand(buffer) abort
-    let l:rails_root = ale#ruby#FindRailsRoot(a:buffer)
-
-    if empty(l:rails_root)
-        return 'erubis -x %t | ruby -c'
-    endif
-
-    " Rails-flavored eRuby does not comply with the standard as understood by
-    " Erubis, so we'll have to do some substitution. This does not reduce the
-    " effectiveness of the linter - the translated code is still evaluated.
-    return 'ruby -r erubis -e ' . ale#Escape('puts Erubis::Eruby.new($stdin.read.gsub(%{<%=},%{<%})).src') . '< %t | ruby -c'
-endfunction
-
-call ale#linter#Define('eruby', {
-\   'name': 'erubis',
-\   'executable': 'erubis',
-\   'output_stream': 'stderr',
-\   'command': function('ale_linters#eruby#erubis#GetCommand'),
-\   'callback': 'ale#handlers#ruby#HandleSyntaxErrors',
-\})
diff --git a/sources_non_forked/ale/ale_linters/eruby/ruumba.vim b/sources_non_forked/ale/ale_linters/eruby/ruumba.vim
deleted file mode 100644
index 2e84acf..0000000
--- a/sources_non_forked/ale/ale_linters/eruby/ruumba.vim
+++ /dev/null
@@ -1,62 +0,0 @@
-" Author: aclemons - https://github.com/aclemons
-" based on the ale rubocop linter
-" Description: Ruumba, RuboCop linting for ERB templates.
-
-call ale#Set('eruby_ruumba_executable', 'ruumba')
-call ale#Set('eruby_ruumba_options', '')
-
-function! ale_linters#eruby#ruumba#GetCommand(buffer) abort
-    let l:executable = ale#Var(a:buffer, 'eruby_ruumba_executable')
-
-    return ale#ruby#EscapeExecutable(l:executable, 'ruumba')
-    \   . ' --format json --force-exclusion '
-    \   . ale#Var(a:buffer, 'eruby_ruumba_options')
-    \   . ' --stdin ' . ale#Escape(expand('#' . a:buffer . ':p'))
-endfunction
-
-function! ale_linters#eruby#ruumba#Handle(buffer, lines) abort
-    try
-        let l:errors = json_decode(a:lines[0])
-    catch
-        return []
-    endtry
-
-    if !has_key(l:errors, 'summary')
-    \|| l:errors['summary']['offense_count'] == 0
-    \|| empty(l:errors['files'])
-        return []
-    endif
-
-    let l:output = []
-
-    for l:error in l:errors['files'][0]['offenses']
-        let l:start_col = l:error['location']['column'] + 0
-        call add(l:output, {
-        \   'lnum': l:error['location']['line'] + 0,
-        \   'col': l:start_col,
-        \   'end_col': l:start_col + l:error['location']['length'] - 1,
-        \   'code': l:error['cop_name'],
-        \   'text': l:error['message'],
-        \   'type': ale_linters#eruby#ruumba#GetType(l:error['severity']),
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-function! ale_linters#eruby#ruumba#GetType(severity) abort
-    if a:severity is? 'convention'
-    \|| a:severity is? 'warning'
-    \|| a:severity is? 'refactor'
-        return 'W'
-    endif
-
-    return 'E'
-endfunction
-
-call ale#linter#Define('eruby', {
-\   'name': 'ruumba',
-\   'executable': {b -> ale#Var(b, 'eruby_ruumba_executable')},
-\   'command': function('ale_linters#eruby#ruumba#GetCommand'),
-\   'callback': 'ale_linters#eruby#ruumba#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/fish/fish.vim b/sources_non_forked/ale/ale_linters/fish/fish.vim
deleted file mode 100644
index 87ede29..0000000
--- a/sources_non_forked/ale/ale_linters/fish/fish.vim
+++ /dev/null
@@ -1,67 +0,0 @@
-" Author: Niraj Thapaliya - https://github.com/nthapaliya
-" Description: Lints fish files using fish -n
-
-function! ale_linters#fish#fish#Handle(buffer, lines) abort
-    " Matches patterns such as:
-    "
-    " home/.config/fish/functions/foo.fish (line 1): Missing end to balance this function definition
-    " function foo
-    " ^
-    "
-    " OR, patterns such as:
-    "
-    " Unsupported use of '||'. In fish, please use 'COMMAND; or COMMAND'.
-    " /tmp/vLz620o/258/test.fish (line 2): if set -q SSH_CLIENT || set -q SSH_TTY
-    "                                                            ^
-    "
-    " fish -n can return errors in either format.
-    let l:pattern = '^\(.* (line \(\d\+\)): \)\(.*\)$'
-    let l:column_pattern = '^ *\^'
-    let l:output = []
-    let l:column_offset = 0
-    let l:last_line_with_message = ''
-
-    for l:line in a:lines
-        " Look for error lines first.
-        let l:match = matchlist(l:line, l:pattern)
-
-        if !empty(l:match)
-            if !empty(l:last_line_with_message)
-                let l:text = l:last_line_with_message
-            else
-                let l:text = l:match[3]
-            endif
-
-            let l:column_offset = len(l:match[1])
-
-            let l:last_line_with_message = ''
-            call add(l:output, {
-            \  'col': 0,
-            \  'lnum': str2nr(l:match[2]),
-            \  'text': l:text,
-            \})
-        else
-            " Look for column markers like '   ^' second.
-            " The column index will be set according to how long the line is.
-            let l:column_match = matchstr(l:line, l:column_pattern)
-
-            if !empty(l:column_match) && !empty(l:output)
-                let l:output[-1].col = len(l:column_match) - l:column_offset
-                let l:last_line_with_message = ''
-            else
-                let l:last_line_with_message = l:line
-                let l:column_offset = 0
-            endif
-        endif
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('fish', {
-\   'name': 'fish',
-\   'output_stream': 'stderr',
-\   'executable': 'fish',
-\   'command': 'fish -n %t',
-\   'callback': 'ale_linters#fish#fish#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/fortran/gcc.vim b/sources_non_forked/ale/ale_linters/fortran/gcc.vim
deleted file mode 100644
index 6e97d6f..0000000
--- a/sources_non_forked/ale/ale_linters/fortran/gcc.vim
+++ /dev/null
@@ -1,72 +0,0 @@
-" Author: w0rp <devw0rp@gmail.com>
-" Description: gcc for Fortran files
-
-" This option can be set to 0 to use -ffixed-form
-call ale#Set('fortran_gcc_use_free_form', 1)
-call ale#Set('fortran_gcc_executable', 'gcc')
-" Set this option to change the GCC options for warnings for Fortran.
-call ale#Set('fortran_gcc_options', '-Wall')
-
-function! ale_linters#fortran#gcc#Handle(buffer, lines) abort
-    " We have to match a starting line and a later ending line together,
-    " like so.
-    "
-    " :21.34:
-    " Error: Expected comma in I/O list at (1)
-    let l:line_marker_pattern = ':\(\d\+\)[.:]\=\(\d\+\)\=:\=$'
-    let l:message_pattern = '^\(Error\|Warning\): \(.\+\)$'
-    let l:looking_for_message = 0
-    let l:last_loclist_obj = {}
-
-    let l:output = []
-
-    for l:line in a:lines
-        if l:looking_for_message
-            let l:match = matchlist(l:line, l:message_pattern)
-        else
-            let l:match = matchlist(l:line, l:line_marker_pattern)
-        endif
-
-        if len(l:match) == 0
-            continue
-        endif
-
-        if l:looking_for_message
-            let l:looking_for_message = 0
-
-            " Now we have the text, we can set it and add the error.
-            let l:last_loclist_obj.text = l:match[2]
-            let l:last_loclist_obj.type = l:match[1] is# 'Warning' ? 'W' : 'E'
-            call add(l:output, l:last_loclist_obj)
-        else
-            let l:last_loclist_obj = {
-            \   'bufnr': a:buffer,
-            \   'lnum': l:match[1] + 0,
-            \   'col': l:match[2] + 0,
-            \}
-
-            " Start looking for the message and error type.
-            let l:looking_for_message = 1
-        endif
-    endfor
-
-    return l:output
-endfunction
-
-function! ale_linters#fortran#gcc#GetCommand(buffer) abort
-    let l:layout_option = ale#Var(a:buffer, 'fortran_gcc_use_free_form')
-    \   ? '-ffree-form'
-    \   : '-ffixed-form'
-
-    return '%e -S -x f95 -fsyntax-only ' . l:layout_option
-    \   . ale#Pad(ale#Var(a:buffer, 'fortran_gcc_options'))
-    \   . ' -'
-endfunction
-
-call ale#linter#Define('fortran', {
-\   'name': 'gcc',
-\   'output_stream': 'stderr',
-\   'executable': {b -> ale#Var(b, 'fortran_gcc_executable')},
-\   'command': function('ale_linters#fortran#gcc#GetCommand'),
-\   'callback': 'ale_linters#fortran#gcc#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/fortran/language_server.vim b/sources_non_forked/ale/ale_linters/fortran/language_server.vim
deleted file mode 100644
index 00aa057..0000000
--- a/sources_non_forked/ale/ale_linters/fortran/language_server.vim
+++ /dev/null
@@ -1,19 +0,0 @@
-" Author: unpairedbracket ben.spiers22@gmail.com
-" Description: A language server for fortran
-
-call ale#Set('fortran_language_server_executable', 'fortls')
-call ale#Set('fortran_language_server_use_global', get(g:, 'ale_use_global_executables', 0))
-
-function! ale_linters#fortran#language_server#GetProjectRoot(buffer) abort
-    let l:fortls_file = ale#path#FindNearestFile(a:buffer, '.fortls')
-
-    return !empty(l:fortls_file) ? fnamemodify(l:fortls_file, ':h') : ''
-endfunction
-
-call ale#linter#Define('fortran', {
-\   'name': 'language_server',
-\   'lsp': 'stdio',
-\   'executable': {b -> ale#Var(b, 'fortran_language_server_executable')},
-\   'command': '%e',
-\   'project_root': function('ale_linters#fortran#language_server#GetProjectRoot'),
-\})
diff --git a/sources_non_forked/ale/ale_linters/fountain/proselint.vim b/sources_non_forked/ale/ale_linters/fountain/proselint.vim
deleted file mode 100644
index 353a2e5..0000000
--- a/sources_non_forked/ale/ale_linters/fountain/proselint.vim
+++ /dev/null
@@ -1,9 +0,0 @@
-" Author: Jansen Mitchell https://github.com/JansenMitchell
-" Description: proselint for Fountain files
-
-call ale#linter#Define('fountain', {
-\    'name': 'proselint',
-\    'executable': 'proselint',
-\    'command': 'proselint %t',
-\    'callback': 'ale#handlers#unix#HandleAsWarning',
-\})
diff --git a/sources_non_forked/ale/ale_linters/fuse/fusionlint.vim b/sources_non_forked/ale/ale_linters/fuse/fusionlint.vim
deleted file mode 100644
index ffb25d3..0000000
--- a/sources_non_forked/ale/ale_linters/fuse/fusionlint.vim
+++ /dev/null
@@ -1,33 +0,0 @@
-" Author: RyanSquared <vandor2012@gmail.com>
-" Description: `fusion-lint` linter for FusionScript files
-
-call ale#Set('fuse_fusionlint_executable', 'fusion-lint')
-call ale#Set('fuse_fusionlint_options', '')
-
-function! ale_linters#fuse#fusionlint#GetCommand(buffer) abort
-    return '%e' . ale#Pad(ale#Var(a:buffer, 'fuse_fusionlint_options'))
-    \   . ' --filename %s -i'
-endfunction
-
-function! ale_linters#fuse#fusionlint#Handle(buffer, lines) abort
-    let l:pattern = '^.*:\(\d\+\):\(\d\+\): (\([WE]\)\d\+) \(.\+\)$'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        call add(l:output, {
-        \   'lnum': l:match[1] + 0,
-        \   'col': l:match[2] + 0,
-        \   'text': l:match[4],
-        \   'type': l:match[3],
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('fuse', {
-\   'name': 'fusionlint',
-\   'executable': {b -> ale#Var(b, 'fuse_fusionlint_executable')},
-\   'command': function('ale_linters#fuse#fusionlint#GetCommand'),
-\   'callback': 'ale_linters#fuse#fusionlint#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/gitcommit/gitlint.vim b/sources_non_forked/ale/ale_linters/gitcommit/gitlint.vim
deleted file mode 100644
index 4b9cec6..0000000
--- a/sources_non_forked/ale/ale_linters/gitcommit/gitlint.vim
+++ /dev/null
@@ -1,51 +0,0 @@
-" Author: Nick Yamane <nick.diego@gmail.com>
-" Description: gitlint for git commit message files
-
-call ale#Set('gitcommit_gitlint_executable', 'gitlint')
-call ale#Set('gitcommit_gitlint_options', '')
-call ale#Set('gitcommit_gitlint_use_global', get(g:, 'ale_use_global_executables', 0))
-
-function! ale_linters#gitcommit#gitlint#GetExecutable(buffer) abort
-    return ale#python#FindExecutable(a:buffer, 'gitcommit_gitlint', ['gitlint'])
-endfunction
-
-function! ale_linters#gitcommit#gitlint#GetCommand(buffer) abort
-    let l:options = ale#Var(a:buffer, 'gitcommit_gitlint_options')
-
-    return '%e' . ale#Pad(l:options) . ' lint'
-endfunction
-
-function! ale_linters#gitcommit#gitlint#Handle(buffer, lines) abort
-    " Matches patterns line the following:
-    let l:pattern = '\v^(\d+): (\w+) (.*)$'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        let l:code = l:match[2]
-
-        if !ale#Var(a:buffer, 'warn_about_trailing_whitespace')
-            if l:code is# 'T2' || l:code is# 'B2'
-                continue
-            endif
-        endif
-
-        let l:item = {
-        \   'lnum': l:match[1] + 0,
-        \   'text': l:match[3],
-        \   'code': l:code,
-        \   'type': 'E',
-        \}
-
-        call add(l:output, l:item)
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('gitcommit', {
-\   'name': 'gitlint',
-\   'output_stream': 'stderr',
-\   'executable': function('ale_linters#gitcommit#gitlint#GetExecutable'),
-\   'command': function('ale_linters#gitcommit#gitlint#GetCommand'),
-\   'callback': 'ale_linters#gitcommit#gitlint#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/glsl/glslang.vim b/sources_non_forked/ale/ale_linters/glsl/glslang.vim
deleted file mode 100644
index bbddce9..0000000
--- a/sources_non_forked/ale/ale_linters/glsl/glslang.vim
+++ /dev/null
@@ -1,40 +0,0 @@
-" Author: Sven-Hendrik Haase <svenstaro@gmail.com>
-" Description: glslang-based linter for glsl files
-"
-" TODO: Once https://github.com/KhronosGroup/glslang/pull/1047 is accepted,
-" we can use stdin.
-
-call ale#Set('glsl_glslang_executable', 'glslangValidator')
-call ale#Set('glsl_glslang_options', '')
-
-function! ale_linters#glsl#glslang#GetCommand(buffer) abort
-    return '%e'
-    \   . ale#Pad(ale#Var(a:buffer, 'glsl_glslang_options'))
-    \   . ' -C %t'
-endfunction
-
-function! ale_linters#glsl#glslang#Handle(buffer, lines) abort
-    " Matches patterns like the following:
-    "
-    " ERROR: 0:5: 'foo' : undeclared identifier
-    let l:pattern = '^\(.\+\): \(\d\+\):\(\d\+\): \(.\+\)'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        call add(l:output, {
-        \   'lnum': str2nr(l:match[3]),
-        \   'col': str2nr(l:match[2]),
-        \   'text': l:match[4],
-        \   'type': l:match[1] is# 'ERROR' ? 'E' : 'W',
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('glsl', {
-\   'name': 'glslang',
-\   'executable': {b -> ale#Var(b, 'glsl_glslang_executable')},
-\   'command': function('ale_linters#glsl#glslang#GetCommand'),
-\   'callback': 'ale_linters#glsl#glslang#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/glsl/glslls.vim b/sources_non_forked/ale/ale_linters/glsl/glslls.vim
deleted file mode 100644
index b62844c..0000000
--- a/sources_non_forked/ale/ale_linters/glsl/glslls.vim
+++ /dev/null
@@ -1,30 +0,0 @@
-" Author: Sven-Hendrik Haase <svenstaro@gmail.com>
-" Description: A language server for glsl
-
-call ale#Set('glsl_glslls_executable', 'glslls')
-call ale#Set('glsl_glslls_logfile', '')
-
-function! ale_linters#glsl#glslls#GetCommand(buffer) abort
-    let l:logfile = ale#Var(a:buffer, 'glsl_glslls_logfile')
-    let l:logfile_args = ''
-
-    if l:logfile isnot# ''
-        let l:logfile_args = ' --verbose -l ' . l:logfile
-    endif
-
-    return '%e' . l:logfile_args . ' --stdin'
-endfunction
-
-function! ale_linters#glsl#glslls#GetProjectRoot(buffer) abort
-    let l:project_root = ale#c#FindProjectRoot(a:buffer)
-
-    return !empty(l:project_root) ? fnamemodify(l:project_root, ':h:h') : ''
-endfunction
-
-call ale#linter#Define('glsl', {
-\   'name': 'glslls',
-\   'lsp': 'stdio',
-\   'executable': {b -> ale#Var(b, 'glsl_glslls_executable')},
-\   'command': function('ale_linters#glsl#glslls#GetCommand'),
-\   'project_root': function('ale_linters#glsl#glslls#GetProjectRoot'),
-\})
diff --git a/sources_non_forked/ale/ale_linters/go/bingo.vim b/sources_non_forked/ale/ale_linters/go/bingo.vim
deleted file mode 100644
index 1e43f8e..0000000
--- a/sources_non_forked/ale/ale_linters/go/bingo.vim
+++ /dev/null
@@ -1,31 +0,0 @@
-" Author: Jerko Steiner <https://github.com/jeremija>
-" Description: https://github.com/saibing/bingo
-
-call ale#Set('go_bingo_executable', 'bingo')
-call ale#Set('go_bingo_options', '--mode stdio')
-
-function! ale_linters#go#bingo#GetCommand(buffer) abort
-    return ale#go#EnvString(a:buffer) . '%e' . ale#Pad(ale#Var(a:buffer, 'go_bingo_options'))
-endfunction
-
-function! ale_linters#go#bingo#FindProjectRoot(buffer) abort
-    let l:go_modules_off = ale#Var(a:buffer, 'go_go111module') is# 'off'
-    let l:project_root = l:go_modules_off ?
-    \ '' : ale#path#FindNearestFile(a:buffer, 'go.mod')
-    let l:mods = ':h'
-
-    if empty(l:project_root)
-        let l:project_root = ale#path#FindNearestDirectory(a:buffer, '.git')
-        let l:mods = ':h:h'
-    endif
-
-    return !empty(l:project_root) ? fnamemodify(l:project_root, l:mods) : ''
-endfunction
-
-call ale#linter#Define('go', {
-\   'name': 'bingo',
-\   'lsp': 'stdio',
-\   'executable': {b -> ale#Var(b, 'go_bingo_executable')},
-\   'command': function('ale_linters#go#bingo#GetCommand'),
-\   'project_root': function('ale_linters#go#bingo#FindProjectRoot'),
-\})
diff --git a/sources_non_forked/ale/ale_linters/go/gobuild.vim b/sources_non_forked/ale/ale_linters/go/gobuild.vim
deleted file mode 100644
index 1dfb6da..0000000
--- a/sources_non_forked/ale/ale_linters/go/gobuild.vim
+++ /dev/null
@@ -1,57 +0,0 @@
-" Author: Joshua Rubin <joshua@rubixconsulting.com>, Ben Reedy <https://github.com/breed808>,
-" Jeff Willette <jrwillette88@gmail.com>
-" Description: go build for Go files
-" inspired by work from dzhou121 <dzhou121@gmail.com>
-
-call ale#Set('go_go_executable', 'go')
-call ale#Set('go_gobuild_options', '')
-
-function! ale_linters#go#gobuild#GetCommand(buffer) abort
-    let l:options = ale#Var(a:buffer, 'go_gobuild_options')
-
-    " Run go test in local directory with relative path
-    return ale#path#BufferCdString(a:buffer)
-    \   . ale#go#EnvString(a:buffer)
-    \   . ale#Var(a:buffer, 'go_go_executable') . ' test'
-    \   . (!empty(l:options) ? ' ' . l:options : '')
-    \   . ' -c -o /dev/null ./'
-endfunction
-
-function! ale_linters#go#gobuild#GetMatches(lines) abort
-    " Matches patterns like the following:
-    "
-    " file.go:27: missing argument for Printf("%s"): format reads arg 2, have only 1 args
-    " file.go:53:10: if block ends with a return statement, so drop this else and outdent its block (move short variable declaration to its own line if necessary)
-    " file.go:5:2: expected declaration, found 'STRING' "log"
-    " go test returns relative paths so use tail of filename as part of pattern matcher
-    let l:pattern = '\v^([a-zA-Z]?:?[^:]+):(\d+):?(\d+)?:? (.+)$'
-
-    return ale#util#GetMatches(a:lines, l:pattern)
-endfunction
-
-function! ale_linters#go#gobuild#Handler(buffer, lines) abort
-    let l:dir = expand('#' . a:buffer . ':p:h')
-    let l:output = []
-
-    for l:match in ale_linters#go#gobuild#GetMatches(a:lines)
-        call add(l:output, {
-        \   'filename': ale#path#GetAbsPath(l:dir, l:match[1]),
-        \   'lnum': l:match[2] + 0,
-        \   'col': l:match[3] + 0,
-        \   'text': l:match[4],
-        \   'type': 'E',
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('go', {
-\   'name': 'gobuild',
-\   'aliases': ['go build'],
-\   'executable': {b -> ale#Var(b, 'go_go_executable')},
-\   'command': function('ale_linters#go#gobuild#GetCommand'),
-\   'output_stream': 'stderr',
-\   'callback': 'ale_linters#go#gobuild#Handler',
-\   'lint_file': 1,
-\})
diff --git a/sources_non_forked/ale/ale_linters/go/gofmt.vim b/sources_non_forked/ale/ale_linters/go/gofmt.vim
deleted file mode 100644
index a233b42..0000000
--- a/sources_non_forked/ale/ale_linters/go/gofmt.vim
+++ /dev/null
@@ -1,16 +0,0 @@
-" Author: neersighted <bjorn@neersighted.com>
-" Description: gofmt for Go files
-
-function! ale_linters#go#gofmt#GetCommand(buffer) abort
-    return ale#go#EnvString(a:buffer)
-    \   . '%e -e %t'
-endfunction
-
-
-call ale#linter#Define('go', {
-\   'name': 'gofmt',
-\   'output_stream': 'stderr',
-\   'executable': 'gofmt',
-\   'command': function('ale_linters#go#gofmt#GetCommand'),
-\   'callback': 'ale#handlers#unix#HandleAsError',
-\})
diff --git a/sources_non_forked/ale/ale_linters/go/golangci_lint.vim b/sources_non_forked/ale/ale_linters/go/golangci_lint.vim
deleted file mode 100644
index dd0e975..0000000
--- a/sources_non_forked/ale/ale_linters/go/golangci_lint.vim
+++ /dev/null
@@ -1,59 +0,0 @@
-" Author: Sascha Grunert <mail@saschagrunert.de>
-" Description: Adds support of golangci-lint
-
-call ale#Set('go_golangci_lint_options', '--enable-all')
-call ale#Set('go_golangci_lint_executable', 'golangci-lint')
-call ale#Set('go_golangci_lint_package', 0)
-
-function! ale_linters#go#golangci_lint#GetCommand(buffer) abort
-    let l:filename = expand('#' . a:buffer . ':t')
-    let l:options = ale#Var(a:buffer, 'go_golangci_lint_options')
-    let l:lint_package = ale#Var(a:buffer, 'go_golangci_lint_package')
-
-
-    if l:lint_package
-        return ale#path#BufferCdString(a:buffer)
-        \   . ale#go#EnvString(a:buffer)
-        \   . '%e run '
-        \   .  l:options
-    endif
-
-    return ale#path#BufferCdString(a:buffer)
-    \   . ale#go#EnvString(a:buffer)
-    \   . '%e run '
-    \   . ale#Escape(l:filename)
-    \   . ' ' . l:options
-endfunction
-
-function! ale_linters#go#golangci_lint#GetMatches(lines) abort
-    let l:pattern = '\v^([a-zA-Z]?:?[^:]+):(\d+):?(\d+)?:?:?:?\s\*?(.+)$'
-
-    return ale#util#GetMatches(a:lines, l:pattern)
-endfunction
-
-function! ale_linters#go#golangci_lint#Handler(buffer, lines) abort
-    let l:dir = expand('#' . a:buffer . ':p:h')
-    let l:output = []
-
-    for l:match in ale_linters#go#golangci_lint#GetMatches(a:lines)
-        " l:match[1] will already be an absolute path, output from
-        " golangci_lint
-        call add(l:output, {
-        \   'filename': ale#path#GetAbsPath(l:dir, l:match[1]),
-        \   'lnum': l:match[2] + 0,
-        \   'col': l:match[3] + 0,
-        \   'type': 'E',
-        \   'text': l:match[4],
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('go', {
-\   'name': 'golangci-lint',
-\   'executable': {b -> ale#Var(b, 'go_golangci_lint_executable')},
-\   'command': function('ale_linters#go#golangci_lint#GetCommand'),
-\   'callback': 'ale_linters#go#golangci_lint#Handler',
-\   'lint_file': 1,
-\})
diff --git a/sources_non_forked/ale/ale_linters/go/golint.vim b/sources_non_forked/ale/ale_linters/go/golint.vim
deleted file mode 100644
index 79bfaeb..0000000
--- a/sources_non_forked/ale/ale_linters/go/golint.vim
+++ /dev/null
@@ -1,21 +0,0 @@
-" Author: neersighted <bjorn@neersighted.com>
-" Description: golint for Go files
-
-call ale#Set('go_golint_executable', 'golint')
-call ale#Set('go_golint_options', '')
-
-function! ale_linters#go#golint#GetCommand(buffer) abort
-    let l:options = ale#Var(a:buffer, 'go_golint_options')
-
-    return ale#go#EnvString(a:buffer) . '%e'
-    \   . (!empty(l:options) ? ' ' . l:options : '')
-    \   . ' %t'
-endfunction
-
-call ale#linter#Define('go', {
-\   'name': 'golint',
-\   'output_stream': 'both',
-\   'executable': {b -> ale#Var(b, 'go_golint_executable')},
-\   'command': function('ale_linters#go#golint#GetCommand'),
-\   'callback': 'ale#handlers#unix#HandleAsWarning',
-\})
diff --git a/sources_non_forked/ale/ale_linters/go/gometalinter.vim b/sources_non_forked/ale/ale_linters/go/gometalinter.vim
deleted file mode 100644
index eed9550..0000000
--- a/sources_non_forked/ale/ale_linters/go/gometalinter.vim
+++ /dev/null
@@ -1,59 +0,0 @@
-" Author: Ben Reedy <https://github.com/breed808>, Jeff Willette <jrwillette88@gmail.com>
-" Description: Adds support for the gometalinter suite for Go files
-
-call ale#Set('go_gometalinter_options', '')
-call ale#Set('go_gometalinter_executable', 'gometalinter')
-call ale#Set('go_gometalinter_lint_package', 0)
-
-function! ale_linters#go#gometalinter#GetCommand(buffer) abort
-    let l:filename = expand('#' . a:buffer . ':t')
-    let l:options = ale#Var(a:buffer, 'go_gometalinter_options')
-    let l:lint_package = ale#Var(a:buffer, 'go_gometalinter_lint_package')
-
-    " BufferCdString is used so that we can be sure the paths output from gometalinter can
-    " be calculated to absolute paths in the Handler
-    if l:lint_package
-        return ale#path#BufferCdString(a:buffer)
-        \   . ale#go#EnvString(a:buffer)
-        \   . '%e'
-        \   . (!empty(l:options) ? ' ' . l:options : '') . ' .'
-    endif
-
-    return ale#path#BufferCdString(a:buffer)
-    \   . ale#go#EnvString(a:buffer)
-    \   . '%e'
-    \   . ' --include=' . ale#Escape(ale#util#EscapePCRE(l:filename))
-    \   . (!empty(l:options) ? ' ' . l:options : '') . ' .'
-endfunction
-
-function! ale_linters#go#gometalinter#GetMatches(lines) abort
-    let l:pattern = '\v^([a-zA-Z]?:?[^:]+):(\d+):?(\d+)?:?:?(warning|error):?\s\*?(.+)$'
-
-    return ale#util#GetMatches(a:lines, l:pattern)
-endfunction
-
-function! ale_linters#go#gometalinter#Handler(buffer, lines) abort
-    let l:dir = expand('#' . a:buffer . ':p:h')
-    let l:output = []
-
-    for l:match in ale_linters#go#gometalinter#GetMatches(a:lines)
-        " l:match[1] will already be an absolute path, output from gometalinter
-        call add(l:output, {
-        \   'filename': ale#path#GetAbsPath(l:dir, l:match[1]),
-        \   'lnum': l:match[2] + 0,
-        \   'col': l:match[3] + 0,
-        \   'type': tolower(l:match[4]) is# 'warning' ? 'W' : 'E',
-        \   'text': l:match[5],
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('go', {
-\   'name': 'gometalinter',
-\   'executable': {b -> ale#Var(b, 'go_gometalinter_executable')},
-\   'command': function('ale_linters#go#gometalinter#GetCommand'),
-\   'callback': 'ale_linters#go#gometalinter#Handler',
-\   'lint_file': 1,
-\})
diff --git a/sources_non_forked/ale/ale_linters/go/gopls.vim b/sources_non_forked/ale/ale_linters/go/gopls.vim
deleted file mode 100644
index dcff5ec..0000000
--- a/sources_non_forked/ale/ale_linters/go/gopls.vim
+++ /dev/null
@@ -1,34 +0,0 @@
-" Author: w0rp <devw0rp@gmail.com>
-" Author: Jerko Steiner <https://github.com/jeremija>
-" Description: https://github.com/saibing/gopls
-
-call ale#Set('go_gopls_executable', 'gopls')
-call ale#Set('go_gopls_options', '--mode stdio')
-
-function! ale_linters#go#gopls#GetCommand(buffer) abort
-    return ale#go#EnvString(a:buffer)
-    \   . '%e'
-    \   . ale#Pad(ale#Var(a:buffer, 'go_gopls_options'))
-endfunction
-
-function! ale_linters#go#gopls#FindProjectRoot(buffer) abort
-    let l:go_modules_off = ale#Var(a:buffer, 'go_go111module') is# 'off'
-    let l:project_root = l:go_modules_off ?
-    \ '' : ale#path#FindNearestFile(a:buffer, 'go.mod')
-    let l:mods = ':h'
-
-    if empty(l:project_root)
-        let l:project_root = ale#path#FindNearestDirectory(a:buffer, '.git')
-        let l:mods = ':h:h'
-    endif
-
-    return !empty(l:project_root) ? fnamemodify(l:project_root, l:mods) : ''
-endfunction
-
-call ale#linter#Define('go', {
-\   'name': 'gopls',
-\   'lsp': 'stdio',
-\   'executable': {b -> ale#Var(b, 'go_gopls_executable')},
-\   'command': function('ale_linters#go#gopls#GetCommand'),
-\   'project_root': function('ale_linters#go#gopls#FindProjectRoot'),
-\})
diff --git a/sources_non_forked/ale/ale_linters/go/gosimple.vim b/sources_non_forked/ale/ale_linters/go/gosimple.vim
deleted file mode 100644
index ad52c62..0000000
--- a/sources_non_forked/ale/ale_linters/go/gosimple.vim
+++ /dev/null
@@ -1,16 +0,0 @@
-" Author: Ben Reedy <https://github.com/breed808>
-" Description: gosimple for Go files
-
-function! ale_linters#go#gosimple#GetCommand(buffer) abort
-    return ale#path#BufferCdString(a:buffer) . ' '
-    \   . ale#go#EnvString(a:buffer) . 'gosimple .'
-endfunction
-
-call ale#linter#Define('go', {
-\   'name': 'gosimple',
-\   'executable': 'gosimple',
-\   'command': function('ale_linters#go#gosimple#GetCommand'),
-\   'callback': 'ale#handlers#go#Handler',
-\   'output_stream': 'both',
-\   'lint_file': 1,
-\})
diff --git a/sources_non_forked/ale/ale_linters/go/gotype.vim b/sources_non_forked/ale/ale_linters/go/gotype.vim
deleted file mode 100644
index 6a5149c..0000000
--- a/sources_non_forked/ale/ale_linters/go/gotype.vim
+++ /dev/null
@@ -1,20 +0,0 @@
-" Author: Jelte Fennema <github-public@jeltef.nl>
-" Description: gotype for Go files
-
-function! ale_linters#go#gotype#GetCommand(buffer) abort
-    if expand('#' . a:buffer . ':p') =~# '_test\.go$'
-        return ''
-    endif
-
-    return ale#path#BufferCdString(a:buffer) . ' '
-    \   . ale#go#EnvString(a:buffer) . 'gotype -e .'
-endfunction
-
-call ale#linter#Define('go', {
-\   'name': 'gotype',
-\   'output_stream': 'stderr',
-\   'executable': 'gotype',
-\   'command': function('ale_linters#go#gotype#GetCommand'),
-\   'callback': 'ale#handlers#go#Handler',
-\   'lint_file': 1,
-\})
diff --git a/sources_non_forked/ale/ale_linters/go/govet.vim b/sources_non_forked/ale/ale_linters/go/govet.vim
deleted file mode 100644
index dddafe1..0000000
--- a/sources_non_forked/ale/ale_linters/go/govet.vim
+++ /dev/null
@@ -1,28 +0,0 @@
-" Author: neersighted <bjorn@neersighted.com>
-" Description: go vet for Go files
-"
-" Author: John Eikenberry <jae@zhar.net>
-" Description: updated to work with go1.10
-
-call ale#Set('go_go_executable', 'go')
-call ale#Set('go_govet_options', '')
-
-function! ale_linters#go#govet#GetCommand(buffer) abort
-    let l:options = ale#Var(a:buffer, 'go_govet_options')
-
-    return ale#path#BufferCdString(a:buffer) . ' '
-    \   . ale#go#EnvString(a:buffer)
-    \   . ale#Var(a:buffer, 'go_go_executable') . ' vet '
-    \   . (!empty(l:options) ? ' ' . l:options : '')
-    \   . ' .'
-endfunction
-
-call ale#linter#Define('go', {
-\   'name': 'govet',
-\   'aliases': ['go vet'],
-\   'output_stream': 'stderr',
-\   'executable': {b -> ale#Var(b, 'go_go_executable')},
-\   'command': function('ale_linters#go#govet#GetCommand'),
-\   'callback': 'ale#handlers#go#Handler',
-\   'lint_file': 1,
-\})
diff --git a/sources_non_forked/ale/ale_linters/go/langserver.vim b/sources_non_forked/ale/ale_linters/go/langserver.vim
deleted file mode 100644
index 7130db4..0000000
--- a/sources_non_forked/ale/ale_linters/go/langserver.vim
+++ /dev/null
@@ -1,29 +0,0 @@
-" Author: Horacio Sanson <https://github.com/hsanson>
-" Description: Support for go-langserver https://github.com/sourcegraph/go-langserver
-
-call ale#Set('go_langserver_executable', 'go-langserver')
-call ale#Set('go_langserver_options', '')
-
-function! ale_linters#go#langserver#GetCommand(buffer) abort
-    let l:executable = [ale#Escape(ale#Var(a:buffer, 'go_langserver_executable'))]
-    let l:options = ale#Var(a:buffer, 'go_langserver_options')
-    let l:options = substitute(l:options, '-gocodecompletion', '', 'g')
-    let l:options = filter(split(l:options, ' '), 'empty(v:val) != 1')
-
-    if ale#Var(a:buffer, 'completion_enabled')
-        call add(l:options, '-gocodecompletion')
-    endif
-
-    let l:options = uniq(sort(l:options))
-    let l:env = ale#go#EnvString(a:buffer)
-
-    return l:env . join(extend(l:executable, l:options), ' ')
-endfunction
-
-call ale#linter#Define('go', {
-\   'name': 'golangserver',
-\   'lsp': 'stdio',
-\   'executable': {b -> ale#Var(b, 'go_langserver_executable')},
-\   'command': function('ale_linters#go#langserver#GetCommand'),
-\   'project_root': function('ale#go#FindProjectRoot'),
-\})
diff --git a/sources_non_forked/ale/ale_linters/go/revive.vim b/sources_non_forked/ale/ale_linters/go/revive.vim
deleted file mode 100644
index b14b5ab..0000000
--- a/sources_non_forked/ale/ale_linters/go/revive.vim
+++ /dev/null
@@ -1,21 +0,0 @@
-" Author: Penghui Liao <liaoishere@gmail.com>
-" Description: Adds support for revive
-
-call ale#Set('go_revive_executable', 'revive')
-call ale#Set('go_revive_options', '')
-
-function! ale_linters#go#revive#GetCommand(buffer) abort
-    let l:options = ale#Var(a:buffer, 'go_revive_options')
-
-    return ale#go#EnvString(a:buffer) . '%e'
-    \   . (!empty(l:options) ? ' ' . l:options : '')
-    \   . ' %t'
-endfunction
-
-call ale#linter#Define('go', {
-\   'name': 'revive',
-\   'output_stream': 'both',
-\   'executable': {b -> ale#Var(b, 'go_revive_executable')},
-\   'command': function('ale_linters#go#revive#GetCommand'),
-\   'callback': 'ale#handlers#unix#HandleAsWarning',
-\})
diff --git a/sources_non_forked/ale/ale_linters/go/staticcheck.vim b/sources_non_forked/ale/ale_linters/go/staticcheck.vim
deleted file mode 100644
index ed40c6c..0000000
--- a/sources_non_forked/ale/ale_linters/go/staticcheck.vim
+++ /dev/null
@@ -1,34 +0,0 @@
-" Author: Ben Reedy <https://github.com/breed808>
-" Description: staticcheck for Go files
-
-call ale#Set('go_staticcheck_options', '')
-call ale#Set('go_staticcheck_lint_package', 0)
-
-function! ale_linters#go#staticcheck#GetCommand(buffer) abort
-    let l:filename = expand('#' . a:buffer . ':t')
-    let l:options = ale#Var(a:buffer, 'go_staticcheck_options')
-    let l:lint_package = ale#Var(a:buffer, 'go_staticcheck_lint_package')
-    let l:env = ale#go#EnvString(a:buffer)
-
-    " BufferCdString is used so that we can be sure the paths output from
-    " staticcheck can be calculated to absolute paths in the Handler
-    if l:lint_package
-        return ale#path#BufferCdString(a:buffer)
-        \   . l:env . 'staticcheck'
-        \   . (!empty(l:options) ? ' ' . l:options : '') . ' .'
-    endif
-
-    return ale#path#BufferCdString(a:buffer)
-    \   . l:env . 'staticcheck'
-    \   . (!empty(l:options) ? ' ' . l:options : '')
-    \   . ' ' . ale#Escape(l:filename)
-endfunction
-
-call ale#linter#Define('go', {
-\   'name': 'staticcheck',
-\   'executable': 'staticcheck',
-\   'command': function('ale_linters#go#staticcheck#GetCommand'),
-\   'callback': 'ale#handlers#go#Handler',
-\   'output_stream': 'both',
-\   'lint_file': 1,
-\})
diff --git a/sources_non_forked/ale/ale_linters/graphql/eslint.vim b/sources_non_forked/ale/ale_linters/graphql/eslint.vim
deleted file mode 100644
index aed1a37..0000000
--- a/sources_non_forked/ale/ale_linters/graphql/eslint.vim
+++ /dev/null
@@ -1,9 +0,0 @@
-" Author: Benjie Gillam <code@benjiegillam.com>
-" Description: eslint for GraphQL files
-
-call ale#linter#Define('graphql', {
-\   'name': 'eslint',
-\   'executable': function('ale#handlers#eslint#GetExecutable'),
-\   'command': function('ale#handlers#eslint#GetCommand'),
-\   'callback': 'ale#handlers#eslint#HandleJSON',
-\})
diff --git a/sources_non_forked/ale/ale_linters/graphql/gqlint.vim b/sources_non_forked/ale/ale_linters/graphql/gqlint.vim
deleted file mode 100644
index d5029de..0000000
--- a/sources_non_forked/ale/ale_linters/graphql/gqlint.vim
+++ /dev/null
@@ -1,15 +0,0 @@
-" Author: Michiel Westerbeek <happylinks@gmail.com>
-" Description: Linter for GraphQL Schemas
-
-function! ale_linters#graphql#gqlint#GetCommand(buffer) abort
-    return ale#path#BufferCdString(a:buffer)
-    \   . 'gqlint'
-    \   . ' --reporter=simple %t'
-endfunction
-
-call ale#linter#Define('graphql', {
-\   'name': 'gqlint',
-\   'executable': 'gqlint',
-\   'command': function('ale_linters#graphql#gqlint#GetCommand'),
-\   'callback': 'ale#handlers#unix#HandleAsWarning',
-\})
diff --git a/sources_non_forked/ale/ale_linters/hack/hack.vim b/sources_non_forked/ale/ale_linters/hack/hack.vim
deleted file mode 100644
index 822b5c8..0000000
--- a/sources_non_forked/ale/ale_linters/hack/hack.vim
+++ /dev/null
@@ -1,22 +0,0 @@
-" Author: Fred Emmott <fe@fb.com>
-" Description: Hack support via `hack lsp`
-
-call ale#Set('hack_hack_executable', 'hh_client')
-
-function! ale_linters#hack#hack#GetProjectRoot(buffer) abort
-    let l:hhconfig = ale#path#FindNearestFile(a:buffer, '.hhconfig')
-
-    return !empty(l:hhconfig) ? fnamemodify(l:hhconfig, ':h') : ''
-endfunction
-
-function! ale_linters#hack#hack#GetExecutable(buffer) abort
-    return ale#Var(a:buffer, 'hack_hack_executable')
-endfunction
-
-call ale#linter#Define('hack', {
-\   'name': 'hack',
-\   'lsp': 'stdio',
-\   'executable': function('ale_linters#hack#hack#GetExecutable'),
-\   'command': '%e lsp --from vim-ale',
-\   'project_root': function('ale_linters#hack#hack#GetProjectRoot'),
-\})
diff --git a/sources_non_forked/ale/ale_linters/hack/hhast.vim b/sources_non_forked/ale/ale_linters/hack/hhast.vim
deleted file mode 100644
index 5e6d4de..0000000
--- a/sources_non_forked/ale/ale_linters/hack/hhast.vim
+++ /dev/null
@@ -1,40 +0,0 @@
-" Author: Fred Emmott <fe@fb.com>
-" Description: Hack support via `hhast lsp`
-
-call ale#Set('hack_hhast_executable', 'vendor/bin/hhast-lint')
-
-function! ale_linters#hack#hhast#GetProjectRoot(buffer) abort
-    " Find the hack root, then figure out if it's also an HHAST root.
-    " Don't try to use lint configurations from vendor/foo/bar/hhast-lint.json
-    let l:hhconfig = ale#path#FindNearestFile(a:buffer, '.hhconfig')
-
-    if empty(l:hhconfig)
-        return ''
-    endif
-
-    let l:root = fnamemodify(l:hhconfig, ':h')
-    let l:hhast_config = findfile('hhast-lint.json', l:root)
-
-    return !empty(l:hhast_config) ? l:root : ''
-endfunction
-
-function! ale_linters#hack#hhast#GetExecutable(buffer) abort
-    let l:root = ale_linters#hack#hhast#GetProjectRoot(a:buffer)
-    let l:relative = ale#Var(a:buffer, 'hack_hhast_executable')
-    let l:absolute = findfile(l:relative, l:root)
-
-    return !empty(l:absolute) ? l:absolute : ''
-endfunction
-
-function! ale_linters#hack#hhast#GetInitializationOptions(buffer) abort
-    return {'lintMode': 'open-files'}
-endfunction
-
-call ale#linter#Define('hack', {
-\   'name': 'hhast',
-\   'lsp': 'stdio',
-\   'executable': function('ale_linters#hack#hhast#GetExecutable'),
-\   'command': '%e --mode lsp --from vim-ale',
-\   'project_root': function('ale_linters#hack#hhast#GetProjectRoot'),
-\   'initialization_options': function('ale_linters#hack#hhast#GetInitializationOptions'),
-\})
diff --git a/sources_non_forked/ale/ale_linters/haml/hamllint.vim b/sources_non_forked/ale/ale_linters/haml/hamllint.vim
deleted file mode 100644
index 9fcd999..0000000
--- a/sources_non_forked/ale/ale_linters/haml/hamllint.vim
+++ /dev/null
@@ -1,57 +0,0 @@
-" Author: Patrick Lewis - https://github.com/patricklewis, thenoseman - https://github.com/thenoseman
-" Description: haml-lint for Haml files
-
-call ale#Set('haml_hamllint_executable', 'haml-lint')
-
-function! ale_linters#haml#hamllint#GetExecutable(buffer) abort
-    return ale#Var(a:buffer, 'haml_hamllint_executable')
-endfunction
-
-function! ale_linters#haml#hamllint#GetCommand(buffer) abort
-    let l:prefix = ''
-
-    let l:rubocop_config_file_path = ale#path#FindNearestFile(a:buffer, '.rubocop.yml')
-    let l:hamllint_config_file_path = ale#path#FindNearestFile(a:buffer, '.haml-lint.yml')
-
-    " Set HAML_LINT_RUBOCOP_CONF variable as it is needed for haml-lint to
-    " pick up the rubocop config.
-    "
-    " See https://github.com/brigade/haml-lint/blob/master/lib/haml_lint/linter/rubocop.rb#L89
-    "     HamlLint::Linter::RuboCop#rubocop_flags
-    if !empty(l:rubocop_config_file_path)
-        if has('win32')
-            let l:prefix = 'set HAML_LINT_RUBOCOP_CONF=' . ale#Escape(l:rubocop_config_file_path) . ' &&'
-        else
-            let l:prefix = 'HAML_LINT_RUBOCOP_CONF=' . ale#Escape(l:rubocop_config_file_path)
-        endif
-    endif
-
-    return (!empty(l:prefix) ? l:prefix . ' ' : '')
-    \   . ale_linters#haml#hamllint#GetExecutable(a:buffer)
-    \   . (!empty(l:hamllint_config_file_path) ? ' --config ' . ale#Escape(l:hamllint_config_file_path) : '')
-    \   . ' %t'
-endfunction
-
-function! ale_linters#haml#hamllint#Handle(buffer, lines) abort
-    " Matches patterns like the following:
-    " <path>:51 [W] RuboCop: Use the new Ruby 1.9 hash syntax.
-    let l:pattern = '\v^.*:(\d+) \[([EW])\] (.+)$'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        call add(l:output, {
-        \   'lnum': l:match[1] + 0,
-        \   'type': l:match[2],
-        \   'text': l:match[3]
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('haml', {
-\   'name': 'hamllint',
-\   'executable': function('ale_linters#haml#hamllint#GetExecutable'),
-\   'command': function('ale_linters#haml#hamllint#GetCommand'),
-\   'callback': 'ale_linters#haml#hamllint#Handle'
-\})
diff --git a/sources_non_forked/ale/ale_linters/handlebars/embertemplatelint.vim b/sources_non_forked/ale/ale_linters/handlebars/embertemplatelint.vim
deleted file mode 100644
index 74bd6a9..0000000
--- a/sources_non_forked/ale/ale_linters/handlebars/embertemplatelint.vim
+++ /dev/null
@@ -1,39 +0,0 @@
-" Author: Adrian Zalewski <aazalewski@hotmail.com>
-" Description: Ember-template-lint for checking Handlebars files
-
-call ale#Set('handlebars_embertemplatelint_executable', 'ember-template-lint')
-call ale#Set('handlebars_embertemplatelint_use_global', get(g:, 'ale_use_global_executables', 0))
-
-function! ale_linters#handlebars#embertemplatelint#Handle(buffer, lines) abort
-    let l:output = []
-    let l:json = ale#util#FuzzyJSONDecode(a:lines, {})
-
-    for l:error in get(values(l:json), 0, [])
-        if has_key(l:error, 'fatal')
-            call add(l:output, {
-            \   'lnum': get(l:error, 'line', 1),
-            \   'col': get(l:error, 'column', 1),
-            \   'text': l:error.message,
-            \   'type': l:error.severity == 1 ? 'W' : 'E',
-            \})
-        else
-            call add(l:output, {
-            \   'lnum': l:error.line,
-            \   'col': l:error.column,
-            \   'text': l:error.rule . ': ' . l:error.message,
-            \   'type': l:error.severity == 1 ? 'W' : 'E',
-            \})
-        endif
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('handlebars', {
-\   'name': 'ember-template-lint',
-\   'executable': {b -> ale#node#FindExecutable(b, 'handlebars_embertemplatelint', [
-\       'node_modules/.bin/ember-template-lint',
-\   ])},
-\   'command': '%e --json %t',
-\   'callback': 'ale_linters#handlebars#embertemplatelint#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/haskell/cabal_ghc.vim b/sources_non_forked/ale/ale_linters/haskell/cabal_ghc.vim
deleted file mode 100644
index f3f248f..0000000
--- a/sources_non_forked/ale/ale_linters/haskell/cabal_ghc.vim
+++ /dev/null
@@ -1,20 +0,0 @@
-" Author: Eric Wolf <ericwolf42@gmail.com>
-" Description: ghc for Haskell files called with cabal exec
-
-call ale#Set('haskell_cabal_ghc_options', '-fno-code -v0')
-
-function! ale_linters#haskell#cabal_ghc#GetCommand(buffer) abort
-    return ale#path#BufferCdString(a:buffer)
-    \   . 'cabal exec -- ghc '
-    \   . ale#Var(a:buffer, 'haskell_cabal_ghc_options')
-    \   . ' %t'
-endfunction
-
-call ale#linter#Define('haskell', {
-\   'name': 'cabal_ghc',
-\   'aliases': ['cabal-ghc'],
-\   'output_stream': 'stderr',
-\   'executable': 'cabal',
-\   'command': function('ale_linters#haskell#cabal_ghc#GetCommand'),
-\   'callback': 'ale#handlers#haskell#HandleGHCFormat',
-\})
diff --git a/sources_non_forked/ale/ale_linters/haskell/ghc.vim b/sources_non_forked/ale/ale_linters/haskell/ghc.vim
deleted file mode 100644
index 9c3906b..0000000
--- a/sources_non_forked/ale/ale_linters/haskell/ghc.vim
+++ /dev/null
@@ -1,18 +0,0 @@
-" Author: w0rp <devw0rp@gmail.com>
-" Description: ghc for Haskell files
-
-call ale#Set('haskell_ghc_options', '-fno-code -v0')
-
-function! ale_linters#haskell#ghc#GetCommand(buffer) abort
-    return 'ghc '
-    \   . ale#Var(a:buffer, 'haskell_ghc_options')
-    \   . ' %t'
-endfunction
-
-call ale#linter#Define('haskell', {
-\   'name': 'ghc',
-\   'output_stream': 'stderr',
-\   'executable': 'ghc',
-\   'command': function('ale_linters#haskell#ghc#GetCommand'),
-\   'callback': 'ale#handlers#haskell#HandleGHCFormat',
-\})
diff --git a/sources_non_forked/ale/ale_linters/haskell/ghc_mod.vim b/sources_non_forked/ale/ale_linters/haskell/ghc_mod.vim
deleted file mode 100644
index 30e96b4..0000000
--- a/sources_non_forked/ale/ale_linters/haskell/ghc_mod.vim
+++ /dev/null
@@ -1,19 +0,0 @@
-" Author: wizzup <wizzup@gmail.com>
-" Description: ghc-mod for Haskell files
-
-call ale#Set('haskell_ghc_mod_executable', 'ghc-mod')
-
-function! ale_linters#haskell#ghc_mod#GetCommand (buffer) abort
-    let l:executable = ale#Var(a:buffer, 'haskell_ghc_mod_executable')
-
-    return ale#handlers#haskell_stack#EscapeExecutable(l:executable, 'ghc-mod')
-    \   . ' --map-file %s=%t check %s'
-endfunction
-
-call ale#linter#Define('haskell', {
-\   'name': 'ghc_mod',
-\   'aliases': ['ghc-mod'],
-\   'executable': {b -> ale#Var(b, 'haskell_ghc_mod_executable')},
-\   'command': function('ale_linters#haskell#ghc_mod#GetCommand'),
-\   'callback': 'ale#handlers#haskell#HandleGHCFormat',
-\})
diff --git a/sources_non_forked/ale/ale_linters/haskell/hdevtools.vim b/sources_non_forked/ale/ale_linters/haskell/hdevtools.vim
deleted file mode 100644
index 3e55e4f..0000000
--- a/sources_non_forked/ale/ale_linters/haskell/hdevtools.vim
+++ /dev/null
@@ -1,20 +0,0 @@
-" Author: rob-b, Takano Akio <tak@anoak.io>
-" Description: hdevtools for Haskell files
-
-call ale#Set('haskell_hdevtools_executable', 'hdevtools')
-call ale#Set('haskell_hdevtools_options', get(g:, 'hdevtools_options', '-g -Wall'))
-
-function! ale_linters#haskell#hdevtools#GetCommand(buffer) abort
-    let l:executable = ale#Var(a:buffer, 'haskell_hdevtools_executable')
-
-    return ale#handlers#haskell_stack#EscapeExecutable(l:executable, 'hdevtools')
-    \ . ' check' . ale#Pad(ale#Var(a:buffer, 'haskell_hdevtools_options'))
-    \ . ' -p %s %t'
-endfunction
-
-call ale#linter#Define('haskell', {
-\   'name': 'hdevtools',
-\   'executable': {b -> ale#Var(b, 'haskell_hdevtools_executable')},
-\   'command': function('ale_linters#haskell#hdevtools#GetCommand'),
-\   'callback': 'ale#handlers#haskell#HandleGHCFormat',
-\})
diff --git a/sources_non_forked/ale/ale_linters/haskell/hie.vim b/sources_non_forked/ale/ale_linters/haskell/hie.vim
deleted file mode 100644
index c4b5f1d..0000000
--- a/sources_non_forked/ale/ale_linters/haskell/hie.vim
+++ /dev/null
@@ -1,41 +0,0 @@
-" Author: Luxed <devildead13@gmail.com>
-" Description: A language server for Haskell
-
-call ale#Set('haskell_hie_executable', 'hie')
-
-function! ale_linters#haskell#hie#GetProjectRoot(buffer) abort
-    " Search for the stack file first
-    let l:project_file = ale#path#FindNearestFile(a:buffer, 'stack.yaml')
-
-    " If it's empty, search for the cabal file
-    if empty(l:project_file)
-        " Search all of the paths except for the root filesystem path.
-        let l:paths = join(
-        \   ale#path#Upwards(expand('#' . a:buffer . ':p:h'))[:-2],
-        \   ','
-        \)
-        let l:project_file = globpath(l:paths, '*.cabal')
-    endif
-
-    " If we still can't find one, use the current file.
-    if empty(l:project_file)
-        let l:project_file = expand('#' . a:buffer . ':p')
-    endif
-
-    return fnamemodify(l:project_file, ':h')
-endfunction
-
-function! ale_linters#haskell#hie#GetCommand(buffer) abort
-    let l:executable = ale#Var(a:buffer, 'haskell_hie_executable')
-
-    return ale#handlers#haskell_stack#EscapeExecutable(l:executable, 'hie')
-    \   . ' --lsp'
-endfunction
-
-call ale#linter#Define('haskell', {
-\   'name': 'hie',
-\   'lsp': 'stdio',
-\   'command': function('ale_linters#haskell#hie#GetCommand'),
-\   'executable': {b -> ale#Var(b, 'haskell_hie_executable')},
-\   'project_root': function('ale_linters#haskell#hie#GetProjectRoot'),
-\})
diff --git a/sources_non_forked/ale/ale_linters/haskell/hlint.vim b/sources_non_forked/ale/ale_linters/haskell/hlint.vim
deleted file mode 100644
index 1425251..0000000
--- a/sources_non_forked/ale/ale_linters/haskell/hlint.vim
+++ /dev/null
@@ -1,46 +0,0 @@
-" Author: jparoz <jesse.paroz@gmail.com>
-" Description: hlint for Haskell files
-
-call ale#Set('haskell_hlint_executable', 'hlint')
-call ale#Set('haskell_hlint_options', get(g:, 'hlint_options', ''))
-
-function! ale_linters#haskell#hlint#Handle(buffer, lines) abort
-    let l:output = []
-
-    for l:error in ale#util#FuzzyJSONDecode(a:lines, [])
-        if l:error.severity is# 'Error'
-            let l:type = 'E'
-        elseif l:error.severity is# 'Suggestion'
-            let l:type = 'I'
-        else
-            let l:type = 'W'
-        endif
-
-        call add(l:output, {
-        \   'lnum': str2nr(l:error.startLine),
-        \   'col': str2nr(l:error.startColumn),
-        \   'end_lnum': str2nr(l:error.endLine),
-        \   'end_col': str2nr(l:error.endColumn),
-        \   'text': l:error.severity . ': ' . l:error.hint . '. Found: ' . l:error.from . ' Why not: ' . l:error.to,
-        \   'type': l:type,
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-function! ale_linters#haskell#hlint#GetCommand(buffer) abort
-    let l:hlintopts = '--color=never --json'
-
-    return ale#handlers#hlint#GetExecutable(a:buffer)
-    \      . ' ' . ale#Var(a:buffer, 'haskell_hlint_options')
-    \      . ' ' . l:hlintopts
-    \      . ' -'
-endfunction
-
-call ale#linter#Define('haskell', {
-\   'name': 'hlint',
-\   'executable': {b -> ale#Var(b, 'haskell_hlint_executable')},
-\   'command': function('ale_linters#haskell#hlint#GetCommand') ,
-\   'callback': 'ale_linters#haskell#hlint#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/haskell/stack_build.vim b/sources_non_forked/ale/ale_linters/haskell/stack_build.vim
deleted file mode 100644
index 8f2d9fd..0000000
--- a/sources_non_forked/ale/ale_linters/haskell/stack_build.vim
+++ /dev/null
@@ -1,23 +0,0 @@
-" Author: Jake Zimmerman <jake@zimmerman.io>
-" Description: Like stack-ghc, but for entire projects
-"
-" Note: Ideally, this would *only* typecheck. Right now, it also does codegen.
-" See <https://github.com/commercialhaskell/stack/issues/977>.
-
-call ale#Set('haskell_stack_build_options', '--fast')
-
-function! ale_linters#haskell#stack_build#GetCommand(buffer) abort
-    let l:flags = ale#Var(a:buffer, 'haskell_stack_build_options')
-
-    return 'stack build ' . l:flags
-endfunction
-
-call ale#linter#Define('haskell', {
-\   'name': 'stack_build',
-\   'aliases': ['stack-build'],
-\   'output_stream': 'stderr',
-\   'executable': function('ale#handlers#haskell#GetStackExecutable'),
-\   'command': function('ale_linters#haskell#stack_build#GetCommand'),
-\   'lint_file': 1,
-\   'callback': 'ale#handlers#haskell#HandleGHCFormat',
-\})
diff --git a/sources_non_forked/ale/ale_linters/haskell/stack_ghc.vim b/sources_non_forked/ale/ale_linters/haskell/stack_ghc.vim
deleted file mode 100644
index c345fe4..0000000
--- a/sources_non_forked/ale/ale_linters/haskell/stack_ghc.vim
+++ /dev/null
@@ -1,21 +0,0 @@
-" Author: w0rp <devw0rp@gmail.com>
-" Description: ghc for Haskell files, using Stack
-
-call ale#Set('haskell_stack_ghc_options', '-fno-code -v0')
-
-function! ale_linters#haskell#stack_ghc#GetCommand(buffer) abort
-    return ale#path#BufferCdString(a:buffer)
-    \ . ale#handlers#haskell#GetStackExecutable(a:buffer)
-    \ . ' ghc -- '
-    \ . ale#Var(a:buffer, 'haskell_stack_ghc_options')
-    \ . ' %t'
-endfunction
-
-call ale#linter#Define('haskell', {
-\   'name': 'stack_ghc',
-\   'aliases': ['stack-ghc'],
-\   'output_stream': 'stderr',
-\   'executable': function('ale#handlers#haskell#GetStackExecutable'),
-\   'command': function('ale_linters#haskell#stack_ghc#GetCommand'),
-\   'callback': 'ale#handlers#haskell#HandleGHCFormat',
-\})
diff --git a/sources_non_forked/ale/ale_linters/help/alex.vim b/sources_non_forked/ale/ale_linters/help/alex.vim
deleted file mode 100644
index 9be00a8..0000000
--- a/sources_non_forked/ale/ale_linters/help/alex.vim
+++ /dev/null
@@ -1,4 +0,0 @@
-" Author: Johannes Wienke <languitar@semipol.de>
-" Description: alex for help files
-
-call ale#handlers#alex#DefineLinter('help', '--text')
diff --git a/sources_non_forked/ale/ale_linters/help/proselint.vim b/sources_non_forked/ale/ale_linters/help/proselint.vim
deleted file mode 100644
index 6212450..0000000
--- a/sources_non_forked/ale/ale_linters/help/proselint.vim
+++ /dev/null
@@ -1,9 +0,0 @@
-" Author: Daniel M. Capella https://github.com/polyzen
-" Description: proselint for Vim help files
-
-call ale#linter#Define('help', {
-\   'name': 'proselint',
-\   'executable': 'proselint',
-\   'command': 'proselint %t',
-\   'callback': 'ale#handlers#unix#HandleAsWarning',
-\})
diff --git a/sources_non_forked/ale/ale_linters/help/writegood.vim b/sources_non_forked/ale/ale_linters/help/writegood.vim
deleted file mode 100644
index eeb21a7..0000000
--- a/sources_non_forked/ale/ale_linters/help/writegood.vim
+++ /dev/null
@@ -1,4 +0,0 @@
-" Author: Sumner Evans <sumner.evans98@gmail.com>
-" Description: write-good for vim Help files
-
-call ale#handlers#writegood#DefineLinter('help')
diff --git a/sources_non_forked/ale/ale_linters/html/alex.vim b/sources_non_forked/ale/ale_linters/html/alex.vim
deleted file mode 100644
index 9775675..0000000
--- a/sources_non_forked/ale/ale_linters/html/alex.vim
+++ /dev/null
@@ -1,4 +0,0 @@
-" Author: Johannes Wienke <languitar@semipol.de>
-" Description: alex for HTML files
-
-call ale#handlers#alex#DefineLinter('html', '--html')
diff --git a/sources_non_forked/ale/ale_linters/html/fecs.vim b/sources_non_forked/ale/ale_linters/html/fecs.vim
deleted file mode 100644
index 15e00e1..0000000
--- a/sources_non_forked/ale/ale_linters/html/fecs.vim
+++ /dev/null
@@ -1,9 +0,0 @@
-" Author: harttle <yangjvn@126.com>
-" Description: fecs for HTMl files
-
-call ale#linter#Define('html', {
-\   'name': 'fecs',
-\   'executable': function('ale#handlers#fecs#GetExecutable'),
-\   'command': function('ale#handlers#fecs#GetCommand'),
-\   'callback': 'ale#handlers#fecs#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/html/htmlhint.vim b/sources_non_forked/ale/ale_linters/html/htmlhint.vim
deleted file mode 100644
index 3e01f51..0000000
--- a/sources_non_forked/ale/ale_linters/html/htmlhint.vim
+++ /dev/null
@@ -1,32 +0,0 @@
-" Author: KabbAmine <amine.kabb@gmail.com>, deathmaz <00maz1987@gmail.com>, diartyz <diartyz@gmail.com>
-" Description: HTMLHint for checking html files
-
-call ale#Set('html_htmlhint_options', '')
-call ale#Set('html_htmlhint_executable', 'htmlhint')
-call ale#Set('html_htmlhint_use_global', get(g:, 'ale_use_global_executables', 0))
-
-function! ale_linters#html#htmlhint#GetCommand(buffer) abort
-    let l:options = ale#Var(a:buffer, 'html_htmlhint_options')
-    let l:config = l:options !~# '--config'
-    \   ? ale#path#FindNearestFile(a:buffer, '.htmlhintrc')
-    \   : ''
-
-    if !empty(l:config)
-        let l:options .= ' --config ' . ale#Escape(l:config)
-    endif
-
-    if !empty(l:options)
-        let l:options = substitute(l:options, '--format=unix', '', '')
-    endif
-
-    return '%e' . ale#Pad(l:options) . ' --format=unix %t'
-endfunction
-
-call ale#linter#Define('html', {
-\   'name': 'htmlhint',
-\   'executable': {b -> ale#node#FindExecutable(b, 'html_htmlhint', [
-\       'node_modules/.bin/htmlhint',
-\   ])},
-\   'command': function('ale_linters#html#htmlhint#GetCommand'),
-\   'callback': 'ale#handlers#unix#HandleAsError',
-\})
diff --git a/sources_non_forked/ale/ale_linters/html/proselint.vim b/sources_non_forked/ale/ale_linters/html/proselint.vim
deleted file mode 100644
index 9fd7d67..0000000
--- a/sources_non_forked/ale/ale_linters/html/proselint.vim
+++ /dev/null
@@ -1,9 +0,0 @@
-" Author: Daniel M. Capella https://github.com/polyzen
-" Description: proselint for HTML files
-
-call ale#linter#Define('html', {
-\   'name': 'proselint',
-\   'executable': 'proselint',
-\   'command': 'proselint %t',
-\   'callback': 'ale#handlers#unix#HandleAsWarning',
-\})
diff --git a/sources_non_forked/ale/ale_linters/html/stylelint.vim b/sources_non_forked/ale/ale_linters/html/stylelint.vim
deleted file mode 100644
index ae8955f..0000000
--- a/sources_non_forked/ale/ale_linters/html/stylelint.vim
+++ /dev/null
@@ -1,27 +0,0 @@
-" Author: Filipe Kiss <hello@filipekiss.com.br> http://github.com/filipekiss
-
-call ale#Set('html_stylelint_executable', 'stylelint')
-call ale#Set('html_stylelint_options', '')
-call ale#Set('html_stylelint_use_global', 0)
-
-function! ale_linters#html#stylelint#GetExecutable(buffer) abort
-    return ale#node#FindExecutable(a:buffer, 'html_stylelint', [
-    \   'node_modules/.bin/stylelint',
-    \])
-endfunction
-
-function! ale_linters#html#stylelint#GetCommand(buffer) abort
-    let l:executable = ale_linters#html#stylelint#GetExecutable(a:buffer)
-    let l:options = ale#Var(a:buffer, 'html_stylelint_options')
-
-    return ale#Escape(l:executable)
-    \   . (!empty(l:options) ? ' ' . l:options : '')
-    \   . ' --stdin-filename %s'
-endfunction
-
-call ale#linter#Define('html', {
-\   'name': 'stylelint',
-\   'executable': function('ale_linters#html#stylelint#GetExecutable'),
-\   'command': function('ale_linters#html#stylelint#GetCommand'),
-\   'callback': 'ale#handlers#css#HandleStyleLintFormat',
-\})
diff --git a/sources_non_forked/ale/ale_linters/html/tidy.vim b/sources_non_forked/ale/ale_linters/html/tidy.vim
deleted file mode 100644
index 1e476d4..0000000
--- a/sources_non_forked/ale/ale_linters/html/tidy.vim
+++ /dev/null
@@ -1,70 +0,0 @@
-" Author: KabbAmine <amine.kabb@gmail.com>
-" Description: This file adds support for checking HTML code with tidy.
-
-let g:ale_html_tidy_executable = get(g:, 'ale_html_tidy_executable', 'tidy')
-let g:ale_html_tidy_options = get(g:, 'ale_html_tidy_options', '-q -e -language en')
-
-function! ale_linters#html#tidy#GetCommand(buffer) abort
-    " Specify file encoding in options
-    " (Idea taken from https://github.com/scrooloose/syntastic/blob/master/syntax_checkers/html/tidy.vim)
-    let l:file_encoding = get({
-    \   'ascii':        '-ascii',
-    \   'big5':         '-big5',
-    \   'cp1252':       '-win1252',
-    \   'cp850':        '-ibm858',
-    \   'cp932':        '-shiftjis',
-    \   'iso-2022-jp':  '-iso-2022',
-    \   'latin1':       '-latin1',
-    \   'macroman':     '-mac',
-    \   'sjis':         '-shiftjis',
-    \   'utf-16le':     '-utf16le',
-    \   'utf-16':       '-utf16',
-    \   'utf-8':        '-utf8',
-    \ }, &fileencoding, '-utf8')
-
-    " On macOS, old tidy (released on 31 Oct 2006) is installed. It does not
-    " consider HTML5 so we should avoid it.
-    let l:executable = ale#Var(a:buffer, 'html_tidy_executable')
-
-    if has('mac') && l:executable is# 'tidy' && exists('*exepath')
-    \  && exepath(l:executable) is# '/usr/bin/tidy'
-        return ''
-    endif
-
-    return printf('%s %s %s -',
-    \   l:executable,
-    \   ale#Var(a:buffer, 'html_tidy_options'),
-    \   l:file_encoding
-    \)
-endfunction
-
-function! ale_linters#html#tidy#Handle(buffer, lines) abort
-    " Matches patterns lines like the following:
-    " line 7 column 5 - Warning: missing </title> before </head>
-    let l:pattern = '^line \(\d\+\) column \(\d\+\) - \(Warning\|Error\): \(.\+\)$'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        let l:line = l:match[1] + 0
-        let l:col = l:match[2] + 0
-        let l:type = l:match[3] is# 'Error' ? 'E' : 'W'
-        let l:text = l:match[4]
-
-        call add(l:output, {
-        \   'lnum': l:line,
-        \   'col': l:col,
-        \   'text': l:text,
-        \   'type': l:type,
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('html', {
-\   'name': 'tidy',
-\   'executable': {b -> ale#Var(b, 'html_tidy_executable')},
-\   'output_stream': 'stderr',
-\   'command': function('ale_linters#html#tidy#GetCommand'),
-\   'callback': 'ale_linters#html#tidy#Handle',
-\ })
diff --git a/sources_non_forked/ale/ale_linters/html/writegood.vim b/sources_non_forked/ale/ale_linters/html/writegood.vim
deleted file mode 100644
index 6a2bd8e..0000000
--- a/sources_non_forked/ale/ale_linters/html/writegood.vim
+++ /dev/null
@@ -1,4 +0,0 @@
-" Author: Sumner Evans <sumner.evans98@gmail.com>
-" Description: write-good for html files
-
-call ale#handlers#writegood#DefineLinter('html')
diff --git a/sources_non_forked/ale/ale_linters/idris/idris.vim b/sources_non_forked/ale/ale_linters/idris/idris.vim
deleted file mode 100644
index 879e92f..0000000
--- a/sources_non_forked/ale/ale_linters/idris/idris.vim
+++ /dev/null
@@ -1,81 +0,0 @@
-" Author: Scott Bonds <scott@ggr.com>
-" Description: default Idris compiler
-
-call ale#Set('idris_idris_executable', 'idris')
-call ale#Set('idris_idris_options', '--total --warnpartial --warnreach --warnipkg')
-
-function! ale_linters#idris#idris#GetCommand(buffer) abort
-    let l:options = ale#Var(a:buffer, 'idris_idris_options')
-
-    return '%e' . ale#Pad(l:options) . ' --check %s'
-endfunction
-
-function! ale_linters#idris#idris#Handle(buffer, lines) abort
-    " This was copied almost verbatim from ale#handlers#haskell#HandleGHCFormat
-    "
-    " Look for lines like the following:
-    " foo.idr:2:6:When checking right hand side of main with expected type
-    " bar.idr:11:11-13:
-    let l:pattern = '\v^([a-zA-Z]?:?[^:]+):(\d+):(\d+)(-\d+)?:(.*)?$'
-    let l:output = []
-
-    let l:corrected_lines = []
-
-    for l:line in a:lines
-        if len(matchlist(l:line, l:pattern)) > 0
-            call add(l:corrected_lines, l:line)
-        elseif len(l:corrected_lines) > 0
-            if l:line is# ''
-                let l:corrected_lines[-1] .= ' ' " turn a blank line into a space
-            else
-                let l:corrected_lines[-1] .= l:line
-            endif
-
-            let l:corrected_lines[-1] = substitute(l:corrected_lines[-1], '\s\+', ' ', 'g')
-        endif
-    endfor
-
-    for l:line in l:corrected_lines
-        let l:match = matchlist(l:line, l:pattern)
-
-        if len(l:match) == 0
-            continue
-        endif
-
-        if !ale#path#IsBufferPath(a:buffer, l:match[1])
-            continue
-        endif
-
-        let l:errors = matchlist(l:match[5], '\v([wW]arning|[eE]rror) - ?(.*)')
-
-        if len(l:errors) > 0
-            let l:ghc_type = l:errors[1]
-            let l:text = l:errors[2]
-        else
-            let l:ghc_type = ''
-            let l:text = l:match[5][:0] is# ' ' ? l:match[5][1:] : l:match[5]
-        endif
-
-        if l:ghc_type is? 'Warning'
-            let l:type = 'W'
-        else
-            let l:type = 'E'
-        endif
-
-        call add(l:output, {
-        \   'lnum': l:match[2] + 0,
-        \   'col': l:match[3] + 0,
-        \   'text': l:text,
-        \   'type': l:type,
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('idris', {
-\   'name': 'idris',
-\   'executable': {b -> ale#Var(b, 'idris_idris_executable')},
-\   'command': function('ale_linters#idris#idris#GetCommand'),
-\   'callback': 'ale_linters#idris#idris#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/ink/ls.vim b/sources_non_forked/ale/ale_linters/ink/ls.vim
deleted file mode 100644
index 1cc9358..0000000
--- a/sources_non_forked/ale/ale_linters/ink/ls.vim
+++ /dev/null
@@ -1,35 +0,0 @@
-" Author: Andreww Hayworth <ahayworth@gmail.com>
-" Description: Integrate ALE with ink-language-server
-
-call ale#Set('ink_ls_executable', 'ink-language-server')
-call ale#Set('ink_ls_use_global', get(g:, 'ale_use_global_executables', 0))
-call ale#Set('ink_ls_initialization_options', {})
-
-function! ale_linters#ink#ls#GetExecutable(buffer) abort
-    return ale#node#FindExecutable(a:buffer, 'ink_ls', [
-    \   'ink-language-server',
-    \   'node_modules/.bin/ink-language-server',
-    \])
-endfunction
-
-function! ale_linters#ink#ls#GetCommand(buffer) abort
-    let l:executable = ale_linters#ink#ls#GetExecutable(a:buffer)
-
-    return ale#Escape(l:executable) . ' --stdio'
-endfunction
-
-function! ale_linters#ink#ls#FindProjectRoot(buffer) abort
-    let l:main_file = get(ale#Var(a:buffer, 'ink_ls_initialization_options'), 'mainStoryPath', 'main.ink')
-    let l:config = ale#path#ResolveLocalPath(a:buffer, l:main_file, expand('#' . a:buffer . ':p'))
-
-    return ale#path#Dirname(l:config)
-endfunction
-
-call ale#linter#Define('ink', {
-\   'name': 'ink-language-server',
-\   'lsp': 'stdio',
-\   'executable': function('ale_linters#ink#ls#GetExecutable'),
-\   'command': function('ale_linters#ink#ls#GetCommand'),
-\   'project_root': function('ale_linters#ink#ls#FindProjectRoot'),
-\   'initialization_options': {b -> ale#Var(b, 'ink_ls_initialization_options')},
-\})
diff --git a/sources_non_forked/ale/ale_linters/ispc/ispc.vim b/sources_non_forked/ale/ale_linters/ispc/ispc.vim
deleted file mode 100644
index eb36511..0000000
--- a/sources_non_forked/ale/ale_linters/ispc/ispc.vim
+++ /dev/null
@@ -1,45 +0,0 @@
-" Author: Martino Pilia <martino.pilia@gmail.com>
-" Description: Lint ispc files with the Intel(R) SPMD Program Compiler
-
-call ale#Set('ispc_ispc_executable', 'ispc')
-call ale#Set('ispc_ispc_options', '')
-
-function! ale_linters#ispc#ispc#GetCommand(buffer) abort
-    " --nowrap: do not wrap message lines
-    return '%e --nowrap'
-    \   . ale#Pad(ale#c#IncludeOptions(ale#c#FindLocalHeaderPaths(a:buffer)))
-    \   . ale#Pad(ale#Var(a:buffer, 'ispc_ispc_options'))
-    \   . ' %s'
-endfunction
-
-" Note that we ignore the two warnings in the beginning of the compiler output
-" ('no output file specified' and 'no --target specified'), since they have
-" nothing to do with linting.
-function! ale_linters#ispc#ispc#Handle(buffer, lines) abort
-    " Message format: <filename>:<lnum>:<col> <type>: <text>
-    " As far as I know, <type> can be any of:
-    "   'error', 'Error', 'fatal error', 'Warning', 'Performance Warning'
-    let l:re = '\v.+:([0-9]+):([0-9]+):\s+([^:]+):\s+(.+)'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:re)
-        call add(l:output, {
-        \   'bufnr': a:buffer,
-        \   'lnum': str2nr(l:match[1]),
-        \   'col': str2nr(l:match[2]),
-        \   'type': l:match[3] =~? 'error' ? 'E' : 'W',
-        \   'text': l:match[4],
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('ispc', {
-\   'name': 'ispc',
-\   'output_stream': 'stderr',
-\   'executable': {b -> ale#Var(b, 'ispc_ispc_executable')},
-\   'command': function('ale_linters#ispc#ispc#GetCommand'),
-\   'callback': 'ale_linters#ispc#ispc#Handle',
-\   'lint_file': 1,
-\})
diff --git a/sources_non_forked/ale/ale_linters/java/checkstyle.vim b/sources_non_forked/ale/ale_linters/java/checkstyle.vim
deleted file mode 100644
index 7901ff7..0000000
--- a/sources_non_forked/ale/ale_linters/java/checkstyle.vim
+++ /dev/null
@@ -1,71 +0,0 @@
-" Author: Devon Meunier <devon.meunier@gmail.com>
-" Description: checkstyle for Java files
-
-call ale#Set('java_checkstyle_executable', 'checkstyle')
-call ale#Set('java_checkstyle_config', '/google_checks.xml')
-call ale#Set('java_checkstyle_options', '')
-
-function! ale_linters#java#checkstyle#Handle(buffer, lines) abort
-    let l:output = []
-
-    " modern checkstyle versions
-    let l:pattern = '\v\[(WARN|ERROR)\] [a-zA-Z]?:?[^:]+:(\d+):(\d+)?:? (.*) \[(.+)\]$'
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        call add(l:output, {
-        \   'type': l:match[1] is? 'WARN' ? 'W' : 'E',
-        \   'lnum': l:match[2] + 0,
-        \   'col': l:match[3] + 0,
-        \   'text': l:match[4],
-        \   'code': l:match[5],
-        \})
-    endfor
-
-    if !empty(l:output)
-        return l:output
-    endif
-
-    " old checkstyle versions
-    let l:pattern = '\v(.+):(\d+): ([^:]+): (.+)$'
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        call add(l:output, {
-        \   'type': l:match[3] is? 'warning' ? 'W' : 'E',
-        \   'lnum': l:match[2] + 0,
-        \   'text': l:match[4],
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-function! s:GetConfig(buffer, config) abort
-    if ale#path#IsAbsolute(a:config)
-        return a:config
-    endif
-
-    let s:file = ale#path#FindNearestFile(a:buffer, a:config)
-
-    return !empty(s:file) ? s:file : a:config
-endfunction
-
-function! ale_linters#java#checkstyle#GetCommand(buffer) abort
-    let l:options = ale#Var(a:buffer, 'java_checkstyle_options')
-    let l:config_option = ale#Var(a:buffer, 'java_checkstyle_config')
-    let l:config = l:options !~# '\v(^| )-c' && !empty(l:config_option)
-    \   ? s:GetConfig(a:buffer, l:config_option)
-    \   : ''
-
-    return '%e'
-    \ . ale#Pad(l:options)
-    \ . (!empty(l:config) ? ' -c ' . ale#Escape(l:config) : '')
-    \ . ' %s'
-endfunction
-
-call ale#linter#Define('java', {
-\   'name': 'checkstyle',
-\   'executable': {b -> ale#Var(b, 'java_checkstyle_executable')},
-\   'command': function('ale_linters#java#checkstyle#GetCommand'),
-\   'callback': 'ale_linters#java#checkstyle#Handle',
-\   'lint_file': 1,
-\})
diff --git a/sources_non_forked/ale/ale_linters/java/eclipselsp.vim b/sources_non_forked/ale/ale_linters/java/eclipselsp.vim
deleted file mode 100644
index 2bfec04..0000000
--- a/sources_non_forked/ale/ale_linters/java/eclipselsp.vim
+++ /dev/null
@@ -1,180 +0,0 @@
-" Author: Horacio Sanson <https://github.com/hsanson>
-" Description: Support for the Eclipse language server https://github.com/eclipse/eclipse.jdt.ls
-
-let s:version_cache = {}
-
-call ale#Set('java_eclipselsp_path', ale#path#Simplify($HOME . '/eclipse.jdt.ls'))
-call ale#Set('java_eclipselsp_config_path', '')
-call ale#Set('java_eclipselsp_workspace_path', '')
-call ale#Set('java_eclipselsp_executable', 'java')
-call ale#Set('java_eclipselsp_javaagent', '')
-
-function! ale_linters#java#eclipselsp#Executable(buffer) abort
-    return ale#Var(a:buffer, 'java_eclipselsp_executable')
-endfunction
-
-function! ale_linters#java#eclipselsp#TargetPath(buffer) abort
-    return ale#Var(a:buffer, 'java_eclipselsp_path')
-endfunction
-
-function! ale_linters#java#eclipselsp#JarPath(buffer) abort
-    let l:path = ale_linters#java#eclipselsp#TargetPath(a:buffer)
-
-    " Search jar file within repository path when manually built using mvn
-    let l:repo_path = l:path . '/org.eclipse.jdt.ls.product/target/repository'
-    let l:files = globpath(l:repo_path, '**/plugins/org.eclipse.equinox.launcher_\d\.\d\.\d\d\d\.*\.jar', 1, 1)
-
-    if len(l:files) == 1
-        return l:files[0]
-    endif
-
-    " Search jar file within VSCode extensions folder.
-    let l:files = globpath(l:path, '**/plugins/org.eclipse.equinox.launcher_\d\.\d\.\d\d\d\.*\.jar', 1, 1)
-
-    if len(l:files) == 1
-        return l:files[0]
-    endif
-
-    " Search jar file within system package path
-    let l:files = globpath('/usr/share/java/jdtls/plugins', 'org.eclipse.equinox.launcher_\d\.\d\.\d\d\d\.*\.jar', 1, 1)
-
-    if len(l:files) == 1
-        return l:files[0]
-    endif
-
-    return ''
-endfunction
-
-function! ale_linters#java#eclipselsp#ConfigurationPath(buffer) abort
-    let l:path = fnamemodify(ale_linters#java#eclipselsp#JarPath(a:buffer), ':p:h:h')
-    let l:config_path = ale#Var(a:buffer, 'java_eclipselsp_config_path')
-
-    if !empty(l:config_path)
-        return ale#path#Simplify(l:config_path)
-    endif
-
-    if has('win32')
-        let l:path = l:path . '/config_win'
-    elseif has('macunix')
-        let l:path = l:path . '/config_mac'
-    else
-        let l:path = l:path . '/config_linux'
-    endif
-
-    return ale#path#Simplify(l:path)
-endfunction
-
-function! ale_linters#java#eclipselsp#VersionCheck(version_lines) abort
-    return s:GetVersion('', a:version_lines)
-endfunction
-
-function! s:GetVersion(executable, version_lines) abort
-    let l:version = []
-
-    for l:line in a:version_lines
-        let l:match = matchlist(l:line, '\(\d\+\)\.\(\d\+\)\.\(\d\+\)')
-
-        if !empty(l:match)
-            let l:version = [l:match[1] + 0, l:match[2] + 0, l:match[3] + 0]
-            let s:version_cache[a:executable] = l:version
-            break
-        endif
-    endfor
-
-    return l:version
-endfunction
-
-function! ale_linters#java#eclipselsp#CommandWithVersion(buffer, version_lines, meta) abort
-    let l:executable = ale_linters#java#eclipselsp#Executable(a:buffer)
-    let l:version = s:GetVersion(l:executable, a:version_lines)
-
-    return ale_linters#java#eclipselsp#Command(a:buffer, l:version)
-endfunction
-
-function! ale_linters#java#eclipselsp#WorkspacePath(buffer) abort
-    let l:wspath = ale#Var(a:buffer, 'java_eclipselsp_workspace_path')
-
-    if !empty(l:wspath)
-        return l:wspath
-    endif
-
-    return ale#path#Dirname(ale#java#FindProjectRoot(a:buffer))
-endfunction
-
-function! ale_linters#java#eclipselsp#Javaagent(buffer) abort
-    let l:rets = []
-    let l:raw = ale#Var(a:buffer, 'java_eclipselsp_javaagent')
-
-    if empty(l:raw)
-        return ''
-    endif
-
-    let l:jars = split(l:raw)
-
-    for l:jar in l:jars
-        call add(l:rets, ale#Escape('-javaagent:' . l:jar))
-    endfor
-
-    return join(l:rets, ' ')
-endfunction
-
-function! ale_linters#java#eclipselsp#Command(buffer, version) abort
-    let l:path = ale#Var(a:buffer, 'java_eclipselsp_path')
-
-    let l:executable = ale_linters#java#eclipselsp#Executable(a:buffer)
-
-    let l:cmd = [ ale#Escape(l:executable),
-    \ ale_linters#java#eclipselsp#Javaagent(a:buffer),
-    \ '-Declipse.application=org.eclipse.jdt.ls.core.id1',
-    \ '-Dosgi.bundles.defaultStartLevel=4',
-    \ '-Declipse.product=org.eclipse.jdt.ls.core.product',
-    \ '-Dlog.level=ALL',
-    \ '-noverify',
-    \ '-Xmx1G',
-    \ '-jar',
-    \ ale#Escape(ale_linters#java#eclipselsp#JarPath(a:buffer)),
-    \ '-configuration',
-    \ ale#Escape(ale_linters#java#eclipselsp#ConfigurationPath(a:buffer)),
-    \ '-data',
-    \ ale#Escape(ale_linters#java#eclipselsp#WorkspacePath(a:buffer))
-    \ ]
-
-    if ale#semver#GTE(a:version, [1, 9])
-        call add(l:cmd, '--add-modules=ALL-SYSTEM')
-        call add(l:cmd, '--add-opens java.base/java.util=ALL-UNNAMED')
-        call add(l:cmd, '--add-opens java.base/java.lang=ALL-UNNAMED')
-    endif
-
-    return join(l:cmd, ' ')
-endfunction
-
-function! ale_linters#java#eclipselsp#RunWithVersionCheck(buffer) abort
-    let l:executable = ale_linters#java#eclipselsp#Executable(a:buffer)
-
-    if empty(l:executable)
-        return ''
-    endif
-
-    let l:cache = s:version_cache
-
-    if has_key(s:version_cache, l:executable)
-        return ale_linters#java#eclipselsp#Command(a:buffer, s:version_cache[l:executable])
-    endif
-
-    let l:command = ale#Escape(l:executable) . ' -version'
-
-    return ale#command#Run(
-    \ a:buffer,
-    \ l:command,
-    \ function('ale_linters#java#eclipselsp#CommandWithVersion')
-    \)
-endfunction
-
-call ale#linter#Define('java', {
-\   'name': 'eclipselsp',
-\   'lsp': 'stdio',
-\   'executable': function('ale_linters#java#eclipselsp#Executable'),
-\   'command': function('ale_linters#java#eclipselsp#RunWithVersionCheck'),
-\   'language': 'java',
-\   'project_root': function('ale#java#FindProjectRoot'),
-\})
diff --git a/sources_non_forked/ale/ale_linters/java/javac.vim b/sources_non_forked/ale/ale_linters/java/javac.vim
deleted file mode 100644
index f866eb0..0000000
--- a/sources_non_forked/ale/ale_linters/java/javac.vim
+++ /dev/null
@@ -1,166 +0,0 @@
-" Author: farenjihn <farenjihn@gmail.com>, w0rp <devw0rp@gmail.com>
-" Description: Lints java files using javac
-
-let s:classpath_sep = has('unix') ? ':' : ';'
-
-call ale#Set('java_javac_executable', 'javac')
-call ale#Set('java_javac_options', '')
-call ale#Set('java_javac_classpath', '')
-call ale#Set('java_javac_sourcepath', '')
-
-function! ale_linters#java#javac#RunWithImportPaths(buffer) abort
-    let l:command = ''
-    let l:pom_path = ale#path#FindNearestFile(a:buffer, 'pom.xml')
-
-    if !empty(l:pom_path) && executable('mvn')
-        let l:command = ale#path#CdString(fnamemodify(l:pom_path, ':h'))
-        \ . 'mvn dependency:build-classpath'
-    endif
-
-    " Try to use Gradle if Maven isn't available.
-    if empty(l:command)
-        let l:command = ale#gradle#BuildClasspathCommand(a:buffer)
-    endif
-
-    " Try to use Ant if Gradle and Maven aren't available
-    if empty(l:command)
-        let l:command = ale#ant#BuildClasspathCommand(a:buffer)
-    endif
-
-    if empty(l:command)
-        return ale_linters#java#javac#GetCommand(a:buffer, [], {})
-    endif
-
-    return ale#command#Run(
-    \   a:buffer,
-    \   l:command,
-    \   function('ale_linters#java#javac#GetCommand')
-    \)
-endfunction
-
-function! s:BuildClassPathOption(buffer, import_paths) abort
-    " Filter out lines like [INFO], etc.
-    let l:class_paths = filter(a:import_paths[:], 'v:val !~# ''[''')
-    let l:cls_path = ale#Var(a:buffer, 'java_javac_classpath')
-
-    if !empty(l:cls_path) && type(l:cls_path) is v:t_string
-        call extend(l:class_paths, split(l:cls_path, s:classpath_sep))
-    endif
-
-    if !empty(l:cls_path) && type(l:cls_path) is v:t_list
-        call extend(l:class_paths, l:cls_path)
-    endif
-
-    return !empty(l:class_paths)
-    \   ? '-cp ' . ale#Escape(join(l:class_paths, s:classpath_sep))
-    \   : ''
-endfunction
-
-function! ale_linters#java#javac#GetCommand(buffer, import_paths, meta) abort
-    let l:cp_option = s:BuildClassPathOption(a:buffer, a:import_paths)
-    let l:sp_option = ''
-
-    " Find the src directory, for files in this project.
-    let l:src_dir = ale#path#FindNearestDirectory(a:buffer, 'src/main/java')
-    let l:sp_dirs = []
-
-    if !empty(l:src_dir)
-        call add(l:sp_dirs, l:src_dir)
-
-        " Automatically include the jaxb directory too, if it's there.
-        let l:jaxb_dir = fnamemodify(l:src_dir, ':h:h')
-        \   . (has('win32') ? '\jaxb\' : '/jaxb/')
-
-        if isdirectory(l:jaxb_dir)
-            call add(l:sp_dirs, l:jaxb_dir)
-        endif
-    endif
-
-    " Automatically include the test directory, but only for test code.
-    if expand('#' . a:buffer . ':p') =~? '\vsrc[/\\]test[/\\]java'
-        let l:test_dir = ale#path#FindNearestDirectory(a:buffer, 'src/test/java')
-
-        if isdirectory(l:test_dir)
-            call add(l:sp_dirs, l:test_dir)
-        endif
-    endif
-
-    let l:source_paths = []
-    let l:source_path = ale#Var(a:buffer, 'java_javac_sourcepath')
-
-    if !empty(l:source_path) && type(l:source_path) is v:t_string
-        let l:source_paths = split(l:source_path, s:classpath_sep)
-    endif
-
-    if !empty(l:source_path) && type(l:source_path) is v:t_list
-        let l:source_paths = l:source_path
-    endif
-
-    if !empty(l:source_paths)
-        for l:path in l:source_paths
-            let l:sp_path = ale#path#FindNearestDirectory(a:buffer, l:path)
-
-            if !empty(l:sp_path)
-                call add(l:sp_dirs, l:sp_path)
-            endif
-        endfor
-    endif
-
-    if !empty(l:sp_dirs)
-        let l:sp_option = '-sourcepath '
-        \   . ale#Escape(join(l:sp_dirs, s:classpath_sep))
-    endif
-
-    " Create .class files in a temporary directory, which we will delete later.
-    let l:class_file_directory = ale#command#CreateDirectory(a:buffer)
-
-    " Always run javac from the directory the file is in, so we can resolve
-    " relative paths correctly.
-    return ale#path#BufferCdString(a:buffer)
-    \ . '%e -Xlint'
-    \ . ale#Pad(l:cp_option)
-    \ . ale#Pad(l:sp_option)
-    \ . ' -d ' . ale#Escape(l:class_file_directory)
-    \ . ale#Pad(ale#Var(a:buffer, 'java_javac_options'))
-    \ . ' %t'
-endfunction
-
-function! ale_linters#java#javac#Handle(buffer, lines) abort
-    " Look for lines like the following.
-    "
-    " Main.java:13: warning: [deprecation] donaught() in Testclass has been deprecated
-    " Main.java:16: error: ';' expected
-    let l:directory = expand('#' . a:buffer . ':p:h')
-    let l:pattern = '\v^(.*):(\d+): (.{-1,}):(.+)$'
-    let l:col_pattern = '\v^(\s*\^)$'
-    let l:symbol_pattern = '\v^ +symbol: *(class|method) +([^ ]+)'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, [l:pattern, l:col_pattern, l:symbol_pattern])
-        if empty(l:match[2]) && empty(l:match[3])
-            let l:output[-1].col = len(l:match[1])
-        elseif empty(l:match[3])
-            " Add symbols to 'cannot find symbol' errors.
-            if l:output[-1].text is# 'error: cannot find symbol'
-                let l:output[-1].text .= ': ' . l:match[2]
-            endif
-        else
-            call add(l:output, {
-            \   'filename': ale#path#GetAbsPath(l:directory, l:match[1]),
-            \   'lnum': l:match[2] + 0,
-            \   'text': l:match[3] . ':' . l:match[4],
-            \   'type': l:match[3] is# 'error' ? 'E' : 'W',
-            \})
-        endif
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('java', {
-\   'name': 'javac',
-\   'executable': {b -> ale#Var(b, 'java_javac_executable')},
-\   'command': function('ale_linters#java#javac#RunWithImportPaths'),
-\   'output_stream': 'stderr',
-\   'callback': 'ale_linters#java#javac#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/java/javalsp.vim b/sources_non_forked/ale/ale_linters/java/javalsp.vim
deleted file mode 100644
index baf584c..0000000
--- a/sources_non_forked/ale/ale_linters/java/javalsp.vim
+++ /dev/null
@@ -1,55 +0,0 @@
-" Author: Horacio Sanson <https://github.com/hsanson>
-" Description: Support for the Java language server https://github.com/georgewfraser/vscode-javac
-
-call ale#Set('java_javalsp_executable', '')
-call ale#Set('java_javalsp_config', {})
-
-function! ale_linters#java#javalsp#Executable(buffer) abort
-    return ale#Var(a:buffer, 'java_javalsp_executable')
-endfunction
-
-function! ale_linters#java#javalsp#Config(buffer) abort
-    let l:defaults = { 'java': { 'classPath': [], 'externalDependencies': [] } }
-    let l:config = ale#Var(a:buffer, 'java_javalsp_config')
-
-    " Ensure the config dictionary contains both classPath and
-    " externalDependencies keys to avoid a NPE crash on Java Language Server.
-    call extend(l:config, l:defaults, 'keep')
-    call extend(l:config['java'], l:defaults['java'], 'keep')
-
-    return l:config
-endfunction
-
-function! ale_linters#java#javalsp#Command(buffer) abort
-    let l:executable = ale_linters#java#javalsp#Executable(a:buffer)
-
-    if fnamemodify(l:executable, ':t') is# 'java'
-        " For backward compatibility.
-        let l:cmd = [
-        \ ale#Escape(l:executable),
-        \ '--add-exports jdk.compiler/com.sun.tools.javac.api=javacs',
-        \ '--add-exports jdk.compiler/com.sun.tools.javac.code=javacs',
-        \ '--add-exports jdk.compiler/com.sun.tools.javac.comp=javacs',
-        \ '--add-exports jdk.compiler/com.sun.tools.javac.main=javacs',
-        \ '--add-exports jdk.compiler/com.sun.tools.javac.tree=javacs',
-        \ '--add-exports jdk.compiler/com.sun.tools.javac.model=javacs',
-        \ '--add-exports jdk.compiler/com.sun.tools.javac.util=javacs',
-        \ '--add-opens jdk.compiler/com.sun.tools.javac.api=javacs',
-        \ '-m javacs/org.javacs.Main',
-        \]
-
-        return join(l:cmd, ' ')
-    else
-        return ale#Escape(l:executable)
-    endif
-endfunction
-
-call ale#linter#Define('java', {
-\   'name': 'javalsp',
-\   'lsp': 'stdio',
-\   'executable': function('ale_linters#java#javalsp#Executable'),
-\   'command': function('ale_linters#java#javalsp#Command'),
-\   'language': 'java',
-\   'project_root': function('ale#java#FindProjectRoot'),
-\   'lsp_config': function('ale_linters#java#javalsp#Config')
-\})
diff --git a/sources_non_forked/ale/ale_linters/java/pmd.vim b/sources_non_forked/ale/ale_linters/java/pmd.vim
deleted file mode 100644
index a1f4c93..0000000
--- a/sources_non_forked/ale/ale_linters/java/pmd.vim
+++ /dev/null
@@ -1,36 +0,0 @@
-" Author: Johannes Wienke <languitar@semipol.de>
-" Description: PMD for Java files
-
-function! ale_linters#java#pmd#Handle(buffer, lines) abort
-    let l:pattern = '"\(\d\+\)",".*","\(.\+\)","\(\d\+\)","\(\d\+\)","\(.\+\)","\(.\+\)","\(.\+\)"$'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        call add(l:output, {
-        \   'type': 'W',
-        \   'lnum': l:match[4] + 0,
-        \   'text': l:match[5],
-        \   'code': l:match[6] . ' - ' . l:match[7],
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-function! ale_linters#java#pmd#GetCommand(buffer) abort
-    return 'pmd '
-    \ . ale#Var(a:buffer, 'java_pmd_options')
-    \ . ' -f csv'
-    \ . ' -d %t'
-endfunction
-
-if !exists('g:ale_java_pmd_options')
-    let g:ale_java_pmd_options = '-R category/java/bestpractices.xml'
-endif
-
-call ale#linter#Define('java', {
-\   'name': 'pmd',
-\   'executable': 'pmd',
-\   'command': function('ale_linters#java#pmd#GetCommand'),
-\   'callback': 'ale_linters#java#pmd#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/javascript/eslint.vim b/sources_non_forked/ale/ale_linters/javascript/eslint.vim
deleted file mode 100644
index 31fb413..0000000
--- a/sources_non_forked/ale/ale_linters/javascript/eslint.vim
+++ /dev/null
@@ -1,10 +0,0 @@
-" Author: w0rp <devw0rp@gmail.com>
-" Description: eslint for JavaScript files
-
-call ale#linter#Define('javascript', {
-\   'name': 'eslint',
-\   'output_stream': 'both',
-\   'executable': function('ale#handlers#eslint#GetExecutable'),
-\   'command': function('ale#handlers#eslint#GetCommand'),
-\   'callback': 'ale#handlers#eslint#HandleJSON',
-\})
diff --git a/sources_non_forked/ale/ale_linters/javascript/fecs.vim b/sources_non_forked/ale/ale_linters/javascript/fecs.vim
deleted file mode 100644
index e47c0a0..0000000
--- a/sources_non_forked/ale/ale_linters/javascript/fecs.vim
+++ /dev/null
@@ -1,10 +0,0 @@
-" Author: harttle <yangjvn@126.com>
-" Description: fecs for JavaScript files
-
-call ale#linter#Define('javascript', {
-\   'name': 'fecs',
-\   'executable': function('ale#handlers#fecs#GetExecutable'),
-\   'command': function('ale#handlers#fecs#GetCommand'),
-\   'read_buffer': 0,
-\   'callback': 'ale#handlers#fecs#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/javascript/flow.vim b/sources_non_forked/ale/ale_linters/javascript/flow.vim
deleted file mode 100644
index 3135e2e..0000000
--- a/sources_non_forked/ale/ale_linters/javascript/flow.vim
+++ /dev/null
@@ -1,160 +0,0 @@
-" Author: Zach Perrault -- @zperrault
-" Author: Florian Beeres <yuuki@protonmail.com>
-" Description: FlowType checking for JavaScript files
-
-call ale#Set('javascript_flow_executable', 'flow')
-call ale#Set('javascript_flow_use_home_config', 0)
-call ale#Set('javascript_flow_use_global', get(g:, 'ale_use_global_executables', 0))
-call ale#Set('javascript_flow_use_respect_pragma', 1)
-
-function! ale_linters#javascript#flow#GetExecutable(buffer) abort
-    let l:flow_config = ale#path#FindNearestFile(a:buffer, '.flowconfig')
-
-    if empty(l:flow_config)
-        " Don't run Flow if we can't find a .flowconfig file.
-        return ''
-    endif
-
-    " Don't run Flow with a configuration file from the home directory by
-    " default, which can eat all of your RAM.
-    if fnamemodify(l:flow_config, ':h') is? $HOME
-    \&& !ale#Var(a:buffer, 'javascript_flow_use_home_config')
-        return ''
-    endif
-
-    return ale#node#FindExecutable(a:buffer, 'javascript_flow', [
-    \   'node_modules/.bin/flow',
-    \])
-endfunction
-
-function! ale_linters#javascript#flow#GetCommand(buffer, version) abort
-    " If we can parse the version number, then only use --respect-pragma
-    " if the version is >= 0.36.0, which added the argument.
-    let l:use_respect_pragma = ale#Var(a:buffer, 'javascript_flow_use_respect_pragma')
-    \   && (empty(a:version) || ale#semver#GTE(a:version, [0, 36]))
-
-    return '%e check-contents'
-    \   . (l:use_respect_pragma ? ' --respect-pragma': '')
-    \   . ' --json --from ale %s < %t'
-    \   . (!has('win32') ? '; echo' : '')
-endfunction
-
-" Filter lines of flow output until we find the first line where the JSON
-" output starts.
-function! s:GetJSONLines(lines) abort
-    let l:start_index = 0
-
-    for l:line in a:lines
-        if l:line[:0] is# '{'
-            break
-        endif
-
-        let l:start_index += 1
-    endfor
-
-    return a:lines[l:start_index :]
-endfunction
-
-function! s:ExtraErrorMsg(current, new) abort
-    let l:newMsg = ''
-
-    if a:current is# ''
-        " extra messages appear to already have a :
-        let l:newMsg = a:new
-    else
-        let l:newMsg = a:current . ' ' . a:new
-    endif
-
-    return l:newMsg
-endfunction
-
-function! s:GetDetails(error) abort
-    let l:detail = ''
-
-    for l:extra_error in a:error.extra
-        if has_key(l:extra_error, 'message')
-            for l:extra_message in l:extra_error.message
-                let l:detail = s:ExtraErrorMsg(l:detail, l:extra_message.descr)
-            endfor
-        endif
-
-        if has_key(l:extra_error, 'children')
-            for l:child in l:extra_error.children
-                for l:child_message in l:child.message
-                    let l:detail = l:detail . ' ' . l:child_message.descr
-                endfor
-            endfor
-        endif
-    endfor
-
-    return l:detail
-endfunction
-
-function! ale_linters#javascript#flow#Handle(buffer, lines) abort
-    let l:str = join(s:GetJSONLines(a:lines), '')
-
-    if empty(l:str)
-        return []
-    endif
-
-    let l:flow_output = json_decode(l:str)
-    let l:output = []
-
-    for l:error in get(l:flow_output, 'errors', [])
-        " Each error is broken up into parts
-        let l:text = ''
-        let l:line = 0
-        let l:col = 0
-
-        for l:message in l:error.message
-            " Comments have no line of column information, so we skip them.
-            " In certain cases, `l:message.loc.source` points to a different path
-            " than the buffer one, thus we skip this loc information too.
-            if has_key(l:message, 'loc')
-            \&& l:line is# 0
-            \&& ale#path#IsBufferPath(a:buffer, l:message.loc.source)
-                let l:line = l:message.loc.start.line + 0
-                let l:col = l:message.loc.start.column + 0
-            endif
-
-            if l:text is# ''
-                let l:text = l:message.descr . ':'
-            else
-                let l:text = l:text . ' ' . l:message.descr
-            endif
-        endfor
-
-        if has_key(l:error, 'operation')
-            let l:text = l:text . ' See also: ' . l:error.operation.descr
-        endif
-
-        let l:errorToAdd = {
-        \   'lnum': l:line,
-        \   'col': l:col,
-        \   'text': l:text,
-        \   'type': has_key(l:error, 'level') && l:error.level is# 'error' ? 'E' : 'W',
-        \}
-
-        if has_key(l:error, 'extra')
-            let l:errorToAdd.detail = l:errorToAdd.text
-            \   . "\n" . s:GetDetails(l:error)
-        endif
-
-        call add(l:output, l:errorToAdd)
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('javascript', {
-\   'name': 'flow',
-\   'executable': function('ale_linters#javascript#flow#GetExecutable'),
-\   'command': {buffer -> ale#semver#RunWithVersionCheck(
-\       buffer,
-\       ale_linters#javascript#flow#GetExecutable(buffer),
-\       '%e --version',
-\       function('ale_linters#javascript#flow#GetCommand'),
-\   )},
-\   'callback': 'ale_linters#javascript#flow#Handle',
-\   'read_buffer': 0,
-\})
diff --git a/sources_non_forked/ale/ale_linters/javascript/flow_ls.vim b/sources_non_forked/ale/ale_linters/javascript/flow_ls.vim
deleted file mode 100644
index accaaa7..0000000
--- a/sources_non_forked/ale/ale_linters/javascript/flow_ls.vim
+++ /dev/null
@@ -1,28 +0,0 @@
-" Author: t_t <jamestthompson3@gmail.com>
-" Description: Integrate ALE with flow-language-server.
-
-call ale#Set('javascript_flow_ls_executable', 'flow')
-call ale#Set('javascript_flow_ls_use_global',
-\    get(g:, 'ale_use_global_executables', 0)
-\)
-
-function! ale_linters#javascript#flow_ls#FindProjectRoot(buffer) abort
-    let l:flow_config = ale#path#FindNearestFile(a:buffer, '.flowconfig')
-
-    if !empty(l:flow_config)
-        return fnamemodify(l:flow_config, ':h')
-    endif
-
-    return ''
-endfunction
-
-call ale#linter#Define('javascript', {
-\   'name': 'flow-language-server',
-\   'lsp': 'stdio',
-\   'executable': {b -> ale#node#FindExecutable(b, 'javascript_flow_ls', [
-\       'node_modules/.bin/flow',
-\   ])},
-\   'command': '%e lsp --from ale-lsp',
-\   'project_root': function('ale_linters#javascript#flow_ls#FindProjectRoot'),
-\   'language': 'javascript',
-\})
diff --git a/sources_non_forked/ale/ale_linters/javascript/jscs.vim b/sources_non_forked/ale/ale_linters/javascript/jscs.vim
deleted file mode 100644
index 8905b3a..0000000
--- a/sources_non_forked/ale/ale_linters/javascript/jscs.vim
+++ /dev/null
@@ -1,61 +0,0 @@
-" Author: Chris Kyrouac - https://github.com/fijshion
-" Description: jscs for JavaScript files
-
-call ale#Set('javascript_jscs_executable', 'jscs')
-call ale#Set('javascript_jscs_use_global', get(g:, 'ale_use_global_executables', 0))
-
-function! ale_linters#javascript#jscs#GetCommand(buffer) abort
-    " Search for a local JShint config locaation, and default to a global one.
-    let l:jscs_config = ale#path#ResolveLocalPath(
-    \   a:buffer,
-    \   '.jscsrc',
-    \   get(g:, 'ale_jscs_config_loc', '')
-    \)
-
-    let l:command = '%e --reporter inline --no-colors'
-
-    if !empty(l:jscs_config)
-        let l:command .= ' --config ' . ale#Escape(l:jscs_config)
-    endif
-
-    let l:command .= ' -'
-
-    return l:command
-endfunction
-
-function! ale_linters#javascript#jscs#Handle(buffer, lines) abort
-    " Matches patterns looking like the following
-    "
-    " foobar.js: line 2, col 1, Expected indentation of 1 characters
-    "
-    let l:pattern = '\v^.*:\s+line (\d+),\s+col\s+(\d+),\s+(.*)$'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        let l:obj = {
-        \   'lnum': l:match[1] + 0,
-        \   'col': l:match[2] + 0,
-        \   'text': l:match[3]
-        \}
-
-        let l:code_match = matchlist(l:match[3], '\v([^ :]+): (.+)$')
-
-        if !empty(l:code_match)
-            let l:obj.code = l:code_match[1]
-            let l:obj.text = l:code_match[2]
-        endif
-
-        call add(l:output, l:obj)
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('javascript', {
-\   'name': 'jscs',
-\   'executable': {b -> ale#node#FindExecutable(b, 'javascript_jscs', [
-\       'node_modules/.bin/jscs',
-\   ])},
-\   'command': function('ale_linters#javascript#jscs#GetCommand'),
-\   'callback': 'ale_linters#javascript#jscs#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/javascript/jshint.vim b/sources_non_forked/ale/ale_linters/javascript/jshint.vim
deleted file mode 100644
index d80a225..0000000
--- a/sources_non_forked/ale/ale_linters/javascript/jshint.vim
+++ /dev/null
@@ -1,33 +0,0 @@
-" Author: Chris Kyrouac - https://github.com/fijshion
-" Description: JSHint for Javascript files
-
-call ale#Set('javascript_jshint_executable', 'jshint')
-call ale#Set('javascript_jshint_use_global', get(g:, 'ale_use_global_executables', 0))
-
-function! ale_linters#javascript#jshint#GetCommand(buffer) abort
-    " Search for a local JShint config locaation, and default to a global one.
-    let l:jshint_config = ale#path#ResolveLocalPath(
-    \   a:buffer,
-    \   '.jshintrc',
-    \   get(g:, 'ale_jshint_config_loc', '')
-    \)
-
-    let l:command = '%e --reporter unix --extract auto'
-
-    if !empty(l:jshint_config)
-        let l:command .= ' --config ' . ale#Escape(l:jshint_config)
-    endif
-
-    let l:command .= ' --filename %s -'
-
-    return l:command
-endfunction
-
-call ale#linter#Define('javascript', {
-\   'name': 'jshint',
-\   'executable': {b -> ale#node#FindExecutable(b, 'javascript_jshint', [
-\       'node_modules/.bin/jshint',
-\   ])},
-\   'command': function('ale_linters#javascript#jshint#GetCommand'),
-\   'callback': 'ale#handlers#unix#HandleAsError',
-\})
diff --git a/sources_non_forked/ale/ale_linters/javascript/standard.vim b/sources_non_forked/ale/ale_linters/javascript/standard.vim
deleted file mode 100644
index 1990adc..0000000
--- a/sources_non_forked/ale/ale_linters/javascript/standard.vim
+++ /dev/null
@@ -1,32 +0,0 @@
-" Author: Ahmed El Gabri <@ahmedelgabri>
-" Description: standardjs for JavaScript files
-
-call ale#Set('javascript_standard_executable', 'standard')
-call ale#Set('javascript_standard_use_global', get(g:, 'ale_use_global_executables', 0))
-call ale#Set('javascript_standard_options', '')
-
-function! ale_linters#javascript#standard#GetExecutable(buffer) abort
-    return ale#node#FindExecutable(a:buffer, 'javascript_standard', [
-    \   'node_modules/standardx/bin/cmd.js',
-    \   'node_modules/standard/bin/cmd.js',
-    \   'node_modules/semistandard/bin/cmd.js',
-    \   'node_modules/.bin/standard',
-    \])
-endfunction
-
-function! ale_linters#javascript#standard#GetCommand(buffer) abort
-    let l:executable = ale_linters#javascript#standard#GetExecutable(a:buffer)
-    let l:options = ale#Var(a:buffer, 'javascript_standard_options')
-
-    return ale#node#Executable(a:buffer, l:executable)
-    \   . (!empty(l:options) ? ' ' . l:options : '')
-    \   . ' --stdin %s'
-endfunction
-
-" standard uses eslint and the output format is the same
-call ale#linter#Define('javascript', {
-\   'name': 'standard',
-\   'executable': function('ale_linters#javascript#standard#GetExecutable'),
-\   'command': function('ale_linters#javascript#standard#GetCommand'),
-\   'callback': 'ale#handlers#eslint#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/javascript/tsserver.vim b/sources_non_forked/ale/ale_linters/javascript/tsserver.vim
deleted file mode 100644
index 68c252c..0000000
--- a/sources_non_forked/ale/ale_linters/javascript/tsserver.vim
+++ /dev/null
@@ -1,17 +0,0 @@
-" Author: Chaucerbao, w0rp <devw0rp@gmail.com>
-" Description: tsserver integration for ALE
-
-call ale#Set('javascript_tsserver_executable', 'tsserver')
-call ale#Set('javascript_tsserver_config_path', '')
-call ale#Set('javascript_tsserver_use_global', get(g:, 'ale_use_global_executables', 0))
-
-call ale#linter#Define('javascript', {
-\   'name': 'tsserver',
-\   'lsp': 'tsserver',
-\   'executable': {b -> ale#node#FindExecutable(b, 'javascript_tsserver', [
-\       'node_modules/.bin/tsserver',
-\   ])},
-\   'command': '%e',
-\   'project_root': function('ale#handlers#tsserver#GetProjectRoot'),
-\   'language': '',
-\})
diff --git a/sources_non_forked/ale/ale_linters/javascript/xo.vim b/sources_non_forked/ale/ale_linters/javascript/xo.vim
deleted file mode 100644
index e24f4a8..0000000
--- a/sources_non_forked/ale/ale_linters/javascript/xo.vim
+++ /dev/null
@@ -1,26 +0,0 @@
-" Author: Daniel Lupu <lupu.daniel.f@gmail.com>
-" Description: xo for JavaScript files
-
-call ale#Set('javascript_xo_executable', 'xo')
-call ale#Set('javascript_xo_use_global', get(g:, 'ale_use_global_executables', 0))
-call ale#Set('javascript_xo_options', '')
-
-function! ale_linters#javascript#xo#GetExecutable(buffer) abort
-    return ale#node#FindExecutable(a:buffer, 'javascript_xo', [
-    \   'node_modules/.bin/xo',
-    \])
-endfunction
-
-function! ale_linters#javascript#xo#GetCommand(buffer) abort
-    return ale#Escape(ale_linters#javascript#xo#GetExecutable(a:buffer))
-    \   . ' ' . ale#Var(a:buffer, 'javascript_xo_options')
-    \   . ' --reporter json --stdin --stdin-filename %s'
-endfunction
-
-" xo uses eslint and the output format is the same
-call ale#linter#Define('javascript', {
-\   'name': 'xo',
-\   'executable': function('ale_linters#javascript#xo#GetExecutable'),
-\   'command': function('ale_linters#javascript#xo#GetCommand'),
-\   'callback': 'ale#handlers#eslint#HandleJSON',
-\})
diff --git a/sources_non_forked/ale/ale_linters/json/jsonlint.vim b/sources_non_forked/ale/ale_linters/json/jsonlint.vim
deleted file mode 100644
index f677b48..0000000
--- a/sources_non_forked/ale/ale_linters/json/jsonlint.vim
+++ /dev/null
@@ -1,43 +0,0 @@
-" Author: KabbAmine <amine.kabb@gmail.com>, David Sierra <https://github.com/davidsierradz>
-
-call ale#Set('json_jsonlint_executable', 'jsonlint')
-call ale#Set('json_jsonlint_use_global', get(g:, 'ale_use_global_executables', 0))
-
-function! ale_linters#json#jsonlint#GetExecutable(buffer) abort
-    return ale#node#FindExecutable(a:buffer, 'json_jsonlint', [
-    \   'node_modules/.bin/jsonlint',
-    \   'node_modules/jsonlint/lib/cli.js',
-    \])
-endfunction
-
-function! ale_linters#json#jsonlint#GetCommand(buffer) abort
-    let l:executable = ale_linters#json#jsonlint#GetExecutable(a:buffer)
-
-    return ale#node#Executable(a:buffer, l:executable)
-    \   . ' --compact -'
-endfunction
-
-function! ale_linters#json#jsonlint#Handle(buffer, lines) abort
-    " Matches patterns like the following:
-    " line 2, col 15, found: 'STRING' - expected: 'EOF', '}', ',', ']'.
-    let l:pattern = '^line \(\d\+\), col \(\d*\), \(.\+\)$'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        call add(l:output, {
-        \   'lnum': l:match[1] + 0,
-        \   'col': l:match[2] + 0,
-        \   'text': l:match[3],
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('json', {
-\   'name': 'jsonlint',
-\   'executable': function('ale_linters#json#jsonlint#GetExecutable'),
-\   'output_stream': 'stderr',
-\   'command': function('ale_linters#json#jsonlint#GetCommand'),
-\   'callback': 'ale_linters#json#jsonlint#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/julia/languageserver.vim b/sources_non_forked/ale/ale_linters/julia/languageserver.vim
deleted file mode 100644
index 564bec3..0000000
--- a/sources_non_forked/ale/ale_linters/julia/languageserver.vim
+++ /dev/null
@@ -1,21 +0,0 @@
-" Author: Bartolomeo Stellato <bartolomeo.stellato@gmail.com>
-" Description: A language server for Julia
-
-" Set julia executable variable
-call ale#Set('julia_executable', 'julia')
-
-function! ale_linters#julia#languageserver#GetCommand(buffer) abort
-    let l:julia_executable = ale#Var(a:buffer, 'julia_executable')
-    let l:cmd_string = 'using LanguageServer; server = LanguageServer.LanguageServerInstance(isdefined(Base, :stdin) ? stdin : STDIN, isdefined(Base, :stdout) ? stdout : STDOUT, false); server.runlinter = true; run(server);'
-
-    return ale#Escape(l:julia_executable) . ' --startup-file=no --history-file=no -e ' . ale#Escape(l:cmd_string)
-endfunction
-
-call ale#linter#Define('julia', {
-\   'name': 'languageserver',
-\   'lsp': 'stdio',
-\   'executable': {b -> ale#Var(b, 'julia_executable')},
-\   'command': function('ale_linters#julia#languageserver#GetCommand'),
-\   'language': 'julia',
-\   'project_root': function('ale#julia#FindProjectRoot'),
-\})
diff --git a/sources_non_forked/ale/ale_linters/kotlin/kotlinc.vim b/sources_non_forked/ale/ale_linters/kotlin/kotlinc.vim
deleted file mode 100644
index 66c075b..0000000
--- a/sources_non_forked/ale/ale_linters/kotlin/kotlinc.vim
+++ /dev/null
@@ -1,181 +0,0 @@
-" Author: Francis Agyapong <francisgyapong2@gmail.com>
-" Description: A linter for the Kotlin programming language that uses kotlinc
-
-let g:ale_kotlin_kotlinc_options = get(g:, 'ale_kotlin_kotlinc_options', '')
-let g:ale_kotlin_kotlinc_enable_config = get(g:, 'ale_kotlin_kotlinc_enable_config', 0)
-let g:ale_kotlin_kotlinc_config_file = get(g:, 'ale_kotlin_kotlinc_config_file', '.ale_kotlinc_config')
-let g:ale_kotlin_kotlinc_classpath = get(g:, 'ale_kotlin_kotlinc_classpath', '')
-let g:ale_kotlin_kotlinc_sourcepath = get(g:, 'ale_kotlin_kotlinc_sourcepath', '')
-let g:ale_kotlin_kotlinc_use_module_file = get(g:, 'ale_kotlin_kotlinc_use_module_file', 0)
-let g:ale_kotlin_kotlinc_module_filename = get(g:, 'ale_kotlin_kotlinc_module_filename', 'module.xml')
-
-let s:classpath_sep = has('unix') ? ':' : ';'
-
-function! ale_linters#kotlin#kotlinc#RunWithImportPaths(buffer) abort
-    let l:command = ''
-
-    " exec maven/gradle only if classpath is not set
-    if ale#Var(a:buffer, 'kotlin_kotlinc_classpath') isnot# ''
-        return ale_linters#kotlin#kotlinc#GetCommand(a:buffer, [], {})
-    endif
-
-    let l:pom_path = ale#path#FindNearestFile(a:buffer, 'pom.xml')
-
-    if !empty(l:pom_path) && executable('mvn')
-        let l:command = ale#path#CdString(fnamemodify(l:pom_path, ':h'))
-        \   . 'mvn dependency:build-classpath'
-    endif
-
-    " Try to use Gradle if Maven isn't available.
-    if empty(l:command)
-        let l:command = ale#gradle#BuildClasspathCommand(a:buffer)
-    endif
-
-    if empty(l:command)
-        return ale_linters#kotlin#kotlinc#GetCommand(a:buffer, [], {})
-    endif
-
-    return ale#command#Run(
-    \   a:buffer,
-    \   l:command,
-    \   function('ale_linters#kotlin#kotlinc#GetCommand')
-    \)
-endfunction
-
-function! s:BuildClassPathOption(buffer, import_paths) abort
-    " Filter out lines like [INFO], etc.
-    let l:class_paths = filter(a:import_paths[:], 'v:val !~# ''[''')
-    call extend(
-    \   l:class_paths,
-    \   split(ale#Var(a:buffer, 'kotlin_kotlinc_classpath'), s:classpath_sep),
-    \)
-
-    return !empty(l:class_paths)
-    \   ? ' -cp ' . ale#Escape(join(l:class_paths, s:classpath_sep))
-    \   : ''
-endfunction
-
-function! ale_linters#kotlin#kotlinc#GetCommand(buffer, import_paths, meta) abort
-    let l:kotlinc_opts = ale#Var(a:buffer, 'kotlin_kotlinc_options')
-    let l:command = 'kotlinc '
-
-    " If the config file is enabled and readable, source it
-    if ale#Var(a:buffer, 'kotlin_kotlinc_enable_config')
-        let l:conf = expand(ale#Var(a:buffer, 'kotlin_kotlinc_config_file'), 1)
-
-        if filereadable(l:conf)
-            execute 'source ' . fnameescape(l:conf)
-        endif
-    endif
-
-    " If use module and module file is readable use that and return
-    if ale#Var(a:buffer, 'kotlin_kotlinc_use_module_file')
-        let l:module_filename = ale#Escape(expand(ale#Var(a:buffer, 'kotlin_kotlinc_module_filename'), 1))
-
-        if filereadable(l:module_filename)
-            let l:kotlinc_opts .= ' -module ' . l:module_filename
-            let l:command .= 'kotlinc ' . l:kotlinc_opts
-
-            return l:command
-        endif
-    endif
-
-    " We only get here if not using module or the module file not readable
-    if ale#Var(a:buffer, 'kotlin_kotlinc_classpath') isnot# ''
-        let l:kotlinc_opts .= ' -cp ' . ale#Var(a:buffer, 'kotlin_kotlinc_classpath')
-    else
-        " get classpath from maven/gradle
-        let l:kotlinc_opts .= s:BuildClassPathOption(a:buffer, a:import_paths)
-    endif
-
-    let l:fname = ''
-
-    if ale#Var(a:buffer, 'kotlin_kotlinc_sourcepath') isnot# ''
-        let l:fname .= expand(ale#Var(a:buffer, 'kotlin_kotlinc_sourcepath'), 1) . ' '
-    else
-        " Find the src directory for files in this project.
-        let l:project_root = ale#gradle#FindProjectRoot(a:buffer)
-
-        if !empty(l:project_root)
-            let l:src_dir = l:project_root
-        else
-            let l:src_dir = ale#path#FindNearestDirectory(a:buffer, 'src/main/java')
-            \   . ' ' . ale#path#FindNearestDirectory(a:buffer, 'src/main/kotlin')
-        endif
-
-        let l:fname .= expand(l:src_dir, 1) . ' '
-    endif
-
-    let l:fname .= ale#Escape(expand('#' . a:buffer . ':p'))
-    let l:command .= l:kotlinc_opts . ' ' . l:fname
-
-    return l:command
-endfunction
-
-function! ale_linters#kotlin#kotlinc#Handle(buffer, lines) abort
-    let l:code_pattern = '^\(.*\):\([0-9]\+\):\([0-9]\+\):\s\+\(error\|warning\):\s\+\(.*\)'
-    let l:general_pattern = '^\(warning\|error\|info\):\s*\(.*\)'
-    let l:output = []
-
-    for l:line in a:lines
-        let l:match = matchlist(l:line, l:code_pattern)
-
-        if len(l:match) == 0
-            continue
-        endif
-
-        let l:file = l:match[1]
-        let l:line = l:match[2] + 0
-        let l:column = l:match[3] + 0
-        let l:type = l:match[4]
-        let l:text = l:match[5]
-
-        let l:buf_abspath = fnamemodify(l:file, ':p')
-        let l:curbuf_abspath = expand('#' . a:buffer . ':p')
-
-        " Skip if file is not loaded
-        if l:buf_abspath isnot# l:curbuf_abspath
-            continue
-        endif
-
-        let l:type_marker_str = l:type is# 'warning' ? 'W' : 'E'
-
-        call add(l:output, {
-        \   'lnum': l:line,
-        \   'col': l:column,
-        \   'text': l:text,
-        \   'type': l:type_marker_str,
-        \})
-    endfor
-
-    " Non-code related messages
-    for l:line in a:lines
-        let l:match = matchlist(l:line, l:general_pattern)
-
-        if len(l:match) == 0
-            continue
-        endif
-
-        let l:type = l:match[1]
-        let l:text = l:match[2]
-
-        let l:type_marker_str = l:type is# 'warning' || l:type is# 'info' ? 'W' : 'E'
-
-        call add(l:output, {
-        \   'lnum': 1,
-        \   'text': l:text,
-        \   'type': l:type_marker_str,
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('kotlin', {
-\   'name': 'kotlinc',
-\   'executable': 'kotlinc',
-\   'output_stream': 'stderr',
-\   'command': function('ale_linters#kotlin#kotlinc#RunWithImportPaths'),
-\   'callback': 'ale_linters#kotlin#kotlinc#Handle',
-\   'lint_file': 1,
-\})
diff --git a/sources_non_forked/ale/ale_linters/kotlin/ktlint.vim b/sources_non_forked/ale/ale_linters/kotlin/ktlint.vim
deleted file mode 100644
index f038400..0000000
--- a/sources_non_forked/ale/ale_linters/kotlin/ktlint.vim
+++ /dev/null
@@ -1,10 +0,0 @@
-" Author: Francis Agyapong <francisagyapong2@gmail.com>
-" Description: Lint kotlin files using ktlint
-
-call ale#linter#Define('kotlin', {
-\   'name': 'ktlint',
-\   'executable': 'ktlint',
-\   'command': function('ale#handlers#ktlint#GetCommand'),
-\   'callback': 'ale#handlers#ktlint#Handle',
-\   'lint_file': 1
-\})
diff --git a/sources_non_forked/ale/ale_linters/kotlin/languageserver.vim b/sources_non_forked/ale/ale_linters/kotlin/languageserver.vim
deleted file mode 100644
index af78c0e..0000000
--- a/sources_non_forked/ale/ale_linters/kotlin/languageserver.vim
+++ /dev/null
@@ -1,29 +0,0 @@
-" Author: MTDL9 <https://github.com/MTDL9>
-" Description: Support for the Kotlin language server https://github.com/fwcd/KotlinLanguageServer
-
-call ale#Set('kotlin_languageserver_executable', 'kotlin-language-server')
-
-function! ale_linters#kotlin#languageserver#GetProjectRoot(buffer) abort
-    let l:gradle_root = ale#gradle#FindProjectRoot(a:buffer)
-
-    if !empty(l:gradle_root)
-        return l:gradle_root
-    endif
-
-    let l:maven_pom_file = ale#path#FindNearestFile(a:buffer, 'pom.xml')
-
-    if !empty(l:maven_pom_file)
-        return fnamemodify(l:maven_pom_file, ':h')
-    endif
-
-    return ''
-endfunction
-
-call ale#linter#Define('kotlin', {
-\   'name': 'languageserver',
-\   'lsp': 'stdio',
-\   'executable': {b -> ale#Var(b, 'kotlin_languageserver_executable')},
-\   'command': '%e',
-\   'language': 'kotlin',
-\   'project_root': function('ale_linters#kotlin#languageserver#GetProjectRoot'),
-\})
diff --git a/sources_non_forked/ale/ale_linters/less/lessc.vim b/sources_non_forked/ale/ale_linters/less/lessc.vim
deleted file mode 100644
index 4ec8b00..0000000
--- a/sources_non_forked/ale/ale_linters/less/lessc.vim
+++ /dev/null
@@ -1,47 +0,0 @@
-" Author: zanona <https://github.com/zanona>, w0rp <devw0rp@gmail.com>
-" Description: This file adds support for checking Less code with lessc.
-
-call ale#Set('less_lessc_executable', 'lessc')
-call ale#Set('less_lessc_options', '')
-call ale#Set('less_lessc_use_global', get(g:, 'ale_use_global_executables', 0))
-
-function! ale_linters#less#lessc#GetCommand(buffer) abort
-    return '%e --no-color --lint'
-    \   . ' --include-path=' . ale#Escape(expand('#' . a:buffer . ':p:h'))
-    \   . ale#Pad(ale#Var(a:buffer, 'less_lessc_options'))
-    \   . ' -'
-endfunction
-
-function! ale_linters#less#lessc#Handle(buffer, lines) abort
-    let l:dir = expand('#' . a:buffer . ':p:h')
-    " Matches patterns like the following:
-    let l:pattern = '^\(\w\+\): \(.\{-}\) in \(.\{-}\) on line \(\d\+\), column \(\d\+\):$'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        let l:item = {
-        \   'lnum': l:match[4] + 0,
-        \   'col': l:match[5] + 0,
-        \   'text': l:match[2],
-        \   'type': 'E',
-        \}
-
-        if l:match[3] isnot# '-'
-            let l:item.filename = ale#path#GetAbsPath(l:dir, l:match[3])
-        endif
-
-        call add(l:output, l:item)
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('less', {
-\   'name': 'lessc',
-\   'executable': {b -> ale#node#FindExecutable(b, 'less_lessc', [
-\       'node_modules/.bin/lessc',
-\   ])},
-\   'command': function('ale_linters#less#lessc#GetCommand'),
-\   'callback': 'ale_linters#less#lessc#Handle',
-\   'output_stream': 'stderr',
-\})
diff --git a/sources_non_forked/ale/ale_linters/less/stylelint.vim b/sources_non_forked/ale/ale_linters/less/stylelint.vim
deleted file mode 100644
index efb036c..0000000
--- a/sources_non_forked/ale/ale_linters/less/stylelint.vim
+++ /dev/null
@@ -1,20 +0,0 @@
-" Author: diartyz <diartyz@gmail.com>, w0rp <devw0rp@gmail.com>
-
-call ale#Set('less_stylelint_executable', 'stylelint')
-call ale#Set('less_stylelint_options', '')
-call ale#Set('less_stylelint_use_global', get(g:, 'ale_use_global_executables', 0))
-
-function! ale_linters#less#stylelint#GetCommand(buffer) abort
-    let l:options = ale#Var(a:buffer, 'less_stylelint_options')
-
-    return '%e' . ale#Pad(l:options) . ' --stdin-filename %s'
-endfunction
-
-call ale#linter#Define('less', {
-\   'name': 'stylelint',
-\   'executable': {b -> ale#node#FindExecutable(b, 'less_stylelint', [
-\       'node_modules/.bin/stylelint',
-\   ])},
-\   'command': function('ale_linters#less#stylelint#GetCommand'),
-\   'callback': 'ale#handlers#css#HandleStyleLintFormat',
-\})
diff --git a/sources_non_forked/ale/ale_linters/llvm/llc.vim b/sources_non_forked/ale/ale_linters/llvm/llc.vim
deleted file mode 100644
index 594be06..0000000
--- a/sources_non_forked/ale/ale_linters/llvm/llc.vim
+++ /dev/null
@@ -1,24 +0,0 @@
-" Author: rhysd <https://rhysd.github.io>
-" Description: Support for checking LLVM IR with llc
-
-call ale#Set('llvm_llc_executable', 'llc')
-
-function! ale_linters#llvm#llc#HandleErrors(buffer, lines) abort
-    " Handle '{path}: {file}:{line}:{col}: error: {message}' format
-    let l:pattern = '\v^[a-zA-Z]?:?[^:]+: [^:]+:(\d+):(\d+): (.+)$'
-
-    return map(ale#util#GetMatches(a:lines, l:pattern), "{
-    \   'lnum': str2nr(v:val[1]),
-    \   'col': str2nr(v:val[2]),
-    \   'text': v:val[3],
-    \   'type': 'E',
-    \}")
-endfunction
-
-call ale#linter#Define('llvm', {
-\   'name': 'llc',
-\   'executable': {b -> ale#Var(b, 'llvm_llc_executable')},
-\   'output_stream': 'stderr',
-\   'command': {-> '%e -filetype=null -o=' . g:ale#util#nul_file},
-\   'callback': 'ale_linters#llvm#llc#HandleErrors',
-\})
diff --git a/sources_non_forked/ale/ale_linters/lua/luac.vim b/sources_non_forked/ale/ale_linters/lua/luac.vim
deleted file mode 100644
index 41674a4..0000000
--- a/sources_non_forked/ale/ale_linters/lua/luac.vim
+++ /dev/null
@@ -1,31 +0,0 @@
-" Author: Jon Xie https://github.com/xiejiangzhi
-" Description: luac linter for lua files
-
-call ale#Set('lua_luac_executable', 'luac')
-
-function! ale_linters#lua#luac#Handle(buffer, lines) abort
-    " Matches patterns line the following:
-    "
-    " luac: stdin:5: '=' expected near ')'
-    " luac: stdin:8: ')' expected (to close '(' at line 6) near '123'
-    let l:pattern = '\v^.*:(\d+): (.+)$'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        call add(l:output, {
-        \   'lnum': l:match[1] + 0,
-        \   'type': 'E',
-        \   'text': l:match[2],
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('lua', {
-\   'name': 'luac',
-\   'executable': {b -> ale#Var(b, 'lua_luac_executable')},
-\   'command': '%e -p -',
-\   'output_stream': 'stderr',
-\   'callback': 'ale_linters#lua#luac#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/lua/luacheck.vim b/sources_non_forked/ale/ale_linters/lua/luacheck.vim
deleted file mode 100644
index 34be2b5..0000000
--- a/sources_non_forked/ale/ale_linters/lua/luacheck.vim
+++ /dev/null
@@ -1,44 +0,0 @@
-" Author: Sol Bekic https://github.com/s-ol
-" Description: luacheck linter for lua files
-
-call ale#Set('lua_luacheck_executable', 'luacheck')
-call ale#Set('lua_luacheck_options', '')
-
-function! ale_linters#lua#luacheck#GetCommand(buffer) abort
-    return '%e' . ale#Pad(ale#Var(a:buffer, 'lua_luacheck_options'))
-    \   . ' --formatter plain --codes --filename %s -'
-endfunction
-
-function! ale_linters#lua#luacheck#Handle(buffer, lines) abort
-    " Matches patterns line the following:
-    "
-    " artal.lua:159:17: (W111) shadowing definition of loop variable 'i' on line 106
-    " artal.lua:182:7: (W213) unused loop variable 'i'
-    let l:pattern = '^.*:\(\d\+\):\(\d\+\): (\([WE]\)\(\d\+\)) \(.\+\)$'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        if !ale#Var(a:buffer, 'warn_about_trailing_whitespace')
-        \   && l:match[3] is# 'W'
-        \   && index(range(611, 614), str2nr(l:match[4])) >= 0
-            continue
-        endif
-
-        call add(l:output, {
-        \   'lnum': l:match[1] + 0,
-        \   'col': l:match[2] + 0,
-        \   'type': l:match[3],
-        \   'code': l:match[3] . l:match[4],
-        \   'text': l:match[5],
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('lua', {
-\   'name': 'luacheck',
-\   'executable': {b -> ale#Var(b, 'lua_luacheck_executable')},
-\   'command': function('ale_linters#lua#luacheck#GetCommand'),
-\   'callback': 'ale_linters#lua#luacheck#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/mail/alex.vim b/sources_non_forked/ale/ale_linters/mail/alex.vim
deleted file mode 100644
index 0fceea7..0000000
--- a/sources_non_forked/ale/ale_linters/mail/alex.vim
+++ /dev/null
@@ -1,4 +0,0 @@
-" Author: Johannes Wienke <languitar@semipol.de>
-" Description: alex for mail files
-
-call ale#handlers#alex#DefineLinter('mail', '--text')
diff --git a/sources_non_forked/ale/ale_linters/mail/languagetool.vim b/sources_non_forked/ale/ale_linters/mail/languagetool.vim
deleted file mode 100644
index 330fb8e..0000000
--- a/sources_non_forked/ale/ale_linters/mail/languagetool.vim
+++ /dev/null
@@ -1,5 +0,0 @@
-" Author: Vincent (wahrwolf [t] wolfpit.net)
-" Description: languagetool for mails
-
-
-call ale#handlers#languagetool#DefineLinter('mail')
diff --git a/sources_non_forked/ale/ale_linters/mail/proselint.vim b/sources_non_forked/ale/ale_linters/mail/proselint.vim
deleted file mode 100644
index 82c8d1f..0000000
--- a/sources_non_forked/ale/ale_linters/mail/proselint.vim
+++ /dev/null
@@ -1,9 +0,0 @@
-" Author: Daniel M. Capella https://github.com/polyzen
-" Description: proselint for mail files
-
-call ale#linter#Define('mail', {
-\   'name': 'proselint',
-\   'executable': 'proselint',
-\   'command': 'proselint %t',
-\   'callback': 'ale#handlers#unix#HandleAsWarning',
-\})
diff --git a/sources_non_forked/ale/ale_linters/mail/vale.vim b/sources_non_forked/ale/ale_linters/mail/vale.vim
deleted file mode 100644
index e6dfd2e..0000000
--- a/sources_non_forked/ale/ale_linters/mail/vale.vim
+++ /dev/null
@@ -1,9 +0,0 @@
-" Author: chew-z https://github.com/chew-z
-" Description: vale for Markdown files
-
-call ale#linter#Define('mail', {
-\   'name': 'vale',
-\   'executable': 'vale',
-\   'command': 'vale --output=JSON %t',
-\   'callback': 'ale#handlers#vale#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/make/checkmake.vim b/sources_non_forked/ale/ale_linters/make/checkmake.vim
deleted file mode 100644
index 5ebdf91..0000000
--- a/sources_non_forked/ale/ale_linters/make/checkmake.vim
+++ /dev/null
@@ -1,25 +0,0 @@
-" Author: aurieh - https://github.com/aurieh
-
-function! ale_linters#make#checkmake#Handle(buffer, lines) abort
-    let l:pattern = '\v^(\d+):(.+):(.+)$'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        call add(l:output, {
-        \    'bufnr': a:buffer,
-        \    'lnum': l:match[1] + 0,
-        \    'type': 'E',
-        \    'code': l:match[2],
-        \    'text': l:match[3],
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('make', {
-\   'name': 'checkmake',
-\   'executable': 'checkmake',
-\   'command': 'checkmake %s --format="{{.LineNumber}}:{{.Rule}}:{{.Violation}}"',
-\   'callback': 'ale_linters#make#checkmake#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/markdown/alex.vim b/sources_non_forked/ale/ale_linters/markdown/alex.vim
deleted file mode 100644
index 63769b5..0000000
--- a/sources_non_forked/ale/ale_linters/markdown/alex.vim
+++ /dev/null
@@ -1,4 +0,0 @@
-" Author: Johannes Wienke <languitar@semipol.de>
-" Description: alex for markdown files
-
-call ale#handlers#alex#DefineLinter('markdown', '')
diff --git a/sources_non_forked/ale/ale_linters/markdown/languagetool.vim b/sources_non_forked/ale/ale_linters/markdown/languagetool.vim
deleted file mode 100644
index d6bca22..0000000
--- a/sources_non_forked/ale/ale_linters/markdown/languagetool.vim
+++ /dev/null
@@ -1,5 +0,0 @@
-" Author: Vincent (wahrwolf [t] wolfpit.net)
-" Description: languagetool for markdown files
-
-
-call ale#handlers#languagetool#DefineLinter('markdown')
diff --git a/sources_non_forked/ale/ale_linters/markdown/markdownlint.vim b/sources_non_forked/ale/ale_linters/markdown/markdownlint.vim
deleted file mode 100644
index e935cbf..0000000
--- a/sources_non_forked/ale/ale_linters/markdown/markdownlint.vim
+++ /dev/null
@@ -1,11 +0,0 @@
-" Author: Ty-Lucas Kelley <tylucaskelley@gmail.com>
-" Description: Adds support for markdownlint
-
-call ale#linter#Define('markdown', {
-\   'name': 'markdownlint',
-\   'executable': 'markdownlint',
-\   'lint_file': 1,
-\   'output_stream': 'both',
-\   'command': 'markdownlint %s',
-\   'callback': 'ale#handlers#markdownlint#Handle'
-\})
diff --git a/sources_non_forked/ale/ale_linters/markdown/mdl.vim b/sources_non_forked/ale/ale_linters/markdown/mdl.vim
deleted file mode 100644
index fd44de6..0000000
--- a/sources_non_forked/ale/ale_linters/markdown/mdl.vim
+++ /dev/null
@@ -1,43 +0,0 @@
-" Author: Steve Dignam <steve@dignam.xyz>, Josh Leeb-du Toit <joshleeb.com>
-" Description: Support for mdl, a markdown linter.
-
-call ale#Set('markdown_mdl_executable', 'mdl')
-call ale#Set('markdown_mdl_options', '')
-
-function! ale_linters#markdown#mdl#GetExecutable(buffer) abort
-    return ale#Var(a:buffer, 'markdown_mdl_executable')
-endfunction
-
-function! ale_linters#markdown#mdl#GetCommand(buffer) abort
-    let l:executable = ale_linters#markdown#mdl#GetExecutable(a:buffer)
-    let l:exec_args = l:executable =~? 'bundle$'
-    \   ? ' exec mdl'
-    \   : ''
-
-    let l:options = ale#Var(a:buffer, 'markdown_mdl_options')
-
-    return ale#Escape(l:executable) . l:exec_args
-    \   . ' -j' . (!empty(l:options) ? ' ' . l:options : '')
-endfunction
-
-function! ale_linters#markdown#mdl#Handle(buffer, lines) abort
-    let l:output = []
-
-    for l:error in ale#util#FuzzyJSONDecode(a:lines, [])
-        call add(l:output, {
-        \   'lnum': l:error['line'],
-        \   'code': l:error['rule']  . '/' . join(l:error['aliases'], '/'),
-        \   'text': l:error['description'],
-        \   'type': 'W',
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('markdown', {
-\   'name': 'mdl',
-\   'executable': function('ale_linters#markdown#mdl#GetExecutable'),
-\   'command': function('ale_linters#markdown#mdl#GetCommand'),
-\   'callback': 'ale_linters#markdown#mdl#Handle'
-\})
diff --git a/sources_non_forked/ale/ale_linters/markdown/proselint.vim b/sources_non_forked/ale/ale_linters/markdown/proselint.vim
deleted file mode 100644
index 289d881..0000000
--- a/sources_non_forked/ale/ale_linters/markdown/proselint.vim
+++ /dev/null
@@ -1,9 +0,0 @@
-" Author: poohzrn https://github.com/poohzrn
-" Description: proselint for Markdown files
-
-call ale#linter#Define('markdown', {
-\   'name': 'proselint',
-\   'executable': 'proselint',
-\   'command': 'proselint %t',
-\   'callback': 'ale#handlers#unix#HandleAsWarning',
-\})
diff --git a/sources_non_forked/ale/ale_linters/markdown/redpen.vim b/sources_non_forked/ale/ale_linters/markdown/redpen.vim
deleted file mode 100644
index ff2cbaf..0000000
--- a/sources_non_forked/ale/ale_linters/markdown/redpen.vim
+++ /dev/null
@@ -1,9 +0,0 @@
-" Author: rhysd https://rhysd.github.io
-" Description: Redpen, a proofreading tool (http://redpen.cc)
-
-call ale#linter#Define('markdown', {
-\   'name': 'redpen',
-\   'executable': 'redpen',
-\   'command': 'redpen -f markdown -r json %t',
-\   'callback': 'ale#handlers#redpen#HandleRedpenOutput',
-\})
diff --git a/sources_non_forked/ale/ale_linters/markdown/remark_lint.vim b/sources_non_forked/ale/ale_linters/markdown/remark_lint.vim
deleted file mode 100644
index ed87d1a..0000000
--- a/sources_non_forked/ale/ale_linters/markdown/remark_lint.vim
+++ /dev/null
@@ -1,48 +0,0 @@
-scriptencoding utf-8
-" Author rhysd https://rhysd.github.io/, Dirk Roorda (dirkroorda), Adrin Gonzlez Rus (@adrigzr)
-" Description: remark-lint for Markdown files
-call ale#Set('markdown_remark_lint_executable', 'remark')
-call ale#Set('markdown_remark_lint_use_global', get(g:, 'ale_use_global_executables', 0))
-call ale#Set('markdown_remark_lint_options', '')
-
-function! ale_linters#markdown#remark_lint#GetCommand(buffer) abort
-    let l:options = ale#Var(a:buffer, 'markdown_remark_lint_options')
-
-    return '%e' . ale#Pad(l:options) . ' --no-stdout --no-color'
-endfunction
-
-function! ale_linters#markdown#remark_lint#Handle(buffer, lines) abort
-    " matches: '  1:4  warning  Incorrect list-item indent: add 1 space  list-item-indent  remark-lint'
-    " matches: '  18:71-19:1  error  Missing new line after list item  list-item-spacing  remark-lint',
-    let l:pattern = '^ \+\(\d\+\):\(\d\+\)\(-\(\d\+\):\(\d\+\)\)\?  \(warning\|error\)  \(.\+\)$'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        let l:item = {
-        \   'lnum': l:match[1] + 0,
-        \   'col': l:match[2] + 0,
-        \   'type': l:match[6] is# 'error' ? 'E' : 'W',
-        \   'text': l:match[7],
-        \}
-
-        if l:match[3] isnot# ''
-            let l:item.end_lnum = l:match[4] + 0
-            let l:item.end_col = l:match[5] + 0
-        endif
-
-        call add(l:output, l:item)
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('markdown', {
-\   'name': 'remark_lint',
-\   'aliases': ['remark-lint'],
-\   'executable': {b -> ale#node#FindExecutable(b, 'markdown_remark_lint', [
-\       'node_modules/.bin/remark',
-\   ])},
-\   'command': function('ale_linters#markdown#remark_lint#GetCommand'),
-\   'callback': 'ale_linters#markdown#remark_lint#Handle',
-\   'output_stream': 'stderr',
-\})
diff --git a/sources_non_forked/ale/ale_linters/markdown/textlint.vim b/sources_non_forked/ale/ale_linters/markdown/textlint.vim
deleted file mode 100644
index 613c841..0000000
--- a/sources_non_forked/ale/ale_linters/markdown/textlint.vim
+++ /dev/null
@@ -1,9 +0,0 @@
-" Author: tokida https://rouger.info, Yasuhiro Kiyota <yasuhiroki.duck@gmail.com>
-" Description: textlint, a proofreading tool (https://textlint.github.io/)
-
-call ale#linter#Define('markdown', {
-\   'name': 'textlint',
-\   'executable': function('ale#handlers#textlint#GetExecutable'),
-\   'command': function('ale#handlers#textlint#GetCommand'),
-\   'callback': 'ale#handlers#textlint#HandleTextlintOutput',
-\})
diff --git a/sources_non_forked/ale/ale_linters/markdown/vale.vim b/sources_non_forked/ale/ale_linters/markdown/vale.vim
deleted file mode 100644
index 838c4db..0000000
--- a/sources_non_forked/ale/ale_linters/markdown/vale.vim
+++ /dev/null
@@ -1,9 +0,0 @@
-" Author: chew-z https://github.com/chew-z
-" Description: vale for Markdown files
-
-call ale#linter#Define('markdown', {
-\   'name': 'vale',
-\   'executable': 'vale',
-\   'command': 'vale --output=JSON %t',
-\   'callback': 'ale#handlers#vale#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/markdown/writegood.vim b/sources_non_forked/ale/ale_linters/markdown/writegood.vim
deleted file mode 100644
index 7108e7a..0000000
--- a/sources_non_forked/ale/ale_linters/markdown/writegood.vim
+++ /dev/null
@@ -1,4 +0,0 @@
-" Author: Sumner Evans <sumner.evans98@gmail.com>
-" Description: write-good for Markdown files
-
-call ale#handlers#writegood#DefineLinter('markdown')
diff --git a/sources_non_forked/ale/ale_linters/matlab/mlint.vim b/sources_non_forked/ale/ale_linters/matlab/mlint.vim
deleted file mode 100644
index f58f8b6..0000000
--- a/sources_non_forked/ale/ale_linters/matlab/mlint.vim
+++ /dev/null
@@ -1,44 +0,0 @@
-" Author: awlayton <alex@layton.in>
-" Description: mlint for MATLAB files
-
-call ale#Set('matlab_mlint_executable', 'mlint')
-
-function! ale_linters#matlab#mlint#Handle(buffer, lines) abort
-    " Matches patterns like the following:
-    "
-    " L 27 (C 1): FNDEF: Terminate statement with semicolon to suppress output.
-    " L 30 (C 13-15): FNDEF: A quoted string is unterminated.
-    let l:pattern = '^L \(\d\+\) (C \([0-9-]\+\)): \([A-Z]\+\): \(.\+\)$'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        let l:lnum = l:match[1] + 0
-        let l:col = l:match[2] + 0
-        let l:code = l:match[3]
-        let l:text = l:match[4]
-
-        " Suppress erroneous waring about filename
-        " TODO: Enable this error when copying filename is supported
-        if l:code is# 'FNDEF'
-            continue
-        endif
-
-        call add(l:output, {
-        \   'bufnr': a:buffer,
-        \   'lnum': l:lnum,
-        \   'col': l:col,
-        \   'text': l:text,
-        \   'type': 'W',
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('matlab', {
-\   'name': 'mlint',
-\   'executable': {b -> ale#Var(b, 'matlab_mlint_executable')},
-\   'command': '%e -id %t',
-\   'output_stream': 'stderr',
-\   'callback': 'ale_linters#matlab#mlint#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/mercury/mmc.vim b/sources_non_forked/ale/ale_linters/mercury/mmc.vim
deleted file mode 100644
index 8a9ccc0..0000000
--- a/sources_non_forked/ale/ale_linters/mercury/mmc.vim
+++ /dev/null
@@ -1,40 +0,0 @@
-" Author: stewy33 <slocumstewy@gmail.com>
-" Description: Lints mercury files using mmc
-
-call ale#Set('mercury_mmc_executable', 'mmc')
-call ale#Set('mercury_mmc_options', '--make --output-compile-error-lines 100')
-
-function! ale_linters#mercury#mmc#GetCommand(buffer) abort
-    let l:module_name = expand('#' . a:buffer . ':t:r')
-
-    return ale#path#BufferCdString(a:buffer)
-    \ . '%e --errorcheck-only '
-    \ . ale#Var(a:buffer, 'mercury_mmc_options')
-    \ . ' ' . l:module_name
-endfunction
-
-function! ale_linters#mercury#mmc#Handle(buffer, lines) abort
-    " output format
-    " <filename>:<line>:   <issue type>: <message>
-    let l:pattern = '\v^\w+\.m:(\d+):\s+([W|w]arning|.*[E|e]rror.*): (.*)'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        call add(l:output, {
-        \   'lnum': substitute(l:match[1], '\v^0*', '', '') + 0,
-        \   'type': l:match[2][0] =~? 'W' ? 'W' : 'E',
-        \   'text': l:match[2] . ': ' . l:match[3]
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('mercury', {
-\   'name': 'mmc',
-\   'output_stream': 'stderr',
-\   'executable': {b -> ale#Var(b, 'mercury_mmc_executable')},
-\   'command': function('ale_linters#mercury#mmc#GetCommand'),
-\   'callback': 'ale_linters#mercury#mmc#Handle',
-\   'lint_file': 1,
-\})
diff --git a/sources_non_forked/ale/ale_linters/nasm/nasm.vim b/sources_non_forked/ale/ale_linters/nasm/nasm.vim
deleted file mode 100644
index 347abc1..0000000
--- a/sources_non_forked/ale/ale_linters/nasm/nasm.vim
+++ /dev/null
@@ -1,42 +0,0 @@
-" Author: Oyvind Ingvaldsen <oyvind.ingvaldsen@gmail.com>
-" Description: NASM linter for asmsyntax nasm.
-
-call ale#Set('nasm_nasm_executable', 'nasm')
-call ale#Set('nasm_nasm_options', '')
-
-function! ale_linters#nasm#nasm#GetCommand(buffer) abort
-    " Note that NASM requires a trailing slash for the -I option.
-    let l:separator = has('win32') ? '\' : '/'
-    let l:path = fnamemodify(bufname(a:buffer), ':p:h') . l:separator
-    let l:output_null = has('win32') ? 'NUL' : '/dev/null'
-
-    return '%e -X gnu -I ' . ale#Escape(l:path)
-    \   . ale#Pad(ale#Var(a:buffer, 'nasm_nasm_options'))
-    \   . ' %s'
-    \   . ' -o ' . l:output_null
-endfunction
-
-function! ale_linters#nasm#nasm#Handle(buffer, lines) abort
-    " Note that we treat 'fatal' as errors.
-    let l:pattern = '^.\+:\(\d\+\): \([^:]\+\): \(.\+\)$'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        call add(l:output, {
-        \ 'lnum': l:match[1] + 0,
-        \ 'type': l:match[2] =~? 'error\|fatal' ? 'E' : 'W',
-        \ 'text': l:match[3],
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('nasm', {
-\   'name': 'nasm',
-\   'output_stream': 'stderr',
-\   'lint_file': 1,
-\   'executable': {b -> ale#Var(b, 'nasm_nasm_executable')},
-\   'command': function('ale_linters#nasm#nasm#GetCommand'),
-\   'callback': 'ale_linters#nasm#nasm#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/nim/nimcheck.vim b/sources_non_forked/ale/ale_linters/nim/nimcheck.vim
deleted file mode 100644
index b739ca0..0000000
--- a/sources_non_forked/ale/ale_linters/nim/nimcheck.vim
+++ /dev/null
@@ -1,79 +0,0 @@
-" Author: Baabelfish
-" Description: Typechecking for nim files
-
-let s:end_col_patterns = [
-\   '\v''([^'']+)'' is declared but not used.*',
-\   '\videntifier expected, but found ''([^'']+)''',
-\   '\vimported and not used: ''([^'']+)''.*',
-\   '\vundeclared identifier: ''([^'']+)''',
-\   '\v''([^'']+)'' cannot be assigned to',
-\   '\vredefinition of ''([^'']+)'';',
-\]
-
-function! ale_linters#nim#nimcheck#Handle(buffer, lines) abort
-    let l:buffer_filename = fnamemodify(bufname(a:buffer), ':p:t')
-    let l:pattern = '^\(.\+\.nim\)(\(\d\+\), \(\d\+\)) \(.\+\)'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        " Only show errors of the current buffer
-        " NOTE: Checking filename only is OK because nim enforces unique
-        "       module names.
-        let l:temp_buffer_filename = fnamemodify(l:match[1], ':p:t')
-
-        if l:buffer_filename isnot# '' && l:temp_buffer_filename isnot# l:buffer_filename
-            continue
-        endif
-
-        let l:item = {
-        \   'lnum': l:match[2] + 0,
-        \   'col': l:match[3] + 0,
-        \   'text': l:match[4],
-        \   'type': 'W',
-        \}
-
-        " Extract error type from message of type 'Error: Some error message'
-        let l:error_match = matchlist(l:item.text, '^\(.\{-}\): \(.\+\)$')
-
-        if !empty(l:error_match)
-            if l:error_match[1] is# 'Error'
-                let l:item.type = 'E'
-                let l:item.text = l:error_match[2]
-            elseif l:error_match[1] is# 'Warning'
-            \|| l:error_match[1] is# 'Hint'
-                let l:item.text = l:error_match[2]
-            endif
-        endif
-
-        let l:code_match = matchlist(l:item.text, '\v^(.+) \[([^ \[]+)\]$')
-
-        if !empty(l:code_match)
-            let l:item.text = l:code_match[1]
-            let l:item.code = l:code_match[2]
-        endif
-
-        " Find position end_col.
-        for l:col_match in ale#util#GetMatches(l:item.text, s:end_col_patterns)
-            let l:item.end_col = l:item.col + len(l:col_match[1]) - 1
-        endfor
-
-        call add(l:output, l:item)
-    endfor
-
-    return l:output
-endfunction
-
-
-function! ale_linters#nim#nimcheck#GetCommand(buffer) abort
-    return 'nim check --verbosity:0 --colors:off --listFullPaths %s'
-endfunction
-
-
-call ale#linter#Define('nim', {
-\    'name': 'nimcheck',
-\    'executable': 'nim',
-\    'output_stream': 'both',
-\    'command': function('ale_linters#nim#nimcheck#GetCommand'),
-\    'callback': 'ale_linters#nim#nimcheck#Handle',
-\    'lint_file': 1,
-\})
diff --git a/sources_non_forked/ale/ale_linters/nim/nimlsp.vim b/sources_non_forked/ale/ale_linters/nim/nimlsp.vim
deleted file mode 100644
index 5d04104..0000000
--- a/sources_non_forked/ale/ale_linters/nim/nimlsp.vim
+++ /dev/null
@@ -1,33 +0,0 @@
-" Author: jeremija <https://github.com/jeremija>
-" Description: Support for nimlsp (language server for nim)
-
-call ale#Set('nim_nimlsp_nim_sources', '')
-
-function! ale_linters#nim#nimlsp#GetProjectRoot(buffer) abort
-    let l:project_root = ale#path#FindNearestDirectory(a:buffer, '.git')
-
-    if !empty(l:project_root)
-        return fnamemodify(l:project_root, ':h:h')
-    endif
-
-    return ''
-endfunction
-
-function! ale_linters#nim#nimlsp#GetCommand(buffer) abort
-    let l:nim_sources = ale#Var(a:buffer, 'nim_nimlsp_nim_sources')
-
-    if !empty(l:nim_sources)
-        let l:nim_sources = ale#Escape(l:nim_sources)
-    endif
-
-    return '%e' . ale#Pad(l:nim_sources)
-endfunction
-
-call ale#linter#Define('nim', {
-\   'name': 'nimlsp',
-\   'lsp': 'stdio',
-\   'executable': 'nimlsp',
-\   'command': function('ale_linters#nim#nimlsp#GetCommand'),
-\   'language': 'nim',
-\   'project_root': function('ale_linters#nim#nimlsp#GetProjectRoot'),
-\})
diff --git a/sources_non_forked/ale/ale_linters/nix/nix.vim b/sources_non_forked/ale/ale_linters/nix/nix.vim
deleted file mode 100644
index 0a0c5c3..0000000
--- a/sources_non_forked/ale/ale_linters/nix/nix.vim
+++ /dev/null
@@ -1,26 +0,0 @@
-" Author: Alistair Bill <@alibabzo>
-" Description: nix-instantiate linter for nix files
-
-function! ale_linters#nix#nix#Handle(buffer, lines) abort
-    let l:pattern = '^\(.\+\): \(.\+\), at .*:\(\d\+\):\(\d\+\)$'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        call add(l:output, {
-        \   'lnum': l:match[3] + 0,
-        \   'col': l:match[4] + 0,
-        \   'text': l:match[1] . ': ' . l:match[2],
-        \   'type': l:match[1] =~# '^error' ? 'E' : 'W',
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('nix', {
-\   'name': 'nix',
-\   'output_stream': 'stderr',
-\   'executable': 'nix-instantiate',
-\   'command': 'nix-instantiate --parse -',
-\   'callback': 'ale_linters#nix#nix#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/nroff/alex.vim b/sources_non_forked/ale/ale_linters/nroff/alex.vim
deleted file mode 100644
index 3f06af2..0000000
--- a/sources_non_forked/ale/ale_linters/nroff/alex.vim
+++ /dev/null
@@ -1,4 +0,0 @@
-" Author: Johannes Wienke <languitar@semipol.de>
-" Description: alex for nroff files
-
-call ale#handlers#alex#DefineLinter('nroff', '--text')
diff --git a/sources_non_forked/ale/ale_linters/nroff/proselint.vim b/sources_non_forked/ale/ale_linters/nroff/proselint.vim
deleted file mode 100644
index a23e56b..0000000
--- a/sources_non_forked/ale/ale_linters/nroff/proselint.vim
+++ /dev/null
@@ -1,9 +0,0 @@
-" Author: Daniel M. Capella https://github.com/polyzen
-" Description: proselint for nroff files
-
-call ale#linter#Define('nroff', {
-\   'name': 'proselint',
-\   'executable': 'proselint',
-\   'command': 'proselint %t',
-\   'callback': 'ale#handlers#unix#HandleAsWarning',
-\})
diff --git a/sources_non_forked/ale/ale_linters/nroff/writegood.vim b/sources_non_forked/ale/ale_linters/nroff/writegood.vim
deleted file mode 100644
index bcf344f..0000000
--- a/sources_non_forked/ale/ale_linters/nroff/writegood.vim
+++ /dev/null
@@ -1,4 +0,0 @@
-" Author: Sumner Evans <sumner.evans98@gmail.com>
-" Description: write-good for nroff files
-
-call ale#handlers#writegood#DefineLinter('nroff')
diff --git a/sources_non_forked/ale/ale_linters/objc/ccls.vim b/sources_non_forked/ale/ale_linters/objc/ccls.vim
deleted file mode 100644
index 51ecf05..0000000
--- a/sources_non_forked/ale/ale_linters/objc/ccls.vim
+++ /dev/null
@@ -1,14 +0,0 @@
-" Author: Ye Jingchen <ye.jingchen@gmail.com>, Ben Falconer <ben@falconers.me.uk>, jtalowell <jtalowell@protonmail.com>
-" Description: A language server for Objective-C
-
-call ale#Set('objc_ccls_executable', 'ccls')
-call ale#Set('objc_ccls_init_options', {})
-
-call ale#linter#Define('objc', {
-\   'name': 'ccls',
-\   'lsp': 'stdio',
-\   'executable': {b -> ale#Var(b, 'objc_ccls_executable')},
-\   'command': '%e',
-\   'project_root': function('ale#handlers#ccls#GetProjectRoot'),
-\   'initialization_options': {b -> ale#Var(b, 'objc_ccls_init_options')},
-\})
diff --git a/sources_non_forked/ale/ale_linters/objc/clang.vim b/sources_non_forked/ale/ale_linters/objc/clang.vim
deleted file mode 100644
index 7873dcc..0000000
--- a/sources_non_forked/ale/ale_linters/objc/clang.vim
+++ /dev/null
@@ -1,23 +0,0 @@
-" Author: Bang Lee <https://github.com/Qusic>
-" Description: clang linter for objc files
-
-" Set this option to change the Clang options for warnings for ObjC.
-if !exists('g:ale_objc_clang_options')
-    let g:ale_objc_clang_options = '-std=c11 -Wall'
-endif
-
-function! ale_linters#objc#clang#GetCommand(buffer) abort
-    " -iquote with the directory the file is in makes #include work for
-    "  headers in the same directory.
-    return 'clang -S -x objective-c -fsyntax-only '
-    \   . '-iquote ' . ale#Escape(fnamemodify(bufname(a:buffer), ':p:h'))
-    \   . ' ' . ale#Var(a:buffer, 'objc_clang_options') . ' -'
-endfunction
-
-call ale#linter#Define('objc', {
-\   'name': 'clang',
-\   'output_stream': 'stderr',
-\   'executable': 'clang',
-\   'command': function('ale_linters#objc#clang#GetCommand'),
-\   'callback': 'ale#handlers#gcc#HandleGCCFormatWithIncludes',
-\})
diff --git a/sources_non_forked/ale/ale_linters/objc/clangd.vim b/sources_non_forked/ale/ale_linters/objc/clangd.vim
deleted file mode 100644
index 318d85b..0000000
--- a/sources_non_forked/ale/ale_linters/objc/clangd.vim
+++ /dev/null
@@ -1,17 +0,0 @@
-" Author: Andrey Melentyev <andrey.melentyev@protonmail.com>
-" Description: Clangd language server
-
-call ale#Set('objc_clangd_executable', 'clangd')
-call ale#Set('objc_clangd_options', '')
-
-function! ale_linters#objc#clangd#GetCommand(buffer) abort
-    return '%e' . ale#Pad(ale#Var(a:buffer, 'objc_clangd_options'))
-endfunction
-
-call ale#linter#Define('objc', {
-\   'name': 'clangd',
-\   'lsp': 'stdio',
-\   'executable': {b -> ale#Var(b, 'objc_clangd_executable')},
-\   'command': function('ale_linters#objc#clangd#GetCommand'),
-\   'project_root': function('ale#c#FindProjectRoot'),
-\})
diff --git a/sources_non_forked/ale/ale_linters/objcpp/clang.vim b/sources_non_forked/ale/ale_linters/objcpp/clang.vim
deleted file mode 100644
index 4dbe55b..0000000
--- a/sources_non_forked/ale/ale_linters/objcpp/clang.vim
+++ /dev/null
@@ -1,23 +0,0 @@
-" Author: Bang Lee <https://github.com/Qusic>
-" Description: clang linter for objcpp files
-
-" Set this option to change the Clang options for warnings for ObjCPP.
-if !exists('g:ale_objcpp_clang_options')
-    let g:ale_objcpp_clang_options = '-std=c++14 -Wall'
-endif
-
-function! ale_linters#objcpp#clang#GetCommand(buffer) abort
-    " -iquote with the directory the file is in makes #include work for
-    "  headers in the same directory.
-    return 'clang++ -S -x objective-c++ -fsyntax-only '
-    \   . '-iquote ' . ale#Escape(fnamemodify(bufname(a:buffer), ':p:h'))
-    \   . ' ' . ale#Var(a:buffer, 'objcpp_clang_options') . ' -'
-endfunction
-
-call ale#linter#Define('objcpp', {
-\   'name': 'clang',
-\   'output_stream': 'stderr',
-\   'executable': 'clang++',
-\   'command': function('ale_linters#objcpp#clang#GetCommand'),
-\   'callback': 'ale#handlers#gcc#HandleGCCFormatWithIncludes',
-\})
diff --git a/sources_non_forked/ale/ale_linters/objcpp/clangd.vim b/sources_non_forked/ale/ale_linters/objcpp/clangd.vim
deleted file mode 100644
index 2945532..0000000
--- a/sources_non_forked/ale/ale_linters/objcpp/clangd.vim
+++ /dev/null
@@ -1,17 +0,0 @@
-" Author: Andrey Melentyev <andrey.melentyev@protonmail.com>
-" Description: Clangd language server
-
-call ale#Set('objcpp_clangd_executable', 'clangd')
-call ale#Set('objcpp_clangd_options', '')
-
-function! ale_linters#objcpp#clangd#GetCommand(buffer) abort
-    return '%e' . ale#Pad(ale#Var(a:buffer, 'objcpp_clangd_options'))
-endfunction
-
-call ale#linter#Define('objcpp', {
-\   'name': 'clangd',
-\   'lsp': 'stdio',
-\   'executable': {b -> ale#Var(b, 'objcpp_clangd_executable')},
-\   'command': function('ale_linters#objcpp#clangd#GetCommand'),
-\   'project_root': function('ale#c#FindProjectRoot'),
-\})
diff --git a/sources_non_forked/ale/ale_linters/ocaml/merlin.vim b/sources_non_forked/ale/ale_linters/ocaml/merlin.vim
deleted file mode 100644
index cfec996..0000000
--- a/sources_non_forked/ale/ale_linters/ocaml/merlin.vim
+++ /dev/null
@@ -1,17 +0,0 @@
-" Author: Andrey Popp -- @andreypopp
-" Description: Report errors in OCaml code with Merlin
-
-if !exists('g:merlin')
-    finish
-endif
-
-function! ale_linters#ocaml#merlin#Handle(buffer, lines) abort
-    return merlin#ErrorLocList()
-endfunction
-
-call ale#linter#Define('ocaml', {
-\   'name': 'merlin',
-\   'executable': 'ocamlmerlin',
-\   'command': 'true',
-\   'callback': 'ale_linters#ocaml#merlin#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/ocaml/ols.vim b/sources_non_forked/ale/ale_linters/ocaml/ols.vim
deleted file mode 100644
index d8208c5..0000000
--- a/sources_non_forked/ale/ale_linters/ocaml/ols.vim
+++ /dev/null
@@ -1,14 +0,0 @@
-" Author: Michael Jungo <michaeljungo92@gmail.com>
-" Description: A language server for OCaml
-
-call ale#Set('ocaml_ols_executable', 'ocaml-language-server')
-call ale#Set('ocaml_ols_use_global', get(g:, 'ale_use_global_executables', 0))
-
-call ale#linter#Define('ocaml', {
-\   'name': 'ols',
-\   'lsp': 'stdio',
-\   'executable': function('ale#handlers#ols#GetExecutable'),
-\   'command': function('ale#handlers#ols#GetCommand'),
-\   'language_callback': 'ale#handlers#ols#GetLanguage',
-\   'project_root': function('ale#handlers#ols#GetProjectRoot'),
-\})
diff --git a/sources_non_forked/ale/ale_linters/perl/perl.vim b/sources_non_forked/ale/ale_linters/perl/perl.vim
deleted file mode 100644
index 0f06528..0000000
--- a/sources_non_forked/ale/ale_linters/perl/perl.vim
+++ /dev/null
@@ -1,64 +0,0 @@
-" Author: Vincent Lequertier <https://github.com/SkySymbol>
-" Description: This file adds support for checking perl syntax
-
-call ale#Set('perl_perl_executable', 'perl')
-call ale#Set('perl_perl_options', '-c -Mwarnings -Ilib')
-
-function! ale_linters#perl#perl#GetCommand(buffer) abort
-    return '%e' . ale#Pad(ale#Var(a:buffer, 'perl_perl_options')) . ' %t'
-endfunction
-
-let s:begin_failed_skip_pattern = '\v' . join([
-\   '^Compilation failed in require',
-\   '^Can''t locate',
-\], '|')
-
-function! ale_linters#perl#perl#Handle(buffer, lines) abort
-    if empty(a:lines)
-        return []
-    endif
-
-    let l:pattern = '\(..\{-}\) at \(..\{-}\) line \(\d\+\)'
-    let l:output = []
-    let l:basename = expand('#' . a:buffer . ':t')
-
-    let l:type = 'E'
-
-    if a:lines[-1] =~# 'syntax OK'
-        let l:type = 'W'
-    endif
-
-    let l:seen = {}
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        let l:line = l:match[3]
-        let l:file = l:match[2]
-        let l:text = l:match[1]
-
-        if ale#path#IsBufferPath(a:buffer, l:file)
-        \ && !has_key(l:seen,l:line)
-        \ && (
-        \   l:text isnot# 'BEGIN failed--compilation aborted'
-        \   || empty(l:output)
-        \   || match(l:output[-1].text, s:begin_failed_skip_pattern) < 0
-        \ )
-            call add(l:output, {
-            \   'lnum': l:line,
-            \   'text': l:text,
-            \   'type': l:type,
-            \})
-
-            let l:seen[l:line] = 1
-        endif
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('perl', {
-\   'name': 'perl',
-\   'executable': {b -> ale#Var(b, 'perl_perl_executable')},
-\   'output_stream': 'both',
-\   'command': function('ale_linters#perl#perl#GetCommand'),
-\   'callback': 'ale_linters#perl#perl#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/perl/perlcritic.vim b/sources_non_forked/ale/ale_linters/perl/perlcritic.vim
deleted file mode 100644
index f3154c0..0000000
--- a/sources_non_forked/ale/ale_linters/perl/perlcritic.vim
+++ /dev/null
@@ -1,61 +0,0 @@
-" Author: Vincent Lequertier <https://github.com/SkySymbol>, Chris Weyl <cweyl@alumni.drew.edu>
-" Description: This file adds support for checking perl with perl critic
-
-call ale#Set('perl_perlcritic_executable', 'perlcritic')
-call ale#Set('perl_perlcritic_profile', '.perlcriticrc')
-call ale#Set('perl_perlcritic_options', '')
-call ale#Set('perl_perlcritic_showrules', 0)
-
-function! ale_linters#perl#perlcritic#GetProfile(buffer) abort
-    " first see if we've been overridden
-    let l:profile = ale#Var(a:buffer, 'perl_perlcritic_profile')
-
-    if l:profile is? ''
-        return ''
-    endif
-
-    " otherwise, iterate upwards to find it
-    return ale#path#FindNearestFile(a:buffer, l:profile)
-endfunction
-
-function! ale_linters#perl#perlcritic#GetCommand(buffer) abort
-    let l:critic_verbosity = '%l:%c %m\n'
-
-    if ale#Var(a:buffer, 'perl_perlcritic_showrules')
-        let l:critic_verbosity = '%l:%c %m [%p]\n'
-    endif
-
-    let l:profile = ale_linters#perl#perlcritic#GetProfile(a:buffer)
-    let l:options = ale#Var(a:buffer, 'perl_perlcritic_options')
-
-    return '%e'
-    \   . ' --verbose ' . ale#Escape(l:critic_verbosity)
-    \   . ' --nocolor'
-    \   . (!empty(l:profile) ? ' --profile ' . ale#Escape(l:profile) : '')
-    \   . ale#Pad(l:options)
-endfunction
-
-
-function! ale_linters#perl#perlcritic#Handle(buffer, lines) abort
-    let l:pattern = '\(\d\+\):\(\d\+\) \(.\+\)'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        call add(l:output, {
-        \   'lnum': l:match[1],
-        \   'col': l:match[2],
-        \   'text': l:match[3],
-        \   'type': 'W'
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('perl', {
-\   'name': 'perlcritic',
-\   'output_stream': 'stdout',
-\   'executable': {b -> ale#Var(b, 'perl_perlcritic_executable')},
-\   'command': function('ale_linters#perl#perlcritic#GetCommand'),
-\   'callback': 'ale_linters#perl#perlcritic#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/perl6/perl6.vim b/sources_non_forked/ale/ale_linters/perl6/perl6.vim
deleted file mode 100644
index 68ef476..0000000
--- a/sources_non_forked/ale/ale_linters/perl6/perl6.vim
+++ /dev/null
@@ -1,166 +0,0 @@
-" Author:Travis Gibson <https://github.com/Garland-g>
-" Description: This file adds support for checking perl6 syntax
-
-let g:ale_perl6_perl6_executable =
-\   get(g:, 'ale_perl6_perl6_executable', 'perl6')
-
-let g:ale_perl6_perl6_options =
-\   get(g:, 'ale_perl6_perl6_options', '-c -Ilib')
-
-let $PERL6_EXCEPTIONS_HANDLER = 'JSON'
-
-let $RAKUDO_ERROR_COLOR = 0
-
-function! ale_linters#perl6#perl6#GetExecutable(buffer) abort
-    return ale#Var(a:buffer, 'perl6_perl6_executable')
-endfunction
-
-function! ale_linters#perl6#perl6#GetCommand(buffer) abort
-    return ale_linters#perl6#perl6#GetExecutable(a:buffer)
-    \   . ' ' . ale#Var(a:buffer, 'perl6_perl6_options')
-    \   . ' %t'
-endfunction
-
-function! ale_linters#perl6#perl6#ExtractError(dict, item, type, buffer) abort
-    let l:file = ''
-    let l:line = 1
-    let l:column = ''
-    let l:text = ''
-    let l:pre = ''
-    let l:counter = 2
-    let l:end_line = ''
-    let l:linepatternmessage = 'at\s\+line\s\+\(\d\+\)'
-
-    if has_key(a:dict[a:item], 'filename') && !empty(a:dict[a:item]['filename'])
-        let l:file = a:dict[a:item]['filename']
-    endif
-
-    if has_key(a:dict[a:item], 'line') && !empty(a:dict[a:item]['line'])
-        let l:line = a:dict[a:item]['line']
-        let l:counter -= 1
-    endif
-
-    if has_key(a:dict[a:item], 'column') && !empty(a:dict[a:item]['column'])
-        let l:column = a:dict[a:item]['column']
-    endif
-
-    if has_key(a:dict[a:item], 'message') && !empty(a:dict[a:item]['message'])
-        let l:text = substitute(a:dict[a:item]['message'], '\s*\n\s*', ' ', 'g')
-        let l:counter -= 1
-    endif
-
-    if has_key(a:dict[a:item], 'line-real') && !empty(a:dict[a:item]['line-real'])
-        let l:end_line = l:line
-        let l:line = a:dict[a:item]['line-real']
-    endif
-
-    for l:match in ale#util#GetMatches(l:text, l:linepatternmessage)
-        let l:line = l:match[1]
-        let l:counter -= 1
-    endfor
-
-" Currently, filenames and line numbers are not always given in the error output
-    if l:counter < 2
-    \&& ( ale#path#IsBufferPath(a:buffer, l:file) || l:file is# '' )
-        return {
-        \   'lnum': '' . l:line,
-        \   'text': l:text,
-        \   'type': a:type,
-        \   'col': l:column,
-        \   'end_lnum': l:end_line,
-        \   'code': a:item,
-        \}
-    endif
-
-    return ''
-endfunction
-
-function! ale_linters#perl6#perl6#Handle(buffer, lines) abort
-    let l:output = []
-
-    if empty(a:lines)
-        return l:output
-    endif
-
-    if a:lines[0] is# 'Syntax OK'
-        return l:output
-    endif
-
-    try
-        let l:json = json_decode(join(a:lines, ''))
-    catch /E474/
-        call add(l:output, {
-        \   'lnum': '1',
-        \   'text': 'Received output in the default Perl6 error format. See :ALEDetail for details',
-        \   'detail': join(a:lines, "\n"),
-        \   'type': 'W',
-        \   })
-
-        return l:output
-    endtry
-
-    if type(l:json) is v:t_dict
-        for l:key in keys(l:json)
-            if has_key(l:json[l:key], 'sorrows')
-            \&& has_key(l:json[l:key], 'worries')
-                if !empty(l:json[l:key]['sorrows'])
-                    for l:dictionary in get(l:json[l:key], 'sorrows')
-                        for l:item in keys(l:dictionary)
-                            let l:result =
-                            \   ale_linters#perl6#perl6#ExtractError(
-                            \       l:dictionary,
-                            \       l:item,
-                            \       'E',
-                            \       a:buffer,
-                            \   )
-
-                            if l:result isnot# ''
-                                call add(l:output, l:result)
-                            endif
-                        endfor
-                    endfor
-                endif
-
-                if !empty(l:json[l:key]['worries'])
-                    for l:dictionary in get(l:json[l:key], 'worries')
-                        for l:item in keys(l:dictionary)
-                            let l:result =
-                            \   ale_linters#perl6#perl6#ExtractError(
-                            \       l:dictionary,
-                            \       l:item,
-                            \       'W',
-                            \       a:buffer,
-                            \   )
-
-                            if l:result isnot# ''
-                                call add(l:output, l:result)
-                            endif
-                        endfor
-                    endfor
-                endif
-            else
-                let l:result = ale_linters#perl6#perl6#ExtractError(
-                \     l:json,
-                \     l:key,
-                \     'E',
-                \     a:buffer,
-                \   )
-
-                if l:result isnot# ''
-                    call add(l:output, l:result)
-                endif
-            endif
-        endfor
-    endif
-
-    return l:output
-endfunction
-
-call ale#linter#Define('perl6', {
-\   'name': 'perl6',
-\   'executable': function('ale_linters#perl6#perl6#GetExecutable'),
-\   'output_stream': 'both',
-\   'command': function('ale_linters#perl6#perl6#GetCommand'),
-\   'callback': 'ale_linters#perl6#perl6#Handle',
-\})
-
diff --git a/sources_non_forked/ale/ale_linters/php/langserver.vim b/sources_non_forked/ale/ale_linters/php/langserver.vim
deleted file mode 100644
index fdd1bf2..0000000
--- a/sources_non_forked/ale/ale_linters/php/langserver.vim
+++ /dev/null
@@ -1,27 +0,0 @@
-" Author: Eric Stern <eric@ericstern.com>
-" Description: PHP Language server integration for ALE
-
-call ale#Set('php_langserver_executable', 'php-language-server.php')
-call ale#Set('php_langserver_use_global', get(g:, 'ale_use_global_executables', 0))
-
-function! ale_linters#php#langserver#GetProjectRoot(buffer) abort
-    let l:composer_path = ale#path#FindNearestFile(a:buffer, 'composer.json')
-
-    if (!empty(l:composer_path))
-        return fnamemodify(l:composer_path, ':h')
-    endif
-
-    let l:git_path = ale#path#FindNearestDirectory(a:buffer, '.git')
-
-    return !empty(l:git_path) ? fnamemodify(l:git_path, ':h:h') : ''
-endfunction
-
-call ale#linter#Define('php', {
-\   'name': 'langserver',
-\   'lsp': 'stdio',
-\   'executable': {b -> ale#node#FindExecutable(b, 'php_langserver', [
-\       'vendor/bin/php-language-server.php',
-\   ])},
-\   'command': 'php %e',
-\   'project_root': function('ale_linters#php#langserver#GetProjectRoot'),
-\})
diff --git a/sources_non_forked/ale/ale_linters/php/phan.vim b/sources_non_forked/ale/ale_linters/php/phan.vim
deleted file mode 100644
index 53cb1ea..0000000
--- a/sources_non_forked/ale/ale_linters/php/phan.vim
+++ /dev/null
@@ -1,73 +0,0 @@
-" Author: diegoholiveira <https://github.com/diegoholiveira>, haginaga <https://github.com/haginaga>
-" Description: static analyzer for PHP
-
-" Define the minimum severity
-let g:ale_php_phan_minimum_severity = get(g:, 'ale_php_phan_minimum_severity', 0)
-
-let g:ale_php_phan_executable = get(g:, 'ale_php_phan_executable', 'phan')
-let g:ale_php_phan_use_client = get(g:, 'ale_php_phan_use_client', 0)
-
-function! ale_linters#php#phan#GetExecutable(buffer) abort
-    let l:executable = ale#Var(a:buffer, 'php_phan_executable')
-
-    if ale#Var(a:buffer, 'php_phan_use_client') == 1 && l:executable is# 'phan'
-        let l:executable = 'phan_client'
-    endif
-
-    return l:executable
-endfunction
-
-function! ale_linters#php#phan#GetCommand(buffer) abort
-    if ale#Var(a:buffer, 'php_phan_use_client') == 1
-        let l:args = '-l '
-        \   . ' %s'
-    else
-        let l:args = '-y '
-        \   . ale#Var(a:buffer, 'php_phan_minimum_severity')
-        \   . ' %s'
-    endif
-
-    let l:executable = ale_linters#php#phan#GetExecutable(a:buffer)
-
-    return ale#Escape(l:executable) . ' ' . l:args
-endfunction
-
-function! ale_linters#php#phan#Handle(buffer, lines) abort
-    " Matches against lines like the following:
-    if ale#Var(a:buffer, 'php_phan_use_client') == 1
-        " Phan error: ERRORTYPE: message in /path/to/some-filename.php on line nnn
-        let l:pattern = '^Phan error: \(\w\+\): \(.\+\) in \(.\+\) on line \(\d\+\)$'
-    else
-        " /path/to/some-filename.php:18 ERRORTYPE message
-        let l:pattern = '^.*:\(\d\+\)\s\(\w\+\)\s\(.\+\)$'
-    endif
-
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        if ale#Var(a:buffer, 'php_phan_use_client') == 1
-            let l:dict = {
-            \   'lnum': l:match[4] + 0,
-            \   'text': l:match[2],
-            \   'type': 'W',
-            \}
-        else
-            let l:dict = {
-            \   'lnum': l:match[1] + 0,
-            \   'text': l:match[3],
-            \   'type': 'W',
-            \}
-        endif
-
-        call add(l:output, l:dict)
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('php', {
-\   'name': 'phan',
-\   'executable': function('ale_linters#php#phan#GetExecutable'),
-\   'command': function('ale_linters#php#phan#GetCommand'),
-\   'callback': 'ale_linters#php#phan#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/php/php.vim b/sources_non_forked/ale/ale_linters/php/php.vim
deleted file mode 100644
index 51a109b..0000000
--- a/sources_non_forked/ale/ale_linters/php/php.vim
+++ /dev/null
@@ -1,39 +0,0 @@
-" Author: Spencer Wood <https://github.com/scwood>, Adriaan Zonnenberg <amz@adriaan.xyz>
-" Description: This file adds support for checking PHP with php-cli
-
-call ale#Set('php_php_executable', 'php')
-
-function! ale_linters#php#php#Handle(buffer, lines) abort
-    " Matches patterns like the following:
-    "
-    " PHP 7.1<= - Parse error:  syntax error, unexpected ';', expecting ']' in - on line 15
-    " PHP 7.2>= - Parse error:  syntax error, unexpected ';', expecting ']' in Standard input code on line 15
-    let l:pattern = '\v^%(Fatal|Parse) error:\s+(.+unexpected ''(.+)%(expecting.+)@<!''.*|.+) in %(-|Standard input code) on line (\d+)'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        let l:col = empty(l:match[2]) ? 0 : stridx(getline(l:match[3]), l:match[2]) + 1
-
-        let l:obj = {
-        \   'lnum': l:match[3] + 0,
-        \   'col': l:col,
-        \   'text': l:match[1],
-        \}
-
-        if l:col != 0
-            let l:obj.end_col = l:col + strlen(l:match[2]) - 1
-        endif
-
-        call add(l:output, l:obj)
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('php', {
-\   'name': 'php',
-\   'executable': {b -> ale#Var(b, 'php_php_executable')},
-\   'output_stream': 'stdout',
-\   'command': '%e -l -d error_reporting=E_ALL -d display_errors=1 -d log_errors=0 --',
-\   'callback': 'ale_linters#php#php#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/php/phpcs.vim b/sources_non_forked/ale/ale_linters/php/phpcs.vim
deleted file mode 100644
index 11b81e8..0000000
--- a/sources_non_forked/ale/ale_linters/php/phpcs.vim
+++ /dev/null
@@ -1,54 +0,0 @@
-" Author: jwilliams108 <https://github.com/jwilliams108>, Eric Stern <https://github.com/firehed>
-" Description: phpcs for PHP files
-
-let g:ale_php_phpcs_standard = get(g:, 'ale_php_phpcs_standard', '')
-
-call ale#Set('php_phpcs_options', '')
-call ale#Set('php_phpcs_executable', 'phpcs')
-call ale#Set('php_phpcs_use_global', get(g:, 'ale_use_global_executables', 0))
-
-function! ale_linters#php#phpcs#GetCommand(buffer) abort
-    let l:standard = ale#Var(a:buffer, 'php_phpcs_standard')
-    let l:standard_option = !empty(l:standard)
-    \   ? '--standard=' . ale#Escape(l:standard)
-    \   : ''
-
-    return ale#path#BufferCdString(a:buffer)
-    \   . '%e -s --report=emacs --stdin-path=%s'
-    \   . ale#Pad(l:standard_option)
-    \   . ale#Pad(ale#Var(a:buffer, 'php_phpcs_options'))
-endfunction
-
-function! ale_linters#php#phpcs#Handle(buffer, lines) abort
-    " Matches against lines like the following:
-    "
-    " /path/to/some-filename.php:18:3: error - Line indented incorrectly; expected 4 spaces, found 2 (Generic.WhiteSpace.ScopeIndent.IncorrectExact)
-    let l:pattern = '^.*:\(\d\+\):\(\d\+\): \(.\+\) - \(.\+\) (\(.\+\))$'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        let l:code = l:match[5]
-        let l:text = l:match[4] . ' (' . l:code . ')'
-        let l:type = l:match[3]
-
-        call add(l:output, {
-        \   'lnum': l:match[1] + 0,
-        \   'col': l:match[2] + 0,
-        \   'text': l:text,
-        \   'type': l:type is# 'error' ? 'E' : 'W',
-        \   'sub_type': 'style',
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('php', {
-\   'name': 'phpcs',
-\   'executable': {b -> ale#node#FindExecutable(b, 'php_phpcs', [
-\       'vendor/bin/phpcs',
-\       'phpcs'
-\   ])},
-\   'command': function('ale_linters#php#phpcs#GetCommand'),
-\   'callback': 'ale_linters#php#phpcs#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/php/phpmd.vim b/sources_non_forked/ale/ale_linters/php/phpmd.vim
deleted file mode 100644
index 9b1d1e4..0000000
--- a/sources_non_forked/ale/ale_linters/php/phpmd.vim
+++ /dev/null
@@ -1,38 +0,0 @@
-" Author: medains <https://github.com/medains>, David Sierra <https://github.com/davidsierradz>
-" Description: phpmd for PHP files
-
-let g:ale_php_phpmd_executable = get(g:, 'ale_php_phpmd_executable', 'phpmd')
-
-" Set to change the ruleset
-let g:ale_php_phpmd_ruleset = get(g:, 'ale_php_phpmd_ruleset', 'cleancode,codesize,controversial,design,naming,unusedcode')
-
-function! ale_linters#php#phpmd#GetCommand(buffer) abort
-    return '%e %s text'
-    \   . ale#Pad(ale#Var(a:buffer, 'php_phpmd_ruleset'))
-    \   . ' --ignore-violations-on-exit %t'
-endfunction
-
-function! ale_linters#php#phpmd#Handle(buffer, lines) abort
-    " Matches against lines like the following:
-    "
-    " /path/to/some-filename.php:18 message
-    let l:pattern = '^.*:\(\d\+\)\s\+\(.\+\)$'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        call add(l:output, {
-        \   'lnum': l:match[1] + 0,
-        \   'text': l:match[2],
-        \   'type': 'W',
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('php', {
-\   'name': 'phpmd',
-\   'executable': {b -> ale#Var(b, 'php_phpmd_executable')},
-\   'command': function('ale_linters#php#phpmd#GetCommand'),
-\   'callback': 'ale_linters#php#phpmd#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/php/phpstan.vim b/sources_non_forked/ale/ale_linters/php/phpstan.vim
deleted file mode 100644
index 78f7dd1..0000000
--- a/sources_non_forked/ale/ale_linters/php/phpstan.vim
+++ /dev/null
@@ -1,74 +0,0 @@
-" Author: medains <https://github.com/medains>, ardis <https://github.com/ardisdreelath>
-" Description: phpstan for PHP files
-
-" Set to change the ruleset
-let g:ale_php_phpstan_executable = get(g:, 'ale_php_phpstan_executable', 'phpstan')
-let g:ale_php_phpstan_level = get(g:, 'ale_php_phpstan_level', '')
-let g:ale_php_phpstan_configuration = get(g:, 'ale_php_phpstan_configuration', '')
-let g:ale_php_phpstan_autoload = get(g:, 'ale_php_phpstan_autoload', '')
-
-function! ale_linters#php#phpstan#GetCommand(buffer, version) abort
-    let l:configuration = ale#Var(a:buffer, 'php_phpstan_configuration')
-    let l:configuration_option = !empty(l:configuration)
-    \   ? ' -c ' . ale#Escape(l:configuration)
-    \   : ''
-
-    let l:autoload = ale#Var(a:buffer, 'php_phpstan_autoload')
-    let l:autoload_option = !empty(l:autoload)
-    \   ? ' -a ' . ale#Escape(l:autoload)
-    \   : ''
-
-    let l:level =  ale#Var(a:buffer, 'php_phpstan_level')
-    let l:config_file_exists = ale#path#FindNearestFile(a:buffer, 'phpstan.neon')
-
-    if empty(l:level) && empty(l:config_file_exists)
-        " if no configuration file is found, then use 4 as a default level
-        let l:level = '4'
-    endif
-
-    let l:level_option = !empty(l:level)
-    \   ? ' -l ' . ale#Escape(l:level)
-    \   : ''
-
-    let l:error_format = ale#semver#GTE(a:version, [0, 10, 3])
-    \   ? ' --error-format raw'
-    \   : ' --errorFormat raw'
-
-    return '%e analyze --no-progress'
-    \   . l:error_format
-    \   . l:configuration_option
-    \   . l:autoload_option
-    \   . l:level_option
-    \   . ' %s'
-endfunction
-
-function! ale_linters#php#phpstan#Handle(buffer, lines) abort
-    " Matches against lines like the following:
-    "
-    " filename.php:15:message
-    " C:\folder\filename.php:15:message
-    let l:pattern = '^\([a-zA-Z]:\)\?[^:]\+:\(\d\+\):\(.*\)$'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        call add(l:output, {
-        \   'lnum': l:match[2] + 0,
-        \   'text': l:match[3],
-        \   'type': 'E',
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('php', {
-\   'name': 'phpstan',
-\   'executable': {b -> ale#Var(b, 'php_phpstan_executable')},
-\   'command': {buffer -> ale#semver#RunWithVersionCheck(
-\       buffer,
-\       ale#Var(buffer, 'php_phpstan_executable'),
-\       '%e --version',
-\       function('ale_linters#php#phpstan#GetCommand'),
-\   )},
-\   'callback': 'ale_linters#php#phpstan#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/php/psalm.vim b/sources_non_forked/ale/ale_linters/php/psalm.vim
deleted file mode 100644
index ab4dbbc..0000000
--- a/sources_non_forked/ale/ale_linters/php/psalm.vim
+++ /dev/null
@@ -1,26 +0,0 @@
-" Author: Matt Brown <https://github.com/muglug>
-" Description: plugin for Psalm, static analyzer for PHP
-
-call ale#Set('psalm_langserver_executable', 'psalm')
-call ale#Set('psalm_langserver_options', '')
-call ale#Set('psalm_langserver_use_global', get(g:, 'ale_use_global_executables', 0))
-
-function! ale_linters#php#psalm#GetProjectRoot(buffer) abort
-    let l:git_path = ale#path#FindNearestDirectory(a:buffer, '.git')
-
-    return !empty(l:git_path) ? fnamemodify(l:git_path, ':h:h') : ''
-endfunction
-
-function! ale_linters#php#psalm#GetCommand(buffer) abort
-    return '%e --language-server' . ale#Pad(ale#Var(a:buffer, 'psalm_langserver_options'))
-endfunction
-
-call ale#linter#Define('php', {
-\   'name': 'psalm',
-\   'lsp': 'stdio',
-\   'executable': {b -> ale#node#FindExecutable(b, 'psalm_langserver', [
-\       'vendor/bin/psalm',
-\   ])},
-\   'command': function('ale_linters#php#psalm#GetCommand'),
-\   'project_root': function('ale_linters#php#psalm#GetProjectRoot'),
-\})
diff --git a/sources_non_forked/ale/ale_linters/po/alex.vim b/sources_non_forked/ale/ale_linters/po/alex.vim
deleted file mode 100644
index 05c67f1..0000000
--- a/sources_non_forked/ale/ale_linters/po/alex.vim
+++ /dev/null
@@ -1,4 +0,0 @@
-" Author: Cian Butler https://github.com/butlerx
-" Description: alex for PO files
-
-call ale#handlers#alex#DefineLinter('po', '--text')
diff --git a/sources_non_forked/ale/ale_linters/po/msgfmt.vim b/sources_non_forked/ale/ale_linters/po/msgfmt.vim
deleted file mode 100644
index 8279ccd..0000000
--- a/sources_non_forked/ale/ale_linters/po/msgfmt.vim
+++ /dev/null
@@ -1,30 +0,0 @@
-" Author: Cian Butler https://github.com/butlerx
-" Description: msgfmt for PO files
-
-function! ale_linters#po#msgfmt#Handle(buffer, lines) abort
-    let l:results = ale#handlers#unix#HandleAsWarning(a:buffer, a:lines)
-    let l:index = 0
-
-    for l:item in l:results
-        if l:index > 0 && l:item.text =~? 'this is the location of the first definition'
-            let l:last_item = l:results[l:index - 1]
-
-            if l:last_item.text =~? 'duplicate message definition'
-                let l:last_item.text = 'duplicate of message at line ' . l:item.lnum
-                let l:item.text = 'first location of duplicate of message at line ' . l:last_item.lnum
-            endif
-        endif
-
-        let l:index += 1
-    endfor
-
-    return l:results
-endfunction
-
-call ale#linter#Define('po', {
-\   'name': 'msgfmt',
-\   'executable': 'msgfmt',
-\   'output_stream': 'stderr',
-\   'command': 'msgfmt --statistics --output-file=- %t',
-\   'callback': 'ale_linters#po#msgfmt#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/po/proselint.vim b/sources_non_forked/ale/ale_linters/po/proselint.vim
deleted file mode 100644
index ce13250..0000000
--- a/sources_non_forked/ale/ale_linters/po/proselint.vim
+++ /dev/null
@@ -1,9 +0,0 @@
-" Author: Cian Butler https://github.com/butlerx
-" Description: proselint for PO files
-
-call ale#linter#Define('po', {
-\   'name': 'proselint',
-\   'executable': 'proselint',
-\   'command': 'proselint %t',
-\   'callback': 'ale#handlers#unix#HandleAsWarning',
-\})
diff --git a/sources_non_forked/ale/ale_linters/po/writegood.vim b/sources_non_forked/ale/ale_linters/po/writegood.vim
deleted file mode 100644
index 1468647..0000000
--- a/sources_non_forked/ale/ale_linters/po/writegood.vim
+++ /dev/null
@@ -1,4 +0,0 @@
-" Author: Cian Butler https://github.com/butlerx
-" Description: write-good for PO files
-
-call ale#handlers#writegood#DefineLinter('po')
diff --git a/sources_non_forked/ale/ale_linters/pod/alex.vim b/sources_non_forked/ale/ale_linters/pod/alex.vim
deleted file mode 100644
index c89f833..0000000
--- a/sources_non_forked/ale/ale_linters/pod/alex.vim
+++ /dev/null
@@ -1,4 +0,0 @@
-" Author: Johannes Wienke <languitar@semipol.de>
-" Description: alex for pod files
-
-call ale#handlers#alex#DefineLinter('pod', '--text')
diff --git a/sources_non_forked/ale/ale_linters/pod/proselint.vim b/sources_non_forked/ale/ale_linters/pod/proselint.vim
deleted file mode 100644
index 2eb83f5..0000000
--- a/sources_non_forked/ale/ale_linters/pod/proselint.vim
+++ /dev/null
@@ -1,9 +0,0 @@
-" Author: Daniel M. Capella https://github.com/polyzen
-" Description: proselint for Pod files
-
-call ale#linter#Define('pod', {
-\   'name': 'proselint',
-\   'executable': 'proselint',
-\   'command': 'proselint %t',
-\   'callback': 'ale#handlers#unix#HandleAsWarning',
-\})
diff --git a/sources_non_forked/ale/ale_linters/pod/writegood.vim b/sources_non_forked/ale/ale_linters/pod/writegood.vim
deleted file mode 100644
index 9f5461e..0000000
--- a/sources_non_forked/ale/ale_linters/pod/writegood.vim
+++ /dev/null
@@ -1,4 +0,0 @@
-" Author: Sumner Evans <sumner.evans98@gmail.com>
-" Description: write-good for Pod files
-
-call ale#handlers#writegood#DefineLinter('pod')
diff --git a/sources_non_forked/ale/ale_linters/pony/ponyc.vim b/sources_non_forked/ale/ale_linters/pony/ponyc.vim
deleted file mode 100644
index 6d4594f..0000000
--- a/sources_non_forked/ale/ale_linters/pony/ponyc.vim
+++ /dev/null
@@ -1,16 +0,0 @@
-" Description: ponyc linter for pony files
-
-call ale#Set('pony_ponyc_executable', 'ponyc')
-call ale#Set('pony_ponyc_options', '--pass paint')
-
-function! ale_linters#pony#ponyc#GetCommand(buffer) abort
-    return '%e' . ale#Pad(ale#Var(a:buffer, 'pony_ponyc_options'))
-endfunction
-
-call ale#linter#Define('pony', {
-\   'name': 'ponyc',
-\   'output_stream': 'stderr',
-\   'executable': {b -> ale#Var(b, 'pony_ponyc_executable')},
-\   'command': function('ale_linters#pony#ponyc#GetCommand'),
-\   'callback': 'ale#handlers#pony#HandlePonycFormat',
-\})
diff --git a/sources_non_forked/ale/ale_linters/powershell/powershell.vim b/sources_non_forked/ale/ale_linters/powershell/powershell.vim
deleted file mode 100644
index 5f49f72..0000000
--- a/sources_non_forked/ale/ale_linters/powershell/powershell.vim
+++ /dev/null
@@ -1,100 +0,0 @@
-" Author: Jesse Harris - https://github.com/zigford
-" Description: This file adds support for powershell scripts synatax errors
-
-call ale#Set('powershell_powershell_executable', 'pwsh')
-
-function! ale_linters#powershell#powershell#GetExecutable(buffer) abort
-    return ale#Var(a:buffer, 'powershell_powershell_executable')
-endfunction
-
-" Some powershell magic to show syntax errors without executing the script
-" thanks to keith hill:
-" https://rkeithhill.wordpress.com/2007/10/30/powershell-quicktip-preparsing-scripts-to-check-for-syntax-errors/
-function! ale_linters#powershell#powershell#GetCommand(buffer) abort
-    let l:script = ['Param($Script);
-    \   $ErrorView = "Normal";
-    \   trap {$_;continue} & {
-    \   $Contents = Get-Content -Path $Script;
-    \   $Contents = [string]::Join([Environment]::NewLine, $Contents);
-    \   [void]$ExecutionContext.InvokeCommand.NewScriptBlock($Contents);
-    \   };']
-
-    return ale#powershell#RunPowerShell(
-    \   a:buffer, 'powershell_powershell', l:script)
-endfunction
-
-" Parse powershell error output using regex into a list of dicts
-function! ale_linters#powershell#powershell#Handle(buffer, lines) abort
-    let l:output = []
-    " Our 3 patterns we need to scrape the data for the dicts
-    let l:patterns = [
-    \   '\v^At line:(\d+) char:(\d+)',
-    \   '\v^(At|\+| )@!.*',
-    \   '\vFullyQualifiedErrorId : (\w+)',
-    \]
-
-    let l:matchcount = 0
-
-    for l:match in ale#util#GetMatches(a:lines, l:patterns)
-        " We want to work with 3 matches per syntax error
-        let l:matchcount = l:matchcount + 1
-
-        if l:matchcount == 1 || str2nr(l:match[1])
-            " First match consists of 2 capture groups, and
-            " can capture the line and col
-            if exists('l:item')
-                " We may be here because the last syntax
-                " didn't emit a code, and so only had 2
-                " matches
-                call add(l:output, l:item)
-                let l:matchcount = 1
-            endif
-
-            " If the match is 0, it was a failed match
-            " probably due to an unexpected token which
-            " contained a newline. Reset matchcount. to
-            " continue to the next match
-            if !empty(l:match[1])
-                let l:item = {
-                \   'lnum': str2nr(l:match[1]),
-                \   'col': str2nr(l:match[2]),
-                \   'type': 'E',
-                \}
-            else
-                let l:matchcount = 0
-            endif
-        elseif l:matchcount == 2
-            " Second match[0] grabs the full line in order
-            " to handles the text
-            let l:item['text'] = l:match[0]
-        else
-            " Final match handles the code, however
-            " powershell only emits 1 code for all errors
-            " so, we get the final code on the last error
-            " and loop over the previously added items to
-            " append the code we now know
-            call add(l:output, l:item)
-            unlet l:item
-
-            if len(l:match[1]) > 0
-                for l:i in l:output
-                    let l:i['code'] = l:match[1]
-                endfor
-            endif
-
-            " Reset the matchcount so we can begin gathering
-            " matches for the next syntax error
-            let l:matchcount = 0
-        endif
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('powershell', {
-\   'name': 'powershell',
-\   'executable': function('ale_linters#powershell#powershell#GetExecutable'),
-\   'command': function('ale_linters#powershell#powershell#GetCommand'),
-\   'output_stream': 'stdout',
-\   'callback': 'ale_linters#powershell#powershell#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/powershell/psscriptanalyzer.vim b/sources_non_forked/ale/ale_linters/powershell/psscriptanalyzer.vim
deleted file mode 100644
index 4794d9d..0000000
--- a/sources_non_forked/ale/ale_linters/powershell/psscriptanalyzer.vim
+++ /dev/null
@@ -1,76 +0,0 @@
-" Author: Jesse Harris - https://github.com/zigford
-" Description: This file adds support for lintng powershell scripts
-"   using the PSScriptAnalyzer module.
-
-" let g:ale_powershell_psscriptanalyzer_exclusions =
-" \ 'PSAvoidUsingWriteHost,PSAvoidGlobalVars'
-call ale#Set('powershell_psscriptanalyzer_exclusions', '')
-call ale#Set('powershell_psscriptanalyzer_executable', 'pwsh')
-call ale#Set('powershell_psscriptanalyzer_module',
-\ 'psscriptanalyzer')
-
-function! ale_linters#powershell#psscriptanalyzer#GetExecutable(buffer) abort
-    return ale#Var(a:buffer, 'powershell_psscriptanalyzer_executable')
-endfunction
-
-" Run Invoke-ScriptAnalyzer and output each linting message as 4 seperate lines
-" for each parsing
-function! ale_linters#powershell#psscriptanalyzer#GetCommand(buffer) abort
-    let l:exclude_option = ale#Var(
-    \   a:buffer, 'powershell_psscriptanalyzer_exclusions')
-    let l:module = ale#Var(
-    \   a:buffer, 'powershell_psscriptanalyzer_module')
-    let l:script = ['Param($Script);
-    \   Invoke-ScriptAnalyzer "$Script" '
-    \   . (!empty(l:exclude_option) ? '-Exclude ' . l:exclude_option : '')
-    \   . '| ForEach-Object {
-    \   $_.Line;
-    \   $_.Severity;
-    \   $_.Message;
-    \   $_.RuleName}']
-
-    return ale#powershell#RunPowerShell(
-    \   a:buffer,
-    \   'powershell_psscriptanalyzer',
-    \   l:script)
-endfunction
-
-" add every 4 lines to an item(Dict) and every item to a list
-" return the list
-function! ale_linters#powershell#psscriptanalyzer#Handle(buffer, lines) abort
-    let l:output = []
-    let l:lcount = 0
-
-    for l:line in a:lines
-        if l:lcount is# 0
-            " the very first line
-            let l:item = {'lnum': str2nr(l:line)}
-        elseif l:lcount is# 1
-            if l:line is# 'Error'
-                let l:item['type'] = 'E'
-            elseif l:line is# 'Information'
-                let l:item['type'] = 'I'
-            else
-                let l:item['type'] = 'W'
-            endif
-        elseif l:lcount is# 2
-            let l:item['text'] = l:line
-        elseif l:lcount is# 3
-            let l:item['code'] = l:line
-            call add(l:output, l:item)
-            let l:lcount = -1
-        endif
-
-        let l:lcount = l:lcount + 1
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('powershell', {
-\   'name': 'psscriptanalyzer',
-\   'executable': function('ale_linters#powershell#psscriptanalyzer#GetExecutable'),
-\   'command': function('ale_linters#powershell#psscriptanalyzer#GetCommand'),
-\   'output_stream': 'stdout',
-\   'callback': 'ale_linters#powershell#psscriptanalyzer#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/prolog/swipl.vim b/sources_non_forked/ale/ale_linters/prolog/swipl.vim
deleted file mode 100644
index 5c601c4..0000000
--- a/sources_non_forked/ale/ale_linters/prolog/swipl.vim
+++ /dev/null
@@ -1,100 +0,0 @@
-" Author: Takuya Fujiwara <tyru.exe@gmail.com>
-" Description: swipl syntax / semantic check for Prolog files
-
-call ale#Set('prolog_swipl_executable', 'swipl')
-call ale#Set('prolog_swipl_load', 'current_prolog_flag(argv, [File]), load_files(File, [sandboxed(true)]), halt.')
-call ale#Set('prolog_swipl_timeout', 3)
-call ale#Set('prolog_swipl_alarm', 'alarm(%t, (%h), _, [])')
-call ale#Set('prolog_swipl_alarm_handler', 'writeln(user_error, "ERROR: Exceeded %t seconds, Please change g:prolog_swipl_timeout to modify the limit."), halt(1)')
-
-function! ale_linters#prolog#swipl#GetCommand(buffer) abort
-    let l:goals = ale#Var(a:buffer, 'prolog_swipl_load')
-    let l:goals = l:goals =~# '^\s*$' ? 'halt' : l:goals
-    let l:timeout = ale#Var(a:buffer, 'prolog_swipl_timeout') + 0
-
-    if l:timeout > 0
-        let l:goals = s:GetAlarm(a:buffer, l:timeout) . ', ' . l:goals
-    endif
-
-    return '%e -g ' . ale#Escape(l:goals) . ' -- %s'
-endfunction
-
-function! s:GetAlarm(buffer, timeout) abort
-    let l:handler = ale#Var(a:buffer, 'prolog_swipl_alarm_handler')
-    let l:handler = s:Subst(l:handler, {'t': a:timeout})
-    let l:alarm = ale#Var(a:buffer, 'prolog_swipl_alarm')
-    let l:alarm = s:Subst(l:alarm, {'t': a:timeout, 'h': l:handler})
-
-    return l:alarm
-endfunction
-
-function! s:Subst(format, vars) abort
-    let l:vars = extend(copy(a:vars), {'%': '%'})
-
-    return substitute(a:format, '%\(.\)', '\=get(l:vars, submatch(1), "")', 'g')
-endfunction
-
-function! ale_linters#prolog#swipl#Handle(buffer, lines) abort
-    let l:pattern = '\v^(ERROR|Warning)+%(:\s*[^:]+:(\d+)%(:(\d+))?)?:\s*(.*)$'
-    let l:output = []
-    let l:i = 0
-
-    while l:i < len(a:lines)
-        let l:match = matchlist(a:lines[l:i], l:pattern)
-
-        if empty(l:match)
-            let l:i += 1
-            continue
-        endif
-
-        let [l:i, l:text] = s:GetErrMsg(l:i, a:lines, l:match[4])
-        let l:item = {
-        \   'lnum': (l:match[2] + 0 ? l:match[2] + 0 : 1),
-        \   'col': l:match[3] + 0,
-        \   'text': l:text,
-        \   'type': (l:match[1] is# 'ERROR' ? 'E' : 'W'),
-        \}
-
-        if !s:Ignore(l:item)
-            call add(l:output, l:item)
-        endif
-    endwhile
-
-    return l:output
-endfunction
-
-" This returns [<next line number>, <error message string>]
-function! s:GetErrMsg(i, lines, text) abort
-    if a:text !~# '^\s*$'
-        return [a:i + 1, a:text]
-    endif
-
-    let l:i = a:i + 1
-    let l:text = []
-
-    while l:i < len(a:lines) && a:lines[l:i] =~# '^\s'
-        call add(l:text, s:Trim(a:lines[l:i]))
-        let l:i += 1
-    endwhile
-
-    return [l:i, join(l:text, '. ')]
-endfunction
-
-function! s:Trim(str) abort
-    return substitute(a:str, '\v^\s+|\s+$', '', 'g')
-endfunction
-
-" Skip sandbox error which is caused by directives
-" because what we want is syntactic or semantic check.
-function! s:Ignore(item) abort
-    return a:item.type is# 'E'
-    \   && a:item.text =~# '\vNo permission to (call|directive|assert) sandboxed'
-endfunction
-
-call ale#linter#Define('prolog', {
-\   'name': 'swipl',
-\   'output_stream': 'stderr',
-\   'executable': {b -> ale#Var(b, 'prolog_swipl_executable')},
-\   'command': function('ale_linters#prolog#swipl#GetCommand'),
-\   'callback': 'ale_linters#prolog#swipl#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/proto/protoc_gen_lint.vim b/sources_non_forked/ale/ale_linters/proto/protoc_gen_lint.vim
deleted file mode 100644
index c3d1093..0000000
--- a/sources_non_forked/ale/ale_linters/proto/protoc_gen_lint.vim
+++ /dev/null
@@ -1,27 +0,0 @@
-" Author: Jeff Willette <jrwillette88@gmail.com>
-" Description: run the protoc-gen-lint plugin for the protoc binary
-
-call ale#Set('proto_protoc_gen_lint_options', '')
-
-function! ale_linters#proto#protoc_gen_lint#GetCommand(buffer) abort
-    let l:dirname = expand('#' . a:buffer . ':p:h')
-
-    let l:options = ['-I ' . ale#Escape(l:dirname)]
-
-    if !empty(ale#Var(a:buffer, 'proto_protoc_gen_lint_options'))
-        let l:options += [ale#Var(a:buffer, 'proto_protoc_gen_lint_options')]
-    endif
-
-    let l:options += ['--lint_out=. ' . '%s']
-
-    return 'protoc' . ' ' . join(l:options)
-endfunction
-
-call ale#linter#Define('proto', {
-\   'name': 'protoc-gen-lint',
-\   'lint_file': 1,
-\   'output_stream': 'stderr',
-\   'executable': 'protoc',
-\   'command': function('ale_linters#proto#protoc_gen_lint#GetCommand'),
-\   'callback': 'ale#handlers#unix#HandleAsError',
-\})
diff --git a/sources_non_forked/ale/ale_linters/pug/puglint.vim b/sources_non_forked/ale/ale_linters/pug/puglint.vim
deleted file mode 100644
index c819cc4..0000000
--- a/sources_non_forked/ale/ale_linters/pug/puglint.vim
+++ /dev/null
@@ -1,56 +0,0 @@
-" Author: w0rp - <devw0rp@gmail.com>
-" Description: pug-lint for checking Pug/Jade files.
-
-call ale#Set('pug_puglint_options', '')
-call ale#Set('pug_puglint_executable', 'pug-lint')
-call ale#Set('pug_puglint_use_global', get(g:, 'ale_use_global_executables', 0))
-
-function! s:FindConfig(buffer) abort
-    for l:filename in [
-    \   '.pug-lintrc',
-    \   '.pug-lintrc.js',
-    \   '.pug-lintrc.json',
-    \   'package.json',
-    \]
-        let l:config = ale#path#FindNearestFile(a:buffer, l:filename)
-
-        if !empty(l:config)
-            return l:config
-        endif
-    endfor
-
-    return ''
-endfunction
-
-function! ale_linters#pug#puglint#GetCommand(buffer) abort
-    let l:options = ale#Var(a:buffer, 'pug_puglint_options')
-    let l:config = s:FindConfig(a:buffer)
-
-    return '%e' . ale#Pad(l:options)
-    \   . (!empty(l:config) ? ' -c ' . ale#Escape(l:config) : '')
-    \   . ' -r inline %t'
-endfunction
-
-function! ale_linters#pug#puglint#Handle(buffer, lines) abort
-    for l:line in a:lines[:10]
-        if l:line =~# '^SyntaxError: '
-            return [{
-            \   'lnum': 1,
-            \   'text': 'puglint configuration error (type :ALEDetail for more information)',
-            \   'detail': join(a:lines, "\n"),
-            \}]
-        endif
-    endfor
-
-    return ale#handlers#unix#HandleAsError(a:buffer, a:lines)
-endfunction
-
-call ale#linter#Define('pug', {
-\   'name': 'puglint',
-\   'executable': {b -> ale#node#FindExecutable(b, 'pug_puglint', [
-\       'node_modules/.bin/pug-lint',
-\   ])},
-\   'output_stream': 'stderr',
-\   'command': function('ale_linters#pug#puglint#GetCommand'),
-\   'callback': 'ale_linters#pug#puglint#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/puppet/languageserver.vim b/sources_non_forked/ale/ale_linters/puppet/languageserver.vim
deleted file mode 100644
index 2078695..0000000
--- a/sources_non_forked/ale/ale_linters/puppet/languageserver.vim
+++ /dev/null
@@ -1,37 +0,0 @@
-" Author: Alexander Olofsson <alexander.olofsson@liu.se>
-" Description: Puppet Language Server integration for ALE
-
-call ale#Set('puppet_languageserver_executable', 'puppet-languageserver')
-
-function! ale_linters#puppet#languageserver#GetProjectRoot(buffer) abort
-    " Note: The metadata.json file is recommended for Puppet 4+ modules, but
-    " there's no requirement to have it, so fall back to the other possible
-    " Puppet module directories
-    let l:root_path = ale#path#FindNearestFile(a:buffer, 'metadata.json')
-
-    if !empty(l:root_path)
-        return fnamemodify(l:root_path, ':h')
-    endif
-
-    for l:test_path in [
-    \   'manifests',
-    \   'templates',
-    \]
-        let l:root_path = ale#path#FindNearestDirectory(a:buffer, l:test_path)
-
-        if !empty(l:root_path)
-            return fnamemodify(l:root_path, ':h:h')
-        endif
-    endfor
-
-    return ''
-endfunction
-
-call ale#linter#Define('puppet', {
-\   'name': 'languageserver',
-\   'lsp': 'stdio',
-\   'executable': {b -> ale#Var(b, 'puppet_languageserver_executable')},
-\   'command': '%e --stdio',
-\   'language': 'puppet',
-\   'project_root': function('ale_linters#puppet#languageserver#GetProjectRoot'),
-\})
diff --git a/sources_non_forked/ale/ale_linters/puppet/puppet.vim b/sources_non_forked/ale/ale_linters/puppet/puppet.vim
deleted file mode 100644
index ae64861..0000000
--- a/sources_non_forked/ale/ale_linters/puppet/puppet.vim
+++ /dev/null
@@ -1,37 +0,0 @@
-" Author: Alexander Olofsson <alexander.olofsson@liu.se>
-
-call ale#Set('puppet_puppet_executable', 'puppet')
-call ale#Set('puppet_puppet_options', '')
-
-function! ale_linters#puppet#puppet#Handle(buffer, lines) abort
-    " Matches patterns like the following:
-    " Error: Could not parse for environment production: Syntax error at ':' at /root/puppetcode/modules/nginx/manifests/init.pp:43:12
-    " Error: Could not parse for environment production: Syntax error at '='; expected '}' at /root/puppetcode/modules/pancakes/manifests/init.pp:5"
-    " Error: Could not parse for environment production: Syntax error at 'parameter1' (file: /tmp/modules/mariadb/manifests/slave.pp, line: 4, column: 5)
-    let l:pattern = '^Error: .*: \(.\+\) \((file:\|at\) .\+\.pp\(, line: \|:\)\(\d\+\)\(, column: \|:\)\=\(\d*\)'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        call add(l:output, {
-        \   'lnum': l:match[4] + 0,
-        \   'col': l:match[6] + 0,
-        \   'text': l:match[1],
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-function! ale_linters#puppet#puppet#GetCommand(buffer) abort
-    return '%e parser validate --color=false '
-    \    . ale#Pad(ale#Var(a:buffer, 'puppet_puppet_options'))
-    \    . ' %t'
-endfunction
-
-call ale#linter#Define('puppet', {
-\   'name': 'puppet',
-\   'executable': {b -> ale#Var(b, 'puppet_puppet_executable')},
-\   'output_stream': 'stderr',
-\   'command': function('ale_linters#puppet#puppet#GetCommand'),
-\   'callback': 'ale_linters#puppet#puppet#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/puppet/puppetlint.vim b/sources_non_forked/ale/ale_linters/puppet/puppetlint.vim
deleted file mode 100644
index 985d6a4..0000000
--- a/sources_non_forked/ale/ale_linters/puppet/puppetlint.vim
+++ /dev/null
@@ -1,18 +0,0 @@
-" Author: Alexander Olofsson <alexander.olofsson@liu.se>, Robert Flechtner <flechtner@chemmedia.de>
-" Description: puppet-lint for puppet files
-
-call ale#Set('puppet_puppetlint_executable', 'puppet-lint')
-call ale#Set('puppet_puppetlint_options', '--no-autoloader_layout-check')
-
-function! ale_linters#puppet#puppetlint#GetCommand(buffer) abort
-    return '%e' . ale#Pad(ale#Var(a:buffer, 'puppet_puppetlint_options'))
-    \   . ' --log-format "-:%{line}:%{column}: %{kind}: [%{check}] %{message}"'
-    \   . ' %t'
-endfunction
-
-call ale#linter#Define('puppet', {
-\   'name': 'puppetlint',
-\   'executable': {b -> ale#Var(b, 'puppet_puppetlint_executable')},
-\   'command': function('ale_linters#puppet#puppetlint#GetCommand'),
-\   'callback': 'ale#handlers#gcc#HandleGCCFormat',
-\})
diff --git a/sources_non_forked/ale/ale_linters/purescript/ls.vim b/sources_non_forked/ale/ale_linters/purescript/ls.vim
deleted file mode 100644
index 1c5f937..0000000
--- a/sources_non_forked/ale/ale_linters/purescript/ls.vim
+++ /dev/null
@@ -1,49 +0,0 @@
-" Author: Drew Olson <drew@drewolson.org>
-" Description: Integrate ALE with purescript-language-server.
-
-call ale#Set('purescript_ls_executable', 'purescript-language-server')
-call ale#Set('purescript_ls_use_global', get(g:, 'ale_use_global_executables', 0))
-call ale#Set('purescript_ls_config', {})
-
-function! ale_linters#purescript#ls#GetExecutable(buffer) abort
-    return ale#node#FindExecutable(a:buffer, 'purescript_ls', [
-    \   'node_modules/.bin/purescript-language-server',
-    \])
-endfunction
-
-function! ale_linters#purescript#ls#GetCommand(buffer) abort
-    let l:executable = ale_linters#purescript#ls#GetExecutable(a:buffer)
-
-    return ale#Escape(l:executable) . ' --stdio'
-endfunction
-
-function! ale_linters#purescript#ls#FindProjectRoot(buffer) abort
-    let l:config = ale#path#FindNearestFile(a:buffer, 'bower.json')
-
-    if !empty(l:config)
-        return fnamemodify(l:config, ':h')
-    endif
-
-    let l:config = ale#path#FindNearestFile(a:buffer, 'psc-package.json')
-
-    if !empty(l:config)
-        return fnamemodify(l:config, ':h')
-    endif
-
-    let l:config = ale#path#FindNearestFile(a:buffer, 'spago.dhall')
-
-    if !empty(l:config)
-        return fnamemodify(l:config, ':h')
-    endif
-
-    return ''
-endfunction
-
-call ale#linter#Define('purescript', {
-\   'name': 'purescript-language-server',
-\   'lsp': 'stdio',
-\   'executable': function('ale_linters#purescript#ls#GetExecutable'),
-\   'command': function('ale_linters#purescript#ls#GetCommand'),
-\   'project_root': function('ale_linters#purescript#ls#FindProjectRoot'),
-\   'lsp_config': {b -> ale#Var(b, 'purescript_ls_config')},
-\})
diff --git a/sources_non_forked/ale/ale_linters/pyrex/cython.vim b/sources_non_forked/ale/ale_linters/pyrex/cython.vim
deleted file mode 100644
index 84382ba..0000000
--- a/sources_non_forked/ale/ale_linters/pyrex/cython.vim
+++ /dev/null
@@ -1,38 +0,0 @@
-" Author: w0rp <devw0rp@gmail.com>,
-" Nicolas Pauss <https://github.com/nicopauss>
-" Description: cython syntax checking for cython files.
-
-call ale#Set('pyrex_cython_executable', 'cython')
-call ale#Set('pyrex_cython_options', '--warning-extra')
-
-function! ale_linters#pyrex#cython#GetCommand(buffer) abort
-    let l:local_dir = ale#Escape(fnamemodify(bufname(a:buffer), ':p:h'))
-
-    return '%e --working ' . l:local_dir . ' --include-dir ' . l:local_dir
-    \   . ale#Pad(ale#Var(a:buffer, 'pyrex_cython_options'))
-    \   . ' --output-file ' . g:ale#util#nul_file . ' %t'
-endfunction
-
-function! ale_linters#pyrex#cython#Handle(buffer, lines) abort
-    let l:pattern = '\v^(\w+: )?[^:]+:(\d+):?(\d+)?:? ?(.+)$'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        call add(l:output, {
-        \   'lnum': l:match[2] + 0,
-        \   'col': l:match[3] + 0,
-        \   'text': l:match[4],
-        \   'type': l:match[1][0] is# 'w' ? 'W' : 'E',
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('pyrex', {
-\   'name': 'cython',
-\   'output_stream': 'stderr',
-\   'executable': {b -> ale#Var(b, 'pyrex_cython_executable')},
-\   'command': function('ale_linters#pyrex#cython#GetCommand'),
-\   'callback': 'ale_linters#pyrex#cython#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/python/bandit.vim b/sources_non_forked/ale/ale_linters/python/bandit.vim
deleted file mode 100644
index 554f500..0000000
--- a/sources_non_forked/ale/ale_linters/python/bandit.vim
+++ /dev/null
@@ -1,68 +0,0 @@
-" Author: Martino Pilia <martino.pilia@gmail.com>
-" Description: bandit linting for python files
-
-call ale#Set('python_bandit_executable', 'bandit')
-call ale#Set('python_bandit_options', '')
-call ale#Set('python_bandit_use_config', 1)
-call ale#Set('python_bandit_use_global', get(g:, 'ale_use_global_executables', 0))
-call ale#Set('python_bandit_auto_pipenv', 0)
-
-function! ale_linters#python#bandit#GetExecutable(buffer) abort
-    if (
-    \   ale#Var(a:buffer, 'python_auto_pipenv')
-    \   || ale#Var(a:buffer, 'python_bandit_auto_pipenv')
-    \) && ale#python#PipenvPresent(a:buffer)
-        return 'pipenv'
-    endif
-
-    return ale#python#FindExecutable(a:buffer, 'python_bandit', ['bandit'])
-endfunction
-
-function! ale_linters#python#bandit#GetCommand(buffer) abort
-    let l:executable = ale_linters#python#bandit#GetExecutable(a:buffer)
-    let l:flags = ' --format custom'
-    \   . ' --msg-template "{line}:{test_id}:{severity}:{msg}" '
-
-    if ale#Var(a:buffer, 'python_bandit_use_config')
-        let l:config_path = ale#path#FindNearestFile(a:buffer, '.bandit')
-
-        if !empty(l:config_path)
-            let l:flags = ' --ini ' . ale#Escape(l:config_path) . l:flags
-        endif
-    endif
-
-    let l:exec_args = l:executable =~? 'pipenv$'
-    \   ? ' run bandit'
-    \   : ''
-
-    return ale#Escape(l:executable) . l:exec_args
-    \   . l:flags
-    \   . ale#Pad(ale#Var(a:buffer, 'python_bandit_options'))
-    \   . ' -'
-endfunction
-
-function! ale_linters#python#bandit#Handle(buffer, lines) abort
-    " Custom format defined in GetCommand via --msg-template
-    let l:pattern = '\v^([0-9]+):(B[0-9]+):([A-Z]+):(.*)$'
-    let l:severity = {'LOW': 'I', 'MEDIUM': 'W', 'HIGH': 'E'}
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        call add(l:output, {
-        \   'bufnr': a:buffer,
-        \   'lnum': str2nr(l:match[1]),
-        \   'code': l:match[2],
-        \   'type': l:severity[l:match[3]],
-        \   'text': l:match[4],
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('python', {
-\   'name': 'bandit',
-\   'executable': function('ale_linters#python#bandit#GetExecutable'),
-\   'command': function('ale_linters#python#bandit#GetCommand'),
-\   'callback': 'ale_linters#python#bandit#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/python/flake8.vim b/sources_non_forked/ale/ale_linters/python/flake8.vim
deleted file mode 100644
index e2e7b74..0000000
--- a/sources_non_forked/ale/ale_linters/python/flake8.vim
+++ /dev/null
@@ -1,146 +0,0 @@
-" Author: w0rp <devw0rp@gmail.com>
-" Description: flake8 for python files
-
-call ale#Set('python_flake8_executable', 'flake8')
-call ale#Set('python_flake8_options', '')
-call ale#Set('python_flake8_use_global', get(g:, 'ale_use_global_executables', 0))
-call ale#Set('python_flake8_change_directory', 1)
-call ale#Set('python_flake8_auto_pipenv', 0)
-
-function! s:UsingModule(buffer) abort
-    return ale#Var(a:buffer, 'python_flake8_options') =~# ' *-m flake8'
-endfunction
-
-function! ale_linters#python#flake8#GetExecutable(buffer) abort
-    if (ale#Var(a:buffer, 'python_auto_pipenv') || ale#Var(a:buffer, 'python_flake8_auto_pipenv'))
-    \ && ale#python#PipenvPresent(a:buffer)
-        return 'pipenv'
-    endif
-
-    if !s:UsingModule(a:buffer)
-        return ale#python#FindExecutable(a:buffer, 'python_flake8', ['flake8'])
-    endif
-
-    return ale#Var(a:buffer, 'python_flake8_executable')
-endfunction
-
-function! ale_linters#python#flake8#RunWithVersionCheck(buffer) abort
-    let l:executable = ale_linters#python#flake8#GetExecutable(a:buffer)
-
-    let l:module_string = s:UsingModule(a:buffer) ? ' -m flake8' : ''
-    let l:command = ale#Escape(l:executable) . l:module_string . ' --version'
-
-    return ale#semver#RunWithVersionCheck(
-    \   a:buffer,
-    \   l:executable,
-    \   l:command,
-    \   function('ale_linters#python#flake8#GetCommand'),
-    \)
-endfunction
-
-function! ale_linters#python#flake8#GetCommand(buffer, version) abort
-    let l:cd_string = ale#Var(a:buffer, 'python_flake8_change_directory')
-    \   ? ale#path#BufferCdString(a:buffer)
-    \   : ''
-    let l:executable = ale_linters#python#flake8#GetExecutable(a:buffer)
-
-    let l:exec_args = l:executable =~? 'pipenv$'
-    \   ? ' run flake8'
-    \   : ''
-
-    " Only include the --stdin-display-name argument if we can parse the
-    " flake8 version, and it is recent enough to support it.
-    let l:display_name_args = ale#semver#GTE(a:version, [3, 0, 0])
-    \   ? ' --stdin-display-name %s'
-    \   : ''
-
-    let l:options = ale#Var(a:buffer, 'python_flake8_options')
-
-    return l:cd_string
-    \   . ale#Escape(l:executable) . l:exec_args
-    \   . (!empty(l:options) ? ' ' . l:options : '')
-    \   . ' --format=default'
-    \   . l:display_name_args . ' -'
-endfunction
-
-let s:end_col_pattern_map = {
-\   'F405': '\(.\+\) may be undefined',
-\   'F821': 'undefined name ''\([^'']\+\)''',
-\   'F999': '^''\([^'']\+\)''',
-\   'F841': 'local variable ''\([^'']\+\)''',
-\}
-
-function! ale_linters#python#flake8#Handle(buffer, lines) abort
-    let l:output = ale#python#HandleTraceback(a:lines, 10)
-
-    if !empty(l:output)
-        return l:output
-    endif
-
-    " Matches patterns line the following:
-    "
-    " Matches patterns line the following:
-    "
-    " stdin:6:6: E111 indentation is not a multiple of four
-    let l:pattern = '\v^[a-zA-Z]?:?[^:]+:(\d+):?(\d+)?: ([[:alnum:]]+):? (.*)$'
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        let l:code = l:match[3]
-
-        if (l:code is# 'W291' || l:code is# 'W293')
-        \ && !ale#Var(a:buffer, 'warn_about_trailing_whitespace')
-            " Skip warnings for trailing whitespace if the option is off.
-            continue
-        endif
-
-        if l:code is# 'W391'
-        \&& !ale#Var(a:buffer, 'warn_about_trailing_blank_lines')
-            " Skip warnings for trailing blank lines if the option is off
-            continue
-        endif
-
-        let l:item = {
-        \   'lnum': l:match[1] + 0,
-        \   'col': l:match[2] + 0,
-        \   'vcol': 1,
-        \   'text': l:match[4],
-        \   'code': l:code,
-        \   'type': 'W',
-        \}
-
-        if l:code[:0] is# 'F'
-            if l:code isnot# 'F401'
-                let l:item.type = 'E'
-            endif
-        elseif l:code[:0] is# 'E'
-            let l:item.type = 'E'
-
-            if l:code isnot# 'E999' && l:code isnot# 'E112'
-                let l:item.sub_type = 'style'
-            endif
-        elseif l:code[:0] is# 'W'
-            let l:item.sub_type = 'style'
-        endif
-
-        let l:end_col_pattern = get(s:end_col_pattern_map, l:code, '')
-
-        if !empty(l:end_col_pattern)
-            let l:end_col_match = matchlist(l:match[4], l:end_col_pattern)
-
-            if !empty(l:end_col_match)
-                let l:item.end_col = l:item.col + len(l:end_col_match[1]) - 1
-            endif
-        endif
-
-        call add(l:output, l:item)
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('python', {
-\   'name': 'flake8',
-\   'executable': function('ale_linters#python#flake8#GetExecutable'),
-\   'command': function('ale_linters#python#flake8#RunWithVersionCheck'),
-\   'callback': 'ale_linters#python#flake8#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/python/mypy.vim b/sources_non_forked/ale/ale_linters/python/mypy.vim
deleted file mode 100644
index 94dfae7..0000000
--- a/sources_non_forked/ale/ale_linters/python/mypy.vim
+++ /dev/null
@@ -1,101 +0,0 @@
-" Author: Keith Smiley <k@keith.so>, w0rp <devw0rp@gmail.com>
-" Description: mypy support for optional python typechecking
-
-call ale#Set('python_mypy_executable', 'mypy')
-call ale#Set('python_mypy_ignore_invalid_syntax', 0)
-call ale#Set('python_mypy_show_notes', 1)
-call ale#Set('python_mypy_options', '')
-call ale#Set('python_mypy_use_global', get(g:, 'ale_use_global_executables', 0))
-call ale#Set('python_mypy_auto_pipenv', 0)
-
-function! ale_linters#python#mypy#GetExecutable(buffer) abort
-    if (ale#Var(a:buffer, 'python_auto_pipenv') || ale#Var(a:buffer, 'python_mypy_auto_pipenv'))
-    \ && ale#python#PipenvPresent(a:buffer)
-        return 'pipenv'
-    endif
-
-    return ale#python#FindExecutable(a:buffer, 'python_mypy', ['mypy'])
-endfunction
-
-" The directory to change to before running mypy
-function! s:GetDir(buffer) abort
-    " If we find a directory with "mypy.ini" in it use that,
-    " else try and find the "python project" root, or failing
-    " that, run from the same folder as the current file
-    for l:path in ale#path#Upwards(expand('#' . a:buffer . ':p:h'))
-        if filereadable(l:path . '/mypy.ini')
-            return l:path
-        endif
-    endfor
-
-    let l:project_root = ale#python#FindProjectRoot(a:buffer)
-
-    return !empty(l:project_root)
-    \   ? l:project_root
-    \   : expand('#' . a:buffer . ':p:h')
-endfunction
-
-function! ale_linters#python#mypy#GetCommand(buffer) abort
-    let l:dir = s:GetDir(a:buffer)
-    let l:executable = ale_linters#python#mypy#GetExecutable(a:buffer)
-
-    let l:exec_args = l:executable =~? 'pipenv$'
-    \   ? ' run mypy'
-    \   : ''
-
-    " We have to always switch to an explicit directory for a command so
-    " we can know with certainty the base path for the 'filename' keys below.
-    return ale#path#CdString(l:dir)
-    \   . ale#Escape(l:executable) . l:exec_args
-    \   . ' --show-column-numbers '
-    \   . ale#Var(a:buffer, 'python_mypy_options')
-    \   . ' --shadow-file %s %t %s'
-endfunction
-
-function! ale_linters#python#mypy#Handle(buffer, lines) abort
-    let l:dir = s:GetDir(a:buffer)
-    " Look for lines like the following:
-    "
-    " file.py:4: error: No library stub file for module 'django.db'
-    "
-    " Lines like these should be ignored below:
-    "
-    " file.py:4: note: (Stub files are from https://github.com/python/typeshed)
-
-    let l:types = 'error|warning'
-
-    if ale#Var(a:buffer, 'python_mypy_show_notes')
-        let l:types = 'error|warning|note'
-    endif
-
-    let l:pattern = '\v^([a-zA-Z]?:?[^:]+):(\d+):?(\d+)?: ('
-    \   . l:types
-    \   . '): (.+)$'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        " Skip invalid syntax errors if the option is on.
-        if l:match[5] is# 'invalid syntax'
-        \&& ale#Var(a:buffer, 'python_mypy_ignore_invalid_syntax')
-            continue
-        endif
-
-        call add(l:output, {
-        \   'filename': ale#path#GetAbsPath(l:dir, l:match[1]),
-        \   'lnum': l:match[2] + 0,
-        \   'col': l:match[3] + 0,
-        \   'type': l:match[4] is# 'error' ? 'E' : (l:match[4] is# 'note' ? 'I': 'W'),
-        \   'text': l:match[5],
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('python', {
-\   'name': 'mypy',
-\   'executable': function('ale_linters#python#mypy#GetExecutable'),
-\   'command': function('ale_linters#python#mypy#GetCommand'),
-\   'callback': 'ale_linters#python#mypy#Handle',
-\   'output_stream': 'both'
-\})
diff --git a/sources_non_forked/ale/ale_linters/python/prospector.vim b/sources_non_forked/ale/ale_linters/python/prospector.vim
deleted file mode 100644
index ee47012..0000000
--- a/sources_non_forked/ale/ale_linters/python/prospector.vim
+++ /dev/null
@@ -1,100 +0,0 @@
-" Author: chocoelho <carlospecter@gmail.com>
-" Description: prospector linter python files
-
-call ale#Set('python_prospector_auto_pipenv', 0)
-
-let g:ale_python_prospector_executable =
-\   get(g:, 'ale_python_prospector_executable', 'prospector')
-
-let g:ale_python_prospector_options =
-\   get(g:, 'ale_python_prospector_options', '')
-
-let g:ale_python_prospector_use_global = get(g:, 'ale_python_prospector_use_global', get(g:, 'ale_use_global_executables', 0))
-
-function! ale_linters#python#prospector#GetExecutable(buffer) abort
-    if (ale#Var(a:buffer, 'python_auto_pipenv') || ale#Var(a:buffer, 'python_prospector_auto_pipenv'))
-    \ && ale#python#PipenvPresent(a:buffer)
-        return 'pipenv'
-    endif
-
-    return ale#python#FindExecutable(a:buffer, 'python_prospector', ['prospector'])
-endfunction
-
-function! ale_linters#python#prospector#GetCommand(buffer) abort
-    let l:executable = ale_linters#python#prospector#GetExecutable(a:buffer)
-
-    let l:exec_args = l:executable =~? 'pipenv$'
-    \   ? ' run prospector'
-    \   : ''
-
-    return ale#Escape(l:executable)
-    \   . l:exec_args
-    \   . ' ' . ale#Var(a:buffer, 'python_prospector_options')
-    \   . ' --messages-only --absolute-paths --zero-exit --output-format json'
-    \   . ' %s'
-endfunction
-
-function! ale_linters#python#prospector#Handle(buffer, lines) abort
-    let l:output = []
-
-    if empty(a:lines)
-        return []
-    endif
-
-    let l:prospector_error = json_decode(join(a:lines, ''))
-
-    for l:error in l:prospector_error.messages
-        if (l:error.code is# 'W291' || l:error.code is# 'W293' || l:error.code is# 'trailing-whitespace')
-        \ && !ale#Var(a:buffer, 'warn_about_trailing_whitespace')
-            " Skip warnings for trailing whitespace if the option is off.
-            continue
-        endif
-
-        if l:error.code is# 'W391'
-        \&& !ale#Var(a:buffer, 'warn_about_trailing_blank_lines')
-            " Skip warnings for trailing blank lines if the option is off
-            continue
-        endif
-
-        if l:error.source =~# '\v\[%(dodgy|mccabe|pep8|pep257|pyroma)\]$'
-            let l:sub_type = 'style'
-        else
-            let l:sub_type = ''
-        endif
-
-        if l:error.source =~# '\v\[pylint\]$'
-            let l:type = l:error.code =~? '\m^[CRW]' ? 'W' : 'E'
-        elseif l:error.source =~# '\v\[%(frosted|pep8)\]$'
-            let l:type = l:error.code =~? '\m^W' ? 'W' : 'E'
-        elseif l:error.source =~# '\v\[%(dodgy|pyroma|vulture)\]$'
-            let l:type = 'W'
-        else
-            let l:type = 'E'
-        endif
-
-        let l:item = {
-        \   'lnum': l:error.location.line,
-        \   'col': l:error.location.character + 1,
-        \   'text': l:error.message,
-        \   'code': printf('(%s) %s', l:error.source, l:error.code),
-        \   'type': l:type,
-        \   'sub_type': l:sub_type,
-        \}
-
-        if l:sub_type is# ''
-            unlet l:item.sub_type
-        endif
-
-        call add(l:output, l:item)
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('python', {
-\   'name': 'prospector',
-\   'executable': function('ale_linters#python#prospector#GetExecutable'),
-\   'command': function('ale_linters#python#prospector#GetCommand'),
-\   'callback': 'ale_linters#python#prospector#Handle',
-\   'lint_file': 1,
-\})
diff --git a/sources_non_forked/ale/ale_linters/python/pycodestyle.vim b/sources_non_forked/ale/ale_linters/python/pycodestyle.vim
deleted file mode 100644
index fb521bc..0000000
--- a/sources_non_forked/ale/ale_linters/python/pycodestyle.vim
+++ /dev/null
@@ -1,75 +0,0 @@
-" Author: Michael Thiesen <micthiesen@gmail.com>
-" Description: pycodestyle linting for python files
-
-call ale#Set('python_pycodestyle_executable', 'pycodestyle')
-call ale#Set('python_pycodestyle_options', '')
-call ale#Set('python_pycodestyle_use_global', get(g:, 'ale_use_global_executables', 0))
-call ale#Set('python_pycodestyle_auto_pipenv', 0)
-
-function! ale_linters#python#pycodestyle#GetExecutable(buffer) abort
-    if (ale#Var(a:buffer, 'python_auto_pipenv') || ale#Var(a:buffer, 'python_pycodestyle_auto_pipenv'))
-    \ && ale#python#PipenvPresent(a:buffer)
-        return 'pipenv'
-    endif
-
-    return ale#python#FindExecutable(a:buffer, 'python_pycodestyle', ['pycodestyle'])
-endfunction
-
-function! ale_linters#python#pycodestyle#GetCommand(buffer) abort
-    let l:executable = ale_linters#python#pycodestyle#GetExecutable(a:buffer)
-
-    let l:exec_args = l:executable =~? 'pipenv$'
-    \   ? ' run pycodestyle'
-    \   : ''
-
-    return ale#Escape(l:executable) . l:exec_args
-    \   . ' '
-    \   . ale#Var(a:buffer, 'python_pycodestyle_options')
-    \   . ' -'
-endfunction
-
-function! ale_linters#python#pycodestyle#Handle(buffer, lines) abort
-    let l:pattern = '\v^(\S*):(\d*):(\d*): ([EW]\d+) (.*)$'
-    let l:output = []
-
-    " lines are formatted as follows:
-    " file.py:21:26: W291 trailing whitespace
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        if(l:match[4] is# 'W291' || l:match[4] is# 'W293')
-        \&& !ale#Var(a:buffer, 'warn_about_trailing_whitespace')
-            " Skip warnings for trailing whitespace if the option is off.
-            continue
-        endif
-
-        if l:match[4] is# 'W391'
-        \&& !ale#Var(a:buffer, 'warn_about_trailing_blank_lines')
-            " Skip warnings for trailing blank lines if the option is off
-            continue
-        endif
-
-        let l:item = {
-        \   'lnum': l:match[2] + 0,
-        \   'col': l:match[3] + 0,
-        \   'type': l:match[4][0],
-        \   'sub_type': 'style',
-        \   'text': l:match[5],
-        \   'code': l:match[4],
-        \}
-
-        " E999 and E112 are syntax errors.
-        if l:match[4] is# 'E999' || l:match[4] is# 'E112'
-            unlet l:item.sub_type
-        endif
-
-        call add(l:output, l:item)
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('python', {
-\   'name': 'pycodestyle',
-\   'executable': function('ale_linters#python#pycodestyle#GetExecutable'),
-\   'command': function('ale_linters#python#pycodestyle#GetCommand'),
-\   'callback': 'ale_linters#python#pycodestyle#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/python/pydocstyle.vim b/sources_non_forked/ale/ale_linters/python/pydocstyle.vim
deleted file mode 100644
index 3901db4..0000000
--- a/sources_non_forked/ale/ale_linters/python/pydocstyle.vim
+++ /dev/null
@@ -1,73 +0,0 @@
-" Author: Pablo Acosta <pmasdev@gmail.com>
-" Description: pydocstyle for python files
-
-call ale#Set('python_pydocstyle_executable', 'pydocstyle')
-call ale#Set('python_pydocstyle_options', '')
-call ale#Set('python_pydocstyle_use_global', get(g:, 'ale_use_global_executables', 0))
-call ale#Set('python_pydocstyle_auto_pipenv', 0)
-
-function! ale_linters#python#pydocstyle#GetExecutable(buffer) abort
-    if (ale#Var(a:buffer, 'python_auto_pipenv') || ale#Var(a:buffer, 'python_pydocstyle_auto_pipenv'))
-    \ && ale#python#PipenvPresent(a:buffer)
-        return 'pipenv'
-    endif
-
-    return ale#python#FindExecutable(a:buffer, 'python_pydocstyle', ['pydocstyle'])
-endfunction
-
-function! ale_linters#python#pydocstyle#GetCommand(buffer) abort
-    let l:dir = fnamemodify(bufname(a:buffer), ':p:h')
-    let l:executable = ale_linters#python#pydocstyle#GetExecutable(a:buffer)
-
-    let l:exec_args = l:executable =~? 'pipenv$'
-    \   ? ' run pydocstyle'
-    \   : ''
-
-    return ale#path#CdString(l:dir)
-    \   . ale#Escape(l:executable) . l:exec_args
-    \   . ' ' . ale#Var(a:buffer, 'python_pydocstyle_options')
-    \   . ' ' . ale#Escape(fnamemodify(bufname(a:buffer), ':p:t'))
-endfunction
-
-function! ale_linters#python#pydocstyle#Handle(buffer, lines) abort
-    " Matches patterns like the following:
-    " mydir/myfile.py:33 in public function `myfunction`:
-    "         DXXX: Error description
-    let l:line1_pattern = '\v^.*:\s*(\d+)\s+.*$'
-    let l:line2_pattern = '\v^.*([a-zA-Z]\d+):\s*(.*)$'
-    let l:output = []
-
-    let l:num_lines = len(a:lines)
-    let l:index = 0
-
-    while l:index < l:num_lines
-        let l:lnum = matchlist(a:lines[l:index], l:line1_pattern)
-
-        if !empty(l:lnum) && (l:index + 1 < l:num_lines)
-            let l:desc = matchlist(a:lines[l:index + 1], l:line2_pattern)
-
-            if !empty(l:desc)
-                call add(l:output, {
-                \ 'lnum': l:lnum[1] + 0,
-                \ 'col': 1,
-                \ 'type': 'W',
-                \ 'text': l:desc[2],
-                \ 'code': l:desc[1],
-                \})
-            endif
-
-            let l:index = l:index + 2
-        else
-            let l:index = l:index + 1
-        endif
-    endwhile
-
-    return l:output
-endfunction
-
-call ale#linter#Define('python', {
-\   'name': 'pydocstyle',
-\   'executable': function('ale_linters#python#pydocstyle#GetExecutable'),
-\   'command': function('ale_linters#python#pydocstyle#GetCommand'),
-\   'callback': 'ale_linters#python#pydocstyle#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/python/pyflakes.vim b/sources_non_forked/ale/ale_linters/python/pyflakes.vim
deleted file mode 100644
index b512702..0000000
--- a/sources_non_forked/ale/ale_linters/python/pyflakes.vim
+++ /dev/null
@@ -1,50 +0,0 @@
-" Author: w0rp <devw0rp@gmail.com>
-" Description: pyflakes for python files
-
-call ale#Set('python_pyflakes_executable', 'pyflakes')
-call ale#Set('python_pyflakes_use_global', get(g:, 'ale_use_global_executables', 0))
-call ale#Set('python_pyflakes_auto_pipenv', 0)
-
-function! ale_linters#python#pyflakes#GetExecutable(buffer) abort
-    if (ale#Var(a:buffer, 'python_auto_pipenv') || ale#Var(a:buffer, 'python_pyflakes_auto_pipenv'))
-    \ && ale#python#PipenvPresent(a:buffer)
-        return 'pipenv'
-    endif
-
-    return ale#python#FindExecutable(a:buffer, 'python_pyflakes', ['pyflakes'])
-endfunction
-
-function! ale_linters#python#pyflakes#GetCommand(buffer) abort
-    let l:executable = ale_linters#python#pyflakes#GetExecutable(a:buffer)
-
-    let l:exec_args = l:executable =~? 'pipenv$'
-    \   ? ' run pyflakes'
-    \   : ''
-
-    return ale#Escape(l:executable)
-    \   . l:exec_args
-    \   . ' %t'
-endfunction
-
-function! ale_linters#python#pyflakes#Handle(buffer, lines) abort
-    let l:pattern = '\v^[a-zA-Z]?:?[^:]+:(\d+):(\d+)?:? (.+)$'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        call add(l:output, {
-        \   'lnum': l:match[1] + 0,
-        \   'col': l:match[2] + 0,
-        \   'text': l:match[3],
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('python', {
-\   'name': 'pyflakes',
-\   'executable': function('ale_linters#python#pyflakes#GetExecutable'),
-\   'command': function('ale_linters#python#pyflakes#GetCommand'),
-\   'callback': 'ale_linters#python#pyflakes#Handle',
-\   'output_stream': 'both',
-\})
diff --git a/sources_non_forked/ale/ale_linters/python/pylama.vim b/sources_non_forked/ale/ale_linters/python/pylama.vim
deleted file mode 100644
index 38dd283..0000000
--- a/sources_non_forked/ale/ale_linters/python/pylama.vim
+++ /dev/null
@@ -1,92 +0,0 @@
-" Author: Kevin Locke <kevin@kevinlocke.name>
-" Description: pylama for python files
-
-call ale#Set('python_pylama_executable', 'pylama')
-call ale#Set('python_pylama_options', '')
-call ale#Set('python_pylama_use_global', get(g:, 'ale_use_global_executables', 0))
-call ale#Set('python_pylama_auto_pipenv', 0)
-call ale#Set('python_pylama_change_directory', 1)
-
-function! ale_linters#python#pylama#GetExecutable(buffer) abort
-    if (ale#Var(a:buffer, 'python_auto_pipenv') || ale#Var(a:buffer, 'python_pylama_auto_pipenv'))
-    \ && ale#python#PipenvPresent(a:buffer)
-        return 'pipenv'
-    endif
-
-    return ale#python#FindExecutable(a:buffer, 'python_pylama', ['pylama'])
-endfunction
-
-function! ale_linters#python#pylama#GetCommand(buffer) abort
-    let l:cd_string = ''
-
-    if ale#Var(a:buffer, 'python_pylama_change_directory')
-        " Pylama loads its configuration from the current directory only, and
-        " applies file masks using paths relative to the current directory.
-        " Run from project root, if found, otherwise buffer dir.
-        let l:project_root = ale#python#FindProjectRoot(a:buffer)
-        let l:cd_string = l:project_root isnot# ''
-        \   ? ale#path#CdString(l:project_root)
-        \   : ale#path#BufferCdString(a:buffer)
-    endif
-
-    let l:executable = ale_linters#python#pylama#GetExecutable(a:buffer)
-    let l:exec_args = l:executable =~? 'pipenv$'
-    \   ? ' run pylama'
-    \   : ''
-
-    " Note: Using %t to lint changes would be preferable, but many pylama
-    " checks use surrounding paths (e.g. C0103 module name, E0402 relative
-    " import beyond top, etc.).  Neither is ideal.
-    return l:cd_string
-    \   . ale#Escape(l:executable) . l:exec_args
-    \   . ale#Pad(ale#Var(a:buffer, 'python_pylama_options'))
-    \   . ' %s'
-endfunction
-
-function! ale_linters#python#pylama#Handle(buffer, lines) abort
-    if empty(a:lines)
-        return []
-    endif
-
-    let l:output = ale#python#HandleTraceback(a:lines, 1)
-    let l:pattern = '\v^.{-}:([0-9]+):([0-9]+): +%(([A-Z][0-9]+):? +)?(.*)$'
-
-    " First letter of error code is a pylint-compatible message type
-    " http://pylint.pycqa.org/en/latest/user_guide/output.html#source-code-analysis-section
-    " D is for Documentation (pydocstyle)
-    let l:pylint_type_to_ale_type = {
-    \   'I': 'I',
-    \   'R': 'W',
-    \   'C': 'W',
-    \   'W': 'W',
-    \   'E': 'E',
-    \   'F': 'E',
-    \   'D': 'W',
-    \}
-    let l:pylint_type_to_ale_sub_type = {
-    \   'R': 'style',
-    \   'C': 'style',
-    \   'D': 'style',
-    \}
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        call add(l:output, {
-        \   'lnum': str2nr(l:match[1]),
-        \   'col': str2nr(l:match[2]),
-        \   'code': l:match[3],
-        \   'type': get(l:pylint_type_to_ale_type, l:match[3][0], 'W'),
-        \   'sub_type': get(l:pylint_type_to_ale_sub_type, l:match[3][0], ''),
-        \   'text': l:match[4],
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('python', {
-\   'name': 'pylama',
-\   'executable': function('ale_linters#python#pylama#GetExecutable'),
-\   'command': function('ale_linters#python#pylama#GetCommand'),
-\   'callback': 'ale_linters#python#pylama#Handle',
-\   'lint_file': 1,
-\})
diff --git a/sources_non_forked/ale/ale_linters/python/pylint.vim b/sources_non_forked/ale/ale_linters/python/pylint.vim
deleted file mode 100644
index b16d535..0000000
--- a/sources_non_forked/ale/ale_linters/python/pylint.vim
+++ /dev/null
@@ -1,92 +0,0 @@
-" Author: keith <k@keith.so>
-" Description: pylint for python files
-
-call ale#Set('python_pylint_executable', 'pylint')
-call ale#Set('python_pylint_options', '')
-call ale#Set('python_pylint_use_global', get(g:, 'ale_use_global_executables', 0))
-call ale#Set('python_pylint_change_directory', 1)
-call ale#Set('python_pylint_auto_pipenv', 0)
-call ale#Set('python_pylint_use_msg_id', 0)
-
-function! ale_linters#python#pylint#GetExecutable(buffer) abort
-    if (ale#Var(a:buffer, 'python_auto_pipenv') || ale#Var(a:buffer, 'python_pylint_auto_pipenv'))
-    \ && ale#python#PipenvPresent(a:buffer)
-        return 'pipenv'
-    endif
-
-    return ale#python#FindExecutable(a:buffer, 'python_pylint', ['pylint'])
-endfunction
-
-function! ale_linters#python#pylint#GetCommand(buffer) abort
-    let l:cd_string = ''
-
-    if ale#Var(a:buffer, 'python_pylint_change_directory')
-        " pylint only checks for pylintrc in the packages above its current
-        " directory before falling back to user and global pylintrc.
-        " Run from project root, if found, otherwise buffer dir.
-        let l:project_root = ale#python#FindProjectRoot(a:buffer)
-        let l:cd_string = l:project_root isnot# ''
-        \   ? ale#path#CdString(l:project_root)
-        \   : ale#path#BufferCdString(a:buffer)
-    endif
-
-    let l:executable = ale_linters#python#pylint#GetExecutable(a:buffer)
-
-    let l:exec_args = l:executable =~? 'pipenv$'
-    \   ? ' run pylint'
-    \   : ''
-
-    return l:cd_string
-    \   . ale#Escape(l:executable) . l:exec_args
-    \   . ' ' . ale#Var(a:buffer, 'python_pylint_options')
-    \   . ' --output-format text --msg-template="{path}:{line}:{column}: {msg_id} ({symbol}) {msg}" --reports n'
-    \   . ' %s'
-endfunction
-
-function! ale_linters#python#pylint#Handle(buffer, lines) abort
-    " Matches patterns like the following:
-    "
-    " test.py:4:4: W0101 (unreachable) Unreachable code
-    let l:pattern = '\v^[a-zA-Z]?:?[^:]+:(\d+):(\d+): ([[:alnum:]]+) \(([^(]*)\) (.*)$'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        "let l:failed = append(0, l:match)
-        let l:code = l:match[3]
-
-        if (l:code is# 'C0303')
-        \ && !ale#Var(a:buffer, 'warn_about_trailing_whitespace')
-            " Skip warnings for trailing whitespace if the option is off.
-            continue
-        endif
-
-        if l:code is# 'I0011'
-            " Skip 'Locally disabling' message
-            continue
-        endif
-
-        if ale#Var(a:buffer, 'python_pylint_use_msg_id') is# 1
-            let l:code_out = l:code
-        else
-            let l:code_out = l:match[4]
-        endif
-
-        call add(l:output, {
-        \   'lnum': l:match[1] + 0,
-        \   'col': l:match[2] + 1,
-        \   'text': l:match[5],
-        \   'code': l:code_out,
-        \   'type': l:code[:0] is# 'E' ? 'E' : 'W',
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('python', {
-\   'name': 'pylint',
-\   'executable': function('ale_linters#python#pylint#GetExecutable'),
-\   'command': function('ale_linters#python#pylint#GetCommand'),
-\   'callback': 'ale_linters#python#pylint#Handle',
-\   'lint_file': 1,
-\})
diff --git a/sources_non_forked/ale/ale_linters/python/pyls.vim b/sources_non_forked/ale/ale_linters/python/pyls.vim
deleted file mode 100644
index c7f9143..0000000
--- a/sources_non_forked/ale/ale_linters/python/pyls.vim
+++ /dev/null
@@ -1,36 +0,0 @@
-" Author: aurieh <me@aurieh.me>
-" Description: A language server for Python
-
-call ale#Set('python_pyls_executable', 'pyls')
-call ale#Set('python_pyls_use_global', get(g:, 'ale_use_global_executables', 0))
-call ale#Set('python_pyls_auto_pipenv', 0)
-call ale#Set('python_pyls_config', {})
-
-function! ale_linters#python#pyls#GetExecutable(buffer) abort
-    if (ale#Var(a:buffer, 'python_auto_pipenv') || ale#Var(a:buffer, 'python_pyls_auto_pipenv'))
-    \ && ale#python#PipenvPresent(a:buffer)
-        return 'pipenv'
-    endif
-
-    return ale#python#FindExecutable(a:buffer, 'python_pyls', ['pyls'])
-endfunction
-
-function! ale_linters#python#pyls#GetCommand(buffer) abort
-    let l:executable = ale_linters#python#pyls#GetExecutable(a:buffer)
-
-    let l:exec_args = l:executable =~? 'pipenv$'
-    \   ? ' run pyls'
-    \   : ''
-
-    return ale#Escape(l:executable) . l:exec_args
-endfunction
-
-call ale#linter#Define('python', {
-\   'name': 'pyls',
-\   'lsp': 'stdio',
-\   'executable': function('ale_linters#python#pyls#GetExecutable'),
-\   'command': function('ale_linters#python#pyls#GetCommand'),
-\   'project_root': function('ale#python#FindProjectRoot'),
-\   'completion_filter': 'ale#completion#python#CompletionItemFilter',
-\   'lsp_config': {b -> ale#Var(b, 'python_pyls_config')},
-\})
diff --git a/sources_non_forked/ale/ale_linters/python/pyre.vim b/sources_non_forked/ale/ale_linters/python/pyre.vim
deleted file mode 100644
index 4edd80f..0000000
--- a/sources_non_forked/ale/ale_linters/python/pyre.vim
+++ /dev/null
@@ -1,34 +0,0 @@
-" Author: dsifford <dereksifford@gmail.com>
-" Description: A performant type-checker supporting LSP for Python 3 created by Facebook
-
-call ale#Set('python_pyre_executable', 'pyre')
-call ale#Set('python_pyre_use_global', get(g:, 'ale_use_global_executables', 0))
-call ale#Set('python_pyre_auto_pipenv', 0)
-
-function! ale_linters#python#pyre#GetExecutable(buffer) abort
-    if (ale#Var(a:buffer, 'python_auto_pipenv') || ale#Var(a:buffer, 'python_pyre_auto_pipenv'))
-    \ && ale#python#PipenvPresent(a:buffer)
-        return 'pipenv'
-    endif
-
-    return ale#python#FindExecutable(a:buffer, 'python_pyre', ['pyre'])
-endfunction
-
-function! ale_linters#python#pyre#GetCommand(buffer) abort
-    let l:executable = ale_linters#python#pyre#GetExecutable(a:buffer)
-
-    let l:exec_args = l:executable =~? 'pipenv$'
-    \   ? ' run pyre persistent'
-    \   : ' persistent'
-
-    return ale#Escape(l:executable) . l:exec_args
-endfunction
-
-call ale#linter#Define('python', {
-\   'name': 'pyre',
-\   'lsp': 'stdio',
-\   'executable': function('ale_linters#python#pyre#GetExecutable'),
-\   'command': function('ale_linters#python#pyre#GetCommand'),
-\   'project_root': function('ale#python#FindProjectRoot'),
-\   'completion_filter': 'ale#completion#python#CompletionItemFilter',
-\})
diff --git a/sources_non_forked/ale/ale_linters/python/vulture.vim b/sources_non_forked/ale/ale_linters/python/vulture.vim
deleted file mode 100644
index d328d26..0000000
--- a/sources_non_forked/ale/ale_linters/python/vulture.vim
+++ /dev/null
@@ -1,80 +0,0 @@
-" Author: Yauheni Kirylau <actionless.loveless@gmail.com>
-" Description: vulture linting for python files
-
-call ale#Set('python_vulture_executable', 'vulture')
-call ale#Set('python_vulture_options', '')
-call ale#Set('python_vulture_use_global', get(g:, 'ale_use_global_executables', 0))
-call ale#Set('python_vulture_change_directory', 1)
-
-
-" The directory to change to before running vulture
-function! s:GetDir(buffer) abort
-    let l:project_root = ale#python#FindProjectRoot(a:buffer)
-
-    return !empty(l:project_root)
-    \   ? l:project_root
-    \   : expand('#' . a:buffer . ':p:h')
-endfunction
-
-
-function! ale_linters#python#vulture#GetExecutable(buffer) abort
-    return ale#python#FindExecutable(a:buffer, 'python_vulture', ['vulture'])
-endfunction
-
-
-function! ale_linters#python#vulture#GetCommand(buffer) abort
-    let l:change_dir = ale#Var(a:buffer, 'python_vulture_change_directory')
-    \   ? ale#path#CdString(s:GetDir(a:buffer))
-    \   : ''
-
-    let l:executable = ale_linters#python#vulture#GetExecutable(a:buffer)
-
-    let l:exec_args = l:executable =~? 'pipenv$'
-    \   ? ' run vulture'
-    \   : ''
-
-    let l:lint_dest = ale#Var(a:buffer, 'python_vulture_change_directory')
-    \   ? ' .'
-    \   : ' %s'
-
-    return l:change_dir
-    \   . ale#Escape(l:executable) . l:exec_args
-    \   . ' '
-    \   . ale#Var(a:buffer, 'python_vulture_options')
-    \   . l:lint_dest
-endfunction
-
-
-function! ale_linters#python#vulture#Handle(buffer, lines) abort
-    let l:output = ale#python#HandleTraceback(a:lines, 10)
-
-    if !empty(l:output)
-        return l:output
-    endif
-
-    " Matches patterns line the following:
-    let l:pattern = '\v^([a-zA-Z]?:?[^:]+):(\d+): (.*)$'
-    let l:dir = s:GetDir(a:buffer)
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        let l:abspath = ale#path#GetAbsPath(l:dir, l:match[1])
-        let l:item = {
-        \   'filename': l:abspath,
-        \   'lnum': l:match[2] + 0,
-        \   'text': l:match[3],
-        \   'type': 'W',
-        \}
-        call add(l:output, l:item)
-    endfor
-
-    return l:output
-endfunction
-
-
-call ale#linter#Define('python', {
-\   'name': 'vulture',
-\   'executable': function('ale_linters#python#vulture#GetExecutable'),
-\   'command': function('ale_linters#python#vulture#GetCommand'),
-\   'callback': 'ale_linters#python#vulture#Handle',
-\   'lint_file': 1,
-\})
diff --git a/sources_non_forked/ale/ale_linters/qml/qmlfmt.vim b/sources_non_forked/ale/ale_linters/qml/qmlfmt.vim
deleted file mode 100644
index 11cc941..0000000
--- a/sources_non_forked/ale/ale_linters/qml/qmlfmt.vim
+++ /dev/null
@@ -1,25 +0,0 @@
-" Author: pylipp (www.github.com/pylipp)
-" Description: qmlfmt for QML files
-
-call ale#Set('qml_qmlfmt_executable', 'qmlfmt')
-
-" Find lines like
-" Error:11:1: Expected token `}'
-function! ale_linters#qml#qmlfmt#Handle(buffer, lines) abort
-    let l:pattern = '\v^(Error|Warning):(\d+):(\d+): (.+)$'
-
-    return map(ale#util#GetMatches(a:lines, l:pattern), "{
-    \   'lnum': v:val[2] + 0,
-    \   'col': v:val[3] + 0,
-    \   'text': v:val[4],
-    \   'type': v:val[1] is# 'Warning' ? 'W' : 'E',
-    \}")
-endfunction
-
-call ale#linter#Define('qml', {
-\   'name': 'qmlfmt',
-\   'output_stream': 'stderr',
-\   'executable': {b -> ale#Var(b, 'qml_qmlfmt_executable')},
-\   'command': '%e -e',
-\   'callback': 'ale_linters#qml#qmlfmt#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/qml/qmllint.vim b/sources_non_forked/ale/ale_linters/qml/qmllint.vim
deleted file mode 100644
index c2258a1..0000000
--- a/sources_non_forked/ale/ale_linters/qml/qmllint.vim
+++ /dev/null
@@ -1,29 +0,0 @@
-" Author: pylipp (www.github.com/pylipp)
-" Description: qmllint for QML files
-
-" Find lines like
-" /home/foo_user42/code-base/qml/Screen.qml:11 : Expected token `}'
-function! ale_linters#qml#qmllint#Handle(buffer, lines) abort
-    let l:pattern = '\v^[/_-a-zA-z0-9\. ]+:(\d+) : (.*)$'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        let l:item = {
-        \   'lnum': l:match[1] + 0,
-        \   'col': 0,
-        \   'text': l:match[2],
-        \   'type': 'E',
-        \}
-        call add(l:output, l:item)
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('qml', {
-\   'name': 'qmllint',
-\   'output_stream': 'stderr',
-\   'executable': 'qmllint',
-\   'command': 'qmllint %t',
-\   'callback': 'ale_linters#qml#qmllint#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/r/lintr.vim b/sources_non_forked/ale/ale_linters/r/lintr.vim
deleted file mode 100644
index 3164c06..0000000
--- a/sources_non_forked/ale/ale_linters/r/lintr.vim
+++ /dev/null
@@ -1,35 +0,0 @@
-" Author: Michel Lang <michellang@gmail.com>, w0rp <devw0rp@gmail.com>,
-"         Fenner Macrae <fmacrae.dev@gmail.com>
-" Description: This file adds support for checking R code with lintr.
-
-let g:ale_r_lintr_options = get(g:, 'ale_r_lintr_options', 'with_defaults()')
-" A reasonable alternative default:
-"   get(g:, 'ale_r_lintr_options', 'with_defaults(object_usage_linter = NULL)')
-
-
-let g:ale_r_lintr_lint_package = get(g:, 'ale_r_lintr_lint_package', 0)
-
-function! ale_linters#r#lintr#GetCommand(buffer) abort
-    if ale#Var(a:buffer, 'r_lintr_lint_package')
-        let l:lint_cmd = 'lint_package(cache = FALSE, linters = '
-        \   . ale#Var(a:buffer, 'r_lintr_options') . ')'
-    else
-        let l:lint_cmd = 'lint(cache = FALSE, commandArgs(TRUE), '
-        \   . ale#Var(a:buffer, 'r_lintr_options') . ')'
-    endif
-
-    let l:cmd_string = 'suppressPackageStartupMessages(library(lintr));'
-    \   . l:lint_cmd
-
-    return ale#path#BufferCdString(a:buffer)
-    \   . 'Rscript --vanilla -e '
-    \   . ale#Escape(l:cmd_string) . ' %t'
-endfunction
-
-call ale#linter#Define('r', {
-\   'name': 'lintr',
-\   'executable': 'Rscript',
-\   'command': function('ale_linters#r#lintr#GetCommand'),
-\   'callback': 'ale#handlers#gcc#HandleGCCFormat',
-\   'output_stream': 'both',
-\})
diff --git a/sources_non_forked/ale/ale_linters/racket/raco.vim b/sources_non_forked/ale/ale_linters/racket/raco.vim
deleted file mode 100644
index e5ee4fb..0000000
--- a/sources_non_forked/ale/ale_linters/racket/raco.vim
+++ /dev/null
@@ -1,33 +0,0 @@
-" Author: aqui18 <https://github.com/aqui18>
-" Description: This file adds support for checking Racket code with raco.
-"              This is the same form of syntax-checking used by DrRacket as well. The
-"              downside is that it will only catch the first error, but none of the
-"              subsequent ones. This is due to how evaluation in Racket works.
-
-function! ale_linters#racket#raco#Handle(buffer, lines) abort
-    " Matches patterns
-    " <file>:<line>:<column> <message>
-    " eg:
-    " info.rkt:4:0: infotab-module: not a well-formed definition
-    let l:pattern = '^\(\s\)\@!\(.\+\):\(\d\+\):\(\d\+\): \(.\+\)$'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        call add(l:output, {
-        \   'lnum': l:match[3] + 0,
-        \   'col': l:match[4] + 0,
-        \   'type': 'E',
-        \   'text': l:match[5],
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('racket', {
-\   'name': 'raco',
-\   'executable': 'raco',
-\   'output_stream': 'stderr',
-\   'command': 'raco expand %s',
-\   'callback': 'ale_linters#racket#raco#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/reason/ls.vim b/sources_non_forked/ale/ale_linters/reason/ls.vim
deleted file mode 100644
index fb1114a..0000000
--- a/sources_non_forked/ale/ale_linters/reason/ls.vim
+++ /dev/null
@@ -1,23 +0,0 @@
-" Author: David Buchan-Swanson <github@deecewan.com>
-" Description: Integrate ALE with reason-language-server.
-
-call ale#Set('reason_ls_executable', '')
-
-function! ale_linters#reason#ls#FindProjectRoot(buffer) abort
-    let l:reason_config = ale#path#FindNearestFile(a:buffer, 'bsconfig.json')
-
-    if !empty(l:reason_config)
-        return fnamemodify(l:reason_config, ':h')
-    endif
-
-    return ''
-endfunction
-
-call ale#linter#Define('reason', {
-\   'name': 'reason-language-server',
-\   'lsp': 'stdio',
-\   'executable': {buffer -> ale#Var(buffer, 'reason_ls_executable')},
-\   'command': '%e',
-\   'project_root': function('ale_linters#reason#ls#FindProjectRoot'),
-\   'language': 'reason',
-\})
diff --git a/sources_non_forked/ale/ale_linters/reason/merlin.vim b/sources_non_forked/ale/ale_linters/reason/merlin.vim
deleted file mode 100644
index 7bef7df..0000000
--- a/sources_non_forked/ale/ale_linters/reason/merlin.vim
+++ /dev/null
@@ -1,17 +0,0 @@
-" Author: Andrey Popp -- @andreypopp
-" Description: Report errors in ReasonML code with Merlin
-
-if !exists('g:merlin')
-    finish
-endif
-
-function! ale_linters#reason#merlin#Handle(buffer, lines) abort
-    return merlin#ErrorLocList()
-endfunction
-
-call ale#linter#Define('reason', {
-\   'name': 'merlin',
-\   'executable': 'ocamlmerlin',
-\   'command': 'true',
-\   'callback': 'ale_linters#reason#merlin#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/reason/ols.vim b/sources_non_forked/ale/ale_linters/reason/ols.vim
deleted file mode 100644
index 66137e1..0000000
--- a/sources_non_forked/ale/ale_linters/reason/ols.vim
+++ /dev/null
@@ -1,14 +0,0 @@
-" Author: Michael Jungo <michaeljungo92@gmail.com>
-" Description: A language server for Reason
-
-call ale#Set('reason_ols_executable', 'ocaml-language-server')
-call ale#Set('reason_ols_use_global', get(g:, 'ale_use_global_executables', 0))
-
-call ale#linter#Define('reason', {
-\   'name': 'ols',
-\   'lsp': 'stdio',
-\   'executable': function('ale#handlers#ols#GetExecutable'),
-\   'command': function('ale#handlers#ols#GetCommand'),
-\   'language_callback': 'ale#handlers#ols#GetLanguage',
-\   'project_root': function('ale#handlers#ols#GetProjectRoot'),
-\})
diff --git a/sources_non_forked/ale/ale_linters/review/redpen.vim b/sources_non_forked/ale/ale_linters/review/redpen.vim
deleted file mode 100644
index 0006cab..0000000
--- a/sources_non_forked/ale/ale_linters/review/redpen.vim
+++ /dev/null
@@ -1,9 +0,0 @@
-" Author: rhysd https://rhysd.github.io
-" Description: Redpen, a proofreading tool (http://redpen.cc)
-
-call ale#linter#Define('review', {
-\   'name': 'redpen',
-\   'executable': 'redpen',
-\   'command': 'redpen -f review -r json %t',
-\   'callback': 'ale#handlers#redpen#HandleRedpenOutput',
-\})
diff --git a/sources_non_forked/ale/ale_linters/rst/alex.vim b/sources_non_forked/ale/ale_linters/rst/alex.vim
deleted file mode 100644
index e7ca6fa..0000000
--- a/sources_non_forked/ale/ale_linters/rst/alex.vim
+++ /dev/null
@@ -1,4 +0,0 @@
-" Author: Johannes Wienke <languitar@semipol.de>
-" Description: alex for rst files
-
-call ale#handlers#alex#DefineLinter('rst', '--text')
diff --git a/sources_non_forked/ale/ale_linters/rst/proselint.vim b/sources_non_forked/ale/ale_linters/rst/proselint.vim
deleted file mode 100644
index 018347a..0000000
--- a/sources_non_forked/ale/ale_linters/rst/proselint.vim
+++ /dev/null
@@ -1,9 +0,0 @@
-" Author: Daniel M. Capella https://github.com/polyzen
-" Description: proselint for reStructuredText files
-
-call ale#linter#Define('rst', {
-\   'name': 'proselint',
-\   'executable': 'proselint',
-\   'command': 'proselint %t',
-\   'callback': 'ale#handlers#unix#HandleAsWarning',
-\})
diff --git a/sources_non_forked/ale/ale_linters/rst/redpen.vim b/sources_non_forked/ale/ale_linters/rst/redpen.vim
deleted file mode 100644
index ac966c5..0000000
--- a/sources_non_forked/ale/ale_linters/rst/redpen.vim
+++ /dev/null
@@ -1,9 +0,0 @@
-" Author: rhysd https://rhysd.github.io
-" Description: Redpen, a proofreading tool (http://redpen.cc)
-
-call ale#linter#Define('rst', {
-\   'name': 'redpen',
-\   'executable': 'redpen',
-\   'command': 'redpen -f rest -r json %t',
-\   'callback': 'ale#handlers#redpen#HandleRedpenOutput',
-\})
diff --git a/sources_non_forked/ale/ale_linters/rst/rstcheck.vim b/sources_non_forked/ale/ale_linters/rst/rstcheck.vim
deleted file mode 100644
index 39e11d6..0000000
--- a/sources_non_forked/ale/ale_linters/rst/rstcheck.vim
+++ /dev/null
@@ -1,38 +0,0 @@
-" Author: John Nduli https://github.com/jnduli
-" Description: Rstcheck for reStructuredText files
-"
-
-function! ale_linters#rst#rstcheck#Handle(buffer, lines) abort
-    " matches: 'bad_rst.rst:1: (SEVERE/4) Title overline & underline
-    " mismatch.'
-    let l:pattern = '\v^(.+):(\d*): \(([a-zA-Z]*)/\d*\) (.+)$'
-    let l:dir = expand('#' . a:buffer . ':p:h')
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        call add(l:output, {
-        \   'filename': ale#path#GetAbsPath(l:dir, l:match[1]),
-        \   'lnum': l:match[2] + 0,
-        \   'col': 0,
-        \   'type': l:match[3] is# 'SEVERE' ? 'E' : 'W',
-        \   'text': l:match[4],
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-function! ale_linters#rst#rstcheck#GetCommand(buffer) abort
-    return ale#path#BufferCdString(a:buffer)
-    \   . 'rstcheck'
-    \   . ' %t'
-endfunction
-
-
-call ale#linter#Define('rst', {
-\   'name': 'rstcheck',
-\   'executable': 'rstcheck',
-\   'command': function('ale_linters#rst#rstcheck#GetCommand'),
-\   'callback': 'ale_linters#rst#rstcheck#Handle',
-\   'output_stream': 'both',
-\})
diff --git a/sources_non_forked/ale/ale_linters/rst/textlint.vim b/sources_non_forked/ale/ale_linters/rst/textlint.vim
deleted file mode 100644
index 56dd8db..0000000
--- a/sources_non_forked/ale/ale_linters/rst/textlint.vim
+++ /dev/null
@@ -1,9 +0,0 @@
-" Author: hokorobi <hokorobi.hokorobi@gmail.com>
-" Description: textlint, a proofreading tool (https://textlint.github.io/)
-
-call ale#linter#Define('rst', {
-\   'name': 'textlint',
-\   'executable': function('ale#handlers#textlint#GetExecutable'),
-\   'command': function('ale#handlers#textlint#GetCommand'),
-\   'callback': 'ale#handlers#textlint#HandleTextlintOutput',
-\})
diff --git a/sources_non_forked/ale/ale_linters/rst/vale.vim b/sources_non_forked/ale/ale_linters/rst/vale.vim
deleted file mode 100644
index 2e654dc..0000000
--- a/sources_non_forked/ale/ale_linters/rst/vale.vim
+++ /dev/null
@@ -1,9 +0,0 @@
-" Author: chew-z https://github.com/chew-z
-" Description: vale for RST files
-
-call ale#linter#Define('rst', {
-\   'name': 'vale',
-\   'executable': 'vale',
-\   'command': 'vale --output=JSON %t',
-\   'callback': 'ale#handlers#vale#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/rst/writegood.vim b/sources_non_forked/ale/ale_linters/rst/writegood.vim
deleted file mode 100644
index 26b1152..0000000
--- a/sources_non_forked/ale/ale_linters/rst/writegood.vim
+++ /dev/null
@@ -1,4 +0,0 @@
-" Author: Sumner Evans <sumner.evans98@gmail.com>
-" Description: write-good for reStructuredText files
-
-call ale#handlers#writegood#DefineLinter('rst')
diff --git a/sources_non_forked/ale/ale_linters/ruby/brakeman.vim b/sources_non_forked/ale/ale_linters/ruby/brakeman.vim
deleted file mode 100644
index 2dc4874..0000000
--- a/sources_non_forked/ale/ale_linters/ruby/brakeman.vim
+++ /dev/null
@@ -1,51 +0,0 @@
-" Author: Eddie Lebow https://github.com/elebow
-" Description: Brakeman, a static analyzer for Rails security
-
-call ale#Set('ruby_brakeman_options', '')
-call ale#Set('ruby_brakeman_executable', 'brakeman')
-call ale#Set('ruby_brakeman_options', '')
-
-function! ale_linters#ruby#brakeman#Handle(buffer, lines) abort
-    let l:output = []
-    let l:json = ale#util#FuzzyJSONDecode(a:lines, {})
-    let l:sep = has('win32') ? '\' : '/'
-    " Brakeman always outputs paths relative to the Rails app root
-    let l:rails_root = ale#ruby#FindRailsRoot(a:buffer)
-
-    for l:warning in get(l:json, 'warnings', [])
-        let l:text = l:warning.warning_type . ' ' . l:warning.message . ' (' . l:warning.confidence . ')'
-        let l:line = l:warning.line != v:null ? l:warning.line : 1
-
-        call add(l:output, {
-        \   'filename': l:rails_root . l:sep .  l:warning.file,
-        \   'lnum': l:line,
-        \   'type': 'W',
-        \   'text': l:text,
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-function! ale_linters#ruby#brakeman#GetCommand(buffer) abort
-    let l:rails_root = ale#ruby#FindRailsRoot(a:buffer)
-
-    if l:rails_root is? ''
-        return ''
-    endif
-
-    let l:executable = ale#Var(a:buffer, 'ruby_brakeman_executable')
-
-    return ale#ruby#EscapeExecutable(l:executable, 'brakeman')
-    \    . ' -f json -q '
-    \    . ale#Var(a:buffer, 'ruby_brakeman_options')
-    \    . ' -p ' . ale#Escape(l:rails_root)
-endfunction
-
-call ale#linter#Define('ruby', {
-\    'name': 'brakeman',
-\    'executable': {b -> ale#Var(b, 'ruby_brakeman_executable')},
-\    'command': function('ale_linters#ruby#brakeman#GetCommand'),
-\    'callback': 'ale_linters#ruby#brakeman#Handle',
-\    'lint_file': 1,
-\})
diff --git a/sources_non_forked/ale/ale_linters/ruby/debride.vim b/sources_non_forked/ale/ale_linters/ruby/debride.vim
deleted file mode 100644
index 3b2cc44..0000000
--- a/sources_non_forked/ale/ale_linters/ruby/debride.vim
+++ /dev/null
@@ -1,42 +0,0 @@
-" Author: Eddie Lebow https://github.com/elebow
-" Description: debride, a dead method detector for Ruby files
-
-call ale#Set('ruby_debride_executable', 'debride')
-call ale#Set('ruby_debride_options', '')
-
-function! ale_linters#ruby#debride#GetCommand(buffer) abort
-    let l:executable = ale#Var(a:buffer, 'ruby_debride_executable')
-
-    return ale#ruby#EscapeExecutable(l:executable, 'debride')
-    \   . ale#Var(a:buffer, 'ruby_debride_options')
-    \   . ' %s'
-endfunction
-
-function! ale_linters#ruby#debride#HandleOutput(buffer, lines) abort
-    let l:output = []
-
-    for l:line in a:lines
-        if l:line !~# '^  '
-            continue
-        endif
-
-        let l:elements = split(l:line)
-        let l:method_name = l:elements[0]
-        let l:lnum = split(l:elements[1], ':')[1]
-
-        call add(l:output, {
-        \   'lnum': 0 + l:lnum,
-        \   'text': 'Possible unused method: ' . l:method_name,
-        \   'type': 'W',
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('ruby', {
-\   'name': 'debride',
-\   'executable': {b -> ale#Var(b, 'ruby_debride_executable')},
-\   'command': function('ale_linters#ruby#debride#GetCommand'),
-\   'callback': 'ale_linters#ruby#debride#HandleOutput',
-\})
diff --git a/sources_non_forked/ale/ale_linters/ruby/rails_best_practices.vim b/sources_non_forked/ale/ale_linters/ruby/rails_best_practices.vim
deleted file mode 100644
index 3664664..0000000
--- a/sources_non_forked/ale/ale_linters/ruby/rails_best_practices.vim
+++ /dev/null
@@ -1,49 +0,0 @@
-" Author: Eddie Lebow https://github.com/elebow
-" Description: rails_best_practices, a code metric tool for rails projects
-
-call ale#Set('ruby_rails_best_practices_options', '')
-call ale#Set('ruby_rails_best_practices_executable', 'rails_best_practices')
-
-function! ale_linters#ruby#rails_best_practices#Handle(buffer, lines) abort
-    let l:output = []
-
-    for l:warning in ale#util#FuzzyJSONDecode(a:lines, [])
-        if !ale#path#IsBufferPath(a:buffer, l:warning.filename)
-            continue
-        endif
-
-        call add(l:output, {
-        \    'lnum': l:warning.line_number + 0,
-        \    'type': 'W',
-        \    'text': l:warning.message,
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-function! ale_linters#ruby#rails_best_practices#GetCommand(buffer) abort
-    let l:rails_root = ale#ruby#FindRailsRoot(a:buffer)
-
-    if l:rails_root is? ''
-        return ''
-    endif
-
-    let l:executable = ale#Var(a:buffer, 'ruby_rails_best_practices_executable')
-    let l:output_file = has('win32') ? '%t ' : '/dev/stdout '
-    let l:cat_file = has('win32') ? '; type %t' : ''
-
-    return ale#ruby#EscapeExecutable(l:executable, 'rails_best_practices')
-    \    . ' --silent -f json --output-file ' . l:output_file
-    \    . ale#Var(a:buffer, 'ruby_rails_best_practices_options')
-    \    . ale#Escape(l:rails_root)
-    \    . l:cat_file
-endfunction
-
-call ale#linter#Define('ruby', {
-\    'name': 'rails_best_practices',
-\    'executable': {b -> ale#Var(b, 'ruby_rails_best_practices_executable')},
-\    'command': function('ale_linters#ruby#rails_best_practices#GetCommand'),
-\    'callback': 'ale_linters#ruby#rails_best_practices#Handle',
-\    'lint_file': 1,
-\})
diff --git a/sources_non_forked/ale/ale_linters/ruby/reek.vim b/sources_non_forked/ale/ale_linters/ruby/reek.vim
deleted file mode 100644
index 226b452..0000000
--- a/sources_non_forked/ale/ale_linters/ruby/reek.vim
+++ /dev/null
@@ -1,65 +0,0 @@
-" Author: Eddie Lebow https://github.com/elebow
-" Description: Reek, a code smell detector for Ruby files
-
-call ale#Set('ruby_reek_show_context', 0)
-call ale#Set('ruby_reek_show_wiki_link', 0)
-call ale#Set('ruby_reek_options', '')
-call ale#Set('ruby_reek_executable', 'reek')
-
-function! ale_linters#ruby#reek#GetCommand(buffer, version) abort
-    let l:executable = ale#Var(a:buffer, 'ruby_reek_executable')
-
-    " Tell reek what the filename is if the version of reek is new enough.
-    let l:display_name_args = ale#semver#GTE(a:version, [5, 0, 0])
-    \   ? ' --stdin-filename %s'
-    \   : ''
-
-    return ale#ruby#EscapeExecutable(l:executable, 'reek')
-    \   . ' -f json --no-progress --no-color --force-exclusion'
-    \   . l:display_name_args
-endfunction
-
-function! s:BuildText(buffer, error) abort
-    let l:parts = []
-
-    if ale#Var(a:buffer, 'ruby_reek_show_context')
-        call add(l:parts, a:error.context)
-    endif
-
-    call add(l:parts, a:error.message)
-
-    if ale#Var(a:buffer, 'ruby_reek_show_wiki_link')
-        call add(l:parts, '[' . a:error.wiki_link . ']')
-    endif
-
-    return join(l:parts, ' ')
-endfunction
-
-function! ale_linters#ruby#reek#Handle(buffer, lines) abort
-    let l:output = []
-
-    for l:error in ale#util#FuzzyJSONDecode(a:lines, [])
-        for l:location in l:error.lines
-            call add(l:output, {
-            \    'lnum': l:location,
-            \    'type': 'W',
-            \    'text': s:BuildText(a:buffer, l:error),
-            \    'code': l:error.smell_type,
-            \})
-        endfor
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('ruby', {
-\   'name': 'reek',
-\   'executable': {b -> ale#Var(b, 'ruby_reek_executable')},
-\   'command': {buffer -> ale#semver#RunWithVersionCheck(
-\       buffer,
-\       ale#Var(buffer, 'ruby_reek_executable'),
-\       '%e --version',
-\       function('ale_linters#ruby#reek#GetCommand'),
-\   )},
-\    'callback': 'ale_linters#ruby#reek#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/ruby/rubocop.vim b/sources_non_forked/ale/ale_linters/ruby/rubocop.vim
deleted file mode 100644
index 410ed0e..0000000
--- a/sources_non_forked/ale/ale_linters/ruby/rubocop.vim
+++ /dev/null
@@ -1,31 +0,0 @@
-" Author: ynonp - https://github.com/ynonp, Eddie Lebow https://github.com/elebow
-" Description: RuboCop, a code style analyzer for Ruby files
-
-call ale#Set('ruby_rubocop_executable', 'rubocop')
-call ale#Set('ruby_rubocop_options', '')
-
-function! ale_linters#ruby#rubocop#GetCommand(buffer) abort
-    let l:executable = ale#Var(a:buffer, 'ruby_rubocop_executable')
-
-    return ale#ruby#EscapeExecutable(l:executable, 'rubocop')
-    \   . ' --format json --force-exclusion '
-    \   . ale#Var(a:buffer, 'ruby_rubocop_options')
-    \   . ' --stdin ' . ale#Escape(expand('#' . a:buffer . ':p'))
-endfunction
-
-function! ale_linters#ruby#rubocop#GetType(severity) abort
-    if a:severity is? 'convention'
-    \|| a:severity is? 'warning'
-    \|| a:severity is? 'refactor'
-        return 'W'
-    endif
-
-    return 'E'
-endfunction
-
-call ale#linter#Define('ruby', {
-\   'name': 'rubocop',
-\   'executable': {b -> ale#Var(b, 'ruby_rubocop_executable')},
-\   'command': function('ale_linters#ruby#rubocop#GetCommand'),
-\   'callback': 'ale#ruby#HandleRubocopOutput',
-\})
diff --git a/sources_non_forked/ale/ale_linters/ruby/ruby.vim b/sources_non_forked/ale/ale_linters/ruby/ruby.vim
deleted file mode 100644
index 2dc55eb..0000000
--- a/sources_non_forked/ale/ale_linters/ruby/ruby.vim
+++ /dev/null
@@ -1,12 +0,0 @@
-" Author: Brandon Roehl - https://github.com/BrandonRoehl
-" Description: Ruby MRI for Ruby files
-
-call ale#Set('ruby_ruby_executable', 'ruby')
-
-call ale#linter#Define('ruby', {
-\   'name': 'ruby',
-\   'executable': {b -> ale#Var(b, 'ruby_ruby_executable')},
-\   'command': '%e -w -c -T1 %t',
-\   'output_stream': 'stderr',
-\   'callback': 'ale#handlers#ruby#HandleSyntaxErrors',
-\})
diff --git a/sources_non_forked/ale/ale_linters/ruby/solargraph.vim b/sources_non_forked/ale/ale_linters/ruby/solargraph.vim
deleted file mode 100644
index bf54a55..0000000
--- a/sources_non_forked/ale/ale_linters/ruby/solargraph.vim
+++ /dev/null
@@ -1,22 +0,0 @@
-" Author: Horacio Sanson - https://github.com/hsanson
-" Description: Solargraph Language Server https://solargraph.org/
-"
-" Author: Devon Meunier <devon.meunier@gmail.com>
-" Description: updated to use stdio
-
-call ale#Set('ruby_solargraph_executable', 'solargraph')
-call ale#Set('ruby_solargraph_options', {})
-
-function! ale_linters#ruby#solargraph#GetCommand(buffer) abort
-    return '%e' . ale#Pad('stdio')
-endfunction
-
-call ale#linter#Define('ruby', {
-\   'name': 'solargraph',
-\   'lsp': 'stdio',
-\   'language': 'ruby',
-\   'executable': {b -> ale#Var(b, 'ruby_solargraph_executable')},
-\   'command': function('ale_linters#ruby#solargraph#GetCommand'),
-\   'project_root': function('ale#ruby#FindProjectRoot'),
-\   'initialization_options': {b -> ale#Var(b, 'ruby_solargraph_options')},
-\})
diff --git a/sources_non_forked/ale/ale_linters/ruby/sorbet.vim b/sources_non_forked/ale/ale_linters/ruby/sorbet.vim
deleted file mode 100644
index cae0683..0000000
--- a/sources_non_forked/ale/ale_linters/ruby/sorbet.vim
+++ /dev/null
@@ -1,23 +0,0 @@
-call ale#Set('ruby_sorbet_executable', 'srb')
-call ale#Set('ruby_sorbet_options', '')
-
-function! ale_linters#ruby#sorbet#GetCommand(buffer) abort
-    let l:executable = ale#Var(a:buffer, 'ruby_sorbet_executable')
-    let l:options = ale#Var(a:buffer, 'ruby_sorbet_options')
-
-    return ale#ruby#EscapeExecutable(l:executable, 'srb')
-    \   . ' tc'
-    \   . (!empty(l:options) ? ' ' . l:options : '')
-    \   . ' --lsp --disable-watchman'
-endfunction
-
-call ale#linter#Define('ruby', {
-\   'name': 'sorbet',
-\   'aliases': ['srb'],
-\   'lsp': 'stdio',
-\   'language': 'ruby',
-\   'executable': {b -> ale#Var(b, 'ruby_sorbet_executable')},
-\   'command': function('ale_linters#ruby#sorbet#GetCommand'),
-\   'project_root': function('ale#ruby#FindProjectRoot')
-\})
-
diff --git a/sources_non_forked/ale/ale_linters/ruby/standardrb.vim b/sources_non_forked/ale/ale_linters/ruby/standardrb.vim
deleted file mode 100644
index f751e80..0000000
--- a/sources_non_forked/ale/ale_linters/ruby/standardrb.vim
+++ /dev/null
@@ -1,23 +0,0 @@
-" Author: Justin Searls https://github.com/searls, ynonp - https://github.com/ynonp, Eddie Lebow https://github.com/elebow
-" based on the ale rubocop linter
-" Description: StandardRB - Ruby Style Guide, with linter & automatic code fixer
-
-call ale#Set('ruby_standardrb_executable', 'standardrb')
-call ale#Set('ruby_standardrb_options', '')
-
-function! ale_linters#ruby#standardrb#GetCommand(buffer) abort
-    let l:executable = ale#Var(a:buffer, 'ruby_standardrb_executable')
-
-    return ale#ruby#EscapeExecutable(l:executable, 'standardrb')
-    \   . ' --format json --force-exclusion '
-    \   . ale#Var(a:buffer, 'ruby_standardrb_options')
-    \   . ' --stdin ' . ale#Escape(expand('#' . a:buffer . ':p'))
-endfunction
-
-" standardrb is based on RuboCop so the callback is the same
-call ale#linter#Define('ruby', {
-\   'name': 'standardrb',
-\   'executable': {b -> ale#Var(b, 'ruby_standardrb_executable')},
-\   'command': function('ale_linters#ruby#standardrb#GetCommand'),
-\   'callback': 'ale#ruby#HandleRubocopOutput',
-\})
diff --git a/sources_non_forked/ale/ale_linters/rust/analyzer.vim b/sources_non_forked/ale/ale_linters/rust/analyzer.vim
deleted file mode 100644
index 3666ec0..0000000
--- a/sources_non_forked/ale/ale_linters/rust/analyzer.vim
+++ /dev/null
@@ -1,24 +0,0 @@
-" Author: Jon Gjengset <jon@thesquareplanet.com>
-" Description: The next generation language server for Rust
-
-call ale#Set('rust_analyzer_executable', 'rust-analyzer')
-call ale#Set('rust_analyzer_config', {})
-
-function! ale_linters#rust#analyzer#GetCommand(buffer) abort
-    return '%e'
-endfunction
-
-function! ale_linters#rust#analyzer#GetProjectRoot(buffer) abort
-    let l:cargo_file = ale#path#FindNearestFile(a:buffer, 'Cargo.toml')
-
-    return !empty(l:cargo_file) ? fnamemodify(l:cargo_file, ':h') : ''
-endfunction
-
-call ale#linter#Define('rust', {
-\   'name': 'analyzer',
-\   'lsp': 'stdio',
-\   'lsp_config': {b -> ale#Var(b, 'rust_analyzer_config')},
-\   'executable': {b -> ale#Var(b, 'rust_analyzer_executable')},
-\   'command': function('ale_linters#rust#analyzer#GetCommand'),
-\   'project_root': function('ale_linters#rust#analyzer#GetProjectRoot'),
-\})
diff --git a/sources_non_forked/ale/ale_linters/rust/cargo.vim b/sources_non_forked/ale/ale_linters/rust/cargo.vim
deleted file mode 100644
index 9917858..0000000
--- a/sources_non_forked/ale/ale_linters/rust/cargo.vim
+++ /dev/null
@@ -1,103 +0,0 @@
-" Author: Daniel Schemala <istjanichtzufassen@gmail.com>,
-" Ivan Petkov <ivanppetkov@gmail.com>
-" Description: rustc invoked by cargo for rust files
-
-call ale#Set('rust_cargo_use_check', 1)
-call ale#Set('rust_cargo_check_all_targets', 0)
-call ale#Set('rust_cargo_check_examples', 0)
-call ale#Set('rust_cargo_check_tests', 0)
-call ale#Set('rust_cargo_avoid_whole_workspace', 1)
-call ale#Set('rust_cargo_default_feature_behavior', 'default')
-call ale#Set('rust_cargo_include_features', '')
-call ale#Set('rust_cargo_use_clippy', 0)
-call ale#Set('rust_cargo_clippy_options', '')
-
-function! ale_linters#rust#cargo#GetCargoExecutable(bufnr) abort
-    if ale#path#FindNearestFile(a:bufnr, 'Cargo.toml') isnot# ''
-        return 'cargo'
-    else
-        " if there is no Cargo.toml file, we don't use cargo even if it exists,
-        " so we return '', because executable('') apparently always fails
-        return ''
-    endif
-endfunction
-
-function! ale_linters#rust#cargo#GetCommand(buffer, version) abort
-    let l:use_check = ale#Var(a:buffer, 'rust_cargo_use_check')
-    \   && ale#semver#GTE(a:version, [0, 17, 0])
-    let l:use_all_targets = ale#Var(a:buffer, 'rust_cargo_check_all_targets')
-    \   && ale#semver#GTE(a:version, [0, 22, 0])
-    let l:use_examples = ale#Var(a:buffer, 'rust_cargo_check_examples')
-    \   && ale#semver#GTE(a:version, [0, 22, 0])
-    let l:use_tests = ale#Var(a:buffer, 'rust_cargo_check_tests')
-    \   && ale#semver#GTE(a:version, [0, 22, 0])
-
-    let l:include_features = ale#Var(a:buffer, 'rust_cargo_include_features')
-
-    if !empty(l:include_features)
-        let l:include_features = ' --features ' . ale#Escape(l:include_features)
-    endif
-
-    let l:avoid_whole_workspace = ale#Var(a:buffer, 'rust_cargo_avoid_whole_workspace')
-    let l:nearest_cargo_prefix = ''
-
-    if l:avoid_whole_workspace
-        let l:nearest_cargo = ale#path#FindNearestFile(a:buffer, 'Cargo.toml')
-        let l:nearest_cargo_dir = fnamemodify(l:nearest_cargo, ':h')
-
-        if l:nearest_cargo_dir isnot# '.'
-            let l:nearest_cargo_prefix = 'cd '. ale#Escape(l:nearest_cargo_dir) .' && '
-        endif
-    endif
-
-    let l:default_feature_behavior = ale#Var(a:buffer, 'rust_cargo_default_feature_behavior')
-
-    if l:default_feature_behavior is# 'all'
-        let l:include_features = ''
-        let l:default_feature = ' --all-features'
-    elseif l:default_feature_behavior is# 'none'
-        let l:default_feature = ' --no-default-features'
-    else
-        let l:default_feature = ''
-    endif
-
-    let l:subcommand = l:use_check ? 'check' : 'build'
-    let l:clippy_options = ''
-
-    if ale#Var(a:buffer, 'rust_cargo_use_clippy')
-        let l:subcommand = 'clippy'
-        let l:clippy_options = ale#Var(a:buffer, 'rust_cargo_clippy_options')
-
-        if l:clippy_options =~# '^-- '
-            let l:clippy_options = join(split(l:clippy_options, '-- '))
-        endif
-
-        if l:clippy_options isnot# ''
-            let l:clippy_options = ' -- ' . l:clippy_options
-        endif
-    endif
-
-    return l:nearest_cargo_prefix . 'cargo '
-    \   . l:subcommand
-    \   . (l:use_all_targets ? ' --all-targets' : '')
-    \   . (l:use_examples ? ' --examples' : '')
-    \   . (l:use_tests ? ' --tests' : '')
-    \   . ' --frozen --message-format=json -q'
-    \   . l:default_feature
-    \   . l:include_features
-    \   . l:clippy_options
-endfunction
-
-call ale#linter#Define('rust', {
-\   'name': 'cargo',
-\   'executable': function('ale_linters#rust#cargo#GetCargoExecutable'),
-\   'command': {buffer -> ale#semver#RunWithVersionCheck(
-\       buffer,
-\       ale_linters#rust#cargo#GetCargoExecutable(buffer),
-\       '%e --version',
-\       function('ale_linters#rust#cargo#GetCommand'),
-\   )},
-\   'callback': 'ale#handlers#rust#HandleRustErrors',
-\   'output_stream': 'both',
-\   'lint_file': 1,
-\})
diff --git a/sources_non_forked/ale/ale_linters/rust/rls.vim b/sources_non_forked/ale/ale_linters/rust/rls.vim
deleted file mode 100644
index 111d755..0000000
--- a/sources_non_forked/ale/ale_linters/rust/rls.vim
+++ /dev/null
@@ -1,27 +0,0 @@
-" Author: w0rp <devw0rp@gmail.com>
-" Description: A language server for Rust
-
-call ale#Set('rust_rls_executable', 'rls')
-call ale#Set('rust_rls_toolchain', '')
-call ale#Set('rust_rls_config', {})
-
-function! ale_linters#rust#rls#GetCommand(buffer) abort
-    let l:toolchain = ale#Var(a:buffer, 'rust_rls_toolchain')
-
-    return '%e' . (!empty(l:toolchain) ? ' +' . ale#Escape(l:toolchain) : '')
-endfunction
-
-function! ale_linters#rust#rls#GetProjectRoot(buffer) abort
-    let l:cargo_file = ale#path#FindNearestFile(a:buffer, 'Cargo.toml')
-
-    return !empty(l:cargo_file) ? fnamemodify(l:cargo_file, ':h') : ''
-endfunction
-
-call ale#linter#Define('rust', {
-\   'name': 'rls',
-\   'lsp': 'stdio',
-\   'lsp_config': {b -> ale#Var(b, 'rust_rls_config')},
-\   'executable': {b -> ale#Var(b, 'rust_rls_executable')},
-\   'command': function('ale_linters#rust#rls#GetCommand'),
-\   'project_root': function('ale_linters#rust#rls#GetProjectRoot'),
-\})
diff --git a/sources_non_forked/ale/ale_linters/rust/rustc.vim b/sources_non_forked/ale/ale_linters/rust/rustc.vim
deleted file mode 100644
index f140b58..0000000
--- a/sources_non_forked/ale/ale_linters/rust/rustc.vim
+++ /dev/null
@@ -1,33 +0,0 @@
-" Author: Daniel Schemala <istjanichtzufassen@gmail.com>
-" Description: rustc for rust files
-
-call ale#Set('rust_rustc_options', '-Z no-codegen')
-
-function! ale_linters#rust#rustc#RustcCommand(buffer) abort
-    " Try to guess the library search path. If the project is managed by cargo,
-    " it's usually <project root>/target/debug/deps/ or
-    " <project root>/target/release/deps/
-    let l:cargo_file = ale#path#FindNearestFile(a:buffer, 'Cargo.toml')
-
-    if l:cargo_file isnot# ''
-        let l:root = fnamemodify(l:cargo_file, ':h')
-        let l:dependencies = ' -L ' . ale#Escape(ale#path#GetAbsPath(l:root, 'target/debug/deps'))
-        \   . ' -L ' . ale#Escape(ale#path#GetAbsPath(l:root, 'target/release/deps'))
-    else
-        let l:dependencies = ''
-    endif
-
-    let l:options = ale#Var(a:buffer, 'rust_rustc_options')
-
-    return 'rustc --error-format=json'
-    \   . (!empty(l:options) ? ' ' . l:options : '')
-    \   . l:dependencies . ' -'
-endfunction
-
-call ale#linter#Define('rust', {
-\   'name': 'rustc',
-\   'executable': 'rustc',
-\   'command': function('ale_linters#rust#rustc#RustcCommand'),
-\   'callback': 'ale#handlers#rust#HandleRustErrors',
-\   'output_stream': 'stderr',
-\})
diff --git a/sources_non_forked/ale/ale_linters/sass/sasslint.vim b/sources_non_forked/ale/ale_linters/sass/sasslint.vim
deleted file mode 100644
index 17cd366..0000000
--- a/sources_non_forked/ale/ale_linters/sass/sasslint.vim
+++ /dev/null
@@ -1,28 +0,0 @@
-" Author: sQVe - https://github.com/sQVe
-
-call ale#Set('sass_sasslint_executable', 'sass-lint')
-call ale#Set('sass_sasslint_options', '')
-call ale#Set('sass_sasslint_use_global', get(g:, 'ale_use_global_executables', 0))
-
-function! ale_linters#sass#sasslint#GetExecutable(buffer) abort
-    return ale#node#FindExecutable(a:buffer, 'sass_sasslint', [
-    \   'node_modules/sass-lint/bin/sass-lint.js',
-    \   'node_modules/.bin/sass-lint',
-    \])
-endfunction
-
-function! ale_linters#sass#sasslint#GetCommand(buffer) abort
-    let l:executable = ale_linters#sass#sasslint#GetExecutable(a:buffer)
-    let l:options = ale#Var(a:buffer, 'sass_sasslint_options')
-
-    return ale#node#Executable(a:buffer, l:executable)
-    \   . (!empty(l:options) ? ' ' . l:options : '')
-    \   . ' -v -q -f compact %t'
-endfunction
-
-call ale#linter#Define('sass', {
-\   'name': 'sasslint',
-\   'executable': function('ale_linters#sass#sasslint#GetExecutable'),
-\   'command': function('ale_linters#sass#sasslint#GetCommand'),
-\   'callback': 'ale#handlers#css#HandleCSSLintFormat',
-\})
diff --git a/sources_non_forked/ale/ale_linters/sass/stylelint.vim b/sources_non_forked/ale/ale_linters/sass/stylelint.vim
deleted file mode 100644
index 7b14c6b..0000000
--- a/sources_non_forked/ale/ale_linters/sass/stylelint.vim
+++ /dev/null
@@ -1,13 +0,0 @@
-" Author: diartyz <diartyz@gmail.com>
-
-call ale#Set('sass_stylelint_executable', 'stylelint')
-call ale#Set('sass_stylelint_use_global', get(g:, 'ale_use_global_executables', 0))
-
-call ale#linter#Define('sass', {
-\   'name': 'stylelint',
-\   'executable': {b -> ale#node#FindExecutable(b, 'sass_stylelint', [
-\       'node_modules/.bin/stylelint',
-\   ])},
-\   'command': '%e --stdin-filename %s',
-\   'callback': 'ale#handlers#css#HandleStyleLintFormat',
-\})
diff --git a/sources_non_forked/ale/ale_linters/scala/fsc.vim b/sources_non_forked/ale/ale_linters/scala/fsc.vim
deleted file mode 100644
index 9413523..0000000
--- a/sources_non_forked/ale/ale_linters/scala/fsc.vim
+++ /dev/null
@@ -1,14 +0,0 @@
-" Author: Nils Leuzinger - https://github.com/PawkyPenguin
-" Description: Basic scala support using fsc
-
-function! s:IsSbt(buffer) abort
-    return index(split(getbufvar(a:buffer, '&filetype'), '\.'), 'sbt') >= 0
-endfunction
-
-call ale#linter#Define('scala', {
-\   'name': 'fsc',
-\   'executable': {buf -> s:IsSbt(buf) ? '' : 'fsc'},
-\   'command': '%e -Ystop-after:parser %t',
-\   'callback': 'ale#handlers#scala#HandleScalacLintFormat',
-\   'output_stream': 'stderr',
-\})
diff --git a/sources_non_forked/ale/ale_linters/scala/metals.vim b/sources_non_forked/ale/ale_linters/scala/metals.vim
deleted file mode 100644
index da9e855..0000000
--- a/sources_non_forked/ale/ale_linters/scala/metals.vim
+++ /dev/null
@@ -1,50 +0,0 @@
-" Author: Jeffrey Lau - https://github.com/zoonfafer
-" Description: Metals Language Server for Scala https://scalameta.org/metals/
-
-call ale#Set('scala_metals_executable', 'metals-vim')
-call ale#Set('scala_metals_project_root', '')
-
-function! ale_linters#scala#metals#GetProjectRoot(buffer) abort
-    let l:project_root = ale#Var(a:buffer, 'scala_metals_project_root')
-
-    if !empty(l:project_root)
-        return l:project_root
-    endif
-
-    let l:potential_roots = [
-    \   'build.sc',
-    \   'build.sbt',
-    \   '.bloop',
-    \   '.metals',
-    \]
-
-    for l:root in l:potential_roots
-        let l:project_root = ale#path#ResolveLocalPath(
-        \   a:buffer,
-        \   l:root,
-        \   ''
-        \)
-
-        if !empty(l:project_root)
-            return fnamemodify(
-            \   l:project_root,
-            \   ':h',
-            \)
-        endif
-    endfor
-
-    return ''
-endfunction
-
-function! ale_linters#scala#metals#GetCommand(buffer) abort
-    return '%e' . ale#Pad('stdio')
-endfunction
-
-call ale#linter#Define('scala', {
-\   'name': 'metals',
-\   'lsp': 'stdio',
-\   'language': 'scala',
-\   'executable': {b -> ale#Var(b, 'scala_metals_executable')},
-\   'command': function('ale_linters#scala#metals#GetCommand'),
-\   'project_root': function('ale_linters#scala#metals#GetProjectRoot'),
-\})
diff --git a/sources_non_forked/ale/ale_linters/scala/sbtserver.vim b/sources_non_forked/ale/ale_linters/scala/sbtserver.vim
deleted file mode 100644
index d4f137c..0000000
--- a/sources_non_forked/ale/ale_linters/scala/sbtserver.vim
+++ /dev/null
@@ -1,31 +0,0 @@
-" Author: ophirr33 <coghlan.ty@gmail.com>
-" Description: TCP lsp client for sbt Server
-
-call ale#Set('scala_sbtserver_address', '127.0.0.1:4273')
-call ale#Set('scala_sbtserver_project_root', '')
-
-function! ale_linters#scala#sbtserver#GetProjectRoot(buffer) abort
-    let l:project_root = ale#Var(a:buffer, 'scala_sbtserver_project_root')
-
-    if l:project_root is? ''
-        let l:project_root = ale#path#FindNearestFile(a:buffer, 'build.sbt')
-
-        return !empty(l:project_root) ? fnamemodify(l:project_root, ':h') : ''
-    endif
-
-    return l:project_root
-endfunction
-
-function! ale_linters#scala#sbtserver#GetAddress(buffer) abort
-    let l:address = ale#Var(a:buffer, 'scala_sbtserver_address')
-
-    return l:address
-endfunction
-
-call ale#linter#Define('scala', {
-\   'name': 'sbtserver',
-\   'lsp': 'socket',
-\   'address': function('ale_linters#scala#sbtserver#GetAddress'),
-\   'language': 'scala',
-\   'project_root': function('ale_linters#scala#sbtserver#GetProjectRoot'),
-\})
diff --git a/sources_non_forked/ale/ale_linters/scala/scalac.vim b/sources_non_forked/ale/ale_linters/scala/scalac.vim
deleted file mode 100644
index 1dd579b..0000000
--- a/sources_non_forked/ale/ale_linters/scala/scalac.vim
+++ /dev/null
@@ -1,15 +0,0 @@
-" Author: Zoltan Kalmar - https://github.com/kalmiz,
-"         w0rp <devw0rp@gmail.com>
-" Description: Basic scala support using scalac
-
-function! s:IsSbt(buffer) abort
-    return index(split(getbufvar(a:buffer, '&filetype'), '\.'), 'sbt') >= 0
-endfunction
-
-call ale#linter#Define('scala', {
-\   'name': 'scalac',
-\   'executable': {buf -> s:IsSbt(buf) ? '' : 'scalac'},
-\   'command': '%e -Ystop-after:parser %t',
-\   'callback': 'ale#handlers#scala#HandleScalacLintFormat',
-\   'output_stream': 'stderr',
-\})
diff --git a/sources_non_forked/ale/ale_linters/scala/scalastyle.vim b/sources_non_forked/ale/ale_linters/scala/scalastyle.vim
deleted file mode 100644
index 6e9e4c1..0000000
--- a/sources_non_forked/ale/ale_linters/scala/scalastyle.vim
+++ /dev/null
@@ -1,86 +0,0 @@
-" Author: Kevin Kays - https://github.com/okkays
-" Description: Support for the scalastyle checker.
-
-call ale#Set('scala_scalastyle_options', '')
-" TODO: Remove support for the old option name in ALE 3.0.
-call ale#Set('scala_scalastyle_config',
-\   get(g:, 'ale_scalastyle_config_loc', '')
-\)
-
-function! ale_linters#scala#scalastyle#Handle(buffer, lines) abort
-    " Look for help output from scalastyle first, which indicates that no
-    " configuration file was found.
-    for l:line in a:lines[:10]
-        if l:line =~# '-c, --config'
-            return [{
-            \   'lnum': 1,
-            \   'text': '(See :help ale-scala-scalastyle)'
-            \       . ' No scalastyle configuration file was found.',
-            \}]
-        endif
-    endfor
-
-    " Matches patterns like the following:
-    "
-    " warning file=/home/blurble/Doop.scala message=Missing or badly formed ScalaDoc: Extra @param foobles line=190
-    let l:patterns = [
-    \   '^\(.\+\) .\+ message=\(.\+\) line=\(\d\+\)$',
-    \   '^\(.\+\) .\+ message=\(.\+\) line=\(\d\+\) column=\(\d\+\)$',
-    \]
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:patterns)
-        let l:args = {
-        \   'lnum': l:match[3] + 0,
-        \   'type': l:match[1] =~? 'error' ? 'E' : 'W',
-        \   'text': l:match[2]
-        \}
-
-        if !empty(l:match[4])
-            let l:args['col'] = l:match[4] + 1
-        endif
-
-        call add(l:output, l:args)
-    endfor
-
-    return l:output
-endfunction
-
-function! ale_linters#scala#scalastyle#GetCommand(buffer) abort
-    " Search for scalastyle config in parent directories.
-    let l:scalastyle_config = ''
-    let l:potential_configs = [
-    \   'scalastyle_config.xml',
-    \   'scalastyle-config.xml'
-    \]
-
-    for l:config in l:potential_configs
-        let l:scalastyle_config = ale#path#ResolveLocalPath(
-        \   a:buffer,
-        \   l:config,
-        \   ''
-        \)
-
-        if !empty(l:scalastyle_config)
-            break
-        endif
-    endfor
-
-    " If all else fails, try the global config.
-    if empty(l:scalastyle_config)
-        let l:scalastyle_config = ale#Var(a:buffer, 'scala_scalastyle_config')
-    endif
-
-    return 'scalastyle'
-    \ . (!empty(l:scalastyle_config) ? ' --config ' . ale#Escape(l:scalastyle_config) : '')
-    \ . ale#Pad(ale#Var(a:buffer, 'scala_scalastyle_options'))
-    \ . ' %t'
-endfunction
-
-call ale#linter#Define('scala', {
-\   'name': 'scalastyle',
-\   'executable': 'scalastyle',
-\   'output_stream': 'stdout',
-\   'command': function('ale_linters#scala#scalastyle#GetCommand'),
-\   'callback': 'ale_linters#scala#scalastyle#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/scss/sasslint.vim b/sources_non_forked/ale/ale_linters/scss/sasslint.vim
deleted file mode 100644
index cf13546..0000000
--- a/sources_non_forked/ale/ale_linters/scss/sasslint.vim
+++ /dev/null
@@ -1,28 +0,0 @@
-" Author: sQVe - https://github.com/sQVe
-
-call ale#Set('scss_sasslint_executable', 'sass-lint')
-call ale#Set('scss_sasslint_options', '')
-call ale#Set('scss_sasslint_use_global', get(g:, 'ale_use_global_executables', 0))
-
-function! ale_linters#scss#sasslint#GetExecutable(buffer) abort
-    return ale#node#FindExecutable(a:buffer, 'scss_sasslint', [
-    \   'node_modules/sass-lint/bin/sass-lint.js',
-    \   'node_modules/.bin/sass-lint',
-    \])
-endfunction
-
-function! ale_linters#scss#sasslint#GetCommand(buffer) abort
-    let l:executable = ale_linters#scss#sasslint#GetExecutable(a:buffer)
-    let l:options = ale#Var(a:buffer, 'scss_sasslint_options')
-
-    return ale#node#Executable(a:buffer, l:executable)
-    \   . (!empty(l:options) ? ' ' . l:options : '')
-    \   . ' -v -q -f compact %t'
-endfunction
-
-call ale#linter#Define('scss', {
-\   'name': 'sasslint',
-\   'executable': function('ale_linters#scss#sasslint#GetExecutable'),
-\   'command': function('ale_linters#scss#sasslint#GetCommand'),
-\   'callback': 'ale#handlers#css#HandleCSSLintFormat',
-\})
diff --git a/sources_non_forked/ale/ale_linters/scss/scsslint.vim b/sources_non_forked/ale/ale_linters/scss/scsslint.vim
deleted file mode 100644
index 7ce5724..0000000
--- a/sources_non_forked/ale/ale_linters/scss/scsslint.vim
+++ /dev/null
@@ -1,34 +0,0 @@
-" Author: w0rp <devw0rp@gmail.com>
-" Description: This file add scsslint support for SCSS support
-
-function! ale_linters#scss#scsslint#Handle(buffer, lines) abort
-    " Matches patterns like the following:
-    "
-    " test.scss:2:1 [W] Indentation: Line should be indented 2 spaces, but was indented 4 spaces
-    let l:pattern = '^.*:\(\d\+\):\(\d*\) \[\([^\]]\+\)\] \(.\+\)$'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        if !ale#Var(a:buffer, 'warn_about_trailing_whitespace')
-        \&& l:match[4] =~# '^TrailingWhitespace'
-            " Skip trailing whitespace warnings if that option is off.
-            continue
-        endif
-
-        call add(l:output, {
-        \   'lnum': l:match[1] + 0,
-        \   'col': l:match[2] + 0,
-        \   'text': l:match[4],
-        \   'type': l:match[3] is# 'E' ? 'E' : 'W',
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('scss', {
-\   'name': 'scsslint',
-\   'executable': 'scss-lint',
-\   'command': 'scss-lint --stdin-file-path=%s',
-\   'callback': 'ale_linters#scss#scsslint#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/scss/stylelint.vim b/sources_non_forked/ale/ale_linters/scss/stylelint.vim
deleted file mode 100644
index b5b2153..0000000
--- a/sources_non_forked/ale/ale_linters/scss/stylelint.vim
+++ /dev/null
@@ -1,19 +0,0 @@
-" Author: diartyz <diartyz@gmail.com>
-
-call ale#Set('scss_stylelint_executable', 'stylelint')
-call ale#Set('scss_stylelint_options', '')
-call ale#Set('scss_stylelint_use_global', get(g:, 'ale_use_global_executables', 0))
-
-function! ale_linters#scss#stylelint#GetCommand(buffer) abort
-    return '%e ' . ale#Pad(ale#Var(a:buffer, 'scss_stylelint_options'))
-    \   . ' --stdin-filename %s'
-endfunction
-
-call ale#linter#Define('scss', {
-\   'name': 'stylelint',
-\   'executable': {b -> ale#node#FindExecutable(b, 'scss_stylelint', [
-\       'node_modules/.bin/stylelint',
-\   ])},
-\   'command': function('ale_linters#scss#stylelint#GetCommand'),
-\   'callback': 'ale#handlers#css#HandleStyleLintFormat',
-\})
diff --git a/sources_non_forked/ale/ale_linters/sh/language_server.vim b/sources_non_forked/ale/ale_linters/sh/language_server.vim
deleted file mode 100644
index 5a3b0e9..0000000
--- a/sources_non_forked/ale/ale_linters/sh/language_server.vim
+++ /dev/null
@@ -1,32 +0,0 @@
-" Author: Christian Hltje (https://docwhat.org/)
-" Description: BASH Language server integration for ALE
-scriptencoding utf-8
-
-call ale#Set('sh_language_server_executable', 'bash-language-server')
-call ale#Set('sh_language_server_use_global', get(g:, 'ale_use_global_executables', 0))
-
-function! ale_linters#sh#language_server#GetExecutable(buffer) abort
-    return ale#node#FindExecutable(a:buffer, 'sh_language_server', [
-    \   'node_modules/.bin/bash-language-server',
-    \])
-endfunction
-
-function! ale_linters#sh#language_server#GetCommand(buffer) abort
-    let l:exe = ale#Escape(ale_linters#sh#language_server#GetExecutable(a:buffer))
-
-    return l:exe . ' start'
-endfunction
-
-function! ale_linters#sh#language_server#GetProjectRoot(buffer) abort
-    let l:git_path = ale#path#FindNearestDirectory(a:buffer, '.git')
-
-    return !empty(l:git_path) ? fnamemodify(l:git_path, ':h:h') : ''
-endfunction
-
-call ale#linter#Define('sh', {
-\   'name': 'language_server',
-\   'lsp': 'stdio',
-\   'executable': function('ale_linters#sh#language_server#GetExecutable'),
-\   'command': function('ale_linters#sh#language_server#GetCommand'),
-\   'project_root': function('ale_linters#sh#language_server#GetProjectRoot'),
-\})
diff --git a/sources_non_forked/ale/ale_linters/sh/shell.vim b/sources_non_forked/ale/ale_linters/sh/shell.vim
deleted file mode 100644
index 171fe64..0000000
--- a/sources_non_forked/ale/ale_linters/sh/shell.vim
+++ /dev/null
@@ -1,59 +0,0 @@
-" Author: w0rp <devw0rp@gmail.com>
-" Description: Lints sh files using bash -n
-
-" Backwards compatibility
-if exists('g:ale_linters_sh_shell_default_shell')
-    let g:ale_sh_shell_default_shell = g:ale_linters_sh_shell_default_shell
-endif
-
-" This option can be changed to change the default shell when the shell
-" cannot be taken from the hashbang line.
-if !exists('g:ale_sh_shell_default_shell')
-    let g:ale_sh_shell_default_shell = fnamemodify($SHELL, ':t')
-
-    if g:ale_sh_shell_default_shell is# '' || g:ale_sh_shell_default_shell is# 'fish'
-        let g:ale_sh_shell_default_shell = 'bash'
-    endif
-endif
-
-function! ale_linters#sh#shell#GetExecutable(buffer) abort
-    let l:shell_type = ale#handlers#sh#GetShellType(a:buffer)
-
-    if !empty(l:shell_type)
-        return l:shell_type
-    endif
-
-    return ale#Var(a:buffer, 'sh_shell_default_shell')
-endfunction
-
-function! ale_linters#sh#shell#GetCommand(buffer) abort
-    return ale_linters#sh#shell#GetExecutable(a:buffer) . ' -n %t'
-endfunction
-
-function! ale_linters#sh#shell#Handle(buffer, lines) abort
-    " Matches patterns line the following:
-    "
-    " bash: line 13: syntax error near unexpected token `d'
-    " bash:0: done
-    " bash:  90: "
-    " sh: 11: Syntax error: "(" unexpected
-    let l:pattern = '\v([^:]+:\D*)(\d+): (.+)$'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        call add(l:output, {
-        \   'lnum': str2nr(l:match[2]),
-        \   'text': l:match[3],
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('sh', {
-\   'name': 'shell',
-\   'output_stream': 'stderr',
-\   'executable': function('ale_linters#sh#shell#GetExecutable'),
-\   'command': function('ale_linters#sh#shell#GetCommand'),
-\   'callback': 'ale_linters#sh#shell#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/sh/shellcheck.vim b/sources_non_forked/ale/ale_linters/sh/shellcheck.vim
deleted file mode 100644
index d994512..0000000
--- a/sources_non_forked/ale/ale_linters/sh/shellcheck.vim
+++ /dev/null
@@ -1,4 +0,0 @@
-" Author: w0rp <devw0rp@gmail.com>
-" Description: shellcheck linter for shell scripts.
-
-call ale#handlers#shellcheck#DefineLinter('sh')
diff --git a/sources_non_forked/ale/ale_linters/slim/slimlint.vim b/sources_non_forked/ale/ale_linters/slim/slimlint.vim
deleted file mode 100644
index 1b365e2..0000000
--- a/sources_non_forked/ale/ale_linters/slim/slimlint.vim
+++ /dev/null
@@ -1,55 +0,0 @@
-" Author: Markus Doits - https://github.com/doits
-" Description: slim-lint for Slim files
-
-function! ale_linters#slim#slimlint#GetCommand(buffer) abort
-    let l:command = 'slim-lint %t'
-
-    let l:rubocop_config = ale#path#FindNearestFile(a:buffer, '.rubocop.yml')
-
-    " Set SLIM_LINT_RUBOCOP_CONF variable as it is needed for slim-lint to
-    " pick up the rubocop config.
-    "
-    " See https://github.com/sds/slim-lint/blob/master/lib/slim_lint/linter/README.md#rubocop
-    if !empty(l:rubocop_config)
-        if has('win32')
-            let l:command = 'set SLIM_LINT_RUBOCOP_CONF=' . ale#Escape(l:rubocop_config) . ' && ' . l:command
-        else
-            let l:command = 'SLIM_LINT_RUBOCOP_CONF=' . ale#Escape(l:rubocop_config) . ' ' . l:command
-        endif
-    endif
-
-    return l:command
-endfunction
-
-function! ale_linters#slim#slimlint#Handle(buffer, lines) abort
-    " Matches patterns like the following:
-    " <path>:5 [W] LineLength: Line is too long. [150/120]
-    let l:pattern = '\v^.*:(\d+) \[([EW])\] (.+)$'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        let l:item = {
-        \   'lnum': l:match[1] + 0,
-        \   'type': l:match[2],
-        \   'text': l:match[3]
-        \}
-
-        let l:code_match = matchlist(l:item.text, '\v^([^:]+): (.+)$')
-
-        if !empty(l:code_match)
-            let l:item.code = l:code_match[1]
-            let l:item.text = l:code_match[2]
-        endif
-
-        call add(l:output, l:item)
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('slim', {
-\   'name': 'slimlint',
-\   'executable': 'slim-lint',
-\   'command': function('ale_linters#slim#slimlint#GetCommand'),
-\   'callback': 'ale_linters#slim#slimlint#Handle'
-\})
diff --git a/sources_non_forked/ale/ale_linters/sml/smlnj.vim b/sources_non_forked/ale/ale_linters/sml/smlnj.vim
deleted file mode 100644
index 852ea17..0000000
--- a/sources_non_forked/ale/ale_linters/sml/smlnj.vim
+++ /dev/null
@@ -1,9 +0,0 @@
-" Author: Paulo Alem <paulo.alem@gmail.com>, Jake Zimmerman <jake@zimmerman.io>
-" Description: Single-file SML checking with SML/NJ compiler
-
-call ale#linter#Define('sml', {
-\   'name': 'smlnj',
-\   'executable': function('ale#handlers#sml#GetExecutableSmlnjFile'),
-\   'command': 'sml',
-\   'callback': 'ale#handlers#sml#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/sml/smlnj_cm.vim b/sources_non_forked/ale/ale_linters/sml/smlnj_cm.vim
deleted file mode 100644
index 9ad24af..0000000
--- a/sources_non_forked/ale/ale_linters/sml/smlnj_cm.vim
+++ /dev/null
@@ -1,21 +0,0 @@
-" Author: Jake Zimmerman <jake@zimmerman.io>
-" Description: SML checking with SML/NJ Compilation Manager
-
-function! ale_linters#sml#smlnj_cm#GetCommand(buffer) abort
-    let l:cmfile = ale#handlers#sml#GetCmFile(a:buffer)
-
-    return 'sml -m ' . l:cmfile . ' < /dev/null'
-endfunction
-
-" Using CM requires that we set "lint_file: 1", since it reads the files
-" from the disk itself.
-call ale#linter#Define('sml', {
-\   'name': 'smlnj_cm',
-\   'aliases': ['smlnj-cm'],
-\   'executable': function('ale#handlers#sml#GetExecutableSmlnjCm'),
-\   'lint_file': 1,
-\   'command': function('ale_linters#sml#smlnj_cm#GetCommand'),
-\   'callback': 'ale#handlers#sml#Handle',
-\})
-
-" vim:ts=4:sts=4:sw=4
diff --git a/sources_non_forked/ale/ale_linters/solidity/solc.vim b/sources_non_forked/ale/ale_linters/solidity/solc.vim
deleted file mode 100644
index e4f220a..0000000
--- a/sources_non_forked/ale/ale_linters/solidity/solc.vim
+++ /dev/null
@@ -1,35 +0,0 @@
-" Author: Karl Bartel <karl42@gmail.com> - http://karl.berlin/
-" Description: Report solc compiler errors in Solidity code
-
-call ale#Set('solidity_solc_options', '')
-
-function! ale_linters#solidity#solc#Handle(buffer, lines) abort
-    " Matches patterns like the following:
-    " /path/to/file/file.sol:1:10: Error: Identifier not found or not unique.
-    let l:pattern = '\v^[^:]+:(\d+):(\d+): (Error|Warning): (.*)$'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        let l:isError = l:match[3] is? 'error'
-        call add(l:output, {
-        \   'lnum': l:match[1] + 0,
-        \   'col': l:match[2] + 0,
-        \   'text': l:match[4],
-        \   'type': l:isError ? 'E' : 'W',
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-function! ale_linters#solidity#solc#GetCommand(buffer) abort
-    return 'solc' . ale#Pad(ale#Var(a:buffer, 'solidity_solc_options')) . ' %s'
-endfunction
-
-call ale#linter#Define('solidity', {
-\   'name': 'solc',
-\   'executable': 'solc',
-\   'command': function('ale_linters#solidity#solc#GetCommand'),
-\   'callback': 'ale_linters#solidity#solc#Handle',
-\   'output_stream': 'stderr',
-\})
diff --git a/sources_non_forked/ale/ale_linters/solidity/solhint.vim b/sources_non_forked/ale/ale_linters/solidity/solhint.vim
deleted file mode 100644
index 8ea33e0..0000000
--- a/sources_non_forked/ale/ale_linters/solidity/solhint.vim
+++ /dev/null
@@ -1,29 +0,0 @@
-" Author: Franco Victorio - https://github.com/fvictorio
-" Description: Report errors in Solidity code with solhint
-
-function! ale_linters#solidity#solhint#Handle(buffer, lines) abort
-    " Matches patterns like the following:
-    " /path/to/file/file.sol: line 1, col 10, Error - 'addOne' is defined but never used. (no-unused-vars)
-    let l:pattern = '\v^[^:]+: line (\d+), col (\d+), (Error|Warning) - (.*) \((.*)\)$'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        let l:isError = l:match[3] is? 'error'
-        call add(l:output, {
-        \   'lnum': l:match[1] + 0,
-        \   'col': l:match[2] + 0,
-        \   'text': l:match[4],
-        \   'code': l:match[5],
-        \   'type': l:isError ? 'E' : 'W',
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('solidity', {
-\   'name': 'solhint',
-\   'executable': 'solhint',
-\   'command': 'solhint --formatter compact %t',
-\   'callback': 'ale_linters#solidity#solhint#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/solidity/solium.vim b/sources_non_forked/ale/ale_linters/solidity/solium.vim
deleted file mode 100644
index 61ab184..0000000
--- a/sources_non_forked/ale/ale_linters/solidity/solium.vim
+++ /dev/null
@@ -1,9 +0,0 @@
-" Author: Jeff Sutherland - https://github.com/jdsutherland
-" Description: Report errors in Solidity code with solium
-
-call ale#linter#Define('solidity', {
-\   'name': 'solium',
-\   'executable': 'solium',
-\   'command': 'solium --reporter gcc --file %t',
-\   'callback': 'ale#handlers#gcc#HandleGCCFormat',
-\})
diff --git a/sources_non_forked/ale/ale_linters/spec/rpmlint.vim b/sources_non_forked/ale/ale_linters/spec/rpmlint.vim
deleted file mode 100644
index 92ef4d6..0000000
--- a/sources_non_forked/ale/ale_linters/spec/rpmlint.vim
+++ /dev/null
@@ -1,78 +0,0 @@
-" Author: Jason Tibbitts <tibbs@math.uh.edu>
-" Description: Adds support for checking RPM spec files with rpmlint
-
-" rpmlint will produce varions types of output:
-"
-" Lines like the following are output when the file is simply not able to be
-" parsed by rpmspec -P:
-"   apcupsd.spec: E: specfile-error warning: bogus date in %changelog: Mon Oct 1 2005 - Foo
-"   apcupsd.spec: E: specfile-error error: %changelog not in descending chronological order
-" They do not contain a line number, and there's not a whole lot that can be
-" done to locate them besides grep for them.  rpmlint is just passing the
-" output from rpm along with the filename, an error indicator, and an error
-" type.
-"
-" Lines like the following:
-"   cyrus-imapd.spec:23: W: macro-in-comment %version
-"   cyrus-imapd.spec:18: E: hardcoded-library-path in %_prefix/lib/%name
-" indicate warnings and errors, respectively.  No column numbers are provided
-"
-" Lines like:
-"   apcupsd.spec: I: checking
-"   apcupsd.spec: I: checking-url https://downloads.sourceforge.net/apcupsd/apcupsd-3.14.14.tar.gz (timeout 10 seconds)
-" are merely informational and are only output when -v is passed.  But they
-" may be useful in a log to know why things are taking so long.
-"
-" And this is always output at the end and should just be ignored:
-"   0 packages and 1 specfiles checked; 4 errors, 0 warnings.
-
-call ale#Set('spec_rpmlint_executable', 'rpmlint')
-call ale#Set('spec_rpmlint_options', '')
-
-function! ale_linters#spec#rpmlint#GetCommand(buffer) abort
-    return '%e'
-    \   . ale#Pad(ale#Var(a:buffer, 'spec_rpmlint_options'))
-    \   . ' -o "NetworkEnabled False"'
-    \   . ' -v'
-    \   . ' %t'
-endfunction
-
-function! ale_linters#spec#rpmlint#Handle(buffer, lines) abort
-    " let l:pat_inform = '^.\+: I: \(.+\)'
-    let l:pat_errwarn = '^.\+:\(\d\+\): \([EW]\): \(.\+\)'
-    let l:pat_baderr = '^.\+: E: \(.\+\)'
-    let l:output = []
-
-    for l:line in a:lines
-        let l:match_errwarn = matchlist(l:line, l:pat_errwarn)
-        let l:match_baderr = matchlist(l:line, l:pat_baderr)
-
-        if len(l:match_errwarn) > 0
-            let l:text = l:match_errwarn[3]
-            let l:type = l:match_errwarn[2]
-            let l:lnum = l:match_errwarn[1] + 0
-        elseif len(l:match_baderr) > 0
-            let l:text = l:match_baderr[1]
-            let l:type = 'E'
-            let l:lnum = 1
-        else
-            continue
-        endif
-
-        call add(l:output, {
-        \   'bufnr': a:buffer,
-        \   'lnum': l:lnum,
-        \   'text': l:text,
-        \   'type': l:type,
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('spec', {
-\   'name': 'rpmlint',
-\   'executable': {b -> ale#Var(b, 'spec_rpmlint_executable')},
-\   'command': function('ale_linters#spec#rpmlint#GetCommand'),
-\   'callback': 'ale_linters#spec#rpmlint#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/sql/sqlint.vim b/sources_non_forked/ale/ale_linters/sql/sqlint.vim
deleted file mode 100644
index ca89372..0000000
--- a/sources_non_forked/ale/ale_linters/sql/sqlint.vim
+++ /dev/null
@@ -1,28 +0,0 @@
-" Author: Adriaan Zonnenberg <amz@adriaan.xyz>
-" Description: sqlint for SQL files
-
-function! ale_linters#sql#sqlint#Handle(buffer, lines) abort
-    " Matches patterns like the following:
-    "
-    " stdin:3:1:ERROR syntax error at or near "WIBBLE"
-    let l:pattern = '\v^[^:]+:(\d+):(\d+):(\u+) (.*)'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        call add(l:output, {
-        \   'lnum': l:match[1] + 0,
-        \   'col': l:match[2] + 0,
-        \   'type': l:match[3][0],
-        \   'text': l:match[4],
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('sql', {
-\   'name': 'sqlint',
-\   'executable': 'sqlint',
-\   'command': 'sqlint',
-\   'callback': 'ale_linters#sql#sqlint#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/stylus/stylelint.vim b/sources_non_forked/ale/ale_linters/stylus/stylelint.vim
deleted file mode 100644
index ce6f942..0000000
--- a/sources_non_forked/ale/ale_linters/stylus/stylelint.vim
+++ /dev/null
@@ -1,20 +0,0 @@
-" Author: diartyz <diartyz@gmail.com>, w0rp <devw0rp@gmail.com>
-
-call ale#Set('stylus_stylelint_executable', 'stylelint')
-call ale#Set('stylus_stylelint_options', '')
-call ale#Set('stylus_stylelint_use_global', get(g:, 'ale_use_global_executables', 0))
-
-function! ale_linters#stylus#stylelint#GetCommand(buffer) abort
-    return '%e'
-    \   . ale#Pad(ale#Var(a:buffer, 'stylus_stylelint_options'))
-    \   . ' --stdin-filename %s'
-endfunction
-
-call ale#linter#Define('stylus', {
-\   'name': 'stylelint',
-\   'executable': {b -> ale#node#FindExecutable(b, 'stylus_stylelint', [
-\       'node_modules/.bin/stylelint',
-\   ])},
-\   'command': function('ale_linters#stylus#stylelint#GetCommand'),
-\   'callback': 'ale#handlers#css#HandleStyleLintFormat',
-\})
diff --git a/sources_non_forked/ale/ale_linters/sugarss/stylelint.vim b/sources_non_forked/ale/ale_linters/sugarss/stylelint.vim
deleted file mode 100644
index 6c705e4..0000000
--- a/sources_non_forked/ale/ale_linters/sugarss/stylelint.vim
+++ /dev/null
@@ -1,21 +0,0 @@
-" Author: toastal <toastal@protonmail.com>
-" Description: `stylelint` linter for SugarSS files
-
-call ale#Set('sugarss_stylelint_executable', 'stylelint')
-call ale#Set('sugarss_stylelint_options', '')
-call ale#Set('sugarss_stylelint_use_global', get(g:, 'ale_use_global_executables', 0))
-
-function! ale_linters#sugarss#stylelint#GetCommand(buffer) abort
-    return '%e ' . ale#Pad(ale#Var(a:buffer, 'sugarss_stylelint_options'))
-    \   . ' --syntax=sugarss'
-    \   . ' --stdin-filename %s'
-endfunction
-
-call ale#linter#Define('sugarss', {
-\   'name': 'stylelint',
-\   'executable': {b -> ale#node#FindExecutable(b, 'sugarss_stylelint', [
-\       'node_modules/.bin/stylelint',
-\   ])},
-\   'command': function('ale_linters#sugarss#stylelint#GetCommand'),
-\   'callback': 'ale#handlers#css#HandleStyleLintFormat',
-\})
diff --git a/sources_non_forked/ale/ale_linters/swift/sourcekitlsp.vim b/sources_non_forked/ale/ale_linters/swift/sourcekitlsp.vim
deleted file mode 100644
index 560893b..0000000
--- a/sources_non_forked/ale/ale_linters/swift/sourcekitlsp.vim
+++ /dev/null
@@ -1,13 +0,0 @@
-" Author: Dan Loman <https://github.com/namolnad>
-" Description: Support for sourcekit-lsp https://github.com/apple/sourcekit-lsp
-
-call ale#Set('sourcekit_lsp_executable', 'sourcekit-lsp')
-
-call ale#linter#Define('swift', {
-\   'name': 'sourcekitlsp',
-\   'lsp': 'stdio',
-\   'executable': {b -> ale#Var(b, 'sourcekit_lsp_executable')},
-\   'command': '%e',
-\   'project_root': function('ale#swift#FindProjectRoot'),
-\   'language': 'swift',
-\})
diff --git a/sources_non_forked/ale/ale_linters/swift/swiftlint.vim b/sources_non_forked/ale/ale_linters/swift/swiftlint.vim
deleted file mode 100644
index 237c45d..0000000
--- a/sources_non_forked/ale/ale_linters/swift/swiftlint.vim
+++ /dev/null
@@ -1,69 +0,0 @@
-" Author: David Mohundro <david@mohundro.com>, Gordon Fontenot <gordon@fonten.io>
-" Description: swiftlint for swift files
-
-call ale#Set('swift_swiftlint_executable', 'swiftlint')
-call ale#Set('swift_swiftlint_use_global', get(g:, 'ale_use_global_executables', 0))
-
-function! ale_linters#swift#swiftlint#GetExecutable(buffer) abort
-    return ale#node#FindExecutable(a:buffer, 'swift_swiftlint', [
-    \ 'Pods/SwiftLint/swiftlint',
-    \ 'ios/Pods/SwiftLint/swiftlint',
-    \ 'swiftlint',
-    \])
-endfunction
-
-function! ale_linters#swift#swiftlint#GetCommand(buffer) abort
-    let l:executable = ale_linters#swift#swiftlint#GetExecutable(a:buffer)
-    let l:args = 'lint --use-stdin'
-
-    return ale#Escape(l:executable)
-    \ . ' ' .l:args
-endfunction
-
-function! ale_linters#swift#swiftlint#Handle(buffer, lines) abort
-    let l:pattern = '\v^([a-zA-Z]?:?[^:]+):(\d+):(\d+)?:? ([^:]+): (.+)$'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        let l:item = {
-        \   'lnum': str2nr(l:match[2]),
-        \   'type': l:match[4] is# 'error' ? 'E' : 'W',
-        \   'text': l:match[5],
-        \}
-
-        if l:match[4] is# 'error'
-            let l:item.type = 'E'
-        elseif l:match[4] is# 'note'
-            let l:item.type = 'I'
-        endif
-
-        if !empty(l:match[3])
-            let l:item.col = str2nr(l:match[3])
-        endif
-
-        " If the filename is something like <stdin>, <nofile> or -, then
-        " this is an error for the file we checked.
-        if l:match[1] isnot# '-' && l:match[1][0] isnot# '<'
-            let l:item['filename'] = l:match[1]
-        endif
-
-        " Parse the code if it's there.
-        let l:code_match = matchlist(l:item.text, '\v^(.+) \(([^ (]+)\)$')
-
-        if !empty(l:code_match)
-            let l:item.text = l:code_match[1]
-            let l:item.code = l:code_match[2]
-        endif
-
-        call add(l:output, l:item)
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('swift', {
-\   'name': 'swiftlint',
-\   'executable': function('ale_linters#swift#swiftlint#GetExecutable'),
-\   'command': function('ale_linters#swift#swiftlint#GetCommand'),
-\   'callback': 'ale_linters#swift#swiftlint#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/tcl/nagelfar.vim b/sources_non_forked/ale/ale_linters/tcl/nagelfar.vim
deleted file mode 100644
index 5a4940e..0000000
--- a/sources_non_forked/ale/ale_linters/tcl/nagelfar.vim
+++ /dev/null
@@ -1,39 +0,0 @@
-" Author: Nick James <github@nsjuk.xyz>
-" Description: nagelfar linter for tcl files
-
-call ale#Set('tcl_nagelfar_executable', 'nagelfar.tcl')
-call ale#Set('tcl_nagelfar_options', '')
-
-function! ale_linters#tcl#nagelfar#GetCommand(buffer) abort
-    let l:options = ale#Var(a:buffer, 'tcl_nagelfar_options')
-
-    return '%e' . ale#Pad(l:options) . ' %s'
-endfunction
-
-function! ale_linters#tcl#nagelfar#Handle(buffer, lines) abort
-    " Matches patterns like the following:
-    " Line   5: W Found constant "bepa" which is also a variable.
-    " Line  13: E Wrong number of arguments (3) to "set"
-    " Line  93: N Close brace not aligned with line 90 (4 0)
-    let l:pattern = '^Line\s\+\([0-9]\+\): \([NEW]\) \(.*\)$'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        call add(l:output, {
-        \   'lnum': l:match[1] + 0,
-        \   'type': l:match[2] is# 'N' ? 'W' : l:match[2],
-        \   'text': l:match[3],
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('tcl', {
-\   'name': 'nagelfar',
-\   'output_stream': 'stdout',
-\   'executable': {b -> ale#Var(b, 'tcl_nagelfar_executable')},
-\   'command': function('ale_linters#tcl#nagelfar#GetCommand'),
-\   'callback': 'ale_linters#tcl#nagelfar#Handle',
-\   'lint_file': 1,
-\})
diff --git a/sources_non_forked/ale/ale_linters/terraform/terraform.vim b/sources_non_forked/ale/ale_linters/terraform/terraform.vim
deleted file mode 100644
index 0429cb7..0000000
--- a/sources_non_forked/ale/ale_linters/terraform/terraform.vim
+++ /dev/null
@@ -1,49 +0,0 @@
-" Author: Keith Maxwell <keith.maxwell@gmail.com>
-" Description: terraform fmt to check for errors
-
-call ale#Set('terraform_terraform_executable', 'terraform')
-
-function! ale_linters#terraform#terraform#GetExecutable(buffer) abort
-    return ale#Var(a:buffer, 'terraform_terraform_executable')
-endfunction
-
-function! ale_linters#terraform#terraform#GetCommand(buffer) abort
-    return ale#Escape(ale_linters#terraform#terraform#GetExecutable(a:buffer))
-    \   . ' fmt -no-color --check=true -'
-endfunction
-
-function! ale_linters#terraform#terraform#Handle(buffer, lines) abort
-    let l:head = '^Error running fmt: In <standard input>: '
-    let l:output = []
-    let l:patterns = [
-    \   l:head.'At \(\d\+\):\(\d\+\): \(.*\)$',
-    \   l:head.'\(.*\)$'
-    \]
-
-    for l:match in ale#util#GetMatches(a:lines, l:patterns)
-        if len(l:match[2]) > 0
-            call add(l:output, {
-            \   'lnum': str2nr(l:match[1]),
-            \   'col': str2nr(l:match[2]),
-            \   'text': l:match[3],
-            \   'type': 'E',
-            \})
-        else
-            call add(l:output, {
-            \   'lnum': line('$'),
-            \   'text': l:match[1],
-            \   'type': 'E',
-            \})
-        endif
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('terraform', {
-\   'name': 'terraform',
-\   'output_stream': 'stderr',
-\   'executable': function('ale_linters#terraform#terraform#GetExecutable'),
-\   'command': function('ale_linters#terraform#terraform#GetCommand'),
-\   'callback': 'ale_linters#terraform#terraform#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/terraform/terraform_lsp.vim b/sources_non_forked/ale/ale_linters/terraform/terraform_lsp.vim
deleted file mode 100644
index e2408c1..0000000
--- a/sources_non_forked/ale/ale_linters/terraform/terraform_lsp.vim
+++ /dev/null
@@ -1,25 +0,0 @@
-" Author: OJFord <dev@ojford.com>
-" Description: terraform-lsp integration for ALE (cf. https://github.com/juliosueiras/terraform-lsp)
-
-call ale#Set('terraform_langserver_executable', 'terraform-lsp')
-call ale#Set('terraform_langserver_options', '')
-
-function! ale_linters#terraform#terraform_lsp#GetCommand(buffer) abort
-    return '%e'
-    \   . ale#Pad(ale#Var(a:buffer, 'terraform_langserver_options'))
-endfunction
-
-function! ale_linters#terraform#terraform_lsp#GetProjectRoot(buffer) abort
-    let l:tf_dir = ale#path#FindNearestDirectory(a:buffer, '.terraform')
-
-    return !empty(l:tf_dir) ? fnamemodify(l:tf_dir, ':h:h') : ''
-endfunction
-
-call ale#linter#Define('terraform', {
-\   'name': 'terraform_lsp',
-\   'lsp': 'stdio',
-\   'executable': {b -> ale#Var(b, 'terraform_langserver_executable')},
-\   'command': function('ale_linters#terraform#terraform_lsp#GetCommand'),
-\   'project_root': function('ale_linters#terraform#terraform_lsp#GetProjectRoot'),
-\   'language': 'terraform',
-\})
diff --git a/sources_non_forked/ale/ale_linters/terraform/tflint.vim b/sources_non_forked/ale/ale_linters/terraform/tflint.vim
deleted file mode 100644
index f57ee6b..0000000
--- a/sources_non_forked/ale/ale_linters/terraform/tflint.vim
+++ /dev/null
@@ -1,104 +0,0 @@
-" Author: Nat Williams <nat.williams@gmail.com>
-" Description: tflint for Terraform files
-"
-" See: https://www.terraform.io/
-"      https://github.com/wata727/tflint
-
-call ale#Set('terraform_tflint_options', '')
-call ale#Set('terraform_tflint_executable', 'tflint')
-
-function! ale_linters#terraform#tflint#Handle(buffer, lines) abort
-    let l:output = []
-    let l:pattern = '\v^(.*):(\d+),(\d+)-(\d+)?,?(\d+): (.{-1,}); (.+)$'
-    let l:json = ale#util#FuzzyJSONDecode(a:lines, {})
-
-    " This is a rough test for tflint's output format
-    " On versions prior to 0.11 it outputs all errors as a single level list
-    if type(l:json) is v:t_list
-        for l:error in l:json
-            if l:error.type is# 'ERROR'
-                let l:type = 'E'
-            elseif l:error.type is# 'NOTICE'
-                let l:type = 'I'
-            else
-                let l:type = 'W'
-            endif
-
-            call add(l:output, {
-            \   'lnum': l:error.line,
-            \   'text': l:error.message,
-            \   'type': l:type,
-            \   'code': l:error.detector,
-            \})
-        endfor
-    else
-        for l:error in get(l:json, 'errors', [])
-            for l:match in ale#util#GetMatches(l:error.message, [l:pattern])
-                if l:match[4] is# ''
-                    let l:match[4] = l:match[2]
-                endif
-
-                call add(l:output, {
-                \   'filename': l:match[1],
-                \   'lnum': str2nr(l:match[2]),
-                \   'col': str2nr(l:match[3]),
-                \   'end_lnum': str2nr(l:match[4]),
-                \   'end_col': str2nr(l:match[5]),
-                \   'text': l:match[7],
-                \   'code': l:match[6],
-                \   'type': 'E',
-                \})
-            endfor
-        endfor
-
-        for l:error in get(l:json, 'issues', [])
-            if l:error.rule.severity is# 'ERROR'
-                let l:type = 'E'
-            elseif l:error.rule.severity is# 'NOTICE'
-                let l:type = 'I'
-            else
-                let l:type = 'W'
-            endif
-
-            call add(l:output, {
-            \   'filename': l:error.range.filename,
-            \   'lnum': l:error.range.start.line,
-            \   'col': l:error.range.start.column,
-            \   'end_lnum': l:error.range.end.line,
-            \   'end_col': l:error.range.end.column,
-            \   'text': l:error.message,
-            \   'code': l:error.rule.name,
-            \   'type': l:type,
-            \})
-        endfor
-    endif
-
-    return l:output
-endfunction
-
-function! ale_linters#terraform#tflint#GetCommand(buffer) abort
-    let l:cmd = '%e'
-
-    let l:config_file = ale#path#FindNearestFile(a:buffer, '.tflint.hcl')
-
-    if !empty(l:config_file)
-        let l:cmd .= ' --config ' . ale#Escape(l:config_file)
-    endif
-
-    let l:opts = ale#Var(a:buffer, 'terraform_tflint_options')
-
-    if !empty(l:opts)
-        let l:cmd .= ' ' . l:opts
-    endif
-
-    let l:cmd .= ' -f json %t'
-
-    return l:cmd
-endfunction
-
-call ale#linter#Define('terraform', {
-\   'name': 'tflint',
-\   'executable': {b -> ale#Var(b, 'terraform_tflint_executable')},
-\   'command': function('ale_linters#terraform#tflint#GetCommand'),
-\   'callback': 'ale_linters#terraform#tflint#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/testft/testlinter.vim b/sources_non_forked/ale/ale_linters/testft/testlinter.vim
deleted file mode 100644
index 65e0b20..0000000
--- a/sources_non_forked/ale/ale_linters/testft/testlinter.vim
+++ /dev/null
@@ -1,10 +0,0 @@
-" Author: neersighted <bjorn@neersighted.com>
-" Description: dummy linter to use in tests
-
-call ale#linter#Define('testft', {
-\   'name': 'testlinter',
-\   'output_stream': 'stdout',
-\   'executable': 'testlinter',
-\   'command': 'testlinter',
-\   'callback': 'testCB',
-\})
diff --git a/sources_non_forked/ale/ale_linters/tex/alex.vim b/sources_non_forked/ale/ale_linters/tex/alex.vim
deleted file mode 100644
index 5d9aec6..0000000
--- a/sources_non_forked/ale/ale_linters/tex/alex.vim
+++ /dev/null
@@ -1,4 +0,0 @@
-" Author: Johannes Wienke <languitar@semipol.de>
-" Description: alex for TeX files
-
-call ale#handlers#alex#DefineLinter('tex', '--text')
diff --git a/sources_non_forked/ale/ale_linters/tex/chktex.vim b/sources_non_forked/ale/ale_linters/tex/chktex.vim
deleted file mode 100644
index 160baf0..0000000
--- a/sources_non_forked/ale/ale_linters/tex/chktex.vim
+++ /dev/null
@@ -1,54 +0,0 @@
-" Author: Andrew Balmos - <andrew@balmos.org>
-" Description: chktex for LaTeX files
-
-let g:ale_tex_chktex_executable =
-\   get(g:, 'ale_tex_chktex_executable', 'chktex')
-
-let g:ale_tex_chktex_options =
-\   get(g:, 'ale_tex_chktex_options', '-I')
-
-function! ale_linters#tex#chktex#GetCommand(buffer) abort
-    " Check for optional .chktexrc
-    let l:chktex_config = ale#path#FindNearestFile(
-    \   a:buffer,
-    \   '.chktexrc')
-
-    let l:command = ale#Var(a:buffer, 'tex_chktex_executable')
-    " Avoid bug when used without -p (last warning has gibberish for a filename)
-    let l:command .= ' -v0 -p stdin -q'
-
-    if !empty(l:chktex_config)
-        let l:command .= ' -l ' . ale#Escape(l:chktex_config)
-    endif
-
-    let l:command .= ' ' . ale#Var(a:buffer, 'tex_chktex_options')
-
-    return l:command
-endfunction
-
-function! ale_linters#tex#chktex#Handle(buffer, lines) abort
-    " Mattes lines like:
-    "
-    " stdin:499:2:24:Delete this space to maintain correct pagereferences.
-    " stdin:507:81:3:You should enclose the previous parenthesis with `{}'.
-    let l:pattern = '^stdin:\(\d\+\):\(\d\+\):\(\d\+\):\(.\+\)$'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        call add(l:output, {
-        \   'lnum': l:match[1] + 0,
-        \   'col': l:match[2] + 0,
-        \   'text': l:match[4] . ' (' . (l:match[3]+0) . ')',
-        \   'type': 'W',
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('tex', {
-\   'name': 'chktex',
-\   'executable': 'chktex',
-\   'command': function('ale_linters#tex#chktex#GetCommand'),
-\   'callback': 'ale_linters#tex#chktex#Handle'
-\})
diff --git a/sources_non_forked/ale/ale_linters/tex/lacheck.vim b/sources_non_forked/ale/ale_linters/tex/lacheck.vim
deleted file mode 100644
index 19d6940..0000000
--- a/sources_non_forked/ale/ale_linters/tex/lacheck.vim
+++ /dev/null
@@ -1,43 +0,0 @@
-" Author: Andrew Balmos - <andrew@balmos.org>
-" Description: lacheck for LaTeX files
-
-call ale#Set('tex_lacheck_executable', 'lacheck')
-
-function! ale_linters#tex#lacheck#Handle(buffer, lines) abort
-    " Mattes lines like:
-    "
-    " "book.tex", line 37: possible unwanted space at "{"
-    " "book.tex", line 38: missing `\ ' after "etc."
-    let l:pattern = '^"\(.\+\)", line \(\d\+\): \(.\+\)$'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        " lacheck follows `\input{}` commands. If the cwd is not the same as the
-        " file in the buffer then it will fail to find the inputed items. We do not
-        " want warnings from those items anyway
-        if !empty(matchstr(l:match[3], '^Could not open ".\+"$'))
-            continue
-        endif
-
-        " lacheck follows `\input{}` commands. We are only interested in
-        " reporting errors for the current buffer only.
-        if empty(matchstr(fnamemodify(l:match[1], ':t'), fnamemodify(bufname(a:buffer), ':t')))
-            continue
-        endif
-
-        call add(l:output, {
-        \   'lnum': l:match[2] + 0,
-        \   'text': l:match[3],
-        \   'type': 'W',
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('tex', {
-\   'name': 'lacheck',
-\   'executable': {b -> ale#Var(b, 'tex_lacheck_executable')},
-\   'command': '%e %t',
-\   'callback': 'ale_linters#tex#lacheck#Handle'
-\})
diff --git a/sources_non_forked/ale/ale_linters/tex/proselint.vim b/sources_non_forked/ale/ale_linters/tex/proselint.vim
deleted file mode 100644
index 35e764e..0000000
--- a/sources_non_forked/ale/ale_linters/tex/proselint.vim
+++ /dev/null
@@ -1,9 +0,0 @@
-" Author: poohzrn https://github.com/poohzrn
-" Description: proselint for TeX files
-
-call ale#linter#Define('tex', {
-\   'name': 'proselint',
-\   'executable': 'proselint',
-\   'command': 'proselint %t',
-\   'callback': 'ale#handlers#unix#HandleAsWarning',
-\})
diff --git a/sources_non_forked/ale/ale_linters/tex/redpen.vim b/sources_non_forked/ale/ale_linters/tex/redpen.vim
deleted file mode 100644
index 952a600..0000000
--- a/sources_non_forked/ale/ale_linters/tex/redpen.vim
+++ /dev/null
@@ -1,9 +0,0 @@
-" Author: rhysd https://rhysd.github.io
-" Description: Redpen, a proofreading tool (http://redpen.cc)
-
-call ale#linter#Define('tex', {
-\   'name': 'redpen',
-\   'executable': 'redpen',
-\   'command': 'redpen -f latex -r json %t',
-\   'callback': 'ale#handlers#redpen#HandleRedpenOutput',
-\})
diff --git a/sources_non_forked/ale/ale_linters/tex/texlab.vim b/sources_non_forked/ale/ale_linters/tex/texlab.vim
deleted file mode 100644
index 5ead74b..0000000
--- a/sources_non_forked/ale/ale_linters/tex/texlab.vim
+++ /dev/null
@@ -1,21 +0,0 @@
-" Author: Ricardo Liang <ricardoliang@gmail.com>
-" Description: Texlab language server (Rust rewrite)
-
-call ale#Set('tex_texlab_executable', 'texlab')
-call ale#Set('tex_texlab_options', '')
-
-function! ale_linters#tex#texlab#GetProjectRoot(buffer) abort
-    return ''
-endfunction
-
-function! ale_linters#tex#texlab#GetCommand(buffer) abort
-    return '%e' . ale#Pad(ale#Var(a:buffer, 'tex_texlab_options'))
-endfunction
-
-call ale#linter#Define('tex', {
-\   'name': 'texlab',
-\   'lsp': 'stdio',
-\   'executable': {b -> ale#Var(b, 'tex_texlab_executable')},
-\   'command': function('ale_linters#tex#texlab#GetCommand'),
-\   'project_root': function('ale_linters#tex#texlab#GetProjectRoot'),
-\})
diff --git a/sources_non_forked/ale/ale_linters/tex/textlint.vim b/sources_non_forked/ale/ale_linters/tex/textlint.vim
deleted file mode 100644
index 5edac46..0000000
--- a/sources_non_forked/ale/ale_linters/tex/textlint.vim
+++ /dev/null
@@ -1,9 +0,0 @@
-" Author: TANIGUCHI Masaya <ta2gch@gmail.com>
-" Description: textlint for LaTeX files
-
-call ale#linter#Define('tex', {
-\   'name': 'textlint',
-\   'executable': function('ale#handlers#textlint#GetExecutable'),
-\   'command': function('ale#handlers#textlint#GetCommand'),
-\   'callback': 'ale#handlers#textlint#HandleTextlintOutput',
-\})
diff --git a/sources_non_forked/ale/ale_linters/tex/vale.vim b/sources_non_forked/ale/ale_linters/tex/vale.vim
deleted file mode 100644
index f64e72a..0000000
--- a/sources_non_forked/ale/ale_linters/tex/vale.vim
+++ /dev/null
@@ -1,9 +0,0 @@
-" Author: chew-z https://github.com/chew-z
-" Description: vale for LaTeX files
-
-call ale#linter#Define('tex', {
-\   'name': 'vale',
-\   'executable': 'vale',
-\   'command': 'vale --output=JSON %t',
-\   'callback': 'ale#handlers#vale#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/tex/writegood.vim b/sources_non_forked/ale/ale_linters/tex/writegood.vim
deleted file mode 100644
index c1aeace..0000000
--- a/sources_non_forked/ale/ale_linters/tex/writegood.vim
+++ /dev/null
@@ -1,4 +0,0 @@
-" Author: Sumner Evans <sumner.evans98@gmail.com>
-" Description: write-good for TeX files
-
-call ale#handlers#writegood#DefineLinter('tex')
diff --git a/sources_non_forked/ale/ale_linters/texinfo/alex.vim b/sources_non_forked/ale/ale_linters/texinfo/alex.vim
deleted file mode 100644
index 4d24552..0000000
--- a/sources_non_forked/ale/ale_linters/texinfo/alex.vim
+++ /dev/null
@@ -1,4 +0,0 @@
-" Author: Johannes Wienke <languitar@semipol.de>
-" Description: alex for texinfo files
-
-call ale#handlers#alex#DefineLinter('texinfo', '--text')
diff --git a/sources_non_forked/ale/ale_linters/texinfo/proselint.vim b/sources_non_forked/ale/ale_linters/texinfo/proselint.vim
deleted file mode 100644
index 003e3a0..0000000
--- a/sources_non_forked/ale/ale_linters/texinfo/proselint.vim
+++ /dev/null
@@ -1,9 +0,0 @@
-" Author: Daniel M. Capella https://github.com/polyzen
-" Description: proselint for Texinfo files
-
-call ale#linter#Define('texinfo', {
-\   'name': 'proselint',
-\   'executable': 'proselint',
-\   'command': 'proselint %t',
-\   'callback': 'ale#handlers#unix#HandleAsWarning',
-\})
diff --git a/sources_non_forked/ale/ale_linters/texinfo/writegood.vim b/sources_non_forked/ale/ale_linters/texinfo/writegood.vim
deleted file mode 100644
index 4427f05..0000000
--- a/sources_non_forked/ale/ale_linters/texinfo/writegood.vim
+++ /dev/null
@@ -1,4 +0,0 @@
-" Author: Sumner Evans <sumner.evans98@gmail.com>
-" Description: write-good for Texinfo files
-
-call ale#handlers#writegood#DefineLinter('texinfo')
diff --git a/sources_non_forked/ale/ale_linters/text/alex.vim b/sources_non_forked/ale/ale_linters/text/alex.vim
deleted file mode 100644
index d87ed91..0000000
--- a/sources_non_forked/ale/ale_linters/text/alex.vim
+++ /dev/null
@@ -1,4 +0,0 @@
-" Author: Johannes Wienke <languitar@semipol.de>
-" Description: alex for text files
-
-call ale#handlers#alex#DefineLinter('text', '--text')
diff --git a/sources_non_forked/ale/ale_linters/text/languagetool.vim b/sources_non_forked/ale/ale_linters/text/languagetool.vim
deleted file mode 100644
index 58c99ba..0000000
--- a/sources_non_forked/ale/ale_linters/text/languagetool.vim
+++ /dev/null
@@ -1,4 +0,0 @@
-" Author: Vincent (wahrwolf [t] wolfpit.net)
-" Description: languagetool for text files
-
-call ale#handlers#languagetool#DefineLinter('text')
diff --git a/sources_non_forked/ale/ale_linters/text/proselint.vim b/sources_non_forked/ale/ale_linters/text/proselint.vim
deleted file mode 100644
index 281b4ff..0000000
--- a/sources_non_forked/ale/ale_linters/text/proselint.vim
+++ /dev/null
@@ -1,9 +0,0 @@
-" Author: poohzrn https://github.com/poohzrn
-" Description: proselint for text files
-
-call ale#linter#Define('text', {
-\   'name': 'proselint',
-\   'executable': 'proselint',
-\   'command': 'proselint %t',
-\   'callback': 'ale#handlers#unix#HandleAsWarning',
-\})
diff --git a/sources_non_forked/ale/ale_linters/text/redpen.vim b/sources_non_forked/ale/ale_linters/text/redpen.vim
deleted file mode 100644
index ec4433b..0000000
--- a/sources_non_forked/ale/ale_linters/text/redpen.vim
+++ /dev/null
@@ -1,9 +0,0 @@
-" Author: rhysd https://rhysd.github.io
-" Description: Redpen, a proofreading tool (http://redpen.cc)
-
-call ale#linter#Define('text', {
-\   'name': 'redpen',
-\   'executable': 'redpen',
-\   'command': 'redpen -f plain -r json %t',
-\   'callback': 'ale#handlers#redpen#HandleRedpenOutput',
-\})
diff --git a/sources_non_forked/ale/ale_linters/text/textlint.vim b/sources_non_forked/ale/ale_linters/text/textlint.vim
deleted file mode 100644
index 67c4e37..0000000
--- a/sources_non_forked/ale/ale_linters/text/textlint.vim
+++ /dev/null
@@ -1,9 +0,0 @@
-" Author: Yasuhiro Kiyota <yasuhiroki.duck@gmail.com>
-" Description: textlint, a proofreading tool (https://textlint.github.io/)
-
-call ale#linter#Define('text', {
-\   'name': 'textlint',
-\   'executable': function('ale#handlers#textlint#GetExecutable'),
-\   'command': function('ale#handlers#textlint#GetCommand'),
-\   'callback': 'ale#handlers#textlint#HandleTextlintOutput',
-\})
diff --git a/sources_non_forked/ale/ale_linters/text/vale.vim b/sources_non_forked/ale/ale_linters/text/vale.vim
deleted file mode 100644
index cf37c2f..0000000
--- a/sources_non_forked/ale/ale_linters/text/vale.vim
+++ /dev/null
@@ -1,9 +0,0 @@
-" Author: chew-z https://github.com/chew-z
-" Description: vale for text files
-
-call ale#linter#Define('text', {
-\   'name': 'vale',
-\   'executable': 'vale',
-\   'command': 'vale --output=JSON %t',
-\   'callback': 'ale#handlers#vale#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/text/writegood.vim b/sources_non_forked/ale/ale_linters/text/writegood.vim
deleted file mode 100644
index 81b935d..0000000
--- a/sources_non_forked/ale/ale_linters/text/writegood.vim
+++ /dev/null
@@ -1,4 +0,0 @@
-" Author: Sumner Evans <sumner.evans98@gmail.com>
-" Description: write-good for text files
-
-call ale#handlers#writegood#DefineLinter('text')
diff --git a/sources_non_forked/ale/ale_linters/thrift/thrift.vim b/sources_non_forked/ale/ale_linters/thrift/thrift.vim
deleted file mode 100644
index 345c7ab..0000000
--- a/sources_non_forked/ale/ale_linters/thrift/thrift.vim
+++ /dev/null
@@ -1,87 +0,0 @@
-" Author: Jon Parise <jon@indelible.org>
-
-call ale#Set('thrift_thrift_executable', 'thrift')
-call ale#Set('thrift_thrift_generators', ['cpp'])
-call ale#Set('thrift_thrift_includes', ['.'])
-call ale#Set('thrift_thrift_options', '-strict')
-
-function! ale_linters#thrift#thrift#GetCommand(buffer) abort
-    let l:generators = ale#Var(a:buffer, 'thrift_thrift_generators')
-    let l:includes = ale#Var(a:buffer, 'thrift_thrift_includes')
-
-    " The thrift compiler requires at least one generator. If none are set,
-    " fall back to our default value to avoid silently failing. We could also
-    " `throw` here, but that seems even less helpful.
-    if empty(l:generators)
-        let l:generators = ['cpp']
-    endif
-
-    let l:output_dir = ale#command#CreateDirectory(a:buffer)
-
-    return '%e'
-    \   . ale#Pad(join(map(copy(l:generators), "'--gen ' . v:val")))
-    \   . ale#Pad(join(map(copy(l:includes), "'-I ' . v:val")))
-    \   . ale#Pad(ale#Var(a:buffer, 'thrift_thrift_options'))
-    \   . ' -out ' . ale#Escape(l:output_dir)
-    \   . ' %t'
-endfunction
-
-function! ale_linters#thrift#thrift#Handle(buffer, lines) abort
-    " Matches lines like the following:
-    "
-    " [SEVERITY:/path/filename.thrift:31] Message text
-    " [ERROR:/path/filename.thrift:31] (last token was ';')
-    let l:pattern = '\v^\[(\u+):(.*):(\d+)\] (.*)$'
-
-    let l:index = 0
-    let l:output = []
-
-    " Roll our own output-matching loop instead of using ale#util#GetMatches
-    " because we need to support error messages that span multiple lines.
-    while l:index < len(a:lines)
-        let l:line = a:lines[l:index]
-
-        let l:match = matchlist(l:line, l:pattern)
-
-        if empty(l:match)
-            let l:index += 1
-            continue
-        endif
-
-        let l:severity = l:match[1]
-
-        if l:severity is# 'WARNING'
-            let l:type = 'W'
-        else
-            let l:type = 'E'
-        endif
-
-        " If our text looks like "(last token was ';')", the *next* line
-        " should contain a more descriptive error message.
-        let l:text = l:match[4]
-
-        if l:text =~# '\(last token was .*\)'
-            let l:index += 1
-            let l:text = get(a:lines, l:index, 'Unknown error ' . l:text)
-        endif
-
-        call add(l:output, {
-        \   'lnum': l:match[3] + 0,
-        \   'col': 0,
-        \   'type': l:type,
-        \   'text': l:text,
-        \})
-
-        let l:index += 1
-    endwhile
-
-    return l:output
-endfunction
-
-call ale#linter#Define('thrift', {
-\   'name': 'thrift',
-\   'output_stream': 'both',
-\   'executable': {b -> ale#Var(b, 'thrift_thrift_executable')},
-\   'command': function('ale_linters#thrift#thrift#GetCommand'),
-\   'callback': 'ale_linters#thrift#thrift#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/typescript/eslint.vim b/sources_non_forked/ale/ale_linters/typescript/eslint.vim
deleted file mode 100644
index 33a2144..0000000
--- a/sources_non_forked/ale/ale_linters/typescript/eslint.vim
+++ /dev/null
@@ -1,9 +0,0 @@
-" Author: w0rp <devw0rp@gmail.com>
-" Description: eslint for JavaScript files
-
-call ale#linter#Define('typescript', {
-\   'name': 'eslint',
-\   'executable': function('ale#handlers#eslint#GetExecutable'),
-\   'command': function('ale#handlers#eslint#GetCommand'),
-\   'callback': 'ale#handlers#eslint#HandleJSON',
-\})
diff --git a/sources_non_forked/ale/ale_linters/typescript/standard.vim b/sources_non_forked/ale/ale_linters/typescript/standard.vim
deleted file mode 100644
index da8f14e..0000000
--- a/sources_non_forked/ale/ale_linters/typescript/standard.vim
+++ /dev/null
@@ -1,31 +0,0 @@
-" Author: Ahmed El Gabri <@ahmedelgabri>
-" Description: standardjs for typescript files
-
-call ale#Set('typescript_standard_executable', 'standard')
-call ale#Set('typescript_standard_use_global', get(g:, 'ale_use_global_executables', 0))
-call ale#Set('typescript_standard_options', '')
-
-function! ale_linters#typescript#standard#GetExecutable(buffer) abort
-    return ale#node#FindExecutable(a:buffer, 'typescript_standard', [
-    \   'node_modules/standardx/bin/cmd.js',
-    \   'node_modules/standard/bin/cmd.js',
-    \   'node_modules/.bin/standard',
-    \])
-endfunction
-
-function! ale_linters#typescript#standard#GetCommand(buffer) abort
-    let l:executable = ale_linters#typescript#standard#GetExecutable(a:buffer)
-    let l:options = ale#Var(a:buffer, 'typescript_standard_options')
-
-    return ale#node#Executable(a:buffer, l:executable)
-    \   . (!empty(l:options) ? ' ' . l:options : '')
-    \   . ' --stdin %s'
-endfunction
-
-" standard uses eslint and the output format is the same
-call ale#linter#Define('typescript', {
-\   'name': 'standard',
-\   'executable': function('ale_linters#typescript#standard#GetExecutable'),
-\   'command': function('ale_linters#typescript#standard#GetCommand'),
-\   'callback': 'ale#handlers#eslint#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/typescript/tslint.vim b/sources_non_forked/ale/ale_linters/typescript/tslint.vim
deleted file mode 100644
index f70c2e4..0000000
--- a/sources_non_forked/ale/ale_linters/typescript/tslint.vim
+++ /dev/null
@@ -1,75 +0,0 @@
-" Author: Prashanth Chandra <https://github.com/prashcr>, Jonathan Clem <https://jclem.net>
-" Description: tslint for TypeScript files
-
-call ale#handlers#tslint#InitVariables()
-
-function! ale_linters#typescript#tslint#Handle(buffer, lines) abort
-    " Do not output any errors for empty files if the option is on.
-    if ale#Var(a:buffer, 'typescript_tslint_ignore_empty_files')
-    \&& getbufline(a:buffer, 1, '$') == ['']
-        return []
-    endif
-
-    let l:dir = expand('#' . a:buffer . ':p:h')
-    let l:output = []
-
-    for l:error in ale#util#FuzzyJSONDecode(a:lines, [])
-        if get(l:error, 'ruleName', '') is# 'no-implicit-dependencies'
-            continue
-        endif
-
-        let l:item = {
-        \   'type': (get(l:error, 'ruleSeverity', '') is# 'WARNING' ? 'W' : 'E'),
-        \   'text': l:error.failure,
-        \   'lnum': l:error.startPosition.line + 1,
-        \   'col': l:error.startPosition.character + 1,
-        \   'end_lnum': l:error.endPosition.line + 1,
-        \   'end_col': l:error.endPosition.character + 1,
-        \}
-
-        let l:filename = ale#path#GetAbsPath(l:dir, l:error.name)
-
-        " Assume temporary files are this file.
-        if !ale#path#IsTempName(l:filename)
-            let l:item.filename = l:filename
-        endif
-
-        if has_key(l:error, 'ruleName')
-            let l:item.code = l:error.ruleName
-        endif
-
-        call add(l:output, l:item)
-    endfor
-
-    return l:output
-endfunction
-
-function! ale_linters#typescript#tslint#GetCommand(buffer) abort
-    let l:tslint_config_path = ale#path#ResolveLocalPath(
-    \   a:buffer,
-    \   'tslint.json',
-    \   ale#Var(a:buffer, 'typescript_tslint_config_path')
-    \)
-    let l:tslint_config_option = !empty(l:tslint_config_path)
-    \   ? ' -c ' . ale#Escape(l:tslint_config_path)
-    \   : ''
-
-    let l:tslint_rules_dir = ale#Var(a:buffer, 'typescript_tslint_rules_dir')
-    let l:tslint_rules_option = !empty(l:tslint_rules_dir)
-    \  ? ' -r ' . ale#Escape(l:tslint_rules_dir)
-    \  : ''
-
-    return ale#path#BufferCdString(a:buffer)
-    \   . ale#Escape(ale#handlers#tslint#GetExecutable(a:buffer))
-    \   . ' --format json'
-    \   . l:tslint_config_option
-    \   . l:tslint_rules_option
-    \   . ' %t'
-endfunction
-
-call ale#linter#Define('typescript', {
-\   'name': 'tslint',
-\   'executable': function('ale#handlers#tslint#GetExecutable'),
-\   'command': function('ale_linters#typescript#tslint#GetCommand'),
-\   'callback': 'ale_linters#typescript#tslint#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/typescript/tsserver.vim b/sources_non_forked/ale/ale_linters/typescript/tsserver.vim
deleted file mode 100644
index 840889f..0000000
--- a/sources_non_forked/ale/ale_linters/typescript/tsserver.vim
+++ /dev/null
@@ -1,17 +0,0 @@
-" Author: w0rp <devw0rp@gmail.com>
-" Description: tsserver integration for ALE
-
-call ale#Set('typescript_tsserver_executable', 'tsserver')
-call ale#Set('typescript_tsserver_config_path', '')
-call ale#Set('typescript_tsserver_use_global', get(g:, 'ale_use_global_executables', 0))
-
-call ale#linter#Define('typescript', {
-\   'name': 'tsserver',
-\   'lsp': 'tsserver',
-\   'executable': {b -> ale#node#FindExecutable(b, 'typescript_tsserver', [
-\       'node_modules/.bin/tsserver',
-\   ])},
-\   'command': '%e',
-\   'project_root': function('ale#handlers#tsserver#GetProjectRoot'),
-\   'language': '',
-\})
diff --git a/sources_non_forked/ale/ale_linters/typescript/typecheck.vim b/sources_non_forked/ale/ale_linters/typescript/typecheck.vim
deleted file mode 100644
index 2f18691..0000000
--- a/sources_non_forked/ale/ale_linters/typescript/typecheck.vim
+++ /dev/null
@@ -1,33 +0,0 @@
-" Author: Prashanth Chandra https://github.com/prashcr, Aleh Kashnikau https://github.com/mkusher
-" Description: type checker for TypeScript files
-
-function! ale_linters#typescript#typecheck#Handle(buffer, lines) abort
-    " Matches patterns like the following:
-    "
-    " hello.ts[7, 41]: Property 'a' does not exist on type 'A'
-    " hello.ts[16, 7]: Type 'A' is not assignable to type 'B'
-    "
-    let l:pattern = '.\+\.ts\[\(\d\+\), \(\d\+\)\]: \(.\+\)'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        let l:line = l:match[1] + 0
-        let l:column = l:match[2] + 0
-        let l:text = l:match[3]
-
-        call add(l:output, {
-        \   'lnum': l:line,
-        \   'col': l:column,
-        \   'text': l:text,
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('typescript', {
-\   'name': 'typecheck',
-\   'executable': 'typecheck',
-\   'command': 'typecheck %s',
-\   'callback': 'ale_linters#typescript#typecheck#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/typescript/xo.vim b/sources_non_forked/ale/ale_linters/typescript/xo.vim
deleted file mode 100644
index 0a3a717..0000000
--- a/sources_non_forked/ale/ale_linters/typescript/xo.vim
+++ /dev/null
@@ -1,23 +0,0 @@
-call ale#Set('typescript_xo_executable', 'xo')
-call ale#Set('typescript_xo_use_global', get(g:, 'ale_use_global_executables', 0))
-call ale#Set('typescript_xo_options', '')
-
-function! ale_linters#typescript#xo#GetExecutable(buffer) abort
-    return ale#node#FindExecutable(a:buffer, 'typescript_xo', [
-    \   'node_modules/.bin/xo',
-    \])
-endfunction
-
-function! ale_linters#typescript#xo#GetCommand(buffer) abort
-    return ale#Escape(ale_linters#typescript#xo#GetExecutable(a:buffer))
-    \   . ale#Pad(ale#Var(a:buffer, 'typescript_xo_options'))
-    \   . ' --reporter json --stdin --stdin-filename %s'
-endfunction
-
-" xo uses eslint and the output format is the same
-call ale#linter#Define('typescript', {
-\   'name': 'xo',
-\   'executable': function('ale_linters#typescript#xo#GetExecutable'),
-\   'command': function('ale_linters#typescript#xo#GetCommand'),
-\   'callback': 'ale#handlers#eslint#HandleJSON',
-\})
diff --git a/sources_non_forked/ale/ale_linters/verilog/iverilog.vim b/sources_non_forked/ale/ale_linters/verilog/iverilog.vim
deleted file mode 100644
index e081f33..0000000
--- a/sources_non_forked/ale/ale_linters/verilog/iverilog.vim
+++ /dev/null
@@ -1,43 +0,0 @@
-" Author: Masahiro H https://github.com/mshr-h
-" Description: iverilog for verilog files
-
-call ale#Set('verilog_iverilog_options', '')
-
-function! ale_linters#verilog#iverilog#GetCommand(buffer) abort
-    return 'iverilog -t null -Wall '
-    \   . ale#Var(a:buffer, 'verilog_iverilog_options')
-    \   . ' %t'
-endfunction
-
-function! ale_linters#verilog#iverilog#Handle(buffer, lines) abort
-    " Look for lines like the following.
-    "
-    " tb_me_top.v:37: warning: Instantiating module me_top with dangling input port 1 (rst_n) floating.
-    " tb_me_top.v:17: syntax error
-    " memory_single_port.v:2: syntax error
-    " tb_me_top.v:17: error: Invalid module instantiation
-    let l:pattern = '^[^:]\+:\(\d\+\): \(warning\|error\|syntax error\)\(: \(.\+\)\)\?'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        let l:line = l:match[1] + 0
-        let l:type = l:match[2] =~# 'error' ? 'E' : 'W'
-        let l:text = l:match[2] is# 'syntax error' ? 'syntax error' : l:match[4]
-
-        call add(l:output, {
-        \   'lnum': l:line,
-        \   'text': l:text,
-        \   'type': l:type,
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('verilog', {
-\   'name': 'iverilog',
-\   'output_stream': 'stderr',
-\   'executable': 'iverilog',
-\   'command': function('ale_linters#verilog#iverilog#GetCommand'),
-\   'callback': 'ale_linters#verilog#iverilog#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/verilog/verilator.vim b/sources_non_forked/ale/ale_linters/verilog/verilator.vim
deleted file mode 100644
index 029dd4c..0000000
--- a/sources_non_forked/ale/ale_linters/verilog/verilator.vim
+++ /dev/null
@@ -1,68 +0,0 @@
-" Author: Masahiro H https://github.com/mshr-h
-" Description: verilator for verilog files
-
-" Set this option to change Verilator lint options
-if !exists('g:ale_verilog_verilator_options')
-    let g:ale_verilog_verilator_options = ''
-endif
-
-function! ale_linters#verilog#verilator#GetCommand(buffer) abort
-    let l:filename = ale#util#Tempname() . '_verilator_linted.v'
-
-    " Create a special filename, so we can detect it in the handler.
-    call ale#command#ManageFile(a:buffer, l:filename)
-    let l:lines = getbufline(a:buffer, 1, '$')
-    call ale#util#Writefile(a:buffer, l:lines, l:filename)
-
-    return 'verilator --lint-only -Wall -Wno-DECLFILENAME '
-    \   . ale#Var(a:buffer, 'verilog_verilator_options') .' '
-    \   . ale#Escape(l:filename)
-endfunction
-
-function! ale_linters#verilog#verilator#Handle(buffer, lines) abort
-    " Look for lines like the following.
-    "
-    " %Error: addr_gen.v:3: syntax error, unexpected IDENTIFIER
-    " %Warning-WIDTH: addr_gen.v:26: Operator ASSIGNDLY expects 12 bits on the Assign RHS, but Assign RHS's CONST '20'h0' generates 20 bits.
-    " %Warning-UNUSED: test.v:3: Signal is not used: a
-    " %Warning-UNDRIVEN: test.v:3: Signal is not driven: clk
-    " %Warning-UNUSED: test.v:4: Signal is not used: dout
-    " %Warning-BLKSEQ: test.v:10: Blocking assignments (=) in sequential (flop or latch) block; suggest delayed assignments (<=).
-    " Since version 4.032 (04/2020) verilator linter messages also contain the column number,
-    " and look like:
-    " %Error: /tmp/test.sv:3:1: syntax error, unexpected endmodule, expecting ';'
-    "
-    " to stay compatible with old versions of the tool, the column number is
-    " optional in the researched pattern
-    let l:pattern = '^%\(Warning\|Error\)[^:]*:\([^:]\+\):\(\d\+\):\(\d\+\)\?:\? \(.\+\)$'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        let l:item = {
-        \   'lnum': str2nr(l:match[3]),
-        \   'text': l:match[5],
-        \   'type': l:match[1] is# 'Error' ? 'E' : 'W',
-        \}
-
-        if !empty(l:match[4])
-            let l:item.col = str2nr(l:match[4])
-        endif
-
-        let l:file = l:match[2]
-
-        if l:file =~# '_verilator_linted.v'
-            call add(l:output, l:item)
-        endif
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('verilog', {
-\   'name': 'verilator',
-\   'output_stream': 'stderr',
-\   'executable': 'verilator',
-\   'command': function('ale_linters#verilog#verilator#GetCommand'),
-\   'callback': 'ale_linters#verilog#verilator#Handle',
-\   'read_buffer': 0,
-\})
diff --git a/sources_non_forked/ale/ale_linters/verilog/vlog.vim b/sources_non_forked/ale/ale_linters/verilog/vlog.vim
deleted file mode 100644
index 951e203..0000000
--- a/sources_non_forked/ale/ale_linters/verilog/vlog.vim
+++ /dev/null
@@ -1,50 +0,0 @@
-" Author:      John Gentile <johncgentile17@gmail.com>
-" Description: Adds support for Mentor Graphics Questa/ModelSim `vlog` Verilog compiler/checker
-
-call ale#Set('verilog_vlog_executable', 'vlog')
-" See `$ vlog -h` for more options
-call ale#Set('verilog_vlog_options', '-quiet -lint')
-
-function! ale_linters#verilog#vlog#GetCommand(buffer) abort
-    return '%e ' . ale#Pad(ale#Var(a:buffer, 'verilog_vlog_options')) . ' %t'
-endfunction
-
-function! ale_linters#verilog#vlog#Handle(buffer, lines) abort
-    "Matches patterns like the following:
-    "** Warning: add.v(7): (vlog-2623) Undefined variable: C.
-    "** Error: file.v(1): (vlog-13294) Identifier must be declared with a port mode: C.
-    let l:pattern = '^**\s\(\w*\):[a-zA-Z0-9\-\.\_\/ ]\+(\(\d\+\)):\s\+\(.*\)'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        call add(l:output, {
-        \   'lnum': l:match[2] + 0,
-        \   'type': l:match[1] is? 'Error' ? 'E' : 'W',
-        \   'text': l:match[3],
-        \})
-    endfor
-
-    "Matches patterns like the following:
-    "** Warning: (vlog-2623) add.v(7): Undefined variable: C.
-    "** Error: (vlog-13294) file.v(1): Identifier must be declared with a port mode: C.
-    " let l:pattern = '^**\s\(\w*\):[a-zA-Z0-9\-\.\_\/ ]\+(\(\d\+\)):\s\+\(.*\)'
-    let l:pattern = '^**\s\(\w*\):\s\([^)]*)\)[a-zA-Z0-9\-\.\_\/ ]\+(\(\d\+\)):\s\+\(.*\)'
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        call add(l:output, {
-        \   'lnum': l:match[3] + 0,
-        \   'type': l:match[1] is? 'Error' ? 'E' : 'W',
-        \   'text': l:match[2] . ' ' . l:match[4],
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('verilog', {
-\   'name': 'vlog',
-\   'output_stream': 'stdout',
-\   'executable': {b -> ale#Var(b, 'verilog_vlog_executable')},
-\   'command': function('ale_linters#verilog#vlog#GetCommand'),
-\   'callback': 'ale_linters#verilog#vlog#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/verilog/xvlog.vim b/sources_non_forked/ale/ale_linters/verilog/xvlog.vim
deleted file mode 100644
index 98b5aae..0000000
--- a/sources_non_forked/ale/ale_linters/verilog/xvlog.vim
+++ /dev/null
@@ -1,35 +0,0 @@
-" Author:      John Gentile <johncgentile17@gmail.com>
-" Description: Adds support for Xilinx Vivado `xvlog` Verilog compiler/checker
-
-call ale#Set('verilog_xvlog_executable', 'xvlog')
-call ale#Set('verilog_xvlog_options', '')
-
-function! ale_linters#verilog#xvlog#GetCommand(buffer) abort
-    return '%e ' . ale#Pad(ale#Var(a:buffer, 'verilog_xvlog_options')) . ' %t'
-endfunction
-
-function! ale_linters#verilog#xvlog#Handle(buffer, lines) abort
-    "Matches patterns like the following:
-    " ERROR: [VRFC 10-1412] syntax error near output [/path/to/file.v:5]
-    let l:pattern = '^ERROR:\s\+\(\[.*\)\[.*:\([0-9]\+\)\]'
-    let l:output = []
-
-    " NOTE: `xvlog` only prints 'INFO' and 'ERROR' messages
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        call add(l:output, {
-        \   'lnum': l:match[2] + 0,
-        \   'type': 'E',
-        \   'text': l:match[1],
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('verilog', {
-\   'name': 'xvlog',
-\   'output_stream': 'stdout',
-\   'executable': {b -> ale#Var(b, 'verilog_xvlog_executable')},
-\   'command': function('ale_linters#verilog#xvlog#GetCommand'),
-\   'callback': 'ale_linters#verilog#xvlog#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/vhdl/ghdl.vim b/sources_non_forked/ale/ale_linters/vhdl/ghdl.vim
deleted file mode 100644
index b09e620..0000000
--- a/sources_non_forked/ale/ale_linters/vhdl/ghdl.vim
+++ /dev/null
@@ -1,37 +0,0 @@
-" Author: John Gentile <johncgentile17@gmail.com>
-" Description: Adds support for `ghdl` VHDL compiler/checker
-
-call ale#Set('vhdl_ghdl_executable', 'ghdl')
-" Compile w/VHDL-2008 support
-call ale#Set('vhdl_ghdl_options', '--std=08')
-
-function! ale_linters#vhdl#ghdl#GetCommand(buffer) abort
-    return '%e -s ' . ale#Pad(ale#Var(a:buffer, 'vhdl_ghdl_options')) . ' %t'
-endfunction
-
-function! ale_linters#vhdl#ghdl#Handle(buffer, lines) abort
-    " Look for 'error' lines like the following:
-    " dff_en.vhd:41:5:error: 'begin' is expected instead of 'if'
-    " /path/to/file.vhdl:12:8: no declaration for "i0"
-    let l:pattern = '^[a-zA-Z0-9\-\.\_\/ ]\+:\(\d\+\):\(\d\+\):\(.*\)'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        call add(l:output, {
-        \   'lnum': l:match[1] + 0,
-        \   'col' : l:match[2] + 0,
-        \   'text': l:match[3],
-        \   'type': 'E',
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('vhdl', {
-\   'name': 'ghdl',
-\   'output_stream': 'stderr',
-\   'executable': {b -> ale#Var(b, 'vhdl_ghdl_executable')},
-\   'command': function('ale_linters#vhdl#ghdl#GetCommand'),
-\   'callback': 'ale_linters#vhdl#ghdl#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/vhdl/vcom.vim b/sources_non_forked/ale/ale_linters/vhdl/vcom.vim
deleted file mode 100644
index 1914fd3..0000000
--- a/sources_non_forked/ale/ale_linters/vhdl/vcom.vim
+++ /dev/null
@@ -1,38 +0,0 @@
-" Author:      John Gentile <johncgentile17@gmail.com>
-" Description: Adds support for Mentor Graphics Questa/ModelSim `vcom` VHDL compiler/checker
-
-call ale#Set('vhdl_vcom_executable', 'vcom')
-" Use VHDL-2008. See `$ vcom -h` for more options
-call ale#Set('vhdl_vcom_options', '-2008 -quiet -lint')
-
-function! ale_linters#vhdl#vcom#GetCommand(buffer) abort
-    return '%e ' . ale#Pad(ale#Var(a:buffer, 'vhdl_vcom_options')) . ' %t'
-endfunction
-
-function! ale_linters#vhdl#vcom#Handle(buffer, lines) abort
-    "Matches patterns like the following:
-    "** Warning: ../path/to/file.vhd(218): (vcom-1236) Shared variables must be of a protected type.
-    "** Error: tb_file.vhd(73): (vcom-1136) Unknown identifier "aresetn".
-    "** Error: tb_file.vhd(73): Bad resolution function (STD_LOGIC) for type (error).
-    "** Error: tb_file.vhd(73): near ":": (vcom-1576) expecting ';' or ')'.
-    let l:pattern = '^**\s\(\w*\):[a-zA-Z0-9\-\.\_\/ ]\+(\(\d\+\)):\s\+\(.*\)'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        call add(l:output, {
-        \   'lnum': l:match[2] + 0,
-        \   'type': l:match[1] is? 'Error' ? 'E' : 'W',
-        \   'text': l:match[3],
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('vhdl', {
-\   'name': 'vcom',
-\   'output_stream': 'stdout',
-\   'executable': {b -> ale#Var(b, 'vhdl_vcom_executable')},
-\   'command': function('ale_linters#vhdl#vcom#GetCommand'),
-\   'callback': 'ale_linters#vhdl#vcom#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/vhdl/xvhdl.vim b/sources_non_forked/ale/ale_linters/vhdl/xvhdl.vim
deleted file mode 100644
index 8010ff1..0000000
--- a/sources_non_forked/ale/ale_linters/vhdl/xvhdl.vim
+++ /dev/null
@@ -1,37 +0,0 @@
-" Author:      John Gentile <johncgentile17@gmail.com>
-" Description: Adds support for Xilinx Vivado `xvhdl` VHDL compiler/checker
-
-call ale#Set('vhdl_xvhdl_executable', 'xvhdl')
-" Use VHDL-2008. See `$ xvhdl -h` for more options
-call ale#Set('vhdl_xvhdl_options', '--2008')
-
-function! ale_linters#vhdl#xvhdl#GetCommand(buffer) abort
-    return '%e ' . ale#Pad(ale#Var(a:buffer, 'vhdl_xvhdl_options')) . ' %t'
-endfunction
-
-function! ale_linters#vhdl#xvhdl#Handle(buffer, lines) abort
-    "Matches patterns like the following:
-    " ERROR: [VRFC 10-91] aresetn is not declared [/path/to/file.vhd:17]
-    " ERROR: [VRFC 10-91] m_axis_tx_tdata is not declared [/home/user/tx_data.vhd:128]
-    let l:pattern = '^ERROR:\s\+\(\[.*\)\[.*:\([0-9]\+\)\]'
-    let l:output = []
-
-    " NOTE: `xvhdl` only prints 'INFO' and 'ERROR' messages
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        call add(l:output, {
-        \   'lnum': l:match[2] + 0,
-        \   'type': 'E',
-        \   'text': l:match[1],
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('vhdl', {
-\   'name': 'xvhdl',
-\   'output_stream': 'stdout',
-\   'executable': {b -> ale#Var(b, 'vhdl_xvhdl_executable')},
-\   'command': function('ale_linters#vhdl#xvhdl#GetCommand'),
-\   'callback': 'ale_linters#vhdl#xvhdl#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/vim/ale_custom_linting_rules.vim b/sources_non_forked/ale/ale_linters/vim/ale_custom_linting_rules.vim
deleted file mode 100644
index 822eb30..0000000
--- a/sources_non_forked/ale/ale_linters/vim/ale_custom_linting_rules.vim
+++ /dev/null
@@ -1,65 +0,0 @@
-" Author: w0rp <devw0rp@gmail.com>
-" Description: A linter for checking ALE project code itself.
-
-function! ale_linters#vim#ale_custom_linting_rules#GetExecutable(buffer) abort
-    let l:filename = expand('#' . a:buffer . ':p')
-    let l:dir_list = []
-
-    for l:dir in split(&runtimepath, ',')
-        if l:filename[:len(l:dir) - 1] is# l:dir
-            call add(l:dir_list, l:dir)
-        endif
-    endfor
-
-    return !empty(l:dir_list)
-    \   ? findfile('test/script/custom-linting-rules', join(l:dir_list, ','))
-    \   : ''
-endfunction
-
-function! s:GetALEProjectDir(buffer) abort
-    let l:executable = ale_linters#vim#ale_custom_linting_rules#GetExecutable(a:buffer)
-
-    return ale#path#Dirname(ale#path#Dirname(ale#path#Dirname(l:executable)))
-endfunction
-
-function! ale_linters#vim#ale_custom_linting_rules#GetCommand(buffer) abort
-    let l:dir = s:GetALEProjectDir(a:buffer)
-
-    let l:temp_dir = ale#command#CreateDirectory(a:buffer)
-    let l:temp_file = l:temp_dir . '/example.vim'
-
-    let l:lines = getbufline(a:buffer, 1, '$')
-    call ale#util#Writefile(a:buffer, l:lines, l:temp_file)
-
-    return ale#path#CdString(l:dir) . '%e ' . ale#Escape(l:temp_dir)
-endfunction
-
-function! ale_linters#vim#ale_custom_linting_rules#Handle(buffer, lines) abort
-    let l:dir = s:GetALEProjectDir(a:buffer)
-    let l:output = []
-    let l:pattern = '\v^([a-zA-Z]?:?[^:]+):(\d+) (.+)$'
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        " Ignore trailing whitespace errors if we've turned them off.
-        if !ale#Var(a:buffer, 'warn_about_trailing_whitespace')
-        \&& l:match[3] is# 'Trailing whitespace'
-            continue
-        endif
-
-        call add(l:output, {
-        \   'lnum': l:match[2],
-        \   'text': l:match[3],
-        \   'type': 'W',
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('vim', {
-\   'name': 'ale_custom_linting_rules',
-\   'executable': function('ale_linters#vim#ale_custom_linting_rules#GetExecutable'),
-\   'command': function('ale_linters#vim#ale_custom_linting_rules#GetCommand'),
-\   'callback': 'ale_linters#vim#ale_custom_linting_rules#Handle',
-\   'read_buffer': 0,
-\})
diff --git a/sources_non_forked/ale/ale_linters/vim/vimls.vim b/sources_non_forked/ale/ale_linters/vim/vimls.vim
deleted file mode 100644
index 26014d6..0000000
--- a/sources_non_forked/ale/ale_linters/vim/vimls.vim
+++ /dev/null
@@ -1,61 +0,0 @@
-" Author: Jeffrey Lau - https://github.com/zoonfafer
-" Description: Vim Language Server integration for ALE
-
-call ale#Set('vim_vimls_executable', 'vim-language-server')
-call ale#Set('vim_vimls_use_global', get(g:, 'ale_use_global_executables', 0))
-call ale#Set('vim_vimls_config', {})
-
-function! ale_linters#vim#vimls#GetProjectRoot(buffer) abort
-    let l:trigger_file_candidates = [
-    \   '.vimrc',
-    \   'init.vim',
-    \]
-
-    for l:candidate in l:trigger_file_candidates
-        let l:trigger_file = fnamemodify(bufname(a:buffer), ':t')
-
-        if l:trigger_file is# l:candidate
-            return fnamemodify(
-            \   bufname(a:buffer),
-            \   ':h',
-            \)
-        endif
-    endfor
-
-    let l:trigger_dir_candidates = [
-    \   'autoload',
-    \   'plugin',
-    \   '.git',
-    \]
-
-    let l:path_upwards = ale#path#Upwards(fnamemodify(bufname(a:buffer), ':p:h'))
-
-    for l:path in l:path_upwards
-        for l:candidate in l:trigger_dir_candidates
-            let l:trigger_dir = ale#path#Simplify(
-            \   l:path . '/' . l:candidate,
-            \)
-
-            if isdirectory(l:trigger_dir)
-                return fnamemodify(
-                \   l:trigger_dir,
-                \   ':p:h:h',
-                \)
-            endif
-        endfor
-    endfor
-
-    return ''
-endfunction
-
-call ale#linter#Define('vim', {
-\   'name': 'vimls',
-\   'lsp': 'stdio',
-\   'lsp_config': {b -> ale#Var(b, 'vim_vimls_config')},
-\   'executable': {b -> ale#node#FindExecutable(b, 'vim_vimls', [
-\       'node_modules/.bin/vim-language-server',
-\   ])},
-\   'command': '%e --stdio',
-\   'language': 'vim',
-\   'project_root': function('ale_linters#vim#vimls#GetProjectRoot'),
-\})
diff --git a/sources_non_forked/ale/ale_linters/vim/vint.vim b/sources_non_forked/ale/ale_linters/vim/vint.vim
deleted file mode 100644
index 65e1912..0000000
--- a/sources_non_forked/ale/ale_linters/vim/vint.vim
+++ /dev/null
@@ -1,60 +0,0 @@
-" Author: w0rp <devw0rp@gmail.com>, KabbAmine <amine.kabb@gmail.com>
-" Description: This file adds support for checking Vim code with Vint.
-
-" This flag can be used to change enable/disable style issues.
-call ale#Set('vim_vint_show_style_issues', 1)
-call ale#Set('vim_vint_executable', 'vint')
-let s:enable_neovim = has('nvim') ? ' --enable-neovim' : ''
-let s:format = '-f "{file_path}:{line_number}:{column_number}: {severity}: {description} (see {reference})"'
-
-function! ale_linters#vim#vint#GetCommand(buffer, version) abort
-    let l:can_use_no_color_flag = empty(a:version)
-    \   || ale#semver#GTE(a:version, [0, 3, 7])
-
-    let l:warning_flag = ale#Var(a:buffer, 'vim_vint_show_style_issues') ? '-s' : '-w'
-
-    return '%e'
-    \   . ' ' . l:warning_flag
-    \   . (l:can_use_no_color_flag ? ' --no-color' : '')
-    \   . s:enable_neovim
-    \   . ' ' . s:format
-    \   . ' %t'
-endfunction
-
-let s:word_regex_list = [
-\   '\v^Undefined variable: ([^ ]+)',
-\   '\v^Make the scope explicit like ...([^ ]+). ',
-\   '\v^.*start with a capital or contain a colon: ([^ ]+)',
-\   '\v.*instead of .(\=[=~]).',
-\]
-
-function! ale_linters#vim#vint#Handle(buffer, lines) abort
-    let l:loclist = ale#handlers#gcc#HandleGCCFormat(a:buffer, a:lines)
-
-    for l:item in l:loclist
-        let l:match = []
-
-        for l:regex in s:word_regex_list
-            let l:match = matchlist(l:item.text, l:regex)
-
-            if !empty(l:match)
-                let l:item.end_col = l:item.col + len(l:match[1]) - 1
-                break
-            endif
-        endfor
-    endfor
-
-    return l:loclist
-endfunction
-
-call ale#linter#Define('vim', {
-\   'name': 'vint',
-\   'executable': {buffer -> ale#Var(buffer, 'vim_vint_executable')},
-\   'command': {buffer -> ale#semver#RunWithVersionCheck(
-\       buffer,
-\       ale#Var(buffer, 'vim_vint_executable'),
-\       '%e --version',
-\       function('ale_linters#vim#vint#GetCommand'),
-\   )},
-\   'callback': 'ale_linters#vim#vint#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/vue/vls.vim b/sources_non_forked/ale/ale_linters/vue/vls.vim
deleted file mode 100644
index ac451f3..0000000
--- a/sources_non_forked/ale/ale_linters/vue/vls.vim
+++ /dev/null
@@ -1,22 +0,0 @@
-" Author: Alexander Olofsson <alexander.olofsson@liu.se>
-" Description: Vue vls Language Server integration for ALE
-
-call ale#Set('vue_vls_executable', 'vls')
-call ale#Set('vue_vls_use_global', get(g:, 'ale_use_global_executables', 0))
-
-function! ale_linters#vue#vls#GetProjectRoot(buffer) abort
-    let l:package_path = ale#path#FindNearestFile(a:buffer, 'package.json')
-
-    return !empty(l:package_path) ? fnamemodify(l:package_path, ':h') : ''
-endfunction
-
-call ale#linter#Define('vue', {
-\   'name': 'vls',
-\   'lsp': 'stdio',
-\   'executable': {b -> ale#node#FindExecutable(b, 'vue_vls', [
-\       'node_modules/.bin/vls',
-\   ])},
-\   'command': '%e --stdio',
-\   'language': 'vue',
-\   'project_root': function('ale_linters#vue#vls#GetProjectRoot'),
-\})
diff --git a/sources_non_forked/ale/ale_linters/xhtml/alex.vim b/sources_non_forked/ale/ale_linters/xhtml/alex.vim
deleted file mode 100644
index 97f3b59..0000000
--- a/sources_non_forked/ale/ale_linters/xhtml/alex.vim
+++ /dev/null
@@ -1,4 +0,0 @@
-" Author: Johannes Wienke <languitar@semipol.de>
-" Description: alex for XHTML files
-
-call ale#handlers#alex#DefineLinter('xhtml', '--text')
diff --git a/sources_non_forked/ale/ale_linters/xhtml/proselint.vim b/sources_non_forked/ale/ale_linters/xhtml/proselint.vim
deleted file mode 100644
index dfad921..0000000
--- a/sources_non_forked/ale/ale_linters/xhtml/proselint.vim
+++ /dev/null
@@ -1,9 +0,0 @@
-" Author: Daniel M. Capella https://github.com/polyzen
-" Description: proselint for XHTML files
-
-call ale#linter#Define('xhtml', {
-\   'name': 'proselint',
-\   'executable': 'proselint',
-\   'command': 'proselint %t',
-\   'callback': 'ale#handlers#unix#HandleAsWarning',
-\})
diff --git a/sources_non_forked/ale/ale_linters/xhtml/writegood.vim b/sources_non_forked/ale/ale_linters/xhtml/writegood.vim
deleted file mode 100644
index 1fcba18..0000000
--- a/sources_non_forked/ale/ale_linters/xhtml/writegood.vim
+++ /dev/null
@@ -1,4 +0,0 @@
-" Author: Sumner Evans <sumner.evans98@gmail.com>
-" Description: write-good for XHTML files
-
-call ale#handlers#writegood#DefineLinter('xhtml')
diff --git a/sources_non_forked/ale/ale_linters/xml/xmllint.vim b/sources_non_forked/ale/ale_linters/xml/xmllint.vim
deleted file mode 100644
index 553d088..0000000
--- a/sources_non_forked/ale/ale_linters/xml/xmllint.vim
+++ /dev/null
@@ -1,65 +0,0 @@
-" Author: q12321q <q12321q@gmail.com>
-" Description: This file adds support for checking XML code with xmllint.
-
-" CLI options
-let g:ale_xml_xmllint_executable = get(g:, 'ale_xml_xmllint_executable', 'xmllint')
-let g:ale_xml_xmllint_options = get(g:, 'ale_xml_xmllint_options', '')
-
-function! ale_linters#xml#xmllint#GetCommand(buffer) abort
-    return '%e'
-    \   . ale#Pad(ale#Var(a:buffer, 'xml_xmllint_options'))
-    \   . ' --noout -'
-endfunction
-
-function! ale_linters#xml#xmllint#Handle(buffer, lines) abort
-    " Matches patterns lines like the following:
-    " file/path:123: error level : error message
-    let l:pattern_message = '\v^([^:]+):(\d+):\s*(([^:]+)\s*:\s+.*)$'
-
-    " parse column token line like that:
-    " file/path:123: parser error : Opening and ending tag mismatch: foo line 1 and bar
-    " </bar>
-    "       ^
-    let l:pattern_column_token = '\v^\s*\^$'
-
-    let l:output = []
-
-    for l:line in a:lines
-        " Parse error/warning lines
-        let l:match_message = matchlist(l:line, l:pattern_message)
-
-        if !empty(l:match_message)
-            let l:line = l:match_message[2] + 0
-            let l:type = l:match_message[4] =~? 'warning' ? 'W' : 'E'
-            let l:text = l:match_message[3]
-
-            call add(l:output, {
-            \   'lnum': l:line,
-            \   'text': l:text,
-            \   'type': l:type,
-            \})
-
-            continue
-        endif
-
-        " Parse column position
-        let l:match_column_token = matchlist(l:line, l:pattern_column_token)
-
-        if !empty(l:output) && !empty(l:match_column_token)
-            let l:previous = l:output[len(l:output) - 1]
-            let l:previous['col'] = len(l:match_column_token[0])
-
-            continue
-        endif
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('xml', {
-\   'name': 'xmllint',
-\   'output_stream': 'stderr',
-\   'executable': {b -> ale#Var(b, 'xml_xmllint_executable')},
-\   'command': function('ale_linters#xml#xmllint#GetCommand'),
-\   'callback': 'ale_linters#xml#xmllint#Handle',
-\ })
diff --git a/sources_non_forked/ale/ale_linters/yaml/swaglint.vim b/sources_non_forked/ale/ale_linters/yaml/swaglint.vim
deleted file mode 100644
index 1f140e3..0000000
--- a/sources_non_forked/ale/ale_linters/yaml/swaglint.vim
+++ /dev/null
@@ -1,40 +0,0 @@
-" Author: Matthew Turland <https://github.com/elazar>
-" Description: This file adds support for linting Swagger / OpenAPI documents using swaglint
-
-call ale#Set('yaml_swaglint_executable', 'swaglint')
-call ale#Set('yaml_swaglint_use_global', get(g:, 'ale_use_global_executables', 0))
-
-function! ale_linters#yaml#swaglint#Handle(buffer, lines) abort
-    let l:pattern = ': \([^\s]\+\) @ \(\d\+\):\(\d\+\) - \(.\+\)$'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        let l:obj = {
-        \   'type': l:match[1] is# 'error' ? 'E' : 'W',
-        \   'lnum': l:match[2] + 0,
-        \   'col': l:match[3] + 0,
-        \   'text': l:match[4],
-        \}
-
-        " Parse the code if it's there.
-        let l:code_match = matchlist(l:obj.text, '\v^(.+) \(([^ (]+)\)$')
-
-        if !empty(l:code_match)
-            let l:obj.text = l:code_match[1]
-            let l:obj.code = l:code_match[2]
-        endif
-
-        call add(l:output, l:obj)
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('yaml', {
-\   'name': 'swaglint',
-\   'executable': {b -> ale#node#FindExecutable(b, 'yaml_swaglint', [
-\       'node_modules/.bin/swaglint',
-\   ])},
-\   'command': '%e -r compact --stdin',
-\   'callback': 'ale_linters#yaml#swaglint#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/yaml/yamllint.vim b/sources_non_forked/ale/ale_linters/yaml/yamllint.vim
deleted file mode 100644
index bedb7bf..0000000
--- a/sources_non_forked/ale/ale_linters/yaml/yamllint.vim
+++ /dev/null
@@ -1,50 +0,0 @@
-" Author: KabbAmine <amine.kabb@gmail.com>
-
-call ale#Set('yaml_yamllint_executable', 'yamllint')
-call ale#Set('yaml_yamllint_options', '')
-
-function! ale_linters#yaml#yamllint#GetCommand(buffer) abort
-    return '%e' . ale#Pad(ale#Var(a:buffer, 'yaml_yamllint_options'))
-    \   . ' -f parsable %t'
-endfunction
-
-function! ale_linters#yaml#yamllint#Handle(buffer, lines) abort
-    " Matches patterns line the following:
-    " something.yaml:1:1: [warning] missing document start "---" (document-start)
-    " something.yml:2:1: [error] syntax error: expected the node content, but found '<stream end>'
-    let l:pattern = '\v^.*:(\d+):(\d+): \[(error|warning)\] (.+)$'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        let l:item = {
-        \   'lnum': l:match[1] + 0,
-        \   'col': l:match[2] + 0,
-        \   'text': l:match[4],
-        \   'type': l:match[3] is# 'error' ? 'E' : 'W',
-        \}
-
-        let l:code_match = matchlist(l:item.text, '\v^(.+) \(([^)]+)\)$')
-
-        if !empty(l:code_match)
-            if l:code_match[2] is# 'trailing-spaces'
-            \&& !ale#Var(a:buffer, 'warn_about_trailing_whitespace')
-                " Skip warnings for trailing whitespace if the option is off.
-                continue
-            endif
-
-            let l:item.text = l:code_match[1]
-            let l:item.code = l:code_match[2]
-        endif
-
-        call add(l:output, l:item)
-    endfor
-
-    return l:output
-endfunction
-
-call ale#linter#Define('yaml', {
-\   'name': 'yamllint',
-\   'executable': {b -> ale#Var(b, 'yaml_yamllint_executable')},
-\   'command': function('ale_linters#yaml#yamllint#GetCommand'),
-\   'callback': 'ale_linters#yaml#yamllint#Handle',
-\})
diff --git a/sources_non_forked/ale/ale_linters/yang/yang_lsp.vim b/sources_non_forked/ale/ale_linters/yang/yang_lsp.vim
deleted file mode 100644
index 81fcaa0..0000000
--- a/sources_non_forked/ale/ale_linters/yang/yang_lsp.vim
+++ /dev/null
@@ -1,15 +0,0 @@
-call ale#Set('yang_lsp_executable', 'yang-language-server')
-
-function! ale_linters#yang#yang_lsp#GetProjectRoot(buffer) abort
-    let l:project_root = ale#path#FindNearestFile(a:buffer, 'yang.settings')
-
-    return !empty(l:project_root) ? fnamemodify(l:project_root, ':h') : ''
-endfunction
-
-call ale#linter#Define('yang', {
-\   'name': 'yang_lsp',
-\   'lsp': 'stdio',
-\   'executable': {b -> ale#Var(b, 'yang_lsp_executable')},
-\   'project_root': function('ale_linters#yang#yang_lsp#GetProjectRoot'),
-\   'command': '%e',
-\})
diff --git a/sources_non_forked/ale/autoload/ale.vim b/sources_non_forked/ale/autoload/ale.vim
deleted file mode 100644
index 6251b47..0000000
--- a/sources_non_forked/ale/autoload/ale.vim
+++ /dev/null
@@ -1,268 +0,0 @@
-" Author: w0rp <devw0rp@gmail.com>, David Alexander <opensource@thelonelyghost.com>
-" Description: Primary code path for the plugin
-"   Manages execution of linters when requested by autocommands
-
-" Strings used for severity in the echoed message
-let g:ale_echo_msg_error_str = get(g:, 'ale_echo_msg_error_str', 'Error')
-let g:ale_echo_msg_info_str = get(g:, 'ale_echo_msg_info_str', 'Info')
-let g:ale_echo_msg_log_str = get(g:, 'ale_echo_msg_log_str', 'Log')
-let g:ale_echo_msg_warning_str = get(g:, 'ale_echo_msg_warning_str', 'Warning')
-" Ignoring linters, for disabling some, or ignoring LSP diagnostics.
-let g:ale_linters_ignore = get(g:, 'ale_linters_ignore', {})
-let g:ale_disable_lsp = get(g:, 'ale_disable_lsp', 0)
-
-" LSP window/showMessage format
-let g:ale_lsp_show_message_format = get(g:, 'ale_lsp_show_message_format', '%severity%:%linter%: %s')
-" Valid values mimic LSP definitions (error, warning and information; log is
-" never shown)
-let g:ale_lsp_show_message_severity = get(g:, 'ale_lsp_show_message_severity', 'error')
-
-let s:lint_timer = -1
-let s:getcmdwintype_exists = exists('*getcmdwintype')
-
-" Return 1 if a file is too large for ALE to handle.
-function! ale#FileTooLarge(buffer) abort
-    let l:max = getbufvar(a:buffer, 'ale_maximum_file_size', get(g:, 'ale_maximum_file_size', 0))
-
-    return l:max > 0 ? (line2byte(line('$') + 1) > l:max) : 0
-endfunction
-
-" A function for checking various conditions whereby ALE just shouldn't
-" attempt to do anything, say if particular buffer types are open in Vim.
-function! ale#ShouldDoNothing(buffer) abort
-    " The checks are split into separate if statements to make it possible to
-    " profile each check individually with Vim's profiling tools.
-    "
-    " Do nothing if ALE is disabled.
-    if !getbufvar(a:buffer, 'ale_enabled', get(g:, 'ale_enabled', 0))
-        return 1
-    endif
-
-    " Don't perform any checks when newer NeoVim versions are exiting.
-    if get(v:, 'exiting', v:null) isnot v:null
-        return 1
-    endif
-
-    let l:filetype = getbufvar(a:buffer, '&filetype')
-
-    " Do nothing when there's no filetype.
-    if l:filetype is# ''
-        return 1
-    endif
-
-    " Do nothing for diff buffers.
-    if getbufvar(a:buffer, '&diff')
-        return 1
-    endif
-
-    " Do nothing for blacklisted files.
-    if index(get(g:, 'ale_filetype_blacklist', []), l:filetype) >= 0
-        return 1
-    endif
-
-    " Do nothing if running from command mode.
-    if s:getcmdwintype_exists && !empty(getcmdwintype())
-        return 1
-    endif
-
-    let l:filename = fnamemodify(bufname(a:buffer), ':t')
-
-    " Do nothing for directories.
-    if l:filename is# '.'
-        return 1
-    endif
-
-    " Don't start linting and so on when an operator is pending.
-    if ale#util#Mode(1) is# 'no'
-        return 1
-    endif
-
-    " Do nothing if running in the sandbox.
-    if ale#util#InSandbox()
-        return 1
-    endif
-
-    " Do nothing if the file is too large.
-    if ale#FileTooLarge(a:buffer)
-        return 1
-    endif
-
-    " Do nothing from CtrlP buffers with CtrlP-funky.
-    if exists(':CtrlPFunky') is 2
-    \&& getbufvar(a:buffer, '&l:statusline') =~# 'CtrlPMode.*funky'
-        return 1
-    endif
-
-    return 0
-endfunction
-
-function! s:Lint(buffer, should_lint_file, timer_id) abort
-    " Use the filetype from the buffer
-    let l:filetype = getbufvar(a:buffer, '&filetype')
-    let l:linters = ale#linter#Get(l:filetype)
-
-    " Apply ignore lists for linters only if needed.
-    let l:ignore_config = ale#Var(a:buffer, 'linters_ignore')
-    let l:disable_lsp = ale#Var(a:buffer, 'disable_lsp')
-    let l:linters = !empty(l:ignore_config) || l:disable_lsp
-    \   ? ale#engine#ignore#Exclude(l:filetype, l:linters, l:ignore_config, l:disable_lsp)
-    \   : l:linters
-
-    " Tell other sources that they can start checking the buffer now.
-    let g:ale_want_results_buffer = a:buffer
-    silent doautocmd <nomodeline> User ALEWantResults
-    unlet! g:ale_want_results_buffer
-
-    " Don't set up buffer data and so on if there are no linters to run.
-    if !has_key(g:ale_buffer_info, a:buffer) && empty(l:linters)
-        return
-    endif
-
-    " Clear lint_file linters, or only run them if the file exists.
-    let l:lint_file = empty(l:linters)
-    \   || (a:should_lint_file && filereadable(expand('#' . a:buffer . ':p')))
-
-    call ale#engine#RunLinters(a:buffer, l:linters, l:lint_file)
-endfunction
-
-" (delay, [linting_flag, buffer_number])
-function! ale#Queue(delay, ...) abort
-    if a:0 > 2
-        throw 'too many arguments!'
-    endif
-
-    let l:buffer = get(a:000, 1, v:null)
-
-    if l:buffer is v:null
-        let l:buffer = bufnr('')
-    endif
-
-    if type(l:buffer) isnot v:t_number
-        throw 'buffer_number must be a Number'
-    endif
-
-    if ale#ShouldDoNothing(l:buffer)
-        return
-    endif
-
-    " Default linting_flag to ''
-    let l:should_lint_file = get(a:000, 0) is# 'lint_file'
-
-    if s:lint_timer != -1
-        call timer_stop(s:lint_timer)
-        let s:lint_timer = -1
-    endif
-
-    if a:delay > 0
-        let s:lint_timer = timer_start(
-        \   a:delay,
-        \   function('s:Lint', [l:buffer, l:should_lint_file])
-        \)
-    else
-        call s:Lint(l:buffer, l:should_lint_file, 0)
-    endif
-endfunction
-
-let s:current_ale_version = [2, 7, 0]
-
-" A function used to check for ALE features in files outside of the project.
-function! ale#Has(feature) abort
-    let l:match = matchlist(a:feature, '\c\v^ale-(\d+)\.(\d+)(\.(\d+))?$')
-
-    if !empty(l:match)
-        let l:version = [l:match[1] + 0, l:match[2] + 0, l:match[4] + 0]
-
-        return ale#semver#GTE(s:current_ale_version, l:version)
-    endif
-
-    return 0
-endfunction
-
-" Given a buffer number and a variable name, look for that variable in the
-" buffer scope, then in global scope. If the name does not exist in the global
-" scope, an exception will be thrown.
-"
-" Every variable name will be prefixed with 'ale_'.
-function! ale#Var(buffer, variable_name) abort
-    let l:full_name = 'ale_' . a:variable_name
-    let l:vars = getbufvar(str2nr(a:buffer), '', {})
-
-    return get(l:vars, l:full_name, g:[l:full_name])
-endfunction
-
-" Initialize a variable with a default value, if it isn't already set.
-"
-" Every variable name will be prefixed with 'ale_'.
-function! ale#Set(variable_name, default) abort
-    let l:full_name = 'ale_' . a:variable_name
-
-    if !has_key(g:, l:full_name)
-        let g:[l:full_name] = a:default
-    endif
-endfunction
-
-" Given a string for adding to a command, return the string padded with a
-" space on the left if it is not empty. Otherwise return an empty string.
-"
-" This can be used for making command strings cleaner and easier to test.
-function! ale#Pad(string) abort
-    return !empty(a:string) ? ' ' . a:string : ''
-endfunction
-
-" Given a environment variable name and a value, produce part of a command for
-" setting an environment variable before running a command. The syntax will be
-" valid for cmd on Windows, or most shells on Unix.
-function! ale#Env(variable_name, value) abort
-    if has('win32')
-        return 'set ' . a:variable_name . '=' . ale#Escape(a:value) . ' && '
-    endif
-
-    return a:variable_name . '=' . ale#Escape(a:value) . ' '
-endfunction
-
-" Escape a string suitably for each platform.
-" shellescape does not work on Windows.
-function! ale#Escape(str) abort
-    if fnamemodify(&shell, ':t') is? 'cmd.exe'
-        " If the string contains spaces, it will be surrounded by quotes.
-        " Otherwise, special characters will be escaped with carets (^).
-        return substitute(
-        \   a:str =~# ' '
-        \       ?  '"' .  substitute(a:str, '"', '""', 'g') . '"'
-        \       : substitute(a:str, '\v([&|<>^])', '^\1', 'g'),
-        \   '%',
-        \   '%%',
-        \   'g',
-        \)
-    endif
-
-    return shellescape (a:str)
-endfunction
-
-" Get the loclist item message according to a given format string.
-"
-" See `:help g:ale_loclist_msg_format` and `:help g:ale_echo_msg_format`
-function! ale#GetLocItemMessage(item, format_string) abort
-    let l:msg = a:format_string
-    let l:severity = g:ale_echo_msg_warning_str
-    let l:code = get(a:item, 'code', '')
-    let l:type = get(a:item, 'type', 'E')
-    let l:linter_name = get(a:item, 'linter_name', '')
-    let l:code_repl = !empty(l:code) ? '\=submatch(1) . l:code . submatch(2)' : ''
-
-    if l:type is# 'E'
-        let l:severity = g:ale_echo_msg_error_str
-    elseif l:type is# 'I'
-        let l:severity = g:ale_echo_msg_info_str
-    endif
-
-    " Replace special markers with certain information.
-    " \=l:variable is used to avoid escaping issues.
-    let l:msg = substitute(l:msg, '\v\%([^\%]*)code([^\%]*)\%', l:code_repl, 'g')
-    let l:msg = substitute(l:msg, '\V%severity%', '\=l:severity', 'g')
-    let l:msg = substitute(l:msg, '\V%linter%', '\=l:linter_name', 'g')
-    " Replace %s with the text.
-    let l:msg = substitute(l:msg, '\V%s', '\=a:item.text', 'g')
-
-    return l:msg
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/ant.vim b/sources_non_forked/ale/autoload/ale/ant.vim
deleted file mode 100644
index 7d02484..0000000
--- a/sources_non_forked/ale/autoload/ale/ant.vim
+++ /dev/null
@@ -1,41 +0,0 @@
-" Author: Andrew Lee <andrew.lambda@tuta.io>.
-" Inspired by ale/gradle.vim by Michael Pardo <michael@michaelpardo.com>
-" Description: Functions for working with Ant projects.
-
-" Given a buffer number, find an Ant project root
-function! ale#ant#FindProjectRoot(buffer) abort
-    let l:build_xml_path = ale#path#FindNearestFile(a:buffer, 'build.xml')
-
-    if !empty(l:build_xml_path)
-        return fnamemodify(l:build_xml_path, ':h')
-    endif
-
-    return ''
-endfunction
-
-" Given a buffer number, find the path to the `ant` executable. Returns an empty
-" string if cannot find the executable.
-function! ale#ant#FindExecutable(buffer) abort
-    if executable('ant')
-        return 'ant'
-    endif
-
-    return ''
-endfunction
-
-" Given a buffer number, build a command to print the classpath of the root
-" project. Returns an empty string if cannot build the command.
-function! ale#ant#BuildClasspathCommand(buffer) abort
-    let l:executable = ale#ant#FindExecutable(a:buffer)
-    let l:project_root = ale#ant#FindProjectRoot(a:buffer)
-
-    if !empty(l:executable) && !empty(l:project_root)
-        return ale#path#CdString(l:project_root)
-        \   . ale#Escape(l:executable)
-        \   . ' classpath'
-        \   . ' -S'
-        \   . ' -q'
-    endif
-
-    return ''
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/args.vim b/sources_non_forked/ale/autoload/ale/args.vim
deleted file mode 100644
index 70afb2e..0000000
--- a/sources_non_forked/ale/autoload/ale/args.vim
+++ /dev/null
@@ -1,43 +0,0 @@
-" Author: w0rp <devw0rp@gmail.com>
-" Description: This module implements a function for parsing arguments for
-" commands.
-
-" Given a list of valid arguments like ['foo', 'bar'] and a string to parse,
-" parse the arguments from the string and return [parsed_args, remainder].
-"
-" Arguments must be prefixed in the string with a single minus (-), and a
-" double minus (--) denotes the end of arguments.
-function! ale#args#Parse(arg_list, string) abort
-    let l:parsed = {}
-    let l:end_of_args = 0
-    let l:word_list = split(a:string, ' ')
-    let l:index = 0
-
-    while l:index < len(l:word_list)
-        let l:word = l:word_list[l:index]
-
-        if l:word[:0] is# '-'
-            let l:index += 1
-
-            if l:word is# '--'
-                break
-            endif
-
-            let l:arg = l:word[1:]
-
-            if index(a:arg_list, l:arg) >= 0
-                let l:parsed[l:arg] = ''
-            else
-                throw 'Invalid argument: ' . l:word
-            endif
-        elseif l:word is# ''
-            let l:index += 1
-        else
-            break
-        endif
-    endwhile
-
-    let l:new_string = join(l:word_list[l:index :], ' ')
-
-    return [l:parsed, l:new_string]
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/assert.vim b/sources_non_forked/ale/autoload/ale/assert.vim
deleted file mode 100644
index 291edce..0000000
--- a/sources_non_forked/ale/autoload/ale/assert.vim
+++ /dev/null
@@ -1,339 +0,0 @@
-let s:command_output = []
-
-function! ale#assert#GivenCommandOutput(...) abort
-    let s:command_output = a:000
-endfunction
-
-function! s:GetLinter() abort
-    let l:linters = ale#linter#GetLintersLoaded()
-    let l:filetype_linters = get(values(l:linters), 0, [])
-
-    if len(l:linters) is 0 || len(l:filetype_linters) is 0
-        throw 'No linters were loaded'
-    endif
-
-    if len(l:linters) > 1 || len(l:filetype_linters) > 1
-        throw 'More than one linter was loaded'
-    endif
-
-    return l:filetype_linters[0]
-endfunction
-
-function! s:FormatExe(command, executable) abort
-    return substitute(a:command, '%e', '\=ale#Escape(a:executable)', 'g')
-endfunction
-
-function! s:ProcessDeferredCommands(initial_result) abort
-    let l:result = a:initial_result
-    let l:command_index = 0
-    let l:command = []
-
-    while ale#command#IsDeferred(l:result)
-        call add(l:command, s:FormatExe(l:result.command, l:result.executable))
-
-        if get(g:, 'ale_run_synchronously_emulate_commands')
-            " Don't run commands, but simulate the results.
-            let l:Callback = g:ale_run_synchronously_callbacks[0]
-            let l:output = get(s:command_output, l:command_index, [])
-            call l:Callback(0, l:output)
-            unlet g:ale_run_synchronously_callbacks
-
-            let l:command_index += 1
-        else
-            " Run the commands in the shell, synchronously.
-            call ale#test#FlushJobs()
-        endif
-
-        let l:result = l:result.value
-    endwhile
-
-    call add(l:command, l:result)
-
-    return l:command
-endfunction
-
-" Load the currently loaded linter for a test case, and check that the command
-" matches the given string.
-function! ale#assert#Linter(expected_executable, expected_command) abort
-    let l:buffer = bufnr('')
-    let l:linter = s:GetLinter()
-    let l:executable = ale#linter#GetExecutable(l:buffer, l:linter)
-
-    while ale#command#IsDeferred(l:executable)
-        call ale#test#FlushJobs()
-        let l:executable = l:executable.value
-    endwhile
-
-    let l:command = s:ProcessDeferredCommands(
-    \   ale#linter#GetCommand(l:buffer, l:linter),
-    \)
-
-    if type(a:expected_command) isnot v:t_list
-        let l:command = l:command[-1]
-    endif
-
-    if type(l:command) is v:t_string
-        " Replace %e with the escaped executable, so tests keep passing after
-        " linters are changed to use %e.
-        let l:command = s:FormatExe(l:command, l:executable)
-    elseif type(l:command) is v:t_list
-        call map(l:command, 's:FormatExe(v:val, l:executable)')
-    endif
-
-    AssertEqual
-    \   [a:expected_executable, a:expected_command],
-    \   [l:executable, l:command]
-endfunction
-
-function! ale#assert#Fixer(expected_result) abort
-    let l:buffer = bufnr('')
-    let l:result = s:ProcessDeferredCommands(s:FixerFunction(l:buffer))
-
-    if type(a:expected_result) isnot v:t_list
-        let l:result = l:result[-1]
-    endif
-
-    AssertEqual a:expected_result, l:result
-endfunction
-
-function! ale#assert#FixerNotExecuted() abort
-    let l:buffer = bufnr('')
-    let l:result = s:ProcessDeferredCommands(s:FixerFunction(l:buffer))[-1]
-
-    Assert empty(l:result), "The fixer will be executed when it shouldn't be"
-endfunction
-
-function! ale#assert#LinterNotExecuted() abort
-    let l:buffer = bufnr('')
-    let l:linter = s:GetLinter()
-    let l:executable = ale#linter#GetExecutable(l:buffer, l:linter)
-
-    Assert empty(l:executable), "The linter will be executed when it shouldn't be"
-endfunction
-
-function! ale#assert#LSPOptions(expected_options) abort
-    let l:buffer = bufnr('')
-    let l:linter = s:GetLinter()
-    let l:initialization_options = ale#lsp_linter#GetOptions(l:buffer, l:linter)
-
-    AssertEqual a:expected_options, l:initialization_options
-endfunction
-
-function! ale#assert#LSPConfig(expected_config) abort
-    let l:buffer = bufnr('')
-    let l:linter = s:GetLinter()
-    let l:config = ale#lsp_linter#GetConfig(l:buffer, l:linter)
-
-    AssertEqual a:expected_config, l:config
-endfunction
-
-function! ale#assert#LSPLanguage(expected_language) abort
-    let l:buffer = bufnr('')
-    let l:linter = s:GetLinter()
-    let l:language = ale#util#GetFunction(l:linter.language_callback)(l:buffer)
-
-    AssertEqual a:expected_language, l:language
-endfunction
-
-function! ale#assert#LSPProject(expected_root) abort
-    let l:buffer = bufnr('')
-    let l:linter = s:GetLinter()
-    let l:root = ale#lsp_linter#FindProjectRoot(l:buffer, l:linter)
-
-    AssertEqual a:expected_root, l:root
-endfunction
-
-function! ale#assert#LSPAddress(expected_address) abort
-    let l:buffer = bufnr('')
-    let l:linter = s:GetLinter()
-    let l:address = ale#linter#GetAddress(l:buffer, l:linter)
-
-    AssertEqual a:expected_address, l:address
-endfunction
-
-function! ale#assert#SetUpLinterTestCommands() abort
-    command! -nargs=+ GivenCommandOutput :call ale#assert#GivenCommandOutput(<args>)
-    command! -nargs=+ AssertLinter :call ale#assert#Linter(<args>)
-    command! -nargs=0 AssertLinterNotExecuted :call ale#assert#LinterNotExecuted()
-    command! -nargs=+ AssertLSPOptions :call ale#assert#LSPOptions(<args>)
-    command! -nargs=+ AssertLSPConfig :call ale#assert#LSPConfig(<args>)
-    command! -nargs=+ AssertLSPLanguage :call ale#assert#LSPLanguage(<args>)
-    command! -nargs=+ AssertLSPProject :call ale#assert#LSPProject(<args>)
-    command! -nargs=+ AssertLSPAddress :call ale#assert#LSPAddress(<args>)
-endfunction
-
-function! ale#assert#SetUpFixerTestCommands() abort
-    command! -nargs=+ GivenCommandOutput :call ale#assert#GivenCommandOutput(<args>)
-    command! -nargs=+ AssertFixer :call ale#assert#Fixer(<args>)
-    command! -nargs=0 AssertFixerNotExecuted :call ale#assert#FixerNotExecuted()
-endfunction
-
-" A dummy function for making sure this module is loaded.
-function! ale#assert#SetUpLinterTest(filetype, name) abort
-    " Set up a marker so ALE doesn't create real random temporary filenames.
-    let g:ale_create_dummy_temporary_file = 1
-
-    " Remove current linters.
-    call ale#linter#Reset()
-    call ale#linter#PreventLoading(a:filetype)
-
-    let l:prefix = 'ale_' . a:filetype . '_' . a:name
-    let b:filter_expr = 'v:val[: len(l:prefix) - 1] is# l:prefix'
-
-    Save g:ale_lsp_root
-    let g:ale_lsp_root = {}
-
-    Save b:ale_lsp_root
-    unlet! b:ale_lsp_root
-
-    Save g:ale_c_build_dir
-    unlet! g:ale_c_build_dir
-
-    " Save and clear linter variables.
-    " We'll load the runtime file to reset them to defaults.
-    for l:key in filter(keys(g:), b:filter_expr)
-        execute 'Save g:' . l:key
-        unlet g:[l:key]
-    endfor
-
-    unlet! b:ale_c_build_dir
-
-    for l:key in filter(keys(b:), b:filter_expr)
-        unlet b:[l:key]
-    endfor
-
-    execute 'runtime ale_linters/' . a:filetype . '/' . a:name . '.vim'
-
-    if !exists('g:dir')
-        call ale#test#SetDirectory('/testplugin/test/command_callback')
-    endif
-
-    call ale#assert#SetUpLinterTestCommands()
-
-    let g:ale_run_synchronously = 1
-    let g:ale_run_synchronously_emulate_commands = 1
-endfunction
-
-function! ale#assert#TearDownLinterTest() abort
-    unlet! g:ale_create_dummy_temporary_file
-    unlet! g:ale_run_synchronously
-    unlet! g:ale_run_synchronously_callbacks
-    unlet! g:ale_run_synchronously_emulate_commands
-    unlet! g:ale_run_synchronously_command_results
-    let s:command_output = []
-
-    if exists(':GivenCommandOutput')
-        delcommand GivenCommandOutput
-    endif
-
-    if exists(':AssertLinter')
-        delcommand AssertLinter
-    endif
-
-    if exists(':AssertLinterNotExecuted')
-        delcommand AssertLinterNotExecuted
-    endif
-
-    if exists(':AssertLSPOptions')
-        delcommand AssertLSPOptions
-    endif
-
-    if exists(':AssertLSPConfig')
-        delcommand AssertLSPConfig
-    endif
-
-    if exists(':AssertLSPLanguage')
-        delcommand AssertLSPLanguage
-    endif
-
-    if exists(':AssertLSPProject')
-        delcommand AssertLSPProject
-    endif
-
-    if exists(':AssertLSPAddress')
-        delcommand AssertLSPAddress
-    endif
-
-    if exists('g:dir')
-        call ale#test#RestoreDirectory()
-    endif
-
-    Restore
-
-    call ale#linter#Reset()
-
-    if exists('*ale#semver#ResetVersionCache')
-        call ale#semver#ResetVersionCache()
-    endif
-endfunction
-
-function! ale#assert#SetUpFixerTest(filetype, name, ...) abort
-    " If the suffix of the option names format is different, an additional
-    " argument can be used for that instead.
-    if a:0 > 1
-        throw 'Too many arguments'
-    endif
-
-    " Set up a marker so ALE doesn't create real random temporary filenames.
-    let g:ale_create_dummy_temporary_file = 1
-
-    let l:function_name = ale#fix#registry#GetFunc(a:name)
-    let s:FixerFunction = function(l:function_name)
-
-    let l:option_suffix = get(a:000, 0, a:name)
-    let l:prefix = 'ale_' . a:filetype . '_'
-    \   . substitute(l:option_suffix, '-', '_', 'g')
-    let b:filter_expr = 'v:val[: len(l:prefix) - 1] is# l:prefix'
-
-    for l:key in filter(keys(g:), b:filter_expr)
-        execute 'Save g:' . l:key
-        unlet g:[l:key]
-    endfor
-
-    for l:key in filter(keys(b:), b:filter_expr)
-        unlet b:[l:key]
-    endfor
-
-    execute 'runtime autoload/ale/fixers/' . substitute(a:name, '-', '_', 'g') . '.vim'
-
-    if !exists('g:dir')
-        call ale#test#SetDirectory('/testplugin/test/fixers')
-    endif
-
-    call ale#assert#SetUpFixerTestCommands()
-
-    let g:ale_run_synchronously = 1
-    let g:ale_run_synchronously_emulate_commands = 1
-endfunction
-
-function! ale#assert#TearDownFixerTest() abort
-    unlet! g:ale_create_dummy_temporary_file
-    unlet! g:ale_run_synchronously
-    unlet! g:ale_run_synchronously_callbacks
-    unlet! g:ale_run_synchronously_emulate_commands
-    unlet! g:ale_run_synchronously_command_results
-    let s:command_output = []
-    unlet! s:FixerFunction
-
-    if exists('g:dir')
-        call ale#test#RestoreDirectory()
-    endif
-
-    Restore
-
-    if exists('*ale#semver#ResetVersionCache')
-        call ale#semver#ResetVersionCache()
-    endif
-
-    if exists(':GivenCommandOutput')
-        delcommand GivenCommandOutput
-    endif
-
-    if exists(':AssertFixer')
-        delcommand AssertFixer
-    endif
-
-    if exists(':AssertFixerNotExecuted')
-        delcommand AssertFixerNotExecuted
-    endif
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/balloon.vim b/sources_non_forked/ale/autoload/ale/balloon.vim
deleted file mode 100644
index 72f6b91..0000000
--- a/sources_non_forked/ale/autoload/ale/balloon.vim
+++ /dev/null
@@ -1,58 +0,0 @@
-" Author: w0rp <devw0rp@gmail.com>
-" Description: balloonexpr support for ALE.
-
-function! ale#balloon#MessageForPos(bufnr, lnum, col) abort
-    " Don't show balloons if they are disabled, or linting is disabled.
-    if !ale#Var(a:bufnr, 'set_balloons')
-    \|| !g:ale_enabled
-    \|| !getbufvar(a:bufnr, 'ale_enabled', 1)
-        return ''
-    endif
-
-    let l:loclist = get(g:ale_buffer_info, a:bufnr, {'loclist': []}).loclist
-    let l:index = ale#util#BinarySearch(l:loclist, a:bufnr, a:lnum, a:col)
-
-    " Show the diagnostics message if found, 'Hover' output otherwise
-    if l:index >= 0
-        return l:loclist[l:index].text
-    elseif exists('*balloon_show') || getbufvar(
-    \   a:bufnr,
-    \   'ale_set_balloons_legacy_echo',
-    \   get(g:, 'ale_set_balloons_legacy_echo', 0)
-    \)
-        " Request LSP/tsserver hover information, but only if this version of
-        " Vim supports the balloon_show function, or if we turned a legacy
-        " setting on.
-        call ale#hover#Show(a:bufnr, a:lnum, a:col, {'called_from_balloonexpr': 1})
-    endif
-
-    return ''
-endfunction
-
-function! ale#balloon#Expr() abort
-    return ale#balloon#MessageForPos(v:beval_bufnr, v:beval_lnum, v:beval_col)
-endfunction
-
-function! ale#balloon#Disable() abort
-    if has('balloon_eval')
-        set noballooneval
-        set balloonexpr=
-    endif
-
-    if has('balloon_eval_term')
-        set noballoonevalterm
-        set balloonexpr=
-    endif
-endfunction
-
-function! ale#balloon#Enable() abort
-    if has('balloon_eval')
-        set ballooneval
-        set balloonexpr=ale#balloon#Expr()
-    endif
-
-    if has('balloon_eval_term')
-        set balloonevalterm
-        set balloonexpr=ale#balloon#Expr()
-    endif
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/c.vim b/sources_non_forked/ale/autoload/ale/c.vim
deleted file mode 100644
index 9b42870..0000000
--- a/sources_non_forked/ale/autoload/ale/c.vim
+++ /dev/null
@@ -1,434 +0,0 @@
-" Author: gagbo <gagbobada@gmail.com>, w0rp <devw0rp@gmail.com>, roel0 <postelmansroel@gmail.com>
-" Description: Functions for integrating with C-family linters.
-
-call ale#Set('c_parse_makefile', 0)
-call ale#Set('c_parse_compile_commands', 0)
-let s:sep = has('win32') ? '\' : '/'
-
-" Set just so tests can override it.
-let g:__ale_c_project_filenames = ['.git/HEAD', 'configure', 'Makefile', 'CMakeLists.txt']
-
-function! ale#c#GetBuildDirectory(buffer) abort
-    " Don't include build directory for header files, as compile_commands.json
-    " files don't consider headers to be translation units, and provide no
-    " commands for compiling header files.
-    if expand('#' . a:buffer) =~# '\v\.(h|hpp)$'
-        return ''
-    endif
-
-    let l:build_dir = ale#Var(a:buffer, 'c_build_dir')
-
-    " c_build_dir has the priority if defined
-    if !empty(l:build_dir)
-        return l:build_dir
-    endif
-
-    let [l:root, l:json_file] = ale#c#FindCompileCommands(a:buffer)
-
-    return ale#path#Dirname(l:json_file)
-endfunction
-
-function! ale#c#ShellSplit(line) abort
-    let l:stack = []
-    let l:args = ['']
-    let l:prev = ''
-
-    for l:char in split(a:line, '\zs')
-        if l:char is# ''''
-            if len(l:stack) > 0 && get(l:stack, -1) is# ''''
-                call remove(l:stack, -1)
-            elseif (len(l:stack) == 0 || get(l:stack, -1) isnot# '"') && l:prev isnot# '\'
-                call add(l:stack, l:char)
-            endif
-        elseif (l:char is# '"' || l:char is# '`') && l:prev isnot# '\'
-            if len(l:stack) > 0 && get(l:stack, -1) is# l:char
-                call remove(l:stack, -1)
-            elseif len(l:stack) == 0 || get(l:stack, -1) isnot# ''''
-                call add(l:stack, l:char)
-            endif
-        elseif (l:char is# '(' || l:char is# '[' || l:char is# '{') && l:prev isnot# '\'
-            if len(l:stack) == 0 || get(l:stack, -1) isnot# ''''
-                call add(l:stack, l:char)
-            endif
-        elseif (l:char is# ')' || l:char is# ']' || l:char is# '}') && l:prev isnot# '\'
-            if len(l:stack) > 0 && get(l:stack, -1) is# {')': '(', ']': '[', '}': '{'}[l:char]
-                call remove(l:stack, -1)
-            endif
-        elseif l:char is# ' ' && len(l:stack) == 0
-            if len(get(l:args, -1)) > 0
-                call add(l:args, '')
-            endif
-
-            continue
-        endif
-
-        let l:args[-1] = get(l:args, -1) . l:char
-    endfor
-
-    return l:args
-endfunction
-
-function! ale#c#ParseCFlags(path_prefix, cflag_line) abort
-    let l:cflags_list = []
-
-    let l:split_lines = ale#c#ShellSplit(a:cflag_line)
-    let l:option_index = 0
-
-    while l:option_index < len(l:split_lines)
-        let l:option = l:split_lines[l:option_index]
-        let l:option_index = l:option_index + 1
-
-        " Include options, that may need relative path fix
-        if stridx(l:option, '-I') == 0
-        \ || stridx(l:option, '-iquote') == 0
-        \ || stridx(l:option, '-isystem') == 0
-        \ || stridx(l:option, '-idirafter') == 0
-            if stridx(l:option, '-I') == 0 && l:option isnot# '-I'
-                let l:arg = join(split(l:option, '\zs')[2:], '')
-                let l:option = '-I'
-            else
-                let l:arg = l:split_lines[l:option_index]
-                let l:option_index = l:option_index + 1
-            endif
-
-            " Fix relative paths if needed
-            if stridx(l:arg, s:sep) != 0 && stridx(l:arg, '/') != 0
-                let l:rel_path = substitute(l:arg, '"', '', 'g')
-                let l:rel_path = substitute(l:rel_path, '''', '', 'g')
-                let l:arg = ale#Escape(a:path_prefix . s:sep . l:rel_path)
-            endif
-
-            call add(l:cflags_list, l:option)
-            call add(l:cflags_list, l:arg)
-        " Options with arg that can be grouped with the option or separate
-        elseif stridx(l:option, '-D') == 0 || stridx(l:option, '-B') == 0
-            call add(l:cflags_list, l:option)
-
-            if l:option is# '-D' || l:option is# '-B'
-                call add(l:cflags_list, l:split_lines[l:option_index])
-                let l:option_index = l:option_index + 1
-            endif
-        " Options that have an argument (always separate)
-        elseif l:option is# '-iprefix' || stridx(l:option, '-iwithprefix') == 0
-        \ || l:option is# '-isysroot' || l:option is# '-imultilib'
-            call add(l:cflags_list, l:option)
-            call add(l:cflags_list, l:split_lines[l:option_index])
-            let l:option_index = l:option_index + 1
-        " Options without argument
-        elseif (stridx(l:option, '-W') == 0 && stridx(l:option, '-Wa,') != 0 && stridx(l:option, '-Wl,') != 0 && stridx(l:option, '-Wp,') != 0)
-        \ || l:option is# '-w' || stridx(l:option, '-pedantic') == 0
-        \ || l:option is# '-ansi' || stridx(l:option, '-std=') == 0
-        \ || (stridx(l:option, '-f') == 0 && stridx(l:option, '-fdump') != 0 && stridx(l:option, '-fdiagnostics') != 0 && stridx(l:option, '-fno-show-column') != 0)
-        \ || stridx(l:option, '-O') == 0
-        \ || l:option is# '-C' || l:option is# '-CC' || l:option is# '-trigraphs'
-        \ || stridx(l:option, '-nostdinc') == 0 || stridx(l:option, '-iplugindir=') == 0
-        \ || stridx(l:option, '--sysroot=') == 0 || l:option is# '--no-sysroot-suffix'
-        \ || stridx(l:option, '-m') == 0
-            call add(l:cflags_list, l:option)
-        endif
-    endwhile
-
-    return join(l:cflags_list, ' ')
-endfunction
-
-function! ale#c#ParseCFlagsFromMakeOutput(buffer, make_output) abort
-    if !g:ale_c_parse_makefile
-        return v:null
-    endif
-
-    let l:buffer_filename = expand('#' . a:buffer . ':t')
-    let l:cflag_line = ''
-
-    " Find a line matching this buffer's filename in the make output.
-    for l:line in a:make_output
-        if stridx(l:line, l:buffer_filename) >= 0
-            let l:cflag_line = l:line
-            break
-        endif
-    endfor
-
-    let l:makefile_path = ale#path#FindNearestFile(a:buffer, 'Makefile')
-    let l:makefile_dir = fnamemodify(l:makefile_path, ':p:h')
-
-    return ale#c#ParseCFlags(l:makefile_dir, l:cflag_line)
-endfunction
-
-" Given a buffer number, find the project directory containing
-" compile_commands.json, and the path to the compile_commands.json file.
-"
-" If compile_commands.json cannot be found, two empty strings will be
-" returned.
-function! ale#c#FindCompileCommands(buffer) abort
-    " Look above the current source file to find compile_commands.json
-    let l:json_file = ale#path#FindNearestFile(a:buffer, 'compile_commands.json')
-
-    if !empty(l:json_file)
-        return [fnamemodify(l:json_file, ':h'), l:json_file]
-    endif
-
-    " Search in build directories if we can't find it in the project.
-    for l:path in ale#path#Upwards(expand('#' . a:buffer . ':p:h'))
-        for l:dirname in ale#Var(a:buffer, 'c_build_dir_names')
-            let l:c_build_dir = l:path . s:sep . l:dirname
-            let l:json_file = l:c_build_dir . s:sep . 'compile_commands.json'
-
-            if filereadable(l:json_file)
-                return [l:path, l:json_file]
-            endif
-        endfor
-    endfor
-
-    return ['', '']
-endfunction
-
-" Find the project root for C/C++ projects.
-"
-" The location of compile_commands.json will be used to find project roots.
-"
-" If compile_commands.json cannot be found, other common configuration files
-" will be used to detect the project root.
-function! ale#c#FindProjectRoot(buffer) abort
-    let [l:root, l:json_file] = ale#c#FindCompileCommands(a:buffer)
-
-    " Fall back on detecting the project root based on other filenames.
-    if empty(l:root)
-        for l:project_filename in g:__ale_c_project_filenames
-            let l:full_path = ale#path#FindNearestFile(a:buffer, l:project_filename)
-
-            if !empty(l:full_path)
-                let l:path = fnamemodify(l:full_path, ':h')
-
-                " Correct .git path detection.
-                if fnamemodify(l:path, ':t') is# '.git'
-                    let l:path = fnamemodify(l:path, ':h')
-                endif
-
-                return l:path
-            endif
-        endfor
-    endif
-
-    return l:root
-endfunction
-
-" Cache compile_commands.json data in a Dictionary, so we don't need to read
-" the same files over and over again. The key in the dictionary will include
-" the last modified time of the file.
-if !exists('s:compile_commands_cache')
-    let s:compile_commands_cache = {}
-endif
-
-function! s:GetLookupFromCompileCommandsFile(compile_commands_file) abort
-    let l:empty = [{}, {}]
-
-    if empty(a:compile_commands_file)
-        return l:empty
-    endif
-
-    let l:time = getftime(a:compile_commands_file)
-
-    if l:time < 0
-        return l:empty
-    endif
-
-    let l:key = a:compile_commands_file . ':' . l:time
-
-    if has_key(s:compile_commands_cache, l:key)
-        return s:compile_commands_cache[l:key]
-    endif
-
-    let l:raw_data = []
-    silent! let l:raw_data = json_decode(join(readfile(a:compile_commands_file), ''))
-
-    if type(l:raw_data) isnot v:t_list
-        let l:raw_data = []
-    endif
-
-    let l:file_lookup = {}
-    let l:dir_lookup = {}
-
-    for l:entry in (type(l:raw_data) is v:t_list ? l:raw_data : [])
-        let l:basename = tolower(fnamemodify(l:entry.file, ':t'))
-        let l:file_lookup[l:basename] = get(l:file_lookup, l:basename, []) + [l:entry]
-
-        let l:dirbasename = tolower(fnamemodify(l:entry.directory, ':p:h:t'))
-        let l:dir_lookup[l:dirbasename] = get(l:dir_lookup, l:dirbasename, []) + [l:entry]
-    endfor
-
-    if !empty(l:file_lookup) && !empty(l:dir_lookup)
-        let l:result = [l:file_lookup, l:dir_lookup]
-        let s:compile_commands_cache[l:key] = l:result
-
-        return l:result
-    endif
-
-    return l:empty
-endfunction
-
-function! ale#c#GetCompileCommand(json_item) abort
-    if has_key(a:json_item, 'command')
-        return a:json_item.command
-    elseif has_key(a:json_item, 'arguments')
-        return join(a:json_item.arguments, ' ')
-    endif
-
-    return ''
-endfunction
-
-function! ale#c#ParseCompileCommandsFlags(buffer, file_lookup, dir_lookup) abort
-    " Search for an exact file match first.
-    let l:basename = tolower(expand('#' . a:buffer . ':t'))
-    let l:file_list = get(a:file_lookup, l:basename, [])
-    " A source file matching the header filename.
-    let l:source_file = ''
-
-    if empty(l:file_list) && l:basename =~? '\.h$\|\.hpp$'
-        for l:suffix in ['.c', '.cpp']
-            let l:key = fnamemodify(l:basename, ':r') . l:suffix
-            let l:file_list = get(a:file_lookup, l:key, [])
-
-            if !empty(l:file_list)
-                let l:source_file = l:key
-                break
-            endif
-        endfor
-    endif
-
-    for l:item in l:file_list
-        " Load the flags for this file, or for a source file matching the
-        " header file.
-        if (
-        \   bufnr(l:item.file) is a:buffer
-        \   || (
-        \       !empty(l:source_file)
-        \       && l:item.file[-len(l:source_file):] is? l:source_file
-        \   )
-        \)
-            return ale#c#ParseCFlags(l:item.directory, ale#c#GetCompileCommand(l:item))
-        endif
-    endfor
-
-    " Look for any file in the same directory if we can't find an exact match.
-    let l:dir = ale#path#Simplify(expand('#' . a:buffer . ':p:h'))
-
-    let l:dirbasename = tolower(expand('#' . a:buffer . ':p:h:t'))
-    let l:dir_list = get(a:dir_lookup, l:dirbasename, [])
-
-    for l:item in l:dir_list
-        if ale#path#Simplify(fnamemodify(l:item.file, ':h')) is? l:dir
-            return ale#c#ParseCFlags(l:item.directory, ale#c#GetCompileCommand(l:item))
-        endif
-    endfor
-
-    return ''
-endfunction
-
-function! ale#c#FlagsFromCompileCommands(buffer, compile_commands_file) abort
-    let l:lookups = s:GetLookupFromCompileCommandsFile(a:compile_commands_file)
-    let l:file_lookup = l:lookups[0]
-    let l:dir_lookup = l:lookups[1]
-
-    return ale#c#ParseCompileCommandsFlags(a:buffer, l:file_lookup, l:dir_lookup)
-endfunction
-
-function! ale#c#GetCFlags(buffer, output) abort
-    let l:cflags = v:null
-
-    if ale#Var(a:buffer, 'c_parse_makefile') && !empty(a:output)
-        let l:cflags = ale#c#ParseCFlagsFromMakeOutput(a:buffer, a:output)
-    endif
-
-    if ale#Var(a:buffer, 'c_parse_compile_commands')
-        let [l:root, l:json_file] = ale#c#FindCompileCommands(a:buffer)
-
-        if !empty(l:json_file)
-            let l:cflags = ale#c#FlagsFromCompileCommands(a:buffer, l:json_file)
-        endif
-    endif
-
-    if l:cflags is v:null
-        let l:cflags = ale#c#IncludeOptions(ale#c#FindLocalHeaderPaths(a:buffer))
-    endif
-
-    return l:cflags isnot v:null ? l:cflags : ''
-endfunction
-
-function! ale#c#GetMakeCommand(buffer) abort
-    if ale#Var(a:buffer, 'c_parse_makefile')
-        let l:makefile_path = ale#path#FindNearestFile(a:buffer, 'Makefile')
-
-        if !empty(l:makefile_path)
-            return 'cd '. fnamemodify(l:makefile_path, ':p:h') . ' && make -n'
-        endif
-    endif
-
-    return ''
-endfunction
-
-function! ale#c#RunMakeCommand(buffer, Callback) abort
-    let l:command = ale#c#GetMakeCommand(a:buffer)
-
-    if empty(l:command)
-        return a:Callback(a:buffer, [])
-    endif
-
-    return ale#command#Run(
-    \   a:buffer,
-    \   l:command,
-    \   {b, output -> a:Callback(a:buffer, output)},
-    \)
-endfunction
-
-" Given a buffer number, search for a project root, and output a List
-" of directories to include based on some heuristics.
-"
-" For projects with headers in the project root, the project root will
-" be returned.
-"
-" For projects with an 'include' directory, that directory will be returned.
-function! ale#c#FindLocalHeaderPaths(buffer) abort
-    let l:project_root = ale#c#FindProjectRoot(a:buffer)
-
-    if empty(l:project_root)
-        return []
-    endif
-
-    " See if we can find .h files directory in the project root.
-    " If we can, that's our include directory.
-    if !empty(globpath(l:project_root, '*.h', 0))
-        return [l:project_root]
-    endif
-
-    " Look for .hpp files too.
-    if !empty(globpath(l:project_root, '*.hpp', 0))
-        return [l:project_root]
-    endif
-
-    " If we find an 'include' directory in the project root, then use that.
-    if isdirectory(l:project_root . '/include')
-        return [ale#path#Simplify(l:project_root . s:sep . 'include')]
-    endif
-
-    return []
-endfunction
-
-" Given a List of include paths, create a string containing the -I include
-" options for those paths, with the paths escaped for use in the shell.
-function! ale#c#IncludeOptions(include_paths) abort
-    let l:option_list = []
-
-    for l:path in a:include_paths
-        call add(l:option_list, '-I' . ale#Escape(l:path))
-    endfor
-
-    if empty(l:option_list)
-        return ''
-    endif
-
-    return join(l:option_list)
-endfunction
-
-let g:ale_c_build_dir_names = get(g:, 'ale_c_build_dir_names', [
-\   'build',
-\   'bin',
-\])
diff --git a/sources_non_forked/ale/autoload/ale/code_action.vim b/sources_non_forked/ale/autoload/ale/code_action.vim
deleted file mode 100644
index 60c3bbe..0000000
--- a/sources_non_forked/ale/autoload/ale/code_action.vim
+++ /dev/null
@@ -1,173 +0,0 @@
-" Author: Jerko Steiner <jerko.steiner@gmail.com>
-" Description: Code action support for LSP / tsserver
-
-function! ale#code_action#HandleCodeAction(code_action, should_save) abort
-    let l:current_buffer = bufnr('')
-    let l:changes = a:code_action.changes
-
-    for l:file_code_edit in l:changes
-        let l:buf = bufnr(l:file_code_edit.fileName)
-
-        if l:buf != -1 && l:buf != l:current_buffer && getbufvar(l:buf, '&mod')
-            call ale#util#Execute('echom ''Aborting action, file is unsaved''')
-
-            return
-        endif
-    endfor
-
-    for l:file_code_edit in l:changes
-        call ale#code_action#ApplyChanges(
-        \ l:file_code_edit.fileName,
-        \ l:file_code_edit.textChanges,
-        \ a:should_save,
-        \ )
-    endfor
-endfunction
-
-function! ale#code_action#ApplyChanges(filename, changes, should_save) abort
-    let l:current_buffer = bufnr('')
-    " The buffer is used to determine the fileformat, if available.
-    let l:buffer = bufnr(a:filename)
-    let l:is_current_buffer = l:buffer > 0 && l:buffer == l:current_buffer
-
-    if l:buffer > 0
-        let l:lines = getbufline(l:buffer, 1, '$')
-    else
-        let l:lines = readfile(a:filename, 'b')
-    endif
-
-    if l:is_current_buffer
-        let l:pos = getpos('.')[1:2]
-    else
-        let l:pos = [1, 1]
-    endif
-
-    " We have to keep track of how many lines we have added, and offset
-    " changes accordingly.
-    let l:line_offset = 0
-    let l:column_offset = 0
-    let l:last_end_line = 0
-
-    for l:code_edit in a:changes
-        if l:code_edit.start.line isnot l:last_end_line
-            let l:column_offset = 0
-        endif
-
-        let l:line = l:code_edit.start.line + l:line_offset
-        let l:column = l:code_edit.start.offset + l:column_offset
-        let l:end_line = l:code_edit.end.line + l:line_offset
-        let l:end_column = l:code_edit.end.offset + l:column_offset
-        let l:text = l:code_edit.newText
-
-        let l:cur_line = l:pos[0]
-        let l:cur_column = l:pos[1]
-
-        let l:last_end_line = l:end_line
-
-        " Adjust the ends according to previous edits.
-        if l:end_line > len(l:lines)
-            let l:end_line_len = 0
-        else
-            let l:end_line_len = len(l:lines[l:end_line - 1])
-        endif
-
-        let l:insertions = split(l:text, '\n', 1)
-
-        if l:line is 1
-            " Same logic as for column below. Vimscript's slice [:-1] will not
-            " be an empty list.
-            let l:start = []
-        else
-            let l:start = l:lines[: l:line - 2]
-        endif
-
-        if l:column is 1
-            " We need to handle column 1 specially, because we can't slice an
-            " empty string ending on index 0.
-            let l:middle = [l:insertions[0]]
-        else
-            let l:middle = [l:lines[l:line - 1][: l:column - 2] . l:insertions[0]]
-        endif
-
-        call extend(l:middle, l:insertions[1:])
-        let l:middle[-1] .= l:lines[l:end_line - 1][l:end_column - 1 :]
-
-        let l:lines_before_change = len(l:lines)
-        let l:lines = l:start + l:middle + l:lines[l:end_line :]
-
-        let l:current_line_offset = len(l:lines) - l:lines_before_change
-        let l:line_offset += l:current_line_offset
-        let l:column_offset = len(l:middle[-1]) - l:end_line_len
-
-        let l:pos = s:UpdateCursor(l:pos,
-        \ [l:line, l:column],
-        \ [l:end_line, l:end_column],
-        \ [l:current_line_offset, l:column_offset])
-    endfor
-
-    if l:lines[-1] is# ''
-        call remove(l:lines, -1)
-    endif
-
-    if a:should_save
-        call ale#util#Writefile(l:buffer, l:lines, a:filename)
-    else
-        call ale#util#SetBufferContents(l:buffer, l:lines)
-    endif
-
-    if l:is_current_buffer
-        if a:should_save
-            call ale#util#Execute(':e!')
-        endif
-
-        call setpos('.', [0, l:pos[0], l:pos[1], 0])
-    endif
-endfunction
-
-function! s:UpdateCursor(cursor, start, end, offset) abort
-    let l:cur_line = a:cursor[0]
-    let l:cur_column = a:cursor[1]
-    let l:line = a:start[0]
-    let l:column = a:start[1]
-    let l:end_line = a:end[0]
-    let l:end_column = a:end[1]
-    let l:line_offset = a:offset[0]
-    let l:column_offset = a:offset[1]
-
-    if l:end_line < l:cur_line
-        " both start and end lines are before the cursor. only line offset
-        " needs to be updated
-        let l:cur_line += l:line_offset
-    elseif l:end_line == l:cur_line
-        " end line is at the same location as cursor, which means
-        " l:line <= l:cur_line
-        if l:line < l:cur_line || l:column <= l:cur_column
-            " updates are happening either before or around the cursor
-            if l:end_column < l:cur_column
-                " updates are happening before the cursor, update the
-                " column offset for cursor
-                let l:cur_line += l:line_offset
-                let l:cur_column += l:column_offset
-            else
-                " updates are happening around the cursor, move the cursor
-                " to the end of the changes
-                let l:cur_line += l:line_offset
-                let l:cur_column = l:end_column + l:column_offset
-            endif
-        " else is not necessary, it means modifications are happening
-        " after the cursor so no cursor updates need to be done
-        endif
-    else
-        " end line is after the cursor
-        if l:line < l:cur_line || l:line == l:cur_line && l:column <= l:cur_column
-            " changes are happening around the cursor, move the cursor
-            " to the end of the changes
-            let l:cur_line = l:end_line + l:line_offset
-            let l:cur_column = l:end_column + l:column_offset
-        " else is not necesary, it means modifications are happening
-        " after the cursor so no cursor updates need to be done
-        endif
-    endif
-
-    return [l:cur_line, l:cur_column]
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/command.vim b/sources_non_forked/ale/autoload/ale/command.vim
deleted file mode 100644
index 1bbc4f4..0000000
--- a/sources_non_forked/ale/autoload/ale/command.vim
+++ /dev/null
@@ -1,379 +0,0 @@
-" Author: w0rp <devw0rp@gmail.com>
-" Description: Functions for formatting command strings, running commands, and
-"   managing files during linting and fixing cycles.
-
-" This dictionary holds lists of files and directories to remove later.
-if !exists('s:buffer_data')
-    let s:buffer_data = {}
-endif
-
-" Used to get the data in tests.
-function! ale#command#GetData() abort
-    return deepcopy(s:buffer_data)
-endfunction
-
-function! ale#command#ClearData() abort
-    let s:buffer_data = {}
-endfunction
-
-function! ale#command#InitData(buffer) abort
-    if !has_key(s:buffer_data, a:buffer)
-        let s:buffer_data[a:buffer] = {
-        \   'jobs': {},
-        \   'file_list': [],
-        \   'directory_list': [],
-        \}
-    endif
-endfunction
-
-function! ale#command#ManageFile(buffer, file) abort
-    call ale#command#InitData(a:buffer)
-    call add(s:buffer_data[a:buffer].file_list, a:file)
-endfunction
-
-function! ale#command#ManageDirectory(buffer, directory) abort
-    call ale#command#InitData(a:buffer)
-    call add(s:buffer_data[a:buffer].directory_list, a:directory)
-endfunction
-
-function! ale#command#CreateFile(buffer) abort
-    " This variable can be set to 1 in tests to stub this out.
-    if get(g:, 'ale_create_dummy_temporary_file')
-        return 'TEMP'
-    endif
-
-    let l:temporary_file = ale#util#Tempname()
-    call ale#command#ManageFile(a:buffer, l:temporary_file)
-
-    return l:temporary_file
-endfunction
-
-" Create a new temporary directory and manage it in one go.
-function! ale#command#CreateDirectory(buffer) abort
-    " This variable can be set to 1 in tests to stub this out.
-    if get(g:, 'ale_create_dummy_temporary_file')
-        return 'TEMP_DIR'
-    endif
-
-    let l:temporary_directory = ale#util#Tempname()
-    " Create the temporary directory for the file, unreadable by 'other'
-    " users.
-    call mkdir(l:temporary_directory, '', 0750)
-    call ale#command#ManageDirectory(a:buffer, l:temporary_directory)
-
-    return l:temporary_directory
-endfunction
-
-function! ale#command#RemoveManagedFiles(buffer) abort
-    let l:info = get(s:buffer_data, a:buffer, {})
-
-    if !empty(l:info) && empty(l:info.jobs)
-        " We can't delete anything in a sandbox, so wait until we escape from
-        " it to delete temporary files and directories.
-        if ale#util#InSandbox()
-            return
-        endif
-
-        " Delete files with a call akin to a plan `rm` command.
-        for l:filename in l:info.file_list
-            call delete(l:filename)
-        endfor
-
-        " Delete directories like `rm -rf`.
-        " Directories are handled differently from files, so paths that are
-        " intended to be single files can be set up for automatic deletion
-        " without accidentally deleting entire directories.
-        for l:directory in l:info.directory_list
-            call delete(l:directory, 'rf')
-        endfor
-
-        call remove(s:buffer_data, a:buffer)
-    endif
-endfunction
-
-function! ale#command#CreateTempFile(buffer, temporary_file, input) abort
-    if empty(a:temporary_file)
-        " There is no file, so we didn't create anything.
-        return 0
-    endif
-
-    " Use an existing list of lines of input if we have it, or get the lines
-    " from the file.
-    let l:lines = a:input isnot v:null ? a:input : getbufline(a:buffer, 1, '$')
-
-    let l:temporary_directory = fnamemodify(a:temporary_file, ':h')
-    " Create the temporary directory for the file, unreadable by 'other'
-    " users.
-    call mkdir(l:temporary_directory, '', 0750)
-    " Automatically delete the directory later.
-    call ale#command#ManageDirectory(a:buffer, l:temporary_directory)
-    " Write the buffer out to a file.
-    call ale#util#Writefile(a:buffer, l:lines, a:temporary_file)
-
-    return 1
-endfunction
-
-function! s:TemporaryFilename(buffer) abort
-    let l:filename = fnamemodify(bufname(a:buffer), ':t')
-
-    if empty(l:filename)
-        " If the buffer's filename is empty, create a dummy filename.
-        let l:ft = getbufvar(a:buffer, '&filetype')
-        let l:filename = 'file' . ale#filetypes#GuessExtension(l:ft)
-    endif
-
-    " Create a temporary filename, <temp_dir>/<original_basename>
-    " The file itself will not be created by this function.
-    return ale#util#Tempname() . (has('win32') ? '\' : '/') . l:filename
-endfunction
-
-" Given part of a command, replace any % with %%, so that no characters in
-" the string will be replaced with filenames, etc.
-function! ale#command#EscapeCommandPart(command_part) abort
-    return substitute(a:command_part, '%', '%%', 'g')
-endfunction
-
-" Given a command string, replace every...
-" %s -> with the current filename
-" %t -> with the name of an unused file in a temporary directory
-" %% -> with a literal %
-function! ale#command#FormatCommand(buffer, executable, command, pipe_file_if_needed, input) abort
-    let l:temporary_file = ''
-    let l:command = a:command
-
-    " First replace all uses of %%, used for literal percent characters,
-    " with an ugly string.
-    let l:command = substitute(l:command, '%%', '<<PERCENTS>>', 'g')
-
-    " Replace %e with the escaped executable, if available.
-    if !empty(a:executable) && l:command =~# '%e'
-        let l:command = substitute(l:command, '%e', '\=ale#Escape(a:executable)', 'g')
-    endif
-
-    " Replace all %s occurrences in the string with the name of the current
-    " file.
-    if l:command =~# '%s'
-        let l:filename = fnamemodify(bufname(a:buffer), ':p')
-        let l:command = substitute(l:command, '%s', '\=ale#Escape(l:filename)', 'g')
-    endif
-
-    if a:input isnot v:false && l:command =~# '%t'
-        " Create a temporary filename, <temp_dir>/<original_basename>
-        " The file itself will not be created by this function.
-        let l:temporary_file = s:TemporaryFilename(a:buffer)
-        let l:command = substitute(l:command, '%t', '\=ale#Escape(l:temporary_file)', 'g')
-    endif
-
-    " Finish formatting so %% becomes %.
-    let l:command = substitute(l:command, '<<PERCENTS>>', '%', 'g')
-
-    if a:pipe_file_if_needed && empty(l:temporary_file)
-        " If we are to send the Vim buffer to a command, we'll do it
-        " in the shell. We'll write out the file to a temporary file,
-        " and then read it back in, in the shell.
-        let l:temporary_file = s:TemporaryFilename(a:buffer)
-        let l:command = l:command . ' < ' . ale#Escape(l:temporary_file)
-    endif
-
-    let l:file_created = ale#command#CreateTempFile(
-    \   a:buffer,
-    \   l:temporary_file,
-    \   a:input,
-    \)
-
-    return [l:temporary_file, l:command, l:file_created]
-endfunction
-
-function! ale#command#StopJobs(buffer, job_type) abort
-    let l:info = get(s:buffer_data, a:buffer, {})
-
-    if !empty(l:info)
-        let l:new_map = {}
-
-        for [l:job_id, l:job_type] in items(l:info.jobs)
-            let l:job_id = str2nr(l:job_id)
-
-            if a:job_type is# 'all' || a:job_type is# l:job_type
-                call ale#job#Stop(l:job_id)
-            else
-                let l:new_map[l:job_id] = l:job_type
-            endif
-        endfor
-
-        let l:info.jobs = l:new_map
-    endif
-endfunction
-
-function! s:GatherOutput(line_list, job_id, line) abort
-    call add(a:line_list, a:line)
-endfunction
-
-function! s:ExitCallback(buffer, line_list, Callback, data) abort
-    if !has_key(s:buffer_data, a:buffer)
-        return
-    endif
-
-    let l:jobs = s:buffer_data[a:buffer].jobs
-
-    if !has_key(l:jobs, a:data.job_id)
-        return
-    endif
-
-    let l:job_type = remove(l:jobs, a:data.job_id)
-
-    if g:ale_history_enabled
-        call ale#history#SetExitCode(a:buffer, a:data.job_id, a:data.exit_code)
-
-        " Log the output of the command for ALEInfo if we should.
-        if g:ale_history_log_output && a:data.log_output is 1
-            call ale#history#RememberOutput(
-            \   a:buffer,
-            \   a:data.job_id,
-            \   a:line_list[:]
-            \)
-        endif
-    endif
-
-    " If the callback starts any new jobs, use the same job type for them.
-    call setbufvar(a:buffer, 'ale_job_type', l:job_type)
-    let l:value = a:Callback(a:buffer, a:line_list, {
-    \   'exit_code': a:data.exit_code,
-    \   'temporary_file': a:data.temporary_file,
-    \})
-
-    let l:result = a:data.result
-    let l:result.value = l:value
-
-    if get(l:result, 'result_callback', v:null) isnot v:null
-        call call(l:result.result_callback, [l:value])
-    endif
-endfunction
-
-function! ale#command#Run(buffer, command, Callback, ...) abort
-    let l:options = get(a:000, 0, {})
-
-    if len(a:000) > 1
-        throw 'Too many arguments!'
-    endif
-
-    let l:output_stream = get(l:options, 'output_stream', 'stdout')
-    let l:line_list = []
-
-    let [l:temporary_file, l:command, l:file_created] = ale#command#FormatCommand(
-    \   a:buffer,
-    \   get(l:options, 'executable', ''),
-    \   a:command,
-    \   get(l:options, 'read_buffer', 0),
-    \   get(l:options, 'input', v:null),
-    \)
-    let l:command = ale#job#PrepareCommand(a:buffer, l:command)
-    let l:job_options = {
-    \   'exit_cb': {job_id, exit_code -> s:ExitCallback(
-    \       a:buffer,
-    \       l:line_list,
-    \       a:Callback,
-    \       {
-    \           'job_id': job_id,
-    \           'exit_code': exit_code,
-    \           'temporary_file': l:temporary_file,
-    \           'log_output': get(l:options, 'log_output', 1),
-    \           'result': l:result,
-    \       }
-    \   )},
-    \   'mode': 'nl',
-    \}
-
-    if l:output_stream is# 'stdout'
-        let l:job_options.out_cb = function('s:GatherOutput', [l:line_list])
-    elseif l:output_stream is# 'stderr'
-        let l:job_options.err_cb = function('s:GatherOutput', [l:line_list])
-    elseif l:output_stream is# 'both'
-        let l:job_options.out_cb = function('s:GatherOutput', [l:line_list])
-        let l:job_options.err_cb = function('s:GatherOutput', [l:line_list])
-    endif
-
-    let l:status = 'failed'
-
-    if get(g:, 'ale_run_synchronously') == 1
-        if get(g:, 'ale_emulate_job_failure') == 1
-            let l:job_id = 0
-        else
-            " Generate a fake job ID for tests.
-            let s:fake_job_id = get(s:, 'fake_job_id', 0) + 1
-            let l:job_id = s:fake_job_id
-        endif
-    elseif has('win32')
-        let l:job_id = ale#job#StartWithCmd(l:command, l:job_options)
-    else
-        let l:job_id = ale#job#Start(l:command, l:job_options)
-    endif
-
-    if l:job_id
-        let l:status = 'started'
-        let l:job_type = getbufvar(a:buffer, 'ale_job_type', 'all')
-
-        call ale#command#InitData(a:buffer)
-        let s:buffer_data[a:buffer].jobs[l:job_id] = l:job_type
-    endif
-
-    if g:ale_history_enabled
-        call ale#history#Add(a:buffer, l:status, l:job_id, l:command)
-    endif
-
-    if !l:job_id
-        return 0
-    endif
-
-    " We'll return this Dictionary. A `result_callback` can be assigned to it
-    " later for capturing the result of a:Callback.
-    "
-    " The `_deferred_job_id` is used for both checking the type of object, and
-    " for checking the job ID and status.
-    "
-    " The original command here is used in tests.
-    let l:result = {
-    \   '_deferred_job_id': l:job_id,
-    \   'executable': get(l:options, 'executable', ''),
-    \   'command': a:command,
-    \}
-
-    if get(g:, 'ale_run_synchronously') == 1 && l:job_id
-        if !exists('g:ale_run_synchronously_callbacks')
-            let g:ale_run_synchronously_callbacks = []
-        endif
-
-        if get(g:, 'ale_run_synchronously_emulate_commands', 0)
-            call add(
-            \   g:ale_run_synchronously_callbacks,
-            \   {exit_code, output -> [
-            \       extend(l:line_list, output),
-            \       l:job_options.exit_cb(l:job_id, exit_code),
-            \   ]}
-            \)
-        else
-            " Run a command synchronously if this test option is set.
-            call extend(l:line_list, systemlist(
-            \   type(l:command) is v:t_list
-            \       ? join(l:command[0:1]) . ' ' . ale#Escape(l:command[2])
-            \       : l:command
-            \))
-
-            " Don't capture output when the callbacks aren't set.
-            if !has_key(l:job_options, 'out_cb')
-            \&& !has_key(l:job_options, 'err_cb')
-                let l:line_list = []
-            endif
-
-            call add(
-            \   g:ale_run_synchronously_callbacks,
-            \   {-> l:job_options.exit_cb(l:job_id, v:shell_error)}
-            \)
-        endif
-    endif
-
-    return l:result
-endfunction
-
-function! ale#command#IsDeferred(value) abort
-    return type(a:value) is v:t_dict && has_key(a:value, '_deferred_job_id')
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/completion.vim b/sources_non_forked/ale/autoload/ale/completion.vim
deleted file mode 100644
index 2b5756e..0000000
--- a/sources_non_forked/ale/autoload/ale/completion.vim
+++ /dev/null
@@ -1,865 +0,0 @@
-" Author: w0rp <devw0rp@gmail.com>
-" Description: Completion support for LSP linters
-scriptencoding utf-8
-
-" The omnicompletion menu is shown through a special Plug mapping which is
-" only valid in Insert mode. This way, feedkeys() won't send these keys if you
-" quit Insert mode quickly enough.
-inoremap <silent> <Plug>(ale_show_completion_menu) <C-x><C-o>
-" If we hit the key sequence in normal mode, then we won't show the menu, so
-" we should restore the old settings right away.
-nnoremap <silent> <Plug>(ale_show_completion_menu) :call ale#completion#RestoreCompletionOptions()<CR>
-cnoremap <silent> <Plug>(ale_show_completion_menu) <Nop>
-vnoremap <silent> <Plug>(ale_show_completion_menu) <Nop>
-onoremap <silent> <Plug>(ale_show_completion_menu) <Nop>
-
-let g:ale_completion_delay = get(g:, 'ale_completion_delay', 100)
-let g:ale_completion_excluded_words = get(g:, 'ale_completion_excluded_words', [])
-let g:ale_completion_max_suggestions = get(g:, 'ale_completion_max_suggestions', 50)
-let g:ale_completion_tsserver_autoimport = get(g:, 'ale_completion_tsserver_autoimport', 0)
-
-let s:timer_id = -1
-let s:last_done_pos = []
-
-" CompletionItemKind values from the LSP protocol.
-let g:ale_lsp_types = {
-\ 1: 'text',
-\ 2: 'method',
-\ 3: 'function',
-\ 4: 'constructor',
-\ 5: 'field',
-\ 6: 'variable',
-\ 7: 'class',
-\ 8: 'interface',
-\ 9: 'module',
-\ 10: 'property',
-\ 11: 'unit',
-\ 12: 'value',
-\ 13: 'enum',
-\ 14: 'keyword',
-\ 15: 'snippet',
-\ 16: 'color',
-\ 17: 'file',
-\ 18: 'reference',
-\ 19: 'folder',
-\ 20: 'enum_member',
-\ 21: 'constant',
-\ 22: 'struct',
-\ 23: 'event',
-\ 24: 'operator',
-\ 25: 'type_parameter',
-\ }
-
-" from https://github.com/microsoft/TypeScript/blob/29becf05012bfa7ba20d50b0d16813971e46b8a6/lib/protocol.d.ts#L2472
-let g:ale_tsserver_types = {
-\ 'warning': 'text',
-\ 'keyword': 'keyword',
-\ 'script': 'file',
-\ 'module': 'module',
-\ 'class': 'class',
-\ 'local class': 'class',
-\ 'interface': 'interface',
-\ 'type': 'class',
-\ 'enum': 'enum',
-\ 'enum member': 'enum_member',
-\ 'var': 'variable',
-\ 'local var': 'variable',
-\ 'function': 'function',
-\ 'local function': 'function',
-\ 'method': 'method',
-\ 'getter': 'property',
-\ 'setter': 'method',
-\ 'property': 'property',
-\ 'constructor': 'constructor',
-\ 'call': 'method',
-\ 'index': 'index',
-\ 'construct': 'constructor',
-\ 'parameter': 'parameter',
-\ 'type parameter': 'type_parameter',
-\ 'primitive type': 'unit',
-\ 'label': 'text',
-\ 'alias': 'class',
-\ 'const': 'constant',
-\ 'let': 'variable',
-\ 'directory': 'folder',
-\ 'external module name': 'text',
-\ 'JSX attribute': 'parameter',
-\ 'string': 'text'
-\ }
-
-" For compatibility reasons, we only use built in VIM completion kinds
-" See :help complete-items for Vim completion kinds
-let g:ale_completion_symbols = get(g:, 'ale_completion_symbols', {
-\ 'text': 'v',
-\ 'method': 'f',
-\ 'function': 'f',
-\ 'constructor': 'f',
-\ 'field': 'm',
-\ 'variable': 'v',
-\ 'class': 't',
-\ 'interface': 't',
-\ 'module': 'd',
-\ 'property': 'm',
-\ 'unit': 'v',
-\ 'value': 'v',
-\ 'enum': 't',
-\ 'keyword': 'v',
-\ 'snippet': 'v',
-\ 'color': 'v',
-\ 'file': 'v',
-\ 'reference': 'v',
-\ 'folder': 'v',
-\ 'enum_member': 'm',
-\ 'constant': 'm',
-\ 'struct': 't',
-\ 'event': 'v',
-\ 'operator': 'f',
-\ 'type_parameter': 'p',
-\ '<default>': 'v'
-\ })
-
-let s:LSP_INSERT_TEXT_FORMAT_PLAIN = 1
-let s:LSP_INSERT_TEXT_FORMAT_SNIPPET = 2
-
-let s:lisp_regex = '\v[a-zA-Z_\-][a-zA-Z_\-0-9]*$'
-
-" Regular expressions for checking the characters in the line before where
-" the insert cursor is. If one of these matches, we'll check for completions.
-let s:should_complete_map = {
-\   '<default>': '\v[a-zA-Z$_][a-zA-Z$_0-9]*$|\.$',
-\   'clojure': s:lisp_regex,
-\   'lisp': s:lisp_regex,
-\   'typescript': '\v[a-zA-Z$_][a-zA-Z$_0-9]*$|\.$|''$|"$',
-\   'rust': '\v[a-zA-Z$_][a-zA-Z$_0-9]*$|\.$|::$',
-\   'cpp': '\v[a-zA-Z$_][a-zA-Z$_0-9]*$|\.$|::$|-\>$',
-\}
-
-" Regular expressions for finding the start column to replace with completion.
-let s:omni_start_map = {
-\   '<default>': '\v[a-zA-Z$_][a-zA-Z$_0-9]*$',
-\}
-
-" A map of exact characters for triggering LSP completions. Do not forget to
-" update self.input_patterns in ale.py in updating entries in this map.
-let s:trigger_character_map = {
-\   '<default>': ['.'],
-\   'typescript': ['.', '''', '"'],
-\   'rust': ['.', '::'],
-\   'cpp': ['.', '::', '->'],
-\}
-
-function! s:GetFiletypeValue(map, filetype) abort
-    for l:part in reverse(split(a:filetype, '\.'))
-        let l:regex = get(a:map, l:part, [])
-
-        if !empty(l:regex)
-            return l:regex
-        endif
-    endfor
-
-    " Use the default regex for other files.
-    return a:map['<default>']
-endfunction
-
-" Check if we should look for completions for a language.
-function! ale#completion#GetPrefix(filetype, line, column) abort
-    let l:regex = s:GetFiletypeValue(s:should_complete_map, a:filetype)
-
-    " The column we're using completions for is where we are inserting text,
-    " like so:
-    "   abc
-    "      ^
-    " So we need check the text in the column before that position.
-    return matchstr(getline(a:line)[: a:column - 2], l:regex)
-endfunction
-
-function! ale#completion#GetTriggerCharacter(filetype, prefix) abort
-    if empty(a:prefix)
-        return ''
-    endif
-
-    let l:char_list = s:GetFiletypeValue(s:trigger_character_map, a:filetype)
-
-    if index(l:char_list, a:prefix) >= 0
-        return a:prefix
-    endif
-
-    return ''
-endfunction
-
-function! ale#completion#Filter(buffer, filetype, suggestions, prefix) abort
-    let l:excluded_words = ale#Var(a:buffer, 'completion_excluded_words')
-
-    if empty(a:prefix)
-        let l:filtered_suggestions = a:suggestions
-    else
-        let l:triggers = s:GetFiletypeValue(s:trigger_character_map, a:filetype)
-
-        " For completing...
-        "   foo.
-        "       ^
-        " We need to include all of the given suggestions.
-        if index(l:triggers, a:prefix) >= 0 || empty(a:prefix)
-            let l:filtered_suggestions = a:suggestions
-        else
-            let l:filtered_suggestions = []
-
-            " Filter suggestions down to those starting with the prefix we
-            " used for finding suggestions in the first place.
-            "
-            " Some completion tools will include suggestions which don't even
-            " start with the characters we have already typed.
-            for l:item in a:suggestions
-                " A List of String values or a List of completion item
-                " Dictionaries is accepted here.
-                let l:word = type(l:item) is v:t_string ? l:item : l:item.word
-
-                " Add suggestions if the suggestion starts with a
-                " case-insensitive match for the prefix.
-                if l:word[: len(a:prefix) - 1] is? a:prefix
-                    call add(l:filtered_suggestions, l:item)
-                endif
-            endfor
-        endif
-    endif
-
-    if !empty(l:excluded_words)
-        " Copy the List if needed. We don't want to modify the argument.
-        " We shouldn't make a copy if we don't need to.
-        if l:filtered_suggestions is a:suggestions
-            let l:filtered_suggestions = copy(a:suggestions)
-        endif
-
-        " Remove suggestions with words in the exclusion List.
-        call filter(
-        \   l:filtered_suggestions,
-        \   'index(l:excluded_words, type(v:val) is v:t_string ? v:val : v:val.word) < 0',
-        \)
-    endif
-
-    return l:filtered_suggestions
-endfunction
-
-function! s:ReplaceCompletionOptions() abort
-    let l:source = get(get(b:, 'ale_completion_info', {}), 'source', '')
-
-    if l:source is# 'ale-automatic' || l:source is# 'ale-manual'
-        " Remember the old omnifunc value, if there is one.
-        " If we don't store an old one, we'll just never reset the option.
-        " This will stop some random exceptions from appearing.
-        if !exists('b:ale_old_omnifunc') && !empty(&l:omnifunc)
-            let b:ale_old_omnifunc = &l:omnifunc
-        endif
-
-        let &l:omnifunc = 'ale#completion#AutomaticOmniFunc'
-    endif
-
-    if l:source is# 'ale-automatic'
-        if !exists('b:ale_old_completeopt')
-            let b:ale_old_completeopt = &l:completeopt
-        endif
-
-        if &l:completeopt =~# 'preview'
-            let &l:completeopt = 'menu,menuone,preview,noselect,noinsert'
-        elseif &l:completeopt =~# 'popup'
-            let &l:completeopt = 'menu,menuone,popup,noselect,noinsert'
-        else
-            let &l:completeopt = 'menu,menuone,noselect,noinsert'
-        endif
-    endif
-endfunction
-
-function! ale#completion#RestoreCompletionOptions() abort
-    " Reset settings when completion is done.
-    if exists('b:ale_old_omnifunc')
-        if b:ale_old_omnifunc isnot# 'pythoncomplete#Complete'
-            let &l:omnifunc = b:ale_old_omnifunc
-        endif
-
-        unlet b:ale_old_omnifunc
-    endif
-
-    if exists('b:ale_old_completeopt')
-        let &l:completeopt = b:ale_old_completeopt
-        unlet b:ale_old_completeopt
-    endif
-endfunction
-
-function! ale#completion#GetCompletionPosition() abort
-    if !exists('b:ale_completion_info')
-        return 0
-    endif
-
-    let l:line = b:ale_completion_info.line
-    let l:column = b:ale_completion_info.column
-    let l:regex = s:GetFiletypeValue(s:omni_start_map, &filetype)
-    let l:up_to_column = getline(l:line)[: l:column - 2]
-    let l:match = matchstr(l:up_to_column, l:regex)
-
-    return l:column - len(l:match) - 1
-endfunction
-
-function! ale#completion#GetCompletionPositionForDeoplete(input) abort
-    return match(a:input, '\k*$')
-endfunction
-
-function! ale#completion#GetCompletionResult() abort
-    if exists('b:ale_completion_result')
-        return b:ale_completion_result
-    endif
-
-    return v:null
-endfunction
-
-function! ale#completion#AutomaticOmniFunc(findstart, base) abort
-    if a:findstart
-        return ale#completion#GetCompletionPosition()
-    else
-        let l:result = ale#completion#GetCompletionResult()
-
-        call s:ReplaceCompletionOptions()
-
-        return l:result isnot v:null ? l:result : []
-    endif
-endfunction
-
-function! ale#completion#Show(result) abort
-    if ale#util#Mode() isnot# 'i'
-        return
-    endif
-
-    " Set the list in the buffer, temporarily replace omnifunc with our
-    " function, and then start omni-completion.
-    let b:ale_completion_result = a:result
-
-    " Don't try to open the completion menu if there's nothing to show.
-    if empty(b:ale_completion_result)
-        return
-    endif
-
-    " Replace completion options shortly before opening the menu.
-    call s:ReplaceCompletionOptions()
-
-    let l:source = get(get(b:, 'ale_completion_info', {}), 'source', '')
-
-    if l:source is# 'ale-automatic' || l:source is# 'ale-manual'
-        call timer_start(
-        \   0,
-        \   {-> ale#util#FeedKeys("\<Plug>(ale_show_completion_menu)")}
-        \)
-    endif
-
-    if l:source is# 'ale-callback'
-        call b:CompleteCallback(b:ale_completion_result)
-    endif
-endfunction
-
-function! ale#completion#GetAllTriggers() abort
-    return deepcopy(s:trigger_character_map)
-endfunction
-
-function! ale#completion#GetCompletionKind(kind) abort
-    let l:lsp_symbol = get(g:ale_lsp_types, a:kind, '')
-
-    if !empty(l:lsp_symbol)
-        return l:lsp_symbol
-    endif
-
-    return get(g:ale_tsserver_types, a:kind, '')
-endfunction
-
-function! ale#completion#GetCompletionSymbols(kind) abort
-    let l:kind = ale#completion#GetCompletionKind(a:kind)
-    let l:symbol = get(g:ale_completion_symbols, l:kind, '')
-
-    if !empty(l:symbol)
-        return l:symbol
-    endif
-
-    return get(g:ale_completion_symbols, '<default>', 'v')
-endfunction
-
-function! s:CompletionStillValid(request_id) abort
-    let [l:line, l:column] = getpos('.')[1:2]
-
-    return ale#util#Mode() is# 'i'
-    \&& has_key(b:, 'ale_completion_info')
-    \&& b:ale_completion_info.request_id == a:request_id
-    \&& b:ale_completion_info.line == l:line
-    \&& (
-    \   b:ale_completion_info.column == l:column
-    \   || b:ale_completion_info.source is# 'ale-omnifunc'
-    \   || b:ale_completion_info.source is# 'ale-callback'
-    \)
-endfunction
-
-function! ale#completion#ParseTSServerCompletions(response) abort
-    let l:names = []
-
-    for l:suggestion in a:response.body
-        call add(l:names, {
-        \ 'word': l:suggestion.name,
-        \ 'source': get(l:suggestion, 'source', ''),
-        \})
-    endfor
-
-    return l:names
-endfunction
-
-function! ale#completion#ParseTSServerCompletionEntryDetails(response) abort
-    let l:buffer = bufnr('')
-    let l:results = []
-    let l:names_with_details = []
-
-    for l:suggestion in a:response.body
-        let l:displayParts = []
-
-        for l:action in get(l:suggestion, 'codeActions', [])
-            call add(l:displayParts, l:action.description . ' ')
-        endfor
-
-        for l:part in l:suggestion.displayParts
-            call add(l:displayParts, l:part.text)
-        endfor
-
-        " Each one of these parts has 'kind' properties
-        let l:documentationParts = []
-
-        for l:part in get(l:suggestion, 'documentation', [])
-            call add(l:documentationParts, l:part.text)
-        endfor
-
-        " See :help complete-items
-        let l:result = {
-        \   'word': l:suggestion.name,
-        \   'kind': ale#completion#GetCompletionSymbols(l:suggestion.kind),
-        \   'icase': 1,
-        \   'menu': join(l:displayParts, ''),
-        \   'dup': g:ale_completion_tsserver_autoimport,
-        \   'info': join(l:documentationParts, ''),
-        \}
-
-        if has_key(l:suggestion, 'codeActions')
-            let l:result.user_data = json_encode({
-            \   'codeActions': l:suggestion.codeActions,
-            \ })
-        endif
-
-        call add(l:results, l:result)
-    endfor
-
-    let l:names = getbufvar(l:buffer, 'ale_tsserver_completion_names', [])
-
-    if !empty(l:names) && len(l:names) != len(l:results)
-        let l:names_with_details = map(copy(l:results), 'v:val.word')
-        let l:missing_names = filter(
-        \   copy(l:names),
-        \   'index(l:names_with_details, v:val.word) < 0',
-        \)
-
-        for l:name in l:missing_names
-            call add(l:results, {
-            \   'word': l:name.word,
-            \   'kind': 'v',
-            \   'icase': 1,
-            \   'menu': '',
-            \   'info': '',
-            \})
-        endfor
-    endif
-
-    return l:results
-endfunction
-
-function! ale#completion#NullFilter(buffer, item) abort
-    return 1
-endfunction
-
-function! ale#completion#ParseLSPCompletions(response) abort
-    let l:buffer = bufnr('')
-    let l:info = get(b:, 'ale_completion_info', {})
-    let l:Filter = get(l:info, 'completion_filter', v:null)
-
-    if l:Filter is v:null
-        let l:Filter = function('ale#completion#NullFilter')
-    else
-        let l:Filter = ale#util#GetFunction(l:Filter)
-    endif
-
-    let l:item_list = []
-
-    if type(get(a:response, 'result')) is v:t_list
-        let l:item_list = a:response.result
-    elseif type(get(a:response, 'result')) is v:t_dict
-    \&& type(get(a:response.result, 'items')) is v:t_list
-        let l:item_list = a:response.result.items
-    endif
-
-    let l:results = []
-
-    for l:item in l:item_list
-        if !call(l:Filter, [l:buffer, l:item])
-            continue
-        endif
-
-        if get(l:item, 'insertTextFormat') is s:LSP_INSERT_TEXT_FORMAT_PLAIN
-        \&& type(get(l:item, 'textEdit')) is v:t_dict
-            let l:text = l:item.textEdit.newText
-        elseif type(get(l:item, 'insertText')) is v:t_string
-            let l:text = l:item.insertText
-        else
-            let l:text = l:item.label
-        endif
-
-        let l:word = matchstr(l:text, '\v^[^(]+')
-
-        if empty(l:word)
-            continue
-        endif
-
-        let l:doc = get(l:item, 'documentation', '')
-
-        if type(l:doc) is v:t_dict && has_key(l:doc, 'value')
-            let l:doc = l:doc.value
-        endif
-
-        call add(l:results, {
-        \   'word': l:word,
-        \   'kind': ale#completion#GetCompletionSymbols(get(l:item, 'kind', '')),
-        \   'icase': 1,
-        \   'menu': get(l:item, 'detail', ''),
-        \   'info': (type(l:doc) is v:t_string ? l:doc : ''),
-        \})
-    endfor
-
-    if has_key(l:info, 'prefix')
-        let l:results = ale#completion#Filter(l:buffer, &filetype, l:results, l:info.prefix)
-    endif
-
-    return l:results[: g:ale_completion_max_suggestions - 1]
-endfunction
-
-function! ale#completion#HandleTSServerResponse(conn_id, response) abort
-    if !s:CompletionStillValid(get(a:response, 'request_seq'))
-        return
-    endif
-
-    if !has_key(a:response, 'body')
-        return
-    endif
-
-    let l:buffer = bufnr('')
-    let l:command = get(a:response, 'command', '')
-
-    if l:command is# 'completions'
-        let l:names = ale#completion#Filter(
-        \   l:buffer,
-        \   &filetype,
-        \   ale#completion#ParseTSServerCompletions(a:response),
-        \   b:ale_completion_info.prefix,
-        \)[: g:ale_completion_max_suggestions - 1]
-
-        " We need to remember some names for tsserver, as it doesn't send
-        " details back for everything we send.
-        call setbufvar(l:buffer, 'ale_tsserver_completion_names', l:names)
-
-        if !empty(l:names)
-            let l:identifiers = []
-
-            for l:name in l:names
-                let l:identifier = {
-                \   'name': l:name.word,
-                \}
-                let l:source = get(l:name, 'source', '')
-
-                " Empty source results in no details for the completed item
-                if !empty(l:source)
-                    call extend(l:identifier, { 'source': l:source })
-                endif
-
-                call add(l:identifiers, l:identifier)
-            endfor
-
-            let b:ale_completion_info.request_id = ale#lsp#Send(
-            \   b:ale_completion_info.conn_id,
-            \   ale#lsp#tsserver_message#CompletionEntryDetails(
-            \       l:buffer,
-            \       b:ale_completion_info.line,
-            \       b:ale_completion_info.column,
-            \       l:identifiers,
-            \   ),
-            \)
-        endif
-    elseif l:command is# 'completionEntryDetails'
-        call ale#completion#Show(
-        \   ale#completion#ParseTSServerCompletionEntryDetails(a:response),
-        \)
-    endif
-endfunction
-
-
-function! ale#completion#HandleLSPResponse(conn_id, response) abort
-    if !s:CompletionStillValid(get(a:response, 'id'))
-        return
-    endif
-
-    call ale#completion#Show(
-    \   ale#completion#ParseLSPCompletions(a:response),
-    \)
-endfunction
-
-function! s:OnReady(linter, lsp_details) abort
-    let l:id = a:lsp_details.connection_id
-
-    if !ale#lsp#HasCapability(l:id, 'completion')
-        return
-    endif
-
-    let l:buffer = a:lsp_details.buffer
-
-    " If we have sent a completion request already, don't send another.
-    if b:ale_completion_info.request_id
-        return
-    endif
-
-    let l:Callback = a:linter.lsp is# 'tsserver'
-    \   ? function('ale#completion#HandleTSServerResponse')
-    \   : function('ale#completion#HandleLSPResponse')
-    call ale#lsp#RegisterCallback(l:id, l:Callback)
-
-    if a:linter.lsp is# 'tsserver'
-        let l:message = ale#lsp#tsserver_message#Completions(
-        \   l:buffer,
-        \   b:ale_completion_info.line,
-        \   b:ale_completion_info.column,
-        \   b:ale_completion_info.prefix,
-        \   g:ale_completion_tsserver_autoimport,
-        \)
-    else
-        " Send a message saying the buffer has changed first, otherwise
-        " completions won't know what text is nearby.
-        call ale#lsp#NotifyForChanges(l:id, l:buffer)
-
-        " For LSP completions, we need to clamp the column to the length of
-        " the line. python-language-server and perhaps others do not implement
-        " this correctly.
-        let l:message = ale#lsp#message#Completion(
-        \   l:buffer,
-        \   b:ale_completion_info.line,
-        \   b:ale_completion_info.column,
-        \   ale#completion#GetTriggerCharacter(&filetype, b:ale_completion_info.prefix),
-        \)
-    endif
-
-    let l:request_id = ale#lsp#Send(l:id, l:message)
-
-    if l:request_id
-        let b:ale_completion_info.conn_id = l:id
-        let b:ale_completion_info.request_id = l:request_id
-
-        if has_key(a:linter, 'completion_filter')
-            let b:ale_completion_info.completion_filter = a:linter.completion_filter
-        endif
-    endif
-endfunction
-
-" This function can be called to check if ALE can provide completion data for
-" the current buffer. 1 will be returned if there's a potential source of
-" completion data ALE can use, and 0 will be returned otherwise.
-function! ale#completion#CanProvideCompletions() abort
-    for l:linter in ale#linter#Get(&filetype)
-        if !empty(l:linter.lsp)
-            return 1
-        endif
-    endfor
-
-    return 0
-endfunction
-
-" This function can be used to manually trigger autocomplete, even when
-" g:ale_completion_enabled is set to false
-function! ale#completion#GetCompletions(...) abort
-    let l:source = get(a:000, 0, '')
-    let l:options = get(a:000, 1, {})
-
-    if len(a:000) > 2
-        throw 'Too many arguments!'
-    endif
-
-    let l:CompleteCallback = get(l:options, 'callback', v:null)
-
-    if l:CompleteCallback isnot v:null
-        let b:CompleteCallback = l:CompleteCallback
-    endif
-
-    let [l:line, l:column] = getpos('.')[1:2]
-
-    let l:prefix = ale#completion#GetPrefix(&filetype, l:line, l:column)
-
-    if l:source is# 'ale-automatic' && empty(l:prefix)
-        return 0
-    endif
-
-    let l:line_length = len(getline('.'))
-
-    let b:ale_completion_info = {
-    \   'line': l:line,
-    \   'line_length': l:line_length,
-    \   'column': l:column,
-    \   'prefix': l:prefix,
-    \   'conn_id': 0,
-    \   'request_id': 0,
-    \   'source': l:source,
-    \}
-    unlet! b:ale_completion_result
-
-    let l:buffer = bufnr('')
-    let l:Callback = function('s:OnReady')
-
-    let l:started = 0
-
-    for l:linter in ale#linter#Get(&filetype)
-        if !empty(l:linter.lsp)
-            if ale#lsp_linter#StartLSP(l:buffer, l:linter, l:Callback)
-                let l:started = 1
-            endif
-        endif
-    endfor
-
-    return l:started
-endfunction
-
-function! ale#completion#OmniFunc(findstart, base) abort
-    if a:findstart
-        let l:started = ale#completion#GetCompletions('ale-omnifunc')
-
-        if !l:started
-            " This is the special value for cancelling completions silently.
-            " See :help complete-functions
-            return -3
-        endif
-
-        return ale#completion#GetCompletionPosition()
-    else
-        let l:result = ale#completion#GetCompletionResult()
-
-        while l:result is v:null && !complete_check()
-            sleep 2ms
-            let l:result = ale#completion#GetCompletionResult()
-        endwhile
-
-        return l:result isnot v:null ? l:result : []
-    endif
-endfunction
-
-function! s:TimerHandler(...) abort
-    if !get(b:, 'ale_completion_enabled', g:ale_completion_enabled)
-        return
-    endif
-
-    let s:timer_id = -1
-
-    let [l:line, l:column] = getpos('.')[1:2]
-
-    " When running the timer callback, we have to be sure that the cursor
-    " hasn't moved from where it was when we requested completions by typing.
-    if s:timer_pos == [l:line, l:column] && ale#util#Mode() is# 'i'
-        call ale#completion#GetCompletions('ale-automatic')
-    endif
-endfunction
-
-" Stop any completion timer that is queued. This is useful for tests.
-function! ale#completion#StopTimer() abort
-    if s:timer_id != -1
-        call timer_stop(s:timer_id)
-    endif
-
-    let s:timer_id = -1
-endfunction
-
-function! ale#completion#Queue() abort
-    if !get(b:, 'ale_completion_enabled', g:ale_completion_enabled)
-        return
-    endif
-
-    let s:timer_pos = getpos('.')[1:2]
-
-    if s:timer_pos == s:last_done_pos
-        " Do not ask for completions if the cursor rests on the position we
-        " last completed on.
-        return
-    endif
-
-    " If we changed the text again while we're still waiting for a response,
-    " then invalidate the requests before the timer ticks again.
-    if exists('b:ale_completion_info')
-        let b:ale_completion_info.request_id = 0
-    endif
-
-    call ale#completion#StopTimer()
-
-    let s:timer_id = timer_start(g:ale_completion_delay, function('s:TimerHandler'))
-endfunction
-
-function! ale#completion#HandleUserData(completed_item) abort
-    let l:source = get(get(b:, 'ale_completion_info', {}), 'source', '')
-
-    if l:source isnot# 'ale-automatic'
-    \&& l:source isnot# 'ale-manual'
-    \&& l:source isnot# 'ale-callback'
-        return
-    endif
-
-    let l:user_data_json = get(a:completed_item, 'user_data', '')
-
-    if empty(l:user_data_json)
-        return
-    endif
-
-    let l:user_data = json_decode(l:user_data_json)
-
-    if type(l:user_data) isnot v:t_dict
-        return
-    endif
-
-    for l:code_action in get(l:user_data, 'codeActions', [])
-        call ale#code_action#HandleCodeAction(l:code_action, v:false)
-    endfor
-endfunction
-
-function! ale#completion#Done() abort
-    silent! pclose
-
-    call ale#completion#RestoreCompletionOptions()
-
-    let s:last_done_pos = getpos('.')[1:2]
-endfunction
-
-augroup ALECompletionActions
-    autocmd CompleteDone * call ale#completion#HandleUserData(v:completed_item)
-augroup END
-
-function! s:Setup(enabled) abort
-    augroup ALECompletionGroup
-        autocmd!
-
-        if a:enabled
-            autocmd TextChangedI * call ale#completion#Queue()
-            autocmd CompleteDone * call ale#completion#Done()
-        endif
-    augroup END
-
-    if !a:enabled
-        augroup! ALECompletionGroup
-    endif
-endfunction
-
-function! ale#completion#Enable() abort
-    let g:ale_completion_enabled = 1
-    call s:Setup(1)
-endfunction
-
-function! ale#completion#Disable() abort
-    let g:ale_completion_enabled = 0
-    call s:Setup(0)
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/completion/python.vim b/sources_non_forked/ale/autoload/ale/completion/python.vim
deleted file mode 100644
index 6b65c5b..0000000
--- a/sources_non_forked/ale/autoload/ale/completion/python.vim
+++ /dev/null
@@ -1,3 +0,0 @@
-function! ale#completion#python#CompletionItemFilter(buffer, item) abort
-    return a:item.label !~# '\v^__[a-z_]+__'
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/cursor.vim b/sources_non_forked/ale/autoload/ale/cursor.vim
deleted file mode 100644
index 8c331c5..0000000
--- a/sources_non_forked/ale/autoload/ale/cursor.vim
+++ /dev/null
@@ -1,167 +0,0 @@
-scriptencoding utf-8
-" Author: w0rp <devw0rp@gmail.com>
-" Author: Joo Paulo S. de Souza <joao.paulo.silvasouza@hotmail.com>
-" Description: Echoes lint message for the current line, if any
-
-" Controls the milliseconds delay before echoing a message.
-let g:ale_echo_delay = get(g:, 'ale_echo_delay', 10)
-" A string format for the echoed message.
-let g:ale_echo_msg_format = get(g:, 'ale_echo_msg_format', '%code: %%s')
-
-let s:cursor_timer = -1
-let s:last_pos = [0, 0, 0]
-
-function! ale#cursor#TruncatedEcho(original_message) abort
-    let l:message = a:original_message
-    " Change tabs to spaces.
-    let l:message = substitute(l:message, "\t", ' ', 'g')
-    " Remove any newlines in the message.
-    let l:message = substitute(l:message, "\n", '', 'g')
-
-    " We need to remember the setting for shortmess and reset it again.
-    let l:shortmess_options = &l:shortmess
-
-    try
-        let l:cursor_position = getpos('.')
-
-        " The message is truncated and saved to the history.
-        silent! setlocal shortmess+=T
-
-        try
-            exec "norm! :echomsg l:message\n"
-        catch /^Vim\%((\a\+)\)\=:E523/
-            " Fallback into manual truncate (#1987)
-            let l:winwidth = winwidth(0)
-
-            if l:winwidth < strdisplaywidth(l:message)
-                " Truncate message longer than window width with trailing '...'
-                let l:message = l:message[:l:winwidth - 4] . '...'
-            endif
-
-            exec 'echomsg l:message'
-        endtry
-
-        " Reset the cursor position if we moved off the end of the line.
-        " Using :norm and :echomsg can move the cursor off the end of the
-        " line.
-        if l:cursor_position != getpos('.')
-            call setpos('.', l:cursor_position)
-        endif
-    finally
-        let &l:shortmess = l:shortmess_options
-    endtry
-endfunction
-
-function! s:StopCursorTimer() abort
-    if s:cursor_timer != -1
-        call timer_stop(s:cursor_timer)
-        let s:cursor_timer = -1
-    endif
-endfunction
-
-function! ale#cursor#EchoCursorWarning(...) abort
-    let l:buffer = bufnr('')
-
-    if !g:ale_echo_cursor && !g:ale_cursor_detail
-        return
-    endif
-
-    " Only echo the warnings in normal mode, otherwise we will get problems.
-    if mode(1) isnot# 'n'
-        return
-    endif
-
-    if ale#ShouldDoNothing(l:buffer)
-        return
-    endif
-
-    let [l:info, l:loc] = ale#util#FindItemAtCursor(l:buffer)
-
-    if g:ale_echo_cursor
-        if !empty(l:loc)
-            let l:format = ale#Var(l:buffer, 'echo_msg_format')
-            let l:msg = ale#GetLocItemMessage(l:loc, l:format)
-            call ale#cursor#TruncatedEcho(l:msg)
-            let l:info.echoed = 1
-        elseif get(l:info, 'echoed')
-            " We'll only clear the echoed message when moving off errors once,
-            " so we don't continually clear the echo line.
-            execute 'echo'
-            let l:info.echoed = 0
-        endif
-    endif
-
-    if g:ale_cursor_detail
-        if !empty(l:loc)
-            call s:ShowCursorDetailForItem(l:loc, {'stay_here': 1})
-        else
-            call ale#preview#CloseIfTypeMatches('ale-preview')
-        endif
-    endif
-endfunction
-
-function! ale#cursor#EchoCursorWarningWithDelay() abort
-    let l:buffer = bufnr('')
-
-    if !g:ale_echo_cursor && !g:ale_cursor_detail
-        return
-    endif
-
-    " Only echo the warnings in normal mode, otherwise we will get problems.
-    if mode(1) isnot# 'n'
-        return
-    endif
-
-    call s:StopCursorTimer()
-
-    let l:pos = getpos('.')[0:2]
-
-    " Check the current buffer, line, and column number against the last
-    " recorded position. If the position has actually changed, *then*
-    " we should echo something. Otherwise we can end up doing processing
-    " the echo message far too frequently.
-    if l:pos != s:last_pos
-        let l:delay = ale#Var(l:buffer, 'echo_delay')
-
-        let s:last_pos = l:pos
-        let s:cursor_timer = timer_start(
-        \   l:delay,
-        \   function('ale#cursor#EchoCursorWarning')
-        \)
-    endif
-endfunction
-
-function! s:ShowCursorDetailForItem(loc, options) abort
-    let l:stay_here = get(a:options, 'stay_here', 0)
-
-    let s:last_detailed_line = line('.')
-    let l:message = get(a:loc, 'detail', a:loc.text)
-    let l:lines = split(l:message, "\n")
-    call ale#preview#Show(l:lines, {'stay_here': l:stay_here})
-
-    " Clear the echo message if we manually displayed details.
-    if !l:stay_here
-        execute 'echo'
-    endif
-endfunction
-
-function! ale#cursor#ShowCursorDetail() abort
-    let l:buffer = bufnr('')
-
-    " Only echo the warnings in normal mode, otherwise we will get problems.
-    if mode() isnot# 'n'
-        return
-    endif
-
-    if ale#ShouldDoNothing(l:buffer)
-        return
-    endif
-
-    call s:StopCursorTimer()
-
-    let [l:info, l:loc] = ale#util#FindItemAtCursor(l:buffer)
-
-    if !empty(l:loc)
-        call s:ShowCursorDetailForItem(l:loc, {'stay_here': 0})
-    endif
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/d.vim b/sources_non_forked/ale/autoload/ale/d.vim
deleted file mode 100644
index 0e23220..0000000
--- a/sources_non_forked/ale/autoload/ale/d.vim
+++ /dev/null
@@ -1,16 +0,0 @@
-" Author: Auri <me@aurieh.me>
-" Description: Functions for integrating with D linters.
-
-function! ale#d#FindDUBConfig(buffer) abort
-    " Find a DUB configuration file in ancestor paths.
-    " The most DUB-specific names will be tried first.
-    for l:possible_filename in ['dub.sdl', 'dub.json', 'package.json']
-        let l:dub_file = ale#path#FindNearestFile(a:buffer, l:possible_filename)
-
-        if !empty(l:dub_file)
-            return l:dub_file
-        endif
-    endfor
-
-    return ''
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/debugging.vim b/sources_non_forked/ale/autoload/ale/debugging.vim
deleted file mode 100644
index 4e134f8..0000000
--- a/sources_non_forked/ale/autoload/ale/debugging.vim
+++ /dev/null
@@ -1,266 +0,0 @@
-" Author: w0rp <devw0rp@gmail.com>
-" Description: This file implements debugging information for ALE
-
-let s:global_variable_list = [
-\    'ale_cache_executable_check_failures',
-\    'ale_change_sign_column_color',
-\    'ale_command_wrapper',
-\    'ale_completion_delay',
-\    'ale_completion_enabled',
-\    'ale_completion_max_suggestions',
-\    'ale_echo_cursor',
-\    'ale_echo_msg_error_str',
-\    'ale_echo_msg_format',
-\    'ale_echo_msg_info_str',
-\    'ale_echo_msg_warning_str',
-\    'ale_enabled',
-\    'ale_fix_on_save',
-\    'ale_fixers',
-\    'ale_history_enabled',
-\    'ale_history_log_output',
-\    'ale_keep_list_window_open',
-\    'ale_lint_delay',
-\    'ale_lint_on_enter',
-\    'ale_lint_on_filetype_changed',
-\    'ale_lint_on_insert_leave',
-\    'ale_lint_on_save',
-\    'ale_lint_on_text_changed',
-\    'ale_linter_aliases',
-\    'ale_linters',
-\    'ale_linters_explicit',
-\    'ale_list_vertical',
-\    'ale_list_window_size',
-\    'ale_loclist_msg_format',
-\    'ale_lsp_root',
-\    'ale_max_buffer_history_size',
-\    'ale_max_signs',
-\    'ale_maximum_file_size',
-\    'ale_open_list',
-\    'ale_pattern_options',
-\    'ale_pattern_options_enabled',
-\    'ale_set_balloons',
-\    'ale_set_highlights',
-\    'ale_set_loclist',
-\    'ale_set_quickfix',
-\    'ale_set_signs',
-\    'ale_sign_column_always',
-\    'ale_sign_error',
-\    'ale_sign_info',
-\    'ale_sign_offset',
-\    'ale_sign_style_error',
-\    'ale_sign_style_warning',
-\    'ale_sign_warning',
-\    'ale_sign_highlight_linenrs',
-\    'ale_statusline_format',
-\    'ale_type_map',
-\    'ale_use_global_executables',
-\    'ale_virtualtext_cursor',
-\    'ale_warn_about_trailing_blank_lines',
-\    'ale_warn_about_trailing_whitespace',
-\]
-
-function! s:Echo(message) abort
-    execute 'echo a:message'
-endfunction
-
-function! s:GetLinterVariables(filetype, exclude_linter_names) abort
-    let l:variable_list = []
-    let l:filetype_parts = split(a:filetype, '\.')
-
-    for l:key in keys(g:)
-        " Extract variable names like: 'ale_python_flake8_executable'
-        let l:match = matchlist(l:key, '\v^ale_([^_]+)_([^_]+)_.+$')
-
-        " Include matching variables.
-        if !empty(l:match)
-        \&& index(l:filetype_parts, l:match[1]) >= 0
-        \&& index(a:exclude_linter_names, l:match[2]) == -1
-            call add(l:variable_list, l:key)
-        endif
-    endfor
-
-    call sort(l:variable_list)
-
-    return l:variable_list
-endfunction
-
-function! s:EchoLinterVariables(variable_list) abort
-    for l:key in a:variable_list
-        call s:Echo('let g:' . l:key . ' = ' . string(g:[l:key]))
-
-        if has_key(b:, l:key)
-            call s:Echo('let b:' . l:key . ' = ' . string(b:[l:key]))
-        endif
-    endfor
-endfunction
-
-function! s:EchoGlobalVariables() abort
-    for l:key in s:global_variable_list
-        call s:Echo('let g:' . l:key . ' = ' . string(get(g:, l:key, v:null)))
-
-        if has_key(b:, l:key)
-            call s:Echo('let b:' . l:key . ' = ' . string(b:[l:key]))
-        endif
-    endfor
-endfunction
-
-" Echo a command that was run.
-function! s:EchoCommand(item) abort
-    let l:status_message = a:item.status
-
-    " Include the exit code in output if we have it.
-    if a:item.status is# 'finished'
-        let l:status_message .= ' - exit code ' . a:item.exit_code
-    endif
-
-    call s:Echo('(' . l:status_message . ') ' . string(a:item.command))
-
-    if g:ale_history_log_output && has_key(a:item, 'output')
-        if empty(a:item.output)
-            call s:Echo('')
-            call s:Echo('<<<NO OUTPUT RETURNED>>>')
-            call s:Echo('')
-        else
-            call s:Echo('')
-            call s:Echo('<<<OUTPUT STARTS>>>')
-
-            for l:line in a:item.output
-                call s:Echo(l:line)
-            endfor
-
-            call s:Echo('<<<OUTPUT ENDS>>>')
-            call s:Echo('')
-        endif
-    endif
-endfunction
-
-" Echo the results of an executable check.
-function! s:EchoExecutable(item) abort
-    call s:Echo(printf(
-    \   '(executable check - %s) %s',
-    \   a:item.status ? 'success' : 'failure',
-    \   a:item.command,
-    \))
-endfunction
-
-function! s:EchoCommandHistory() abort
-    let l:buffer = bufnr('%')
-
-    for l:item in ale#history#Get(l:buffer)
-        if l:item.job_id is# 'executable'
-            call s:EchoExecutable(l:item)
-        else
-            call s:EchoCommand(l:item)
-        endif
-    endfor
-endfunction
-
-function! s:EchoLinterAliases(all_linters) abort
-    let l:first = 1
-
-    for l:linter in a:all_linters
-        if !empty(l:linter.aliases)
-            if l:first
-                call s:Echo('   Linter Aliases:')
-            endif
-
-            let l:first = 0
-
-            call s:Echo(string(l:linter.name) . ' -> ' . string(l:linter.aliases))
-        endif
-    endfor
-endfunction
-
-function! s:EchoLSPErrorMessages(all_linter_names) abort
-    let l:lsp_error_messages = get(g:, 'ale_lsp_error_messages', {})
-    let l:header_echoed = 0
-
-    for l:linter_name in a:all_linter_names
-        let l:error_list = get(l:lsp_error_messages, l:linter_name, [])
-
-        if !empty(l:error_list)
-            if !l:header_echoed
-                call s:Echo(' LSP Error Messages:')
-                call s:Echo('')
-            endif
-
-            call s:Echo('(Errors for ' . l:linter_name . ')')
-
-            for l:message in l:error_list
-                for l:line in split(l:message, "\n")
-                    call s:Echo(l:line)
-                endfor
-            endfor
-        endif
-    endfor
-endfunction
-
-function! ale#debugging#Info() abort
-    let l:filetype = &filetype
-
-    " We get the list of enabled linters for free by the above function.
-    let l:enabled_linters = deepcopy(ale#linter#Get(l:filetype))
-
-    " But have to build the list of available linters ourselves.
-    let l:all_linters = []
-    let l:linter_variable_list = []
-
-    for l:part in split(l:filetype, '\.')
-        let l:aliased_filetype = ale#linter#ResolveFiletype(l:part)
-        call extend(l:all_linters, ale#linter#GetAll(l:aliased_filetype))
-    endfor
-
-    let l:all_names = map(copy(l:all_linters), 'v:val[''name'']')
-    let l:enabled_names = map(copy(l:enabled_linters), 'v:val[''name'']')
-    let l:exclude_names = filter(copy(l:all_names), 'index(l:enabled_names, v:val) == -1')
-
-    " Load linter variables to display
-    " This must be done after linters are loaded.
-    let l:variable_list = s:GetLinterVariables(l:filetype, l:exclude_names)
-
-    let l:fixers = ale#fix#registry#SuggestedFixers(l:filetype)
-    let l:fixers = uniq(sort(l:fixers[0] + l:fixers[1]))
-    let l:fixers_string = join(map(copy(l:fixers), '"\n  " . v:val'), '')
-
-    call s:Echo(' Current Filetype: ' . l:filetype)
-    call s:Echo('Available Linters: ' . string(l:all_names))
-    call s:EchoLinterAliases(l:all_linters)
-    call s:Echo('  Enabled Linters: ' . string(l:enabled_names))
-    call s:Echo(' Suggested Fixers: ' . l:fixers_string)
-    call s:Echo(' Linter Variables:')
-    call s:Echo('')
-    call s:EchoLinterVariables(l:variable_list)
-    call s:Echo(' Global Variables:')
-    call s:Echo('')
-    call s:EchoGlobalVariables()
-    call s:EchoLSPErrorMessages(l:all_names)
-    call s:Echo('  Command History:')
-    call s:Echo('')
-    call s:EchoCommandHistory()
-endfunction
-
-function! ale#debugging#InfoToClipboard() abort
-    if !has('clipboard')
-        call s:Echo('clipboard not available. Try :ALEInfoToFile instead.')
-
-        return
-    endif
-
-    redir => l:output
-        silent call ale#debugging#Info()
-    redir END
-
-    let @+ = l:output
-    call s:Echo('ALEInfo copied to your clipboard')
-endfunction
-
-function! ale#debugging#InfoToFile(filename) abort
-    let l:expanded_filename = expand(a:filename)
-
-    redir => l:output
-        silent call ale#debugging#Info()
-    redir END
-
-    call writefile(split(l:output, "\n"), l:expanded_filename)
-    call s:Echo('ALEInfo written to ' . l:expanded_filename)
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/definition.vim b/sources_non_forked/ale/autoload/ale/definition.vim
deleted file mode 100644
index ffcd9d1..0000000
--- a/sources_non_forked/ale/autoload/ale/definition.vim
+++ /dev/null
@@ -1,195 +0,0 @@
-" Author: w0rp <devw0rp@gmail.com>
-" Description: Go to definition support for LSP linters.
-
-let s:go_to_definition_map = {}
-
-" Enable automatic updates of the tagstack
-let g:ale_update_tagstack = get(g:, 'ale_update_tagstack', 1)
-let g:ale_default_navigation = get(g:, 'ale_default_navigation', 'buffer')
-
-" Used to get the definition map in tests.
-function! ale#definition#GetMap() abort
-    return deepcopy(s:go_to_definition_map)
-endfunction
-
-" Used to set the definition map in tests.
-function! ale#definition#SetMap(map) abort
-    let s:go_to_definition_map = a:map
-endfunction
-
-function! ale#definition#ClearLSPData() abort
-    let s:go_to_definition_map = {}
-endfunction
-
-function! ale#definition#UpdateTagStack() abort
-    let l:should_update_tagstack = exists('*gettagstack') && exists('*settagstack') && g:ale_update_tagstack
-
-    if l:should_update_tagstack
-        " Grab the old location (to jump back to) and the word under the
-        " cursor (as a label for the tagstack)
-        let l:old_location = [bufnr('%'), line('.'), col('.'), 0]
-        let l:tagname = expand('<cword>')
-        let l:winid = win_getid()
-        call settagstack(l:winid, {'items': [{'from': l:old_location, 'tagname': l:tagname}]}, 'a')
-        call settagstack(l:winid, {'curidx': len(gettagstack(l:winid)['items']) + 1})
-    endif
-endfunction
-
-function! ale#definition#HandleTSServerResponse(conn_id, response) abort
-    if get(a:response, 'command', '') is# 'definition'
-    \&& has_key(s:go_to_definition_map, a:response.request_seq)
-        let l:options = remove(s:go_to_definition_map, a:response.request_seq)
-
-        if get(a:response, 'success', v:false) is v:true && !empty(a:response.body)
-            let l:filename = a:response.body[0].file
-            let l:line = a:response.body[0].start.line
-            let l:column = a:response.body[0].start.offset
-
-            call ale#definition#UpdateTagStack()
-            call ale#util#Open(l:filename, l:line, l:column, l:options)
-        endif
-    endif
-endfunction
-
-function! ale#definition#HandleLSPResponse(conn_id, response) abort
-    if has_key(a:response, 'id')
-    \&& has_key(s:go_to_definition_map, a:response.id)
-        let l:options = remove(s:go_to_definition_map, a:response.id)
-
-        " The result can be a Dictionary item, a List of the same, or null.
-        let l:result = get(a:response, 'result', v:null)
-
-        if type(l:result) is v:t_dict
-            let l:result = [l:result]
-        elseif type(l:result) isnot v:t_list
-            let l:result = []
-        endif
-
-        for l:item in l:result
-            let l:filename = ale#path#FromURI(l:item.uri)
-            let l:line = l:item.range.start.line + 1
-            let l:column = l:item.range.start.character + 1
-
-            call ale#definition#UpdateTagStack()
-            call ale#util#Open(l:filename, l:line, l:column, l:options)
-            break
-        endfor
-    endif
-endfunction
-
-function! s:OnReady(line, column, options, capability, linter, lsp_details) abort
-    let l:id = a:lsp_details.connection_id
-
-    if !ale#lsp#HasCapability(l:id, a:capability)
-        return
-    endif
-
-    let l:buffer = a:lsp_details.buffer
-
-    let l:Callback = a:linter.lsp is# 'tsserver'
-    \   ? function('ale#definition#HandleTSServerResponse')
-    \   : function('ale#definition#HandleLSPResponse')
-    call ale#lsp#RegisterCallback(l:id, l:Callback)
-
-    if a:linter.lsp is# 'tsserver'
-        let l:message = ale#lsp#tsserver_message#Definition(
-        \   l:buffer,
-        \   a:line,
-        \   a:column
-        \)
-    else
-        " Send a message saying the buffer has changed first, or the
-        " definition position probably won't make sense.
-        call ale#lsp#NotifyForChanges(l:id, l:buffer)
-
-        " For LSP completions, we need to clamp the column to the length of
-        " the line. python-language-server and perhaps others do not implement
-        " this correctly.
-        if a:capability is# 'definition'
-            let l:message = ale#lsp#message#Definition(l:buffer, a:line, a:column)
-        elseif a:capability is# 'typeDefinition'
-            let l:message = ale#lsp#message#TypeDefinition(l:buffer, a:line, a:column)
-        else
-            " XXX: log here?
-            return
-        endif
-    endif
-
-    let l:request_id = ale#lsp#Send(l:id, l:message)
-
-    let s:go_to_definition_map[l:request_id] = {
-    \   'open_in': get(a:options, 'open_in', 'current-buffer'),
-    \}
-endfunction
-
-function! s:GoToLSPDefinition(linter, options, capability) abort
-    let l:buffer = bufnr('')
-    let [l:line, l:column] = getpos('.')[1:2]
-    let l:column = min([l:column, len(getline(l:line))])
-
-    let l:Callback = function(
-    \   's:OnReady',
-    \   [l:line, l:column, a:options, a:capability]
-    \)
-    call ale#lsp_linter#StartLSP(l:buffer, a:linter, l:Callback)
-endfunction
-
-function! ale#definition#GoTo(options) abort
-    if !get(g:, 'ale_ignore_2_7_warnings') && has_key(a:options, 'deprecated_command')
-        execute 'echom '':' . a:options.deprecated_command . ' is deprecated. Use `let g:ale_ignore_2_7_warnings = 1` to disable this message.'''
-    endif
-
-    for l:linter in ale#linter#Get(&filetype)
-        if !empty(l:linter.lsp)
-            call s:GoToLSPDefinition(l:linter, a:options, 'definition')
-        endif
-    endfor
-endfunction
-
-function! ale#definition#GoToType(options) abort
-    if !get(g:, 'ale_ignore_2_7_warnings') && has_key(a:options, 'deprecated_command')
-        execute 'echom '':' . a:options.deprecated_command . ' is deprecated. Use `let g:ale_ignore_2_7_warnings = 1` to disable this message.'''
-    endif
-
-    for l:linter in ale#linter#Get(&filetype)
-        if !empty(l:linter.lsp)
-            " TODO: handle typeDefinition for tsserver if supported by the
-            " protocol
-            if l:linter.lsp is# 'tsserver'
-                continue
-            endif
-
-            call s:GoToLSPDefinition(l:linter, a:options, 'typeDefinition')
-        endif
-    endfor
-endfunction
-
-function! ale#definition#GoToCommandHandler(command, ...) abort
-    let l:options = {}
-
-    if len(a:000) > 0
-        for l:option in a:000
-            if l:option is? '-tab'
-                let l:options.open_in = 'tab'
-            elseif l:option is? '-split'
-                let l:options.open_in = 'split'
-            elseif l:option is? '-vsplit'
-                let l:options.open_in = 'vsplit'
-            endif
-        endfor
-    endif
-
-    if !has_key(l:options, 'open_in')
-        let l:default_navigation = ale#Var(bufnr(''), 'default_navigation')
-
-        if index(['tab', 'split', 'vsplit'], l:default_navigation) >= 0
-            let l:options.open_in = l:default_navigation
-        endif
-    endif
-
-    if a:command is# 'type'
-        call ale#definition#GoToType(l:options)
-    else
-        call ale#definition#GoTo(l:options)
-    endif
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/engine.vim b/sources_non_forked/ale/autoload/ale/engine.vim
deleted file mode 100644
index 491d3c2..0000000
--- a/sources_non_forked/ale/autoload/ale/engine.vim
+++ /dev/null
@@ -1,733 +0,0 @@
-" Author: w0rp <devw0rp@gmail.com>
-" Description: Backend execution and job management
-"   Executes linters in the background, using NeoVim or Vim 8 jobs
-
-" Remapping of linter problems.
-let g:ale_type_map = get(g:, 'ale_type_map', {})
-
-if !has_key(s:, 'executable_cache_map')
-    let s:executable_cache_map = {}
-endif
-
-function! ale#engine#CleanupEveryBuffer() abort
-    for l:key in keys(g:ale_buffer_info)
-        " The key could be a filename or a buffer number, so try and
-        " convert it to a number. We need a number for the other
-        " functions.
-        let l:buffer = str2nr(l:key)
-
-        if l:buffer > 0
-            " Stop all jobs and clear the results for everything, and delete
-            " all of the data we stored for the buffer.
-            call ale#engine#Cleanup(l:buffer)
-        endif
-    endfor
-endfunction
-
-function! ale#engine#MarkLinterActive(info, linter) abort
-    let l:found = 0
-
-    for l:other_linter in a:info.active_linter_list
-        if l:other_linter.name is# a:linter.name
-            let l:found = 1
-            break
-        endif
-    endfor
-
-    if !l:found
-        call add(a:info.active_linter_list, a:linter)
-    endif
-endfunction
-
-function! ale#engine#MarkLinterInactive(info, linter_name) abort
-    call filter(a:info.active_linter_list, 'v:val.name isnot# a:linter_name')
-endfunction
-
-function! ale#engine#ResetExecutableCache() abort
-    let s:executable_cache_map = {}
-endfunction
-
-" Check if files are executable, and if they are, remember that they are
-" for subsequent calls. We'll keep checking until programs can be executed.
-function! ale#engine#IsExecutable(buffer, executable) abort
-    if empty(a:executable)
-        " Don't log the executable check if the executable string is empty.
-        return 0
-    endif
-
-    " Check for a cached executable() check.
-    let l:result = get(s:executable_cache_map, a:executable, v:null)
-
-    if l:result isnot v:null
-        return l:result
-    endif
-
-    " Check if the file is executable, and convert -1 to 1.
-    let l:result = executable(a:executable) isnot 0
-
-    " Cache the executable check if we found it, or if the option to cache
-    " failing checks is on.
-    if l:result || get(g:, 'ale_cache_executable_check_failures', 0)
-        let s:executable_cache_map[a:executable] = l:result
-    endif
-
-    if g:ale_history_enabled
-        call ale#history#Add(a:buffer, l:result, 'executable', a:executable)
-    endif
-
-    return l:result
-endfunction
-
-function! ale#engine#InitBufferInfo(buffer) abort
-    if !has_key(g:ale_buffer_info, a:buffer)
-        " active_linter_list will hold the list of active linter names
-        " loclist holds the loclist items after all jobs have completed.
-        let g:ale_buffer_info[a:buffer] = {
-        \   'active_linter_list': [],
-        \   'active_other_sources_list': [],
-        \   'loclist': [],
-        \}
-
-        return 1
-    endif
-
-    return 0
-endfunction
-
-" This function is documented and part of the public API.
-"
-" Return 1 if ALE is busy checking a given buffer
-function! ale#engine#IsCheckingBuffer(buffer) abort
-    let l:info = get(g:ale_buffer_info, a:buffer, {})
-
-    return !empty(get(l:info, 'active_linter_list', []))
-    \   || !empty(get(l:info, 'active_other_sources_list', []))
-endfunction
-
-" Register a temporary file to be managed with the ALE engine for
-" a current job run.
-function! ale#engine#ManageFile(buffer, filename) abort
-    if !get(g:, 'ale_ignore_2_4_warnings')
-        execute 'echom ''ale#engine#ManageFile is deprecated. Use `let g:ale_ignore_2_4_warnings = 1` to disable this message.'''
-    endif
-
-    call ale#command#ManageFile(a:buffer, a:filename)
-endfunction
-
-" Same as the above, but manage an entire directory.
-function! ale#engine#ManageDirectory(buffer, directory) abort
-    if !get(g:, 'ale_ignore_2_4_warnings')
-        execute 'echom ''ale#engine#ManageDirectory is deprecated. Use `let g:ale_ignore_2_4_warnings = 1` to disable this message.'''
-    endif
-
-    call ale#command#ManageDirectory(a:buffer, a:directory)
-endfunction
-
-function! ale#engine#CreateFile(buffer) abort
-    if !get(g:, 'ale_ignore_2_4_warnings')
-        execute 'echom ''ale#engine#CreateFile is deprecated. Use `let g:ale_ignore_2_4_warnings = 1` to disable this message.'''
-    endif
-
-    return ale#command#CreateFile(a:buffer)
-endfunction
-
-" Create a new temporary directory and manage it in one go.
-function! ale#engine#CreateDirectory(buffer) abort
-    if !get(g:, 'ale_ignore_2_4_warnings')
-        execute 'echom ''ale#engine#CreateDirectory is deprecated. Use `let g:ale_ignore_2_4_warnings = 1` to disable this message.'''
-    endif
-
-    return ale#command#CreateDirectory(a:buffer)
-endfunction
-
-function! ale#engine#HandleLoclist(linter_name, buffer, loclist, from_other_source) abort
-    let l:info = get(g:ale_buffer_info, a:buffer, {})
-
-    if empty(l:info)
-        return
-    endif
-
-    if !a:from_other_source
-        " Remove this linter from the list of active linters.
-        " This may have already been done when the job exits.
-        call filter(l:info.active_linter_list, 'v:val.name isnot# a:linter_name')
-    endif
-
-    " Make some adjustments to the loclists to fix common problems, and also
-    " to set default values for loclist items.
-    let l:linter_loclist = ale#engine#FixLocList(
-    \   a:buffer,
-    \   a:linter_name,
-    \   a:from_other_source,
-    \   a:loclist,
-    \)
-
-    " Remove previous items for this linter.
-    call filter(l:info.loclist, 'v:val.linter_name isnot# a:linter_name')
-
-    " We don't need to add items or sort the list when this list is empty.
-    if !empty(l:linter_loclist)
-        " Add the new items.
-        call extend(l:info.loclist, l:linter_loclist)
-
-        " Sort the loclist again.
-        " We need a sorted list so we can run a binary search against it
-        " for efficient lookup of the messages in the cursor handler.
-        call sort(l:info.loclist, 'ale#util#LocItemCompare')
-    endif
-
-    if ale#ShouldDoNothing(a:buffer)
-        return
-    endif
-
-    call ale#engine#SetResults(a:buffer, l:info.loclist)
-endfunction
-
-function! s:HandleExit(job_info, buffer, output, data) abort
-    let l:buffer_info = get(g:ale_buffer_info, a:buffer)
-
-    if empty(l:buffer_info)
-        return
-    endif
-
-    let l:linter = a:job_info.linter
-    let l:executable = a:job_info.executable
-    let l:next_chain_index = a:job_info.next_chain_index
-
-    " Remove this job from the list.
-    call ale#engine#MarkLinterInactive(l:buffer_info, l:linter.name)
-
-    " Stop here if we land in the handle for a job completing if we're in
-    " a sandbox.
-    if ale#util#InSandbox()
-        return
-    endif
-
-    if has('nvim') && !empty(a:output) && empty(a:output[-1])
-        call remove(a:output, -1)
-    endif
-
-    if l:next_chain_index < len(get(l:linter, 'command_chain', []))
-        let [l:command, l:options] = ale#engine#ProcessChain(
-        \   a:buffer,
-        \   l:executable,
-        \   l:linter,
-        \   l:next_chain_index,
-        \   a:output,
-        \)
-
-        call s:RunJob(l:command, l:options)
-
-        return
-    endif
-
-    try
-        let l:loclist = ale#util#GetFunction(l:linter.callback)(a:buffer, a:output)
-    " Handle the function being unknown, or being deleted.
-    catch /E700/
-        let l:loclist = []
-    endtry
-
-    call ale#engine#HandleLoclist(l:linter.name, a:buffer, l:loclist, 0)
-endfunction
-
-function! ale#engine#SetResults(buffer, loclist) abort
-    let l:linting_is_done = !ale#engine#IsCheckingBuffer(a:buffer)
-
-    " Set signs first. This could potentially fix some line numbers.
-    " The List could be sorted again here by SetSigns.
-    if g:ale_set_signs
-        call ale#sign#SetSigns(a:buffer, a:loclist)
-    endif
-
-    if g:ale_set_quickfix || g:ale_set_loclist
-        call ale#list#SetLists(a:buffer, a:loclist)
-    endif
-
-    if exists('*ale#statusline#Update')
-        " Don't load/run if not already loaded.
-        call ale#statusline#Update(a:buffer, a:loclist)
-    endif
-
-    if g:ale_set_highlights
-        call ale#highlight#SetHighlights(a:buffer, a:loclist)
-    endif
-
-    if l:linting_is_done
-        if g:ale_echo_cursor
-            " Try and echo the warning now.
-            " This will only do something meaningful if we're in normal mode.
-            call ale#cursor#EchoCursorWarning()
-        endif
-
-        if g:ale_virtualtext_cursor
-            " Try and show the warning now.
-            " This will only do something meaningful if we're in normal mode.
-            call ale#virtualtext#ShowCursorWarning()
-        endif
-
-        " Reset the save event marker, used for opening windows, etc.
-        call setbufvar(a:buffer, 'ale_save_event_fired', 0)
-        " Set a marker showing how many times a buffer has been checked.
-        call setbufvar(
-        \   a:buffer,
-        \   'ale_linted',
-        \   getbufvar(a:buffer, 'ale_linted', 0) + 1
-        \)
-
-        " Automatically remove all managed temporary files and directories
-        " now that all jobs have completed.
-        call ale#command#RemoveManagedFiles(a:buffer)
-
-        " Call user autocommands. This allows users to hook into ALE's lint cycle.
-        silent doautocmd <nomodeline> User ALELintPost
-    endif
-endfunction
-
-function! s:RemapItemTypes(type_map, loclist) abort
-    for l:item in a:loclist
-        let l:key = l:item.type
-        \   . (get(l:item, 'sub_type', '') is# 'style' ? 'S' : '')
-        let l:new_key = get(a:type_map, l:key, '')
-
-        if l:new_key is# 'E'
-        \|| l:new_key is# 'ES'
-        \|| l:new_key is# 'W'
-        \|| l:new_key is# 'WS'
-        \|| l:new_key is# 'I'
-            let l:item.type = l:new_key[0]
-
-            if l:new_key is# 'ES' || l:new_key is# 'WS'
-                let l:item.sub_type = 'style'
-            elseif has_key(l:item, 'sub_type')
-                call remove(l:item, 'sub_type')
-            endif
-        endif
-    endfor
-endfunction
-
-function! ale#engine#FixLocList(buffer, linter_name, from_other_source, loclist) abort
-    let l:bufnr_map = {}
-    let l:new_loclist = []
-
-    " Some errors have line numbers beyond the end of the file,
-    " so we need to adjust them so they set the error at the last line
-    " of the file instead.
-    let l:last_line_number = ale#util#GetLineCount(a:buffer)
-
-    for l:old_item in a:loclist
-        " Copy the loclist item with some default values and corrections.
-        "
-        " line and column numbers will be converted to numbers.
-        " The buffer will default to the buffer being checked.
-        " The vcol setting will default to 0, a byte index.
-        " The error type will default to 'E' for errors.
-        " The error number will default to -1.
-        "
-        " The line number and text are the only required keys.
-        "
-        " The linter_name will be set on the errors so it can be used in
-        " output, filtering, etc..
-        let l:item = {
-        \   'bufnr': a:buffer,
-        \   'text': l:old_item.text,
-        \   'lnum': str2nr(l:old_item.lnum),
-        \   'col': str2nr(get(l:old_item, 'col', 0)),
-        \   'vcol': 0,
-        \   'type': get(l:old_item, 'type', 'E'),
-        \   'nr': get(l:old_item, 'nr', -1),
-        \   'linter_name': a:linter_name,
-        \}
-
-        if a:from_other_source
-            let l:item.from_other_source = 1
-        endif
-
-        if has_key(l:old_item, 'code')
-            let l:item.code = l:old_item.code
-        endif
-
-        if has_key(l:old_item, 'filename')
-        \&& !ale#path#IsTempName(l:old_item.filename)
-            " Use the filename given.
-            " Temporary files are assumed to be for this buffer,
-            " and the filename is not included then, because it looks bad
-            " in the loclist window.
-            let l:filename = l:old_item.filename
-            let l:item.filename = l:filename
-
-            if has_key(l:old_item, 'bufnr')
-                " If a buffer number is also given, include that too.
-                " If Vim detects that he buffer number is valid, it will
-                " be used instead of the filename.
-                let l:item.bufnr = l:old_item.bufnr
-            elseif has_key(l:bufnr_map, l:filename)
-                " Get the buffer number from the map, which can be faster.
-                let l:item.bufnr = l:bufnr_map[l:filename]
-            else
-                " Look up the buffer number.
-                let l:item.bufnr = bufnr(l:filename)
-                let l:bufnr_map[l:filename] = l:item.bufnr
-            endif
-        elseif has_key(l:old_item, 'bufnr')
-            let l:item.bufnr = l:old_item.bufnr
-        endif
-
-        if has_key(l:old_item, 'detail')
-            let l:item.detail = l:old_item.detail
-        endif
-
-        " Pass on a end_col key if set, used for highlights.
-        if has_key(l:old_item, 'end_col')
-            let l:item.end_col = str2nr(l:old_item.end_col)
-        endif
-
-        if has_key(l:old_item, 'end_lnum')
-            let l:item.end_lnum = str2nr(l:old_item.end_lnum)
-        endif
-
-        if has_key(l:old_item, 'sub_type')
-            let l:item.sub_type = l:old_item.sub_type
-        endif
-
-        if l:item.lnum < 1
-            " When errors appear before line 1, put them at line 1.
-            let l:item.lnum = 1
-        elseif l:item.bufnr == a:buffer && l:item.lnum > l:last_line_number
-            " When errors go beyond the end of the file, put them at the end.
-            " This is only done for the current buffer.
-            let l:item.lnum = l:last_line_number
-        elseif get(l:old_item, 'vcol', 0)
-            " Convert virtual column positions to byte positions.
-            " The positions will be off if the buffer has changed recently.
-            let l:line = getbufline(a:buffer, l:item.lnum)[0]
-
-            let l:item.col = ale#util#Col(l:line, l:item.col)
-
-            if has_key(l:item, 'end_col')
-                let l:end_line = get(l:item, 'end_lnum', l:line) != l:line
-                \   ? getbufline(a:buffer, l:item.end_lnum)[0]
-                \   : l:line
-
-                let l:item.end_col = ale#util#Col(l:end_line, l:item.end_col)
-            endif
-        endif
-
-        call add(l:new_loclist, l:item)
-    endfor
-
-    let l:type_map = get(ale#Var(a:buffer, 'type_map'), a:linter_name, {})
-
-    if !empty(l:type_map)
-        call s:RemapItemTypes(l:type_map, l:new_loclist)
-    endif
-
-    return l:new_loclist
-endfunction
-
-" Given part of a command, replace any % with %%, so that no characters in
-" the string will be replaced with filenames, etc.
-function! ale#engine#EscapeCommandPart(command_part) abort
-    " TODO: Emit deprecation warning here later.
-    return ale#command#EscapeCommandPart(a:command_part)
-endfunction
-
-" Run a job.
-"
-" Returns 1 when a job was started successfully.
-function! s:RunJob(command, options) abort
-    if ale#command#IsDeferred(a:command)
-        let a:command.result_callback = {
-        \   command -> s:RunJob(command, a:options)
-        \}
-
-        return 1
-    endif
-
-    let l:command = a:command
-
-    if empty(l:command)
-        return 0
-    endif
-
-    let l:executable = a:options.executable
-    let l:buffer = a:options.buffer
-    let l:linter = a:options.linter
-    let l:output_stream = a:options.output_stream
-    let l:next_chain_index = a:options.next_chain_index
-    let l:read_buffer = a:options.read_buffer
-    let l:info = g:ale_buffer_info[l:buffer]
-
-    let l:Callback = function('s:HandleExit', [{
-    \   'linter': l:linter,
-    \   'executable': l:executable,
-    \   'next_chain_index': l:next_chain_index,
-    \}])
-    let l:result = ale#command#Run(l:buffer, l:command, l:Callback, {
-    \   'output_stream': l:output_stream,
-    \   'executable': l:executable,
-    \   'read_buffer': l:read_buffer,
-    \   'log_output': l:next_chain_index >= len(get(l:linter, 'command_chain', [])),
-    \})
-
-    " Only proceed if the job is being run.
-    if empty(l:result)
-        return 0
-    endif
-
-    call ale#engine#MarkLinterActive(l:info, l:linter)
-
-    silent doautocmd <nomodeline> User ALEJobStarted
-
-    return 1
-endfunction
-
-" Determine which commands to run for a link in a command chain, or
-" just a regular command.
-function! ale#engine#ProcessChain(buffer, executable, linter, chain_index, input) abort
-    let l:output_stream = get(a:linter, 'output_stream', 'stdout')
-    let l:read_buffer = a:linter.read_buffer
-    let l:chain_index = a:chain_index
-    let l:input = a:input
-
-    while l:chain_index < len(a:linter.command_chain)
-        " Run a chain of commands, one asynchronous command after the other,
-        " so that many programs can be run in a sequence.
-        let l:chain_item = a:linter.command_chain[l:chain_index]
-
-        if l:chain_index == 0
-            " The first callback in the chain takes only a buffer number.
-            let l:command = ale#util#GetFunction(l:chain_item.callback)(
-            \   a:buffer
-            \)
-        else
-            " The second callback in the chain takes some input too.
-            let l:command = ale#util#GetFunction(l:chain_item.callback)(
-            \   a:buffer,
-            \   l:input
-            \)
-        endif
-
-        " If we have a command to run, execute that.
-        if !empty(l:command)
-            " The chain item can override the output_stream option.
-            if has_key(l:chain_item, 'output_stream')
-                let l:output_stream = l:chain_item.output_stream
-            endif
-
-            " The chain item can override the read_buffer option.
-            if has_key(l:chain_item, 'read_buffer')
-                let l:read_buffer = l:chain_item.read_buffer
-            elseif l:chain_index != len(a:linter.command_chain) - 1
-                " Don't read the buffer for commands besides the last one
-                " in the chain by default.
-                let l:read_buffer = 0
-            endif
-
-            break
-        endif
-
-        " Command chain items can return an empty string to indicate that
-        " a command should be skipped, so we should try the next item
-        " with no input.
-        let l:input = []
-        let l:chain_index += 1
-    endwhile
-
-    return [l:command, {
-    \   'executable': a:executable,
-    \   'buffer': a:buffer,
-    \   'linter': a:linter,
-    \   'output_stream': l:output_stream,
-    \   'next_chain_index': l:chain_index + 1,
-    \   'read_buffer': l:read_buffer,
-    \}]
-endfunction
-
-function! s:StopCurrentJobs(buffer, clear_lint_file_jobs) abort
-    let l:info = get(g:ale_buffer_info, a:buffer, {})
-    call ale#command#StopJobs(a:buffer, 'linter')
-
-    " Update the active linter list, clearing out anything not running.
-    if a:clear_lint_file_jobs
-        call ale#command#StopJobs(a:buffer, 'file_linter')
-        let l:info.active_linter_list = []
-    else
-        " Keep jobs for linting files when we're only linting buffers.
-        call filter(l:info.active_linter_list, 'get(v:val, ''lint_file'')')
-    endif
-endfunction
-
-function! s:RemoveProblemsForDisabledLinters(buffer, linters) abort
-    " Figure out which linters are still enabled, and remove
-    " problems for linters which are no longer enabled.
-    " Problems from other sources will be kept.
-    let l:name_map = {}
-
-    for l:linter in a:linters
-        let l:name_map[l:linter.name] = 1
-    endfor
-
-    call filter(
-    \   get(g:ale_buffer_info[a:buffer], 'loclist', []),
-    \   'get(v:val, ''from_other_source'') || get(l:name_map, get(v:val, ''linter_name''))',
-    \)
-endfunction
-
-function! s:AddProblemsFromOtherBuffers(buffer, linters) abort
-    let l:filename = expand('#' . a:buffer . ':p')
-    let l:loclist = []
-    let l:name_map = {}
-
-    " Build a map of the active linters.
-    for l:linter in a:linters
-        let l:name_map[l:linter.name] = 1
-    endfor
-
-    " Find the items from other buffers, for the linters that are enabled.
-    for l:info in values(g:ale_buffer_info)
-        for l:item in l:info.loclist
-            if has_key(l:item, 'filename')
-            \&& l:item.filename is# l:filename
-            \&& has_key(l:name_map, l:item.linter_name)
-                " Copy the items and set the buffer numbers to this one.
-                let l:new_item = copy(l:item)
-                let l:new_item.bufnr = a:buffer
-                call add(l:loclist, l:new_item)
-            endif
-        endfor
-    endfor
-
-    if !empty(l:loclist)
-        call sort(l:loclist, function('ale#util#LocItemCompareWithText'))
-        call uniq(l:loclist, function('ale#util#LocItemCompareWithText'))
-
-        " Set the loclist variable, used by some parts of ALE.
-        let g:ale_buffer_info[a:buffer].loclist = l:loclist
-        call ale#engine#SetResults(a:buffer, l:loclist)
-    endif
-endfunction
-
-function! s:RunIfExecutable(buffer, linter, executable) abort
-    if ale#command#IsDeferred(a:executable)
-        let a:executable.result_callback = {
-        \   executable -> s:RunIfExecutable(a:buffer, a:linter, executable)
-        \}
-
-        return 1
-    endif
-
-    if ale#engine#IsExecutable(a:buffer, a:executable)
-        " Use different job types for file or linter jobs.
-        let l:job_type = a:linter.lint_file ? 'file_linter' : 'linter'
-        call setbufvar(a:buffer, 'ale_job_type', l:job_type)
-
-        if has_key(a:linter, 'command_chain')
-            let [l:command, l:options] = ale#engine#ProcessChain(
-            \   a:buffer,
-            \   a:executable,
-            \   a:linter,
-            \   0,
-            \   []
-            \)
-
-            return s:RunJob(l:command, l:options)
-        endif
-
-        let l:command = ale#linter#GetCommand(a:buffer, a:linter)
-        let l:options = {
-        \   'executable': a:executable,
-        \   'buffer': a:buffer,
-        \   'linter': a:linter,
-        \   'output_stream': get(a:linter, 'output_stream', 'stdout'),
-        \   'next_chain_index': 1,
-        \   'read_buffer': a:linter.read_buffer,
-        \}
-
-        return s:RunJob(l:command, l:options)
-    endif
-
-    return 0
-endfunction
-
-" Run a linter for a buffer.
-"
-" Returns 1 if the linter was successfully run.
-function! s:RunLinter(buffer, linter) abort
-    if !empty(a:linter.lsp)
-        return ale#lsp_linter#CheckWithLSP(a:buffer, a:linter)
-    else
-        let l:executable = ale#linter#GetExecutable(a:buffer, a:linter)
-
-        return s:RunIfExecutable(a:buffer, a:linter, l:executable)
-    endif
-
-    return 0
-endfunction
-
-function! ale#engine#RunLinters(buffer, linters, should_lint_file) abort
-    " Initialise the buffer information if needed.
-    let l:new_buffer = ale#engine#InitBufferInfo(a:buffer)
-    call s:StopCurrentJobs(a:buffer, a:should_lint_file)
-    call s:RemoveProblemsForDisabledLinters(a:buffer, a:linters)
-
-    " We can only clear the results if we aren't checking the buffer.
-    let l:can_clear_results = !ale#engine#IsCheckingBuffer(a:buffer)
-
-    silent doautocmd <nomodeline> User ALELintPre
-
-    for l:linter in a:linters
-        " Only run lint_file linters if we should.
-        if !l:linter.lint_file || a:should_lint_file
-            if s:RunLinter(a:buffer, l:linter)
-                " If a single linter ran, we shouldn't clear everything.
-                let l:can_clear_results = 0
-            endif
-        else
-            " If we skipped running a lint_file linter still in the list,
-            " we shouldn't clear everything.
-            let l:can_clear_results = 0
-        endif
-    endfor
-
-    " Clear the results if we can. This needs to be done when linters are
-    " disabled, or ALE itself is disabled.
-    if l:can_clear_results
-        call ale#engine#SetResults(a:buffer, [])
-    elseif l:new_buffer
-        call s:AddProblemsFromOtherBuffers(a:buffer, a:linters)
-    endif
-endfunction
-
-" Clean up a buffer.
-"
-" This function will stop all current jobs for the buffer,
-" clear the state of everything, and remove the Dictionary for managing
-" the buffer.
-function! ale#engine#Cleanup(buffer) abort
-    " Don't bother with cleanup code when newer NeoVim versions are exiting.
-    if get(v:, 'exiting', v:null) isnot v:null
-        return
-    endif
-
-    if exists('*ale#lsp#CloseDocument')
-        call ale#lsp#CloseDocument(a:buffer)
-    endif
-
-    if !has_key(g:ale_buffer_info, a:buffer)
-        return
-    endif
-
-    call ale#engine#RunLinters(a:buffer, [], 1)
-
-    call remove(g:ale_buffer_info, a:buffer)
-endfunction
-
-" Given a buffer number, return the warnings and errors for a given buffer.
-function! ale#engine#GetLoclist(buffer) abort
-    if !has_key(g:ale_buffer_info, a:buffer)
-        return []
-    endif
-
-    return g:ale_buffer_info[a:buffer].loclist
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/engine/ignore.vim b/sources_non_forked/ale/autoload/ale/engine/ignore.vim
deleted file mode 100644
index 8057465..0000000
--- a/sources_non_forked/ale/autoload/ale/engine/ignore.vim
+++ /dev/null
@@ -1,50 +0,0 @@
-" Author: w0rp <devw0rp@gmail.com>
-" Description: Code for ignoring linters. Only loaded and if configured.
-
-" Given a filetype and a configuration for ignoring linters, return a List of
-" Strings for linter names to ignore.
-function! ale#engine#ignore#GetList(filetype, config) abort
-    if type(a:config) is v:t_list
-        return a:config
-    endif
-
-    if type(a:config) is v:t_dict
-        let l:names_to_remove = []
-
-        for l:part in split(a:filetype , '\.')
-            call extend(l:names_to_remove, get(a:config, l:part, []))
-        endfor
-
-        return l:names_to_remove
-    endif
-
-    return []
-endfunction
-
-" Given a List of linter descriptions, exclude the linters to be ignored.
-function! ale#engine#ignore#Exclude(filetype, all_linters, config, disable_lsp) abort
-    let l:names_to_remove = ale#engine#ignore#GetList(a:filetype, a:config)
-    let l:filtered_linters = []
-
-    for l:linter in a:all_linters
-        let l:name_list = [l:linter.name] + l:linter.aliases
-        let l:should_include = 1
-
-        for l:name in l:name_list
-            if index(l:names_to_remove, l:name) >= 0
-                let l:should_include = 0
-                break
-            endif
-        endfor
-
-        if a:disable_lsp && has_key(l:linter, 'lsp') && l:linter.lsp isnot# ''
-            let l:should_include = 0
-        endif
-
-        if l:should_include
-            call add(l:filtered_linters, l:linter)
-        endif
-    endfor
-
-    return l:filtered_linters
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/events.vim b/sources_non_forked/ale/autoload/ale/events.vim
deleted file mode 100644
index da554ef..0000000
--- a/sources_non_forked/ale/autoload/ale/events.vim
+++ /dev/null
@@ -1,155 +0,0 @@
-" Author: w0rp <devw0rp@gmail.com>
-" Description: ALE functions for autocmd events.
-
-" Get the number of milliseconds since some vague, but consistent, point in
-" the past.
-"
-" This function can be used for timing execution, etc.
-"
-" The time will be returned as a Number.
-function! ale#events#ClockMilliseconds() abort
-    return float2nr(reltimefloat(reltime()) * 1000)
-endfunction
-
-function! ale#events#QuitEvent(buffer) abort
-    " Remember when ALE is quitting for BufWrite, etc.
-    call setbufvar(a:buffer, 'ale_quitting', ale#events#ClockMilliseconds())
-endfunction
-
-function! ale#events#QuitRecently(buffer) abort
-    let l:time = getbufvar(a:buffer, 'ale_quitting', 0)
-
-    return l:time && ale#events#ClockMilliseconds() - l:time < 1000
-endfunction
-
-function! ale#events#SaveEvent(buffer) abort
-    let l:should_lint = ale#Var(a:buffer, 'enabled') && g:ale_lint_on_save
-
-    if l:should_lint
-        call setbufvar(a:buffer, 'ale_save_event_fired', 1)
-    endif
-
-    if ale#Var(a:buffer, 'fix_on_save') && !ale#events#QuitRecently(a:buffer)
-        let l:will_fix = ale#fix#Fix(a:buffer, 'save_file')
-        let l:should_lint = l:should_lint && !l:will_fix
-    endif
-
-    if l:should_lint && !ale#events#QuitRecently(a:buffer)
-        call ale#Queue(0, 'lint_file', a:buffer)
-    endif
-endfunction
-
-function! ale#events#LintOnEnter(buffer) abort
-    " Unmark a file as being changed outside of Vim after we try to check it.
-    call setbufvar(a:buffer, 'ale_file_changed', 0)
-
-    if ale#Var(a:buffer, 'enabled') && g:ale_lint_on_enter
-        call ale#Queue(0, 'lint_file', a:buffer)
-    endif
-endfunction
-
-function! ale#events#ReadOrEnterEvent(buffer) abort
-    " Apply pattern options if the variable is set.
-    if get(g:, 'ale_pattern_options_enabled', 1)
-    \&& !empty(get(g:, 'ale_pattern_options'))
-        call ale#pattern_options#SetOptions(a:buffer)
-    endif
-
-    " When entering a buffer, we are no longer quitting it.
-    call setbufvar(a:buffer, 'ale_quitting', 0)
-    let l:filetype = getbufvar(a:buffer, '&filetype')
-    call setbufvar(a:buffer, 'ale_original_filetype', l:filetype)
-
-    " If the file changed outside of Vim, check it on BufEnter,BufRead
-    if getbufvar(a:buffer, 'ale_file_changed')
-        call ale#events#LintOnEnter(a:buffer)
-    endif
-endfunction
-
-function! ale#events#FileTypeEvent(buffer, new_filetype) abort
-    " The old filetype will be set to an empty string by the BuFEnter event,
-    " and not linting when the old filetype hasn't been set yet prevents
-    " buffers being checked when you enter them when linting on enter is off.
-    let l:old_filetype = getbufvar(a:buffer, 'ale_original_filetype', v:null)
-
-    if l:old_filetype isnot v:null
-    \&& !empty(a:new_filetype)
-    \&& a:new_filetype isnot# l:old_filetype
-        " Remember what the new filetype is.
-        call setbufvar(a:buffer, 'ale_original_filetype', a:new_filetype)
-
-        if g:ale_lint_on_filetype_changed
-            call ale#Queue(300, 'lint_file', a:buffer)
-        endif
-    endif
-endfunction
-
-function! ale#events#FileChangedEvent(buffer) abort
-    call setbufvar(a:buffer, 'ale_file_changed', 1)
-
-    if bufnr('') == a:buffer
-        call ale#events#LintOnEnter(a:buffer)
-    endif
-endfunction
-
-function! ale#events#Init() abort
-    " This value used to be a Boolean as a Number, and is now a String.
-    let l:text_changed = '' . g:ale_lint_on_text_changed
-
-    augroup ALEEvents
-        autocmd!
-
-        " These events always need to be set up.
-        autocmd BufEnter,BufRead * call ale#events#ReadOrEnterEvent(str2nr(expand('<abuf>')))
-        autocmd BufWritePost * call ale#events#SaveEvent(str2nr(expand('<abuf>')))
-
-        if g:ale_enabled
-            if l:text_changed is? 'always' || l:text_changed is# '1'
-                autocmd TextChanged,TextChangedI * call ale#Queue(g:ale_lint_delay)
-            elseif l:text_changed is? 'normal'
-                autocmd TextChanged * call ale#Queue(g:ale_lint_delay)
-            elseif l:text_changed is? 'insert'
-                autocmd TextChangedI * call ale#Queue(g:ale_lint_delay)
-            endif
-
-            if g:ale_lint_on_enter
-                autocmd BufWinEnter * call ale#events#LintOnEnter(str2nr(expand('<abuf>')))
-                " Track when the file is changed outside of Vim.
-                autocmd FileChangedShellPost * call ale#events#FileChangedEvent(str2nr(expand('<abuf>')))
-            endif
-
-            if g:ale_lint_on_filetype_changed
-                " Only start linting if the FileType actually changes after
-                " opening a buffer. The FileType will fire when buffers are opened.
-                autocmd FileType * call ale#events#FileTypeEvent(
-                \   str2nr(expand('<abuf>')),
-                \   expand('<amatch>')
-                \)
-            endif
-
-            if g:ale_lint_on_insert_leave
-                autocmd InsertLeave * if ale#Var(str2nr(expand('<abuf>')), 'lint_on_insert_leave') | call ale#Queue(0) | endif
-            endif
-
-            if g:ale_echo_cursor || g:ale_cursor_detail
-                autocmd CursorMoved,CursorHold * if exists('*ale#engine#Cleanup') | call ale#cursor#EchoCursorWarningWithDelay() | endif
-                " Look for a warning to echo as soon as we leave Insert mode.
-                " The script's position variable used when moving the cursor will
-                " not be changed here.
-                autocmd InsertLeave * if exists('*ale#engine#Cleanup') | call ale#cursor#EchoCursorWarning() | endif
-            endif
-
-            if g:ale_virtualtext_cursor
-                autocmd CursorMoved,CursorHold * if exists('*ale#engine#Cleanup') | call ale#virtualtext#ShowCursorWarningWithDelay() | endif
-                " Look for a warning to echo as soon as we leave Insert mode.
-                " The script's position variable used when moving the cursor will
-                " not be changed here.
-                autocmd InsertLeave * if exists('*ale#engine#Cleanup') | call ale#virtualtext#ShowCursorWarning() | endif
-            endif
-
-            if g:ale_close_preview_on_insert
-                autocmd InsertEnter * if exists('*ale#preview#CloseIfTypeMatches') | call ale#preview#CloseIfTypeMatches('ale-preview') | endif
-            endif
-        endif
-    augroup END
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/filetypes.vim b/sources_non_forked/ale/autoload/ale/filetypes.vim
deleted file mode 100644
index 6cdc9ec..0000000
--- a/sources_non_forked/ale/autoload/ale/filetypes.vim
+++ /dev/null
@@ -1,60 +0,0 @@
-" Author: w0rp <devw0rp@gmail.com>
-" Description: This file handles guessing file extensions for filetypes, etc.
-
-function! ale#filetypes#LoadExtensionMap() abort
-    " Output includes:
-    "    '*.erl setf erlang'
-    redir => l:output
-        silent exec 'autocmd'
-    redir end
-
-    let l:map = {}
-
-    for l:line in split(l:output, "\n")
-        " Parse filetypes, like so:
-        "
-        "    *.erl setf erlang
-        " *.md      set filetype=markdown
-        " *.snippet setlocal filetype=snippets
-        let l:match = matchlist(l:line, '\v^ *\*(\.[^ ]+).*set(f *| *filetype=|local *filetype=)([^ ]+)')
-
-        if !empty(l:match)
-            let l:map[substitute(l:match[3], '^=', '', '')] = l:match[1]
-        endif
-    endfor
-
-    return l:map
-endfunction
-
-let s:cached_map = {}
-
-function! s:GetCachedExtensionMap() abort
-    if empty(s:cached_map)
-        let s:cached_map = ale#filetypes#LoadExtensionMap()
-    endif
-
-    return s:cached_map
-endfunction
-
-function! ale#filetypes#GuessExtension(filetype) abort
-    let l:map = s:GetCachedExtensionMap()
-    let l:ext = get(l:map, a:filetype, '')
-
-    " If we have an exact match, like something for javascript.jsx, use that.
-    if !empty(l:ext)
-        return l:ext
-    endif
-
-    " If we don't have an exact match, use the first filetype in the compound
-    " filetype.
-    for l:part in split(a:filetype, '\.')
-        let l:ext = get(l:map, l:part, '')
-
-        if !empty(l:ext)
-            return l:ext
-        endif
-    endfor
-
-    " Return an empty string if we don't find anything.
-    return ''
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/fix.vim b/sources_non_forked/ale/autoload/ale/fix.vim
deleted file mode 100644
index 69817b3..0000000
--- a/sources_non_forked/ale/autoload/ale/fix.vim
+++ /dev/null
@@ -1,391 +0,0 @@
-call ale#Set('fix_on_save_ignore', {})
-
-" Apply fixes queued up for buffers which may be hidden.
-" Vim doesn't let you modify hidden buffers.
-function! ale#fix#ApplyQueuedFixes(buffer) abort
-    let l:data = get(g:ale_fix_buffer_data, a:buffer, {'done': 0})
-
-    if !l:data.done || (!ale#util#HasBuflineApi() && a:buffer isnot bufnr(''))
-        return
-    endif
-
-    call remove(g:ale_fix_buffer_data, a:buffer)
-
-    if l:data.changes_made
-        let l:new_lines = ale#util#SetBufferContents(a:buffer, l:data.output)
-
-        if l:data.should_save
-            if a:buffer is bufnr('')
-                if empty(&buftype)
-                    noautocmd :w!
-                else
-                    set nomodified
-                endif
-            else
-                call writefile(l:new_lines, expand('#' . a:buffer . ':p')) " no-custom-checks
-                call setbufvar(a:buffer, '&modified', 0)
-            endif
-        endif
-    endif
-
-    if l:data.should_save
-        let l:should_lint = ale#Var(a:buffer, 'fix_on_save')
-        \   && ale#Var(a:buffer, 'lint_on_save')
-    else
-        let l:should_lint = l:data.changes_made
-    endif
-
-    silent doautocmd <nomodeline> User ALEFixPost
-
-    " If ALE linting is enabled, check for problems with the file again after
-    " fixing problems.
-    if g:ale_enabled
-    \&& l:should_lint
-    \&& !ale#events#QuitRecently(a:buffer)
-        call ale#Queue(0, l:data.should_save ? 'lint_file' : '')
-    endif
-endfunction
-
-function! ale#fix#ApplyFixes(buffer, output) abort
-    let l:data = g:ale_fix_buffer_data[a:buffer]
-    let l:data.output = a:output
-    let l:data.changes_made = l:data.lines_before !=# l:data.output " no-custom-checks
-    let l:data.done = 1
-
-    call ale#command#RemoveManagedFiles(a:buffer)
-
-    if !bufexists(a:buffer)
-        " Remove the buffer data when it doesn't exist.
-        call remove(g:ale_fix_buffer_data, a:buffer)
-    endif
-
-    if l:data.changes_made && bufexists(a:buffer)
-        let l:lines = getbufline(a:buffer, 1, '$')
-
-        if l:data.lines_before != l:lines
-            call remove(g:ale_fix_buffer_data, a:buffer)
-            execute 'echoerr ''The file was changed before fixing finished'''
-
-            return
-        endif
-    endif
-
-    " We can only change the lines of a buffer which is currently open,
-    " so try and apply the fixes to the current buffer.
-    call ale#fix#ApplyQueuedFixes(a:buffer)
-endfunction
-
-function! s:HandleExit(job_info, buffer, job_output, data) abort
-    let l:buffer_info = get(g:ale_fix_buffer_data, a:buffer, {})
-
-    if empty(l:buffer_info)
-        return
-    endif
-
-    if a:job_info.read_temporary_file
-        let l:output = !empty(a:data.temporary_file)
-        \   ?  readfile(a:data.temporary_file)
-        \   : []
-    else
-        let l:output = a:job_output
-    endif
-
-    let l:ChainCallback = get(a:job_info, 'chain_with', v:null)
-    let l:ProcessWith = get(a:job_info, 'process_with', v:null)
-
-    " Post-process the output with a function if we have one.
-    if l:ProcessWith isnot v:null
-        let l:output = call(l:ProcessWith, [a:buffer, l:output])
-    endif
-
-    " Use the output of the job for changing the file if it isn't empty,
-    " otherwise skip this job and use the input from before.
-    "
-    " We'll use the input from before for chained commands.
-    if l:ChainCallback is v:null && !empty(split(join(l:output)))
-        let l:input = l:output
-    else
-        let l:input = a:job_info.input
-    endif
-
-    if l:ChainCallback isnot v:null && !get(g:, 'ale_ignore_2_4_warnings')
-        execute 'echom ''chain_with is deprecated. Use `let g:ale_ignore_2_4_warnings = 1` to disable this message.'''
-    endif
-
-    let l:next_index = l:ChainCallback is v:null
-    \   ? a:job_info.callback_index + 1
-    \   : a:job_info.callback_index
-
-    call s:RunFixer({
-    \   'buffer': a:buffer,
-    \   'input': l:input,
-    \   'output': l:output,
-    \   'callback_list': a:job_info.callback_list,
-    \   'callback_index': l:next_index,
-    \   'chain_callback': l:ChainCallback,
-    \})
-endfunction
-
-function! s:RunJob(result, options) abort
-    if ale#command#IsDeferred(a:result)
-        let a:result.result_callback = {x -> s:RunJob(x, a:options)}
-
-        return
-    endif
-
-    let l:buffer = a:options.buffer
-    let l:input = a:options.input
-
-    if a:result is 0 || type(a:result) is v:t_list
-        if type(a:result) is v:t_list
-            let l:input = a:result
-        endif
-
-        call s:RunFixer({
-        \   'buffer': l:buffer,
-        \   'input': l:input,
-        \   'callback_index': a:options.callback_index + 1,
-        \   'callback_list': a:options.callback_list,
-        \})
-
-        return
-    endif
-
-    let l:command = get(a:result, 'command', '')
-    let l:ChainWith = get(a:result, 'chain_with', v:null)
-
-    if empty(l:command)
-        " If the command is empty, skip to the next item, or call the
-        " chain_with function.
-        call s:RunFixer({
-        \   'buffer': l:buffer,
-        \   'input': l:input,
-        \   'callback_index': a:options.callback_index + (l:ChainWith is v:null),
-        \   'callback_list': a:options.callback_list,
-        \   'chain_callback': l:ChainWith,
-        \   'output': [],
-        \})
-
-        return
-    endif
-
-    let l:read_temporary_file = get(a:result, 'read_temporary_file', 0)
-    " Default to piping the buffer for the last fixer in the chain.
-    let l:read_buffer = get(a:result, 'read_buffer', l:ChainWith is v:null)
-    let l:output_stream = get(a:result, 'output_stream', 'stdout')
-
-    if l:read_temporary_file
-        let l:output_stream = 'none'
-    endif
-
-    let l:Callback = function('s:HandleExit', [{
-    \   'input': l:input,
-    \   'chain_with': l:ChainWith,
-    \   'callback_index': a:options.callback_index,
-    \   'callback_list': a:options.callback_list,
-    \   'process_with': get(a:result, 'process_with', v:null),
-    \   'read_temporary_file': l:read_temporary_file,
-    \}])
-    let l:run_result = ale#command#Run(l:buffer, l:command, l:Callback, {
-    \   'output_stream': l:output_stream,
-    \   'executable': '',
-    \   'read_buffer': l:read_buffer,
-    \   'input': l:input,
-    \   'log_output': 0,
-    \})
-
-    if empty(l:run_result)
-        call s:RunFixer({
-        \   'buffer': l:buffer,
-        \   'input': l:input,
-        \   'callback_index': a:options.callback_index + 1,
-        \   'callback_list': a:options.callback_list,
-        \})
-    endif
-endfunction
-
-function! s:RunFixer(options) abort
-    let l:buffer = a:options.buffer
-    let l:input = a:options.input
-    let l:index = a:options.callback_index
-
-    if len(a:options.callback_list) <= l:index
-        call ale#fix#ApplyFixes(l:buffer, l:input)
-
-        return
-    endif
-
-    let l:ChainCallback = get(a:options, 'chain_callback', v:null)
-
-    let l:Function = l:ChainCallback isnot v:null
-    \   ? ale#util#GetFunction(l:ChainCallback)
-    \   : a:options.callback_list[l:index]
-
-    " Record new jobs started as fixer jobs.
-    call setbufvar(l:buffer, 'ale_job_type', 'fixer')
-
-    if l:ChainCallback isnot v:null
-        " Chained commands accept (buffer, output, [input])
-        let l:result = ale#util#FunctionArgCount(l:Function) == 2
-        \   ? call(l:Function, [l:buffer, a:options.output])
-        \   : call(l:Function, [l:buffer, a:options.output, copy(l:input)])
-    else
-        " Regular fixer commands accept (buffer, [input])
-        let l:result = ale#util#FunctionArgCount(l:Function) == 1
-        \   ? call(l:Function, [l:buffer])
-        \   : call(l:Function, [l:buffer, copy(l:input)])
-    endif
-
-    call s:RunJob(l:result, {
-    \   'buffer': l:buffer,
-    \   'input': l:input,
-    \   'callback_list': a:options.callback_list,
-    \   'callback_index': l:index,
-    \})
-endfunction
-
-function! s:AddSubCallbacks(full_list, callbacks) abort
-    if type(a:callbacks) is v:t_string
-        call add(a:full_list, a:callbacks)
-    elseif type(a:callbacks) is v:t_list
-        call extend(a:full_list, a:callbacks)
-    else
-        return 0
-    endif
-
-    return 1
-endfunction
-
-function! s:IgnoreFixers(callback_list, filetype, config) abort
-    if type(a:config) is v:t_list
-        let l:ignore_list = a:config
-    else
-        let l:ignore_list = []
-
-        for l:part in split(a:filetype , '\.')
-            call extend(l:ignore_list, get(a:config, l:part, []))
-        endfor
-    endif
-
-    call filter(a:callback_list, 'index(l:ignore_list, v:val) < 0')
-endfunction
-
-function! s:GetCallbacks(buffer, fixing_flag, fixers) abort
-    if len(a:fixers)
-        let l:callback_list = a:fixers
-    elseif type(get(b:, 'ale_fixers')) is v:t_list
-        " Lists can be used for buffer-local variables only
-        let l:callback_list = b:ale_fixers
-    else
-        " buffer and global options can use dictionaries mapping filetypes to
-        " callbacks to run.
-        let l:fixers = ale#Var(a:buffer, 'fixers')
-        let l:callback_list = []
-        let l:matched = 0
-
-        for l:sub_type in split(&filetype, '\.')
-            if s:AddSubCallbacks(l:callback_list, get(l:fixers, l:sub_type))
-                let l:matched = 1
-            endif
-        endfor
-
-        " If we couldn't find fixers for a filetype, default to '*' fixers.
-        if !l:matched
-            call s:AddSubCallbacks(l:callback_list, get(l:fixers, '*'))
-        endif
-    endif
-
-    if a:fixing_flag is# 'save_file'
-        let l:config = ale#Var(a:buffer, 'fix_on_save_ignore')
-
-        if !empty(l:config)
-            call s:IgnoreFixers(l:callback_list, &filetype, l:config)
-        endif
-    endif
-
-    let l:corrected_list = []
-
-    " Variables with capital characters are needed, or Vim will complain about
-    " funcref variables.
-    for l:Item in l:callback_list
-        if type(l:Item) is v:t_string
-            let l:Func = ale#fix#registry#GetFunc(l:Item)
-
-            if !empty(l:Func)
-                let l:Item = l:Func
-            endif
-        endif
-
-        try
-            call add(l:corrected_list, ale#util#GetFunction(l:Item))
-        catch /E475/
-            " Rethrow exceptions for failing to get a function so we can print
-            " a friendly message about it.
-            throw 'BADNAME ' . v:exception
-        endtry
-    endfor
-
-    return l:corrected_list
-endfunction
-
-function! ale#fix#InitBufferData(buffer, fixing_flag) abort
-    " The 'done' flag tells the function for applying changes when fixing
-    " is complete.
-    let g:ale_fix_buffer_data[a:buffer] = {
-    \   'lines_before': getbufline(a:buffer, 1, '$'),
-    \   'done': 0,
-    \   'should_save': a:fixing_flag is# 'save_file',
-    \   'temporary_directory_list': [],
-    \}
-endfunction
-
-" Accepts an optional argument for what to do when fixing.
-"
-" Returns 0 if no fixes can be applied, and 1 if fixing can be done.
-function! ale#fix#Fix(buffer, fixing_flag, ...) abort
-    if a:fixing_flag isnot# '' && a:fixing_flag isnot# 'save_file'
-        throw "fixing_flag must be either '' or 'save_file'"
-    endif
-
-    try
-        let l:callback_list = s:GetCallbacks(a:buffer, a:fixing_flag, a:000)
-    catch /E700\|BADNAME/
-        let l:function_name = join(split(split(v:exception, ':')[3]))
-        let l:echo_message = printf(
-        \   'There is no fixer named `%s`. Check :ALEFixSuggest',
-        \   l:function_name,
-        \)
-        execute 'echom l:echo_message'
-
-        return 0
-    endtry
-
-    if empty(l:callback_list)
-        if a:fixing_flag is# ''
-            execute 'echom ''No fixers have been defined. Try :ALEFixSuggest'''
-        endif
-
-        return 0
-    endif
-
-    call ale#command#StopJobs(a:buffer, 'fixer')
-    " Clean up any files we might have left behind from a previous run.
-    call ale#command#RemoveManagedFiles(a:buffer)
-    call ale#fix#InitBufferData(a:buffer, a:fixing_flag)
-
-    silent doautocmd <nomodeline> User ALEFixPre
-
-    call s:RunFixer({
-    \   'buffer': a:buffer,
-    \   'input': g:ale_fix_buffer_data[a:buffer].lines_before,
-    \   'callback_index': 0,
-    \   'callback_list': l:callback_list,
-    \})
-
-    return 1
-endfunction
-
-" Set up an autocmd command to try and apply buffer fixes when available.
-augroup ALEBufferFixGroup
-    autocmd!
-    autocmd BufEnter * call ale#fix#ApplyQueuedFixes(str2nr(expand('<abuf>')))
diff --git a/sources_non_forked/ale/autoload/ale/fix/registry.vim b/sources_non_forked/ale/autoload/ale/fix/registry.vim
deleted file mode 100644
index 1b3ca1a..0000000
--- a/sources_non_forked/ale/autoload/ale/fix/registry.vim
+++ /dev/null
@@ -1,574 +0,0 @@
-" Author: w0rp <devw0rp@gmail.com>
-" Description: A registry of functions for fixing things.
-
-let s:default_registry = {
-\   'add_blank_lines_for_python_control_statements': {
-\       'function': 'ale#fixers#generic_python#AddLinesBeforeControlStatements',
-\       'suggested_filetypes': ['python'],
-\       'description': 'Add blank lines before control statements.',
-\   },
-\   'align_help_tags': {
-\       'function': 'ale#fixers#help#AlignTags',
-\       'suggested_filetypes': ['help'],
-\       'description': 'Align help tags to the right margin',
-\   },
-\   'autopep8': {
-\       'function': 'ale#fixers#autopep8#Fix',
-\       'suggested_filetypes': ['python'],
-\       'description': 'Fix PEP8 issues with autopep8.',
-\   },
-\   'bibclean': {
-\       'function': 'ale#fixers#bibclean#Fix',
-\       'suggested_filetypes': ['bib'],
-\       'description': 'Format bib files using bibclean.',
-\   },
-\   'black': {
-\       'function': 'ale#fixers#black#Fix',
-\       'suggested_filetypes': ['python'],
-\       'description': 'Fix PEP8 issues with black.',
-\   },
-\   'dfmt': {
-\       'function': 'ale#fixers#dfmt#Fix',
-\       'suggested_filetypes': ['d'],
-\       'description': 'Fix D files with dfmt.',
-\   },
-\   'fecs': {
-\       'function': 'ale#fixers#fecs#Fix',
-\       'suggested_filetypes': ['javascript', 'css', 'html'],
-\       'description': 'Apply fecs format to a file.',
-\   },
-\   'tidy': {
-\       'function': 'ale#fixers#tidy#Fix',
-\       'suggested_filetypes': ['html'],
-\       'description': 'Fix HTML files with tidy.',
-\   },
-\   'prettier_standard': {
-\       'function': 'ale#fixers#prettier_standard#Fix',
-\       'suggested_filetypes': ['javascript'],
-\       'description': 'Apply prettier-standard to a file.',
-\       'aliases': ['prettier-standard'],
-\   },
-\   'elm-format': {
-\       'function': 'ale#fixers#elm_format#Fix',
-\       'suggested_filetypes': ['elm'],
-\       'description': 'Apply elm-format to a file.',
-\       'aliases': ['format'],
-\   },
-\   'nimpretty': {
-\       'function': 'ale#fixers#nimpretty#Fix',
-\       'suggested_filetypes': ['nim'],
-\       'description': 'Apply nimpretty to a file.',
-\   },
-\   'eslint': {
-\       'function': 'ale#fixers#eslint#Fix',
-\       'suggested_filetypes': ['javascript', 'typescript'],
-\       'description': 'Apply eslint --fix to a file.',
-\   },
-\   'mix_format': {
-\       'function': 'ale#fixers#mix_format#Fix',
-\       'suggested_filetypes': ['elixir'],
-\       'description': 'Apply mix format to a file.',
-\   },
-\   'isort': {
-\       'function': 'ale#fixers#isort#Fix',
-\       'suggested_filetypes': ['python'],
-\       'description': 'Sort Python imports with isort.',
-\   },
-\   'prettier': {
-\       'function': 'ale#fixers#prettier#Fix',
-\       'suggested_filetypes': ['javascript', 'typescript', 'css', 'less', 'scss', 'json', 'json5', 'graphql', 'markdown', 'vue', 'html', 'yaml'],
-\       'description': 'Apply prettier to a file.',
-\   },
-\   'prettier_eslint': {
-\       'function': 'ale#fixers#prettier_eslint#Fix',
-\       'suggested_filetypes': ['javascript'],
-\       'description': 'Apply prettier-eslint to a file.',
-\       'aliases': ['prettier-eslint'],
-\   },
-\   'importjs': {
-\       'function': 'ale#fixers#importjs#Fix',
-\       'suggested_filetypes': ['javascript'],
-\       'description': 'automatic imports for javascript',
-\   },
-\   'puppetlint': {
-\       'function': 'ale#fixers#puppetlint#Fix',
-\       'suggested_filetypes': ['puppet'],
-\       'description': 'Run puppet-lint -f on a file.',
-\   },
-\   'remove_trailing_lines': {
-\       'function': 'ale#fixers#generic#RemoveTrailingBlankLines',
-\       'suggested_filetypes': [],
-\       'description': 'Remove all blank lines at the end of a file.',
-\   },
-\   'trim_whitespace': {
-\       'function': 'ale#fixers#generic#TrimWhitespace',
-\       'suggested_filetypes': [],
-\       'description': 'Remove all trailing whitespace characters at the end of every line.',
-\   },
-\   'yapf': {
-\       'function': 'ale#fixers#yapf#Fix',
-\       'suggested_filetypes': ['python'],
-\       'description': 'Fix Python files with yapf.',
-\   },
-\   'rubocop': {
-\       'function': 'ale#fixers#rubocop#Fix',
-\       'suggested_filetypes': ['ruby'],
-\       'description': 'Fix ruby files with rubocop --auto-correct.',
-\   },
-\   'rufo': {
-\       'function': 'ale#fixers#rufo#Fix',
-\       'suggested_filetypes': ['ruby'],
-\       'description': 'Fix ruby files with rufo',
-\   },
-\   'scalafmt': {
-\       'function': 'ale#fixers#scalafmt#Fix',
-\       'suggested_filetypes': ['scala'],
-\       'description': 'Fix Scala files using scalafmt',
-\   },
-\   'sorbet': {
-\       'function': 'ale#fixers#sorbet#Fix',
-\       'suggested_filetypes': ['ruby'],
-\       'description': 'Fix ruby files with srb tc --autocorrect.',
-\   },
-\   'standard': {
-\       'function': 'ale#fixers#standard#Fix',
-\       'suggested_filetypes': ['javascript'],
-\       'description': 'Fix JavaScript files using standard --fix',
-\   },
-\   'standardrb': {
-\       'function': 'ale#fixers#standardrb#Fix',
-\       'suggested_filetypes': ['ruby'],
-\       'description': 'Fix ruby files with standardrb --fix',
-\   },
-\   'stylelint': {
-\       'function': 'ale#fixers#stylelint#Fix',
-\       'suggested_filetypes': ['css', 'sass', 'scss', 'sugarss', 'stylus'],
-\       'description': 'Fix stylesheet files using stylelint --fix.',
-\   },
-\   'swiftformat': {
-\       'function': 'ale#fixers#swiftformat#Fix',
-\       'suggested_filetypes': ['swift'],
-\       'description': 'Apply SwiftFormat to a file.',
-\   },
-\   'phpcbf': {
-\       'function': 'ale#fixers#phpcbf#Fix',
-\       'suggested_filetypes': ['php'],
-\       'description': 'Fix PHP files with phpcbf.',
-\   },
-\   'php_cs_fixer': {
-\       'function': 'ale#fixers#php_cs_fixer#Fix',
-\       'suggested_filetypes': ['php'],
-\       'description': 'Fix PHP files with php-cs-fixer.',
-\   },
-\   'clangtidy': {
-\       'function': 'ale#fixers#clangtidy#Fix',
-\       'suggested_filetypes': ['c', 'cpp', 'objc'],
-\       'description': 'Fix C/C++ and ObjectiveC files with clang-tidy.',
-\   },
-\   'clang-format': {
-\       'function': 'ale#fixers#clangformat#Fix',
-\       'suggested_filetypes': ['c', 'cpp', 'cuda'],
-\       'description': 'Fix C/C++ and cuda files with clang-format.',
-\   },
-\   'cmakeformat': {
-\       'function': 'ale#fixers#cmakeformat#Fix',
-\       'suggested_filetypes': ['cmake'],
-\       'description': 'Fix CMake files with cmake-format.',
-\   },
-\   'gofmt': {
-\       'function': 'ale#fixers#gofmt#Fix',
-\       'suggested_filetypes': ['go'],
-\       'description': 'Fix Go files with go fmt.',
-\   },
-\   'goimports': {
-\       'function': 'ale#fixers#goimports#Fix',
-\       'suggested_filetypes': ['go'],
-\       'description': 'Fix Go files imports with goimports.',
-\   },
-\   'gomod': {
-\       'function': 'ale#fixers#gomod#Fix',
-\       'suggested_filetypes': ['gomod'],
-\       'description': 'Fix Go module files with go mod edit -fmt.',
-\   },
-\   'tslint': {
-\       'function': 'ale#fixers#tslint#Fix',
-\       'suggested_filetypes': ['typescript'],
-\       'description': 'Fix typescript files with tslint --fix.',
-\   },
-\   'rustfmt': {
-\       'function': 'ale#fixers#rustfmt#Fix',
-\       'suggested_filetypes': ['rust'],
-\       'description': 'Fix Rust files with Rustfmt.',
-\   },
-\   'textlint': {
-\       'function': 'ale#fixers#textlint#Fix',
-\       'suggested_filetypes': ['text','markdown','asciidoc','tex'],
-\       'description': 'Fix text files with textlint --fix',
-\   },
-\   'hackfmt': {
-\       'function': 'ale#fixers#hackfmt#Fix',
-\       'suggested_filetypes': ['hack'],
-\       'description': 'Fix Hack files with hackfmt.',
-\   },
-\   'floskell': {
-\       'function': 'ale#fixers#floskell#Fix',
-\       'suggested_filetypes': ['haskell'],
-\       'description': 'Fix Haskell files with floskell.',
-\   },
-\   'hfmt': {
-\       'function': 'ale#fixers#hfmt#Fix',
-\       'suggested_filetypes': ['haskell'],
-\       'description': 'Fix Haskell files with hfmt.',
-\   },
-\   'brittany': {
-\       'function': 'ale#fixers#brittany#Fix',
-\       'suggested_filetypes': ['haskell'],
-\       'description': 'Fix Haskell files with brittany.',
-\   },
-\   'hindent': {
-\       'function': 'ale#fixers#hindent#Fix',
-\       'suggested_filetypes': ['haskell'],
-\       'description': 'Fix Haskell files with hindent.',
-\   },
-\   'hlint': {
-\       'function': 'ale#fixers#hlint#Fix',
-\       'suggested_filetypes': ['haskell'],
-\       'description': 'Refactor Haskell files with hlint.',
-\   },
-\   'stylish-haskell': {
-\       'function': 'ale#fixers#stylish_haskell#Fix',
-\       'suggested_filetypes': ['haskell'],
-\       'description': 'Refactor Haskell files with stylish-haskell.',
-\   },
-\   'purty': {
-\       'function': 'ale#fixers#purty#Fix',
-\       'suggested_filetypes': ['purescript'],
-\       'description': 'Format PureScript files with purty.',
-\   },
-\   'ocamlformat': {
-\       'function': 'ale#fixers#ocamlformat#Fix',
-\       'suggested_filetypes': ['ocaml'],
-\       'description': 'Fix OCaml files with ocamlformat.',
-\   },
-\   'ocp-indent': {
-\       'function': 'ale#fixers#ocp_indent#Fix',
-\       'suggested_filetypes': ['ocaml'],
-\       'description': 'Fix OCaml files with ocp-indent.',
-\   },
-\   'refmt': {
-\       'function': 'ale#fixers#refmt#Fix',
-\       'suggested_filetypes': ['reason'],
-\       'description': 'Fix ReasonML files with refmt.',
-\   },
-\   'shfmt': {
-\       'function': 'ale#fixers#shfmt#Fix',
-\       'suggested_filetypes': ['sh'],
-\       'description': 'Fix sh files with shfmt.',
-\   },
-\   'sqlfmt': {
-\       'function': 'ale#fixers#sqlfmt#Fix',
-\       'suggested_filetypes': ['sql'],
-\       'description': 'Fix SQL files with sqlfmt.',
-\   },
-\   'sqlformat': {
-\       'function': 'ale#fixers#sqlformat#Fix',
-\       'suggested_filetypes': ['sql'],
-\       'description': 'Fix SQL files with sqlformat.',
-\   },
-\   'google_java_format': {
-\       'function': 'ale#fixers#google_java_format#Fix',
-\       'suggested_filetypes': ['java'],
-\       'description': 'Fix Java files with google-java-format.',
-\   },
-\   'fixjson': {
-\       'function': 'ale#fixers#fixjson#Fix',
-\       'suggested_filetypes': ['json'],
-\       'description': 'Fix JSON files with fixjson.',
-\   },
-\   'jq': {
-\       'function': 'ale#fixers#jq#Fix',
-\       'suggested_filetypes': ['json'],
-\       'description': 'Fix JSON files with jq.',
-\   },
-\   'perltidy': {
-\       'function': 'ale#fixers#perltidy#Fix',
-\       'suggested_filetypes': ['perl'],
-\       'description': 'Fix Perl files with perltidy.',
-\   },
-\   'xo': {
-\       'function': 'ale#fixers#xo#Fix',
-\       'suggested_filetypes': ['javascript', 'typescript'],
-\       'description': 'Fix JavaScript/TypeScript files using xo --fix.',
-\   },
-\   'qmlfmt': {
-\       'function': 'ale#fixers#qmlfmt#Fix',
-\       'suggested_filetypes': ['qml'],
-\       'description': 'Fix QML files with qmlfmt.',
-\   },
-\   'dartfmt': {
-\       'function': 'ale#fixers#dartfmt#Fix',
-\       'suggested_filetypes': ['dart'],
-\       'description': 'Fix Dart files with dartfmt.',
-\   },
-\   'xmllint': {
-\       'function': 'ale#fixers#xmllint#Fix',
-\       'suggested_filetypes': ['xml'],
-\       'description': 'Fix XML files with xmllint.',
-\   },
-\   'uncrustify': {
-\       'function': 'ale#fixers#uncrustify#Fix',
-\       'suggested_filetypes': ['c', 'cpp', 'cs', 'objc', 'objcpp', 'd', 'java', 'p', 'vala' ],
-\       'description': 'Fix C, C++, C#, ObjectiveC, ObjectiveC++, D, Java, Pawn, and VALA files with uncrustify.',
-\   },
-\   'terraform': {
-\       'function': 'ale#fixers#terraform#Fix',
-\       'suggested_filetypes': ['hcl', 'terraform'],
-\       'description': 'Fix tf and hcl files with terraform fmt.',
-\   },
-\   'ktlint': {
-\       'function': 'ale#fixers#ktlint#Fix',
-\       'suggested_filetypes': ['kt'],
-\       'description': 'Fix Kotlin files with ktlint.',
-\   },
-\   'styler': {
-\       'function': 'ale#fixers#styler#Fix',
-\       'suggested_filetypes': ['r', 'rmarkdown', 'rmd'],
-\       'description': 'Fix R files with styler.',
-\   },
-\   'latexindent': {
-\       'function': 'ale#fixers#latexindent#Fix',
-\       'suggested_filetypes': ['tex'],
-\       'description' : 'Indent code within environments, commands, after headings and within special code blocks.',
-\   },
-\   'pgformatter': {
-\       'function': 'ale#fixers#pgformatter#Fix',
-\       'suggested_filetypes': ['sql'],
-\       'description': 'A PostgreSQL SQL syntax beautifier',
-\   },
-\   'reorder-python-imports': {
-\       'function': 'ale#fixers#reorder_python_imports#Fix',
-\       'suggested_filetypes': ['python'],
-\       'description': 'Sort Python imports with reorder-python-imports.',
-\   },
-\   'gnatpp': {
-\       'function': 'ale#fixers#gnatpp#Fix',
-\       'suggested_filetypes': ['ada'],
-\       'description': 'Format Ada files with gnatpp.',
-\   },
-\   'nixpkgs-fmt': {
-\       'function': 'ale#fixers#nixpkgsfmt#Fix',
-\       'suggested_filetypes': ['nix'],
-\       'description': 'A formatter for Nix code',
-\   },
-\   'html-beautify': {
-\       'function': 'ale#fixers#html_beautify#Fix',
-\       'suggested_filetypes': ['html', 'htmldjango'],
-\       'description': 'Fix HTML files with html-beautify.',
-\   },
-\}
-
-" Reset the function registry to the default entries.
-function! ale#fix#registry#ResetToDefaults() abort
-    let s:entries = deepcopy(s:default_registry)
-    let s:aliases = {}
-
-    " Set up aliases for fixers too.
-    for [l:key, l:entry] in items(s:entries)
-        for l:alias in get(l:entry, 'aliases', [])
-            let s:aliases[l:alias] = l:key
-        endfor
-    endfor
-endfunction
-
-" Set up entries now.
-call ale#fix#registry#ResetToDefaults()
-
-" Remove everything from the registry, useful for tests.
-function! ale#fix#registry#Clear() abort
-    let s:entries = {}
-    let s:aliases = {}
-endfunction
-
-" Add a function for fixing problems to the registry.
-" (name, func, filetypes, desc, aliases)
-function! ale#fix#registry#Add(name, func, filetypes, desc, ...) abort
-    " This command will throw from the sandbox.
-    let &l:equalprg=&l:equalprg
-
-    if type(a:name) isnot v:t_string
-        throw '''name'' must be a String'
-    endif
-
-    if type(a:func) isnot v:t_string
-        throw '''func'' must be a String'
-    endif
-
-    if type(a:filetypes) isnot v:t_list
-        throw '''filetypes'' must be a List'
-    endif
-
-    for l:type in a:filetypes
-        if type(l:type) isnot v:t_string
-            throw 'Each entry of ''filetypes'' must be a String'
-        endif
-    endfor
-
-    if type(a:desc) isnot v:t_string
-        throw '''desc'' must be a String'
-    endif
-
-    let l:aliases = get(a:000, 0, [])
-
-    if type(l:aliases) isnot v:t_list
-    \|| !empty(filter(copy(l:aliases), 'type(v:val) isnot v:t_string'))
-        throw '''aliases'' must be a List of String values'
-    endif
-
-    let s:entries[a:name] = {
-    \   'function': a:func,
-    \   'suggested_filetypes': a:filetypes,
-    \   'description': a:desc,
-    \}
-
-    " Set up aliases for the fixer.
-    if !empty(l:aliases)
-        let s:entries[a:name].aliases = l:aliases
-
-        for l:alias in l:aliases
-            let s:aliases[l:alias] = a:name
-        endfor
-    endif
-endfunction
-
-" Get a function from the registry by its short name.
-function! ale#fix#registry#GetFunc(name) abort
-    " Use the exact name, or an alias.
-    let l:resolved_name = !has_key(s:entries, a:name)
-    \   ? get(s:aliases, a:name, a:name)
-    \   : a:name
-
-    return get(s:entries, l:resolved_name, {'function': ''}).function
-endfunction
-
-function! s:ShouldSuggestForType(suggested_filetypes, type_list) abort
-    for l:type in a:type_list
-        if index(a:suggested_filetypes, l:type) >= 0
-            return 1
-        endif
-    endfor
-
-    return 0
-endfunction
-
-function! s:IsGenericFixer(suggested_filetypes) abort
-    if empty(a:suggested_filetypes)
-        return 1
-    endif
-
-    return 0
-endfunction
-
-function! s:FormatEntry(key, entry) abort
-    let l:aliases_str = ''
-
-    " Show aliases in :ALEFixSuggest if they are there.
-    if !empty(get(a:entry, 'aliases', []))
-        let l:aliases_str = ', ' . join(
-        \   map(copy(a:entry.aliases), 'string(v:val)'),
-        \   ','
-        \)
-    endif
-
-    return printf(
-    \   '%s%s - %s',
-    \   string(a:key),
-    \   l:aliases_str,
-    \   a:entry.description,
-    \)
-endfunction
-
-" Get list of applicable fixers for filetype, including generic fixers
-function! ale#fix#registry#GetApplicableFixers(filetype) abort
-    let l:type_list = split(a:filetype, '\.')
-    let l:fixer_name_list = []
-
-    for l:key in sort(keys(s:entries))
-        let l:suggested_filetypes = s:entries[l:key].suggested_filetypes
-
-        if s:IsGenericFixer(l:suggested_filetypes) || s:ShouldSuggestForType(l:suggested_filetypes, l:type_list)
-            call add(l:fixer_name_list, l:key)
-        endif
-    endfor
-
-    return l:fixer_name_list
-endfunction
-
-" Function that returns autocomplete candidates for ALEFix command
-function! ale#fix#registry#CompleteFixers(ArgLead, CmdLine, CursorPos) abort
-    return filter(ale#fix#registry#GetApplicableFixers(&filetype), 'v:val =~? a:ArgLead')
-endfunction
-
-function! ale#fix#registry#SuggestedFixers(filetype) abort
-    let l:type_list = split(a:filetype, '\.')
-    let l:filetype_fixer_list = []
-
-    for l:key in sort(keys(s:entries))
-        let l:suggested_filetypes = s:entries[l:key].suggested_filetypes
-
-        if s:ShouldSuggestForType(l:suggested_filetypes, l:type_list)
-            call add(
-            \   l:filetype_fixer_list,
-            \   s:FormatEntry(l:key, s:entries[l:key]),
-            \)
-        endif
-    endfor
-
-    let l:generic_fixer_list = []
-
-    for l:key in sort(keys(s:entries))
-        if s:IsGenericFixer(s:entries[l:key].suggested_filetypes)
-            call add(
-            \   l:generic_fixer_list,
-            \   s:FormatEntry(l:key, s:entries[l:key]),
-            \)
-        endif
-    endfor
-
-    return [l:filetype_fixer_list, l:generic_fixer_list]
-endfunction
-
-" Suggest functions to use from the registry.
-function! ale#fix#registry#Suggest(filetype) abort
-    let l:suggested = ale#fix#registry#SuggestedFixers(a:filetype)
-    let l:filetype_fixer_list = l:suggested[0]
-    let l:generic_fixer_list = l:suggested[1]
-
-    let l:filetype_fixer_header = !empty(l:filetype_fixer_list)
-    \   ? ['Try the following fixers appropriate for the filetype:', '']
-    \   : []
-    let l:generic_fixer_header = !empty(l:generic_fixer_list)
-    \   ? ['Try the following generic fixers:', '']
-    \   : []
-
-    let l:has_both_lists = !empty(l:filetype_fixer_list) && !empty(l:generic_fixer_list)
-
-    let l:lines =
-    \   l:filetype_fixer_header
-    \   + l:filetype_fixer_list
-    \   + (l:has_both_lists ? [''] : [])
-    \   + l:generic_fixer_header
-    \   + l:generic_fixer_list
-
-    if empty(l:lines)
-        let l:lines = ['There is nothing in the registry to suggest.']
-    else
-        let l:lines += ['', 'See :help ale-fix-configuration']
-    endif
-
-    let l:lines += ['', 'Press q to close this window']
-
-    new +set\ filetype=ale-fix-suggest
-    call setline(1, l:lines)
-    setlocal nomodified
-    setlocal nomodifiable
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/fixers/autopep8.vim b/sources_non_forked/ale/autoload/ale/fixers/autopep8.vim
deleted file mode 100644
index 5798d82..0000000
--- a/sources_non_forked/ale/autoload/ale/fixers/autopep8.vim
+++ /dev/null
@@ -1,26 +0,0 @@
-" Author: w0rp <devw0rp@gmail.com>
-" Description: Fixing files with autopep8.
-
-call ale#Set('python_autopep8_executable', 'autopep8')
-call ale#Set('python_autopep8_use_global', get(g:, 'ale_use_global_executables', 0))
-call ale#Set('python_autopep8_options', '')
-
-function! ale#fixers#autopep8#Fix(buffer) abort
-    let l:executable = ale#python#FindExecutable(
-    \   a:buffer,
-    \   'python_autopep8',
-    \   ['autopep8'],
-    \)
-
-    if !executable(l:executable)
-        return 0
-    endif
-
-    let l:options = ale#Var(a:buffer, 'python_autopep8_options')
-
-    return {
-    \   'command': ale#Escape(l:executable)
-    \       . (!empty(l:options) ? ' ' . l:options : '')
-    \       . ' -',
-    \}
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/fixers/bibclean.vim b/sources_non_forked/ale/autoload/ale/fixers/bibclean.vim
deleted file mode 100644
index 89cb97a..0000000
--- a/sources_non_forked/ale/autoload/ale/fixers/bibclean.vim
+++ /dev/null
@@ -1,15 +0,0 @@
-" Author: Horacio Sanson - https://github.com/hsanson
-" Description: Support for bibclean fixer for BibTeX files.
-
-call ale#Set('bib_bibclean_executable', 'bibclean')
-call ale#Set('bib_bibclean_options', '-align-equals')
-
-function! ale#fixers#bibclean#Fix(buffer) abort
-    let l:options = ale#Var(a:buffer, 'bib_bibclean_options')
-    let l:executable = ale#Var(a:buffer, 'bib_bibclean_executable')
-
-    return {
-    \   'command': ale#Escape(l:executable)
-    \       . ' ' . (empty(l:options) ? '' : l:options),
-    \}
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/fixers/black.vim b/sources_non_forked/ale/autoload/ale/fixers/black.vim
deleted file mode 100644
index fba6c3b..0000000
--- a/sources_non_forked/ale/autoload/ale/fixers/black.vim
+++ /dev/null
@@ -1,41 +0,0 @@
-" Author: w0rp <devw0rp@gmail.com>
-" Description: Fixing Python files with black.
-"
-call ale#Set('python_black_executable', 'black')
-call ale#Set('python_black_use_global', get(g:, 'ale_use_global_executables', 0))
-call ale#Set('python_black_options', '')
-call ale#Set('python_black_auto_pipenv', 0)
-call ale#Set('python_black_change_directory', 1)
-
-function! ale#fixers#black#GetExecutable(buffer) abort
-    if (ale#Var(a:buffer, 'python_auto_pipenv') || ale#Var(a:buffer, 'python_black_auto_pipenv'))
-    \ && ale#python#PipenvPresent(a:buffer)
-        return 'pipenv'
-    endif
-
-    return ale#python#FindExecutable(a:buffer, 'python_black', ['black'])
-endfunction
-
-function! ale#fixers#black#Fix(buffer) abort
-    let l:cd_string = ale#Var(a:buffer, 'python_black_change_directory')
-    \   ? ale#path#BufferCdString(a:buffer)
-    \   : ''
-
-    let l:executable = ale#fixers#black#GetExecutable(a:buffer)
-
-    let l:exec_args = l:executable =~? 'pipenv$'
-    \   ? ' run black'
-    \   : ''
-
-    let l:options = ale#Var(a:buffer, 'python_black_options')
-
-    if expand('#' . a:buffer . ':e') is? 'pyi'
-        let l:options .= '--pyi'
-    endif
-
-    return {
-    \   'command': l:cd_string . ale#Escape(l:executable) . l:exec_args
-    \       . (!empty(l:options) ? ' ' . l:options : '')
-    \       . ' -',
-    \}
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/fixers/brittany.vim b/sources_non_forked/ale/autoload/ale/fixers/brittany.vim
deleted file mode 100644
index c244834..0000000
--- a/sources_non_forked/ale/autoload/ale/fixers/brittany.vim
+++ /dev/null
@@ -1,22 +0,0 @@
-" Author: eborden <evan@evan-borden.com>, ifyouseewendy <ifyouseewendy@gmail.com>, aspidiets <emarshall85@gmail.com>
-" Description: Integration of brittany with ALE.
-
-call ale#Set('haskell_brittany_executable', 'brittany')
-
-function! ale#fixers#brittany#GetExecutable(buffer) abort
-    let l:executable = ale#Var(a:buffer, 'haskell_brittany_executable')
-
-    return ale#handlers#haskell_stack#EscapeExecutable(l:executable, 'brittany')
-endfunction
-
-function! ale#fixers#brittany#Fix(buffer) abort
-    let l:executable = ale#fixers#brittany#GetExecutable(a:buffer)
-
-    return {
-    \   'command': l:executable
-    \       . ' --write-mode inplace'
-    \       . ' %t',
-    \   'read_temporary_file': 1,
-    \}
-endfunction
-
diff --git a/sources_non_forked/ale/autoload/ale/fixers/clangformat.vim b/sources_non_forked/ale/autoload/ale/fixers/clangformat.vim
deleted file mode 100644
index ea5743a..0000000
--- a/sources_non_forked/ale/autoload/ale/fixers/clangformat.vim
+++ /dev/null
@@ -1,27 +0,0 @@
-scriptencoding utf-8
-" Author: Peter Renstrm <renstrom.peter@gmail.com>
-" Description: Fixing C/C++ files with clang-format.
-
-call ale#Set('c_clangformat_executable', 'clang-format')
-call ale#Set('c_clangformat_use_global', get(g:, 'ale_use_global_executables', 0))
-call ale#Set('c_clangformat_options', '')
-
-function! ale#fixers#clangformat#GetExecutable(buffer) abort
-    return ale#node#FindExecutable(a:buffer, 'c_clangformat', [
-    \   'clang-format',
-    \])
-endfunction
-
-function! ale#fixers#clangformat#Fix(buffer) abort
-    let l:executable = ale#Escape(ale#fixers#clangformat#GetExecutable(a:buffer))
-    let l:filename = ale#Escape(bufname(a:buffer))
-    let l:options = ale#Var(a:buffer, 'c_clangformat_options')
-
-    let l:command = l:executable . ' --assume-filename=' . l:filename
-
-    if l:options isnot# ''
-        let l:command .= ' ' . l:options
-    endif
-
-    return {'command': l:command}
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/fixers/clangtidy.vim b/sources_non_forked/ale/autoload/ale/fixers/clangtidy.vim
deleted file mode 100644
index b37360a..0000000
--- a/sources_non_forked/ale/autoload/ale/fixers/clangtidy.vim
+++ /dev/null
@@ -1,52 +0,0 @@
-scriptencoding utf-8
-" Author: ObserverOfTime <chronobserver@disroot.org>
-" Description: Fixing C/C++ files with clang-tidy.
-
-function! s:set_variables() abort
-    let l:use_global = get(g:, 'ale_use_global_executables', 0)
-
-    for l:ft in ['c', 'cpp']
-        call ale#Set(l:ft . '_clangtidy_executable', 'clang-tidy')
-        call ale#Set(l:ft . '_clangtidy_use_global', l:use_global)
-        call ale#Set(l:ft . '_clangtidy_checks', [])
-        call ale#Set(l:ft . '_clangtidy_options', '')
-        call ale#Set(l:ft . '_clangtidy_extra_options', '')
-        call ale#Set(l:ft . '_clangtidy_fix_errors', 1)
-    endfor
-
-    call ale#Set('c_build_dir', '')
-endfunction
-
-call s:set_variables()
-
-function! ale#fixers#clangtidy#Var(buffer, name) abort
-    let l:ft = getbufvar(str2nr(a:buffer), '&filetype')
-    let l:ft = l:ft =~# 'cpp' ? 'cpp' : 'c'
-
-    return ale#Var(a:buffer, l:ft . '_clangtidy_' . a:name)
-endfunction
-
-function! ale#fixers#clangtidy#GetCommand(buffer) abort
-    let l:checks = join(ale#fixers#clangtidy#Var(a:buffer, 'checks'), ',')
-    let l:extra_options = ale#fixers#clangtidy#Var(a:buffer, 'extra_options')
-    let l:build_dir = ale#c#GetBuildDirectory(a:buffer)
-    let l:options = empty(l:build_dir)
-    \   ? ale#fixers#clangtidy#Var(a:buffer, 'options') : ''
-    let l:fix_errors = ale#fixers#clangtidy#Var(a:buffer, 'fix_errors')
-
-    return ' -fix' . (l:fix_errors ? ' -fix-errors' : '')
-    \   . (empty(l:checks) ? '' : ' -checks=' . ale#Escape(l:checks))
-    \   . (empty(l:extra_options) ? '' : ' ' . l:extra_options)
-    \   . (empty(l:build_dir) ? '' : ' -p ' . ale#Escape(l:build_dir))
-    \   . ' %t' . (empty(l:options) ? '' : ' -- ' . l:options)
-endfunction
-
-function! ale#fixers#clangtidy#Fix(buffer) abort
-    let l:executable = ale#fixers#clangtidy#Var(a:buffer, 'executable')
-    let l:command = ale#fixers#clangtidy#GetCommand(a:buffer)
-
-    return {
-    \   'command': ale#Escape(l:executable) . l:command,
-    \   'read_temporary_file': 1,
-    \}
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/fixers/cmakeformat.vim b/sources_non_forked/ale/autoload/ale/fixers/cmakeformat.vim
deleted file mode 100644
index f40ed6e..0000000
--- a/sources_non_forked/ale/autoload/ale/fixers/cmakeformat.vim
+++ /dev/null
@@ -1,18 +0,0 @@
-" Author: Attila Maczak <attila@maczak.hu>
-" Description: Integration of cmakeformat with ALE.
-
-call ale#Set('cmake_cmakeformat_executable', 'cmake-format')
-call ale#Set('cmake_cmakeformat_options', '')
-
-function! ale#fixers#cmakeformat#Fix(buffer) abort
-    let l:executable = ale#Var(a:buffer, 'cmake_cmakeformat_executable')
-    let l:options = ale#Var(a:buffer, 'cmake_cmakeformat_options')
-
-    return {
-    \   'command': ale#Escape(l:executable)
-    \       . ' -i '
-    \       . (empty(l:options) ? '' : ' ' . l:options)
-    \       . ' %t',
-    \   'read_temporary_file': 1,
-    \}
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/fixers/dartfmt.vim b/sources_non_forked/ale/autoload/ale/fixers/dartfmt.vim
deleted file mode 100644
index 0687d6d..0000000
--- a/sources_non_forked/ale/autoload/ale/fixers/dartfmt.vim
+++ /dev/null
@@ -1,18 +0,0 @@
-" Author: reisub0 <reisub0@gmail.com>
-" Description: Integration of dartfmt with ALE.
-
-call ale#Set('dart_dartfmt_executable', 'dartfmt')
-call ale#Set('dart_dartfmt_options', '')
-
-function! ale#fixers#dartfmt#Fix(buffer) abort
-    let l:executable = ale#Var(a:buffer, 'dart_dartfmt_executable')
-    let l:options = ale#Var(a:buffer, 'dart_dartfmt_options')
-
-    return {
-    \   'command': ale#Escape(l:executable)
-    \       . ' -w'
-    \       . (empty(l:options) ? '' : ' ' . l:options)
-    \       . ' %t',
-    \   'read_temporary_file': 1,
-    \}
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/fixers/dfmt.vim b/sources_non_forked/ale/autoload/ale/fixers/dfmt.vim
deleted file mode 100644
index 0072e04..0000000
--- a/sources_non_forked/ale/autoload/ale/fixers/dfmt.vim
+++ /dev/null
@@ -1,18 +0,0 @@
-" Author: theoldmoon0602
-" Description: Integration of dfmt with ALE.
-
-call ale#Set('d_dfmt_executable', 'dfmt')
-call ale#Set('d_dfmt_options', '')
-
-function! ale#fixers#dfmt#Fix(buffer) abort
-    let l:executable = ale#Var(a:buffer, 'd_dfmt_executable')
-    let l:options = ale#Var(a:buffer, 'd_dfmt_options')
-
-    return {
-    \   'command': ale#Escape(l:executable)
-    \       . ' -i'
-    \       . (empty(l:options) ? '' : ' ' . l:options)
-    \       . ' %t',
-    \   'read_temporary_file': 1,
-    \}
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/fixers/elm_format.vim b/sources_non_forked/ale/autoload/ale/fixers/elm_format.vim
deleted file mode 100644
index cd2be2c..0000000
--- a/sources_non_forked/ale/autoload/ale/fixers/elm_format.vim
+++ /dev/null
@@ -1,23 +0,0 @@
-" Author: soywod <clement.douin@gmail.com>
-" Description: Integration of elm-format with ALE.
-
-call ale#Set('elm_format_executable', 'elm-format')
-call ale#Set('elm_format_use_global', get(g:, 'ale_use_global_executables', 0))
-call ale#Set('elm_format_options', '--yes')
-
-function! ale#fixers#elm_format#GetExecutable(buffer) abort
-    return ale#node#FindExecutable(a:buffer, 'elm_format', [
-    \   'node_modules/.bin/elm-format',
-    \])
-endfunction
-
-function! ale#fixers#elm_format#Fix(buffer) abort
-    let l:options = ale#Var(a:buffer, 'elm_format_options')
-
-    return {
-    \   'command': ale#Escape(ale#fixers#elm_format#GetExecutable(a:buffer))
-    \       . ' %t'
-    \       . (empty(l:options) ? '' : ' ' . l:options),
-    \   'read_temporary_file': 1,
-    \}
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/fixers/eslint.vim b/sources_non_forked/ale/autoload/ale/fixers/eslint.vim
deleted file mode 100644
index 62e692b..0000000
--- a/sources_non_forked/ale/autoload/ale/fixers/eslint.vim
+++ /dev/null
@@ -1,80 +0,0 @@
-" Author: w0rp <devw0rp@gmail.com>
-" Description: Fixing files with eslint.
-
-function! ale#fixers#eslint#Fix(buffer) abort
-    let l:executable = ale#handlers#eslint#GetExecutable(a:buffer)
-    let l:command = ale#node#Executable(a:buffer, l:executable)
-    \   . ' --version'
-
-    return ale#semver#RunWithVersionCheck(
-    \   a:buffer,
-    \   l:executable,
-    \   l:command,
-    \   function('ale#fixers#eslint#ApplyFixForVersion'),
-    \)
-endfunction
-
-function! ale#fixers#eslint#ProcessFixDryRunOutput(buffer, output) abort
-    for l:item in ale#util#FuzzyJSONDecode(a:output, [])
-        return split(get(l:item, 'output', ''), "\n")
-    endfor
-
-    return []
-endfunction
-
-function! ale#fixers#eslint#ProcessEslintDOutput(buffer, output) abort
-    " If the output is an error message, don't use it.
-    for l:line in a:output[:10]
-        if l:line =~# '\v^Error:|^Could not connect'
-            return []
-        endif
-    endfor
-
-    return a:output
-endfunction
-
-function! ale#fixers#eslint#ApplyFixForVersion(buffer, version) abort
-    let l:executable = ale#handlers#eslint#GetExecutable(a:buffer)
-    let l:options = ale#Var(a:buffer, 'javascript_eslint_options')
-
-    " Use the configuration file from the options, if configured.
-    if l:options =~# '\v(^| )-c|(^| )--config'
-        let l:config = ''
-        let l:has_config = 1
-    else
-        let l:config = ale#handlers#eslint#FindConfig(a:buffer)
-        let l:has_config = !empty(l:config)
-    endif
-
-    if !l:has_config
-        return 0
-    endif
-
-    " Use --fix-to-stdout with eslint_d
-    if l:executable =~# 'eslint_d$' && ale#semver#GTE(a:version, [3, 19, 0])
-        return {
-        \   'command': ale#node#Executable(a:buffer, l:executable)
-        \       . ale#Pad(l:options)
-        \       . ' --stdin-filename %s --stdin --fix-to-stdout',
-        \   'process_with': 'ale#fixers#eslint#ProcessEslintDOutput',
-        \}
-    endif
-
-    " 4.9.0 is the first version with --fix-dry-run
-    if ale#semver#GTE(a:version, [4, 9, 0])
-        return {
-        \   'command': ale#node#Executable(a:buffer, l:executable)
-        \       . ale#Pad(l:options)
-        \       . ' --stdin-filename %s --stdin --fix-dry-run --format=json',
-        \   'process_with': 'ale#fixers#eslint#ProcessFixDryRunOutput',
-        \}
-    endif
-
-    return {
-    \   'command': ale#node#Executable(a:buffer, l:executable)
-    \       . ale#Pad(l:options)
-    \       . (!empty(l:config) ? ' -c ' . ale#Escape(l:config) : '')
-    \       . ' --fix %t',
-    \   'read_temporary_file': 1,
-    \}
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/fixers/fecs.vim b/sources_non_forked/ale/autoload/ale/fixers/fecs.vim
deleted file mode 100644
index d692bc9..0000000
--- a/sources_non_forked/ale/autoload/ale/fixers/fecs.vim
+++ /dev/null
@@ -1,17 +0,0 @@
-" Author: harttle <yangjvn@126.com>
-" Description: Apply fecs format to a file.
-
-function! ale#fixers#fecs#Fix(buffer) abort
-    let l:executable = ale#handlers#fecs#GetExecutable(a:buffer)
-
-    if !executable(l:executable)
-        return 0
-    endif
-
-    let l:config_options = ' format --replace=true %t'
-
-    return {
-    \   'command': ale#Escape(l:executable) . l:config_options,
-    \   'read_temporary_file': 1,
-    \}
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/fixers/fixjson.vim b/sources_non_forked/ale/autoload/ale/fixers/fixjson.vim
deleted file mode 100644
index 33ce0af..0000000
--- a/sources_non_forked/ale/autoload/ale/fixers/fixjson.vim
+++ /dev/null
@@ -1,28 +0,0 @@
-" Author: rhysd <https://rhysd.github.io>
-" Description: Integration of fixjson with ALE.
-
-call ale#Set('json_fixjson_executable', 'fixjson')
-call ale#Set('json_fixjson_options', '')
-call ale#Set('json_fixjson_use_global', get(g:, 'ale_use_global_executables', 0))
-
-function! ale#fixers#fixjson#GetExecutable(buffer) abort
-    return ale#node#FindExecutable(a:buffer, 'json_fixjson', [
-    \   'node_modules/.bin/fixjson',
-    \])
-endfunction
-
-function! ale#fixers#fixjson#Fix(buffer) abort
-    let l:executable = ale#Escape(ale#fixers#fixjson#GetExecutable(a:buffer))
-    let l:filename = ale#Escape(bufname(a:buffer))
-    let l:command = l:executable . ' --stdin-filename ' . l:filename
-
-    let l:options = ale#Var(a:buffer, 'json_fixjson_options')
-
-    if l:options isnot# ''
-        let l:command .= ' ' . l:options
-    endif
-
-    return {
-    \   'command': l:command
-    \}
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/fixers/floskell.vim b/sources_non_forked/ale/autoload/ale/fixers/floskell.vim
deleted file mode 100644
index f0015db..0000000
--- a/sources_non_forked/ale/autoload/ale/fixers/floskell.vim
+++ /dev/null
@@ -1,20 +0,0 @@
-" Author: robertjlooby <robertjlooby@gmail.com>
-" Description: Integration of floskell with ALE.
-
-call ale#Set('haskell_floskell_executable', 'floskell')
-
-function! ale#fixers#floskell#GetExecutable(buffer) abort
-    let l:executable = ale#Var(a:buffer, 'haskell_floskell_executable')
-
-    return ale#handlers#haskell_stack#EscapeExecutable(l:executable, 'floskell')
-endfunction
-
-function! ale#fixers#floskell#Fix(buffer) abort
-    let l:executable = ale#fixers#floskell#GetExecutable(a:buffer)
-
-    return {
-    \   'command': l:executable
-    \       . ' %t',
-    \   'read_temporary_file': 1,
-    \}
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/fixers/generic.vim b/sources_non_forked/ale/autoload/ale/fixers/generic.vim
deleted file mode 100644
index cb8865b..0000000
--- a/sources_non_forked/ale/autoload/ale/fixers/generic.vim
+++ /dev/null
@@ -1,25 +0,0 @@
-" Author: w0rp <devw0rp@gmail.com>
-" Description: Generic functions for fixing files with.
-
-function! ale#fixers#generic#RemoveTrailingBlankLines(buffer, lines) abort
-    let l:end_index = len(a:lines) - 1
-
-    while l:end_index > 0 && empty(a:lines[l:end_index])
-        let l:end_index -= 1
-    endwhile
-
-    return a:lines[:l:end_index]
-endfunction
-
-" Remove all whitespaces at the end of lines
-function! ale#fixers#generic#TrimWhitespace(buffer, lines) abort
-    let l:index = 0
-    let l:lines_new = range(len(a:lines))
-
-    for l:line in a:lines
-        let l:lines_new[l:index] = substitute(l:line, '\s\+$', '', 'g')
-        let l:index = l:index + 1
-    endfor
-
-    return l:lines_new
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/fixers/generic_python.vim b/sources_non_forked/ale/autoload/ale/fixers/generic_python.vim
deleted file mode 100644
index d55a23c..0000000
--- a/sources_non_forked/ale/autoload/ale/fixers/generic_python.vim
+++ /dev/null
@@ -1,75 +0,0 @@
-" Author: w0rp <devw0rp@gmail.com>
-" Description: Generic fixer functions for Python.
-
-" Add blank lines before control statements.
-function! ale#fixers#generic_python#AddLinesBeforeControlStatements(buffer, lines) abort
-    let l:new_lines = []
-    let l:last_indent_size = 0
-    let l:last_line_is_blank = 0
-    let l:in_docstring = 0
-
-    for l:line in a:lines
-        let l:indent_size = len(matchstr(l:line, '^ *'))
-
-        if !l:in_docstring
-            " Make sure it is not just a single line docstring and then verify
-            " it's starting a new docstring
-            if match(l:line, '\v^ *("""|'''''').*("""|'''''')') == -1
-            \&& match(l:line, '\v^ *("""|'''''')') >= 0
-                let l:in_docstring = 1
-            endif
-        else
-            if match(l:line, '\v^ *.*("""|'''''')') >= 0
-                let l:in_docstring = 0
-            endif
-        endif
-
-        if !l:last_line_is_blank
-        \&& !l:in_docstring
-        \&& l:indent_size <= l:last_indent_size
-        \&& match(l:line, '\v^ *(return|if|for|while|break|continue)(\(| |$)') >= 0
-            call add(l:new_lines, '')
-        endif
-
-        call add(l:new_lines, l:line)
-        let l:last_indent_size = l:indent_size
-        let l:last_line_is_blank = empty(split(l:line))
-    endfor
-
-    return l:new_lines
-endfunction
-
-" This function breaks up long lines so that autopep8 or other tools can
-" fix the badly-indented code which is produced as a result.
-function! ale#fixers#generic_python#BreakUpLongLines(buffer, lines) abort
-    " Default to a maximum line length of 79
-    let l:max_line_length = 79
-    let l:conf = ale#path#FindNearestFile(a:buffer, 'setup.cfg')
-
-    " Read the maximum line length from setup.cfg
-    if !empty(l:conf)
-        for l:match in ale#util#GetMatches(
-        \   readfile(l:conf),
-        \   '\v^ *max-line-length *\= *(\d+)',
-        \)
-            let l:max_line_length = str2nr(l:match[1])
-        endfor
-    endif
-
-    let l:new_list = []
-
-    for l:line in a:lines
-        if len(l:line) > l:max_line_length && l:line !~# '# *noqa'
-            let l:line = substitute(l:line, '\v([(,])([^)])', '\1\n\2', 'g')
-            let l:line = substitute(l:line, '\v([^(])([)])', '\1,\n\2', 'g')
-
-            for l:split_line in split(l:line, "\n")
-                call add(l:new_list, l:split_line)
-            endfor
-        else
-            call add(l:new_list, l:line)
-        endif
-    endfor
-
-    return l:new_list
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/fixers/gnatpp.vim b/sources_non_forked/ale/autoload/ale/fixers/gnatpp.vim
deleted file mode 100644
index bf3d484..0000000
--- a/sources_non_forked/ale/autoload/ale/fixers/gnatpp.vim
+++ /dev/null
@@ -1,17 +0,0 @@
-" Author: tim <tim@inept.tech>
-" Description: Fix files with gnatpp.
-
-call ale#Set('ada_gnatpp_executable', 'gnatpp')
-call ale#Set('ada_gnatpp_options', '')
-
-function! ale#fixers#gnatpp#Fix(buffer) abort
-    let l:executable = ale#Var(a:buffer, 'ada_gnatpp_executable')
-    let l:options = ale#Var(a:buffer, 'ada_gnatpp_options')
-
-    return {
-    \   'command': ale#Escape(l:executable)
-    \       . (!empty(l:options) ? ' ' . l:options : '')
-    \       . ' %t',
-    \   'read_temporary_file': 1,
-    \}
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/fixers/gofmt.vim b/sources_non_forked/ale/autoload/ale/fixers/gofmt.vim
deleted file mode 100644
index d5a539b..0000000
--- a/sources_non_forked/ale/autoload/ale/fixers/gofmt.vim
+++ /dev/null
@@ -1,19 +0,0 @@
-" Author: aliou <code@aliou.me>
-" Description: Integration of gofmt with ALE.
-
-call ale#Set('go_gofmt_executable', 'gofmt')
-call ale#Set('go_gofmt_options', '')
-
-function! ale#fixers#gofmt#Fix(buffer) abort
-    let l:executable = ale#Var(a:buffer, 'go_gofmt_executable')
-    let l:options = ale#Var(a:buffer, 'go_gofmt_options')
-    let l:env = ale#go#EnvString(a:buffer)
-
-    return {
-    \   'command': l:env . ale#Escape(l:executable)
-    \       . ' -l -w'
-    \       . (empty(l:options) ? '' : ' ' . l:options)
-    \       . ' %t',
-    \   'read_temporary_file': 1,
-    \}
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/fixers/goimports.vim b/sources_non_forked/ale/autoload/ale/fixers/goimports.vim
deleted file mode 100644
index 65f0fd9..0000000
--- a/sources_non_forked/ale/autoload/ale/fixers/goimports.vim
+++ /dev/null
@@ -1,23 +0,0 @@
-" Author: Jeff Willette <jrwillette88@gmail.com>
-" Description: Integration of goimports with ALE.
-
-call ale#Set('go_goimports_executable', 'goimports')
-call ale#Set('go_goimports_options', '')
-
-function! ale#fixers#goimports#Fix(buffer) abort
-    let l:executable = ale#Var(a:buffer, 'go_goimports_executable')
-    let l:options = ale#Var(a:buffer, 'go_goimports_options')
-    let l:env = ale#go#EnvString(a:buffer)
-
-    if !executable(l:executable)
-        return 0
-    endif
-
-    return {
-    \   'command': l:env . ale#Escape(l:executable)
-    \       . ' -l -w -srcdir %s'
-    \       . (empty(l:options) ? '' : ' ' . l:options)
-    \       . ' %t',
-    \   'read_temporary_file': 1,
-    \}
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/fixers/gomod.vim b/sources_non_forked/ale/autoload/ale/fixers/gomod.vim
deleted file mode 100644
index ee8c46c..0000000
--- a/sources_non_forked/ale/autoload/ale/fixers/gomod.vim
+++ /dev/null
@@ -1,11 +0,0 @@
-call ale#Set('go_go_executable', 'go')
-
-function! ale#fixers#gomod#Fix(buffer) abort
-    let l:executable = ale#Var(a:buffer, 'go_go_executable')
-    let l:env = ale#go#EnvString(a:buffer)
-
-    return {
-    \   'command': l:env . ale#Escape(l:executable) . ' mod edit -fmt %t',
-    \   'read_temporary_file': 1,
-    \}
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/fixers/google_java_format.vim b/sources_non_forked/ale/autoload/ale/fixers/google_java_format.vim
deleted file mode 100644
index 20086c7..0000000
--- a/sources_non_forked/ale/autoload/ale/fixers/google_java_format.vim
+++ /dev/null
@@ -1,23 +0,0 @@
-" Author: butlerx <butlerx@notthe,cloud>
-" Description: Integration of Google-java-format with ALE.
-
-call ale#Set('java_google_java_format_executable', 'google-java-format')
-call ale#Set('java_google_java_format_use_global', get(g:, 'ale_use_global_executables', 0))
-call ale#Set('java_google_java_format_options', '')
-
-function! ale#fixers#google_java_format#Fix(buffer) abort
-    let l:options = ale#Var(a:buffer, 'java_google_java_format_options')
-    let l:executable = ale#Var(a:buffer, 'java_google_java_format_executable')
-
-    if !executable(l:executable)
-        return 0
-    endif
-
-    return {
-    \   'command': ale#Escape(l:executable)
-    \       . ' ' . (empty(l:options) ? '' : ' ' . l:options)
-    \       . ' --replace'
-    \       . ' %t',
-    \   'read_temporary_file': 1,
-    \}
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/fixers/hackfmt.vim b/sources_non_forked/ale/autoload/ale/fixers/hackfmt.vim
deleted file mode 100644
index bf2d4f7..0000000
--- a/sources_non_forked/ale/autoload/ale/fixers/hackfmt.vim
+++ /dev/null
@@ -1,18 +0,0 @@
-" Author: Sam Howie <samhowie@gmail.com>
-" Description: Integration of hackfmt with ALE.
-
-call ale#Set('hack_hackfmt_executable', 'hackfmt')
-call ale#Set('hack_hackfmt_options', '')
-
-function! ale#fixers#hackfmt#Fix(buffer) abort
-    let l:executable = ale#Var(a:buffer, 'hack_hackfmt_executable')
-    let l:options = ale#Var(a:buffer, 'hack_hackfmt_options')
-
-    return {
-    \   'command': ale#Escape(l:executable)
-    \       . ' -i'
-    \       . (empty(l:options) ? '' : ' ' . l:options)
-    \       . ' %t',
-    \   'read_temporary_file': 1,
-    \}
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/fixers/help.vim b/sources_non_forked/ale/autoload/ale/fixers/help.vim
deleted file mode 100644
index b20740f..0000000
--- a/sources_non_forked/ale/autoload/ale/fixers/help.vim
+++ /dev/null
@@ -1,24 +0,0 @@
-" Author: w0rp <devw0rp@gmail.com>
-" Description: Generic fixer functions for Vim help documents.
-
-function! ale#fixers#help#AlignTags(buffer, lines) abort
-    let l:new_lines = []
-
-    for l:line in a:lines
-        if len(l:line) != 79
-            let l:match = matchlist(l:line, '\v +(\*[^*]+\*)$')
-
-            if !empty(l:match)
-                let l:start = l:line[:-len(l:match[0]) - 1]
-                let l:tag = l:match[1]
-                let l:spaces = repeat(' ', 79 - len(l:start) - len(l:tag))
-
-                let l:line = l:start . l:spaces . l:tag
-            endif
-        endif
-
-        call add(l:new_lines, l:line)
-    endfor
-
-    return l:new_lines
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/fixers/hfmt.vim b/sources_non_forked/ale/autoload/ale/fixers/hfmt.vim
deleted file mode 100644
index 0407b71..0000000
--- a/sources_non_forked/ale/autoload/ale/fixers/hfmt.vim
+++ /dev/null
@@ -1,16 +0,0 @@
-" Author: zack <zack@kourouma.me>
-" Description: Integration of hfmt with ALE.
-
-call ale#Set('haskell_hfmt_executable', 'hfmt')
-
-function! ale#fixers#hfmt#Fix(buffer) abort
-    let l:executable = ale#Var(a:buffer, 'haskell_hfmt_executable')
-
-    return {
-    \   'command': ale#handlers#haskell_stack#EscapeExecutable(l:executable, 'hfmt')
-    \       . ' -w'
-    \       . ' %t',
-    \   'read_temporary_file': 1,
-    \}
-endfunction
-
diff --git a/sources_non_forked/ale/autoload/ale/fixers/hindent.vim b/sources_non_forked/ale/autoload/ale/fixers/hindent.vim
deleted file mode 100644
index b6009a2..0000000
--- a/sources_non_forked/ale/autoload/ale/fixers/hindent.vim
+++ /dev/null
@@ -1,20 +0,0 @@
-" Author: AlexeiDrake <drake.alexei@gmail.com>
-" Description: Integration of hindent formatting with ALE.
-"
-call ale#Set('haskell_hindent_executable', 'hindent')
-
-function! ale#fixers#hindent#GetExecutable(buffer) abort
-    let l:executable = ale#Var(a:buffer, 'haskell_hindent_executable')
-
-    return ale#handlers#haskell_stack#EscapeExecutable(l:executable, 'hindent')
-endfunction
-
-function! ale#fixers#hindent#Fix(buffer) abort
-    let l:executable = ale#fixers#hindent#GetExecutable(a:buffer)
-
-    return {
-    \   'command': l:executable
-    \       . ' %t',
-    \   'read_temporary_file': 1,
-    \}
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/fixers/hlint.vim b/sources_non_forked/ale/autoload/ale/fixers/hlint.vim
deleted file mode 100644
index 88779a5..0000000
--- a/sources_non_forked/ale/autoload/ale/fixers/hlint.vim
+++ /dev/null
@@ -1,13 +0,0 @@
-" Author: eborden <evan@evan-borden.com>
-" Description: Integration of hlint refactor with ALE.
-"
-
-function! ale#fixers#hlint#Fix(buffer) abort
-    return {
-    \   'command': ale#handlers#hlint#GetExecutable(a:buffer)
-    \       . ' --refactor'
-    \       . ' --refactor-options="--inplace"'
-    \       . ' %t',
-    \   'read_temporary_file': 1,
-    \}
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/fixers/html_beautify.vim b/sources_non_forked/ale/autoload/ale/fixers/html_beautify.vim
deleted file mode 100644
index 236cb6e..0000000
--- a/sources_non_forked/ale/autoload/ale/fixers/html_beautify.vim
+++ /dev/null
@@ -1,21 +0,0 @@
-" Author: WhyNotHugo <hugo@barrera.io>
-" Description: Lint HTML files with html-beautify.
-"
-call ale#Set('html_beautify_executable', 'html-beautify')
-call ale#Set('html_beautify_use_global', get(g:, 'ale_use_global_executables', 0))
-call ale#Set('html_beautify_options', '')
-call ale#Set('html_beautify_change_directory', 1)
-
-function! ale#fixers#html_beautify#Fix(buffer) abort
-    let l:executable = ale#python#FindExecutable(
-    \   a:buffer,
-    \   'html_beautify',
-    \   ['html-beautify']
-    \)
-
-    let l:options = ale#Var(a:buffer, 'html_beautify_options')
-
-    return {
-    \   'command': ale#Escape(l:executable). ' ' . l:options . ' -',
-    \}
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/fixers/importjs.vim b/sources_non_forked/ale/autoload/ale/fixers/importjs.vim
deleted file mode 100644
index b5487b2..0000000
--- a/sources_non_forked/ale/autoload/ale/fixers/importjs.vim
+++ /dev/null
@@ -1,25 +0,0 @@
-" Author: Jeff Willette <jrwillette88@gmail.com>
-" Description: Integration of importjs with ALE.
-
-call ale#Set('javascript_importjs_executable', 'importjs')
-
-function! ale#fixers#importjs#ProcessOutput(buffer, output) abort
-    let l:result = ale#util#FuzzyJSONDecode(a:output, [])
-
-    return split(get(l:result, 'fileContent', ''), "\n")
-endfunction
-
-function! ale#fixers#importjs#Fix(buffer) abort
-    let l:executable = ale#Var(a:buffer, 'javascript_importjs_executable')
-
-    if !executable(l:executable)
-        return 0
-    endif
-
-    return {
-    \   'command': ale#Escape(l:executable)
-    \       . ' fix'
-    \       . ' %s',
-    \   'process_with': 'ale#fixers#importjs#ProcessOutput',
-    \}
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/fixers/isort.vim b/sources_non_forked/ale/autoload/ale/fixers/isort.vim
deleted file mode 100644
index 9070fb2..0000000
--- a/sources_non_forked/ale/autoload/ale/fixers/isort.vim
+++ /dev/null
@@ -1,25 +0,0 @@
-" Author: w0rp <devw0rp@gmail.com>
-" Description: Fixing Python imports with isort.
-
-call ale#Set('python_isort_executable', 'isort')
-call ale#Set('python_isort_options', '')
-call ale#Set('python_isort_use_global', get(g:, 'ale_use_global_executables', 0))
-
-function! ale#fixers#isort#Fix(buffer) abort
-    let l:options = ale#Var(a:buffer, 'python_isort_options')
-
-    let l:executable = ale#python#FindExecutable(
-    \   a:buffer,
-    \   'python_isort',
-    \   ['isort'],
-    \)
-
-    if !executable(l:executable)
-        return 0
-    endif
-
-    return {
-    \   'command': ale#path#BufferCdString(a:buffer)
-    \   .   ale#Escape(l:executable) . (!empty(l:options) ? ' ' . l:options : '') . ' -',
-    \}
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/fixers/jq.vim b/sources_non_forked/ale/autoload/ale/fixers/jq.vim
deleted file mode 100644
index cd9b913..0000000
--- a/sources_non_forked/ale/autoload/ale/fixers/jq.vim
+++ /dev/null
@@ -1,22 +0,0 @@
-call ale#Set('json_jq_executable', 'jq')
-call ale#Set('json_jq_options', '')
-call ale#Set('json_jq_filters', '.')
-
-function! ale#fixers#jq#GetExecutable(buffer) abort
-    return ale#Var(a:buffer, 'json_jq_executable')
-endfunction
-
-function! ale#fixers#jq#Fix(buffer) abort
-    let l:options = ale#Var(a:buffer, 'json_jq_options')
-    let l:filters = ale#Var(a:buffer, 'json_jq_filters')
-
-    if empty(l:filters)
-        return 0
-    endif
-
-    return {
-    \  'command': ale#Escape(ale#fixers#jq#GetExecutable(a:buffer))
-    \      . ' ' . l:filters . ' '
-    \      . l:options,
-    \}
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/fixers/ktlint.vim b/sources_non_forked/ale/autoload/ale/fixers/ktlint.vim
deleted file mode 100644
index cb975d6..0000000
--- a/sources_non_forked/ale/autoload/ale/fixers/ktlint.vim
+++ /dev/null
@@ -1,9 +0,0 @@
-" Author: Michael Phillips <michaeljoelphillips@gmail.com>
-" Description: Fix Kotlin files with ktlint.
-
-function! ale#fixers#ktlint#Fix(buffer) abort
-    return {
-    \   'command': ale#handlers#ktlint#GetCommand(a:buffer) . ' --format',
-    \   'read_temporary_file': 1,
-    \}
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/fixers/latexindent.vim b/sources_non_forked/ale/autoload/ale/fixers/latexindent.vim
deleted file mode 100644
index b0a0884..0000000
--- a/sources_non_forked/ale/autoload/ale/fixers/latexindent.vim
+++ /dev/null
@@ -1,18 +0,0 @@
-" Author: riley-martine <riley.martine@protonmail.com>
-" Description: Integration of latexindent with ALE.
-
-call ale#Set('tex_latexindent_executable', 'latexindent')
-call ale#Set('tex_latexindent_options', '')
-
-function! ale#fixers#latexindent#Fix(buffer) abort
-    let l:executable = ale#Var(a:buffer, 'tex_latexindent_executable')
-    let l:options = ale#Var(a:buffer, 'tex_latexindent_options')
-
-    return {
-    \   'command': ale#Escape(l:executable)
-    \       . ' -l -w'
-    \       . (empty(l:options) ? '' : ' ' . l:options)
-    \       . ' %t',
-    \   'read_temporary_file': 1,
-    \}
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/fixers/mix_format.vim b/sources_non_forked/ale/autoload/ale/fixers/mix_format.vim
deleted file mode 100644
index 7a09170..0000000
--- a/sources_non_forked/ale/autoload/ale/fixers/mix_format.vim
+++ /dev/null
@@ -1,25 +0,0 @@
-" Author: carakan <carakan@gmail.com>, Fernando Mendes <fernando@mendes.codes>
-" Description: Fixing files with elixir formatter 'mix format'.
-
-call ale#Set('elixir_mix_executable', 'mix')
-call ale#Set('elixir_mix_format_options', '')
-
-function! ale#fixers#mix_format#GetExecutable(buffer) abort
-    return ale#Var(a:buffer, 'elixir_mix_executable')
-endfunction
-
-function! ale#fixers#mix_format#GetCommand(buffer) abort
-    let l:executable = ale#Escape(ale#fixers#mix_format#GetExecutable(a:buffer))
-    let l:options = ale#Var(a:buffer, 'elixir_mix_format_options')
-
-    return l:executable . ' format'
-    \   . (!empty(l:options) ? ' ' . l:options : '')
-    \   . ' %t'
-endfunction
-
-function! ale#fixers#mix_format#Fix(buffer) abort
-    return {
-    \   'command': ale#fixers#mix_format#GetCommand(a:buffer),
-    \   'read_temporary_file': 1,
-    \}
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/fixers/nimpretty.vim b/sources_non_forked/ale/autoload/ale/fixers/nimpretty.vim
deleted file mode 100644
index fe2e713..0000000
--- a/sources_non_forked/ale/autoload/ale/fixers/nimpretty.vim
+++ /dev/null
@@ -1,15 +0,0 @@
-" Author: Nhan <hi@imnhan.com>
-" Description: Integration of nimpretty with ALE.
-
-call ale#Set('nim_nimpretty_executable', 'nimpretty')
-call ale#Set('nim_nimpretty_options', '--maxLineLen:80')
-
-function! ale#fixers#nimpretty#Fix(buffer) abort
-    let l:executable = ale#Var(a:buffer, 'nim_nimpretty_executable')
-    let l:options = ale#Var(a:buffer, 'nim_nimpretty_options')
-
-    return {
-    \   'command': ale#Escape(l:executable) . ' %t' . ale#Pad(l:options),
-    \   'read_temporary_file': 1,
-    \}
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/fixers/nixpkgsfmt.vim b/sources_non_forked/ale/autoload/ale/fixers/nixpkgsfmt.vim
deleted file mode 100644
index 403ce79..0000000
--- a/sources_non_forked/ale/autoload/ale/fixers/nixpkgsfmt.vim
+++ /dev/null
@@ -1,12 +0,0 @@
-call ale#Set('nix_nixpkgsfmt_executable', 'nixpkgs-fmt')
-call ale#Set('nix_nixpkgsfmt_options', '')
-
-function! ale#fixers#nixpkgsfmt#Fix(buffer) abort
-    let l:executable = ale#Var(a:buffer, 'nix_nixpkgsfmt_executable')
-    let l:options = ale#Var(a:buffer, 'nix_nixpkgsfmt_options')
-
-    return {
-    \   'command': ale#Escape(l:executable)
-    \       . (empty(l:options) ? '' : ' ' . l:options),
-    \}
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/fixers/ocamlformat.vim b/sources_non_forked/ale/autoload/ale/fixers/ocamlformat.vim
deleted file mode 100644
index 9b7c3e1..0000000
--- a/sources_non_forked/ale/autoload/ale/fixers/ocamlformat.vim
+++ /dev/null
@@ -1,18 +0,0 @@
-" Author: Stephen Lumenta <@sbl>
-" Description: Integration of ocamlformat with ALE.
-
-call ale#Set('ocaml_ocamlformat_executable', 'ocamlformat')
-call ale#Set('ocaml_ocamlformat_options', '')
-
-function! ale#fixers#ocamlformat#Fix(buffer) abort
-    let l:filename = expand('#' . a:buffer . ':p')
-    let l:executable = ale#Var(a:buffer, 'ocaml_ocamlformat_executable')
-    let l:options = ale#Var(a:buffer, 'ocaml_ocamlformat_options')
-
-    return {
-    \   'command': ale#Escape(l:executable)
-    \       . (empty(l:options) ? '' : ' ' . l:options)
-    \       . ' --name=' . ale#Escape(l:filename)
-    \       . ' -'
-    \}
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/fixers/ocp_indent.vim b/sources_non_forked/ale/autoload/ale/fixers/ocp_indent.vim
deleted file mode 100644
index e1b047b..0000000
--- a/sources_non_forked/ale/autoload/ale/fixers/ocp_indent.vim
+++ /dev/null
@@ -1,18 +0,0 @@
-" Author: Kanenobu Mitsuru
-" Description: Integration of ocp-indent with ALE.
-
-call ale#Set('ocaml_ocp_indent_executable', 'ocp-indent')
-call ale#Set('ocaml_ocp_indent_options', '')
-call ale#Set('ocaml_ocp_indent_config', '')
-
-function! ale#fixers#ocp_indent#Fix(buffer) abort
-    let l:executable = ale#Var(a:buffer, 'ocaml_ocp_indent_executable')
-    let l:config = ale#Var(a:buffer, 'ocaml_ocp_indent_config')
-    let l:options = ale#Var(a:buffer, 'ocaml_ocp_indent_options')
-
-    return {
-    \   'command': ale#Escape(l:executable)
-    \       . (empty(l:config) ? '' : ' --config=' . ale#Escape(l:config))
-    \       . (empty(l:options) ? '': ' ' . l:options)
-    \}
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/fixers/perltidy.vim b/sources_non_forked/ale/autoload/ale/fixers/perltidy.vim
deleted file mode 100644
index a55a572..0000000
--- a/sources_non_forked/ale/autoload/ale/fixers/perltidy.vim
+++ /dev/null
@@ -1,18 +0,0 @@
-" Author: kfly8 <kentafly88@gmail.com>
-" Description: Integration of perltidy with ALE.
-
-call ale#Set('perl_perltidy_executable', 'perltidy')
-call ale#Set('perl_perltidy_options', '')
-
-function! ale#fixers#perltidy#Fix(buffer) abort
-    let l:executable = ale#Var(a:buffer, 'perl_perltidy_executable')
-    let l:options = ale#Var(a:buffer, 'perl_perltidy_options')
-
-    return {
-    \   'command': ale#Escape(l:executable)
-    \       . ' -b'
-    \       . (empty(l:options) ? '' : ' ' . l:options)
-    \       . ' %t',
-    \   'read_temporary_file': 1,
-    \}
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/fixers/pgformatter.vim b/sources_non_forked/ale/autoload/ale/fixers/pgformatter.vim
deleted file mode 100644
index 9ea08ec..0000000
--- a/sources_non_forked/ale/autoload/ale/fixers/pgformatter.vim
+++ /dev/null
@@ -1,12 +0,0 @@
-call ale#Set('sql_pgformatter_executable', 'pg_format')
-call ale#Set('sql_pgformatter_options', '')
-
-function! ale#fixers#pgformatter#Fix(buffer) abort
-    let l:executable = ale#Var(a:buffer, 'sql_pgformatter_executable')
-    let l:options = ale#Var(a:buffer, 'sql_pgformatter_options')
-
-    return {
-    \   'command': ale#Escape(l:executable)
-    \       . (empty(l:options) ? '' : ' ' . l:options),
-    \}
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/fixers/php_cs_fixer.vim b/sources_non_forked/ale/autoload/ale/fixers/php_cs_fixer.vim
deleted file mode 100644
index 5c59e26..0000000
--- a/sources_non_forked/ale/autoload/ale/fixers/php_cs_fixer.vim
+++ /dev/null
@@ -1,24 +0,0 @@
-" Author: Julien Deniau <julien.deniau@gmail.com>
-" Description: Fixing files with php-cs-fixer.
-
-call ale#Set('php_cs_fixer_executable', 'php-cs-fixer')
-call ale#Set('php_cs_fixer_use_global', get(g:, 'ale_use_global_executables', 0))
-call ale#Set('php_cs_fixer_options', '')
-
-function! ale#fixers#php_cs_fixer#GetExecutable(buffer) abort
-    return ale#node#FindExecutable(a:buffer, 'php_cs_fixer', [
-    \   'vendor/bin/php-cs-fixer',
-    \   'php-cs-fixer'
-    \])
-endfunction
-
-function! ale#fixers#php_cs_fixer#Fix(buffer) abort
-    let l:executable = ale#fixers#php_cs_fixer#GetExecutable(a:buffer)
-
-    return {
-    \   'command': ale#Escape(l:executable)
-    \       . ' ' . ale#Var(a:buffer, 'php_cs_fixer_options')
-    \       . ' fix %t',
-    \   'read_temporary_file': 1,
-    \}
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/fixers/phpcbf.vim b/sources_non_forked/ale/autoload/ale/fixers/phpcbf.vim
deleted file mode 100644
index f14b840..0000000
--- a/sources_non_forked/ale/autoload/ale/fixers/phpcbf.vim
+++ /dev/null
@@ -1,25 +0,0 @@
-" Author: notomo <notomo.motono@gmail.com>
-" Description: Fixing files with phpcbf.
-
-call ale#Set('php_phpcbf_standard', '')
-call ale#Set('php_phpcbf_executable', 'phpcbf')
-call ale#Set('php_phpcbf_use_global', get(g:, 'ale_use_global_executables', 0))
-
-function! ale#fixers#phpcbf#GetExecutable(buffer) abort
-    return ale#node#FindExecutable(a:buffer, 'php_phpcbf', [
-    \   'vendor/bin/phpcbf',
-    \   'phpcbf'
-    \])
-endfunction
-
-function! ale#fixers#phpcbf#Fix(buffer) abort
-    let l:executable = ale#fixers#phpcbf#GetExecutable(a:buffer)
-    let l:standard = ale#Var(a:buffer, 'php_phpcbf_standard')
-    let l:standard_option = !empty(l:standard)
-    \   ? '--standard=' . l:standard
-    \   : ''
-
-    return {
-    \   'command': ale#Escape(l:executable) . ' --stdin-path=%s ' . l:standard_option . ' -'
-    \}
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/fixers/prettier.vim b/sources_non_forked/ale/autoload/ale/fixers/prettier.vim
deleted file mode 100644
index 2312077..0000000
--- a/sources_non_forked/ale/autoload/ale/fixers/prettier.vim
+++ /dev/null
@@ -1,114 +0,0 @@
-" Author: tunnckoCore (Charlike Mike Reagent) <mameto2011@gmail.com>,
-"         w0rp <devw0rp@gmail.com>, morhetz (Pavel Pertsev) <morhetz@gmail.com>
-" Description: Integration of Prettier with ALE.
-
-call ale#Set('javascript_prettier_executable', 'prettier')
-call ale#Set('javascript_prettier_use_global', get(g:, 'ale_use_global_executables', 0))
-call ale#Set('javascript_prettier_options', '')
-
-function! ale#fixers#prettier#GetExecutable(buffer) abort
-    return ale#node#FindExecutable(a:buffer, 'javascript_prettier', [
-    \   'node_modules/.bin/prettier_d',
-    \   'node_modules/prettier-cli/index.js',
-    \   'node_modules/.bin/prettier',
-    \])
-endfunction
-
-function! ale#fixers#prettier#Fix(buffer) abort
-    return ale#semver#RunWithVersionCheck(
-    \   a:buffer,
-    \   ale#fixers#prettier#GetExecutable(a:buffer),
-    \   '%e --version',
-    \   function('ale#fixers#prettier#ApplyFixForVersion'),
-    \)
-endfunction
-
-function! ale#fixers#prettier#ProcessPrettierDOutput(buffer, output) abort
-    " If the output is an error message, don't use it.
-    for l:line in a:output[:10]
-        if l:line =~# '^\w*Error:'
-            return []
-        endif
-    endfor
-
-    return a:output
-endfunction
-
-function! ale#fixers#prettier#ApplyFixForVersion(buffer, version) abort
-    let l:executable = ale#fixers#prettier#GetExecutable(a:buffer)
-    let l:options = ale#Var(a:buffer, 'javascript_prettier_options')
-    let l:parser = ''
-
-    let l:filetypes = split(getbufvar(a:buffer, '&filetype'), '\.')
-
-    if index(l:filetypes, 'handlebars') > -1
-        let l:parser = 'glimmer'
-    endif
-
-    " Append the --parser flag depending on the current filetype (unless it's
-    " already set in g:javascript_prettier_options).
-    if empty(expand('#' . a:buffer . ':e')) && l:parser is# ''  && match(l:options, '--parser') == -1
-        " Mimic Prettier's defaults. In cases without a file extension or
-        " filetype (scratch buffer), Prettier needs `parser` set to know how
-        " to process the buffer.
-        if ale#semver#GTE(a:version, [1, 16, 0])
-            let l:parser = 'babel'
-        else
-            let l:parser = 'babylon'
-        endif
-
-        let l:prettier_parsers = {
-        \    'typescript': 'typescript',
-        \    'css': 'css',
-        \    'less': 'less',
-        \    'scss': 'scss',
-        \    'json': 'json',
-        \    'json5': 'json5',
-        \    'graphql': 'graphql',
-        \    'markdown': 'markdown',
-        \    'vue': 'vue',
-        \    'yaml': 'yaml',
-        \    'html': 'html',
-        \}
-
-        for l:filetype in l:filetypes
-            if has_key(l:prettier_parsers, l:filetype)
-                let l:parser = l:prettier_parsers[l:filetype]
-                break
-            endif
-        endfor
-    endif
-
-    if !empty(l:parser)
-        let l:options = (!empty(l:options) ? l:options . ' ' : '') . '--parser ' . l:parser
-    endif
-
-    " Special error handling needed for prettier_d
-    if l:executable =~# 'prettier_d$'
-        return {
-        \   'command': ale#path#BufferCdString(a:buffer)
-        \       . ale#Escape(l:executable)
-        \       . (!empty(l:options) ? ' ' . l:options : '')
-        \       . ' --stdin-filepath %s --stdin',
-        \   'process_with': 'ale#fixers#prettier#ProcessPrettierDOutput',
-        \}
-    endif
-
-    " 1.4.0 is the first version with --stdin-filepath
-    if ale#semver#GTE(a:version, [1, 4, 0])
-        return {
-        \   'command': ale#path#BufferCdString(a:buffer)
-        \       . ale#Escape(l:executable)
-        \       . (!empty(l:options) ? ' ' . l:options : '')
-        \       . ' --stdin-filepath %s --stdin',
-        \}
-    endif
-
-    return {
-    \   'command': ale#Escape(l:executable)
-    \       . ' %t'
-    \       . (!empty(l:options) ? ' ' . l:options : '')
-    \       . ' --write',
-    \   'read_temporary_file': 1,
-    \}
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/fixers/prettier_eslint.vim b/sources_non_forked/ale/autoload/ale/fixers/prettier_eslint.vim
deleted file mode 100644
index 1e66f49..0000000
--- a/sources_non_forked/ale/autoload/ale/fixers/prettier_eslint.vim
+++ /dev/null
@@ -1,56 +0,0 @@
-" Author: tunnckoCore (Charlike Mike Reagent) <mameto2011@gmail.com>,
-"         w0rp <devw0rp@gmail.com>, morhetz (Pavel Pertsev) <morhetz@gmail.com>
-" Description: Integration between Prettier and ESLint.
-
-call ale#Set('javascript_prettier_eslint_executable', 'prettier-eslint')
-call ale#Set('javascript_prettier_eslint_use_global', get(g:, 'ale_use_global_executables', 0))
-call ale#Set('javascript_prettier_eslint_options', '')
-
-function! ale#fixers#prettier_eslint#GetExecutable(buffer) abort
-    return ale#node#FindExecutable(a:buffer, 'javascript_prettier_eslint', [
-    \   'node_modules/prettier-eslint-cli/dist/index.js',
-    \   'node_modules/.bin/prettier-eslint',
-    \])
-endfunction
-
-function! ale#fixers#prettier_eslint#Fix(buffer) abort
-    return ale#semver#RunWithVersionCheck(
-    \   a:buffer,
-    \   ale#fixers#prettier_eslint#GetExecutable(a:buffer),
-    \   '%e --version',
-    \   function('ale#fixers#prettier_eslint#ApplyFixForVersion'),
-    \)
-endfunction
-
-function! ale#fixers#prettier_eslint#ApplyFixForVersion(buffer, version) abort
-    let l:options = ale#Var(a:buffer, 'javascript_prettier_eslint_options')
-    let l:executable = ale#fixers#prettier_eslint#GetExecutable(a:buffer)
-
-    " 4.2.0 is the first version with --eslint-config-path
-    let l:config = ale#semver#GTE(a:version, [4, 2, 0])
-    \   ? ale#handlers#eslint#FindConfig(a:buffer)
-    \   : ''
-    let l:eslint_config_option = !empty(l:config)
-    \   ? ' --eslint-config-path ' . ale#Escape(l:config)
-    \   : ''
-
-    " 4.4.0 is the first version with --stdin-filepath
-    if ale#semver#GTE(a:version, [4, 4, 0])
-        return {
-        \   'command': ale#path#BufferCdString(a:buffer)
-        \       . ale#Escape(l:executable)
-        \       . l:eslint_config_option
-        \       . (!empty(l:options) ? ' ' . l:options : '')
-        \       . ' --stdin-filepath %s --stdin',
-        \}
-    endif
-
-    return {
-    \   'command': ale#Escape(l:executable)
-    \       . ' %t'
-    \       . l:eslint_config_option
-    \       . (!empty(l:options) ? ' ' . l:options : '')
-    \       . ' --write',
-    \   'read_temporary_file': 1,
-    \}
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/fixers/prettier_standard.vim b/sources_non_forked/ale/autoload/ale/fixers/prettier_standard.vim
deleted file mode 100644
index b6e0a6f..0000000
--- a/sources_non_forked/ale/autoload/ale/fixers/prettier_standard.vim
+++ /dev/null
@@ -1,24 +0,0 @@
-" Author: sheerun (Adam Stankiewicz) <sheerun@sher.pl>
-" Description: Integration of Prettier Standard with ALE.
-
-call ale#Set('javascript_prettier_standard_executable', 'prettier-standard')
-call ale#Set('javascript_prettier_standard_use_global', get(g:, 'ale_use_global_executables', 0))
-call ale#Set('javascript_prettier_standard_options', '')
-
-function! ale#fixers#prettier_standard#GetExecutable(buffer) abort
-    return ale#node#FindExecutable(a:buffer, 'javascript_prettier_standard', [
-    \   'node_modules/prettier-standard/lib/index.js',
-    \   'node_modules/.bin/prettier-standard',
-    \])
-endfunction
-
-function! ale#fixers#prettier_standard#Fix(buffer) abort
-    let l:options = ale#Var(a:buffer, 'javascript_prettier_standard_options')
-
-    return {
-    \   'command': ale#Escape(ale#fixers#prettier_standard#GetExecutable(a:buffer))
-    \       . ' %t'
-    \       . ' ' . l:options,
-    \   'read_temporary_file': 1,
-    \}
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/fixers/puppetlint.vim b/sources_non_forked/ale/autoload/ale/fixers/puppetlint.vim
deleted file mode 100644
index bf36e48..0000000
--- a/sources_non_forked/ale/autoload/ale/fixers/puppetlint.vim
+++ /dev/null
@@ -1,22 +0,0 @@
-" Author: Alexander Olofsson <alexander.olofsson@liu.se>
-" Description: puppet-lint fixer
-
-if !exists('g:ale_puppet_puppetlint_executable')
-    let g:ale_puppet_puppetlint_executable = 'puppet-lint'
-endif
-
-if !exists('g:ale_puppet_puppetlint_options')
-    let g:ale_puppet_puppetlint_options = ''
-endif
-
-function! ale#fixers#puppetlint#Fix(buffer) abort
-    let l:executable = ale#Var(a:buffer, 'puppet_puppetlint_executable')
-
-    return {
-    \   'command': ale#Escape(l:executable)
-    \       . ' ' . ale#Var(a:buffer, 'puppet_puppetlint_options')
-    \       . ' --fix'
-    \       . ' %t',
-    \   'read_temporary_file': 1,
-    \}
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/fixers/purty.vim b/sources_non_forked/ale/autoload/ale/fixers/purty.vim
deleted file mode 100644
index 46d2cac..0000000
--- a/sources_non_forked/ale/autoload/ale/fixers/purty.vim
+++ /dev/null
@@ -1,22 +0,0 @@
-" Author: iclanzan <sorin@iclanzan.com>
-" Description: Integration of purty with ALE.
-
-call ale#Set('purescript_purty_executable', 'purty')
-
-function! ale#fixers#purty#GetExecutable(buffer) abort
-    let l:executable = ale#Var(a:buffer, 'purescript_purty_executable')
-
-    return ale#Escape(l:executable)
-endfunction
-
-function! ale#fixers#purty#Fix(buffer) abort
-    let l:executable = ale#fixers#purty#GetExecutable(a:buffer)
-
-    return {
-    \   'command': l:executable
-    \       . ' --write'
-    \       . ' %t',
-    \   'read_temporary_file': 1,
-    \}
-endfunction
-
diff --git a/sources_non_forked/ale/autoload/ale/fixers/qmlfmt.vim b/sources_non_forked/ale/autoload/ale/fixers/qmlfmt.vim
deleted file mode 100644
index 90b2567..0000000
--- a/sources_non_forked/ale/autoload/ale/fixers/qmlfmt.vim
+++ /dev/null
@@ -1,11 +0,0 @@
-call ale#Set('qml_qmlfmt_executable', 'qmlfmt')
-
-function! ale#fixers#qmlfmt#GetExecutable(buffer) abort
-    return ale#Var(a:buffer, 'qml_qmlfmt_executable')
-endfunction
-
-function! ale#fixers#qmlfmt#Fix(buffer) abort
-    return {
-    \  'command': ale#Escape(ale#fixers#qmlfmt#GetExecutable(a:buffer)),
-    \}
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/fixers/refmt.vim b/sources_non_forked/ale/autoload/ale/fixers/refmt.vim
deleted file mode 100644
index 514f950..0000000
--- a/sources_non_forked/ale/autoload/ale/fixers/refmt.vim
+++ /dev/null
@@ -1,18 +0,0 @@
-" Author: Ahmed El Gabri <@ahmedelgabri>
-" Description: Integration of refmt with ALE.
-
-call ale#Set('reasonml_refmt_executable', 'refmt')
-call ale#Set('reasonml_refmt_options', '')
-
-function! ale#fixers#refmt#Fix(buffer) abort
-    let l:executable = ale#Var(a:buffer, 'reasonml_refmt_executable')
-    let l:options = ale#Var(a:buffer, 'reasonml_refmt_options')
-
-    return {
-    \   'command': ale#Escape(l:executable)
-    \       . (empty(l:options) ? '' : ' ' . l:options)
-    \       . ' --in-place'
-    \       . ' %t',
-    \   'read_temporary_file': 1,
-    \}
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/fixers/reorder_python_imports.vim b/sources_non_forked/ale/autoload/ale/fixers/reorder_python_imports.vim
deleted file mode 100644
index 42a0a6e..0000000
--- a/sources_non_forked/ale/autoload/ale/fixers/reorder_python_imports.vim
+++ /dev/null
@@ -1,25 +0,0 @@
-" Author: jake <me@jake.computer>
-" Description: Fixing Python imports with reorder-python-imports.
-
-call ale#Set('python_reorder_python_imports_executable', 'reorder-python-imports')
-call ale#Set('python_reorder_python_imports_options', '')
-call ale#Set('python_reorder_python_imports_use_global', get(g:, 'ale_use_global_executables', 0))
-
-function! ale#fixers#reorder_python_imports#Fix(buffer) abort
-    let l:executable = ale#python#FindExecutable(
-    \   a:buffer,
-    \   'python_reorder_python_imports',
-    \   ['reorder-python-imports'],
-    \)
-
-    if !executable(l:executable)
-        return 0
-    endif
-
-    let l:options = ale#Var(a:buffer, 'python_reorder_python_imports_options')
-
-    return {
-    \   'command': ale#Escape(l:executable)
-    \       . (!empty(l:options) ? ' ' . l:options : '') . ' -',
-    \}
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/fixers/rubocop.vim b/sources_non_forked/ale/autoload/ale/fixers/rubocop.vim
deleted file mode 100644
index 0c7441e..0000000
--- a/sources_non_forked/ale/autoload/ale/fixers/rubocop.vim
+++ /dev/null
@@ -1,20 +0,0 @@
-call ale#Set('ruby_rubocop_options', '')
-call ale#Set('ruby_rubocop_executable', 'rubocop')
-
-function! ale#fixers#rubocop#GetCommand(buffer) abort
-    let l:executable = ale#Var(a:buffer, 'ruby_rubocop_executable')
-    let l:config = ale#path#FindNearestFile(a:buffer, '.rubocop.yml')
-    let l:options = ale#Var(a:buffer, 'ruby_rubocop_options')
-
-    return ale#ruby#EscapeExecutable(l:executable, 'rubocop')
-    \   . (!empty(l:config) ? ' --config ' . ale#Escape(l:config) : '')
-    \   . (!empty(l:options) ? ' ' . l:options : '')
-    \   . ' --auto-correct --force-exclusion %t'
-endfunction
-
-function! ale#fixers#rubocop#Fix(buffer) abort
-    return {
-    \   'command': ale#fixers#rubocop#GetCommand(a:buffer),
-    \   'read_temporary_file': 1,
-    \}
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/fixers/rufo.vim b/sources_non_forked/ale/autoload/ale/fixers/rufo.vim
deleted file mode 100644
index 01d537a..0000000
--- a/sources_non_forked/ale/autoload/ale/fixers/rufo.vim
+++ /dev/null
@@ -1,20 +0,0 @@
-" Author: Fohte (Hayato Kawai) https://github.com/fohte
-" Description: Integration of Rufo with ALE.
-
-call ale#Set('ruby_rufo_executable', 'rufo')
-
-function! ale#fixers#rufo#GetCommand(buffer) abort
-    let l:executable = ale#Var(a:buffer, 'ruby_rufo_executable')
-    let l:exec_args = l:executable =~? 'bundle$'
-    \   ? ' exec rufo'
-    \   : ''
-
-    return ale#Escape(l:executable) . l:exec_args . ' %t'
-endfunction
-
-function! ale#fixers#rufo#Fix(buffer) abort
-    return {
-    \   'command': ale#fixers#rufo#GetCommand(a:buffer),
-    \   'read_temporary_file': 1,
-    \}
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/fixers/rustfmt.vim b/sources_non_forked/ale/autoload/ale/fixers/rustfmt.vim
deleted file mode 100644
index 38882fb..0000000
--- a/sources_non_forked/ale/autoload/ale/fixers/rustfmt.vim
+++ /dev/null
@@ -1,15 +0,0 @@
-" Author: Kelly Fox <kelly@bumfuddled.com>
-" Description: Integration of rustfmt with ALE.
-
-call ale#Set('rust_rustfmt_executable', 'rustfmt')
-call ale#Set('rust_rustfmt_options', '')
-
-function! ale#fixers#rustfmt#Fix(buffer) abort
-    let l:executable = ale#Var(a:buffer, 'rust_rustfmt_executable')
-    let l:options = ale#Var(a:buffer, 'rust_rustfmt_options')
-
-    return {
-    \   'command': ale#Escape(l:executable)
-    \       . (empty(l:options) ? '' : ' ' . l:options),
-    \}
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/fixers/scalafmt.vim b/sources_non_forked/ale/autoload/ale/fixers/scalafmt.vim
deleted file mode 100644
index dd0e774..0000000
--- a/sources_non_forked/ale/autoload/ale/fixers/scalafmt.vim
+++ /dev/null
@@ -1,25 +0,0 @@
-" Author: Jeffrey Lau https://github.com/zoonfafer
-" Description: Integration of Scalafmt with ALE.
-
-call ale#Set('scala_scalafmt_executable', 'scalafmt')
-call ale#Set('scala_scalafmt_use_global', get(g:, 'ale_use_global_executables', 0))
-call ale#Set('scala_scalafmt_options', '')
-
-function! ale#fixers#scalafmt#GetCommand(buffer) abort
-    let l:executable = ale#Var(a:buffer, 'scala_scalafmt_executable')
-    let l:options = ale#Var(a:buffer, 'scala_scalafmt_options')
-    let l:exec_args = l:executable =~? 'ng$'
-    \   ? ' scalafmt'
-    \   : ''
-
-    return ale#Escape(l:executable) . l:exec_args
-    \   . (empty(l:options) ? '' : ' ' . l:options)
-    \   . ' %t'
-endfunction
-
-function! ale#fixers#scalafmt#Fix(buffer) abort
-    return {
-    \   'command': ale#fixers#scalafmt#GetCommand(a:buffer),
-    \   'read_temporary_file': 1,
-    \}
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/fixers/shfmt.vim b/sources_non_forked/ale/autoload/ale/fixers/shfmt.vim
deleted file mode 100644
index 06e8da5..0000000
--- a/sources_non_forked/ale/autoload/ale/fixers/shfmt.vim
+++ /dev/null
@@ -1,31 +0,0 @@
-scriptencoding utf-8
-" Author: Simon Bugert <simon.bugert@gmail.com>
-" Description: Fix sh files with shfmt.
-
-call ale#Set('sh_shfmt_executable', 'shfmt')
-call ale#Set('sh_shfmt_options', '')
-
-function! s:DefaultOption(buffer) abort
-    if getbufvar(a:buffer, '&expandtab') == 0
-        " Tab is used by default
-        return ''
-    endif
-
-    let l:tabsize = getbufvar(a:buffer, '&shiftwidth')
-
-    if l:tabsize == 0
-        let l:tabsize = getbufvar(a:buffer, '&tabstop')
-    endif
-
-    return ' -i ' . l:tabsize
-endfunction
-
-function! ale#fixers#shfmt#Fix(buffer) abort
-    let l:executable = ale#Var(a:buffer, 'sh_shfmt_executable')
-    let l:options = ale#Var(a:buffer, 'sh_shfmt_options')
-
-    return {
-    \   'command': ale#Escape(l:executable)
-    \       . (empty(l:options) ? s:DefaultOption(a:buffer) : ' ' . l:options)
-    \}
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/fixers/sorbet.vim b/sources_non_forked/ale/autoload/ale/fixers/sorbet.vim
deleted file mode 100644
index 7c12fa1..0000000
--- a/sources_non_forked/ale/autoload/ale/fixers/sorbet.vim
+++ /dev/null
@@ -1,19 +0,0 @@
-call ale#Set('ruby_sorbet_executable', 'srb')
-call ale#Set('ruby_sorbet_options', '')
-
-function! ale#fixers#sorbet#GetCommand(buffer) abort
-    let l:executable = ale#Var(a:buffer, 'ruby_sorbet_executable')
-    let l:options = ale#Var(a:buffer, 'ruby_sorbet_options')
-
-    return ale#ruby#EscapeExecutable(l:executable, 'srb')
-    \   . ' tc'
-    \   . (!empty(l:options) ? ' ' . l:options : '')
-    \   . ' --autocorrect --file %t'
-endfunction
-
-function! ale#fixers#sorbet#Fix(buffer) abort
-    return {
-    \   'command': ale#fixers#sorbet#GetCommand(a:buffer),
-    \   'read_temporary_file': 1,
-    \}
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/fixers/sqlfmt.vim b/sources_non_forked/ale/autoload/ale/fixers/sqlfmt.vim
deleted file mode 100644
index c88a8ec..0000000
--- a/sources_non_forked/ale/autoload/ale/fixers/sqlfmt.vim
+++ /dev/null
@@ -1,13 +0,0 @@
-call ale#Set('sql_sqlfmt_executable', 'sqlfmt')
-call ale#Set('sql_sqlfmt_options', '')
-
-function! ale#fixers#sqlfmt#Fix(buffer) abort
-    let l:executable = ale#Var(a:buffer, 'sql_sqlfmt_executable')
-    let l:options = ale#Var(a:buffer, 'sql_sqlfmt_options')
-
-    return {
-    \   'command': ale#Escape(l:executable)
-    \       . ' -w'
-    \       . (empty(l:options) ? '' : ' ' . l:options),
-    \}
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/fixers/sqlformat.vim b/sources_non_forked/ale/autoload/ale/fixers/sqlformat.vim
deleted file mode 100644
index 6319c1a..0000000
--- a/sources_non_forked/ale/autoload/ale/fixers/sqlformat.vim
+++ /dev/null
@@ -1,16 +0,0 @@
-" Author: Cluas <Cluas@live.cn>
-" Description: Fixing files with sqlformat.
-
-call ale#Set('sql_sqlformat_executable', 'sqlformat')
-call ale#Set('sql_sqlformat_options', '')
-
-function! ale#fixers#sqlformat#Fix(buffer) abort
-    let l:executable = ale#Var(a:buffer, 'sql_sqlformat_executable')
-    let l:options = ale#Var(a:buffer, 'sql_sqlformat_options')
-
-    return {
-    \ 'command': ale#Escape(l:executable)
-    \ . (!empty(l:options) ? ' ' . l:options : '')
-    \ . ' -'
-    \}
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/fixers/standard.vim b/sources_non_forked/ale/autoload/ale/fixers/standard.vim
deleted file mode 100644
index cffa9f9..0000000
--- a/sources_non_forked/ale/autoload/ale/fixers/standard.vim
+++ /dev/null
@@ -1,33 +0,0 @@
-" Author: Sumner Evans <sumner.evans98@gmail.com>
-" Description: Fixing files with Standard.
-
-call ale#Set('javascript_standard_executable', 'standard')
-call ale#Set('javascript_standard_use_global', get(g:, 'ale_use_global_executables', 0))
-call ale#Set('javascript_standard_options', '')
-
-function! ale#fixers#standard#GetExecutable(buffer) abort
-    return ale#node#FindExecutable(a:buffer, 'javascript_standard', [
-    \   'node_modules/standardx/bin/cmd.js',
-    \   'node_modules/standard/bin/cmd.js',
-    \   'node_modules/.bin/standard',
-    \])
-endfunction
-
-function! ale#fixers#standard#Fix(buffer) abort
-    let l:executable = ale#fixers#standard#GetExecutable(a:buffer)
-    let l:filetype = getbufvar(a:buffer, '&filetype')
-    let l:options_type = 'javascript_standard_options'
-
-    if l:filetype =~# 'typescript'
-        let l:options_type = 'typescript_standard_options'
-    endif
-
-    let l:options = ale#Var(a:buffer, l:options_type)
-
-    return {
-    \   'command': ale#node#Executable(a:buffer, l:executable)
-    \   . (!empty(l:options) ? ' ' . l:options : '')
-    \       . ' --fix %t',
-    \   'read_temporary_file': 1,
-    \}
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/fixers/standardrb.vim b/sources_non_forked/ale/autoload/ale/fixers/standardrb.vim
deleted file mode 100644
index 54330a3..0000000
--- a/sources_non_forked/ale/autoload/ale/fixers/standardrb.vim
+++ /dev/null
@@ -1,23 +0,0 @@
-" Author: Justin Searls - https://github.com/searls
-" Description: Fix Ruby files with StandardRB.
-
-call ale#Set('ruby_standardrb_options', '')
-call ale#Set('ruby_standardrb_executable', 'standardrb')
-
-function! ale#fixers#standardrb#GetCommand(buffer) abort
-    let l:executable = ale#Var(a:buffer, 'ruby_standardrb_executable')
-    let l:config = ale#path#FindNearestFile(a:buffer, '.standard.yml')
-    let l:options = ale#Var(a:buffer, 'ruby_standardrb_options')
-
-    return ale#ruby#EscapeExecutable(l:executable, 'standardrb')
-    \   . (!empty(l:config) ? ' --config ' . ale#Escape(l:config) : '')
-    \   . (!empty(l:options) ? ' ' . l:options : '')
-    \   . ' --fix --force-exclusion %t'
-endfunction
-
-function! ale#fixers#standardrb#Fix(buffer) abort
-    return {
-    \   'command': ale#fixers#standardrb#GetCommand(a:buffer),
-    \   'read_temporary_file': 1,
-    \}
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/fixers/stylelint.vim b/sources_non_forked/ale/autoload/ale/fixers/stylelint.vim
deleted file mode 100644
index 6f4cf17..0000000
--- a/sources_non_forked/ale/autoload/ale/fixers/stylelint.vim
+++ /dev/null
@@ -1,27 +0,0 @@
-" Author: Mahmoud Mostafa <mah@moud.info>
-" Description: Fixing files with stylelint.
-
-call ale#Set('stylelint_executable', 'stylelint')
-call ale#Set('stylelint_use_global', get(g:, 'ale_use_global_executables', 0))
-call ale#Set('stylelint_options', '')
-
-function! ale#fixers#stylelint#GetExecutable(buffer) abort
-    return ale#node#FindExecutable(a:buffer, 'stylelint', [
-    \   'node_modules/stylelint/bin/stylelint.js',
-    \   'node_modules/.bin/stylelint',
-    \])
-endfunction
-
-function! ale#fixers#stylelint#Fix(buffer) abort
-    let l:executable = ale#fixers#stylelint#GetExecutable(a:buffer)
-    let l:options = ale#Var(a:buffer, 'stylelint_options')
-
-    return {
-    \   'command': ale#path#BufferCdString(a:buffer)
-    \       . ale#node#Executable(a:buffer, l:executable)
-    \       . ' %t'
-    \       . ale#Pad(l:options)
-    \       . ' --fix',
-    \   'read_temporary_file': 1,
-    \}
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/fixers/styler.vim b/sources_non_forked/ale/autoload/ale/fixers/styler.vim
deleted file mode 100644
index 1c7607b..0000000
--- a/sources_non_forked/ale/autoload/ale/fixers/styler.vim
+++ /dev/null
@@ -1,16 +0,0 @@
-" Author: tvatter <thibault.vatter@gmail.com>
-" Description: Fixing R files with styler.
-
-call ale#Set('r_styler_executable', 'Rscript')
-call ale#Set('r_styler_options', 'tidyverse_style()')
-
-function! ale#fixers#styler#Fix(buffer) abort
-    return {
-    \   'command': 'Rscript --vanilla -e '
-    \       . '"suppressPackageStartupMessages(library(styler));'
-    \       . 'style_file(commandArgs(TRUE), transformers = '
-    \       . ale#Var(a:buffer, 'r_styler_options') . ')"'
-    \       . ' %t',
-    \   'read_temporary_file': 1,
-    \}
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/fixers/stylish_haskell.vim b/sources_non_forked/ale/autoload/ale/fixers/stylish_haskell.vim
deleted file mode 100644
index ce71c1c..0000000
--- a/sources_non_forked/ale/autoload/ale/fixers/stylish_haskell.vim
+++ /dev/null
@@ -1,21 +0,0 @@
-" Author: eborden <evan@evan-borden.com>
-" Description: Integration of stylish-haskell formatting with ALE.
-"
-call ale#Set('haskell_stylish_haskell_executable', 'stylish-haskell')
-
-function! ale#fixers#stylish_haskell#GetExecutable(buffer) abort
-    let l:executable = ale#Var(a:buffer, 'haskell_stylish_haskell_executable')
-
-    return ale#handlers#haskell_stack#EscapeExecutable(l:executable, 'stylish-haskell')
-endfunction
-
-function! ale#fixers#stylish_haskell#Fix(buffer) abort
-    let l:executable = ale#fixers#stylish_haskell#GetExecutable(a:buffer)
-
-    return {
-    \   'command': l:executable
-    \       . ' --inplace'
-    \       . ' %t',
-    \   'read_temporary_file': 1,
-    \}
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/fixers/swiftformat.vim b/sources_non_forked/ale/autoload/ale/fixers/swiftformat.vim
deleted file mode 100644
index 304182b..0000000
--- a/sources_non_forked/ale/autoload/ale/fixers/swiftformat.vim
+++ /dev/null
@@ -1,25 +0,0 @@
-" Author: gfontenot (Gordon Fontenot) <gordon@fonten.io>
-" Description: Integration of SwiftFormat with ALE.
-
-call ale#Set('swift_swiftformat_executable', 'swiftformat')
-call ale#Set('swift_swiftformat_use_global', get(g:, 'ale_use_global_executables', 0))
-call ale#Set('swift_swiftformat_options', '')
-
-function! ale#fixers#swiftformat#GetExecutable(buffer) abort
-    return ale#node#FindExecutable(a:buffer, 'swift_swiftformat', [
-    \   'Pods/SwiftFormat/CommandLineTool/swiftformat',
-    \   'ios/Pods/SwiftFormat/CommandLineTool/swiftformat',
-    \   'swiftformat',
-    \])
-endfunction
-
-function! ale#fixers#swiftformat#Fix(buffer) abort
-    let l:options = ale#Var(a:buffer, 'swift_swiftformat_options')
-
-    return {
-    \   'read_temporary_file': 1,
-    \   'command': ale#Escape(ale#fixers#swiftformat#GetExecutable(a:buffer))
-    \       . ' %t'
-    \       . ' ' . l:options,
-    \}
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/fixers/terraform.vim b/sources_non_forked/ale/autoload/ale/fixers/terraform.vim
deleted file mode 100644
index bc05380..0000000
--- a/sources_non_forked/ale/autoload/ale/fixers/terraform.vim
+++ /dev/null
@@ -1,17 +0,0 @@
-" Author: dsifford <dereksifford@gmail.com>
-" Description: Fixer for terraform and .hcl files
-
-call ale#Set('terraform_fmt_executable', 'terraform')
-call ale#Set('terraform_fmt_options', '')
-
-function! ale#fixers#terraform#Fix(buffer) abort
-    let l:executable = ale#Var(a:buffer, 'terraform_fmt_executable')
-    let l:options = ale#Var(a:buffer, 'terraform_fmt_options')
-
-    return {
-    \   'command': ale#Escape(l:executable)
-    \       . ' fmt'
-    \       . (empty(l:options) ? '' : ' ' . l:options)
-    \       . ' -'
-    \}
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/fixers/textlint.vim b/sources_non_forked/ale/autoload/ale/fixers/textlint.vim
deleted file mode 100644
index 38ab2bf..0000000
--- a/sources_non_forked/ale/autoload/ale/fixers/textlint.vim
+++ /dev/null
@@ -1,15 +0,0 @@
-" Author: TANIGUCHI Masaya <ta2gch@gmail.com>
-" Description: Integration of textlint with ALE.
-
-function! ale#fixers#textlint#Fix(buffer) abort
-    let l:executable = ale#handlers#textlint#GetExecutable(a:buffer)
-    let l:options = ale#Var(a:buffer, 'textlint_options')
-
-    return {
-    \   'command': ale#Escape(l:executable)
-    \       . ' --fix'
-    \       . (empty(l:options) ? '' : ' ' . l:options)
-    \       . ' %t',
-    \   'read_temporary_file': 1,
-    \}
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/fixers/tidy.vim b/sources_non_forked/ale/autoload/ale/fixers/tidy.vim
deleted file mode 100644
index 1af4120..0000000
--- a/sources_non_forked/ale/autoload/ale/fixers/tidy.vim
+++ /dev/null
@@ -1,26 +0,0 @@
-" Author: meain <abinsimon10@gmail.com>
-" Description: Fixing HTML files with tidy.
-
-call ale#Set('html_tidy_executable', 'tidy')
-call ale#Set('html_tidy_use_global', get(g:, 'ale_use_global_executables', 0))
-
-function! ale#fixers#tidy#Fix(buffer) abort
-    let l:executable = ale#node#FindExecutable(
-    \   a:buffer,
-    \   'html_tidy',
-    \   ['tidy'],
-    \)
-
-    if !executable(l:executable)
-        return 0
-    endif
-
-    let l:config = ale#path#FindNearestFile(a:buffer, '.tidyrc')
-    let l:config_options = !empty(l:config)
-    \   ? ' -q --tidy-mark no --show-errors 0 --show-warnings 0 -config ' . ale#Escape(l:config)
-    \   : ' -q --tidy-mark no --show-errors 0 --show-warnings 0'
-
-    return {
-    \   'command': ale#Escape(l:executable) . l:config_options,
-    \}
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/fixers/tslint.vim b/sources_non_forked/ale/autoload/ale/fixers/tslint.vim
deleted file mode 100644
index b352af3..0000000
--- a/sources_non_forked/ale/autoload/ale/fixers/tslint.vim
+++ /dev/null
@@ -1,22 +0,0 @@
-" Author: carakan <carakan@gmail.com>
-" Description: Fixing files with tslint.
-
-function! ale#fixers#tslint#Fix(buffer) abort
-    let l:executable = ale#handlers#tslint#GetExecutable(a:buffer)
-
-    let l:tslint_config_path = ale#path#ResolveLocalPath(
-    \   a:buffer,
-    \   'tslint.json',
-    \   ale#Var(a:buffer, 'typescript_tslint_config_path')
-    \)
-    let l:tslint_config_option = !empty(l:tslint_config_path)
-    \   ? ' -c ' . ale#Escape(l:tslint_config_path)
-    \   : ''
-
-    return {
-    \   'command': ale#node#Executable(a:buffer, l:executable)
-    \       . l:tslint_config_option
-    \       . ' --fix %t',
-    \   'read_temporary_file': 1,
-    \}
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/fixers/uncrustify.vim b/sources_non_forked/ale/autoload/ale/fixers/uncrustify.vim
deleted file mode 100644
index ffec18e..0000000
--- a/sources_non_forked/ale/autoload/ale/fixers/uncrustify.vim
+++ /dev/null
@@ -1,16 +0,0 @@
-" Author: Derek P Sifford <dereksifford@gmail.com>
-" Description: Fixer for C, C++, C#, ObjectiveC, D, Java, Pawn, and VALA.
-
-call ale#Set('c_uncrustify_executable', 'uncrustify')
-call ale#Set('c_uncrustify_options', '')
-
-function! ale#fixers#uncrustify#Fix(buffer) abort
-    let l:executable = ale#Var(a:buffer, 'c_uncrustify_executable')
-    let l:options = ale#Var(a:buffer, 'c_uncrustify_options')
-
-    return {
-    \   'command': ale#Escape(l:executable)
-    \       . ' --no-backup'
-    \       . (empty(l:options) ? '' : ' ' . l:options)
-    \}
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/fixers/xmllint.vim b/sources_non_forked/ale/autoload/ale/fixers/xmllint.vim
deleted file mode 100644
index b14ffd3..0000000
--- a/sources_non_forked/ale/autoload/ale/fixers/xmllint.vim
+++ /dev/null
@@ -1,29 +0,0 @@
-" Author: Cyril Roelandt <tipecaml@gmail.com>
-" Description: Integration of xmllint with ALE.
-
-call ale#Set('xml_xmllint_executable', 'xmllint')
-call ale#Set('xml_xmllint_options', '')
-call ale#Set('xml_xmllint_indentsize', 2)
-
-function! ale#fixers#xmllint#Fix(buffer) abort
-    let l:executable = ale#Escape(ale#Var(a:buffer, 'xml_xmllint_executable'))
-    let l:filename = ale#Escape(bufname(a:buffer))
-    let l:command = l:executable . ' --format ' . l:filename
-
-    let l:indent = ale#Var(a:buffer, 'xml_xmllint_indentsize')
-
-    if l:indent isnot# ''
-        let l:env = ale#Env('XMLLINT_INDENT', repeat(' ', l:indent))
-        let l:command = l:env . l:command
-    endif
-
-    let l:options = ale#Var(a:buffer, 'xml_xmllint_options')
-
-    if l:options isnot# ''
-        let l:command .= ' ' . l:options
-    endif
-
-    return {
-    \   'command': l:command
-    \}
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/fixers/xo.vim b/sources_non_forked/ale/autoload/ale/fixers/xo.vim
deleted file mode 100644
index 882350b..0000000
--- a/sources_non_forked/ale/autoload/ale/fixers/xo.vim
+++ /dev/null
@@ -1,23 +0,0 @@
-" Author: Albert Marquez - https://github.com/a-marquez
-" Description: Fixing files with XO.
-
-call ale#Set('javascript_xo_executable', 'xo')
-call ale#Set('javascript_xo_use_global', get(g:, 'ale_use_global_executables', 0))
-call ale#Set('javascript_xo_options', '')
-
-function! ale#fixers#xo#GetExecutable(buffer) abort
-    return ale#node#FindExecutable(a:buffer, 'javascript_xo', [
-    \   'node_modules/xo/cli.js',
-    \   'node_modules/.bin/xo',
-    \])
-endfunction
-
-function! ale#fixers#xo#Fix(buffer) abort
-    let l:executable = ale#fixers#xo#GetExecutable(a:buffer)
-
-    return {
-    \   'command': ale#node#Executable(a:buffer, l:executable)
-    \       . ' --fix %t',
-    \   'read_temporary_file': 1,
-    \}
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/fixers/yapf.vim b/sources_non_forked/ale/autoload/ale/fixers/yapf.vim
deleted file mode 100644
index f04bb1f..0000000
--- a/sources_non_forked/ale/autoload/ale/fixers/yapf.vim
+++ /dev/null
@@ -1,26 +0,0 @@
-" Author: w0rp <devw0rp@gmail.com>
-" Description: Fixing Python files with yapf.
-
-call ale#Set('python_yapf_executable', 'yapf')
-call ale#Set('python_yapf_use_global', get(g:, 'ale_use_global_executables', 0))
-
-function! ale#fixers#yapf#Fix(buffer) abort
-    let l:executable = ale#python#FindExecutable(
-    \   a:buffer,
-    \   'python_yapf',
-    \   ['yapf'],
-    \)
-
-    if !executable(l:executable)
-        return 0
-    endif
-
-    let l:config = ale#path#FindNearestFile(a:buffer, '.style.yapf')
-    let l:config_options = !empty(l:config)
-    \   ? ' --no-local-style --style ' . ale#Escape(l:config)
-    \   : ''
-
-    return {
-    \   'command': ale#Escape(l:executable) . l:config_options,
-    \}
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/go.vim b/sources_non_forked/ale/autoload/ale/go.vim
deleted file mode 100644
index 4a21e59..0000000
--- a/sources_non_forked/ale/autoload/ale/go.vim
+++ /dev/null
@@ -1,44 +0,0 @@
-" Author: Horacio Sanson https://github.com/hsanson
-" Description: Functions for integrating with Go tools
-
-" Find the nearest dir listed in GOPATH and assume it the root of the go
-" project.
-function! ale#go#FindProjectRoot(buffer) abort
-    let l:sep = has('win32') ? ';' : ':'
-
-    let l:filename = ale#path#Simplify(expand('#' . a:buffer . ':p'))
-
-    for l:name in split($GOPATH, l:sep)
-        let l:path_dir = ale#path#Simplify(l:name)
-
-        " Use the directory from GOPATH if the current filename starts with it.
-        if l:filename[: len(l:path_dir) - 1] is? l:path_dir
-            return l:path_dir
-        endif
-    endfor
-
-    let l:default_go_path = ale#path#Simplify(expand('~/go'))
-
-    if isdirectory(l:default_go_path)
-        return l:default_go_path
-    endif
-
-    return ''
-endfunction
-
-
-call ale#Set('go_go111module', '')
-
-" Return a string setting Go-specific environment variables
-function! ale#go#EnvString(buffer) abort
-    let l:env = ''
-
-    " GO111MODULE - turn go modules behavior on/off
-    let l:go111module = ale#Var(a:buffer, 'go_go111module')
-
-    if !empty(l:go111module)
-        let l:env = ale#Env('GO111MODULE', l:go111module) . l:env
-    endif
-
-    return l:env
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/gradle.vim b/sources_non_forked/ale/autoload/ale/gradle.vim
deleted file mode 100644
index dc377fb..0000000
--- a/sources_non_forked/ale/autoload/ale/gradle.vim
+++ /dev/null
@@ -1,67 +0,0 @@
-" Author: Michael Pardo <michael@michaelpardo.com>
-" Description: Functions for working with Gradle projects.
-
-let s:script_path = fnamemodify(resolve(expand('<sfile>:p')), ':h')
-let s:init_path = has('win32')
-\   ? s:script_path . '\gradle\init.gradle'
-\   : s:script_path . '/gradle/init.gradle'
-
-function! ale#gradle#GetInitPath() abort
-    return s:init_path
-endfunction
-
-" Given a buffer number, find a Gradle project root.
-function! ale#gradle#FindProjectRoot(buffer) abort
-    let l:gradlew_path = ale#path#FindNearestFile(a:buffer, 'gradlew')
-
-    if !empty(l:gradlew_path)
-        return fnamemodify(l:gradlew_path, ':h')
-    endif
-
-    let l:settings_path = ale#path#FindNearestFile(a:buffer, 'settings.gradle')
-
-    if !empty(l:settings_path)
-        return fnamemodify(l:settings_path, ':h')
-    endif
-
-    let l:build_path = ale#path#FindNearestFile(a:buffer, 'build.gradle')
-
-    if !empty(l:build_path)
-        return fnamemodify(l:build_path, ':h')
-    endif
-
-    return ''
-endfunction
-
-" Given a buffer number, find the path to the executable.
-" First search on the path for 'gradlew', if nothing is found, try the global
-" command. Returns an empty string if cannot find the executable.
-function! ale#gradle#FindExecutable(buffer) abort
-    let l:gradlew_path = ale#path#FindNearestFile(a:buffer, 'gradlew')
-
-    if !empty(l:gradlew_path)
-        return l:gradlew_path
-    endif
-
-    if executable('gradle')
-        return 'gradle'
-    endif
-
-    return ''
-endfunction
-
-" Given a buffer number, build a command to print the classpath of the root
-" project. Returns an empty string if cannot build the command.
-function! ale#gradle#BuildClasspathCommand(buffer) abort
-    let l:executable = ale#gradle#FindExecutable(a:buffer)
-    let l:project_root = ale#gradle#FindProjectRoot(a:buffer)
-
-    if !empty(l:executable) && !empty(l:project_root)
-        return ale#path#CdString(l:project_root)
-        \   . ale#Escape(l:executable)
-        \   . ' -I ' . ale#Escape(s:init_path)
-        \   . ' -q printClasspath'
-    endif
-
-    return ''
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/gradle/init.gradle b/sources_non_forked/ale/autoload/ale/gradle/init.gradle
deleted file mode 100644
index fb1db9e..0000000
--- a/sources_non_forked/ale/autoload/ale/gradle/init.gradle
+++ /dev/null
@@ -1,23 +0,0 @@
-class ClasspathPlugin implements Plugin<Project> {
-    void apply(Project project) {
-        project.task('printClasspath') {
-            doLast {
-                project
-                    .rootProject
-                    .allprojects
-                    .configurations
-                    .flatten()
-                    .findAll { it.name.endsWith('Classpath') }
-                    .collect { it.resolve() }
-                    .flatten()
-                    .unique()
-                    .findAll { it.exists() }
-                    .each { println it }
-            }
-        }
-    }
-}
-
-rootProject {
-    apply plugin: ClasspathPlugin
-}
diff --git a/sources_non_forked/ale/autoload/ale/handlers/alex.vim b/sources_non_forked/ale/autoload/ale/handlers/alex.vim
deleted file mode 100644
index 190a7f8..0000000
--- a/sources_non_forked/ale/autoload/ale/handlers/alex.vim
+++ /dev/null
@@ -1,54 +0,0 @@
-scriptencoding utf-8
-" Author: Johannes Wienke <languitar@semipol.de>
-" Description: Error handling for errors in alex output format
-
-function! ale#handlers#alex#GetExecutable(buffer) abort
-    return ale#node#FindExecutable(a:buffer, 'alex', [
-    \   'node_modules/.bin/alex',
-    \   'node_modules/alex/cli.js',
-    \])
-endfunction
-
-function! ale#handlers#alex#CreateCommandCallback(flags) abort
-    return {b -> ale#node#Executable(b, ale#handlers#alex#GetExecutable(b))
-    \            . ' %s '
-    \            . a:flags}
-endfunction
-
-function! ale#handlers#alex#Handle(buffer, lines) abort
-    " Example output:
-    "       6:256-6:262  warning  Be careful with killed, its profane in some cases      killed           retext-profanities
-    let l:pattern = '\v^ *(\d+):(\d+)-(\d+):(\d+) +warning +(.{-})  +(.{-})  +(.{-})$'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        call add(l:output, {
-        \   'lnum': l:match[1] + 0,
-        \   'col': l:match[2] + 0,
-        \   'end_lnum': l:match[3] + 0,
-        \   'end_col': l:match[4] - 1,
-        \   'text': l:match[5] . ' (' . (l:match[7]) . ')',
-        \   'type': 'W',
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-" Define a linter for a specific filetype. Accept flags to adapt to the filetype.
-"    no flags  treat input as markdown
-"    --html    treat input as HTML
-"    --text    treat input as plaintext
-function! ale#handlers#alex#DefineLinter(filetype, flags) abort
-    call ale#Set('alex_executable', 'alex')
-    call ale#Set('alex_use_global', get(g:, 'ale_use_global_executables', 0))
-
-    call ale#linter#Define(a:filetype, {
-    \   'name': 'alex',
-    \   'executable': function('ale#handlers#alex#GetExecutable'),
-    \   'command': ale#handlers#alex#CreateCommandCallback(a:flags),
-    \   'output_stream': 'stderr',
-    \   'callback': 'ale#handlers#alex#Handle',
-    \   'lint_file': 1,
-    \})
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/handlers/ccls.vim b/sources_non_forked/ale/autoload/ale/handlers/ccls.vim
deleted file mode 100644
index 1e2aa31..0000000
--- a/sources_non_forked/ale/autoload/ale/handlers/ccls.vim
+++ /dev/null
@@ -1,19 +0,0 @@
-scriptencoding utf-8
-" Author: Ye Jingchen <ye.jingchen@gmail.com>
-" Description: Utilities for ccls
-
-function! ale#handlers#ccls#GetProjectRoot(buffer) abort
-    " Try to find ccls configuration files first.
-    let l:config = ale#path#FindNearestFile(a:buffer, '.ccls-root')
-
-    if empty(l:config)
-        let l:config = ale#path#FindNearestFile(a:buffer, '.ccls')
-    endif
-
-    if !empty(l:config)
-        return fnamemodify(l:config, ':h')
-    endif
-
-    " Fall back on default project root detection.
-    return ale#c#FindProjectRoot(a:buffer)
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/handlers/cppcheck.vim b/sources_non_forked/ale/autoload/ale/handlers/cppcheck.vim
deleted file mode 100644
index 6d8fa15..0000000
--- a/sources_non_forked/ale/autoload/ale/handlers/cppcheck.vim
+++ /dev/null
@@ -1,62 +0,0 @@
-" Description: Handle errors for cppcheck.
-
-function! ale#handlers#cppcheck#GetCdCommand(buffer) abort
-    let [l:dir, l:json_path] = ale#c#FindCompileCommands(a:buffer)
-    let l:cd_command = !empty(l:dir) ? ale#path#CdString(l:dir) : ''
-
-    return l:cd_command
-endfunction
-
-function! ale#handlers#cppcheck#GetBufferPathIncludeOptions(buffer) abort
-    let l:buffer_path_include = ''
-
-    " Get path to this buffer so we can include it into cppcheck with -I
-    " This could be expanded to get more -I directives from the compile
-    " command in compile_commands.json, if it's found.
-    let l:buffer_path = fnamemodify(bufname(a:buffer), ':p:h')
-    let l:buffer_path_include = ' -I' . ale#Escape(l:buffer_path)
-
-    return l:buffer_path_include
-endfunction
-
-function! ale#handlers#cppcheck#GetCompileCommandsOptions(buffer) abort
-    " If the current buffer is modified, using compile_commands.json does no
-    " good, so include the file's directory instead. It's not quite as good as
-    " using --project, but is at least equivalent to running cppcheck on this
-    " file manually from the file's directory.
-    let l:modified = getbufvar(a:buffer, '&modified')
-
-    if l:modified
-        return ''
-    endif
-
-    " Search upwards from the file for compile_commands.json.
-    "
-    " If we find it, we'll `cd` to where the compile_commands.json file is,
-    " then use the file to set up import paths, etc.
-    let [l:dir, l:json_path] = ale#c#FindCompileCommands(a:buffer)
-
-    return !empty(l:json_path)
-    \   ? '--project=' . ale#Escape(l:json_path[len(l:dir) + 1: ])
-    \   : ''
-endfunction
-
-function! ale#handlers#cppcheck#HandleCppCheckFormat(buffer, lines) abort
-    " Look for lines like the following.
-    "
-    " [test.cpp:5]: (error) Array 'a[10]' accessed at index 10, which is out of bounds
-    let l:pattern = '\v^\[(.+):(\d+)\]: \(([a-z]+)\) (.+)$'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        if ale#path#IsBufferPath(a:buffer, l:match[1])
-            call add(l:output, {
-            \   'lnum': str2nr(l:match[2]),
-            \   'type': l:match[3] is# 'error' ? 'E' : 'W',
-            \   'text': l:match[4],
-            \})
-        endif
-    endfor
-
-    return l:output
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/handlers/cpplint.vim b/sources_non_forked/ale/autoload/ale/handlers/cpplint.vim
deleted file mode 100644
index 5c475a5..0000000
--- a/sources_non_forked/ale/autoload/ale/handlers/cpplint.vim
+++ /dev/null
@@ -1,21 +0,0 @@
-" Author: Dawid Kurek https://github.com/dawikur
-" Description: Handle errors for cpplint.
-
-function! ale#handlers#cpplint#HandleCppLintFormat(buffer, lines) abort
-    " Look for lines like the following.
-    " test.cpp:5:  Estra space after ( in function call [whitespace/parents] [4]
-    let l:pattern = '^.\{-}:\(\d\+\): *\(.\+\) *\[\(.*/.*\)\] '
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        call add(l:output, {
-        \   'lnum': l:match[1] + 0,
-        \   'col': 0,
-        \   'text': join(split(l:match[2])),
-        \   'code': l:match[3],
-        \   'type': 'W',
-        \})
-    endfor
-
-    return l:output
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/handlers/css.vim b/sources_non_forked/ale/autoload/ale/handlers/css.vim
deleted file mode 100644
index de9eadc..0000000
--- a/sources_non_forked/ale/autoload/ale/handlers/css.vim
+++ /dev/null
@@ -1,70 +0,0 @@
-scriptencoding utf-8
-" Author: w0rp <devw0rp@gmail.com>
-" Description: Error handling for CSS linters.
-
-function! ale#handlers#css#HandleCSSLintFormat(buffer, lines) abort
-    " Matches patterns line the following:
-    "
-    " something.css: line 2, col 1, Error - Expected RBRACE at line 2, col 1. (errors)
-    " something.css: line 2, col 5, Warning - Expected (inline | block | list-item | inline-block | table | inline-table | table-row-group | table-header-group | table-footer-group | table-row | table-column-group | table-column | table-cell | table-caption | grid | inline-grid | run-in | ruby | ruby-base | ruby-text | ruby-base-container | ruby-text-container | contents | none | -moz-box | -moz-inline-block | -moz-inline-box | -moz-inline-grid | -moz-inline-stack | -moz-inline-table | -moz-grid | -moz-grid-group | -moz-grid-line | -moz-groupbox | -moz-deck | -moz-popup | -moz-stack | -moz-marker | -webkit-box | -webkit-inline-box | -ms-flexbox | -ms-inline-flexbox | flex | -webkit-flex | inline-flex | -webkit-inline-flex) but found 'wat'. (known-properties)
-    "
-    " These errors can be very massive, so the type will be moved to the front
-    " so you can actually read the error type.
-    let l:pattern = '\v^.*: line (\d+), col (\d+), (Error|Warning) - (.+)$'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        let l:item = {
-        \   'lnum': l:match[1] + 0,
-        \   'col': l:match[2] + 0,
-        \   'type': l:match[3] is# 'Warning' ? 'W' : 'E',
-        \   'text': l:match[4],
-        \}
-
-        let l:code_match = matchlist(l:match[4], '\v(.+) \(([^(]+)\)$')
-
-        " Split up the error code and the text if we find one.
-        if !empty(l:code_match)
-            let l:item.text = l:code_match[1]
-            let l:item.code = l:code_match[2]
-        endif
-
-        call add(l:output, l:item)
-    endfor
-
-    return l:output
-endfunction
-
-function! ale#handlers#css#HandleStyleLintFormat(buffer, lines) abort
-    let l:exception_pattern = '\v^Error:'
-
-    for l:line in a:lines[:10]
-        if len(matchlist(l:line, l:exception_pattern)) > 0
-            return [{
-            \   'lnum': 1,
-            \   'text': 'stylelint exception thrown (type :ALEDetail for more information)',
-            \   'detail': join(a:lines, "\n"),
-            \}]
-        endif
-    endfor
-
-    " Matches patterns line the following:
-    "
-    " src/main.css
-    "  108:10    Unexpected leading zero         number-leading-zero
-    "  116:20    Expected a trailing semicolon   declaration-block-trailing-semicolon
-    let l:pattern = '\v^.* (\d+):(\d+) \s+(\S+)\s+ (.*[^ ])\s+([^ ]+)\s*$'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        call add(l:output, {
-        \   'lnum': l:match[1] + 0,
-        \   'col': l:match[2] + 0,
-        \   'type': l:match[3] is# '' ? 'E' : 'W',
-        \   'text': l:match[4],
-        \   'code': l:match[5],
-        \})
-    endfor
-
-    return l:output
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/handlers/elixir.vim b/sources_non_forked/ale/autoload/ale/handlers/elixir.vim
deleted file mode 100644
index 2fddf8e..0000000
--- a/sources_non_forked/ale/autoload/ale/handlers/elixir.vim
+++ /dev/null
@@ -1,28 +0,0 @@
-" Author: Matteo Centenaro (bugant) - https://github.com/bugant
-" Author: Jon Parise <jon@indelible.org>
-" Description: Functions for working with Elixir projects
-
-" Find the root directory for an elixir project that uses mix.
-function! ale#handlers#elixir#FindMixProjectRoot(buffer) abort
-    let l:mix_file = ale#path#FindNearestFile(a:buffer, 'mix.exs')
-
-    if !empty(l:mix_file)
-        return fnamemodify(l:mix_file, ':p:h')
-    endif
-
-    return '.'
-endfunction
-
-" Similar to ale#handlers#elixir#FindMixProjectRoot but also continue the
-" search upward for a potential umbrella project root. If an umbrella root
-" does not exist, the initial project root will be returned.
-function! ale#handlers#elixir#FindMixUmbrellaRoot(buffer) abort
-    let l:app_root = ale#handlers#elixir#FindMixProjectRoot(a:buffer)
-    let l:umbrella_root = fnamemodify(l:app_root, ':h:h')
-
-    if filereadable(l:umbrella_root . '/mix.exs')
-        return l:umbrella_root
-    endif
-
-    return l:app_root
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/handlers/eslint.vim b/sources_non_forked/ale/autoload/ale/handlers/eslint.vim
deleted file mode 100644
index 156b939..0000000
--- a/sources_non_forked/ale/autoload/ale/handlers/eslint.vim
+++ /dev/null
@@ -1,260 +0,0 @@
-" Author: w0rp <devw0rp@gmail.com>
-" Description: Functions for working with eslint, for checking or fixing files.
-
-let s:sep = has('win32') ? '\' : '/'
-
-call ale#Set('javascript_eslint_options', '')
-call ale#Set('javascript_eslint_executable', 'eslint')
-call ale#Set('javascript_eslint_use_global', get(g:, 'ale_use_global_executables', 0))
-call ale#Set('javascript_eslint_suppress_eslintignore', 0)
-call ale#Set('javascript_eslint_suppress_missing_config', 0)
-
-function! ale#handlers#eslint#FindConfig(buffer) abort
-    for l:path in ale#path#Upwards(expand('#' . a:buffer . ':p:h'))
-        for l:basename in [
-        \   '.eslintrc.js',
-        \   '.eslintrc.yaml',
-        \   '.eslintrc.yml',
-        \   '.eslintrc.json',
-        \   '.eslintrc',
-        \]
-            let l:config = ale#path#Simplify(join([l:path, l:basename], s:sep))
-
-            if filereadable(l:config)
-                return l:config
-            endif
-        endfor
-    endfor
-
-    return ale#path#FindNearestFile(a:buffer, 'package.json')
-endfunction
-
-function! ale#handlers#eslint#GetExecutable(buffer) abort
-    return ale#node#FindExecutable(a:buffer, 'javascript_eslint', [
-    \   'node_modules/.bin/eslint_d',
-    \   'node_modules/eslint/bin/eslint.js',
-    \   'node_modules/.bin/eslint',
-    \])
-endfunction
-
-function! ale#handlers#eslint#GetCommand(buffer) abort
-    let l:executable = ale#handlers#eslint#GetExecutable(a:buffer)
-
-    let l:options = ale#Var(a:buffer, 'javascript_eslint_options')
-
-    " ESLint 6 loads plugins/configs/parsers from the project root
-    " By default, the project root is simply the CWD of the running process.
-    " https://github.com/eslint/rfcs/blob/master/designs/2018-simplified-package-loading/README.md
-    " https://github.com/dense-analysis/ale/issues/2787
-    " Identify project root from presence of node_modules dir.
-    " Note: If node_modules not present yet, can't load local deps anyway.
-    let l:modules_dir = ale#path#FindNearestDirectory(a:buffer, 'node_modules')
-    let l:project_dir = !empty(l:modules_dir) ? fnamemodify(l:modules_dir, ':h:h') : ''
-    let l:cd_command = !empty(l:project_dir) ? ale#path#CdString(l:project_dir) : ''
-
-    return l:cd_command
-    \   . ale#node#Executable(a:buffer, l:executable)
-    \   . (!empty(l:options) ? ' ' . l:options : '')
-    \   . ' -f json --stdin --stdin-filename %s'
-endfunction
-
-function! s:AddHintsForTypeScriptParsingErrors(output) abort
-    for l:item in a:output
-        let l:item.text = substitute(
-        \   l:item.text,
-        \   '^\(Parsing error\)',
-        \   '\1 (You may need configure typescript-eslint-parser)',
-        \   '',
-        \)
-    endfor
-endfunction
-
-function! s:CheckForBadConfig(buffer, lines) abort
-    let l:config_error_pattern = '\v^ESLint couldn''t find a configuration file'
-    \   . '|^Cannot read config file'
-    \   . '|^.*Configuration for rule .* is invalid'
-    \   . '|^ImportDeclaration should appear'
-
-    " Look for a message in the first few lines which indicates that
-    " a configuration file couldn't be found.
-    for l:line in a:lines[:10]
-        let l:match = matchlist(l:line, l:config_error_pattern)
-
-        if len(l:match) > 0
-            " Don't show the missing config error if we've disabled it.
-            if ale#Var(a:buffer, 'javascript_eslint_suppress_missing_config')
-            \&& l:match[0] is# 'ESLint couldn''t find a configuration file'
-                return 0
-            endif
-
-            return 1
-        endif
-    endfor
-
-    return 0
-endfunction
-
-function! s:parseJSON(buffer, lines) abort
-    let l:parsed = []
-
-    for l:line in a:lines
-        try
-            let l:parsed = extend(l:parsed, json_decode(l:line))
-        catch
-        endtry
-    endfor
-
-    if type(l:parsed) != v:t_list || empty(l:parsed)
-        return []
-    endif
-
-    let l:errors = l:parsed[0]['messages']
-
-    if empty(l:errors)
-        return []
-    endif
-
-    let l:output = []
-
-    for l:error in l:errors
-        let l:obj = ({
-        \   'lnum': get(l:error, 'line', 0),
-        \   'text': get(l:error, 'message', ''),
-        \   'type': 'E',
-        \})
-
-        if get(l:error, 'severity', 0) is# 1
-            let l:obj.type = 'W'
-        endif
-
-        if has_key(l:error, 'ruleId')
-            let l:code = l:error['ruleId']
-
-            " Sometimes ESLint returns null here
-            if !empty(l:code)
-                let l:obj.code = l:code
-            endif
-        endif
-
-        if has_key(l:error, 'column')
-            let l:obj.col = l:error['column']
-        endif
-
-        if has_key(l:error, 'endColumn')
-            let l:obj.end_col = l:error['endColumn'] - 1
-        endif
-
-        if has_key(l:error, 'endLine')
-            let l:obj.end_lnum = l:error['endLine']
-        endif
-
-        call add(l:output, l:obj)
-    endfor
-
-    return l:output
-endfunction
-
-let s:col_end_patterns = [
-\   '\vParsing error: Unexpected token (.+) ?',
-\   '\v''(.+)'' is not defined.',
-\   '\v%(Unexpected|Redundant use of) [''`](.+)[''`]',
-\   '\vUnexpected (console) statement',
-\]
-
-function! s:parseLines(buffer, lines) abort
-    " Matches patterns line the following:
-    "
-    " /path/to/some-filename.js:47:14: Missing trailing comma. [Warning/comma-dangle]
-    " /path/to/some-filename.js:56:41: Missing semicolon. [Error/semi]
-    let l:pattern = '^.*:\(\d\+\):\(\d\+\): \(.\+\) \[\(.\+\)\]$'
-    " This second pattern matches lines like the following:
-    "
-    " /path/to/some-filename.js:13:3: Parsing error: Unexpected token
-    let l:parsing_pattern = '^.*:\(\d\+\):\(\d\+\): \(.\+\)$'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, [l:pattern, l:parsing_pattern])
-        let l:text = l:match[3]
-
-        let l:obj = {
-        \   'lnum': l:match[1] + 0,
-        \   'col': l:match[2] + 0,
-        \   'text': l:text,
-        \   'type': 'E',
-        \}
-
-        " Take the error type from the output if available.
-        let l:split_code = split(l:match[4], '/')
-
-        if get(l:split_code, 0, '') is# 'Warning'
-            let l:obj.type = 'W'
-        endif
-
-        " The code can be something like 'Error/foo/bar', or just 'Error'
-        if !empty(get(l:split_code, 1))
-            let l:obj.code = join(l:split_code[1:], '/')
-        endif
-
-        for l:col_match in ale#util#GetMatches(l:text, s:col_end_patterns)
-            let l:obj.end_col = l:obj.col + len(l:col_match[1]) - 1
-        endfor
-
-        call add(l:output, l:obj)
-    endfor
-
-    return l:output
-endfunction
-
-function! s:FilterResult(buffer, obj) abort
-    if ale#Var(a:buffer, 'javascript_eslint_suppress_eslintignore')
-        if a:obj.text =~# '^File ignored'
-            return 0
-        endif
-    endif
-
-    if has_key(a:obj, 'code') && a:obj.code is# 'no-trailing-spaces'
-    \&& !ale#Var(a:buffer, 'warn_about_trailing_whitespace')
-        return 0
-    endif
-
-    return 1
-endfunction
-
-function! s:HandleESLintOutput(buffer, lines, type) abort
-    if s:CheckForBadConfig(a:buffer, a:lines)
-        return [{
-        \   'lnum': 1,
-        \   'text': 'eslint configuration error (type :ALEDetail for more information)',
-        \   'detail': join(a:lines, "\n"),
-        \}]
-    endif
-
-    if a:lines == ['Could not connect']
-        return [{
-        \   'lnum': 1,
-        \   'text': 'Could not connect to eslint_d. Try updating eslint_d or killing it.',
-        \}]
-    endif
-
-    if a:type is# 'json'
-        let l:output = s:parseJSON(a:buffer, a:lines)
-    else
-        let l:output = s:parseLines(a:buffer, a:lines)
-    endif
-
-    call filter(l:output, {idx, obj -> s:FilterResult(a:buffer, obj)})
-
-    if expand('#' . a:buffer . ':t') =~? '\.tsx\?$'
-        call s:AddHintsForTypeScriptParsingErrors(l:output)
-    endif
-
-    return l:output
-endfunction
-
-function! ale#handlers#eslint#HandleJSON(buffer, lines) abort
-    return s:HandleESLintOutput(a:buffer, a:lines, 'json')
-endfunction
-
-function! ale#handlers#eslint#Handle(buffer, lines) abort
-    return s:HandleESLintOutput(a:buffer, a:lines, 'lines')
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/handlers/fecs.vim b/sources_non_forked/ale/autoload/ale/handlers/fecs.vim
deleted file mode 100644
index 5362edb..0000000
--- a/sources_non_forked/ale/autoload/ale/handlers/fecs.vim
+++ /dev/null
@@ -1,52 +0,0 @@
-" Author: harttle <yangjvn@126.com>
-" Description: fecs http://fecs.baidu.com/
-
-call ale#Set('javascript_fecs_executable', 'fecs')
-call ale#Set('javascript_fecs_use_global', get(g:, 'ale_use_global_executables', 0))
-
-function! ale#handlers#fecs#GetCommand(buffer) abort
-    return '%e check --colors=false --rule=true %t'
-endfunction
-
-function! ale#handlers#fecs#GetExecutable(buffer) abort
-    return ale#node#FindExecutable(a:buffer, 'javascript_fecs', [
-    \   'node_modules/.bin/fecs',
-    \   'node_modules/fecs/bin/fecs',
-    \])
-endfunction
-
-function! ale#handlers#fecs#Handle(buffer, lines) abort
-    " Matches patterns looking like the following
-    "
-    " fecs  WARN  line 20, col 25: Unexpected console statement.     (no-console)
-    " fecs ERROR  line 24, col 36: Missing radix parameter.  (radix)
-    "
-    let l:pattern = '\v^.*(WARN|ERROR)\s+\s+line (\d+),\s+col\s+(\d+):\s+(.*)$'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        let l:obj = {
-        \   'lnum': l:match[2] + 0,
-        \   'col': l:match[3] + 0,
-        \   'text': l:match[4]
-        \}
-
-        let l:code_match = matchlist(l:match[4], '\v^(.{-})\s*\((.+)\)$')
-
-        if !empty(l:code_match)
-            let l:obj.code = l:code_match[2]
-            let l:obj.text = l:code_match[1]
-        endif
-
-        if l:match[1] is# 'WARN'
-            let l:obj.type = 'W'
-        elseif l:match[1] is# 'ERROR'
-            let l:obj.type = 'E'
-        endif
-
-        call add(l:output, l:obj)
-    endfor
-
-    return l:output
-endfunction
-
diff --git a/sources_non_forked/ale/autoload/ale/handlers/flawfinder.vim b/sources_non_forked/ale/autoload/ale/handlers/flawfinder.vim
deleted file mode 100644
index b7d2bec..0000000
--- a/sources_non_forked/ale/autoload/ale/handlers/flawfinder.vim
+++ /dev/null
@@ -1,48 +0,0 @@
-scriptencoding utf-8
-" Author: Christian Gibbons <cgibbons@gmu.edu>
-" Description: This file defines a handler function that should work for the
-" flawfinder format with the -CDQS flags.
-
-" Swiped this function from the GCC handler. Not sure if needed, but doesn't
-" hurt to have it.
-function! s:RemoveUnicodeQuotes(text) abort
-    let l:text = a:text
-    let l:text = substitute(l:text, '[`]', '''', 'g')
-    let l:text = substitute(l:text, '\v\\u2018([^\\]+)\\u2019', '''\1''', 'g')
-    let l:text = substitute(l:text, '[]', '"', 'g')
-
-    return l:text
-endfunction
-
-function! ale#handlers#flawfinder#HandleFlawfinderFormat(buffer, lines) abort
-    " Look for lines like the following.
-    "
-    " <stdin>:12:4:  [2] (buffer) char:Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).  Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.
-    " <stdin>:31:4:  [1] (buffer) strncpy:Easily used incorrectly; doesn't always \0-terminate or check for invalid pointers [MS-banned] (CWE-120).
-    let l:pattern = '\v^([a-zA-Z]?:?[^:]+):(\d+):(\d+)?:? ( \[[0-5]\] [^:]+):(.+)$'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        " Use severity level to determine if it should be considered a warning
-        " or error.
-        let l:severity = str2nr(matchstr(split(l:match[4])[0], '[0-5]'))
-
-        let l:item = {
-        \   'lnum': str2nr(l:match[2]),
-        \   'col': str2nr(l:match[3]),
-        \   'type': (l:severity < ale#Var(a:buffer, 'c_flawfinder_error_severity'))
-        \       ? 'W' : 'E',
-        \   'text': s:RemoveUnicodeQuotes(join(split(l:match[4])[1:]) . ': ' . l:match[5]),
-        \}
-
-        " If the filename is something like <stdin>, <nofile> or -, then
-        " this is an error for the file we checked.
-        if l:match[1] isnot# '-' && l:match[1][0] isnot# '<'
-            let l:item['filename'] = l:match[1]
-        endif
-
-        call add(l:output, l:item)
-    endfor
-
-    return l:output
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/handlers/gawk.vim b/sources_non_forked/ale/autoload/ale/handlers/gawk.vim
deleted file mode 100644
index 50bc4c4..0000000
--- a/sources_non_forked/ale/autoload/ale/handlers/gawk.vim
+++ /dev/null
@@ -1,27 +0,0 @@
-" Author: Anthony DeDominic <adedomin@gmail.com>
-" Description: Handle output from gawk's --lint option
-
-function! ale#handlers#gawk#HandleGawkFormat(buffer, lines) abort
-    " Look for lines like the following:
-    " gawk: /tmp/v0fddXz/1/something.awk:1: ^ invalid char ''' in expression
-    let l:pattern = '^.\{-}:\(\d\+\):\s\+\(warning:\|\^\)\s*\(.*\)'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        let l:ecode = 'E'
-
-        if l:match[2] is? 'warning:'
-            let l:ecode = 'W'
-        endif
-
-        call add(l:output, {
-        \   'lnum': l:match[1] + 0,
-        \   'col': 0,
-        \   'text': l:match[3],
-        \   'code': 0,
-        \   'type': l:ecode,
-        \})
-    endfor
-
-    return l:output
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/handlers/gcc.vim b/sources_non_forked/ale/autoload/ale/handlers/gcc.vim
deleted file mode 100644
index ec16b97..0000000
--- a/sources_non_forked/ale/autoload/ale/handlers/gcc.vim
+++ /dev/null
@@ -1,159 +0,0 @@
-scriptencoding utf-8
-" Author: w0rp <devw0rp@gmail.com>
-" Description: This file defines a handler function which ought to work for
-" any program which outputs errors in the format that GCC uses.
-
-let s:pragma_error = '#pragma once in main file'
-
-" Look for lines like the following.
-"
-" <stdin>:8:5: warning: conversion lacks type at end of format [-Wformat=]
-" <stdin>:10:27: error: invalid operands to binary - (have int and char *)
-" -:189:7: note: $/${} is unnecessary on arithmetic variables. [SC2004]
-let s:pattern = '\v^([a-zA-Z]?:?[^:]+):(\d+):(\d+)?:? ([^:]+): (.+)$'
-let s:inline_pattern = '\v inlined from .* at \<stdin\>:(\d+):(\d+):$'
-
-function! s:IsHeaderFile(filename) abort
-    return a:filename =~? '\v\.(h|hpp)$'
-endfunction
-
-function! s:RemoveUnicodeQuotes(text) abort
-    let l:text = a:text
-    let l:text = substitute(l:text, '[`]', '''', 'g')
-    let l:text = substitute(l:text, '\v\\u2018([^\\]+)\\u2019', '''\1''', 'g')
-    let l:text = substitute(l:text, '[]', '"', 'g')
-
-    return l:text
-endfunction
-
-function! s:ParseInlinedFunctionProblems(buffer, lines) abort
-    let l:output = []
-    let l:pos_match = []
-
-    for l:line in a:lines
-        let l:match = matchlist(l:line, s:pattern)
-
-        if !empty(l:match) && !empty(l:pos_match)
-            call add(l:output, {
-            \   'lnum': str2nr(l:pos_match[1]),
-            \   'col': str2nr(l:pos_match[2]),
-            \   'type': (l:match[4] is# 'error' || l:match[4] is# 'fatal error') ? 'E' : 'W',
-            \   'text': s:RemoveUnicodeQuotes(l:match[5]),
-            \})
-        endif
-
-        let l:pos_match = matchlist(l:line, s:inline_pattern)
-    endfor
-
-    return l:output
-endfunction
-
-" Report problems inside of header files just for gcc and clang
-function! s:ParseProblemsInHeaders(buffer, lines) abort
-    let l:output = []
-    let l:include_item = {}
-
-    for l:line in a:lines[: -2]
-        let l:include_match = matchlist(l:line, '\v^In file included from')
-
-        if !empty(l:include_item)
-            let l:pattern_match = matchlist(l:line, s:pattern)
-
-            if !empty(l:pattern_match) && l:pattern_match[1] is# '<stdin>'
-                if has_key(l:include_item, 'lnum')
-                    call add(l:output, l:include_item)
-                endif
-
-                let l:include_item = {}
-
-                continue
-            endif
-
-            let l:include_item.detail .= "\n" . l:line
-        endif
-
-        if !empty(l:include_match)
-            if empty(l:include_item)
-                let l:include_item = {
-                \   'text': 'Error found in header. See :ALEDetail',
-                \   'detail': l:line,
-                \}
-            endif
-        endif
-
-        if !empty(l:include_item)
-            let l:stdin_match = matchlist(l:line, '\vfrom \<stdin\>:(\d+):(\d*):?$')
-
-            if !empty(l:stdin_match)
-                let l:include_item.lnum = str2nr(l:stdin_match[1])
-
-                if str2nr(l:stdin_match[2])
-                    let l:include_item.col = str2nr(l:stdin_match[2])
-                endif
-            endif
-        endif
-    endfor
-
-    if !empty(l:include_item) && has_key(l:include_item, 'lnum')
-        call add(l:output, l:include_item)
-    endif
-
-    return l:output
-endfunction
-
-function! ale#handlers#gcc#HandleGCCFormat(buffer, lines) abort
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, s:pattern)
-        " Filter out the pragma errors
-        if s:IsHeaderFile(bufname(bufnr('')))
-        \&& l:match[5][:len(s:pragma_error) - 1] is# s:pragma_error
-            continue
-        endif
-
-        " If the 'error type' is a note, make it detail related to
-        " the previous error parsed in output
-        if l:match[4] is# 'note'
-            if !empty(l:output)
-                if !has_key(l:output[-1], 'detail')
-                    let l:output[-1].detail = l:output[-1].text
-                endif
-
-                let l:output[-1].detail = l:output[-1].detail . "\n"
-                \   . s:RemoveUnicodeQuotes(l:match[0])
-            endif
-
-            continue
-        endif
-
-        let l:item = {
-        \   'lnum': str2nr(l:match[2]),
-        \   'type': (l:match[4] is# 'error' || l:match[4] is# 'fatal error') ? 'E' : 'W',
-        \   'text': s:RemoveUnicodeQuotes(l:match[5]),
-        \}
-
-        if !empty(l:match[3])
-            let l:item.col = str2nr(l:match[3])
-        endif
-
-        " If the filename is something like <stdin>, <nofile> or -, then
-        " this is an error for the file we checked.
-        if l:match[1] isnot# '-' && l:match[1][0] isnot# '<'
-            let l:item['filename'] = l:match[1]
-        endif
-
-        call add(l:output, l:item)
-    endfor
-
-    return l:output
-endfunction
-
-" Handle problems with the GCC format, but report problems inside of headers.
-function! ale#handlers#gcc#HandleGCCFormatWithIncludes(buffer, lines) abort
-    let l:output = ale#handlers#gcc#HandleGCCFormat(a:buffer, a:lines)
-
-    call extend(l:output, s:ParseInlinedFunctionProblems(a:buffer, a:lines))
-    call extend(l:output, s:ParseProblemsInHeaders(a:buffer, a:lines))
-
-    return l:output
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/handlers/go.vim b/sources_non_forked/ale/autoload/ale/handlers/go.vim
deleted file mode 100644
index f17cd86..0000000
--- a/sources_non_forked/ale/autoload/ale/handlers/go.vim
+++ /dev/null
@@ -1,26 +0,0 @@
-" Author: neersighted <bjorn@neersighted.com>
-" Description: go vet for Go files
-"
-" Author: John Eikenberry <jae@zhar.net>
-" Description: updated to work with go1.10
-"
-" Author: Ben Paxton <ben@gn32.uk>
-" Description: moved to generic Golang file from govet
-
-function! ale#handlers#go#Handler(buffer, lines) abort
-    let l:pattern = '\v^([a-zA-Z]?:?[^:]+):(\d+):?(\d+)?:? ?(.+)$'
-    let l:output = []
-    let l:dir = expand('#' . a:buffer . ':p:h')
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        call add(l:output, {
-        \   'filename': ale#path#GetAbsPath(l:dir, l:match[1]),
-        \   'lnum': l:match[2] + 0,
-        \   'col': l:match[3] + 0,
-        \   'text': l:match[4],
-        \   'type': 'E',
-        \})
-    endfor
-
-    return l:output
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/handlers/haskell.vim b/sources_non_forked/ale/autoload/ale/handlers/haskell.vim
deleted file mode 100644
index 3613b1b..0000000
--- a/sources_non_forked/ale/autoload/ale/handlers/haskell.vim
+++ /dev/null
@@ -1,101 +0,0 @@
-" Author: w0rp <devw0rp@gmail.com>
-" Description: Error handling for the format GHC outputs.
-"
-function! ale#handlers#haskell#GetStackExecutable(bufnr) abort
-    if ale#path#FindNearestFile(a:bufnr, 'stack.yaml') isnot# ''
-        return 'stack'
-    endif
-
-    " if there is no stack.yaml file, we don't use stack even if it exists,
-    " so we return '', because executable('') apparently always fails
-    return ''
-endfunction
-
-" Remember the directory used for temporary files for Vim.
-let s:temp_dir = fnamemodify(ale#util#Tempname(), ':h')
-" Build part of a regular expression for matching ALE temporary filenames.
-let s:temp_regex_prefix =
-\   '\M'
-\   . substitute(s:temp_dir, '\\', '\\\\', 'g')
-\   . '\.\{-}'
-
-function! ale#handlers#haskell#HandleGHCFormat(buffer, lines) abort
-    " Look for lines like the following.
-    "
-    "Appoint/Lib.hs:8:1: warning:
-    "Appoint/Lib.hs:8:1:
-    let l:basename = expand('#' . a:buffer . ':t')
-    " Build a complete regular expression for replacing temporary filenames
-    " in Haskell error messages with the basename for this file.
-    let l:temp_filename_regex = s:temp_regex_prefix . l:basename
-
-    let l:pattern = '\v^\s*([a-zA-Z]?:?[^:]+):(\d+):(\d+):(.*)?$'
-    let l:output = []
-
-    let l:corrected_lines = []
-
-    " Group the lines into smaller lists.
-    for l:line in a:lines
-        if len(matchlist(l:line, l:pattern)) > 0
-            call add(l:corrected_lines, [l:line])
-        elseif l:line is# ''
-            call add(l:corrected_lines, [l:line])
-        elseif len(l:corrected_lines) > 0
-            call add(l:corrected_lines[-1], l:line)
-        endif
-    endfor
-
-    for l:line_list in l:corrected_lines
-        " Join the smaller lists into one large line to parse.
-        let l:line = l:line_list[0]
-
-        for l:extra_line in l:line_list[1:]
-            let l:line .= substitute(l:extra_line, '\v^\s+', ' ', '')
-        endfor
-
-        let l:match = matchlist(l:line, l:pattern)
-
-        if len(l:match) == 0
-            continue
-        endif
-
-        if !ale#path#IsBufferPath(a:buffer, l:match[1])
-            continue
-        endif
-
-        let l:errors = matchlist(l:match[4], '\v([wW]arning|[eE]rror): ?(.*)')
-
-        if len(l:errors) > 0
-            let l:ghc_type = l:errors[1]
-            let l:text = l:errors[2]
-        else
-            let l:ghc_type = ''
-            let l:text = l:match[4][:0] is# ' ' ? l:match[4][1:] : l:match[4]
-        endif
-
-        if l:ghc_type is? 'Warning'
-            let l:type = 'W'
-        else
-            let l:type = 'E'
-        endif
-
-        " Replace temporary filenames in problem messages with the basename
-        let l:text = substitute(l:text, l:temp_filename_regex, l:basename, 'g')
-
-        let l:item = {
-        \   'lnum': l:match[2] + 0,
-        \   'col': l:match[3] + 0,
-        \   'text': l:text,
-        \   'type': l:type,
-        \}
-
-        " Include extra lines as details if they are there.
-        if len(l:line_list) > 1
-            let l:item.detail = join(l:line_list[1:], "\n")
-        endif
-
-        call add(l:output, l:item)
-    endfor
-
-    return l:output
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/handlers/haskell_stack.vim b/sources_non_forked/ale/autoload/ale/handlers/haskell_stack.vim
deleted file mode 100644
index 108301a..0000000
--- a/sources_non_forked/ale/autoload/ale/handlers/haskell_stack.vim
+++ /dev/null
@@ -1,7 +0,0 @@
-function! ale#handlers#haskell_stack#EscapeExecutable(executable, stack_exec) abort
-    let l:exec_args = a:executable =~? 'stack$'
-    \   ? ' exec ' . ale#Escape(a:stack_exec) . ' --'
-    \   : ''
-
-    return ale#Escape(a:executable) . l:exec_args
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/handlers/hlint.vim b/sources_non_forked/ale/autoload/ale/handlers/hlint.vim
deleted file mode 100644
index b9a8c32..0000000
--- a/sources_non_forked/ale/autoload/ale/handlers/hlint.vim
+++ /dev/null
@@ -1,8 +0,0 @@
-call ale#Set('haskell_hlint_executable', 'hlint')
-call ale#Set('haskell_hlint_options', get(g:, 'hlint_options', ''))
-
-function! ale#handlers#hlint#GetExecutable(buffer) abort
-    let l:executable = ale#Var(a:buffer, 'haskell_hlint_executable')
-
-    return ale#handlers#haskell_stack#EscapeExecutable(l:executable, 'hlint')
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/handlers/ktlint.vim b/sources_non_forked/ale/autoload/ale/handlers/ktlint.vim
deleted file mode 100644
index ad99948..0000000
--- a/sources_non_forked/ale/autoload/ale/handlers/ktlint.vim
+++ /dev/null
@@ -1,45 +0,0 @@
-" Author: Michael Phillips <michaeljoelphillips@gmail.com>
-" Description: Handler functions for ktlint.
-
-call ale#Set('kotlin_ktlint_executable', 'ktlint')
-call ale#Set('kotlin_ktlint_rulesets', [])
-call ale#Set('kotlin_ktlint_options', '')
-
-function! ale#handlers#ktlint#GetCommand(buffer) abort
-    let l:executable = ale#Var(a:buffer, 'kotlin_ktlint_executable')
-    let l:options = ale#Var(a:buffer, 'kotlin_ktlint_options')
-    let l:rulesets = ale#handlers#ktlint#GetRulesets(a:buffer)
-
-    return ale#Escape(l:executable)
-    \   . (empty(l:options) ? '' : ' ' . l:options)
-    \   . (empty(l:rulesets) ? '' : ' ' . l:rulesets)
-    \   . ' %t'
-endfunction
-
-function! ale#handlers#ktlint#GetRulesets(buffer) abort
-    let l:rulesets = map(ale#Var(a:buffer, 'kotlin_ktlint_rulesets'), '''--ruleset '' . v:val')
-
-    return join(l:rulesets, ' ')
-endfunction
-
-function! ale#handlers#ktlint#Handle(buffer, lines) abort
-    let l:message_pattern = '^\(.*\):\([0-9]\+\):\([0-9]\+\):\s\+\(.*\)'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:message_pattern)
-        let l:line = l:match[2] + 0
-        let l:column = l:match[3] + 0
-        let l:text = l:match[4]
-
-        let l:type = l:text =~? 'not a valid kotlin file' ? 'E' : 'W'
-
-        call add(l:output, {
-        \   'lnum': l:line,
-        \   'col': l:column,
-        \   'text': l:text,
-        \   'type': l:type
-        \})
-    endfor
-
-    return l:output
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/handlers/languagetool.vim b/sources_non_forked/ale/autoload/ale/handlers/languagetool.vim
deleted file mode 100644
index 73974ce..0000000
--- a/sources_non_forked/ale/autoload/ale/handlers/languagetool.vim
+++ /dev/null
@@ -1,77 +0,0 @@
-" Author: Vincent (wahrwolf [at] wolfpit.net)
-" Description: languagetool for markdown files
-"
-call ale#Set('languagetool_executable', 'languagetool')
-call ale#Set('languagetool_options', '--autoDetect')
-
-function! ale#handlers#languagetool#GetExecutable(buffer) abort
-    return ale#Var(a:buffer, 'languagetool_executable')
-endfunction
-
-function! ale#handlers#languagetool#GetCommand(buffer) abort
-    let l:executable = ale#handlers#languagetool#GetExecutable(a:buffer)
-    let l:options = ale#Var(a:buffer, 'languagetool_options')
-
-    return ale#Escape(l:executable)
-    \ . (empty(l:options) ? '' : ' ' . l:options) . ' %s'
-endfunction
-
-function! ale#handlers#languagetool#HandleOutput(buffer, lines) abort
-    " Match lines like:
-    " 1.) Line 5, column 1, Rule ID:
-    let l:head_pattern = '^\v.+.\) Line (\d+), column (\d+), Rule ID. (.+)$'
-    let l:head_matches = ale#util#GetMatches(a:lines, l:head_pattern)
-
-    " Match lines like:
-    " Message: Did you forget a comma after a conjunctive/linking adverb?
-    let l:message_pattern = '^\vMessage. (.+)$'
-    let l:message_matches = ale#util#GetMatches(a:lines, l:message_pattern)
-
-    " Match lines like:
-    "   ^^^^^ "
-    let l:markers_pattern = '^\v *(\^+) *$'
-    let l:markers_matches = ale#util#GetMatches(a:lines, l:markers_pattern)
-
-    let l:output = []
-
-
-    " Okay tbh I was to lazy to figure out a smarter solution here
-    " We just check that the arrays are same sized and merge everything
-    " together
-    let l:i = 0
-
-    while l:i < len(l:head_matches)
-    \   && (
-    \       (len(l:head_matches) == len(l:markers_matches))
-    \       && (len(l:head_matches) == len(l:message_matches))
-    \   )
-        let l:item = {
-        \   'lnum'    : str2nr(l:head_matches[l:i][1]),
-        \   'col'     : str2nr(l:head_matches[l:i][2]),
-        \   'end_col' : str2nr(l:head_matches[l:i][2]) + len(l:markers_matches[l:i][1])-1,
-        \   'type'    : 'W',
-        \   'code'    : l:head_matches[l:i][3],
-        \   'text'    : l:message_matches[l:i][1]
-        \}
-        call add(l:output, l:item)
-        let l:i+=1
-    endwhile
-
-    return l:output
-endfunction
-
-" Define the languagetool linter for a given filetype.
-" TODO:
-" - Add language detection settings based on user env (for mothertongue)
-" - Add fixer
-" - Add config options for rules
-function! ale#handlers#languagetool#DefineLinter(filetype) abort
-    call ale#linter#Define(a:filetype, {
-    \   'name': 'languagetool',
-    \   'executable': function('ale#handlers#languagetool#GetExecutable'),
-    \   'command': function('ale#handlers#languagetool#GetCommand'),
-    \   'output_stream': 'stdout',
-    \   'callback': 'ale#handlers#languagetool#HandleOutput',
-    \   'lint_file': 1,
-    \})
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/handlers/markdownlint.vim b/sources_non_forked/ale/autoload/ale/handlers/markdownlint.vim
deleted file mode 100644
index daaa1d6..0000000
--- a/sources_non_forked/ale/autoload/ale/handlers/markdownlint.vim
+++ /dev/null
@@ -1,17 +0,0 @@
-" Author: Ty-Lucas Kelley <tylucaskelley@gmail.com>
-" Description: Adds support for markdownlint
-
-function! ale#handlers#markdownlint#Handle(buffer, lines) abort
-    let l:pattern=': \(\d*\): \(MD\d\{3}\)\(\/\)\([A-Za-z0-9-]\+\)\(.*\)$'
-    let l:output=[]
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        call add(l:output, {
-        \ 'lnum': l:match[1] + 0,
-        \ 'text': '(' . l:match[2] . l:match[3] . l:match[4] . ')' . l:match[5],
-        \ 'type': 'W',
-        \})
-    endfor
-
-    return l:output
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/handlers/ols.vim b/sources_non_forked/ale/autoload/ale/handlers/ols.vim
deleted file mode 100644
index 74130a2..0000000
--- a/sources_non_forked/ale/autoload/ale/handlers/ols.vim
+++ /dev/null
@@ -1,26 +0,0 @@
-" Author: Michael Jungo <michaeljungo92@gmail.com>
-" Description: Handlers for the OCaml language server
-
-function! ale#handlers#ols#GetExecutable(buffer) abort
-    let l:ols_setting = ale#handlers#ols#GetLanguage(a:buffer) . '_ols'
-
-    return ale#node#FindExecutable(a:buffer, l:ols_setting, [
-    \   'node_modules/.bin/ocaml-language-server',
-    \])
-endfunction
-
-function! ale#handlers#ols#GetCommand(buffer) abort
-    let l:executable = ale#handlers#ols#GetExecutable(a:buffer)
-
-    return ale#node#Executable(a:buffer, l:executable) . ' --stdio'
-endfunction
-
-function! ale#handlers#ols#GetLanguage(buffer) abort
-    return getbufvar(a:buffer, '&filetype')
-endfunction
-
-function! ale#handlers#ols#GetProjectRoot(buffer) abort
-    let l:merlin_file = ale#path#FindNearestFile(a:buffer, '.merlin')
-
-    return !empty(l:merlin_file) ? fnamemodify(l:merlin_file, ':h') : ''
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/handlers/pony.vim b/sources_non_forked/ale/autoload/ale/handlers/pony.vim
deleted file mode 100644
index ea84ac4..0000000
--- a/sources_non_forked/ale/autoload/ale/handlers/pony.vim
+++ /dev/null
@@ -1,33 +0,0 @@
-scriptencoding utf-8
-" Description: This file defines a handler function which ought to work for
-" any program which outputs errors in the format that ponyc uses.
-
-function! s:RemoveUnicodeQuotes(text) abort
-    let l:text = a:text
-    let l:text = substitute(l:text, '[`]', '''', 'g')
-    let l:text = substitute(l:text, '\v\\u2018([^\\]+)\\u2019', '''\1''', 'g')
-    let l:text = substitute(l:text, '[]', '"', 'g')
-
-    return l:text
-endfunction
-
-function! ale#handlers#pony#HandlePonycFormat(buffer, lines) abort
-    " Look for lines like the following.
-    " /home/code/pony/classes/Wombat.pony:22:30: can't lookup private fields from outside the type
-    let l:pattern = '\v^([^:]+):(\d+):(\d+)?:? (.+)$'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        let l:item = {
-        \   'filename': l:match[1],
-        \   'lnum': str2nr(l:match[2]),
-        \   'col': str2nr(l:match[3]),
-        \   'type': 'E',
-        \   'text': s:RemoveUnicodeQuotes(l:match[4]),
-        \}
-
-        call add(l:output, l:item)
-    endfor
-
-    return l:output
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/handlers/redpen.vim b/sources_non_forked/ale/autoload/ale/handlers/redpen.vim
deleted file mode 100644
index 195057c..0000000
--- a/sources_non_forked/ale/autoload/ale/handlers/redpen.vim
+++ /dev/null
@@ -1,65 +0,0 @@
-" Author: rhysd https://rhysd.github.io
-" Description: Redpen, a proofreading tool (http://redpen.cc)
-
-function! ale#handlers#redpen#HandleRedpenOutput(buffer, lines) abort
-    " Only one file was passed to redpen. So response array has only one
-    " element.
-    let l:res = get(ale#util#FuzzyJSONDecode(a:lines, []), 0, {})
-    let l:output = []
-
-    for l:err in get(l:res, 'errors', [])
-        let l:item = {
-        \   'text': l:err.message,
-        \   'type': 'W',
-        \   'code': l:err.validator,
-        \}
-
-        if has_key(l:err, 'startPosition')
-            let l:item.lnum = l:err.startPosition.lineNum
-            let l:item.col = l:err.startPosition.offset + 1
-
-            if has_key(l:err, 'endPosition')
-                let l:item.end_lnum = l:err.endPosition.lineNum
-                let l:item.end_col = l:err.endPosition.offset
-            endif
-        else
-            " Fallback to a whole sentence region when a region is not
-            " specified by the error.
-            let l:item.lnum = l:err.lineNum
-            let l:item.col = l:err.sentenceStartColumnNum + 1
-        endif
-
-        " Adjust column number for multibyte string
-        let l:line = getline(l:item.lnum)
-
-        if l:line is# ''
-            let l:line = l:err.sentence
-        endif
-
-        let l:line = split(l:line, '\zs')
-
-        if l:item.col >= 2
-            let l:col = 0
-
-            for l:strlen in map(l:line[0:(l:item.col - 2)], 'strlen(v:val)')
-                let l:col = l:col + l:strlen
-            endfor
-
-            let l:item.col = l:col + 1
-        endif
-
-        if has_key(l:item, 'end_col')
-            let l:col = 0
-
-            for l:strlen in map(l:line[0:(l:item.end_col - 1)], 'strlen(v:val)')
-                let l:col = l:col + l:strlen
-            endfor
-
-            let l:item.end_col = l:col
-        endif
-
-        call add(l:output, l:item)
-    endfor
-
-    return l:output
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/handlers/ruby.vim b/sources_non_forked/ale/autoload/ale/handlers/ruby.vim
deleted file mode 100644
index 7a1c576..0000000
--- a/sources_non_forked/ale/autoload/ale/handlers/ruby.vim
+++ /dev/null
@@ -1,38 +0,0 @@
-" Author: Brandon Roehl - https://github.com/BrandonRoehl, Matthias Guenther https://wikimatze.de
-"
-" Description: This file implements handlers specific to Ruby.
-
-function! s:HandleSyntaxError(buffer, lines) abort
-    " Matches patterns line the following:
-    "
-    " test.rb:3: warning: parentheses after method name is interpreted as an argument list, not a decomposed argument
-    " test.rb:8: syntax error, unexpected keyword_end, expecting end-of-input
-    let l:pattern = '\v^.+:(\d+): (warning: )?(.+)$'
-    let l:column = '\v^(\s+)\^$'
-    let l:output = []
-
-    for l:line in a:lines
-        let l:match = matchlist(l:line, l:pattern)
-
-        if len(l:match) == 0
-            let l:match = matchlist(l:line, l:column)
-
-            if len(l:match) != 0
-                let l:output[len(l:output) - 1]['col'] = len(l:match[1])
-            endif
-        else
-            call add(l:output, {
-            \   'lnum': l:match[1] + 0,
-            \   'col': 0,
-            \   'text': l:match[2] . l:match[3],
-            \   'type': empty(l:match[2]) ? 'E' : 'W',
-            \})
-        endif
-    endfor
-
-    return l:output
-endfunction
-
-function! ale#handlers#ruby#HandleSyntaxErrors(buffer, lines) abort
-    return s:HandleSyntaxError(a:buffer, a:lines)
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/handlers/rust.vim b/sources_non_forked/ale/autoload/ale/handlers/rust.vim
deleted file mode 100644
index a7fac46..0000000
--- a/sources_non_forked/ale/autoload/ale/handlers/rust.vim
+++ /dev/null
@@ -1,78 +0,0 @@
-" Author: Daniel Schemala <istjanichtzufassen@gmail.com>,
-"   w0rp <devw0rp@gmail.com>
-"
-" Description: This file implements handlers specific to Rust.
-
-if !exists('g:ale_rust_ignore_error_codes')
-    let g:ale_rust_ignore_error_codes = []
-endif
-
-if !exists('g:ale_rust_ignore_secondary_spans')
-    let g:ale_rust_ignore_secondary_spans = 0
-endif
-
-function! s:FindSpan(buffer, span) abort
-    if ale#path#IsBufferPath(a:buffer, a:span.file_name) || a:span.file_name is# '<anon>'
-        return a:span
-    endif
-
-    " Search inside the expansion of an error, as the problem for this buffer
-    " could lie inside a nested object.
-    if !empty(get(a:span, 'expansion', v:null))
-        return s:FindSpan(a:buffer, a:span.expansion.span)
-    endif
-
-    return {}
-endfunction
-
-function! ale#handlers#rust#HandleRustErrors(buffer, lines) abort
-    let l:output = []
-
-    for l:errorline in a:lines
-        " ignore everything that is not JSON
-        if l:errorline !~# '^{'
-            continue
-        endif
-
-        let l:error = json_decode(l:errorline)
-
-        if has_key(l:error, 'message') && type(l:error.message) is v:t_dict
-            let l:error = l:error.message
-        endif
-
-        if !has_key(l:error, 'code')
-            continue
-        endif
-
-        if !empty(l:error.code) && index(g:ale_rust_ignore_error_codes, l:error.code.code) > -1
-            continue
-        endif
-
-        for l:root_span in l:error.spans
-            let l:span = s:FindSpan(a:buffer, l:root_span)
-
-            if ale#Var(a:buffer, 'rust_ignore_secondary_spans') && !get(l:span, 'is_primary', 1)
-                continue
-            endif
-
-            if !empty(l:span)
-                let l:output_line = {
-                \   'lnum': l:span.line_start,
-                \   'end_lnum': l:span.line_end,
-                \   'col': l:span.column_start,
-                \   'end_col': l:span.column_end-1,
-                \   'text': empty(l:span.label) ? l:error.message : printf('%s: %s', l:error.message, l:span.label),
-                \   'type': toupper(l:error.level[0]),
-                \}
-
-                if has_key(l:error, 'rendered') && !empty(l:error.rendered)
-                    let l:output_line.detail = l:error.rendered
-                endif
-
-                call add(l:output, l:output_line)
-            endif
-        endfor
-    endfor
-
-    return l:output
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/handlers/scala.vim b/sources_non_forked/ale/autoload/ale/handlers/scala.vim
deleted file mode 100644
index 3fe7a12..0000000
--- a/sources_non_forked/ale/autoload/ale/handlers/scala.vim
+++ /dev/null
@@ -1,37 +0,0 @@
-" Author: Nils Leuzinger - https://github.com/PawkyPenguin
-" Description: Scala linting handlers for scalac-like compilers.
-
-function! ale#handlers#scala#HandleScalacLintFormat(buffer, lines) abort
-    " Matches patterns line the following:
-    "
-    " /var/folders/5q/20rgxx3x1s34g3m14n5bq0x80000gn/T/vv6pSsy/0:26: error: expected class or object definition
-    let l:pattern = '^.\+:\(\d\+\): \(\w\+\): \(.\+\)'
-    let l:output = []
-    let l:ln = 0
-
-    for l:line in a:lines
-        let l:ln = l:ln + 1
-        let l:match = matchlist(l:line, l:pattern)
-
-        if len(l:match) == 0
-            continue
-        endif
-
-        let l:text = l:match[3]
-        let l:type = l:match[2] is# 'error' ? 'E' : 'W'
-        let l:col = 0
-
-        if l:ln + 1 < len(a:lines)
-            let l:col = stridx(a:lines[l:ln + 1], '^')
-        endif
-
-        call add(l:output, {
-        \   'lnum': l:match[1] + 0,
-        \   'col': l:col + 1,
-        \   'text': l:text,
-        \   'type': l:type,
-        \})
-    endfor
-
-    return l:output
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/handlers/sh.vim b/sources_non_forked/ale/autoload/ale/handlers/sh.vim
deleted file mode 100644
index 75eaf71..0000000
--- a/sources_non_forked/ale/autoload/ale/handlers/sh.vim
+++ /dev/null
@@ -1,20 +0,0 @@
-" Author: w0rp <devw0rp@gmail.com>
-
-" Get the shell type for a buffer, based on the hashbang line.
-function! ale#handlers#sh#GetShellType(buffer) abort
-    let l:bang_line = get(getbufline(a:buffer, 1), 0, '')
-
-    " Take the shell executable from the hashbang, if we can.
-    if l:bang_line[:1] is# '#!'
-        " Remove options like -e, etc.
-        let l:command = substitute(l:bang_line, ' --\?[a-zA-Z0-9]\+', '', 'g')
-
-        for l:possible_shell in ['bash', 'dash', 'ash', 'tcsh', 'csh', 'zsh', 'ksh', 'sh']
-            if l:command =~# l:possible_shell . '\s*$'
-                return l:possible_shell
-            endif
-        endfor
-    endif
-
-    return ''
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/handlers/shellcheck.vim b/sources_non_forked/ale/autoload/ale/handlers/shellcheck.vim
deleted file mode 100644
index b16280f..0000000
--- a/sources_non_forked/ale/autoload/ale/handlers/shellcheck.vim
+++ /dev/null
@@ -1,107 +0,0 @@
-" Author: w0rp <devw0rp@gmail.com>
-" Description: This file adds support for using the shellcheck linter
-
-function! ale#handlers#shellcheck#GetDialectArgument(buffer) abort
-    let l:shell_type = ale#handlers#sh#GetShellType(a:buffer)
-
-    if !empty(l:shell_type)
-        " Use the dash dialect for /bin/ash, etc.
-        if l:shell_type is# 'ash'
-            return 'dash'
-        endif
-
-        return l:shell_type
-    endif
-
-    " If there's no hashbang, try using Vim's buffer variables.
-    if getbufvar(a:buffer, 'is_bash', 0)
-        return 'bash'
-    elseif getbufvar(a:buffer, 'is_sh', 0)
-        return 'sh'
-    elseif getbufvar(a:buffer, 'is_kornshell', 0)
-        return 'ksh'
-    endif
-
-    return ''
-endfunction
-
-function! ale#handlers#shellcheck#GetCommand(buffer, version) abort
-    let l:options = ale#Var(a:buffer, 'sh_shellcheck_options')
-    let l:exclude_option = ale#Var(a:buffer, 'sh_shellcheck_exclusions')
-    let l:dialect = ale#Var(a:buffer, 'sh_shellcheck_dialect')
-    let l:external_option = ale#semver#GTE(a:version, [0, 4, 0]) ? ' -x' : ''
-    let l:cd_string = ale#Var(a:buffer, 'sh_shellcheck_change_directory')
-    \   ? ale#path#BufferCdString(a:buffer)
-    \   : ''
-
-    if l:dialect is# 'auto'
-        let l:dialect = ale#handlers#shellcheck#GetDialectArgument(a:buffer)
-    endif
-
-    return l:cd_string
-    \   . '%e'
-    \   . (!empty(l:dialect) ? ' -s ' . l:dialect : '')
-    \   . (!empty(l:options) ? ' ' . l:options : '')
-    \   . (!empty(l:exclude_option) ? ' -e ' . l:exclude_option : '')
-    \   . l:external_option
-    \   . ' -f gcc -'
-endfunction
-
-function! ale#handlers#shellcheck#Handle(buffer, lines) abort
-    let l:pattern = '\v^([a-zA-Z]?:?[^:]+):(\d+):(\d+)?:? ([^:]+): (.+) \[([^\]]+)\]$'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        if l:match[4] is# 'error'
-            let l:type = 'E'
-        elseif l:match[4] is# 'note'
-            let l:type = 'I'
-        else
-            let l:type = 'W'
-        endif
-
-        let l:item = {
-        \   'lnum': str2nr(l:match[2]),
-        \   'type': l:type,
-        \   'text': l:match[5],
-        \   'code': l:match[6],
-        \}
-
-        if !empty(l:match[3])
-            let l:item.col = str2nr(l:match[3])
-        endif
-
-        " If the filename is something like <stdin>, <nofile> or -, then
-        " this is an error for the file we checked.
-        if l:match[1] isnot# '-' && l:match[1][0] isnot# '<'
-            let l:item['filename'] = l:match[1]
-        endif
-
-        call add(l:output, l:item)
-    endfor
-
-    return l:output
-endfunction
-
-function! ale#handlers#shellcheck#DefineLinter(filetype) abort
-    " This global variable can be set with a string of comma-separated error
-    " codes to exclude from shellcheck. For example:
-    " let g:ale_sh_shellcheck_exclusions = 'SC2002,SC2004'
-    call ale#Set('sh_shellcheck_exclusions', get(g:, 'ale_linters_sh_shellcheck_exclusions', ''))
-    call ale#Set('sh_shellcheck_executable', 'shellcheck')
-    call ale#Set('sh_shellcheck_dialect', 'auto')
-    call ale#Set('sh_shellcheck_options', '')
-    call ale#Set('sh_shellcheck_change_directory', 1)
-
-    call ale#linter#Define(a:filetype, {
-    \   'name': 'shellcheck',
-    \   'executable': {buffer -> ale#Var(buffer, 'sh_shellcheck_executable')},
-    \   'command': {buffer -> ale#semver#RunWithVersionCheck(
-    \       buffer,
-    \       ale#Var(buffer, 'sh_shellcheck_executable'),
-    \       '%e --version',
-    \       function('ale#handlers#shellcheck#GetCommand'),
-    \   )},
-    \   'callback': 'ale#handlers#shellcheck#Handle',
-    \})
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/handlers/sml.vim b/sources_non_forked/ale/autoload/ale/handlers/sml.vim
deleted file mode 100644
index 594ee4f..0000000
--- a/sources_non_forked/ale/autoload/ale/handlers/sml.vim
+++ /dev/null
@@ -1,93 +0,0 @@
-" Author: Jake Zimmerman <jake@zimmerman.io>
-" Description: Shared functions for SML linters
-
-" The glob to use for finding the .cm file.
-"
-" See :help ale-sml-smlnj for more information.
-call ale#Set('sml_smlnj_cm_file', '*.cm')
-
-function! ale#handlers#sml#GetCmFile(buffer) abort
-    let l:pattern = ale#Var(a:buffer, 'sml_smlnj_cm_file')
-    let l:as_list = 1
-
-    let l:cmfile = ''
-
-    for l:path in ale#path#Upwards(expand('#' . a:buffer . ':p:h'))
-        let l:results = glob(l:path . '/' . l:pattern, 0, l:as_list)
-
-        if len(l:results) > 0
-            " If there is more than one CM file, we take the first one
-            " See :help ale-sml-smlnj for how to configure this.
-            let l:cmfile = l:results[0]
-        endif
-    endfor
-
-    return l:cmfile
-endfunction
-
-" Only one of smlnj or smlnj-cm can be enabled at a time.
-function! s:GetExecutable(buffer, source) abort
-    if ale#handlers#sml#GetCmFile(a:buffer) is# ''
-        " No CM file found; only allow single-file mode to be enabled
-        if a:source is# 'smlnj-file'
-            return 'sml'
-        elseif a:source is# 'smlnj-cm'
-            return ''
-        endif
-    else
-        " Found a CM file; only allow cm-file mode to be enabled
-        if a:source is# 'smlnj-file'
-            return ''
-        elseif a:source is# 'smlnj-cm'
-            return 'sml'
-        endif
-    endif
-endfunction
-
-function! ale#handlers#sml#GetExecutableSmlnjCm(buffer) abort
-    return s:GetExecutable(a:buffer, 'smlnj-cm')
-endfunction
-
-function! ale#handlers#sml#GetExecutableSmlnjFile(buffer) abort
-    return s:GetExecutable(a:buffer, 'smlnj-file')
-endfunction
-
-function! ale#handlers#sml#Handle(buffer, lines) abort
-    " Try to match basic sml errors
-    " TODO(jez) We can get better errorfmt strings from Syntastic
-    let l:out = []
-    let l:pattern = '^.*\:\([0-9\.]\+\)\ \(\w\+\)\:\ \(.*\)'
-    let l:pattern2 = '^.*\:\([0-9]\+\)\.\?\([0-9]\+\).* \(\(Warning\|Error\): .*\)'
-
-    for l:line in a:lines
-        let l:match2 = matchlist(l:line, l:pattern2)
-
-        if len(l:match2) != 0
-            call add(l:out, {
-            \   'bufnr': a:buffer,
-            \   'lnum': l:match2[1] + 0,
-            \   'col' : l:match2[2] - 1,
-            \   'text': l:match2[3],
-            \   'type': l:match2[3] =~# '^Warning' ? 'W' : 'E',
-            \})
-
-            continue
-        endif
-
-        let l:match = matchlist(l:line, l:pattern)
-
-        if len(l:match) != 0
-            call add(l:out, {
-            \   'bufnr': a:buffer,
-            \   'lnum': l:match[1] + 0,
-            \   'text': l:match[2] . ': ' . l:match[3],
-            \   'type': l:match[2] is# 'error' ? 'E' : 'W',
-            \})
-            continue
-        endif
-    endfor
-
-    return l:out
-endfunction
-
-" vim:ts=4:sts=4:sw=4
diff --git a/sources_non_forked/ale/autoload/ale/handlers/textlint.vim b/sources_non_forked/ale/autoload/ale/handlers/textlint.vim
deleted file mode 100644
index 6d495b0..0000000
--- a/sources_non_forked/ale/autoload/ale/handlers/textlint.vim
+++ /dev/null
@@ -1,39 +0,0 @@
-" Author: tokida https://rouger.info, Yasuhiro Kiyota <yasuhiroki.duck@gmail.com>
-" Description: textlint, a proofreading tool (https://textlint.github.io/)
-
-call ale#Set('textlint_executable', 'textlint')
-call ale#Set('textlint_use_global', get(g:, 'ale_use_global_executables', 0))
-call ale#Set('textlint_options', '')
-
-function! ale#handlers#textlint#GetExecutable(buffer) abort
-    return ale#node#FindExecutable(a:buffer, 'textlint', [
-    \   'node_modules/.bin/textlint',
-    \   'node_modules/textlint/bin/textlint.js',
-    \])
-endfunction
-
-function! ale#handlers#textlint#GetCommand(buffer) abort
-    let l:executable = ale#handlers#textlint#GetExecutable(a:buffer)
-    let l:options = ale#Var(a:buffer, 'textlint_options')
-
-    return ale#node#Executable(a:buffer, l:executable)
-    \    . (!empty(l:options) ? ' ' . l:options : '')
-    \    . ' -f json --stdin --stdin-filename %s'
-endfunction
-
-function! ale#handlers#textlint#HandleTextlintOutput(buffer, lines) abort
-    let l:res = get(ale#util#FuzzyJSONDecode(a:lines, []), 0, {'messages': []})
-    let l:output = []
-
-    for l:err in l:res.messages
-        call add(l:output, {
-        \   'text': l:err.message,
-        \   'type': 'W',
-        \   'code': l:err.ruleId,
-        \   'lnum': l:err.line,
-        \   'col' : l:err.column
-        \})
-    endfor
-
-    return l:output
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/handlers/tslint.vim b/sources_non_forked/ale/autoload/ale/handlers/tslint.vim
deleted file mode 100644
index 9057934..0000000
--- a/sources_non_forked/ale/autoload/ale/handlers/tslint.vim
+++ /dev/null
@@ -1,13 +0,0 @@
-function! ale#handlers#tslint#InitVariables() abort
-    call ale#Set('typescript_tslint_executable', 'tslint')
-    call ale#Set('typescript_tslint_config_path', '')
-    call ale#Set('typescript_tslint_rules_dir', '')
-    call ale#Set('typescript_tslint_use_global', get(g:, 'ale_use_global_executables', 0))
-    call ale#Set('typescript_tslint_ignore_empty_files', 0)
-endfunction
-
-function! ale#handlers#tslint#GetExecutable(buffer) abort
-    return ale#node#FindExecutable(a:buffer, 'typescript_tslint', [
-    \   'node_modules/.bin/tslint',
-    \])
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/handlers/tsserver.vim b/sources_non_forked/ale/autoload/ale/handlers/tsserver.vim
deleted file mode 100644
index f78499a..0000000
--- a/sources_non_forked/ale/autoload/ale/handlers/tsserver.vim
+++ /dev/null
@@ -1,8 +0,0 @@
-" Author: Derek Sifford <dereksifford@gmail.com>
-" Description: Handlers for tsserver
-
-function! ale#handlers#tsserver#GetProjectRoot(buffer) abort
-    let l:tsconfig_file = ale#path#FindNearestFile(a:buffer, 'tsconfig.json')
-
-    return !empty(l:tsconfig_file) ? fnamemodify(l:tsconfig_file, ':h') : ''
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/handlers/unix.vim b/sources_non_forked/ale/autoload/ale/handlers/unix.vim
deleted file mode 100644
index f90fd59..0000000
--- a/sources_non_forked/ale/autoload/ale/handlers/unix.vim
+++ /dev/null
@@ -1,26 +0,0 @@
-" Author: w0rp <devw0rp@gmail.com>
-" Description: Error handling for errors in a Unix format.
-
-function! s:HandleUnixFormat(buffer, lines, type) abort
-    let l:pattern = '\v^[a-zA-Z]?:?[^:]+:(\d+):?(\d+)?:? ?(.+)$'
-    let l:output = []
-
-    for l:match in ale#util#GetMatches(a:lines, l:pattern)
-        call add(l:output, {
-        \   'lnum': l:match[1] + 0,
-        \   'col': l:match[2] + 0,
-        \   'text': l:match[3],
-        \   'type': a:type,
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-function! ale#handlers#unix#HandleAsError(buffer, lines) abort
-    return s:HandleUnixFormat(a:buffer, a:lines, 'E')
-endfunction
-
-function! ale#handlers#unix#HandleAsWarning(buffer, lines) abort
-    return s:HandleUnixFormat(a:buffer, a:lines, 'W')
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/handlers/vale.vim b/sources_non_forked/ale/autoload/ale/handlers/vale.vim
deleted file mode 100644
index 2da72fc..0000000
--- a/sources_non_forked/ale/autoload/ale/handlers/vale.vim
+++ /dev/null
@@ -1,39 +0,0 @@
-" Author: Johannes Wienke <languitar@semipol.de>
-" Description: output handler for the vale JSON format
-
-function! ale#handlers#vale#GetType(severity) abort
-    if a:severity is? 'warning'
-        return 'W'
-    elseif a:severity is? 'suggestion'
-        return 'I'
-    endif
-
-    return 'E'
-endfunction
-
-function! ale#handlers#vale#Handle(buffer, lines) abort
-    try
-        let l:errors = json_decode(join(a:lines, ''))
-    catch
-        return []
-    endtry
-
-    if empty(l:errors)
-        return []
-    endif
-
-    let l:output = []
-
-    for l:error in l:errors[keys(l:errors)[0]]
-        call add(l:output, {
-        \   'lnum': l:error['Line'],
-        \   'col': l:error['Span'][0],
-        \   'end_col': l:error['Span'][1],
-        \   'code': l:error['Check'],
-        \   'text': l:error['Message'],
-        \   'type': ale#handlers#vale#GetType(l:error['Severity']),
-        \})
-    endfor
-
-    return l:output
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/handlers/writegood.vim b/sources_non_forked/ale/autoload/ale/handlers/writegood.vim
deleted file mode 100644
index 8ae61a3..0000000
--- a/sources_non_forked/ale/autoload/ale/handlers/writegood.vim
+++ /dev/null
@@ -1,72 +0,0 @@
-" Author: Sumner Evans <sumner.evans98@gmail.com>
-" Description: Error handling for errors in the write-good format.
-
-function! ale#handlers#writegood#ResetOptions() abort
-    call ale#Set('writegood_options', '')
-    call ale#Set('writegood_executable', 'write-good')
-    call ale#Set('writegood_use_global', get(g:, 'ale_use_global_executables', 0))
-endfunction
-
-" Reset the options so the tests can test how they are set.
-call ale#handlers#writegood#ResetOptions()
-
-function! ale#handlers#writegood#GetExecutable(buffer) abort
-    return ale#node#FindExecutable(a:buffer, 'writegood', [
-    \   'node_modules/.bin/write-good',
-    \   'node_modules/write-good/bin/write-good.js',
-    \])
-endfunction
-
-function! ale#handlers#writegood#GetCommand(buffer) abort
-    let l:executable = ale#handlers#writegood#GetExecutable(a:buffer)
-    let l:options = ale#Var(a:buffer, 'writegood_options')
-
-    return ale#node#Executable(a:buffer, l:executable)
-    \   . (!empty(l:options) ? ' ' . l:options : '')
-    \   . ' %t'
-endfunction
-
-function! ale#handlers#writegood#Handle(buffer, lines) abort
-    " Look for lines like the following.
-    "
-    " "it is" is wordy or unneeded on line 20 at column 53
-    " "easily" can weaken meaning on line 154 at column 29
-    let l:marks_pattern = '\v^ *(\^+) *$'
-    let l:pattern = '\v^(".*"\s.*)\son\sline\s(\d+)\sat\scolumn\s(\d+)$'
-    let l:output = []
-    let l:last_len = 0
-
-    for l:match in ale#util#GetMatches(a:lines, [l:marks_pattern, l:pattern])
-        if empty(l:match[2])
-            let l:last_len = len(l:match[1])
-        else
-            let l:col = l:match[3] + 1
-
-            " Add the linter error. Note that we need to add 1 to the col because
-            " write-good reports the column corresponding to the space before the
-            " offending word or phrase.
-            call add(l:output, {
-            \   'text': l:match[1],
-            \   'lnum': l:match[2] + 0,
-            \   'col': l:col,
-            \   'end_col': l:last_len ? (l:col + l:last_len - 1) : l:col,
-            \   'type': 'W',
-            \})
-
-            let l:last_len = 0
-        endif
-    endfor
-
-    return l:output
-endfunction
-
-" Define the writegood linter for a given filetype.
-function! ale#handlers#writegood#DefineLinter(filetype) abort
-    call ale#linter#Define(a:filetype, {
-    \   'name': 'writegood',
-    \   'aliases': ['write-good'],
-    \   'executable': function('ale#handlers#writegood#GetExecutable'),
-    \   'command': function('ale#handlers#writegood#GetCommand'),
-    \   'callback': 'ale#handlers#writegood#Handle',
-    \})
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/highlight.vim b/sources_non_forked/ale/autoload/ale/highlight.vim
deleted file mode 100644
index 473ad35..0000000
--- a/sources_non_forked/ale/autoload/ale/highlight.vim
+++ /dev/null
@@ -1,222 +0,0 @@
-scriptencoding utf8
-" Author: w0rp <devw0rp@gmail.com>
-" Description: This module implements error/warning highlighting.
-
-if !hlexists('ALEError')
-    highlight link ALEError SpellBad
-endif
-
-if !hlexists('ALEStyleError')
-    highlight link ALEStyleError ALEError
-endif
-
-if !hlexists('ALEWarning')
-    highlight link ALEWarning SpellCap
-endif
-
-if !hlexists('ALEStyleWarning')
-    highlight link ALEStyleWarning ALEWarning
-endif
-
-if !hlexists('ALEInfo')
-    highlight link ALEInfo ALEWarning
-endif
-
-" The maximum number of items for the second argument of matchaddpos()
-let s:MAX_POS_VALUES = 8
-let s:MAX_COL_SIZE = 1073741824 " pow(2, 30)
-
-let s:has_nvim_highlight = exists('*nvim_buf_add_highlight') && exists('*nvim_buf_clear_namespace')
-
-if s:has_nvim_highlight
-    let s:ns_id = nvim_create_namespace('ale_highlight')
-endif
-
-" Wrappers are necessary to test this functionality by faking the calls in tests.
-function! ale#highlight#nvim_buf_add_highlight(buffer, ns_id, hl_group, line, col_start, col_end) abort
-    " Ignore all errors for adding highlights.
-    try
-        call nvim_buf_add_highlight(a:buffer, a:ns_id, a:hl_group, a:line, a:col_start, a:col_end)
-    catch
-    endtry
-endfunction
-
-function! ale#highlight#nvim_buf_clear_namespace(buffer, ns_id, line_start, line_end) abort
-    call nvim_buf_clear_namespace(a:buffer, a:ns_id, a:line_start, a:line_end)
-endfunction
-
-function! ale#highlight#CreatePositions(line, col, end_line, end_col) abort
-    if a:line >= a:end_line
-        " For single lines, just return the one position.
-        return [[[a:line, a:col, a:end_col - a:col + 1]]]
-    endif
-
-    " Get positions from the first line at the first column, up to a large
-    " integer for highlighting up to the end of the line, followed by
-    " the lines in-between, for highlighting entire lines, and
-    " a highlight for the last line, up to the end column.
-    let l:all_positions =
-    \   [[a:line, a:col, s:MAX_COL_SIZE]]
-    \   + range(a:line + 1, a:end_line - 1)
-    \   + [[a:end_line, 1, a:end_col]]
-
-    return map(
-    \   range(0, len(l:all_positions) - 1, s:MAX_POS_VALUES),
-    \   'l:all_positions[v:val : v:val + s:MAX_POS_VALUES - 1]',
-    \)
-endfunction
-
-" Given a loclist for current items to highlight, remove all highlights
-" except these which have matching loclist item entries.
-
-function! ale#highlight#RemoveHighlights() abort
-    if s:has_nvim_highlight
-        call ale#highlight#nvim_buf_clear_namespace(bufnr(''), s:ns_id, 0, -1)
-    else
-        for l:match in getmatches()
-            if l:match.group =~? '\v^ALE(Style)?(Error|Warning|Info)(Line)?$'
-                call matchdelete(l:match.id)
-            endif
-        endfor
-    endif
-endfunction
-
-" Same semantics of matchaddpos but will use nvim_buf_add_highlight if
-" available. This involves iterating over the position list, switching from
-" 1-based indexing to 0-based indexing, and translating the multiple ways
-" that position can be specified for matchaddpos into line + col_start +
-" col_end.
-function! s:matchaddpos(group, pos_list) abort
-    if s:has_nvim_highlight
-        for l:pos in a:pos_list
-            let l:line = type(l:pos) == v:t_number
-            \   ? l:pos - 1
-            \   : l:pos[0] - 1
-
-            if type(l:pos) == v:t_number || len(l:pos) == 1
-                let l:col_start = 0
-                let l:col_end = s:MAX_COL_SIZE
-            else
-                let l:col_start = l:pos[1] - 1
-                let l:col_end = l:col_start + get(l:pos, 2, 1)
-            endif
-
-            call ale#highlight#nvim_buf_add_highlight(
-            \   bufnr(''),
-            \   s:ns_id,
-            \   a:group,
-            \   l:line,
-            \   l:col_start,
-            \   l:col_end,
-            \)
-        endfor
-    else
-        call matchaddpos(a:group, a:pos_list)
-    endif
-endfunction
-
-function! s:highlight_line(bufnr, lnum, group) abort
-    call s:matchaddpos(a:group, [a:lnum])
-endfunction
-
-function! s:highlight_range(bufnr, range, group) abort
-    " Set all of the positions, which are chunked into Lists which
-    " are as large as will be accepted by matchaddpos.
-    call map(
-    \   ale#highlight#CreatePositions(
-    \       a:range.lnum,
-    \       a:range.col,
-    \       a:range.end_lnum,
-    \       a:range.end_col
-    \   ),
-    \   's:matchaddpos(a:group, v:val)'
-    \)
-endfunction
-
-function! ale#highlight#UpdateHighlights() abort
-    let l:item_list = get(b:, 'ale_enabled', 1) && g:ale_enabled
-    \   ? get(b:, 'ale_highlight_items', [])
-    \   : []
-
-    call ale#highlight#RemoveHighlights()
-
-    for l:item in l:item_list
-        if l:item.type is# 'W'
-            if get(l:item, 'sub_type', '') is# 'style'
-                let l:group = 'ALEStyleWarning'
-            else
-                let l:group = 'ALEWarning'
-            endif
-        elseif l:item.type is# 'I'
-            let l:group = 'ALEInfo'
-        elseif get(l:item, 'sub_type', '') is# 'style'
-            let l:group = 'ALEStyleError'
-        else
-            let l:group = 'ALEError'
-        endif
-
-        let l:range = {
-        \   'lnum': l:item.lnum,
-        \   'col': l:item.col,
-        \   'end_lnum': get(l:item, 'end_lnum', l:item.lnum),
-        \   'end_col': get(l:item, 'end_col', l:item.col)
-        \}
-
-        call s:highlight_range(l:item.bufnr, l:range, l:group)
-    endfor
-
-    " If highlights are enabled and signs are not enabled, we should still
-    " offer line highlights by adding a separate set of highlights.
-    if !g:ale_set_signs
-        let l:available_groups = {
-        \   'ALEWarningLine': hlexists('ALEWarningLine'),
-        \   'ALEInfoLine': hlexists('ALEInfoLine'),
-        \   'ALEErrorLine': hlexists('ALEErrorLine'),
-        \}
-
-        for l:item in l:item_list
-            if l:item.type is# 'W'
-                let l:group = 'ALEWarningLine'
-            elseif l:item.type is# 'I'
-                let l:group = 'ALEInfoLine'
-            else
-                let l:group = 'ALEErrorLine'
-            endif
-
-            if l:available_groups[l:group]
-                call s:highlight_line(l:item.bufnr, l:item.lnum, l:group)
-            endif
-        endfor
-    endif
-endfunction
-
-function! ale#highlight#BufferHidden(buffer) abort
-    " Remove highlights right away when buffers are hidden.
-    " They will be restored later when buffers are entered.
-    call ale#highlight#RemoveHighlights()
-endfunction
-
-augroup ALEHighlightBufferGroup
-    autocmd!
-    autocmd BufEnter * call ale#highlight#UpdateHighlights()
-    autocmd BufHidden * call ale#highlight#BufferHidden(expand('<abuf>'))
-augroup END
-
-function! ale#highlight#SetHighlights(buffer, loclist) abort
-    let l:new_list = getbufvar(a:buffer, 'ale_enabled', 1) && g:ale_enabled
-    \   ? filter(copy(a:loclist), 'v:val.bufnr == a:buffer && v:val.col > 0')
-    \   : []
-
-    " Set the list in the buffer variable.
-    call setbufvar(str2nr(a:buffer), 'ale_highlight_items', l:new_list)
-
-    let l:exclude_list = ale#Var(a:buffer, 'exclude_highlights')
-
-    if !empty(l:exclude_list)
-        call filter(l:new_list, 'empty(ale#util#GetMatches(v:val.text, l:exclude_list))')
-    endif
-
-    " Update highlights for the current buffer, which may or may not
-    " be the buffer we just set highlights for.
-    call ale#highlight#UpdateHighlights()
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/history.vim b/sources_non_forked/ale/autoload/ale/history.vim
deleted file mode 100644
index 27ae74c..0000000
--- a/sources_non_forked/ale/autoload/ale/history.vim
+++ /dev/null
@@ -1,62 +0,0 @@
-" Author: w0rp <devw0rp@gmail.com>
-" Description: Tools for managing command history
-
-" A flag for controlling the maximum size of the command history to store.
-let g:ale_max_buffer_history_size = get(g:, 'ale_max_buffer_history_size', 20)
-
-" Return a shallow copy of the command history for a given buffer number.
-function! ale#history#Get(buffer) abort
-    return copy(getbufvar(a:buffer, 'ale_history', []))
-endfunction
-
-function! ale#history#Add(buffer, status, job_id, command) abort
-    if g:ale_max_buffer_history_size <= 0
-        " Don't save anything if the history isn't a positive number.
-        call setbufvar(a:buffer, 'ale_history', [])
-
-        return
-    endif
-
-    let l:history = getbufvar(a:buffer, 'ale_history', [])
-
-    " Remove the first item if we hit the max history size.
-    if len(l:history) >= g:ale_max_buffer_history_size
-        let l:history = l:history[1:]
-    endif
-
-    call add(l:history, {
-    \   'status': a:status,
-    \   'job_id': a:job_id,
-    \   'command': a:command,
-    \})
-
-    call setbufvar(a:buffer, 'ale_history', l:history)
-endfunction
-
-function! s:FindHistoryItem(buffer, job_id) abort
-    " Search backwards to find a matching job ID. IDs might be recycled,
-    " so finding the last one should be good enough.
-    for l:obj in reverse(ale#history#Get(a:buffer))
-        if l:obj.job_id == a:job_id
-            return l:obj
-        endif
-    endfor
-
-    return {}
-endfunction
-
-" Set an exit code for a command which finished.
-function! ale#history#SetExitCode(buffer, job_id, exit_code) abort
-    let l:obj = s:FindHistoryItem(a:buffer, a:job_id)
-
-    " If we find a match, then set the code and status.
-    let l:obj.exit_code = a:exit_code
-    let l:obj.status = 'finished'
-endfunction
-
-" Set the output for a command which finished.
-function! ale#history#RememberOutput(buffer, job_id, output) abort
-    let l:obj = s:FindHistoryItem(a:buffer, a:job_id)
-
-    let l:obj.output = a:output
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/hover.vim b/sources_non_forked/ale/autoload/ale/hover.vim
deleted file mode 100644
index 8fdd288..0000000
--- a/sources_non_forked/ale/autoload/ale/hover.vim
+++ /dev/null
@@ -1,199 +0,0 @@
-" Author: w0rp <devw0rp@gmail.com>
-" Description: Hover support for LSP linters.
-
-let s:hover_map = {}
-
-" Used to get the hover map in tests.
-function! ale#hover#GetMap() abort
-    return deepcopy(s:hover_map)
-endfunction
-
-" Used to set the hover map in tests.
-function! ale#hover#SetMap(map) abort
-    let s:hover_map = a:map
-endfunction
-
-function! ale#hover#ClearLSPData() abort
-    let s:hover_map = {}
-endfunction
-
-function! ale#hover#HandleTSServerResponse(conn_id, response) abort
-    if get(a:response, 'command', '') is# 'quickinfo'
-    \&& has_key(s:hover_map, a:response.request_seq)
-        let l:options = remove(s:hover_map, a:response.request_seq)
-
-        if get(a:response, 'success', v:false) is v:true
-        \&& get(a:response, 'body', v:null) isnot v:null
-            " If we pass the show_documentation flag, we should show the full
-            " documentation, and always in the preview window.
-            if get(l:options, 'show_documentation', 0)
-                let l:documentation = get(a:response.body, 'documentation', '')
-
-                " displayString is not included here, because it can be very
-                " noisy and run on for many lines for complex types. A less
-                " verbose alternative may be nice in future.
-                if !empty(l:documentation)
-                    call ale#preview#Show(split(l:documentation, "\n"), {
-                    \   'filetype': 'ale-preview.message',
-                    \   'stay_here': 1,
-                    \})
-                endif
-            elseif get(l:options, 'hover_from_balloonexpr', 0)
-            \&& exists('*balloon_show')
-            \&& ale#Var(l:options.buffer, 'set_balloons')
-                call balloon_show(a:response.body.displayString)
-            elseif g:ale_hover_to_preview
-                call ale#preview#Show(split(a:response.body.displayString, "\n"), {
-                \   'filetype': 'ale-preview.message',
-                \   'stay_here': 1,
-                \})
-            else
-                call ale#util#ShowMessage(a:response.body.displayString)
-            endif
-        endif
-    endif
-endfunction
-
-function! ale#hover#HandleLSPResponse(conn_id, response) abort
-    if has_key(a:response, 'id')
-    \&& has_key(s:hover_map, a:response.id)
-        let l:options = remove(s:hover_map, a:response.id)
-
-        " If the call did __not__ come from balloonexpr...
-        if !get(l:options, 'hover_from_balloonexpr', 0)
-            let l:buffer = bufnr('')
-            let [l:line, l:column] = getpos('.')[1:2]
-            let l:end = len(getline(l:line))
-
-            if l:buffer isnot l:options.buffer
-            \|| l:line isnot l:options.line
-            \|| min([l:column, l:end]) isnot min([l:options.column, l:end])
-                " ... Cancel display the message if the cursor has moved.
-                return
-            endif
-        endif
-
-        " The result can be a Dictionary item, a List of the same, or null.
-        let l:result = get(a:response, 'result', v:null)
-
-        if l:result is v:null
-            return
-        endif
-
-        let l:result = l:result.contents
-
-        if type(l:result) is v:t_string
-            " The result can be just a string.
-            let l:result = [l:result]
-        endif
-
-        if type(l:result) is v:t_dict
-            " If the result is an object, then it's markup content.
-            let l:result = [l:result.value]
-        endif
-
-        if type(l:result) is v:t_list
-            " Replace objects with text values.
-            call map(l:result, 'type(v:val) is v:t_string ? v:val : v:val.value')
-            let l:str = join(l:result, "\n")
-            let l:str = substitute(l:str, '^\s*\(.\{-}\)\s*$', '\1', '')
-
-            if !empty(l:str)
-                if get(l:options, 'hover_from_balloonexpr', 0)
-                \&& exists('*balloon_show')
-                \&& ale#Var(l:options.buffer, 'set_balloons')
-                    call balloon_show(l:str)
-                elseif g:ale_hover_to_preview
-                    call ale#preview#Show(split(l:str, "\n"), {
-                    \   'filetype': 'ale-preview.message',
-                    \   'stay_here': 1,
-                    \})
-                else
-                    call ale#util#ShowMessage(l:str)
-                endif
-            endif
-        endif
-    endif
-endfunction
-
-function! s:OnReady(line, column, opt, linter, lsp_details) abort
-    let l:id = a:lsp_details.connection_id
-
-    if !ale#lsp#HasCapability(l:id, 'hover')
-        return
-    endif
-
-    let l:buffer = a:lsp_details.buffer
-
-    let l:Callback = a:linter.lsp is# 'tsserver'
-    \   ? function('ale#hover#HandleTSServerResponse')
-    \   : function('ale#hover#HandleLSPResponse')
-    call ale#lsp#RegisterCallback(l:id, l:Callback)
-
-    if a:linter.lsp is# 'tsserver'
-        let l:column = a:column
-
-        let l:message = ale#lsp#tsserver_message#Quickinfo(
-        \   l:buffer,
-        \   a:line,
-        \   l:column
-        \)
-    else
-        " Send a message saying the buffer has changed first, or the
-        " hover position probably won't make sense.
-        call ale#lsp#NotifyForChanges(l:id, l:buffer)
-
-        let l:column = min([a:column, len(getbufline(l:buffer, a:line)[0])])
-
-        let l:message = ale#lsp#message#Hover(l:buffer, a:line, l:column)
-    endif
-
-    let l:request_id = ale#lsp#Send(l:id, l:message)
-
-    let s:hover_map[l:request_id] = {
-    \   'buffer': l:buffer,
-    \   'line': a:line,
-    \   'column': l:column,
-    \   'hover_from_balloonexpr': get(a:opt, 'called_from_balloonexpr', 0),
-    \   'show_documentation': get(a:opt, 'show_documentation', 0),
-    \}
-endfunction
-
-" Obtain Hover information for the specified position
-" Pass optional arguments in the dictionary opt.
-" Currently, only one key/value is useful:
-"   - called_from_balloonexpr, this flag marks if we want the result from this
-"     ale#hover#Show to display in a balloon if possible
-"
-" Currently, the callbacks displays the info from hover :
-" - in the balloon if opt.called_from_balloonexpr and balloon_show is detected
-" - as status message otherwise
-function! ale#hover#Show(buffer, line, col, opt) abort
-    let l:show_documentation = get(a:opt, 'show_documentation', 0)
-    let l:Callback = function('s:OnReady', [a:line, a:col, a:opt])
-
-    for l:linter in ale#linter#Get(getbufvar(a:buffer, '&filetype'))
-        " Only tsserver supports documentation requests at the moment.
-        if !empty(l:linter.lsp)
-        \&& (!l:show_documentation || l:linter.lsp is# 'tsserver')
-            call ale#lsp_linter#StartLSP(a:buffer, l:linter, l:Callback)
-        endif
-    endfor
-endfunction
-
-" This function implements the :ALEHover command.
-function! ale#hover#ShowAtCursor() abort
-    let l:buffer = bufnr('')
-    let l:pos = getpos('.')
-
-    call ale#hover#Show(l:buffer, l:pos[1], l:pos[2], {})
-endfunction
-
-" This function implements the :ALEDocumentation command.
-function! ale#hover#ShowDocumentationAtCursor() abort
-    let l:buffer = bufnr('')
-    let l:pos = getpos('.')
-    let l:options = {'show_documentation': 1}
-
-    call ale#hover#Show(l:buffer, l:pos[1], l:pos[2], l:options)
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/java.vim b/sources_non_forked/ale/autoload/ale/java.vim
deleted file mode 100644
index e641ac6..0000000
--- a/sources_non_forked/ale/autoload/ale/java.vim
+++ /dev/null
@@ -1,26 +0,0 @@
-" Author: Horacio Sanson https://github.com/hsanson
-" Description: Functions for integrating with Java tools
-
-" Find the nearest dir contining a gradle or pom file and asume it
-" the root of a java app.
-function! ale#java#FindProjectRoot(buffer) abort
-    let l:gradle_root = ale#gradle#FindProjectRoot(a:buffer)
-
-    if !empty(l:gradle_root)
-        return l:gradle_root
-    endif
-
-    let l:maven_pom_file = ale#path#FindNearestFile(a:buffer, 'pom.xml')
-
-    if !empty(l:maven_pom_file)
-        return fnamemodify(l:maven_pom_file, ':h')
-    endif
-
-    let l:ant_root = ale#ant#FindProjectRoot(a:buffer)
-
-    if !empty(l:ant_root)
-        return l:ant_root
-    endif
-
-    return ''
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/job.vim b/sources_non_forked/ale/autoload/ale/job.vim
deleted file mode 100644
index 14b3e48..0000000
--- a/sources_non_forked/ale/autoload/ale/job.vim
+++ /dev/null
@@ -1,373 +0,0 @@
-" Author: w0rp <devw0rp@gmail.com>
-" Description: APIs for working with Asynchronous jobs, with an API normalised
-" between Vim 8 and NeoVim.
-"
-" Important functions are described below. They are:
-"
-"   ale#job#Start(command, options) -> job_id
-"   ale#job#IsRunning(job_id) -> 1 if running, 0 otherwise.
-"   ale#job#Stop(job_id)
-
-" A setting for wrapping commands.
-let g:ale_command_wrapper = get(g:, 'ale_command_wrapper', '')
-
-if !has_key(s:, 'job_map')
-    let s:job_map = {}
-endif
-
-" A map from timer IDs to jobs, for tracking jobs that need to be killed
-" with SIGKILL if they don't terminate right away.
-if !has_key(s:, 'job_kill_timers')
-    let s:job_kill_timers = {}
-endif
-
-function! s:KillHandler(timer) abort
-    let l:job = remove(s:job_kill_timers, a:timer)
-    call job_stop(l:job, 'kill')
-endfunction
-
-function! s:NeoVimCallback(job, data, event) abort
-    let l:info = s:job_map[a:job]
-
-    if a:event is# 'stdout'
-        let l:info.out_cb_line = ale#util#JoinNeovimOutput(
-        \   a:job,
-        \   l:info.out_cb_line,
-        \   a:data,
-        \   l:info.mode,
-        \   ale#util#GetFunction(l:info.out_cb),
-        \)
-    elseif a:event is# 'stderr'
-        let l:info.err_cb_line = ale#util#JoinNeovimOutput(
-        \   a:job,
-        \   l:info.err_cb_line,
-        \   a:data,
-        \   l:info.mode,
-        \   ale#util#GetFunction(l:info.err_cb),
-        \)
-    else
-        if has_key(l:info, 'out_cb') && !empty(l:info.out_cb_line)
-            call ale#util#GetFunction(l:info.out_cb)(a:job, l:info.out_cb_line)
-        endif
-
-        if has_key(l:info, 'err_cb') && !empty(l:info.err_cb_line)
-            call ale#util#GetFunction(l:info.err_cb)(a:job, l:info.err_cb_line)
-        endif
-
-        try
-            call ale#util#GetFunction(l:info.exit_cb)(a:job, a:data)
-        finally
-            " Automatically forget about the job after it's done.
-            if has_key(s:job_map, a:job)
-                call remove(s:job_map, a:job)
-            endif
-        endtry
-    endif
-endfunction
-
-function! s:VimOutputCallback(channel, data) abort
-    let l:job = ch_getjob(a:channel)
-    let l:job_id = ale#job#ParseVim8ProcessID(string(l:job))
-
-    " Only call the callbacks for jobs which are valid.
-    if l:job_id > 0 && has_key(s:job_map, l:job_id)
-        call ale#util#GetFunction(s:job_map[l:job_id].out_cb)(l:job_id, a:data)
-    endif
-endfunction
-
-function! s:VimErrorCallback(channel, data) abort
-    let l:job = ch_getjob(a:channel)
-    let l:job_id = ale#job#ParseVim8ProcessID(string(l:job))
-
-    " Only call the callbacks for jobs which are valid.
-    if l:job_id > 0 && has_key(s:job_map, l:job_id)
-        call ale#util#GetFunction(s:job_map[l:job_id].err_cb)(l:job_id, a:data)
-    endif
-endfunction
-
-function! s:VimCloseCallback(channel) abort
-    let l:job = ch_getjob(a:channel)
-    let l:job_id = ale#job#ParseVim8ProcessID(string(l:job))
-    let l:info = get(s:job_map, l:job_id, {})
-
-    if empty(l:info)
-        return
-    endif
-
-    " job_status() can trigger the exit handler.
-    " The channel can close before the job has exited.
-    if job_status(l:job) is# 'dead'
-        try
-            if !empty(l:info) && has_key(l:info, 'exit_cb')
-                " We have to remove the callback, so we don't call it twice.
-                call ale#util#GetFunction(remove(l:info, 'exit_cb'))(l:job_id, get(l:info, 'exit_code', 1))
-            endif
-        finally
-            " Automatically forget about the job after it's done.
-            if has_key(s:job_map, l:job_id)
-                call remove(s:job_map, l:job_id)
-            endif
-        endtry
-    endif
-endfunction
-
-function! s:VimExitCallback(job, exit_code) abort
-    let l:job_id = ale#job#ParseVim8ProcessID(string(a:job))
-    let l:info = get(s:job_map, l:job_id, {})
-
-    if empty(l:info)
-        return
-    endif
-
-    let l:info.exit_code = a:exit_code
-
-    " The program can exit before the data has finished being read.
-    if ch_status(job_getchannel(a:job)) is# 'closed'
-        try
-            if !empty(l:info) && has_key(l:info, 'exit_cb')
-                " We have to remove the callback, so we don't call it twice.
-                call ale#util#GetFunction(remove(l:info, 'exit_cb'))(l:job_id, a:exit_code)
-            endif
-        finally
-            " Automatically forget about the job after it's done.
-            if has_key(s:job_map, l:job_id)
-                call remove(s:job_map, l:job_id)
-            endif
-        endtry
-    endif
-endfunction
-
-function! ale#job#ParseVim8ProcessID(job_string) abort
-    return matchstr(a:job_string, '\d\+') + 0
-endfunction
-
-function! ale#job#ValidateArguments(command, options) abort
-    if a:options.mode isnot# 'nl' && a:options.mode isnot# 'raw'
-        throw 'Invalid mode: ' . a:options.mode
-    endif
-endfunction
-
-function! s:PrepareWrappedCommand(original_wrapper, command) abort
-    let l:match = matchlist(a:command, '\v^(.*(\&\&|;)) *(.*)$')
-    let l:prefix = ''
-    let l:command = a:command
-
-    if !empty(l:match)
-        let l:prefix = l:match[1] . ' '
-        let l:command = l:match[3]
-    endif
-
-    let l:format = a:original_wrapper
-
-    if l:format =~# '%@'
-        let l:wrapped = substitute(l:format, '%@', ale#Escape(l:command), '')
-    else
-        if l:format !~# '%\*'
-            let l:format .= ' %*'
-        endif
-
-        let l:wrapped = substitute(l:format, '%\*', l:command, '')
-    endif
-
-    return l:prefix . l:wrapped
-endfunction
-
-function! ale#job#PrepareCommand(buffer, command) abort
-    let l:wrapper = ale#Var(a:buffer, 'command_wrapper')
-
-    " The command will be executed in a subshell. This fixes a number of
-    " issues, including reading the PATH variables correctly, %PATHEXT%
-    " expansion on Windows, etc.
-    "
-    " NeoVim handles this issue automatically if the command is a String,
-    " but we'll do this explicitly, so we use the same exact command for both
-    " versions.
-    let l:command = !empty(l:wrapper)
-    \ ? s:PrepareWrappedCommand(l:wrapper, a:command)
-    \ : a:command
-
-    " If a custom shell is specified, use that.
-    if exists('g:ale_shell')
-        let l:shell_arguments = get(g:, 'ale_shell_arguments', &shellcmdflag)
-
-        return split(g:ale_shell) + split(l:shell_arguments) + [l:command]
-    endif
-
-    if has('win32')
-        return 'cmd /s/c "' . l:command . '"'
-    endif
-
-    if &shell =~? 'fish$\|pwsh$'
-        return ['/bin/sh', '-c', l:command]
-    endif
-
-    return split(&shell) + split(&shellcmdflag) + [l:command]
-endfunction
-
-" Start a job with options which are agnostic to Vim and NeoVim.
-"
-" The following options are accepted:
-"
-" out_cb  - A callback for receiving stdin.  Arguments: (job_id, data)
-" err_cb  - A callback for receiving stderr. Arguments: (job_id, data)
-" exit_cb - A callback for program exit.     Arguments: (job_id, status_code)
-" mode    - A mode for I/O. Can be 'nl' for split lines or 'raw'.
-function! ale#job#Start(command, options) abort
-    call ale#job#ValidateArguments(a:command, a:options)
-
-    let l:job_info = copy(a:options)
-    let l:job_options = {}
-
-    if has('nvim')
-        if has_key(a:options, 'out_cb')
-            let l:job_options.on_stdout = function('s:NeoVimCallback')
-            let l:job_info.out_cb_line = ''
-        endif
-
-        if has_key(a:options, 'err_cb')
-            let l:job_options.on_stderr = function('s:NeoVimCallback')
-            let l:job_info.err_cb_line = ''
-        endif
-
-        if has_key(a:options, 'exit_cb')
-            let l:job_options.on_exit = function('s:NeoVimCallback')
-        endif
-
-        let l:job_info.job = jobstart(a:command, l:job_options)
-        let l:job_id = l:job_info.job
-    else
-        let l:job_options = {
-        \   'in_mode': l:job_info.mode,
-        \   'out_mode': l:job_info.mode,
-        \   'err_mode': l:job_info.mode,
-        \}
-
-        if has_key(a:options, 'out_cb')
-            let l:job_options.out_cb = function('s:VimOutputCallback')
-        endif
-
-        if has_key(a:options, 'err_cb')
-            let l:job_options.err_cb = function('s:VimErrorCallback')
-        endif
-
-        if has_key(a:options, 'exit_cb')
-            " Set a close callback to which simply calls job_status()
-            " when the channel is closed, which can trigger the exit callback
-            " earlier on.
-            let l:job_options.close_cb = function('s:VimCloseCallback')
-            let l:job_options.exit_cb = function('s:VimExitCallback')
-        endif
-
-        " Use non-blocking writes for Vim versions that support the option.
-        if has('patch-8.1.350')
-            let l:job_options.noblock = 1
-        endif
-
-        " Vim 8 will read the stdin from the file's buffer.
-        let l:job_info.job = job_start(a:command, l:job_options)
-        let l:job_id = ale#job#ParseVim8ProcessID(string(l:job_info.job))
-    endif
-
-    if l:job_id > 0
-        " Store the job in the map for later only if we can get the ID.
-        let s:job_map[l:job_id] = l:job_info
-    endif
-
-    return l:job_id
-endfunction
-
-" Force running commands in a Windows CMD command line.
-" This means the same command syntax works everywhere.
-function! ale#job#StartWithCmd(command, options) abort
-    let l:shell = &l:shell
-    let l:shellcmdflag = &l:shellcmdflag
-    let &l:shell = 'cmd'
-    let &l:shellcmdflag = '/c'
-
-    try
-        let l:job_id = ale#job#Start(a:command, a:options)
-    finally
-        let &l:shell = l:shell
-        let &l:shellcmdflag = l:shellcmdflag
-    endtry
-
-    return l:job_id
-endfunction
-
-" Send raw data to the job.
-function! ale#job#SendRaw(job_id, string) abort
-    if has('nvim')
-        call jobsend(a:job_id, a:string)
-    else
-        let l:job = s:job_map[a:job_id].job
-
-        if ch_status(l:job) is# 'open'
-            call ch_sendraw(job_getchannel(l:job), a:string)
-        endif
-    endif
-endfunction
-
-" Given a job ID, return 1 if the job is currently running.
-" Invalid job IDs will be ignored.
-function! ale#job#IsRunning(job_id) abort
-    if has('nvim')
-        try
-            " In NeoVim, if the job isn't running, jobpid() will throw.
-            call jobpid(a:job_id)
-
-            return 1
-        catch
-        endtry
-    elseif has_key(s:job_map, a:job_id)
-        let l:job = s:job_map[a:job_id].job
-
-        return job_status(l:job) is# 'run'
-    endif
-
-    return 0
-endfunction
-
-function! ale#job#HasOpenChannel(job_id) abort
-    if ale#job#IsRunning(a:job_id)
-        if has('nvim')
-            " TODO: Implement a check for NeoVim.
-            return 1
-        endif
-
-        " Check if the Job's channel can be written to.
-        return ch_status(s:job_map[a:job_id].job) is# 'open'
-    endif
-
-    return 0
-endfunction
-
-" Given a Job ID, stop that job.
-" Invalid job IDs will be ignored.
-function! ale#job#Stop(job_id) abort
-    if !has_key(s:job_map, a:job_id)
-        return
-    endif
-
-    if has('nvim')
-        " FIXME: NeoVim kills jobs on a timer, but will not kill any processes
-        " which are child processes on Unix. Some work needs to be done to
-        " kill child processes to stop long-running processes like pylint.
-        silent! call jobstop(a:job_id)
-    else
-        let l:job = s:job_map[a:job_id].job
-
-        " We must close the channel for reading the buffer if it is open
-        " when stopping a job. Otherwise, we will get errors in the status line.
-        if ch_status(job_getchannel(l:job)) is# 'open'
-            call ch_close_in(job_getchannel(l:job))
-        endif
-
-        " Ask nicely for the job to stop.
-        call job_stop(l:job)
-
-        if ale#job#IsRunning(l:job)
-            " Set a 100ms delay for killing the job with SIGKILL.
-            let s:job_kill_timers[timer_start(100, function('s:KillHandler'))] = l:job
-        endif
-    endif
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/julia.vim b/sources_non_forked/ale/autoload/ale/julia.vim
deleted file mode 100644
index 18dd9ad..0000000
--- a/sources_non_forked/ale/autoload/ale/julia.vim
+++ /dev/null
@@ -1,19 +0,0 @@
-" Author: Bartolomeo Stellato bartolomeo.stellato@gmail.com
-" Description: Functions for integrating with Julia tools
-
-" Find the nearest dir containing a julia project
-let s:__ale_julia_project_filenames = ['REQUIRE', 'Manifest.toml', 'Project.toml']
-
-function! ale#julia#FindProjectRoot(buffer) abort
-    for l:project_filename in s:__ale_julia_project_filenames
-        let l:full_path = ale#path#FindNearestFile(a:buffer, l:project_filename)
-
-        if !empty(l:full_path)
-            let l:path = fnamemodify(l:full_path, ':p:h')
-
-            return l:path
-        endif
-    endfor
-
-    return ''
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/linter.vim b/sources_non_forked/ale/autoload/ale/linter.vim
deleted file mode 100644
index a85f06e..0000000
--- a/sources_non_forked/ale/autoload/ale/linter.vim
+++ /dev/null
@@ -1,554 +0,0 @@
-" Author: w0rp <devw0rp@gmail.com>
-" Description: Linter registration and lazy-loading
-"   Retrieves linters as requested by the engine, loading them if needed.
-
-let s:runtime_loaded_map = {}
-let s:linters = {}
-
-" Default filetype aliases.
-" The user defined aliases will be merged with this Dictionary.
-"
-" NOTE: Update the g:ale_linter_aliases documentation when modifying this.
-let s:default_ale_linter_aliases = {
-\   'Dockerfile': 'dockerfile',
-\   'csh': 'sh',
-\   'javascriptreact': ['javascript', 'jsx'],
-\   'plaintex': 'tex',
-\   'rmarkdown': 'r',
-\   'rmd': 'r',
-\   'systemverilog': 'verilog',
-\   'typescriptreact': ['typescript', 'tsx'],
-\   'verilog_systemverilog': ['verilog_systemverilog', 'verilog'],
-\   'vimwiki': 'markdown',
-\   'vue': ['vue', 'javascript'],
-\   'xsd': ['xsd', 'xml'],
-\   'xslt': ['xslt', 'xml'],
-\   'zsh': 'sh',
-\}
-
-" Default linters to run for particular filetypes.
-" The user defined linter selections will be merged with this Dictionary.
-"
-" No linters are used for plaintext files by default.
-"
-" Only cargo is enabled for Rust by default.
-" rpmlint is disabled by default because it can result in code execution.
-" hhast is disabled by default because it executes code in the project root.
-"
-" NOTE: Update the g:ale_linters documentation when modifying this.
-let s:default_ale_linters = {
-\   'csh': ['shell'],
-\   'elixir': ['credo', 'dialyxir', 'dogma'],
-\   'go': ['gofmt', 'golint', 'go vet'],
-\   'hack': ['hack'],
-\   'help': [],
-\   'perl': ['perlcritic'],
-\   'perl6': [],
-\   'python': ['flake8', 'mypy', 'pylint'],
-\   'rust': ['cargo'],
-\   'spec': [],
-\   'text': [],
-\   'vue': ['eslint', 'vls'],
-\   'zsh': ['shell'],
-\}
-
-" Testing/debugging helper to unload all linters.
-function! ale#linter#Reset() abort
-    let s:runtime_loaded_map = {}
-    let s:linters = {}
-endfunction
-
-" Return a reference to the linters loaded.
-" This is only for tests.
-" Do not call this function.
-function! ale#linter#GetLintersLoaded() abort
-    " This command will throw from the sandbox.
-    let &l:equalprg=&l:equalprg
-
-    return s:linters
-endfunction
-
-function! s:IsCallback(value) abort
-    return type(a:value) is v:t_string || type(a:value) is v:t_func
-endfunction
-
-function! s:IsBoolean(value) abort
-    return type(a:value) is v:t_number && (a:value == 0 || a:value == 1)
-endfunction
-
-function! s:LanguageGetter(buffer) dict abort
-    return l:self.language
-endfunction
-
-function! ale#linter#PreProcess(filetype, linter) abort
-    if type(a:linter) isnot v:t_dict
-        throw 'The linter object must be a Dictionary'
-    endif
-
-    let l:obj = {
-    \   'name': get(a:linter, 'name'),
-    \   'lsp': get(a:linter, 'lsp', ''),
-    \}
-
-    if type(l:obj.name) isnot v:t_string
-        throw '`name` must be defined to name the linter'
-    endif
-
-    let l:needs_address = l:obj.lsp is# 'socket'
-    let l:needs_executable = l:obj.lsp isnot# 'socket'
-    let l:needs_command = l:obj.lsp isnot# 'socket'
-    let l:needs_lsp_details = !empty(l:obj.lsp)
-
-    if empty(l:obj.lsp)
-        let l:obj.callback = get(a:linter, 'callback')
-
-        if !s:IsCallback(l:obj.callback)
-            throw '`callback` must be defined with a callback to accept output'
-        endif
-    endif
-
-    if index(['', 'socket', 'stdio', 'tsserver'], l:obj.lsp) < 0
-        throw '`lsp` must be either `''lsp''`, `''stdio''`, `''socket''` or `''tsserver''` if defined'
-    endif
-
-    if !l:needs_executable
-        if has_key(a:linter, 'executable')
-        \|| has_key(a:linter, 'executable_callback')
-            throw '`executable` and `executable_callback` cannot be used when lsp == ''socket'''
-        endif
-    elseif has_key(a:linter, 'executable_callback')
-        let l:obj.executable_callback = a:linter.executable_callback
-
-        if !s:IsCallback(l:obj.executable_callback)
-            throw '`executable_callback` must be a callback if defined'
-        endif
-    elseif has_key(a:linter, 'executable')
-        let l:obj.executable = a:linter.executable
-
-        if type(l:obj.executable) isnot v:t_string
-        \&& type(l:obj.executable) isnot v:t_func
-            throw '`executable` must be a String or Function if defined'
-        endif
-    else
-        throw 'Either `executable` or `executable_callback` must be defined'
-    endif
-
-    if !l:needs_command
-        if has_key(a:linter, 'command')
-        \|| has_key(a:linter, 'command_callback')
-        \|| has_key(a:linter, 'command_chain')
-            throw '`command` and `command_callback` and `command_chain` cannot be used when lsp == ''socket'''
-        endif
-    elseif has_key(a:linter, 'command_chain')
-        let l:obj.command_chain = a:linter.command_chain
-
-        if type(l:obj.command_chain) isnot v:t_list
-            throw '`command_chain` must be a List'
-        endif
-
-        if empty(l:obj.command_chain)
-            throw '`command_chain` must contain at least one item'
-        endif
-
-        let l:link_index = 0
-
-        for l:link in l:obj.command_chain
-            let l:err_prefix = 'The `command_chain` item ' . l:link_index . ' '
-
-            if !s:IsCallback(get(l:link, 'callback'))
-                throw l:err_prefix . 'must define a `callback` function'
-            endif
-
-            if has_key(l:link, 'output_stream')
-                if type(l:link.output_stream) isnot v:t_string
-                \|| index(['stdout', 'stderr', 'both'], l:link.output_stream) < 0
-                    throw l:err_prefix . '`output_stream` flag must be '
-                    \   . "'stdout', 'stderr', or 'both'"
-                endif
-            endif
-
-            if has_key(l:link, 'read_buffer') && !s:IsBoolean(l:link.read_buffer)
-                throw l:err_prefix . 'value for `read_buffer` must be `0` or `1`'
-            endif
-
-            let l:link_index += 1
-        endfor
-    elseif has_key(a:linter, 'command_callback')
-        let l:obj.command_callback = a:linter.command_callback
-
-        if !s:IsCallback(l:obj.command_callback)
-            throw '`command_callback` must be a callback if defined'
-        endif
-    elseif has_key(a:linter, 'command')
-        let l:obj.command = a:linter.command
-
-        if type(l:obj.command) isnot v:t_string
-        \&& type(l:obj.command) isnot v:t_func
-            throw '`command` must be a String or Function if defined'
-        endif
-    else
-        throw 'Either `command`, `executable_callback`, `command_chain` '
-        \   . 'must be defined'
-    endif
-
-    if (
-    \   has_key(a:linter, 'command')
-    \   + has_key(a:linter, 'command_chain')
-    \   + has_key(a:linter, 'command_callback')
-    \) > 1
-        throw 'Only one of `command`, `command_callback`, or `command_chain` '
-        \   . 'should be set'
-    endif
-
-    if !l:needs_address
-        if has_key(a:linter, 'address') || has_key(a:linter, 'address_callback')
-            throw '`address` or `address_callback` cannot be used when lsp != ''socket'''
-        endif
-    elseif has_key(a:linter, 'address')
-        if type(a:linter.address) isnot v:t_string
-        \&& type(a:linter.address) isnot v:t_func
-            throw '`address` must be a String or Function if defined'
-        endif
-
-        let l:obj.address = a:linter.address
-    elseif has_key(a:linter, 'address_callback')
-        let l:obj.address_callback = a:linter.address_callback
-
-        if !s:IsCallback(l:obj.address_callback)
-            throw '`address_callback` must be a callback if defined'
-        endif
-    else
-        throw '`address` or `address_callback` must be defined for getting the LSP address'
-    endif
-
-    if l:needs_lsp_details
-        if has_key(a:linter, 'language_callback')
-            if has_key(a:linter, 'language')
-                throw 'Only one of `language` or `language_callback` '
-                \   . 'should be set'
-            endif
-
-            let l:obj.language_callback = get(a:linter, 'language_callback')
-
-            if !s:IsCallback(l:obj.language_callback)
-                throw '`language_callback` must be a callback for LSP linters'
-            endif
-        else
-            " Default to using the filetype as the language.
-            let l:Language = get(a:linter, 'language', a:filetype)
-
-            if type(l:Language) is v:t_string
-                " Make 'language_callback' return the 'language' value.
-                let l:obj.language = l:Language
-                let l:obj.language_callback = function('s:LanguageGetter')
-            elseif type(l:Language) is v:t_func
-                let l:obj.language_callback = l:Language
-            else
-                throw '`language` must be a String or Funcref'
-            endif
-        endif
-
-        if has_key(a:linter, 'project_root')
-            let l:obj.project_root = a:linter.project_root
-
-            if type(l:obj.project_root) isnot v:t_string
-            \&& type(l:obj.project_root) isnot v:t_func
-                throw '`project_root` must be a String or Function if defined'
-            endif
-        elseif has_key(a:linter, 'project_root_callback')
-            let l:obj.project_root_callback = a:linter.project_root_callback
-
-            if !s:IsCallback(l:obj.project_root_callback)
-                throw '`project_root_callback` must be a callback if defined'
-            endif
-        else
-            throw '`project_root` or `project_root_callback` must be defined for LSP linters'
-        endif
-
-        if has_key(a:linter, 'completion_filter')
-            let l:obj.completion_filter = a:linter.completion_filter
-
-            if !s:IsCallback(l:obj.completion_filter)
-                throw '`completion_filter` must be a callback'
-            endif
-        endif
-
-        if has_key(a:linter, 'initialization_options_callback')
-            if has_key(a:linter, 'initialization_options')
-                throw 'Only one of `initialization_options` or '
-                \   . '`initialization_options_callback` should be set'
-            endif
-
-            let l:obj.initialization_options_callback = a:linter.initialization_options_callback
-
-            if !s:IsCallback(l:obj.initialization_options_callback)
-                throw '`initialization_options_callback` must be a callback if defined'
-            endif
-        elseif has_key(a:linter, 'initialization_options')
-            let l:obj.initialization_options = a:linter.initialization_options
-
-            if type(l:obj.initialization_options) isnot v:t_dict
-            \&& type(l:obj.initialization_options) isnot v:t_func
-                throw '`initialization_options` must be a String or Function if defined'
-            endif
-        endif
-
-        if has_key(a:linter, 'lsp_config_callback')
-            if has_key(a:linter, 'lsp_config')
-                throw 'Only one of `lsp_config` or `lsp_config_callback` should be set'
-            endif
-
-            let l:obj.lsp_config_callback = a:linter.lsp_config_callback
-
-            if !s:IsCallback(l:obj.lsp_config_callback)
-                throw '`lsp_config_callback` must be a callback if defined'
-            endif
-        elseif has_key(a:linter, 'lsp_config')
-            if type(a:linter.lsp_config) isnot v:t_dict
-            \&& type(a:linter.lsp_config) isnot v:t_func
-                throw '`lsp_config` must be a Dictionary or Function if defined'
-            endif
-
-            let l:obj.lsp_config = a:linter.lsp_config
-        endif
-    endif
-
-    let l:obj.output_stream = get(a:linter, 'output_stream', 'stdout')
-
-    if type(l:obj.output_stream) isnot v:t_string
-    \|| index(['stdout', 'stderr', 'both'], l:obj.output_stream) < 0
-        throw "`output_stream` must be 'stdout', 'stderr', or 'both'"
-    endif
-
-    " An option indicating that this linter should only be run against the
-    " file on disk.
-    let l:obj.lint_file = get(a:linter, 'lint_file', 0)
-
-    if !s:IsBoolean(l:obj.lint_file)
-        throw '`lint_file` must be `0` or `1`'
-    endif
-
-    " An option indicating that the buffer should be read.
-    let l:obj.read_buffer = get(a:linter, 'read_buffer', !l:obj.lint_file)
-
-    if !s:IsBoolean(l:obj.read_buffer)
-        throw '`read_buffer` must be `0` or `1`'
-    endif
-
-    if l:obj.lint_file && l:obj.read_buffer
-        throw 'Only one of `lint_file` or `read_buffer` can be `1`'
-    endif
-
-    let l:obj.aliases = get(a:linter, 'aliases', [])
-
-    if type(l:obj.aliases) isnot v:t_list
-    \|| len(filter(copy(l:obj.aliases), 'type(v:val) isnot v:t_string')) > 0
-        throw '`aliases` must be a List of String values'
-    endif
-
-    for l:key in filter(keys(a:linter), 'v:val[-9:] is# ''_callback'' || v:val is# ''command_chain''')
-        if !get(g:, 'ale_ignore_2_4_warnings')
-            execute 'echom l:key . '' is deprecated. Use `let g:ale_ignore_2_4_warnings = 1` to disable this message.'''
-        endif
-
-        break
-    endfor
-
-    return l:obj
-endfunction
-
-function! ale#linter#Define(filetype, linter) abort
-    " This command will throw from the sandbox.
-    let &l:equalprg=&l:equalprg
-
-    let l:new_linter = ale#linter#PreProcess(a:filetype, a:linter)
-
-    if !has_key(s:linters, a:filetype)
-        let s:linters[a:filetype] = []
-    endif
-
-    " Remove previously defined linters with the same name.
-    call filter(s:linters[a:filetype], 'v:val.name isnot# a:linter.name')
-    call add(s:linters[a:filetype], l:new_linter)
-endfunction
-
-" Prevent any linters from being loaded for a given filetype.
-function! ale#linter#PreventLoading(filetype) abort
-    let s:runtime_loaded_map[a:filetype] = 1
-endfunction
-
-function! ale#linter#GetAll(filetypes) abort
-    " Don't return linters in the sandbox.
-    " Otherwise a sandboxed script could modify them.
-    if ale#util#InSandbox()
-        return []
-    endif
-
-    let l:combined_linters = []
-
-    for l:filetype in a:filetypes
-        " Load linters from runtimepath if we haven't done that yet.
-        if !has_key(s:runtime_loaded_map, l:filetype)
-            execute 'silent! runtime! ale_linters/' . l:filetype . '/*.vim'
-
-            let s:runtime_loaded_map[l:filetype] = 1
-        endif
-
-        call extend(l:combined_linters, get(s:linters, l:filetype, []))
-    endfor
-
-    return l:combined_linters
-endfunction
-
-function! s:GetAliasedFiletype(original_filetype) abort
-    let l:buffer_aliases = get(b:, 'ale_linter_aliases', {})
-
-    " b:ale_linter_aliases can be set to a List or String.
-    if type(l:buffer_aliases) is v:t_list
-    \|| type(l:buffer_aliases) is v:t_string
-        return l:buffer_aliases
-    endif
-
-    " Check for aliased filetypes first in a buffer variable,
-    " then the global variable,
-    " then in the default mapping,
-    " otherwise use the original filetype.
-    for l:dict in [
-    \   l:buffer_aliases,
-    \   g:ale_linter_aliases,
-    \   s:default_ale_linter_aliases,
-    \]
-        if has_key(l:dict, a:original_filetype)
-            return l:dict[a:original_filetype]
-        endif
-    endfor
-
-    return a:original_filetype
-endfunction
-
-function! ale#linter#ResolveFiletype(original_filetype) abort
-    let l:filetype = s:GetAliasedFiletype(a:original_filetype)
-
-    if type(l:filetype) isnot v:t_list
-        return [l:filetype]
-    endif
-
-    return l:filetype
-endfunction
-
-function! s:GetLinterNames(original_filetype) abort
-    let l:buffer_ale_linters = get(b:, 'ale_linters', {})
-
-    " b:ale_linters can be set to 'all'
-    if l:buffer_ale_linters is# 'all'
-        return 'all'
-    endif
-
-    " b:ale_linters can be set to a List.
-    if type(l:buffer_ale_linters) is v:t_list
-        return l:buffer_ale_linters
-    endif
-
-    " Try to get a buffer-local setting for the filetype
-    if has_key(l:buffer_ale_linters, a:original_filetype)
-        return l:buffer_ale_linters[a:original_filetype]
-    endif
-
-    " Try to get a global setting for the filetype
-    if has_key(g:ale_linters, a:original_filetype)
-        return g:ale_linters[a:original_filetype]
-    endif
-
-    " If the user has configured ALE to only enable linters explicitly, then
-    " don't enable any linters by default.
-    if g:ale_linters_explicit
-        return []
-    endif
-
-    " Try to get a default setting for the filetype
-    if has_key(s:default_ale_linters, a:original_filetype)
-        return s:default_ale_linters[a:original_filetype]
-    endif
-
-    return 'all'
-endfunction
-
-function! ale#linter#Get(original_filetypes) abort
-    let l:possibly_duplicated_linters = []
-
-    " Handle dot-separated filetypes.
-    for l:original_filetype in split(a:original_filetypes, '\.')
-        let l:filetype = ale#linter#ResolveFiletype(l:original_filetype)
-        let l:linter_names = s:GetLinterNames(l:original_filetype)
-        let l:all_linters = ale#linter#GetAll(l:filetype)
-        let l:filetype_linters = []
-
-        if type(l:linter_names) is v:t_string && l:linter_names is# 'all'
-            let l:filetype_linters = l:all_linters
-        elseif type(l:linter_names) is v:t_list
-            " Select only the linters we or the user has specified.
-            for l:linter in l:all_linters
-                let l:name_list = [l:linter.name] + l:linter.aliases
-
-                for l:name in l:name_list
-                    if index(l:linter_names, l:name) >= 0
-                        call add(l:filetype_linters, l:linter)
-                        break
-                    endif
-                endfor
-            endfor
-        endif
-
-        call extend(l:possibly_duplicated_linters, l:filetype_linters)
-    endfor
-
-    let l:name_list = []
-    let l:combined_linters = []
-
-    " Make sure we override linters so we don't get two with the same name,
-    " like 'eslint' for both 'javascript' and 'typescript'
-    "
-    " Note that the reverse calls here modify the List variables.
-    for l:linter in reverse(l:possibly_duplicated_linters)
-        if index(l:name_list, l:linter.name) < 0
-            call add(l:name_list, l:linter.name)
-            call add(l:combined_linters, l:linter)
-        endif
-    endfor
-
-    return reverse(l:combined_linters)
-endfunction
-
-" Given a buffer and linter, get the executable String for the linter.
-function! ale#linter#GetExecutable(buffer, linter) abort
-    let l:Executable = has_key(a:linter, 'executable_callback')
-    \   ? function(a:linter.executable_callback)
-    \   : a:linter.executable
-
-    return type(l:Executable) is v:t_func
-    \   ? l:Executable(a:buffer)
-    \   : l:Executable
-endfunction
-
-" Given a buffer and linter, get the command String for the linter.
-" The command_chain key is not supported.
-function! ale#linter#GetCommand(buffer, linter) abort
-    let l:Command = has_key(a:linter, 'command_callback')
-    \   ? function(a:linter.command_callback)
-    \   : a:linter.command
-
-    return type(l:Command) is v:t_func
-    \   ? l:Command(a:buffer)
-    \   : l:Command
-endfunction
-
-" Given a buffer and linter, get the address for connecting to the server.
-function! ale#linter#GetAddress(buffer, linter) abort
-    let l:Address = has_key(a:linter, 'address_callback')
-    \   ? function(a:linter.address_callback)
-    \   : a:linter.address
-
-    return type(l:Address) is v:t_func
-    \   ? l:Address(a:buffer)
-    \   : l:Address
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/list.vim b/sources_non_forked/ale/autoload/ale/list.vim
deleted file mode 100644
index 4bfe2a7..0000000
--- a/sources_non_forked/ale/autoload/ale/list.vim
+++ /dev/null
@@ -1,233 +0,0 @@
-" Author: Bjorn Neergaard <bjorn@neersighted.com>, modified by Yann fery <yann@fery.me>
-" Description: Manages the loclist and quickfix lists
-
-" This flag dictates if ale open the configured loclist
-let g:ale_open_list = get(g:, 'ale_open_list', 0)
-" This flag dictates if ale keeps open loclist even if there is no error in loclist
-let g:ale_keep_list_window_open = get(g:, 'ale_keep_list_window_open', 0)
-" This flag dictates that quickfix windows should be opened vertically
-let g:ale_list_vertical = get(g:, 'ale_list_vertical', 0)
-" The window size to set for the quickfix and loclist windows
-let g:ale_list_window_size = get(g:, 'ale_list_window_size', 10)
-" A string format for the loclist messages.
-let g:ale_loclist_msg_format = get(g:, 'ale_loclist_msg_format',
-\   get(g:, 'ale_echo_msg_format', '%code: %%s')
-\)
-
-if !exists('s:timer_args')
-    let s:timer_args = {}
-endif
-
-" Return 1 if there is a buffer with buftype == 'quickfix' in bufffer list
-function! ale#list#IsQuickfixOpen() abort
-    for l:buf in range(1, bufnr('$'))
-        if getbufvar(l:buf, '&buftype') is# 'quickfix'
-            return 1
-        endif
-    endfor
-
-    return 0
-endfunction
-
-" Check if we should open the list, based on the save event being fired, and
-" that setting being on, or the setting just being set to `1`.
-function! s:ShouldOpen(buffer) abort
-    let l:val = ale#Var(a:buffer, 'open_list')
-    let l:saved = getbufvar(a:buffer, 'ale_save_event_fired', 0)
-
-    return l:val is 1 || (l:val is# 'on_save' && l:saved)
-endfunction
-
-function! ale#list#GetCombinedList() abort
-    let l:list = []
-
-    for l:info in values(g:ale_buffer_info)
-        call extend(l:list, l:info.loclist)
-    endfor
-
-    call sort(l:list, function('ale#util#LocItemCompareWithText'))
-    call uniq(l:list, function('ale#util#LocItemCompareWithText'))
-
-    return l:list
-endfunction
-
-function! s:FixList(buffer, list) abort
-    let l:format = ale#Var(a:buffer, 'loclist_msg_format')
-    let l:new_list = []
-
-    for l:item in a:list
-        let l:fixed_item = copy(l:item)
-
-        let l:fixed_item.text = ale#GetLocItemMessage(l:item, l:format)
-
-        if l:item.bufnr == -1
-            " If the buffer number is invalid, remove it.
-            call remove(l:fixed_item, 'bufnr')
-        endif
-
-        call add(l:new_list, l:fixed_item)
-    endfor
-
-    return l:new_list
-endfunction
-
-function! s:WinFindBuf(buffer) abort
-    return exists('*win_findbuf') ? win_findbuf(str2nr(a:buffer)) : [0]
-endfunction
-
-function! s:SetListsImpl(timer_id, buffer, loclist) abort
-    let l:title = expand('#' . a:buffer . ':p')
-
-    if g:ale_set_quickfix
-        let l:quickfix_list = ale#list#GetCombinedList()
-
-        if has('nvim')
-            call setqflist(s:FixList(a:buffer, l:quickfix_list), ' ', l:title)
-        else
-            call setqflist(s:FixList(a:buffer, l:quickfix_list))
-            call setqflist([], 'r', {'title': l:title})
-        endif
-    elseif g:ale_set_loclist
-        " If windows support is off, win_findbuf() may not exist.
-        " We'll set result in the current window, which might not be correct,
-        " but it's better than nothing.
-        let l:ids = s:WinFindBuf(a:buffer)
-
-        for l:id in l:ids
-            if has('nvim')
-                call setloclist(l:id, s:FixList(a:buffer, a:loclist), ' ', l:title)
-            else
-                call setloclist(l:id, s:FixList(a:buffer, a:loclist))
-                call setloclist(l:id, [], 'r', {'title': l:title})
-            endif
-        endfor
-    endif
-
-    " Save the current view before opening/closing any window
-    call setbufvar(a:buffer, 'ale_winview', winsaveview())
-
-    " Open a window to show the problems if we need to.
-    "
-    " We'll check if the current buffer's List is not empty here, so the
-    " window will only be opened if the current buffer has problems.
-    if s:ShouldOpen(a:buffer) && !empty(a:loclist)
-        let l:winnr = winnr()
-        let l:mode = mode()
-
-        " open windows vertically instead of default horizontally
-        let l:open_type = ''
-
-        if ale#Var(a:buffer, 'list_vertical') == 1
-            let l:open_type = 'vert rightbelow '
-        endif
-
-        if g:ale_set_quickfix
-            if !ale#list#IsQuickfixOpen()
-                silent! execute l:open_type . 'copen ' . str2nr(ale#Var(a:buffer, 'list_window_size'))
-            endif
-        elseif g:ale_set_loclist
-            silent! execute l:open_type . 'lopen ' . str2nr(ale#Var(a:buffer, 'list_window_size'))
-        endif
-
-        " If focus changed, restore it (jump to the last window).
-        if l:winnr isnot# winnr()
-            wincmd p
-        endif
-
-        " Return to original mode when applicable
-        if mode() != l:mode
-            if l:mode is? 'v' || l:mode is# "\<c-v>"
-                " Reset our last visual selection
-                normal! gv
-            elseif l:mode is? 's' || l:mode is# "\<c-s>"
-                " Reset our last character selection
-                normal! "\<c-g>"
-            endif
-        endif
-
-        call s:RestoreViewIfNeeded(a:buffer)
-    endif
-
-    " If ALE isn't currently checking for more problems, close the window if
-    " needed now. This check happens inside of this timer function, so
-    " the window can be closed reliably.
-    if !ale#engine#IsCheckingBuffer(a:buffer)
-        call s:CloseWindowIfNeeded(a:buffer)
-    endif
-endfunction
-
-" Try to restore the window view after closing any of the lists to avoid making
-" the it moving around, especially useful when on insert mode
-function! s:RestoreViewIfNeeded(buffer) abort
-    let l:saved_view = getbufvar(a:buffer, 'ale_winview', {})
-
-    " Saved view is empty, can't do anything
-    if empty(l:saved_view)
-        return
-    endif
-
-    " Check wether the cursor has moved since linting was actually requested. If
-    " the user has indeed moved lines, do nothing
-    let l:current_view = winsaveview()
-
-    if l:current_view['lnum'] != l:saved_view['lnum']
-        return
-    endif
-
-    " Anchor view by topline if the list is set to open horizontally
-    if ale#Var(a:buffer, 'list_vertical') == 0
-        call winrestview({'topline': l:saved_view['topline']})
-    endif
-endfunction
-
-function! ale#list#SetLists(buffer, loclist) abort
-    if get(g:, 'ale_set_lists_synchronously') == 1
-    \|| getbufvar(a:buffer, 'ale_save_event_fired', 0)
-        " Update lists immediately if running a test synchronously, or if the
-        " buffer was saved.
-        "
-        " The lists need to be updated immediately when saving a buffer so
-        " that we can reliably close window automatically, if so configured.
-        call s:SetListsImpl(-1, a:buffer, a:loclist)
-    else
-        call ale#util#StartPartialTimer(
-        \   0,
-        \   function('s:SetListsImpl'),
-        \   [a:buffer, a:loclist],
-        \)
-    endif
-endfunction
-
-function! s:CloseWindowIfNeeded(buffer) abort
-    if ale#Var(a:buffer, 'keep_list_window_open') || !s:ShouldOpen(a:buffer)
-        return
-    endif
-
-    let l:did_close_any_list = 0
-
-    try
-        " Only close windows if the quickfix list or loclist is completely empty,
-        " including errors set through other means.
-        if g:ale_set_quickfix
-            if empty(getqflist())
-                cclose
-                let l:did_close_any_list = 1
-            endif
-        else
-            let l:win_ids = s:WinFindBuf(a:buffer)
-
-            for l:win_id in l:win_ids
-                if g:ale_set_loclist && empty(getloclist(l:win_id))
-                    lclose
-                    let l:did_close_any_list = 1
-                endif
-            endfor
-        endif
-    " Ignore 'Cannot close last window' errors.
-    catch /E444/
-    endtry
-
-    if l:did_close_any_list
-        call s:RestoreViewIfNeeded(a:buffer)
-    endif
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/loclist_jumping.vim b/sources_non_forked/ale/autoload/ale/loclist_jumping.vim
deleted file mode 100644
index 55097d1..0000000
--- a/sources_non_forked/ale/autoload/ale/loclist_jumping.vim
+++ /dev/null
@@ -1,163 +0,0 @@
-" Author: w0rp <devw0rp@gmail.com>
-" Description: This file implements functions for jumping around in a file
-"   based on ALE's internal loclist.
-
-" Search for the nearest line either before or after the current position
-" in the loclist. The argument 'wrap' can be passed to enable wrapping
-" around the end of the list.
-"
-" If there are no items or we have hit the end with wrapping off, an empty
-" List will be returned, otherwise a pair of [line_number, column_number] will
-" be returned.
-function! ale#loclist_jumping#FindNearest(direction, wrap, ...) abort
-    let l:buffer = bufnr('')
-    let l:pos = getpos('.')
-    let l:info = get(g:ale_buffer_info, bufnr('%'), {'loclist': []})
-    " Copy the list and filter to only the items in this buffer.
-    let l:loclist = filter(copy(l:info.loclist), 'v:val.bufnr == l:buffer')
-    let l:search_item = {'bufnr': l:buffer, 'lnum': l:pos[1], 'col': l:pos[2]}
-
-    if a:0 > 0
-        let l:filter = a:1
-    else
-        let l:filter = 'any'
-    endif
-
-    if a:0 > 1
-        let l:subtype_filter = a:2
-    else
-        let l:subtype_filter = 'any'
-    endif
-
-    " When searching backwards, so we can find the next smallest match.
-    if a:direction is# 'before'
-        call reverse(l:loclist)
-    endif
-
-    " Look for items before or after the current position.
-    for l:item in l:loclist
-        " Compare the cursor with a item where the column number is bounded,
-        " such that it's possible for the cursor to actually be on the given
-        " column number, without modifying the cursor number we return. This
-        " will allow us to move through matches, but still let us move the
-        " cursor to a line without changing the column, in some cases.
-        let l:cmp_value = ale#util#LocItemCompare(
-        \   {
-        \       'bufnr': l:buffer,
-        \       'lnum': l:item.lnum,
-        \       'col': min([
-        \           max([l:item.col, 1]),
-        \           max([len(getline(l:item.lnum)), 1]),
-        \       ]),
-        \   },
-        \   l:search_item
-        \)
-
-        if (l:filter is# 'any' || l:filter is# l:item.type)
-        \&& (
-        \   l:subtype_filter is# 'any'
-        \   || l:subtype_filter is# get(l:item, 'sub_type', '')
-        \)
-
-            if a:direction is# 'before' && l:cmp_value < 0
-                return [l:item.lnum, l:item.col]
-            endif
-
-            if a:direction is# 'after' && l:cmp_value > 0
-                return [l:item.lnum, l:item.col]
-            endif
-        endif
-    endfor
-
-    " If we found nothing, and the wrap option is set to 1, then we should
-    " wrap around the list of warnings/errors
-    if a:wrap
-        for l:item in l:loclist
-            if (l:filter is# 'any' || l:filter is# l:item.type)
-            \&& (
-            \   l:subtype_filter is# 'any'
-            \   || l:subtype_filter is# get(l:item, 'sub_type', '')
-            \)
-                return [l:item.lnum, l:item.col]
-            endif
-        endfor
-    endif
-
-    return []
-endfunction
-
-" As before, find the nearest match, but position the cursor at it.
-function! ale#loclist_jumping#Jump(direction, ...) abort
-    if a:0 > 0
-        let l:wrap = a:1
-    else
-        let l:wrap = 0
-    endif
-
-    if a:0 > 1
-        let l:filter = a:2
-    else
-        let l:filter = 'any'
-    endif
-
-    if a:0 > 2
-        let l:subtype_filter = a:3
-    else
-        let l:subtype_filter = 'any'
-    endif
-
-    let l:nearest = ale#loclist_jumping#FindNearest(a:direction,
-    \   l:wrap, l:filter, l:subtype_filter)
-
-    if !empty(l:nearest)
-        normal! m`
-        call cursor([l:nearest[0], max([l:nearest[1], 1])])
-    endif
-endfunction
-
-function! ale#loclist_jumping#WrapJump(direction, sargs) abort
-    let [l:args, l:rest] = ale#args#Parse(['error', 'warning', 'info', 'wrap',
-    \                                      'style', 'nostyle'], a:sargs)
-
-    let l:wrap = 0
-    let l:type_filter = 'any'
-    let l:subtype_filter = 'any'
-
-    if get(l:args, 'wrap', 'nil') is# ''
-        let l:wrap = 1
-    endif
-
-    if get(l:args, 'error', 'nil') is# ''
-        let l:type_filter = 'E'
-    elseif get(l:args, 'warning', 'nil') is# ''
-        let l:type_filter = 'W'
-    elseif get(l:args, 'info', 'nil') is# ''
-        let l:type_filter = 'I'
-    endif
-
-    if get(l:args, 'nostyle', 'nil') is# ''
-        let l:subtype_filter = 'style'
-    elseif get(l:args, 'style', 'nil') is# ''
-        let l:subtype_filter = ''
-    endif
-
-    call ale#loclist_jumping#Jump(a:direction, l:wrap, l:type_filter,
-    \                             l:subtype_filter)
-endfunction
-
-function! ale#loclist_jumping#JumpToIndex(index) abort
-    let l:buffer = bufnr('')
-    let l:info = get(g:ale_buffer_info, l:buffer, {'loclist': []})
-    let l:loclist = filter(copy(l:info.loclist), 'v:val.bufnr == l:buffer')
-
-    if empty(l:loclist)
-        return
-    endif
-
-    let l:item = l:loclist[a:index]
-
-    if !empty(l:item)
-        normal! m`
-        call cursor([l:item.lnum, l:item.col])
-    endif
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/lsp.vim b/sources_non_forked/ale/autoload/ale/lsp.vim
deleted file mode 100644
index 2509174..0000000
--- a/sources_non_forked/ale/autoload/ale/lsp.vim
+++ /dev/null
@@ -1,637 +0,0 @@
-" Author: w0rp <devw0rp@gmail.com>
-" Description: Language Server Protocol client code
-
-" A Dictionary for tracking connections.
-let s:connections = get(s:, 'connections', {})
-let g:ale_lsp_next_message_id = 1
-
-" Given an id, which can be an executable or address, and a project path,
-" create a new connection if needed. Return a unique ID for the connection.
-function! ale#lsp#Register(executable_or_address, project, init_options) abort
-    let l:conn_id = a:executable_or_address . ':' . a:project
-
-    if !has_key(s:connections, l:conn_id)
-        " is_tsserver: 1 if the connection is for tsserver.
-        " data: The message data received so far.
-        " root: The project root.
-        " open_documents: A Dictionary mapping buffers to b:changedtick, keeping
-        "   track of when documents were opened, and when we last changed them.
-        " initialized: 0 if the connection is ready, 1 otherwise.
-        " init_request_id: The ID for the init request.
-        " init_options: Options to send to the server.
-        " config: Configuration settings to send to the server.
-        " callback_list: A list of callbacks for handling LSP responses.
-        " capabilities_queue: The list of callbacks to call with capabilities.
-        " capabilities: Features the server supports.
-        let s:connections[l:conn_id] = {
-        \   'id': l:conn_id,
-        \   'is_tsserver': 0,
-        \   'data': '',
-        \   'root': a:project,
-        \   'open_documents': {},
-        \   'initialized': 0,
-        \   'init_request_id': 0,
-        \   'init_options': a:init_options,
-        \   'config': {},
-        \   'callback_list': [],
-        \   'init_queue': [],
-        \   'capabilities': {
-        \       'hover': 0,
-        \       'rename': 0,
-        \       'references': 0,
-        \       'completion': 0,
-        \       'completion_trigger_characters': [],
-        \       'definition': 0,
-        \       'typeDefinition': 0,
-        \       'symbol_search': 0,
-        \   },
-        \}
-    endif
-
-    return l:conn_id
-endfunction
-
-" Remove an LSP connection with a given ID. This is only for tests.
-function! ale#lsp#RemoveConnectionWithID(id) abort
-    if has_key(s:connections, a:id)
-        call remove(s:connections, a:id)
-    endif
-endfunction
-
-function! ale#lsp#ResetConnections() abort
-    let s:connections = {}
-endfunction
-
-" Used only in tests.
-function! ale#lsp#GetConnections() abort
-    return s:connections
-endfunction
-
-" This is only needed for tests
-function! ale#lsp#MarkDocumentAsOpen(id, buffer) abort
-    let l:conn = get(s:connections, a:id, {})
-
-    if !empty(l:conn)
-        let l:conn.open_documents[a:buffer] = -1
-    endif
-endfunction
-
-function! ale#lsp#GetNextMessageID() abort
-    " Use the current ID
-    let l:id = g:ale_lsp_next_message_id
-
-    " Increment the ID variable.
-    let g:ale_lsp_next_message_id += 1
-
-    " When the ID overflows, reset it to 1. By the time we hit the initial ID
-    " again, the messages will be long gone.
-    if g:ale_lsp_next_message_id < 1
-        let g:ale_lsp_next_message_id = 1
-    endif
-
-    return l:id
-endfunction
-
-" TypeScript messages use a different format.
-function! s:CreateTSServerMessageData(message) abort
-    let l:is_notification = a:message[0]
-
-    let l:obj = {
-    \   'seq': v:null,
-    \   'type': 'request',
-    \   'command': a:message[1][3:],
-    \}
-
-    if !l:is_notification
-        let l:obj.seq = ale#lsp#GetNextMessageID()
-    endif
-
-    if len(a:message) > 2
-        let l:obj.arguments = a:message[2]
-    endif
-
-    let l:data = json_encode(l:obj) . "\n"
-
-    return [l:is_notification ? 0 : l:obj.seq, l:data]
-endfunction
-
-" Given a List of one or two items, [method_name] or [method_name, params],
-" return a List containing [message_id, message_data]
-function! ale#lsp#CreateMessageData(message) abort
-    if a:message[1][:2] is# 'ts@'
-        return s:CreateTSServerMessageData(a:message)
-    endif
-
-    let l:is_notification = a:message[0]
-
-    let l:obj = {
-    \   'method': a:message[1],
-    \   'jsonrpc': '2.0',
-    \}
-
-    if !l:is_notification
-        let l:obj.id = ale#lsp#GetNextMessageID()
-    endif
-
-    if len(a:message) > 2
-        let l:obj.params = a:message[2]
-    endif
-
-    let l:body = json_encode(l:obj)
-    let l:data = 'Content-Length: ' . strlen(l:body) . "\r\n\r\n" . l:body
-
-    return [l:is_notification ? 0 : l:obj.id, l:data]
-endfunction
-
-function! ale#lsp#ReadMessageData(data) abort
-    let l:response_list = []
-    let l:remainder = a:data
-
-    while 1
-        " Look for the end of the HTTP headers
-        let l:body_start_index = matchend(l:remainder, "\r\n\r\n")
-
-        if l:body_start_index < 0
-            " No header end was found yet.
-            break
-        endif
-
-        " Parse the Content-Length header.
-        let l:header_data = l:remainder[:l:body_start_index - 4]
-        let l:length_match = matchlist(
-        \   l:header_data,
-        \   '\vContent-Length: *(\d+)'
-        \)
-
-        if empty(l:length_match)
-            throw "Invalid JSON-RPC header:\n" . l:header_data
-        endif
-
-        " Split the body and the remainder of the text.
-        let l:remainder_start_index = l:body_start_index + str2nr(l:length_match[1])
-
-        if len(l:remainder) < l:remainder_start_index
-            " We don't have enough data yet.
-            break
-        endif
-
-        let l:body = l:remainder[l:body_start_index : l:remainder_start_index - 1]
-        let l:remainder = l:remainder[l:remainder_start_index :]
-
-        " Parse the JSON object and add it to the list.
-        call add(l:response_list, json_decode(l:body))
-    endwhile
-
-    return [l:remainder, l:response_list]
-endfunction
-
-" Update capabilities from the server, so we know which features the server
-" supports.
-function! s:UpdateCapabilities(conn, capabilities) abort
-    if type(a:capabilities) isnot v:t_dict
-        return
-    endif
-
-    if get(a:capabilities, 'hoverProvider') is v:true
-        let a:conn.capabilities.hover = 1
-    endif
-
-    if get(a:capabilities, 'referencesProvider') is v:true
-        let a:conn.capabilities.references = 1
-    endif
-
-    if get(a:capabilities, 'renameProvider') is v:true
-        let a:conn.capabilities.rename = 1
-    endif
-
-    if !empty(get(a:capabilities, 'completionProvider'))
-        let a:conn.capabilities.completion = 1
-    endif
-
-    if type(get(a:capabilities, 'completionProvider')) is v:t_dict
-        let l:chars = get(a:capabilities.completionProvider, 'triggerCharacters')
-
-        if type(l:chars) is v:t_list
-            let a:conn.capabilities.completion_trigger_characters = l:chars
-        endif
-    endif
-
-    if get(a:capabilities, 'definitionProvider') is v:true
-        let a:conn.capabilities.definition = 1
-    endif
-
-    if get(a:capabilities, 'typeDefinitionProvider') is v:true
-        let a:conn.capabilities.typeDefinition = 1
-    endif
-
-    if get(a:capabilities, 'workspaceSymbolProvider') is v:true
-        let a:conn.capabilities.symbol_search = 1
-    endif
-endfunction
-
-" Update a connection's configuration dictionary and notify LSP servers
-" of any changes since the last update. Returns 1 if a configuration
-" update was sent; otherwise 0 will be returned.
-function! ale#lsp#UpdateConfig(conn_id, buffer, config) abort
-    let l:conn = get(s:connections, a:conn_id, {})
-
-    if empty(l:conn) || a:config ==# l:conn.config " no-custom-checks
-        return 0
-    endif
-
-    let l:conn.config = a:config
-    let l:message = ale#lsp#message#DidChangeConfiguration(a:buffer, a:config)
-
-    call ale#lsp#Send(a:conn_id, l:message)
-
-    return 1
-endfunction
-
-
-function! ale#lsp#HandleInitResponse(conn, response) abort
-    if get(a:response, 'method', '') is# 'initialize'
-        let a:conn.initialized = 1
-    elseif type(get(a:response, 'result')) is v:t_dict
-    \&& has_key(a:response.result, 'capabilities')
-        call s:UpdateCapabilities(a:conn, a:response.result.capabilities)
-
-        let a:conn.initialized = 1
-    endif
-
-    if !a:conn.initialized
-        return
-    endif
-
-    " The initialized message must be sent before everything else.
-    call ale#lsp#Send(a:conn.id, ale#lsp#message#Initialized())
-
-    " Call capabilities callbacks queued for the project.
-    for l:Callback in a:conn.init_queue
-        call l:Callback()
-    endfor
-
-    let a:conn.init_queue = []
-endfunction
-
-function! ale#lsp#HandleMessage(conn_id, message) abort
-    let l:conn = get(s:connections, a:conn_id, {})
-
-    if empty(l:conn)
-        return
-    endif
-
-    if type(a:message) isnot v:t_string
-        " Ignore messages that aren't strings.
-        return
-    endif
-
-    let l:conn.data .= a:message
-
-    " Parse the objects now if we can, and keep the remaining text.
-    let [l:conn.data, l:response_list] = ale#lsp#ReadMessageData(l:conn.data)
-
-    " Look for initialize responses first.
-    if !l:conn.initialized
-        for l:response in l:response_list
-            call ale#lsp#HandleInitResponse(l:conn, l:response)
-        endfor
-    endif
-
-    " If the connection is marked as initialized, call the callbacks with the
-    " responses.
-    if l:conn.initialized
-        for l:response in l:response_list
-            " Call all of the registered handlers with the response.
-            for l:Callback in l:conn.callback_list
-                call ale#util#GetFunction(l:Callback)(a:conn_id, l:response)
-            endfor
-        endfor
-    endif
-endfunction
-
-" Given a connection ID, mark it as a tsserver connection, so it will be
-" handled that way.
-function! ale#lsp#MarkConnectionAsTsserver(conn_id) abort
-    let l:conn = s:connections[a:conn_id]
-    let l:conn.is_tsserver = 1
-    let l:conn.initialized = 1
-    " Set capabilities which are supported by tsserver.
-    let l:conn.capabilities.hover = 1
-    let l:conn.capabilities.references = 1
-    let l:conn.capabilities.completion = 1
-    let l:conn.capabilities.completion_trigger_characters = ['.']
-    let l:conn.capabilities.definition = 1
-    let l:conn.capabilities.symbol_search = 1
-    let l:conn.capabilities.rename = 1
-endfunction
-
-function! s:SendInitMessage(conn) abort
-    let [l:init_id, l:init_data] = ale#lsp#CreateMessageData(
-    \   ale#lsp#message#Initialize(
-    \       a:conn.root,
-    \       a:conn.init_options,
-    \       {
-    \           'workspace': {
-    \               'applyEdit': v:false,
-    \               'didChangeConfiguration': {
-    \                   'dynamicRegistration': v:false,
-    \               },
-    \               'symbol': {
-    \                   'dynamicRegistration': v:false,
-    \               },
-    \               'workspaceFolders': v:false,
-    \               'configuration': v:false,
-    \           },
-    \           'textDocument': {
-    \               'synchronization': {
-    \                   'dynamicRegistration': v:false,
-    \                   'willSave': v:false,
-    \                   'willSaveWaitUntil': v:false,
-    \                   'didSave': v:true,
-    \               },
-    \               'completion': {
-    \                   'dynamicRegistration': v:false,
-    \                   'completionItem': {
-    \                       'snippetSupport': v:false,
-    \                       'commitCharactersSupport': v:false,
-    \                       'documentationFormat': ['plaintext'],
-    \                       'deprecatedSupport': v:false,
-    \                       'preselectSupport': v:false,
-    \                   },
-    \                   'contextSupport': v:false,
-    \               },
-    \               'hover': {
-    \                   'dynamicRegistration': v:false,
-    \                   'contentFormat': ['plaintext'],
-    \               },
-    \               'references': {
-    \                   'dynamicRegistration': v:false,
-    \               },
-    \               'documentSymbol': {
-    \                   'dynamicRegistration': v:false,
-    \                   'hierarchicalDocumentSymbolSupport': v:false,
-    \               },
-    \               'definition': {
-    \                   'dynamicRegistration': v:false,
-    \                   'linkSupport': v:false,
-    \               },
-    \               'typeDefinition': {
-    \                   'dynamicRegistration': v:false,
-    \               },
-    \               'publishDiagnostics': {
-    \                   'relatedInformation': v:true,
-    \               },
-    \               'codeAction': {
-    \                   'dynamicRegistration': v:false,
-    \               },
-    \               'rename': {
-    \                   'dynamicRegistration': v:false,
-    \               },
-    \           },
-    \       },
-    \   ),
-    \)
-    let a:conn.init_request_id = l:init_id
-    call s:SendMessageData(a:conn, l:init_data)
-endfunction
-
-" Start a program for LSP servers.
-"
-" 1 will be returned if the program is running, or 0 if the program could
-" not be started.
-function! ale#lsp#StartProgram(conn_id, executable, command) abort
-    let l:conn = s:connections[a:conn_id]
-    let l:started = 0
-
-    if !has_key(l:conn, 'job_id') || !ale#job#HasOpenChannel(l:conn.job_id)
-        let l:options = {
-        \   'mode': 'raw',
-        \   'out_cb': {_, message -> ale#lsp#HandleMessage(a:conn_id, message)},
-        \}
-
-        if has('win32')
-            let l:job_id = ale#job#StartWithCmd(a:command, l:options)
-        else
-            let l:job_id = ale#job#Start(a:command, l:options)
-        endif
-
-        let l:started = 1
-    else
-        let l:job_id = l:conn.job_id
-    endif
-
-    if l:job_id > 0
-        let l:conn.job_id = l:job_id
-    endif
-
-    if l:started && !l:conn.is_tsserver
-        call s:SendInitMessage(l:conn)
-    endif
-
-    return l:job_id > 0
-endfunction
-
-" Connect to an LSP server via TCP.
-"
-" 1 will be returned if the connection is running, or 0 if the connection could
-" not be opened.
-function! ale#lsp#ConnectToAddress(conn_id, address) abort
-    let l:conn = s:connections[a:conn_id]
-    let l:started = 0
-
-    if !has_key(l:conn, 'channel_id') || !ale#socket#IsOpen(l:conn.channel_id)
-        let l:channel_id = ale#socket#Open(a:address, {
-        \   'callback': {_, mess -> ale#lsp#HandleMessage(a:conn_id, mess)},
-        \})
-
-        let l:started = 1
-    else
-        let l:channel_id = l:conn.channel_id
-    endif
-
-    if l:channel_id >= 0
-        let l:conn.channel_id = l:channel_id
-    endif
-
-    if l:started
-        call s:SendInitMessage(l:conn)
-    endif
-
-    return l:channel_id >= 0
-endfunction
-
-" Given a connection ID and a callback, register that callback for handling
-" messages if the connection exists.
-function! ale#lsp#RegisterCallback(conn_id, callback) abort
-    let l:conn = get(s:connections, a:conn_id, {})
-
-    if !empty(l:conn)
-        " Add the callback to the List if it's not there already.
-        call uniq(sort(add(l:conn.callback_list, a:callback)))
-    endif
-endfunction
-
-" Stop a single LSP connection.
-function! ale#lsp#Stop(conn_id) abort
-    if has_key(s:connections, a:conn_id)
-        let l:conn = remove(s:connections, a:conn_id)
-
-        if has_key(l:conn, 'channel_id')
-            call ale#socket#Close(l:conn.channel_id)
-        elseif has_key(l:conn, 'job_id')
-            call ale#job#Stop(l:conn.job_id)
-        endif
-    endif
-endfunction
-
-function! ale#lsp#CloseDocument(conn_id) abort
-endfunction
-
-" Stop all LSP connections, closing all jobs and channels, and removing any
-" queued messages.
-function! ale#lsp#StopAll() abort
-    for l:conn_id in keys(s:connections)
-        call ale#lsp#Stop(l:conn_id)
-    endfor
-endfunction
-
-function! s:SendMessageData(conn, data) abort
-    if has_key(a:conn, 'job_id')
-        call ale#job#SendRaw(a:conn.job_id, a:data)
-    elseif has_key(a:conn, 'channel_id') && ale#socket#IsOpen(a:conn.channel_id)
-        " Send the message to the server
-        call ale#socket#Send(a:conn.channel_id, a:data)
-    else
-        return 0
-    endif
-
-    return 1
-endfunction
-
-" Send a message to an LSP server.
-" Notifications do not need to be handled.
-"
-" Returns -1 when a message is sent, but no response is expected
-"          0 when the message is not sent and
-"          >= 1 with the message ID when a response is expected.
-function! ale#lsp#Send(conn_id, message) abort
-    let l:conn = get(s:connections, a:conn_id, {})
-
-    if empty(l:conn)
-        return 0
-    endif
-
-    if !l:conn.initialized
-        throw 'LSP server not initialized yet!'
-    endif
-
-    let [l:id, l:data] = ale#lsp#CreateMessageData(a:message)
-    call s:SendMessageData(l:conn, l:data)
-
-    return l:id == 0 ? -1 : l:id
-endfunction
-
-" Notify LSP servers or tsserver if a document is opened, if needed.
-" If a document is opened, 1 will be returned, otherwise 0 will be returned.
-function! ale#lsp#OpenDocument(conn_id, buffer, language_id) abort
-    let l:conn = get(s:connections, a:conn_id, {})
-    let l:opened = 0
-
-    if !empty(l:conn) && !has_key(l:conn.open_documents, a:buffer)
-        if l:conn.is_tsserver
-            let l:message = ale#lsp#tsserver_message#Open(a:buffer)
-        else
-            let l:message = ale#lsp#message#DidOpen(a:buffer, a:language_id)
-        endif
-
-        call ale#lsp#Send(a:conn_id, l:message)
-        let l:conn.open_documents[a:buffer] = getbufvar(a:buffer, 'changedtick')
-        let l:opened = 1
-    endif
-
-    return l:opened
-endfunction
-
-" Notify LSP servers or tsserver that a document is closed, if opened before.
-" If a document is closed, 1 will be returned, otherwise 0 will be returned.
-"
-" Only the buffer number is required here. A message will be sent to every
-" language server that was notified previously of the document being opened.
-function! ale#lsp#CloseDocument(buffer) abort
-    let l:closed = 0
-
-    " The connection keys are sorted so the messages are easier to test, and
-    " so messages are sent in a consistent order.
-    for l:conn_id in sort(keys(s:connections))
-        let l:conn = s:connections[l:conn_id]
-
-        if l:conn.initialized && has_key(l:conn.open_documents, a:buffer)
-            if l:conn.is_tsserver
-                let l:message = ale#lsp#tsserver_message#Close(a:buffer)
-            else
-                let l:message = ale#lsp#message#DidClose(a:buffer)
-            endif
-
-            call ale#lsp#Send(l:conn_id, l:message)
-            call remove(l:conn.open_documents, a:buffer)
-            let l:closed = 1
-        endif
-    endfor
-
-    return l:closed
-endfunction
-
-" Notify LSP servers or tsserver that a document has changed, if needed.
-" If a notification is sent, 1 will be returned, otherwise 0 will be returned.
-function! ale#lsp#NotifyForChanges(conn_id, buffer) abort
-    let l:conn = get(s:connections, a:conn_id, {})
-    let l:notified = 0
-
-    if !empty(l:conn) && has_key(l:conn.open_documents, a:buffer)
-        let l:new_tick = getbufvar(a:buffer, 'changedtick')
-
-        if l:conn.open_documents[a:buffer] < l:new_tick
-            if l:conn.is_tsserver
-                let l:message = ale#lsp#tsserver_message#Change(a:buffer)
-            else
-                let l:message = ale#lsp#message#DidChange(a:buffer)
-            endif
-
-            call ale#lsp#Send(a:conn_id, l:message)
-            let l:conn.open_documents[a:buffer] = l:new_tick
-            let l:notified = 1
-        endif
-    endif
-
-    return l:notified
-endfunction
-
-" Wait for an LSP server to be initialized.
-function! ale#lsp#OnInit(conn_id, Callback) abort
-    let l:conn = get(s:connections, a:conn_id, {})
-
-    if empty(l:conn)
-        return
-    endif
-
-    if l:conn.initialized
-        call a:Callback()
-    else
-        call add(l:conn.init_queue, a:Callback)
-    endif
-endfunction
-
-" Check if an LSP has a given capability.
-function! ale#lsp#HasCapability(conn_id, capability) abort
-    let l:conn = get(s:connections, a:conn_id, {})
-
-    if empty(l:conn)
-        return 0
-    endif
-
-    if type(get(l:conn.capabilities, a:capability, v:null)) isnot v:t_number
-        throw 'Invalid capability ' . a:capability
-    endif
-
-    return l:conn.capabilities[a:capability]
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/lsp/message.vim b/sources_non_forked/ale/autoload/ale/lsp/message.vim
deleted file mode 100644
index 5b0cb8b..0000000
--- a/sources_non_forked/ale/autoload/ale/lsp/message.vim
+++ /dev/null
@@ -1,174 +0,0 @@
-" Author: w0rp <devw0rp@gmail.com>
-" Description: Language Server Protocol message implementations
-"
-" Messages in this movie will be returned in the format
-" [is_notification, method_name, params?]
-"
-" All functions which accept line and column arguments expect them to be 1-based
-" (the same format as being returned by getpos() and friends), those then
-" will be converted to 0-based as specified by LSP.
-let g:ale_lsp_next_version_id = 1
-
-" The LSP protocols demands that we send every change to a document, including
-" undo, with incrementing version numbers, so we'll just use one incrementing
-" ID for everything.
-function! ale#lsp#message#GetNextVersionID() abort
-    " Use the current ID
-    let l:id = g:ale_lsp_next_version_id
-
-    " Increment the ID variable.
-    let g:ale_lsp_next_version_id += 1
-
-    " When the ID overflows, reset it to 1. By the time we hit the initial ID
-    " again, the messages will be long gone.
-    if g:ale_lsp_next_version_id < 1
-        let g:ale_lsp_next_version_id = 1
-    endif
-
-    return l:id
-endfunction
-
-function! ale#lsp#message#Initialize(root_path, options, capabilities) abort
-    " NOTE: rootPath is deprecated in favour of rootUri
-    return [0, 'initialize', {
-    \   'processId': getpid(),
-    \   'rootPath': a:root_path,
-    \   'capabilities': a:capabilities,
-    \   'initializationOptions': a:options,
-    \   'rootUri': ale#path#ToURI(a:root_path),
-    \}]
-endfunction
-
-function! ale#lsp#message#Initialized() abort
-    return [1, 'initialized', {}]
-endfunction
-
-function! ale#lsp#message#Shutdown() abort
-    return [0, 'shutdown']
-endfunction
-
-function! ale#lsp#message#Exit() abort
-    return [1, 'exit']
-endfunction
-
-function! ale#lsp#message#DidOpen(buffer, language_id) abort
-    let l:lines = getbufline(a:buffer, 1, '$')
-
-    return [1, 'textDocument/didOpen', {
-    \   'textDocument': {
-    \       'uri': ale#path#ToURI(expand('#' . a:buffer . ':p')),
-    \       'languageId': a:language_id,
-    \       'version': ale#lsp#message#GetNextVersionID(),
-    \       'text': join(l:lines, "\n") . "\n",
-    \   },
-    \}]
-endfunction
-
-function! ale#lsp#message#DidChange(buffer) abort
-    let l:lines = getbufline(a:buffer, 1, '$')
-
-    " For changes, we simply send the full text of the document to the server.
-    return [1, 'textDocument/didChange', {
-    \   'textDocument': {
-    \       'uri': ale#path#ToURI(expand('#' . a:buffer . ':p')),
-    \       'version': ale#lsp#message#GetNextVersionID(),
-    \   },
-    \   'contentChanges': [{'text': join(l:lines, "\n") . "\n"}]
-    \}]
-endfunction
-
-function! ale#lsp#message#DidSave(buffer) abort
-    return [1, 'textDocument/didSave', {
-    \   'textDocument': {
-    \       'uri': ale#path#ToURI(expand('#' . a:buffer . ':p')),
-    \   },
-    \}]
-endfunction
-
-function! ale#lsp#message#DidClose(buffer) abort
-    return [1, 'textDocument/didClose', {
-    \   'textDocument': {
-    \       'uri': ale#path#ToURI(expand('#' . a:buffer . ':p')),
-    \   },
-    \}]
-endfunction
-
-let s:COMPLETION_TRIGGER_INVOKED = 1
-let s:COMPLETION_TRIGGER_CHARACTER = 2
-
-function! ale#lsp#message#Completion(buffer, line, column, trigger_character) abort
-    let l:message = [0, 'textDocument/completion', {
-    \   'textDocument': {
-    \       'uri': ale#path#ToURI(expand('#' . a:buffer . ':p')),
-    \   },
-    \   'position': {'line': a:line - 1, 'character': a:column - 1},
-    \}]
-
-    if !empty(a:trigger_character)
-        let l:message[2].context = {
-        \   'triggerKind': s:COMPLETION_TRIGGER_CHARACTER,
-        \   'triggerCharacter': a:trigger_character,
-        \}
-    endif
-
-    return l:message
-endfunction
-
-function! ale#lsp#message#Definition(buffer, line, column) abort
-    return [0, 'textDocument/definition', {
-    \   'textDocument': {
-    \       'uri': ale#path#ToURI(expand('#' . a:buffer . ':p')),
-    \   },
-    \   'position': {'line': a:line - 1, 'character': a:column - 1},
-    \}]
-endfunction
-
-function! ale#lsp#message#TypeDefinition(buffer, line, column) abort
-    return [0, 'textDocument/typeDefinition', {
-    \   'textDocument': {
-    \       'uri': ale#path#ToURI(expand('#' . a:buffer . ':p')),
-    \   },
-    \   'position': {'line': a:line - 1, 'character': a:column - 1},
-    \}]
-endfunction
-
-function! ale#lsp#message#References(buffer, line, column) abort
-    return [0, 'textDocument/references', {
-    \   'textDocument': {
-    \       'uri': ale#path#ToURI(expand('#' . a:buffer . ':p')),
-    \   },
-    \   'position': {'line': a:line - 1, 'character': a:column - 1},
-    \   'context': {'includeDeclaration': v:false},
-    \}]
-endfunction
-
-function! ale#lsp#message#Symbol(query) abort
-    return [0, 'workspace/symbol', {
-    \   'query': a:query,
-    \}]
-endfunction
-
-function! ale#lsp#message#Hover(buffer, line, column) abort
-    return [0, 'textDocument/hover', {
-    \   'textDocument': {
-    \       'uri': ale#path#ToURI(expand('#' . a:buffer . ':p')),
-    \   },
-    \   'position': {'line': a:line - 1, 'character': a:column - 1},
-    \}]
-endfunction
-
-function! ale#lsp#message#DidChangeConfiguration(buffer, config) abort
-    return [1, 'workspace/didChangeConfiguration', {
-    \   'settings': a:config,
-    \}]
-endfunction
-
-function! ale#lsp#message#Rename(buffer, line, column, new_name) abort
-    return [0, 'textDocument/rename', {
-    \   'textDocument': {
-    \       'uri': ale#path#ToURI(expand('#' . a:buffer . ':p')),
-    \   },
-    \   'position': {'line': a:line - 1, 'character': a:column - 1},
-    \   'newName': a:new_name,
-    \}]
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/lsp/reset.vim b/sources_non_forked/ale/autoload/ale/lsp/reset.vim
deleted file mode 100644
index 2fc7f0a..0000000
--- a/sources_non_forked/ale/autoload/ale/lsp/reset.vim
+++ /dev/null
@@ -1,25 +0,0 @@
-" Stop all LSPs and remove all of the data for them.
-function! ale#lsp#reset#StopAllLSPs() abort
-    call ale#lsp#StopAll()
-
-    if exists('*ale#definition#ClearLSPData')
-        " Clear the mapping for connections, etc.
-        call ale#definition#ClearLSPData()
-    endif
-
-    if exists('*ale#lsp_linter#ClearLSPData')
-        " Clear the mapping for connections, etc.
-        call ale#lsp_linter#ClearLSPData()
-
-        " Remove the problems for all of the LSP linters in every buffer.
-        for l:buffer_string in keys(g:ale_buffer_info)
-            let l:buffer = str2nr(l:buffer_string)
-
-            for l:linter in ale#linter#Get(getbufvar(l:buffer, '&filetype'))
-                if !empty(l:linter.lsp)
-                    call ale#engine#HandleLoclist(l:linter.name, l:buffer, [], 0)
-                endif
-            endfor
-        endfor
-    endif
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/lsp/response.vim b/sources_non_forked/ale/autoload/ale/lsp/response.vim
deleted file mode 100644
index 30da77e..0000000
--- a/sources_non_forked/ale/autoload/ale/lsp/response.vim
+++ /dev/null
@@ -1,151 +0,0 @@
-" Author: w0rp <devw0rp@gmail.com>
-" Description: Parsing and transforming of LSP server responses.
-
-" Constants for error codes.
-" Defined by JSON RPC
-let s:PARSE_ERROR = -32700
-let s:INVALID_REQUEST = -32600
-let s:METHOD_NOT_FOUND = -32601
-let s:INVALID_PARAMS = -32602
-let s:INTERNAL_ERROR = -32603
-let s:SERVER_ERROR_START = -32099
-let s:SERVER_ERROR_END = -32000
-let s:SERVER_NOT_INITIALIZED = -32002
-let s:UNKNOWN_ERROR_CODE = -32001
-" Defined by the protocol.
-let s:REQUEST_CANCELLED = -32800
-
-" Constants for message severity codes.
-let s:SEVERITY_ERROR = 1
-let s:SEVERITY_WARNING = 2
-let s:SEVERITY_INFORMATION = 3
-let s:SEVERITY_HINT = 4
-
-" Parse the message for textDocument/publishDiagnostics
-function! ale#lsp#response#ReadDiagnostics(response) abort
-    let l:loclist = []
-
-    for l:diagnostic in a:response.params.diagnostics
-        let l:severity = get(l:diagnostic, 'severity', 0)
-        let l:loclist_item = {
-        \   'text': substitute(l:diagnostic.message, '\(\r\n\|\n\|\r\)', ' ', 'g'),
-        \   'type': 'E',
-        \   'lnum': l:diagnostic.range.start.line + 1,
-        \   'col': l:diagnostic.range.start.character + 1,
-        \   'end_lnum': l:diagnostic.range.end.line + 1,
-        \   'end_col': l:diagnostic.range.end.character,
-        \}
-
-        if l:severity == s:SEVERITY_WARNING
-            let l:loclist_item.type = 'W'
-        elseif l:severity == s:SEVERITY_INFORMATION
-            " TODO: Use 'I' here in future.
-            let l:loclist_item.type = 'W'
-        elseif l:severity == s:SEVERITY_HINT
-            " TODO: Use 'H' here in future
-            let l:loclist_item.type = 'W'
-        endif
-
-        if has_key(l:diagnostic, 'code')
-            if type(l:diagnostic.code) == v:t_string
-                let l:loclist_item.code = l:diagnostic.code
-            elseif type(l:diagnostic.code) == v:t_number && l:diagnostic.code != -1
-                let l:loclist_item.code = string(l:diagnostic.code)
-                let l:loclist_item.nr = l:diagnostic.code
-            endif
-        endif
-
-        if has_key(l:diagnostic, 'relatedInformation')
-            let l:related = deepcopy(l:diagnostic.relatedInformation)
-            call map(l:related, {key, val ->
-            \   ale#path#FromURI(val.location.uri) .
-            \   ':' . (val.location.range.start.line + 1) .
-            \   ':' . (val.location.range.start.character + 1) .
-            \   ":\n\t" . val.message
-            \})
-            let l:loclist_item.detail = l:diagnostic.message . "\n" . join(l:related, "\n")
-        endif
-
-        if has_key(l:diagnostic, 'source')
-            let l:loclist_item.detail = printf(
-            \   '[%s] %s',
-            \   l:diagnostic.source,
-            \   l:diagnostic.message
-            \)
-        endif
-
-        call add(l:loclist, l:loclist_item)
-    endfor
-
-    return l:loclist
-endfunction
-
-function! ale#lsp#response#ReadTSServerDiagnostics(response) abort
-    let l:loclist = []
-
-    for l:diagnostic in a:response.body.diagnostics
-        let l:loclist_item = {
-        \   'text': l:diagnostic.text,
-        \   'type': 'E',
-        \   'lnum': l:diagnostic.start.line,
-        \   'col': l:diagnostic.start.offset,
-        \   'end_lnum': l:diagnostic.end.line,
-        \   'end_col': l:diagnostic.end.offset - 1,
-        \}
-
-        if has_key(l:diagnostic, 'code')
-            if type(l:diagnostic.code) == v:t_string
-                let l:loclist_item.code = l:diagnostic.code
-            elseif type(l:diagnostic.code) == v:t_number && l:diagnostic.code != -1
-                let l:loclist_item.code = string(l:diagnostic.code)
-                let l:loclist_item.nr = l:diagnostic.code
-            endif
-        endif
-
-        if get(l:diagnostic, 'category') is# 'warning'
-            let l:loclist_item.type = 'W'
-        endif
-
-        if get(l:diagnostic, 'category') is# 'suggestion'
-            let l:loclist_item.type = 'I'
-        endif
-
-        call add(l:loclist, l:loclist_item)
-    endfor
-
-    return l:loclist
-endfunction
-
-function! ale#lsp#response#GetErrorMessage(response) abort
-    if type(get(a:response, 'error', 0)) isnot v:t_dict
-        return ''
-    endif
-
-    let l:code = get(a:response.error, 'code')
-
-    " Only report things for these error codes.
-    if l:code isnot s:INVALID_PARAMS && l:code isnot s:INTERNAL_ERROR
-        return ''
-    endif
-
-    let l:message = get(a:response.error, 'message', '')
-
-    if empty(l:message)
-        return ''
-    endif
-
-    " Include the traceback or error data as details, if present.
-    let l:error_data = get(a:response.error, 'data', {})
-
-    if type(l:error_data) is v:t_string
-        let l:message .= "\n" . l:error_data
-    elseif type(l:error_data) is v:t_dict
-        let l:traceback = get(l:error_data, 'traceback', [])
-
-        if type(l:traceback) is v:t_list && !empty(l:traceback)
-            let l:message .= "\n" . join(l:traceback, "\n")
-        endif
-    endif
-
-    return l:message
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/lsp/tsserver_message.vim b/sources_non_forked/ale/autoload/ale/lsp/tsserver_message.vim
deleted file mode 100644
index b9fafaa..0000000
--- a/sources_non_forked/ale/autoload/ale/lsp/tsserver_message.vim
+++ /dev/null
@@ -1,105 +0,0 @@
-" Author: w0rp <devw0rp@gmail.com>
-" Description: tsserver message implementations
-"
-" Messages in this movie will be returned in the format
-" [is_notification, command_name, params?]
-"
-" Every command must begin with the string 'ts@', which will be used to
-" detect the different message format for tsserver, and this string will
-" be removed from the actual command name,
-
-function! ale#lsp#tsserver_message#Open(buffer) abort
-    return [1, 'ts@open', {'file': expand('#' . a:buffer . ':p')}]
-endfunction
-
-function! ale#lsp#tsserver_message#Close(buffer) abort
-    return [1, 'ts@close', {'file': expand('#' . a:buffer . ':p')}]
-endfunction
-
-function! ale#lsp#tsserver_message#Change(buffer) abort
-    let l:lines = getbufline(a:buffer, 1, '$')
-
-    " We will always use a very high endLine number, so we can delete
-    " lines from files. tsserver will gladly accept line numbers beyond the
-    " end.
-    return [1, 'ts@change', {
-    \   'file': expand('#' . a:buffer . ':p'),
-    \   'line': 1,
-    \   'offset': 1,
-    \   'endLine': 1073741824,
-    \   'endOffset': 1,
-    \   'insertString': join(l:lines, "\n") . "\n",
-    \}]
-endfunction
-
-function! ale#lsp#tsserver_message#Geterr(buffer) abort
-    return [1, 'ts@geterr', {'files': [expand('#' . a:buffer . ':p')]}]
-endfunction
-
-function! ale#lsp#tsserver_message#Completions(
-\ buffer, line, column, prefix, include_external) abort
-    return [0, 'ts@completions', {
-    \   'line': a:line,
-    \   'offset': a:column,
-    \   'file': expand('#' . a:buffer . ':p'),
-    \   'prefix': a:prefix,
-    \   'includeExternalModuleExports': a:include_external,
-    \}]
-endfunction
-
-function! ale#lsp#tsserver_message#CompletionEntryDetails(buffer, line, column, entry_names) abort
-    return [0, 'ts@completionEntryDetails', {
-    \   'line': a:line,
-    \   'offset': a:column,
-    \   'file': expand('#' . a:buffer . ':p'),
-    \   'entryNames': a:entry_names,
-    \}]
-endfunction
-
-function! ale#lsp#tsserver_message#Definition(buffer, line, column) abort
-    return [0, 'ts@definition', {
-    \   'line': a:line,
-    \   'offset': a:column,
-    \   'file': expand('#' . a:buffer . ':p'),
-    \}]
-endfunction
-
-function! ale#lsp#tsserver_message#References(buffer, line, column) abort
-    return [0, 'ts@references', {
-    \   'line': a:line,
-    \   'offset': a:column,
-    \   'file': expand('#' . a:buffer . ':p'),
-    \}]
-endfunction
-
-function! ale#lsp#tsserver_message#Quickinfo(buffer, line, column) abort
-    return [0, 'ts@quickinfo', {
-    \   'line': a:line,
-    \   'offset': a:column,
-    \   'file': expand('#' . a:buffer . ':p'),
-    \}]
-endfunction
-
-function! ale#lsp#tsserver_message#Rename(
-\ buffer, line, column, find_in_comments, find_in_strings) abort
-    return [0, 'ts@rename', {
-    \   'line': a:line,
-    \   'offset': a:column,
-    \   'file': expand('#' . a:buffer . ':p'),
-    \   'arguments': {
-    \       'findInComments': a:find_in_comments,
-    \       'findInStrings': a:find_in_strings,
-    \   }
-    \}]
-endfunction
-
-function! ale#lsp#tsserver_message#OrganizeImports(buffer) abort
-    return [0, 'ts@organizeImports', {
-    \   'scope': {
-    \       'type': 'file',
-    \       'args': {
-    \           'file': expand('#' . a:buffer . ':p'),
-    \       },
-    \   },
-    \}]
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/lsp_linter.vim b/sources_non_forked/ale/autoload/ale/lsp_linter.vim
deleted file mode 100644
index e4148ce..0000000
--- a/sources_non_forked/ale/autoload/ale/lsp_linter.vim
+++ /dev/null
@@ -1,472 +0,0 @@
-" Author: w0rp <devw0rp@gmail.com>
-" Description: Integration between linters and LSP/tsserver.
-
-" This code isn't loaded if a user never users LSP features or linters.
-
-" Associates LSP connection IDs with linter names.
-if !has_key(s:, 'lsp_linter_map')
-    let s:lsp_linter_map = {}
-endif
-
-" A Dictionary to track one-shot handlers for custom LSP requests
-let s:custom_handlers_map = get(s:, 'custom_handlers_map', {})
-
-" Check if diagnostics for a particular linter should be ignored.
-function! s:ShouldIgnore(buffer, linter_name) abort
-    " Ignore all diagnostics if LSP integration is disabled.
-    if ale#Var(a:buffer, 'disable_lsp')
-        return 1
-    endif
-
-    let l:config = ale#Var(a:buffer, 'linters_ignore')
-
-    " Don't load code for ignoring diagnostics if there's nothing to ignore.
-    if empty(l:config)
-        return 0
-    endif
-
-    let l:filetype = getbufvar(a:buffer, '&filetype')
-    let l:ignore_list = ale#engine#ignore#GetList(l:filetype, l:config)
-
-    return index(l:ignore_list, a:linter_name) >= 0
-endfunction
-
-function! s:HandleLSPDiagnostics(conn_id, response) abort
-    let l:linter_name = s:lsp_linter_map[a:conn_id]
-    let l:filename = ale#path#FromURI(a:response.params.uri)
-    let l:buffer = bufnr('^' . l:filename . '$')
-    let l:info = get(g:ale_buffer_info, l:buffer, {})
-
-    if empty(l:info)
-        return
-    endif
-
-    if s:ShouldIgnore(l:buffer, l:linter_name)
-        return
-    endif
-
-    let l:loclist = ale#lsp#response#ReadDiagnostics(a:response)
-
-    call ale#engine#HandleLoclist(l:linter_name, l:buffer, l:loclist, 0)
-endfunction
-
-function! s:HandleTSServerDiagnostics(response, error_type) abort
-    let l:linter_name = 'tsserver'
-    let l:buffer = bufnr('^' . a:response.body.file . '$')
-    let l:info = get(g:ale_buffer_info, l:buffer, {})
-
-    if empty(l:info)
-        return
-    endif
-
-    call ale#engine#MarkLinterInactive(l:info, l:linter_name)
-
-    if s:ShouldIgnore(l:buffer, l:linter_name)
-        return
-    endif
-
-    let l:thislist = ale#lsp#response#ReadTSServerDiagnostics(a:response)
-    let l:no_changes = 0
-
-    " tsserver sends syntax and semantic errors in separate messages, so we
-    " have to collect the messages separately for each buffer and join them
-    " back together again.
-    if a:error_type is# 'syntax'
-        if len(l:thislist) is 0 && len(get(l:info, 'syntax_loclist', [])) is 0
-            let l:no_changes = 1
-        endif
-
-        let l:info.syntax_loclist = l:thislist
-    else
-        if len(l:thislist) is 0 && len(get(l:info, 'semantic_loclist', [])) is 0
-            let l:no_changes = 1
-        endif
-
-        let l:info.semantic_loclist = l:thislist
-    endif
-
-    if l:no_changes
-        return
-    endif
-
-    let l:loclist = get(l:info, 'semantic_loclist', [])
-    \   + get(l:info, 'syntax_loclist', [])
-
-    call ale#engine#HandleLoclist(l:linter_name, l:buffer, l:loclist, 0)
-endfunction
-
-function! s:HandleLSPErrorMessage(linter_name, response) abort
-    if !g:ale_history_enabled || !g:ale_history_log_output
-        return
-    endif
-
-    if empty(a:linter_name)
-        return
-    endif
-
-    let l:message = ale#lsp#response#GetErrorMessage(a:response)
-
-    if empty(l:message)
-        return
-    endif
-
-    " This global variable is set here so we don't load the debugging.vim file
-    " until someone uses :ALEInfo.
-    let g:ale_lsp_error_messages = get(g:, 'ale_lsp_error_messages', {})
-
-    if !has_key(g:ale_lsp_error_messages, a:linter_name)
-        let g:ale_lsp_error_messages[a:linter_name] = []
-    endif
-
-    call add(g:ale_lsp_error_messages[a:linter_name], l:message)
-endfunction
-
-function! ale#lsp_linter#HandleLSPResponse(conn_id, response) abort
-    let l:method = get(a:response, 'method', '')
-
-    if get(a:response, 'jsonrpc', '') is# '2.0' && has_key(a:response, 'error')
-        let l:linter_name = get(s:lsp_linter_map, a:conn_id, '')
-
-        call s:HandleLSPErrorMessage(l:linter_name, a:response)
-    elseif l:method is# 'textDocument/publishDiagnostics'
-        call s:HandleLSPDiagnostics(a:conn_id, a:response)
-    elseif l:method is# 'window/showMessage'
-        call ale#lsp_window#HandleShowMessage(
-        \   s:lsp_linter_map[a:conn_id],
-        \   g:ale_lsp_show_message_format,
-        \   a:response.params
-        \)
-    elseif get(a:response, 'type', '') is# 'event'
-    \&& get(a:response, 'event', '') is# 'semanticDiag'
-        call s:HandleTSServerDiagnostics(a:response, 'semantic')
-    elseif get(a:response, 'type', '') is# 'event'
-    \&& get(a:response, 'event', '') is# 'syntaxDiag'
-        call s:HandleTSServerDiagnostics(a:response, 'syntax')
-    endif
-endfunction
-
-function! ale#lsp_linter#GetOptions(buffer, linter) abort
-    if has_key(a:linter, 'initialization_options_callback')
-        return ale#util#GetFunction(a:linter.initialization_options_callback)(a:buffer)
-    endif
-
-    if has_key(a:linter, 'initialization_options')
-        let l:Options = a:linter.initialization_options
-
-        if type(l:Options) is v:t_func
-            let l:Options = l:Options(a:buffer)
-        endif
-
-        return l:Options
-    endif
-
-    return {}
-endfunction
-
-function! ale#lsp_linter#GetConfig(buffer, linter) abort
-    if has_key(a:linter, 'lsp_config_callback')
-        return ale#util#GetFunction(a:linter.lsp_config_callback)(a:buffer)
-    endif
-
-    if has_key(a:linter, 'lsp_config')
-        let l:Config = a:linter.lsp_config
-
-        if type(l:Config) is v:t_func
-            let l:Config = l:Config(a:buffer)
-        endif
-
-        return l:Config
-    endif
-
-    return {}
-endfunction
-
-function! ale#lsp_linter#FindProjectRoot(buffer, linter) abort
-    let l:buffer_ale_root = getbufvar(a:buffer, 'ale_lsp_root', {})
-
-    if type(l:buffer_ale_root) is v:t_string
-        return l:buffer_ale_root
-    endif
-
-    " Try to get a buffer-local setting for the root
-    if has_key(l:buffer_ale_root, a:linter.name)
-        let l:Root = l:buffer_ale_root[a:linter.name]
-
-        if type(l:Root) is v:t_func
-            return l:Root(a:buffer)
-        else
-            return l:Root
-        endif
-    endif
-
-    " Try to get a global setting for the root
-    if has_key(g:ale_lsp_root, a:linter.name)
-        let l:Root = g:ale_lsp_root[a:linter.name]
-
-        if type(l:Root) is v:t_func
-            return l:Root(a:buffer)
-        else
-            return l:Root
-        endif
-    endif
-
-    " Fall back to the linter-specific configuration
-    if has_key(a:linter, 'project_root')
-        let l:Root = a:linter.project_root
-
-        return type(l:Root) is v:t_func ? l:Root(a:buffer) : l:Root
-    endif
-
-    return ale#util#GetFunction(a:linter.project_root_callback)(a:buffer)
-endfunction
-
-" This function is accessible so tests can call it.
-function! ale#lsp_linter#OnInit(linter, details, Callback) abort
-    let l:buffer = a:details.buffer
-    let l:conn_id = a:details.connection_id
-    let l:command = a:details.command
-
-    let l:config = ale#lsp_linter#GetConfig(l:buffer, a:linter)
-    let l:language_id = ale#util#GetFunction(a:linter.language_callback)(l:buffer)
-
-    call ale#lsp#UpdateConfig(l:conn_id, l:buffer, l:config)
-
-    if ale#lsp#OpenDocument(l:conn_id, l:buffer, l:language_id)
-        if g:ale_history_enabled && !empty(l:command)
-            call ale#history#Add(l:buffer, 'started', l:conn_id, l:command)
-        endif
-    endif
-
-    " The change message needs to be sent for tsserver before doing anything.
-    if a:linter.lsp is# 'tsserver'
-        call ale#lsp#NotifyForChanges(l:conn_id, l:buffer)
-    endif
-
-    call a:Callback(a:linter, a:details)
-endfunction
-
-function! s:StartLSP(options, address, executable, command) abort
-    let l:buffer = a:options.buffer
-    let l:linter = a:options.linter
-    let l:root = a:options.root
-    let l:Callback = a:options.callback
-
-    let l:init_options = ale#lsp_linter#GetOptions(l:buffer, l:linter)
-
-    if l:linter.lsp is# 'socket'
-        let l:conn_id = ale#lsp#Register(a:address, l:root, l:init_options)
-        let l:ready = ale#lsp#ConnectToAddress(l:conn_id, a:address)
-        let l:command = ''
-    else
-        let l:conn_id = ale#lsp#Register(a:executable, l:root, l:init_options)
-
-        " tsserver behaves differently, so tell the LSP API that it is tsserver.
-        if l:linter.lsp is# 'tsserver'
-            call ale#lsp#MarkConnectionAsTsserver(l:conn_id)
-        endif
-
-        let l:command = ale#command#FormatCommand(l:buffer, a:executable, a:command, 0, v:false)[1]
-        let l:command = ale#job#PrepareCommand(l:buffer, l:command)
-        let l:ready = ale#lsp#StartProgram(l:conn_id, a:executable, l:command)
-    endif
-
-    if !l:ready
-        if g:ale_history_enabled && !empty(a:command)
-            call ale#history#Add(l:buffer, 'failed', l:conn_id, a:command)
-        endif
-
-        return 0
-    endif
-
-    let l:details = {
-    \   'buffer': l:buffer,
-    \   'connection_id': l:conn_id,
-    \   'command': l:command,
-    \   'project_root': l:root,
-    \}
-
-    call ale#lsp#OnInit(l:conn_id, {->
-    \   ale#lsp_linter#OnInit(l:linter, l:details, l:Callback)
-    \})
-
-    return 1
-endfunction
-
-function! s:StartWithAddress(options, address) abort
-    if ale#command#IsDeferred(a:address)
-        let a:address.result_callback = {
-        \   address -> s:StartWithAddress(a:options, address)
-        \}
-
-        return 1
-    endif
-
-    if empty(a:address)
-        return 0
-    endif
-
-    return s:StartLSP(a:options, a:address, '', '')
-endfunction
-
-function! s:StartWithCommand(options, executable, command) abort
-    if ale#command#IsDeferred(a:command)
-        let a:command.result_callback = {
-        \   command -> s:StartWithCommand(a:options, a:executable, command)
-        \}
-
-        return 1
-    endif
-
-    if empty(a:command)
-        return 0
-    endif
-
-    return s:StartLSP(a:options, '', a:executable, a:command)
-endfunction
-
-function! s:StartIfExecutable(options, executable) abort
-    if ale#command#IsDeferred(a:executable)
-        let a:executable.result_callback = {
-        \   executable -> s:StartIfExecutable(a:options, executable)
-        \}
-
-        return 1
-    endif
-
-    if !ale#engine#IsExecutable(a:options.buffer, a:executable)
-        return 0
-    endif
-
-    let l:command = ale#linter#GetCommand(a:options.buffer, a:options.linter)
-
-    return s:StartWithCommand(a:options, a:executable, l:command)
-endfunction
-
-" Given a buffer, an LSP linter, start up an LSP linter and get ready to
-" receive messages for the document.
-function! ale#lsp_linter#StartLSP(buffer, linter, Callback) abort
-    let l:command = ''
-    let l:address = ''
-    let l:root = ale#lsp_linter#FindProjectRoot(a:buffer, a:linter)
-
-    if empty(l:root) && a:linter.lsp isnot# 'tsserver'
-        " If there's no project root, then we can't check files with LSP,
-        " unless we are using tsserver, which doesn't use project roots.
-        return 0
-    endif
-
-    let l:options = {
-    \   'buffer': a:buffer,
-    \   'linter': a:linter,
-    \   'callback': a:Callback,
-    \   'root': l:root,
-    \}
-
-    if a:linter.lsp is# 'socket'
-        let l:address = ale#linter#GetAddress(a:buffer, a:linter)
-
-        return s:StartWithAddress(l:options, l:address)
-    endif
-
-    let l:executable = ale#linter#GetExecutable(a:buffer, a:linter)
-
-    return s:StartIfExecutable(l:options, l:executable)
-endfunction
-
-function! s:CheckWithLSP(linter, details) abort
-    let l:buffer = a:details.buffer
-    let l:info = get(g:ale_buffer_info, l:buffer)
-
-    if empty(l:info)
-        return
-    endif
-
-    let l:id = a:details.connection_id
-
-    " Register a callback now for handling errors now.
-    let l:Callback = function('ale#lsp_linter#HandleLSPResponse')
-    call ale#lsp#RegisterCallback(l:id, l:Callback)
-
-    " Remember the linter this connection is for.
-    let s:lsp_linter_map[l:id] = a:linter.name
-
-    if a:linter.lsp is# 'tsserver'
-        let l:message = ale#lsp#tsserver_message#Geterr(l:buffer)
-        let l:notified = ale#lsp#Send(l:id, l:message) != 0
-
-        if l:notified
-            call ale#engine#MarkLinterActive(l:info, a:linter)
-        endif
-    else
-        let l:notified = ale#lsp#NotifyForChanges(l:id, l:buffer)
-    endif
-
-    " If this was a file save event, also notify the server of that.
-    if a:linter.lsp isnot# 'tsserver'
-    \&& getbufvar(l:buffer, 'ale_save_event_fired', 0)
-        let l:save_message = ale#lsp#message#DidSave(l:buffer)
-        let l:notified = ale#lsp#Send(l:id, l:save_message) != 0
-    endif
-endfunction
-
-function! ale#lsp_linter#CheckWithLSP(buffer, linter) abort
-    return ale#lsp_linter#StartLSP(a:buffer, a:linter, function('s:CheckWithLSP'))
-endfunction
-
-" Clear LSP linter data for the linting engine.
-function! ale#lsp_linter#ClearLSPData() abort
-    let s:lsp_linter_map = {}
-    let s:custom_handlers_map = {}
-endfunction
-
-" Just for tests.
-function! ale#lsp_linter#SetLSPLinterMap(replacement_map) abort
-    let s:lsp_linter_map = a:replacement_map
-endfunction
-
-function! s:HandleLSPResponseToCustomRequests(conn_id, response) abort
-    if has_key(a:response, 'id')
-    \&& has_key(s:custom_handlers_map, a:response.id)
-        let l:Handler = remove(s:custom_handlers_map, a:response.id)
-        call l:Handler(a:response)
-    endif
-endfunction
-
-function! s:OnReadyForCustomRequests(args, linter, lsp_details) abort
-    let l:id = a:lsp_details.connection_id
-    let l:request_id = ale#lsp#Send(l:id, a:args.message)
-
-    if l:request_id > 0 && has_key(a:args, 'handler')
-        let l:Callback = function('s:HandleLSPResponseToCustomRequests')
-        call ale#lsp#RegisterCallback(l:id, l:Callback)
-        let s:custom_handlers_map[l:request_id] = a:args.handler
-    endif
-endfunction
-
-" Send a custom request to an LSP linter.
-function! ale#lsp_linter#SendRequest(buffer, linter_name, message, ...) abort
-    let l:filetype = ale#linter#ResolveFiletype(getbufvar(a:buffer, '&filetype'))
-    let l:linter_list = ale#linter#GetAll(l:filetype)
-    let l:linter_list = filter(l:linter_list, {_, v -> v.name is# a:linter_name})
-
-    if len(l:linter_list) < 1
-        throw 'Linter "' . a:linter_name . '" not found!'
-    endif
-
-    let l:linter = l:linter_list[0]
-
-    if empty(l:linter.lsp)
-        throw 'Linter "' . a:linter_name . '" does not support LSP!'
-    endif
-
-    let l:is_notification = a:message[0]
-    let l:callback_args = {'message': a:message}
-
-    if !l:is_notification && a:0
-        let l:callback_args.handler = a:1
-    endif
-
-    let l:Callback = function('s:OnReadyForCustomRequests', [l:callback_args])
-
-    return ale#lsp_linter#StartLSP(a:buffer, l:linter, l:Callback)
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/lsp_window.vim b/sources_non_forked/ale/autoload/ale/lsp_window.vim
deleted file mode 100644
index 9a27f2f..0000000
--- a/sources_non_forked/ale/autoload/ale/lsp_window.vim
+++ /dev/null
@@ -1,58 +0,0 @@
-" Author: suoto <andre820@gmail.com>
-" Description: Handling of window/* LSP methods, although right now only
-" handles window/showMessage
-
-" Constants for message type codes
-let s:LSP_MESSAGE_TYPE_DISABLED = 0
-let s:LSP_MESSAGE_TYPE_ERROR = 1
-let s:LSP_MESSAGE_TYPE_WARNING = 2
-let s:LSP_MESSAGE_TYPE_INFORMATION = 3
-let s:LSP_MESSAGE_TYPE_LOG = 4
-
-" Translate strings from the user config to a number so we can check
-" severities
-let s:CFG_TO_LSP_SEVERITY = {
-\   'disabled': s:LSP_MESSAGE_TYPE_DISABLED,
-\   'error': s:LSP_MESSAGE_TYPE_ERROR,
-\   'warning': s:LSP_MESSAGE_TYPE_WARNING,
-\   'information': s:LSP_MESSAGE_TYPE_INFORMATION,
-\   'info': s:LSP_MESSAGE_TYPE_INFORMATION,
-\   'log': s:LSP_MESSAGE_TYPE_LOG
-\}
-
-" Handle window/showMessage response.
-" - details: dict containing linter name and format (g:ale_lsp_show_message_format)
-" - params: dict with the params for the call in the form of {type: number, message: string}
-function! ale#lsp_window#HandleShowMessage(linter_name, format, params) abort
-    let l:message = a:params.message
-    let l:type = a:params.type
-
-    " Get the configured severity level threshold and check if the message
-    " should be displayed or not
-    let l:configured_severity = tolower(get(g:, 'ale_lsp_show_message_severity', 'error'))
-    " If the user has configured with a value we can't find on the conversion
-    " dict, fall back to warning
-    let l:cfg_severity_threshold = get(s:CFG_TO_LSP_SEVERITY, l:configured_severity, s:LSP_MESSAGE_TYPE_WARNING)
-
-    if l:type > l:cfg_severity_threshold
-        return
-    endif
-
-    " Severity will depend on the message type
-    if l:type is# s:LSP_MESSAGE_TYPE_ERROR
-        let l:severity = g:ale_echo_msg_error_str
-    elseif l:type is# s:LSP_MESSAGE_TYPE_INFORMATION
-        let l:severity = g:ale_echo_msg_info_str
-    elseif l:type is# s:LSP_MESSAGE_TYPE_LOG
-        let l:severity = g:ale_echo_msg_log_str
-    else
-        " Default to warning just in case
-        let l:severity = g:ale_echo_msg_warning_str
-    endif
-
-    let l:string = substitute(a:format, '\V%severity%', l:severity, 'g')
-    let l:string = substitute(l:string, '\V%linter%', a:linter_name, 'g')
-    let l:string = substitute(l:string, '\V%s\>', l:message, 'g')
-
-    call ale#util#ShowMessage(l:string)
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/node.vim b/sources_non_forked/ale/autoload/ale/node.vim
deleted file mode 100644
index 6906012..0000000
--- a/sources_non_forked/ale/autoload/ale/node.vim
+++ /dev/null
@@ -1,42 +0,0 @@
-" Author: w0rp <devw0rp@gmail.com>
-" Description: Functions for working with Node executables.
-
-call ale#Set('windows_node_executable_path', 'node.exe')
-
-" Given a buffer number, a base variable name, and a list of paths to search
-" for in ancestor directories, detect the executable path for a Node program.
-"
-" The use_global and executable options for the relevant program will be used.
-function! ale#node#FindExecutable(buffer, base_var_name, path_list) abort
-    if ale#Var(a:buffer, a:base_var_name . '_use_global')
-        return ale#Var(a:buffer, a:base_var_name . '_executable')
-    endif
-
-    for l:path in a:path_list
-        let l:executable = ale#path#FindNearestFile(a:buffer, l:path)
-
-        if !empty(l:executable)
-            return l:executable
-        endif
-    endfor
-
-    return ale#Var(a:buffer, a:base_var_name . '_executable')
-endfunction
-
-" Create a executable string which executes a Node.js script command with a
-" Node.js executable if needed.
-"
-" The executable string should not be escaped before passing it to this
-" function, the executable string will be escaped when returned by this
-" function.
-"
-" The executable is only prefixed for Windows machines
-function! ale#node#Executable(buffer, executable) abort
-    if has('win32') && a:executable =~? '\.js$'
-        let l:node = ale#Var(a:buffer, 'windows_node_executable_path')
-
-        return ale#Escape(l:node) . ' ' . ale#Escape(a:executable)
-    endif
-
-    return ale#Escape(a:executable)
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/organize_imports.vim b/sources_non_forked/ale/autoload/ale/organize_imports.vim
deleted file mode 100644
index e89c832..0000000
--- a/sources_non_forked/ale/autoload/ale/organize_imports.vim
+++ /dev/null
@@ -1,59 +0,0 @@
-" Author: Jerko Steiner <jerko.steiner@gmail.com>
-" Description: Organize imports support for tsserver
-"
-function! ale#organize_imports#HandleTSServerResponse(conn_id, response) abort
-    if get(a:response, 'command', '') isnot# 'organizeImports'
-        return
-    endif
-
-    if get(a:response, 'success', v:false) isnot v:true
-        return
-    endif
-
-    let l:file_code_edits =  a:response.body
-
-    call ale#code_action#HandleCodeAction({
-    \   'description': 'Organize Imports',
-    \   'changes': l:file_code_edits,
-    \}, v:false)
-endfunction
-
-function! s:OnReady(linter, lsp_details) abort
-    let l:id = a:lsp_details.connection_id
-
-    if a:linter.lsp isnot# 'tsserver'
-        call ale#util#Execute('echom ''OrganizeImports currently only works with tsserver''')
-
-        return
-    endif
-
-    let l:buffer = a:lsp_details.buffer
-
-    let l:Callback = function('ale#organize_imports#HandleTSServerResponse')
-
-    call ale#lsp#RegisterCallback(l:id, l:Callback)
-
-    let l:message = ale#lsp#tsserver_message#OrganizeImports(l:buffer)
-
-    let l:request_id = ale#lsp#Send(l:id, l:message)
-endfunction
-
-function! s:OrganizeImports(linter) abort
-    let l:buffer = bufnr('')
-    let [l:line, l:column] = getpos('.')[1:2]
-
-    if a:linter.lsp isnot# 'tsserver'
-        let l:column = min([l:column, len(getline(l:line))])
-    endif
-
-    let l:Callback = function('s:OnReady')
-    call ale#lsp_linter#StartLSP(l:buffer, a:linter, l:Callback)
-endfunction
-
-function! ale#organize_imports#Execute() abort
-    for l:linter in ale#linter#Get(&filetype)
-        if !empty(l:linter.lsp)
-            call s:OrganizeImports(l:linter)
-        endif
-    endfor
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/other_source.vim b/sources_non_forked/ale/autoload/ale/other_source.vim
deleted file mode 100644
index 1a09203..0000000
--- a/sources_non_forked/ale/autoload/ale/other_source.vim
+++ /dev/null
@@ -1,21 +0,0 @@
-" Tell ALE that another source has started checking a buffer.
-function! ale#other_source#StartChecking(buffer, linter_name) abort
-    call ale#engine#InitBufferInfo(a:buffer)
-    let l:list = g:ale_buffer_info[a:buffer].active_other_sources_list
-
-    call add(l:list, a:linter_name)
-    call uniq(sort(l:list))
-endfunction
-
-" Show some results, and stop checking a buffer.
-" To clear results or cancel checking a buffer, an empty List can be given.
-function! ale#other_source#ShowResults(buffer, linter_name, loclist) abort
-    call ale#engine#InitBufferInfo(a:buffer)
-    let l:info = g:ale_buffer_info[a:buffer]
-
-    " Remove this linter name from the active list.
-    let l:list = l:info.active_other_sources_list
-    call filter(l:list, 'v:val isnot# a:linter_name')
-
-    call ale#engine#HandleLoclist(a:linter_name, a:buffer, a:loclist, 1)
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/path.vim b/sources_non_forked/ale/autoload/ale/path.vim
deleted file mode 100644
index 3055050..0000000
--- a/sources_non_forked/ale/autoload/ale/path.vim
+++ /dev/null
@@ -1,224 +0,0 @@
-" Author: w0rp <devw0rp@gmail.com>
-" Description: Functions for working with paths in the filesystem.
-
-" simplify a path, and fix annoying issues with paths on Windows.
-"
-" Forward slashes are changed to back slashes so path equality works better
-" on Windows. Back slashes are changed to forward slashes on Unix.
-"
-" Unix paths can technically contain back slashes, but in practice no path
-" should, and replacing back slashes with forward slashes makes linters work
-" in environments like MSYS.
-"
-" Paths starting with more than one forward slash are changed to only one
-" forward slash, to prevent the paths being treated as special MSYS paths.
-function! ale#path#Simplify(path) abort
-    if has('unix')
-        let l:unix_path = substitute(a:path, '\\', '/', 'g')
-
-        return substitute(simplify(l:unix_path), '^//\+', '/', 'g') " no-custom-checks
-    endif
-
-    let l:win_path = substitute(a:path, '/', '\\', 'g')
-
-    return substitute(simplify(l:win_path), '^\\\+', '\', 'g') " no-custom-checks
-endfunction
-
-" Given a buffer and a filename, find the nearest file by searching upwards
-" through the paths relative to the given buffer.
-function! ale#path#FindNearestFile(buffer, filename) abort
-    let l:buffer_filename = fnamemodify(bufname(a:buffer), ':p')
-    let l:buffer_filename = fnameescape(l:buffer_filename)
-
-    let l:relative_path = findfile(a:filename, l:buffer_filename . ';')
-
-    if !empty(l:relative_path)
-        return fnamemodify(l:relative_path, ':p')
-    endif
-
-    return ''
-endfunction
-
-" Given a buffer and a directory name, find the nearest directory by searching upwards
-" through the paths relative to the given buffer.
-function! ale#path#FindNearestDirectory(buffer, directory_name) abort
-    let l:buffer_filename = fnamemodify(bufname(a:buffer), ':p')
-    let l:buffer_filename = fnameescape(l:buffer_filename)
-
-    let l:relative_path = finddir(a:directory_name, l:buffer_filename . ';')
-
-    if !empty(l:relative_path)
-        return fnamemodify(l:relative_path, ':p')
-    endif
-
-    return ''
-endfunction
-
-" Given a buffer, a string to search for, and a global fallback for when
-" the search fails, look for a file in parent paths, and if that fails,
-" use the global fallback path instead.
-function! ale#path#ResolveLocalPath(buffer, search_string, global_fallback) abort
-    " Search for a locally installed file first.
-    let l:path = ale#path#FindNearestFile(a:buffer, a:search_string)
-
-    " If the search fails, try the global executable instead.
-    if empty(l:path)
-        let l:path = a:global_fallback
-    endif
-
-    return l:path
-endfunction
-
-" Output 'cd <directory> && '
-" This function can be used changing the directory for a linter command.
-function! ale#path#CdString(directory) abort
-    if has('win32')
-        return 'cd /d ' . ale#Escape(a:directory) . ' && '
-    else
-        return 'cd ' . ale#Escape(a:directory) . ' && '
-    endif
-endfunction
-
-" Output 'cd <buffer_filename_directory> && '
-" This function can be used changing the directory for a linter command.
-function! ale#path#BufferCdString(buffer) abort
-    return ale#path#CdString(fnamemodify(bufname(a:buffer), ':p:h'))
-endfunction
-
-" Return 1 if a path is an absolute path.
-function! ale#path#IsAbsolute(filename) abort
-    if has('win32') && a:filename[:0] is# '\'
-        return 1
-    endif
-
-    " Check for /foo and C:\foo, etc.
-    return a:filename[:0] is# '/' || a:filename[1:2] is# ':\'
-endfunction
-
-let s:temp_dir = ale#path#Simplify(fnamemodify(ale#util#Tempname(), ':h'))
-
-" Given a filename, return 1 if the file represents some temporary file
-" created by Vim.
-function! ale#path#IsTempName(filename) abort
-    return ale#path#Simplify(a:filename)[:len(s:temp_dir) - 1] is# s:temp_dir
-endfunction
-
-" Given a base directory, which must not have a trailing slash, and a
-" filename, which may have an absolute path a path relative to the base
-" directory, return the absolute path to the file.
-function! ale#path#GetAbsPath(base_directory, filename) abort
-    if ale#path#IsAbsolute(a:filename)
-        return ale#path#Simplify(a:filename)
-    endif
-
-    let l:sep = has('win32') ? '\' : '/'
-
-    return ale#path#Simplify(a:base_directory . l:sep . a:filename)
-endfunction
-
-" Given a path, return the directory name for that path, with no trailing
-" slashes. If the argument is empty(), return an empty string.
-function! ale#path#Dirname(path) abort
-    if empty(a:path)
-        return ''
-    endif
-
-    " For /foo/bar/ we need :h:h to get /foo
-    if a:path[-1:] is# '/'
-        return fnamemodify(a:path, ':h:h')
-    endif
-
-    return fnamemodify(a:path, ':h')
-endfunction
-
-" Given a buffer number and a relative or absolute path, return 1 if the
-" two paths represent the same file on disk.
-function! ale#path#IsBufferPath(buffer, complex_filename) abort
-    " If the path is one of many different names for stdin, we have a match.
-    if a:complex_filename is# '-'
-    \|| a:complex_filename is# 'stdin'
-    \|| a:complex_filename[:0] is# '<'
-        return 1
-    endif
-
-    let l:test_filename = ale#path#Simplify(a:complex_filename)
-
-    if l:test_filename[:1] is# './'
-        let l:test_filename = l:test_filename[2:]
-    endif
-
-    if l:test_filename[:1] is# '..'
-        " Remove ../../ etc. from the front of the path.
-        let l:test_filename = substitute(l:test_filename, '\v^(\.\.[/\\])+', '/', '')
-    endif
-
-    " Use the basename for temporary files, as they are likely our files.
-    if ale#path#IsTempName(l:test_filename)
-        let l:test_filename = fnamemodify(l:test_filename, ':t')
-    endif
-
-    let l:buffer_filename = expand('#' . a:buffer . ':p')
-
-    return l:buffer_filename is# l:test_filename
-    \   || l:buffer_filename[-len(l:test_filename):] is# l:test_filename
-endfunction
-
-" Given a path, return every component of the path, moving upwards.
-function! ale#path#Upwards(path) abort
-    let l:pattern = has('win32') ? '\v/+|\\+' : '\v/+'
-    let l:sep = has('win32') ? '\' : '/'
-    let l:parts = split(ale#path#Simplify(a:path), l:pattern)
-    let l:path_list = []
-
-    while !empty(l:parts)
-        call add(l:path_list, join(l:parts, l:sep))
-        let l:parts = l:parts[:-2]
-    endwhile
-
-    if has('win32') && a:path =~# '^[a-zA-z]:\'
-        " Add \ to C: for C:\, etc.
-        let l:path_list[-1] .= '\'
-    elseif a:path[0] is# '/'
-        " If the path starts with /, even on Windows, add / and / to all paths.
-        call map(l:path_list, '''/'' . v:val')
-        call add(l:path_list, '/')
-    endif
-
-    return l:path_list
-endfunction
-
-" Convert a filesystem path to a file:// URI
-" relatives paths will not be prefixed with the protocol.
-" For Windows paths, the `:` in C:\ etc. will not be percent-encoded.
-function! ale#path#ToURI(path) abort
-    let l:has_drive_letter = a:path[1:2] is# ':\'
-
-    return substitute(
-    \   ((l:has_drive_letter || a:path[:0] is# '/') ? 'file://' : '')
-    \       . (l:has_drive_letter ? '/' . a:path[:2] : '')
-    \       . ale#uri#Encode(l:has_drive_letter ? a:path[3:] : a:path),
-    \   '\\',
-    \   '/',
-    \   'g',
-    \)
-endfunction
-
-function! ale#path#FromURI(uri) abort
-    if a:uri[:6] is? 'file://'
-        let l:encoded_path = a:uri[7:]
-    elseif a:uri[:4] is? 'file:'
-        let l:encoded_path = a:uri[5:]
-    else
-        let l:encoded_path = a:uri
-    endif
-
-    let l:path = ale#uri#Decode(l:encoded_path)
-
-    " If the path is like /C:/foo/bar, it should be C:\foo\bar instead.
-    if has('win32') && l:path =~# '^/[a-zA-Z][:|]'
-        let l:path = substitute(l:path[1:], '/', '\\', 'g')
-        let l:path = l:path[0] . ':' . l:path[2:]
-    endif
-
-    return l:path
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/pattern_options.vim b/sources_non_forked/ale/autoload/ale/pattern_options.vim
deleted file mode 100644
index 14e2142..0000000
--- a/sources_non_forked/ale/autoload/ale/pattern_options.vim
+++ /dev/null
@@ -1,47 +0,0 @@
-" Author: w0rp <devw0rp@gmail.com>
-" Description: Set options in files based on regex patterns.
-
-" These variables are used to cache the sorting of patterns below.
-let s:last_pattern_options = {}
-let s:sorted_items = []
-
-function! s:CmpPatterns(left_item, right_item) abort
-    if a:left_item[0] < a:right_item[0]
-        return -1
-    endif
-
-    if a:left_item[0] > a:right_item[0]
-        return 1
-    endif
-
-    return 0
-endfunction
-
-function! ale#pattern_options#SetOptions(buffer) abort
-    let l:pattern_options = get(g:, 'ale_pattern_options', {})
-
-    if empty(l:pattern_options)
-        " Stop if no options are set.
-        return
-    endif
-
-    " The items will only be sorted whenever the patterns change.
-    if l:pattern_options != s:last_pattern_options
-        let s:last_pattern_options = deepcopy(l:pattern_options)
-        " The patterns are sorted, so they are applied consistently.
-        let s:sorted_items = sort(
-        \   items(l:pattern_options),
-        \   function('s:CmpPatterns')
-        \)
-    endif
-
-    let l:filename = expand('#' . a:buffer . ':p')
-
-    for [l:pattern, l:options] in s:sorted_items
-        if match(l:filename, l:pattern) >= 0
-            for [l:key, l:value] in items(l:options)
-                call setbufvar(a:buffer, l:key, l:value)
-            endfor
-        endif
-    endfor
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/powershell.vim b/sources_non_forked/ale/autoload/ale/powershell.vim
deleted file mode 100644
index 8c16320..0000000
--- a/sources_non_forked/ale/autoload/ale/powershell.vim
+++ /dev/null
@@ -1,32 +0,0 @@
-" Author: zigford <zigford@gmail.com>
-" Description: Functions for integrating with Powershell linters.
-
-" Write a powershell script to a temp file for execution
-" return the command used to execute it
-function! s:TemporaryPSScript(buffer, input) abort
-    let l:filename = 'script.ps1'
-    " Create a temp dir to house our temp .ps1 script
-    " a temp dir is needed as powershell needs the .ps1
-    " extension
-    let l:tempdir = ale#util#Tempname() . (has('win32') ? '\' : '/')
-    let l:tempscript = l:tempdir . l:filename
-    " Create the temporary directory for the file, unreadable by 'other'
-    " users.
-    call mkdir(l:tempdir, '', 0750)
-    " Automatically delete the directory later.
-    call ale#command#ManageDirectory(a:buffer, l:tempdir)
-    " Write the script input out to a file.
-    call ale#util#Writefile(a:buffer, a:input, l:tempscript)
-
-    return l:tempscript
-endfunction
-
-function! ale#powershell#RunPowerShell(buffer, base_var_name, command) abort
-    let l:executable = ale#Var(a:buffer, a:base_var_name . '_executable')
-    let l:tempscript = s:TemporaryPSScript(a:buffer, a:command)
-
-    return ale#Escape(l:executable)
-    \ . ' -Exe Bypass -NoProfile -File '
-    \ . ale#Escape(l:tempscript)
-    \ . ' %t'
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/preview.vim b/sources_non_forked/ale/autoload/ale/preview.vim
deleted file mode 100644
index 7902ec6..0000000
--- a/sources_non_forked/ale/autoload/ale/preview.vim
+++ /dev/null
@@ -1,119 +0,0 @@
-" Author: w0rp <devw0rp@gmail.com>
-" Description: Preview windows for showing whatever information in.
-
-if !has_key(s:, 'last_selection_list')
-    let s:last_selection_list = []
-endif
-
-if !has_key(s:, 'last_selection_open_in')
-    let s:last_selection_open_in = 'current-buffer'
-endif
-
-" Open a preview window and show some lines in it.
-" A second argument can be passed as a Dictionary with options. They are...
-"
-" filetype  - The filetype to use, defaulting to 'ale-preview'
-" stay_here - If 1, stay in the window you came from.
-function! ale#preview#Show(lines, ...) abort
-    let l:options = get(a:000, 0, {})
-
-    silent pedit ALEPreviewWindow
-    wincmd P
-
-    setlocal modifiable
-    setlocal noreadonly
-    setlocal nobuflisted
-    setlocal buftype=nofile
-    setlocal bufhidden=wipe
-    :%d
-    call setline(1, a:lines)
-    setlocal nomodifiable
-    setlocal readonly
-    let &l:filetype = get(l:options, 'filetype', 'ale-preview')
-
-    if get(l:options, 'stay_here')
-        wincmd p
-    endif
-endfunction
-
-" Close the preview window if the filetype matches the given one.
-function! ale#preview#CloseIfTypeMatches(filetype) abort
-    for l:win in getwininfo()
-        let l:wintype = gettabwinvar(l:win.tabnr, l:win.winnr, '&filetype')
-
-        if l:wintype is# a:filetype
-            silent! pclose!
-        endif
-    endfor
-endfunction
-
-" Show a location selection preview window, given some items.
-" Each item should have 'filename', 'line', and 'column' keys.
-function! ale#preview#ShowSelection(item_list, ...) abort
-    let l:options = get(a:000, 0, {})
-    let l:sep = has('win32') ? '\' : '/'
-    let l:lines = []
-
-    " Create lines to display to users.
-    for l:item in a:item_list
-        let l:match = get(l:item, 'match', '')
-        let l:filename = l:item.filename
-
-        if get(l:options, 'use_relative_paths')
-            let l:cwd = getcwd() " no-custom-checks
-            let l:filename = substitute(l:filename, '^' . l:cwd . l:sep, '', '')
-        endif
-
-        call add(
-        \   l:lines,
-        \   l:filename
-        \       . ':' . l:item.line
-        \       . ':' . l:item.column
-        \       . (!empty(l:match) ? ' ' . l:match : ''),
-        \)
-    endfor
-
-    call ale#preview#Show(l:lines, {'filetype': 'ale-preview-selection'})
-    let b:ale_preview_item_list = a:item_list
-    let b:ale_preview_item_open_in = get(l:options, 'open_in', 'current-buffer')
-
-    " Remove the last preview
-    let s:last_selection_list = b:ale_preview_item_list
-    let s:last_selection_open_in = b:ale_preview_item_open_in
-endfunction
-
-function! ale#preview#RepeatSelection() abort
-    if empty(s:last_selection_list)
-        return
-    endif
-
-    call ale#preview#ShowSelection(s:last_selection_list, {
-    \   'open_in': s:last_selection_open_in,
-    \})
-endfunction
-
-function! s:Open(open_in) abort
-    let l:item_list = get(b:, 'ale_preview_item_list', [])
-    let l:item = get(l:item_list, getpos('.')[1] - 1, {})
-
-    if empty(l:item)
-        return
-    endif
-
-    :q!
-
-    call ale#util#Open(
-    \   l:item.filename,
-    \   l:item.line,
-    \   l:item.column,
-    \   {'open_in': a:open_in},
-    \)
-endfunction
-
-function! ale#preview#OpenSelection() abort
-    call s:Open(b:ale_preview_item_open_in)
-endfunction
-
-function! ale#preview#OpenSelectionInTab() abort
-    call s:Open('tab')
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/python.vim b/sources_non_forked/ale/autoload/ale/python.vim
deleted file mode 100644
index 7ed2236..0000000
--- a/sources_non_forked/ale/autoload/ale/python.vim
+++ /dev/null
@@ -1,157 +0,0 @@
-" Author: w0rp <devw0rp@gmail.com>
-" Description: Functions for integrating with Python linters.
-
-call ale#Set('python_auto_pipenv', '0')
-
-let s:sep = has('win32') ? '\' : '/'
-" bin is used for Unix virtualenv directories, and Scripts is for Windows.
-let s:bin_dir = has('unix') ? 'bin' : 'Scripts'
-let g:ale_virtualenv_dir_names = get(g:, 'ale_virtualenv_dir_names', [
-\   '.env',
-\   '.venv',
-\   'env',
-\   've-py3',
-\   've',
-\   'virtualenv',
-\   'venv',
-\])
-
-function! ale#python#FindProjectRootIni(buffer) abort
-    for l:path in ale#path#Upwards(expand('#' . a:buffer . ':p:h'))
-        " If you change this, update ale-python-root documentation.
-        if filereadable(l:path . '/MANIFEST.in')
-        \|| filereadable(l:path . '/setup.cfg')
-        \|| filereadable(l:path . '/pytest.ini')
-        \|| filereadable(l:path . '/tox.ini')
-        \|| filereadable(l:path . '/mypy.ini')
-        \|| filereadable(l:path . '/pycodestyle.cfg')
-        \|| filereadable(l:path . '/.flake8')
-        \|| filereadable(l:path . '/.flake8rc')
-        \|| filereadable(l:path . '/pylama.ini')
-        \|| filereadable(l:path . '/pylintrc')
-        \|| filereadable(l:path . '/.pylintrc')
-        \|| filereadable(l:path . '/Pipfile')
-        \|| filereadable(l:path . '/Pipfile.lock')
-            return l:path
-        endif
-    endfor
-
-    return ''
-endfunction
-
-" Given a buffer number, find the project root directory for Python.
-" The root directory is defined as the first directory found while searching
-" upwards through paths, including the current directory, until a path
-" containing an init file (one from MANIFEST.in, setup.cfg, pytest.ini,
-" tox.ini) is found. If it is not possible to find the project root directory
-" via init file, then it will be defined as the first directory found
-" searching upwards through paths, including the current directory, until no
-" __init__.py files is found.
-function! ale#python#FindProjectRoot(buffer) abort
-    let l:ini_root = ale#python#FindProjectRootIni(a:buffer)
-
-    if !empty(l:ini_root)
-        return l:ini_root
-    endif
-
-    for l:path in ale#path#Upwards(expand('#' . a:buffer . ':p:h'))
-        if !filereadable(l:path . '/__init__.py')
-            return l:path
-        endif
-    endfor
-
-    return ''
-endfunction
-
-" Given a buffer number, find a virtualenv path for Python.
-function! ale#python#FindVirtualenv(buffer) abort
-    for l:path in ale#path#Upwards(expand('#' . a:buffer . ':p:h'))
-        " Skip empty path components returned in MSYS.
-        if empty(l:path)
-            continue
-        endif
-
-        for l:dirname in ale#Var(a:buffer, 'virtualenv_dir_names')
-            let l:venv_dir = ale#path#Simplify(
-            \   join([l:path, l:dirname], s:sep)
-            \)
-            let l:script_filename = ale#path#Simplify(
-            \   join([l:venv_dir, s:bin_dir, 'activate'], s:sep)
-            \)
-
-            if filereadable(l:script_filename)
-                return l:venv_dir
-            endif
-        endfor
-    endfor
-
-    return $VIRTUAL_ENV
-endfunction
-
-" Given a buffer number and a command name, find the path to the executable.
-" First search on a virtualenv for Python, if nothing is found, try the global
-" command. Returns an empty string if cannot find the executable
-function! ale#python#FindExecutable(buffer, base_var_name, path_list) abort
-    if ale#Var(a:buffer, a:base_var_name . '_use_global')
-        return ale#Var(a:buffer, a:base_var_name . '_executable')
-    endif
-
-    let l:virtualenv = ale#python#FindVirtualenv(a:buffer)
-
-    if !empty(l:virtualenv)
-        for l:path in a:path_list
-            let l:ve_executable = ale#path#Simplify(
-            \   join([l:virtualenv, s:bin_dir, l:path], s:sep)
-            \)
-
-            if executable(l:ve_executable)
-                return l:ve_executable
-            endif
-        endfor
-    endif
-
-    return ale#Var(a:buffer, a:base_var_name . '_executable')
-endfunction
-
-" Handle traceback.print_exception() output starting in the first a:limit lines.
-function! ale#python#HandleTraceback(lines, limit) abort
-    let l:nlines = len(a:lines)
-    let l:limit = a:limit > l:nlines ? l:nlines : a:limit
-    let l:start = 0
-
-    while l:start < l:limit
-        if a:lines[l:start] is# 'Traceback (most recent call last):'
-            break
-        endif
-
-        let l:start += 1
-    endwhile
-
-    if l:start >= l:limit
-        return []
-    endif
-
-    let l:end = l:start + 1
-
-    " Traceback entries are always prefixed with 2 spaces.
-    " SyntaxError marker (if present) is prefixed with at least 4 spaces.
-    " Final exc line starts with exception class name (never a space).
-    while l:end < l:nlines && a:lines[l:end][0] is# ' '
-        let l:end += 1
-    endwhile
-
-    let l:exc_line = l:end < l:nlines
-    \   ? a:lines[l:end]
-    \   : 'An exception was thrown.'
-
-    return [{
-    \   'lnum': 1,
-    \   'text': l:exc_line . ' (See :ALEDetail)',
-    \   'detail': join(a:lines[(l:start):(l:end)], "\n"),
-    \}]
-endfunction
-
-" Detects whether a pipenv environment is present.
-function! ale#python#PipenvPresent(buffer) abort
-    return findfile('Pipfile.lock', expand('#' . a:buffer . ':p:h') . ';') isnot# ''
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/references.vim b/sources_non_forked/ale/autoload/ale/references.vim
deleted file mode 100644
index 38ff0d3..0000000
--- a/sources_non_forked/ale/autoload/ale/references.vim
+++ /dev/null
@@ -1,144 +0,0 @@
-let g:ale_default_navigation = get(g:, 'ale_default_navigation', 'buffer')
-
-let s:references_map = {}
-
-" Used to get the references map in tests.
-function! ale#references#GetMap() abort
-    return deepcopy(s:references_map)
-endfunction
-
-" Used to set the references map in tests.
-function! ale#references#SetMap(map) abort
-    let s:references_map = a:map
-endfunction
-
-function! ale#references#ClearLSPData() abort
-    let s:references_map = {}
-endfunction
-
-function! ale#references#HandleTSServerResponse(conn_id, response) abort
-    if get(a:response, 'command', '') is# 'references'
-    \&& has_key(s:references_map, a:response.request_seq)
-        let l:options = remove(s:references_map, a:response.request_seq)
-
-        if get(a:response, 'success', v:false) is v:true
-            let l:item_list = []
-
-            for l:response_item in a:response.body.refs
-                call add(l:item_list, {
-                \ 'filename': l:response_item.file,
-                \ 'line': l:response_item.start.line,
-                \ 'column': l:response_item.start.offset,
-                \ 'match': substitute(l:response_item.lineText, '^\s*\(.\{-}\)\s*$', '\1', ''),
-                \})
-            endfor
-
-            if empty(l:item_list)
-                call ale#util#Execute('echom ''No references found.''')
-            else
-                call ale#preview#ShowSelection(l:item_list, l:options)
-            endif
-        endif
-    endif
-endfunction
-
-function! ale#references#HandleLSPResponse(conn_id, response) abort
-    if has_key(a:response, 'id')
-    \&& has_key(s:references_map, a:response.id)
-        let l:options = remove(s:references_map, a:response.id)
-
-        " The result can be a Dictionary item, a List of the same, or null.
-        let l:result = get(a:response, 'result', [])
-        let l:item_list = []
-
-        if type(l:result) is v:t_list
-            for l:response_item in l:result
-                call add(l:item_list, {
-                \ 'filename': ale#path#FromURI(l:response_item.uri),
-                \ 'line': l:response_item.range.start.line + 1,
-                \ 'column': l:response_item.range.start.character + 1,
-                \})
-            endfor
-        endif
-
-        if empty(l:item_list)
-            call ale#util#Execute('echom ''No references found.''')
-        else
-            call ale#preview#ShowSelection(l:item_list, l:options)
-        endif
-    endif
-endfunction
-
-function! s:OnReady(line, column, options, linter, lsp_details) abort
-    let l:id = a:lsp_details.connection_id
-
-    if !ale#lsp#HasCapability(l:id, 'references')
-        return
-    endif
-
-    let l:buffer = a:lsp_details.buffer
-
-    let l:Callback = a:linter.lsp is# 'tsserver'
-    \   ? function('ale#references#HandleTSServerResponse')
-    \   : function('ale#references#HandleLSPResponse')
-
-    call ale#lsp#RegisterCallback(l:id, l:Callback)
-
-    if a:linter.lsp is# 'tsserver'
-        let l:message = ale#lsp#tsserver_message#References(
-        \   l:buffer,
-        \   a:line,
-        \   a:column
-        \)
-    else
-        " Send a message saying the buffer has changed first, or the
-        " references position probably won't make sense.
-        call ale#lsp#NotifyForChanges(l:id, l:buffer)
-
-        let l:message = ale#lsp#message#References(l:buffer, a:line, a:column)
-    endif
-
-    let l:request_id = ale#lsp#Send(l:id, l:message)
-
-    let s:references_map[l:request_id] = {
-    \ 'use_relative_paths': has_key(a:options, 'use_relative_paths') ? a:options.use_relative_paths : 0,
-    \ 'open_in': get(a:options, 'open_in', 'current-buffer'),
-    \}
-endfunction
-
-function! ale#references#Find(...) abort
-    let l:options = {}
-
-    if len(a:000) > 0
-        for l:option in a:000
-            if l:option is? '-relative'
-                let l:options.use_relative_paths = 1
-            elseif l:option is? '-tab'
-                let l:options.open_in = 'tab'
-            elseif l:option is? '-split'
-                let l:options.open_in = 'split'
-            elseif l:option is? '-vsplit'
-                let l:options.open_in = 'vsplit'
-            endif
-        endfor
-    endif
-
-    if !has_key(l:options, 'open_in')
-        let l:default_navigation = ale#Var(bufnr(''), 'default_navigation')
-
-        if index(['tab', 'split', 'vsplit'], l:default_navigation) >= 0
-            let l:options.open_in = l:default_navigation
-        endif
-    endif
-
-    let l:buffer = bufnr('')
-    let [l:line, l:column] = getpos('.')[1:2]
-    let l:column = min([l:column, len(getline(l:line))])
-    let l:Callback = function('s:OnReady', [l:line, l:column, l:options])
-
-    for l:linter in ale#linter#Get(&filetype)
-        if !empty(l:linter.lsp)
-            call ale#lsp_linter#StartLSP(l:buffer, l:linter, l:Callback)
-        endif
-    endfor
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/rename.vim b/sources_non_forked/ale/autoload/ale/rename.vim
deleted file mode 100644
index fbd6c2a..0000000
--- a/sources_non_forked/ale/autoload/ale/rename.vim
+++ /dev/null
@@ -1,225 +0,0 @@
-" Author: Jerko Steiner <jerko.steiner@gmail.com>
-" Description: Rename symbol support for LSP / tsserver
-
-let s:rename_map = {}
-
-" Used to get the rename map in tests.
-function! ale#rename#GetMap() abort
-    return deepcopy(s:rename_map)
-endfunction
-
-" Used to set the rename map in tests.
-function! ale#rename#SetMap(map) abort
-    let s:rename_map = a:map
-endfunction
-
-function! ale#rename#ClearLSPData() abort
-    let s:rename_map = {}
-endfunction
-
-let g:ale_rename_tsserver_find_in_comments = get(g:, 'ale_rename_tsserver_find_in_comments')
-let g:ale_rename_tsserver_find_in_strings = get(g:, 'ale_rename_tsserver_find_in_strings')
-
-function! s:message(message) abort
-    call ale#util#Execute('echom ' . string(a:message))
-endfunction
-
-function! ale#rename#HandleTSServerResponse(conn_id, response) abort
-    if get(a:response, 'command', '') isnot# 'rename'
-        return
-    endif
-
-    if !has_key(s:rename_map, a:response.request_seq)
-        return
-    endif
-
-    let l:old_name = s:rename_map[a:response.request_seq].old_name
-    let l:new_name = s:rename_map[a:response.request_seq].new_name
-    call remove(s:rename_map, a:response.request_seq)
-
-    if get(a:response, 'success', v:false) is v:false
-        let l:message = get(a:response, 'message', 'unknown')
-        call s:message('Error renaming "' . l:old_name . '" to: "' . l:new_name
-        \ . '". Reason: ' . l:message)
-
-        return
-    endif
-
-    let l:changes = []
-
-    for l:response_item in a:response.body.locs
-        let l:filename = l:response_item.file
-        let l:text_changes = []
-
-        for l:loc in l:response_item.locs
-            call add(l:text_changes, {
-            \ 'start': {
-            \   'line': l:loc.start.line,
-            \   'offset': l:loc.start.offset,
-            \ },
-            \ 'end': {
-            \   'line': l:loc.end.line,
-            \   'offset': l:loc.end.offset,
-            \ },
-            \ 'newText': l:new_name,
-            \})
-        endfor
-
-        call add(l:changes, {
-        \   'fileName': l:filename,
-        \   'textChanges': l:text_changes,
-        \})
-    endfor
-
-    if empty(l:changes)
-        call s:message('Error renaming "' . l:old_name . '" to: "' . l:new_name . '"')
-
-        return
-    endif
-
-    call ale#code_action#HandleCodeAction({
-    \ 'description': 'rename',
-    \ 'changes': l:changes,
-    \}, v:true)
-endfunction
-
-function! ale#rename#HandleLSPResponse(conn_id, response) abort
-    if has_key(a:response, 'id')
-    \&& has_key(s:rename_map, a:response.id)
-        call remove(s:rename_map, a:response.id)
-
-        if !has_key(a:response, 'result')
-            call s:message('No rename result received from server')
-
-            return
-        endif
-
-        let l:workspace_edit = a:response.result
-
-        if !has_key(l:workspace_edit, 'changes') || empty(l:workspace_edit.changes)
-            call s:message('No changes received from server')
-
-            return
-        endif
-
-        let l:changes = []
-
-        for l:file_name in keys(l:workspace_edit.changes)
-            let l:text_edits = l:workspace_edit.changes[l:file_name]
-            let l:text_changes = []
-
-            for l:edit in l:text_edits
-                let l:range = l:edit.range
-                let l:new_text = l:edit.newText
-
-                call add(l:text_changes, {
-                \ 'start': {
-                \   'line': l:range.start.line + 1,
-                \   'offset': l:range.start.character + 1,
-                \ },
-                \ 'end': {
-                \   'line': l:range.end.line + 1,
-                \   'offset': l:range.end.character + 1,
-                \ },
-                \ 'newText': l:new_text,
-                \})
-            endfor
-
-            call add(l:changes, {
-            \   'fileName': ale#path#FromURI(l:file_name),
-            \   'textChanges': l:text_changes,
-            \})
-        endfor
-
-        call ale#code_action#HandleCodeAction({
-        \   'description': 'rename',
-        \   'changes': l:changes,
-        \}, v:true)
-    endif
-endfunction
-
-function! s:OnReady(line, column, old_name, new_name, linter, lsp_details) abort
-    let l:id = a:lsp_details.connection_id
-
-    if !ale#lsp#HasCapability(l:id, 'rename')
-        return
-    endif
-
-    let l:buffer = a:lsp_details.buffer
-
-    let l:Callback = a:linter.lsp is# 'tsserver'
-    \   ? function('ale#rename#HandleTSServerResponse')
-    \   : function('ale#rename#HandleLSPResponse')
-
-    call ale#lsp#RegisterCallback(l:id, l:Callback)
-
-    if a:linter.lsp is# 'tsserver'
-        let l:message = ale#lsp#tsserver_message#Rename(
-        \   l:buffer,
-        \   a:line,
-        \   a:column,
-        \   g:ale_rename_tsserver_find_in_comments,
-        \   g:ale_rename_tsserver_find_in_strings,
-        \)
-    else
-        " Send a message saying the buffer has changed first, or the
-        " rename position probably won't make sense.
-        call ale#lsp#NotifyForChanges(l:id, l:buffer)
-
-        let l:message = ale#lsp#message#Rename(
-        \   l:buffer,
-        \   a:line,
-        \   a:column,
-        \   a:new_name
-        \)
-    endif
-
-    let l:request_id = ale#lsp#Send(l:id, l:message)
-
-    let s:rename_map[l:request_id] = {
-    \   'new_name': a:new_name,
-    \   'old_name': a:old_name,
-    \}
-endfunction
-
-function! s:ExecuteRename(linter, old_name, new_name) abort
-    let l:buffer = bufnr('')
-    let [l:line, l:column] = getpos('.')[1:2]
-
-    if a:linter.lsp isnot# 'tsserver'
-        let l:column = min([l:column, len(getline(l:line))])
-    endif
-
-    let l:Callback = function(
-    \ 's:OnReady', [l:line, l:column, a:old_name, a:new_name])
-    call ale#lsp_linter#StartLSP(l:buffer, a:linter, l:Callback)
-endfunction
-
-function! ale#rename#Execute() abort
-    let l:lsp_linters = []
-
-    for l:linter in ale#linter#Get(&filetype)
-        if !empty(l:linter.lsp)
-            call add(l:lsp_linters, l:linter)
-        endif
-    endfor
-
-    if empty(l:lsp_linters)
-        call s:message('No active LSPs')
-
-        return
-    endif
-
-    let l:old_name = expand('<cword>')
-    let l:new_name = ale#util#Input('New name: ', l:old_name)
-
-    if empty(l:new_name)
-        call s:message('New name cannot be empty!')
-
-        return
-    endif
-
-    for l:lsp_linter in l:lsp_linters
-        call s:ExecuteRename(l:lsp_linter, l:old_name, l:new_name)
-    endfor
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/ruby.vim b/sources_non_forked/ale/autoload/ale/ruby.vim
deleted file mode 100644
index d941bb2..0000000
--- a/sources_non_forked/ale/autoload/ale/ruby.vim
+++ /dev/null
@@ -1,83 +0,0 @@
-" Author: Eddie Lebow https://github.com/elebow
-" Description: Functions for integrating with Ruby tools
-
-" Find the nearest dir containing "app", "db", and "config", and assume it is
-" the root of a Rails app.
-function! ale#ruby#FindRailsRoot(buffer) abort
-    for l:name in ['app', 'config', 'db']
-        let l:dir = fnamemodify(
-        \   ale#path#FindNearestDirectory(a:buffer, l:name),
-        \   ':h:h'
-        \)
-
-        if l:dir isnot# '.'
-        \&& isdirectory(l:dir . '/app')
-        \&& isdirectory(l:dir . '/config')
-        \&& isdirectory(l:dir . '/db')
-            return l:dir
-        endif
-    endfor
-
-    return ''
-endfunction
-
-" Find the nearest dir containing a potential ruby project.
-function! ale#ruby#FindProjectRoot(buffer) abort
-    let l:dir = ale#ruby#FindRailsRoot(a:buffer)
-
-    if isdirectory(l:dir)
-        return l:dir
-    endif
-
-    for l:name in ['.solargraph.yml', 'Rakefile', 'Gemfile']
-        let l:dir = fnamemodify(
-        \   ale#path#FindNearestFile(a:buffer, l:name),
-        \   ':h'
-        \)
-
-        if l:dir isnot# '.' && isdirectory(l:dir)
-            return l:dir
-        endif
-    endfor
-
-    return ''
-endfunction
-
-" Handle output from rubocop and linters that depend on it (e.b. standardrb)
-function! ale#ruby#HandleRubocopOutput(buffer, lines) abort
-    try
-        let l:errors = json_decode(a:lines[0])
-    catch
-        return []
-    endtry
-
-    if !has_key(l:errors, 'summary')
-    \|| l:errors['summary']['offense_count'] == 0
-    \|| empty(l:errors['files'])
-        return []
-    endif
-
-    let l:output = []
-
-    for l:error in l:errors['files'][0]['offenses']
-        let l:start_col = l:error['location']['column'] + 0
-        call add(l:output, {
-        \   'lnum': l:error['location']['line'] + 0,
-        \   'col': l:start_col,
-        \   'end_col': l:start_col + l:error['location']['length'] - 1,
-        \   'code': l:error['cop_name'],
-        \   'text': l:error['message'],
-        \   'type': ale_linters#ruby#rubocop#GetType(l:error['severity']),
-        \})
-    endfor
-
-    return l:output
-endfunction
-
-function! ale#ruby#EscapeExecutable(executable, bundle_exec) abort
-    let l:exec_args = a:executable =~? 'bundle'
-    \   ? ' exec ' . a:bundle_exec
-    \   : ''
-
-    return ale#Escape(a:executable) . l:exec_args
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/semver.vim b/sources_non_forked/ale/autoload/ale/semver.vim
deleted file mode 100644
index e3eb49c..0000000
--- a/sources_non_forked/ale/autoload/ale/semver.vim
+++ /dev/null
@@ -1,78 +0,0 @@
-let s:version_cache = {}
-
-" Reset the version cache used for parsing the version.
-function! ale#semver#ResetVersionCache() abort
-    let s:version_cache = {}
-endfunction
-
-function! ale#semver#ParseVersion(version_lines) abort
-    for l:line in a:version_lines
-        let l:match = matchlist(l:line, '\v(\d+)\.(\d+)(\.(\d+))?')
-
-        if !empty(l:match)
-            return [l:match[1] + 0, l:match[2] + 0, l:match[4] + 0]
-        endif
-    endfor
-
-    return []
-endfunction
-
-" Given an executable name and some lines of output, which can be empty,
-" parse the version from the lines of output, or return the cached version
-" triple [major, minor, patch]
-"
-" If the version cannot be found, an empty List will be returned instead.
-function! s:GetVersion(executable, version_lines) abort
-    let l:version = get(s:version_cache, a:executable, [])
-    let l:parsed_version = ale#semver#ParseVersion(a:version_lines)
-
-    if !empty(l:parsed_version)
-        let l:version = l:parsed_version
-        let s:version_cache[a:executable] = l:version
-    endif
-
-    return l:version
-endfunction
-
-function! ale#semver#RunWithVersionCheck(buffer, executable, command, Callback) abort
-    if empty(a:executable)
-        return ''
-    endif
-
-    let l:cache = s:version_cache
-
-    if has_key(s:version_cache, a:executable)
-        return a:Callback(a:buffer, s:version_cache[a:executable])
-    endif
-
-    return ale#command#Run(
-    \   a:buffer,
-    \   a:command,
-    \   {_, output -> a:Callback(a:buffer, s:GetVersion(a:executable, output))},
-    \   {'output_stream': 'both', 'executable': a:executable}
-    \)
-endfunction
-
-" Given two triples of integers [major, minor, patch], compare the triples
-" and return 1 if the LHS is greater than or equal to the RHS.
-"
-" Pairs of [major, minor] can also be used for either argument.
-"
-" 0 will be returned if the LHS is an empty List.
-function! ale#semver#GTE(lhs, rhs) abort
-    if empty(a:lhs)
-        return 0
-    endif
-
-    if a:lhs[0] > a:rhs[0]
-        return 1
-    elseif a:lhs[0] == a:rhs[0]
-        if a:lhs[1] > a:rhs[1]
-            return 1
-        elseif a:lhs[1] == a:rhs[1]
-            return get(a:lhs, 2) >= get(a:rhs, 2)
-        endif
-    endif
-
-    return 0
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/sign.vim b/sources_non_forked/ale/autoload/ale/sign.vim
deleted file mode 100644
index 8109c60..0000000
--- a/sources_non_forked/ale/autoload/ale/sign.vim
+++ /dev/null
@@ -1,470 +0,0 @@
-scriptencoding utf8
-" Author: w0rp <devw0rp@gmail.com>
-" Description: Draws error and warning signs into signcolumn
-
-" This flag can be set to some integer to control the maximum number of signs
-" that ALE will set.
-let g:ale_max_signs = get(g:, 'ale_max_signs', -1)
-" This flag can be set to 1 to enable changing the sign column colors when
-" there are errors.
-let g:ale_change_sign_column_color = get(g:, 'ale_change_sign_column_color', 0)
-" These variables dictate what signs are used to indicate errors and warnings.
-let g:ale_sign_error = get(g:, 'ale_sign_error', '>>')
-let g:ale_sign_style_error = get(g:, 'ale_sign_style_error', g:ale_sign_error)
-let g:ale_sign_warning = get(g:, 'ale_sign_warning', '--')
-let g:ale_sign_style_warning = get(g:, 'ale_sign_style_warning', g:ale_sign_warning)
-let g:ale_sign_info = get(g:, 'ale_sign_info', g:ale_sign_warning)
-let g:ale_sign_priority = get(g:, 'ale_sign_priority', 30)
-" This variable sets an offset which can be set for sign IDs.
-" This ID can be changed depending on what IDs are set for other plugins.
-" The dummy sign will use the ID exactly equal to the offset.
-let g:ale_sign_offset = get(g:, 'ale_sign_offset', 1000000)
-" This flag can be set to 1 to keep sign gutter always open
-let g:ale_sign_column_always = get(g:, 'ale_sign_column_always', 0)
-let g:ale_sign_highlight_linenrs = get(g:, 'ale_sign_highlight_linenrs', 0)
-
-let s:supports_sign_groups = has('nvim-0.4.2') || has('patch-8.1.614')
-
-if !hlexists('ALEErrorSign')
-    highlight link ALEErrorSign error
-endif
-
-if !hlexists('ALEStyleErrorSign')
-    highlight link ALEStyleErrorSign ALEErrorSign
-endif
-
-if !hlexists('ALEWarningSign')
-    highlight link ALEWarningSign todo
-endif
-
-if !hlexists('ALEStyleWarningSign')
-    highlight link ALEStyleWarningSign ALEWarningSign
-endif
-
-if !hlexists('ALEInfoSign')
-    highlight link ALEInfoSign ALEWarningSign
-endif
-
-if !hlexists('ALESignColumnWithErrors')
-    highlight link ALESignColumnWithErrors error
-endif
-
-function! ale#sign#SetUpDefaultColumnWithoutErrorsHighlight() abort
-    redir => l:output
-        0verbose silent highlight SignColumn
-    redir end
-
-    let l:highlight_syntax = join(split(l:output)[2:])
-    let l:match = matchlist(l:highlight_syntax, '\vlinks to (.+)$')
-
-    if !empty(l:match)
-        execute 'highlight link ALESignColumnWithoutErrors ' . l:match[1]
-    elseif l:highlight_syntax isnot# 'cleared'
-        execute 'highlight ALESignColumnWithoutErrors ' . l:highlight_syntax
-    endif
-endfunction
-
-if !hlexists('ALESignColumnWithoutErrors')
-    call ale#sign#SetUpDefaultColumnWithoutErrorsHighlight()
-endif
-
-" Spaces and backslashes need to be escaped for signs.
-function! s:EscapeSignText(sign_text) abort
-    return substitute(substitute(a:sign_text, ' *$', '', ''), '\\\| ', '\\\0', 'g')
-endfunction
-
-" Signs show up on the left for error markers.
-execute 'sign define ALEErrorSign text=' . s:EscapeSignText(g:ale_sign_error)
-\   . ' texthl=ALEErrorSign linehl=ALEErrorLine'
-execute 'sign define ALEStyleErrorSign text=' .  s:EscapeSignText(g:ale_sign_style_error)
-\   . ' texthl=ALEStyleErrorSign linehl=ALEErrorLine'
-execute 'sign define ALEWarningSign text=' . s:EscapeSignText(g:ale_sign_warning)
-\   . ' texthl=ALEWarningSign linehl=ALEWarningLine'
-execute 'sign define ALEStyleWarningSign text=' . s:EscapeSignText(g:ale_sign_style_warning)
-\   . ' texthl=ALEStyleWarningSign linehl=ALEWarningLine'
-execute 'sign define ALEInfoSign text=' . s:EscapeSignText(g:ale_sign_info)
-\   . ' texthl=ALEInfoSign linehl=ALEInfoLine'
-sign define ALEDummySign
-
-if g:ale_sign_highlight_linenrs && has('nvim-0.3.2')
-    if !hlexists('ALEErrorSignLineNr')
-        highlight link ALEErrorSignLineNr CursorLineNr
-    endif
-
-    if !hlexists('ALEStyleErrorSignLineNr')
-        highlight link ALEStyleErrorSignLineNr CursorLineNr
-    endif
-
-    if !hlexists('ALEWarningSignLineNr')
-        highlight link ALEWarningSignLineNr CursorLineNr
-    endif
-
-    if !hlexists('ALEStyleWarningSignLineNr')
-        highlight link ALEStyleWarningSignLineNr CursorLineNr
-    endif
-
-    if !hlexists('ALEInfoSignLineNr')
-        highlight link ALEInfoSignLineNr CursorLineNr
-    endif
-
-    sign define ALEErrorSign numhl=ALEErrorSignLineNr
-    sign define ALEStyleErrorSign numhl=ALEStyleErrorSignLineNr
-    sign define ALEWarningSign numhl=ALEWarningSignLineNr
-    sign define ALEStyleWarningSign numhl=ALEStyleWarningSignLineNr
-    sign define ALEInfoSign numhl=ALEInfoSignLineNr
-endif
-
-function! ale#sign#GetSignName(sublist) abort
-    let l:priority = g:ale#util#style_warning_priority
-
-    " Determine the highest priority item for the line.
-    for l:item in a:sublist
-        let l:item_priority = ale#util#GetItemPriority(l:item)
-
-        if l:item_priority > l:priority
-            let l:priority = l:item_priority
-        endif
-    endfor
-
-    if l:priority is# g:ale#util#error_priority
-        return 'ALEErrorSign'
-    endif
-
-    if l:priority is# g:ale#util#warning_priority
-        return 'ALEWarningSign'
-    endif
-
-    if l:priority is# g:ale#util#style_error_priority
-        return 'ALEStyleErrorSign'
-    endif
-
-    if l:priority is# g:ale#util#style_warning_priority
-        return 'ALEStyleWarningSign'
-    endif
-
-    if l:priority is# g:ale#util#info_priority
-        return 'ALEInfoSign'
-    endif
-
-    " Use the error sign for invalid severities.
-    return 'ALEErrorSign'
-endfunction
-
-function! s:PriorityCmd() abort
-    if s:supports_sign_groups
-        return ' priority=' . g:ale_sign_priority . ' '
-    else
-        return ''
-    endif
-endfunction
-
-function! s:GroupCmd() abort
-    if s:supports_sign_groups
-        return ' group=ale '
-    else
-        return ' '
-    endif
-endfunction
-
-" Read sign data for a buffer to a list of lines.
-function! ale#sign#ReadSigns(buffer) abort
-    redir => l:output
-        silent execute 'sign place ' . s:GroupCmd() . s:PriorityCmd()
-        \ . ' buffer=' . a:buffer
-    redir end
-
-    return split(l:output, "\n")
-endfunction
-
-function! ale#sign#ParsePattern() abort
-    if s:supports_sign_groups
-        " Matches output like :
-        " line=4  id=1  group=ale  name=ALEErrorSign
-        " =1  id=1000001  =ale  =ALEErrorSign
-        " =1  =1000001  =ale  =ALEWarningSign
-        " lnea=12 id=1000001 grupo=ale  nombre=ALEWarningSign
-        " riga=1 id=1000001  gruppo=ale   nome=ALEWarningSign
-        " Zeile=235  id=1000001 Gruppe=ale  Name=ALEErrorSign
-        let l:pattern = '\v^.*\=(\d+).*\=(\d+).*\=ale>.*\=(ALE[a-zA-Z]+Sign)'
-    else
-        " Matches output like :
-        " line=4  id=1  name=ALEErrorSign
-        " =1  id=1000001  =ALEErrorSign
-        " =1  =1000001  =ALEWarningSign
-        " lnea=12 id=1000001 nombre=ALEWarningSign
-        " riga=1 id=1000001  nome=ALEWarningSign
-        " Zeile=235  id=1000001  Name=ALEErrorSign
-        let l:pattern = '\v^.*\=(\d+).*\=(\d+).*\=(ALE[a-zA-Z]+Sign)'
-    endif
-
-    return l:pattern
-endfunction
-
-" Given a list of lines for sign output, return a List of [line, id, group]
-function! ale#sign#ParseSigns(line_list) abort
-    let l:pattern =ale#sign#ParsePattern()
-    let l:result = []
-    let l:is_dummy_sign_set = 0
-
-    for l:line in a:line_list
-        let l:match = matchlist(l:line, l:pattern)
-
-        if len(l:match) > 0
-            if l:match[3] is# 'ALEDummySign'
-                let l:is_dummy_sign_set = 1
-            else
-                call add(l:result, [
-                \   str2nr(l:match[1]),
-                \   str2nr(l:match[2]),
-                \   l:match[3],
-                \])
-            endif
-        endif
-    endfor
-
-    return [l:is_dummy_sign_set, l:result]
-endfunction
-
-function! ale#sign#FindCurrentSigns(buffer) abort
-    let l:line_list = ale#sign#ReadSigns(a:buffer)
-
-    return ale#sign#ParseSigns(l:line_list)
-endfunction
-
-" Given a loclist, group the List into with one List per line.
-function! s:GroupLoclistItems(buffer, loclist) abort
-    let l:grouped_items = []
-    let l:last_lnum = -1
-
-    for l:obj in a:loclist
-        if l:obj.bufnr != a:buffer
-            continue
-        endif
-
-        " Create a new sub-List when we hit a new line.
-        if l:obj.lnum != l:last_lnum
-            call add(l:grouped_items, [])
-        endif
-
-        call add(l:grouped_items[-1], l:obj)
-        let l:last_lnum = l:obj.lnum
-    endfor
-
-    return l:grouped_items
-endfunction
-
-function! s:UpdateLineNumbers(buffer, current_sign_list, loclist) abort
-    let l:line_map = {}
-    let l:line_numbers_changed = 0
-
-    for [l:line, l:sign_id, l:name] in a:current_sign_list
-        let l:line_map[l:sign_id] = l:line
-    endfor
-
-    for l:item in a:loclist
-        if l:item.bufnr == a:buffer
-            let l:lnum = get(l:line_map, get(l:item, 'sign_id', 0), 0)
-
-            if l:lnum && l:item.lnum != l:lnum
-                let l:item.lnum = l:lnum
-                let l:line_numbers_changed = 1
-            endif
-        endif
-    endfor
-
-    " When the line numbers change, sort the list again
-    if l:line_numbers_changed
-        call sort(a:loclist, 'ale#util#LocItemCompare')
-    endif
-endfunction
-
-function! s:BuildSignMap(buffer, current_sign_list, grouped_items) abort
-    let l:max_signs = ale#Var(a:buffer, 'max_signs')
-
-    if l:max_signs is 0
-        let l:selected_grouped_items = []
-    elseif type(l:max_signs) is v:t_number && l:max_signs > 0
-        let l:selected_grouped_items = a:grouped_items[:l:max_signs - 1]
-    else
-        let l:selected_grouped_items = a:grouped_items
-    endif
-
-    let l:sign_map = {}
-    let l:sign_offset = g:ale_sign_offset
-
-    for [l:line, l:sign_id, l:name] in a:current_sign_list
-        let l:sign_info = get(l:sign_map, l:line, {
-        \   'current_id_list': [],
-        \   'current_name_list': [],
-        \   'new_id': 0,
-        \   'new_name': '',
-        \   'items': [],
-        \})
-
-        " Increment the sign offset for new signs, by the maximum sign ID.
-        if l:sign_id > l:sign_offset
-            let l:sign_offset = l:sign_id
-        endif
-
-        " Remember the sign names and IDs in separate Lists, so they are easy
-        " to work with.
-        call add(l:sign_info.current_id_list, l:sign_id)
-        call add(l:sign_info.current_name_list, l:name)
-
-        let l:sign_map[l:line] = l:sign_info
-    endfor
-
-    for l:group in l:selected_grouped_items
-        let l:line = l:group[0].lnum
-        let l:sign_info = get(l:sign_map, l:line, {
-        \   'current_id_list': [],
-        \   'current_name_list': [],
-        \   'new_id': 0,
-        \   'new_name': '',
-        \   'items': [],
-        \})
-
-        let l:sign_info.new_name = ale#sign#GetSignName(l:group)
-        let l:sign_info.items = l:group
-
-        let l:index = index(
-        \   l:sign_info.current_name_list,
-        \   l:sign_info.new_name
-        \)
-
-        if l:index >= 0
-            " We have a sign with this name already, so use the same ID.
-            let l:sign_info.new_id = l:sign_info.current_id_list[l:index]
-        else
-            " This sign name replaces the previous name, so use a new ID.
-            let l:sign_info.new_id = l:sign_offset + 1
-            let l:sign_offset += 1
-        endif
-
-        let l:sign_map[l:line] = l:sign_info
-    endfor
-
-    return l:sign_map
-endfunction
-
-function! ale#sign#GetSignCommands(buffer, was_sign_set, sign_map) abort
-    let l:command_list = []
-    let l:is_dummy_sign_set = a:was_sign_set
-
-    " Set the dummy sign if we need to.
-    " The dummy sign is needed to keep the sign column open while we add
-    " and remove signs.
-    if !l:is_dummy_sign_set && (!empty(a:sign_map) || g:ale_sign_column_always)
-        call add(l:command_list, 'sign place '
-        \   .  g:ale_sign_offset
-        \   . s:GroupCmd()
-        \   . s:PriorityCmd()
-        \   . ' line=1 name=ALEDummySign '
-        \   . ' buffer=' . a:buffer
-        \)
-        let l:is_dummy_sign_set = 1
-    endif
-
-    " Place new items first.
-    for [l:line_str, l:info] in items(a:sign_map)
-        if l:info.new_id
-            " Save the sign IDs we are setting back on our loclist objects.
-            " These IDs will be used to preserve items which are set many times.
-            for l:item in l:info.items
-                let l:item.sign_id = l:info.new_id
-            endfor
-
-            if index(l:info.current_id_list, l:info.new_id) < 0
-                call add(l:command_list, 'sign place '
-                \   . (l:info.new_id)
-                \   . s:GroupCmd()
-                \   . s:PriorityCmd()
-                \   . ' line=' . l:line_str
-                \   . ' name=' . (l:info.new_name)
-                \   . ' buffer=' . a:buffer
-                \)
-            endif
-        endif
-    endfor
-
-    " Remove signs without new IDs.
-    for l:info in values(a:sign_map)
-        for l:current_id in l:info.current_id_list
-            if l:current_id isnot l:info.new_id
-                call add(l:command_list, 'sign unplace '
-                \   . l:current_id
-                \   . s:GroupCmd()
-                \   . ' buffer=' . a:buffer
-                \)
-            endif
-        endfor
-    endfor
-
-    " Remove the dummy sign to close the sign column if we need to.
-    if l:is_dummy_sign_set && !g:ale_sign_column_always
-        call add(l:command_list, 'sign unplace '
-        \   . g:ale_sign_offset
-        \   . s:GroupCmd()
-        \   . ' buffer=' . a:buffer
-        \)
-    endif
-
-    return l:command_list
-endfunction
-
-" This function will set the signs which show up on the left.
-function! ale#sign#SetSigns(buffer, loclist) abort
-    if !bufexists(str2nr(a:buffer))
-        " Stop immediately when attempting to set signs for a buffer which
-        " does not exist.
-        return
-    endif
-
-    " Find the current markers
-    let [l:is_dummy_sign_set, l:current_sign_list] =
-    \   ale#sign#FindCurrentSigns(a:buffer)
-
-    " Update the line numbers for items from before which may have moved.
-    call s:UpdateLineNumbers(a:buffer, l:current_sign_list, a:loclist)
-
-    " Group items after updating the line numbers.
-    let l:grouped_items = s:GroupLoclistItems(a:buffer, a:loclist)
-
-    " Build a map of current and new signs, with the lines as the keys.
-    let l:sign_map = s:BuildSignMap(
-    \   a:buffer,
-    \   l:current_sign_list,
-    \   l:grouped_items,
-    \)
-
-    let l:command_list = ale#sign#GetSignCommands(
-    \   a:buffer,
-    \   l:is_dummy_sign_set,
-    \   l:sign_map,
-    \)
-
-    " Change the sign column color if the option is on.
-    if g:ale_change_sign_column_color && !empty(a:loclist)
-        highlight clear SignColumn
-        highlight link SignColumn ALESignColumnWithErrors
-    endif
-
-    for l:command in l:command_list
-        silent! execute l:command
-    endfor
-
-    " Reset the sign column color when there are no more errors.
-    if g:ale_change_sign_column_color && empty(a:loclist)
-        highlight clear SignColumn
-        highlight link SignColumn ALESignColumnWithoutErrors
-    endif
-endfunction
-
-" Remove all signs.
-function! ale#sign#Clear() abort
-    if s:supports_sign_groups
-        sign unplace group=ale *
-    else
-        sign unplace *
-    endif
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/socket.vim b/sources_non_forked/ale/autoload/ale/socket.vim
deleted file mode 100644
index 7e069fb..0000000
--- a/sources_non_forked/ale/autoload/ale/socket.vim
+++ /dev/null
@@ -1,152 +0,0 @@
-" Author: w0rp <devw0rp@gmail.com>
-" Description: APIs for working with asynchronous sockets, with an API
-" normalised between Vim 8 and NeoVim. Socket connections only work in NeoVim
-" 0.3+, and silently do nothing in earlier NeoVim versions.
-"
-" Important functions are described below. They are:
-"
-"   ale#socket#Open(address, options) -> channel_id (>= 0 if successful)
-"   ale#socket#IsOpen(channel_id) -> 1 if open, 0 otherwise
-"   ale#socket#Close(channel_id)
-"   ale#socket#Send(channel_id, data)
-"   ale#socket#GetAddress(channel_id) -> Return the address for a job
-
-let s:channel_map = get(s:, 'channel_map', {})
-
-function! s:VimOutputCallback(channel, data) abort
-    let l:channel_id = ch_info(a:channel).id
-
-    " Only call the callbacks for jobs which are valid.
-    if l:channel_id >= 0 && has_key(s:channel_map, l:channel_id)
-        call ale#util#GetFunction(s:channel_map[l:channel_id].callback)(l:channel_id, a:data)
-    endif
-endfunction
-
-function! s:NeoVimOutputCallback(channel_id, data, event) abort
-    let l:info = s:channel_map[a:channel_id]
-
-    if a:event is# 'data'
-        let l:info.last_line = ale#util#JoinNeovimOutput(
-        \   a:channel_id,
-        \   l:info.last_line,
-        \   a:data,
-        \   l:info.mode,
-        \   ale#util#GetFunction(l:info.callback),
-        \)
-    endif
-endfunction
-
-" Open a socket for a given address. The following options are accepted:
-"
-" callback - A callback for receiving input. (required)
-"
-" A non-negative number representing a channel ID will be returned is the
-" connection was successful. 0 is a valid channel ID in Vim, so test if the
-" connection ID is >= 0.
-function! ale#socket#Open(address, options) abort
-    let l:mode = get(a:options, 'mode', 'raw')
-    let l:Callback = a:options.callback
-
-    let l:channel_info = {
-    \   'address': a:address,
-    \   'mode': l:mode,
-    \   'callback': a:options.callback,
-    \}
-
-    if !has('nvim')
-        " Vim
-        let l:channel_options = {
-        \   'mode': l:mode,
-        \   'waittime': 0,
-        \   'callback': function('s:VimOutputCallback'),
-        \}
-
-        " Use non-blocking writes for Vim versions that support the option.
-        if has('patch-8.1.350')
-            let l:channel_options.noblock = 1
-        endif
-
-        let l:channel_info.channel = ch_open(a:address, l:channel_options)
-        let l:vim_info = ch_info(l:channel_info.channel)
-        let l:channel_id = !empty(l:vim_info) ? l:vim_info.id : -1
-    elseif exists('*chansend') && exists('*sockconnect')
-        " NeoVim 0.3+
-        try
-            let l:channel_id = sockconnect('tcp', a:address, {
-            \   'on_data': function('s:NeoVimOutputCallback'),
-            \})
-            let l:channel_info.last_line = ''
-        catch /connection failed/
-            let l:channel_id = -1
-        endtry
-
-        " 0 means the connection failed some times in NeoVim, so make the ID
-        " invalid to match Vim.
-        if l:channel_id is 0
-            let l:channel_id = -1
-        endif
-
-        let l:channel_info.channel = l:channel_id
-    else
-        " Other Vim versions.
-        let l:channel_id = -1
-    endif
-
-    if l:channel_id >= 0
-        let s:channel_map[l:channel_id] = l:channel_info
-    endif
-
-    return l:channel_id
-endfunction
-
-" Return 1 is a channel is open, 0 otherwise.
-function! ale#socket#IsOpen(channel_id) abort
-    if !has_key(s:channel_map, a:channel_id)
-        return 0
-    endif
-
-    if has('nvim')
-        " In NeoVim, we have to check if this channel is in the global list.
-        return index(map(nvim_list_chans(), 'v:val.id'), a:channel_id) >= 0
-    endif
-
-    let l:channel = s:channel_map[a:channel_id].channel
-
-    return ch_status(l:channel) is# 'open'
-endfunction
-
-" Close a socket, if it's still open.
-function! ale#socket#Close(channel_id) abort
-    " IsRunning isn't called here, so we don't check nvim_list_chans()
-    if !has_key(s:channel_map, a:channel_id)
-        return 0
-    endif
-
-    let l:channel = remove(s:channel_map, a:channel_id).channel
-
-    if has('nvim')
-        silent! call chanclose(l:channel)
-    elseif ch_status(l:channel) is# 'open'
-        call ch_close(l:channel)
-    endif
-endfunction
-
-" Send some data to a socket.
-function! ale#socket#Send(channel_id, data) abort
-    if !has_key(s:channel_map, a:channel_id)
-        return
-    endif
-
-    let l:channel = s:channel_map[a:channel_id].channel
-
-    if has('nvim')
-        call chansend(l:channel, a:data)
-    else
-        call ch_sendraw(l:channel, a:data)
-    endif
-endfunction
-
-" Get an address for a channel, or an empty string.
-function! ale#socket#GetAddress(channel_id) abort
-    return get(get(s:channel_map, a:channel_id, {}), 'address', '')
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/statusline.vim b/sources_non_forked/ale/autoload/ale/statusline.vim
deleted file mode 100644
index 6b93ba5..0000000
--- a/sources_non_forked/ale/autoload/ale/statusline.vim
+++ /dev/null
@@ -1,135 +0,0 @@
-" Author: KabbAmine <amine.kabb@gmail.com>
-" Additions by: petpetpetpet <chris@freelanceninjas.com>
-" Description: Statusline related function(s)
-
-function! s:CreateCountDict() abort
-    " Keys 0 and 1 are for backwards compatibility.
-    " The count object used to be a List of [error_count, warning_count].
-    return {
-    \   '0': 0,
-    \   '1': 0,
-    \   'error': 0,
-    \   'warning': 0,
-    \   'info': 0,
-    \   'style_error': 0,
-    \   'style_warning': 0,
-    \   'total': 0,
-    \}
-endfunction
-
-" Update the buffer error/warning count with data from loclist.
-function! ale#statusline#Update(buffer, loclist) abort
-    if !exists('g:ale_buffer_info') || !has_key(g:ale_buffer_info, a:buffer)
-        return
-    endif
-
-    let l:loclist = filter(copy(a:loclist), 'v:val.bufnr == a:buffer')
-    let l:count = s:CreateCountDict()
-    let l:count.total = len(l:loclist)
-
-    " Allows easy access to the first instance of each problem type.
-    let l:first_problems = {}
-
-    for l:entry in l:loclist
-        if l:entry.type is# 'W'
-            if get(l:entry, 'sub_type', '') is# 'style'
-                let l:count.style_warning += 1
-
-                if l:count.style_warning == 1
-                    let l:first_problems.style_warning = l:entry
-                endif
-            else
-                let l:count.warning += 1
-
-                if l:count.warning == 1
-                    let l:first_problems.warning = l:entry
-                endif
-            endif
-        elseif l:entry.type is# 'I'
-            let l:count.info += 1
-
-            if l:count.info == 1
-                let l:first_problems.info = l:entry
-            endif
-        elseif get(l:entry, 'sub_type', '') is# 'style'
-            let l:count.style_error += 1
-
-            if l:count.style_error == 1
-                let l:first_problems.style_error = l:entry
-            endif
-        else
-            let l:count.error += 1
-
-            if l:count.error == 1
-                let l:first_problems.error = l:entry
-            endif
-        endif
-    endfor
-
-    " Set keys for backwards compatibility.
-    let l:count[0] = l:count.error + l:count.style_error
-    let l:count[1] = l:count.total - l:count[0]
-
-    let g:ale_buffer_info[a:buffer].count = l:count
-    let g:ale_buffer_info[a:buffer].first_problems = l:first_problems
-endfunction
-
-" Get the counts for the buffer, and update the counts if needed.
-function! s:UpdateCacheIfNecessary(buffer) abort
-    " Cache is cold, so manually ask for an update.
-    if !has_key(g:ale_buffer_info[a:buffer], 'count')
-        call ale#statusline#Update(
-        \   a:buffer,
-        \   g:ale_buffer_info[a:buffer].loclist
-        \)
-    endif
-endfunction
-
-function! s:BufferCacheExists(buffer) abort
-    if !exists('g:ale_buffer_info') || !has_key(g:ale_buffer_info, a:buffer)
-        return 0
-    endif
-
-    return 1
-endfunction
-
-" Get the counts for the buffer, and update the counts if needed.
-function! s:GetCounts(buffer) abort
-    if !s:BufferCacheExists(a:buffer)
-        return s:CreateCountDict()
-    endif
-
-    call s:UpdateCacheIfNecessary(a:buffer)
-
-    return g:ale_buffer_info[a:buffer].count
-endfunction
-
-" Get the dict of first_problems, update the buffer info cache if necessary.
-function! s:GetFirstProblems(buffer) abort
-    if !s:BufferCacheExists(a:buffer)
-        return {}
-    endif
-
-    call s:UpdateCacheIfNecessary(a:buffer)
-
-    return g:ale_buffer_info[a:buffer].first_problems
-endfunction
-
-" Returns a Dictionary with counts for use in third party integrations.
-function! ale#statusline#Count(buffer) abort
-    " The Dictionary is copied here before exposing it to other plugins.
-    return copy(s:GetCounts(a:buffer))
-endfunction
-
-" Returns a copy of the *first* locline instance of the specified problem
-" type. (so this would allow an external integration to know all the info
-" about the first style warning in the file, for example.)
-function! ale#statusline#FirstProblem(buffer, type) abort
-    let l:first_problems = s:GetFirstProblems(a:buffer)
-
-    if !empty(l:first_problems) && has_key(l:first_problems, a:type)
-        return copy(l:first_problems[a:type])
-    endif
-
-    return {}
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/swift.vim b/sources_non_forked/ale/autoload/ale/swift.vim
deleted file mode 100644
index b31b8dc..0000000
--- a/sources_non_forked/ale/autoload/ale/swift.vim
+++ /dev/null
@@ -1,13 +0,0 @@
-" Author: Dan Loman <https://github.com/namolnad>
-" Description: Functions for integrating with Swift tools
-
-" Find the nearest dir containing a Package.swift file and assume it is the root of the Swift project.
-function! ale#swift#FindProjectRoot(buffer) abort
-    let l:swift_config = ale#path#FindNearestFile(a:buffer, 'Package.swift')
-
-    if !empty(l:swift_config)
-        return fnamemodify(l:swift_config, ':h')
-    endif
-
-    return ''
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/symbol.vim b/sources_non_forked/ale/autoload/ale/symbol.vim
deleted file mode 100644
index ae4151a..0000000
--- a/sources_non_forked/ale/autoload/ale/symbol.vim
+++ /dev/null
@@ -1,110 +0,0 @@
-let s:symbol_map = {}
-
-" Used to get the symbol map in tests.
-function! ale#symbol#GetMap() abort
-    return deepcopy(s:symbol_map)
-endfunction
-
-" Used to set the symbol map in tests.
-function! ale#symbol#SetMap(map) abort
-    let s:symbol_map = a:map
-endfunction
-
-function! ale#symbol#ClearLSPData() abort
-    let s:symbol_map = {}
-endfunction
-
-function! ale#symbol#HandleLSPResponse(conn_id, response) abort
-    if has_key(a:response, 'id')
-    \&& has_key(s:symbol_map, a:response.id)
-        let l:options = remove(s:symbol_map, a:response.id)
-
-        let l:result = get(a:response, 'result', v:null)
-        let l:item_list = []
-
-        if type(l:result) is v:t_list
-            " Each item looks like this:
-            " {
-            "   'name': 'foo',
-            "   'kind': 123,
-            "   'deprecated': v:false,
-            "   'location': {
-            "     'uri': 'file://...',
-            "     'range': {
-            "       'start': {'line': 0, 'character': 0},
-            "       'end': {'line': 0, 'character': 0},
-            "     },
-            "   },
-            "   'containerName': 'SomeContainer',
-            " }
-            for l:response_item in l:result
-                let l:location = l:response_item.location
-
-                call add(l:item_list, {
-                \ 'filename': ale#path#FromURI(l:location.uri),
-                \ 'line': l:location.range.start.line + 1,
-                \ 'column': l:location.range.start.character + 1,
-                \ 'match': l:response_item.name,
-                \})
-            endfor
-        endif
-
-        if empty(l:item_list)
-            call ale#util#Execute('echom ''No symbols found.''')
-        else
-            call ale#preview#ShowSelection(l:item_list, l:options)
-        endif
-    endif
-endfunction
-
-function! s:OnReady(query, options, linter, lsp_details) abort
-    let l:id = a:lsp_details.connection_id
-
-    if !ale#lsp#HasCapability(l:id, 'symbol_search')
-        return
-    endif
-
-    let l:buffer = a:lsp_details.buffer
-
-    " If we already made a request, stop here.
-    if getbufvar(l:buffer, 'ale_symbol_request_made', 0)
-        return
-    endif
-
-    let l:Callback = function('ale#symbol#HandleLSPResponse')
-    call ale#lsp#RegisterCallback(l:id, l:Callback)
-
-    let l:message = ale#lsp#message#Symbol(a:query)
-    let l:request_id = ale#lsp#Send(l:id, l:message)
-
-    call setbufvar(l:buffer, 'ale_symbol_request_made', 1)
-    let s:symbol_map[l:request_id] = {
-    \   'buffer': l:buffer,
-    \   'use_relative_paths': has_key(a:options, 'use_relative_paths') ? a:options.use_relative_paths : 0
-    \}
-endfunction
-
-function! ale#symbol#Search(args) abort
-    let [l:opts, l:query] = ale#args#Parse(['relative'], a:args)
-
-    if empty(l:query)
-        throw 'A non-empty string must be provided!'
-    endif
-
-    let l:buffer = bufnr('')
-    let l:options = {}
-
-    if has_key(l:opts, 'relative')
-        let l:options.use_relative_paths = 1
-    endif
-
-    " Set a flag so we only make one request.
-    call setbufvar(l:buffer, 'ale_symbol_request_made', 0)
-    let l:Callback = function('s:OnReady', [l:query, l:options])
-
-    for l:linter in ale#linter#Get(getbufvar(l:buffer, '&filetype'))
-        if !empty(l:linter.lsp) && l:linter.lsp isnot# 'tsserver'
-            call ale#lsp_linter#StartLSP(l:buffer, l:linter, l:Callback)
-        endif
-    endfor
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/test.vim b/sources_non_forked/ale/autoload/ale/test.vim
deleted file mode 100644
index 082d91f..0000000
--- a/sources_non_forked/ale/autoload/ale/test.vim
+++ /dev/null
@@ -1,187 +0,0 @@
-" Author: w0rp <devw0rp@gmail.com>
-" Description: Functions for making testing ALE easier.
-"
-" This file should not typically be loaded during the normal execution of ALE.
-
-" Change the directory for checking things in particular test directories
-"
-" This function will set the g:dir variable, which represents the working
-" directory after changing the path. This variable allows a test to change
-" directories, and then switch back to a directory at the start of the test
-" run.
-"
-" This function should be run in a Vader Before: block.
-function! ale#test#SetDirectory(docker_path) abort
-    if a:docker_path[:len('/testplugin/') - 1] isnot# '/testplugin/'
-        throw 'docker_path must start with /testplugin/!'
-    endif
-
-    " Try to switch directory, which will fail when running tests directly,
-    " and not through the Docker image.
-    silent! execute 'cd ' . fnameescape(a:docker_path)
-    let g:dir = getcwd() " no-custom-checks
-endfunction
-
-" When g:dir is defined, switch back to the directory we saved, and then
-" delete that variable.
-"
-" The filename will be reset to dummy.txt
-"
-" This function should be run in a Vader After: block.
-function! ale#test#RestoreDirectory() abort
-    call ale#test#SetFilename('dummy.txt')
-    silent execute 'cd ' . fnameescape(g:dir)
-    unlet! g:dir
-endfunction
-
-" Change the filename for the current buffer using a relative path to
-" the script without running autocmd commands.
-"
-" If a g:dir variable is set, it will be used as the path to the directory
-" containing the test file.
-function! ale#test#SetFilename(path) abort
-    let l:dir = get(g:, 'dir', '')
-
-    if empty(l:dir)
-        let l:dir = getcwd() " no-custom-checks
-    endif
-
-    let l:full_path = ale#path#IsAbsolute(a:path)
-    \   ? a:path
-    \   : l:dir . '/' . a:path
-
-    silent! noautocmd execute 'file ' . fnameescape(ale#path#Simplify(l:full_path))
-endfunction
-
-function! s:RemoveModule(results) abort
-    for l:item in a:results
-        if has_key(l:item, 'module')
-            call remove(l:item, 'module')
-        endif
-    endfor
-endfunction
-
-" Return loclist data without the module string, only in newer Vim versions.
-function! ale#test#GetLoclistWithoutModule() abort
-    let l:results = getloclist(0)
-    call s:RemoveModule(l:results)
-
-    return l:results
-endfunction
-
-function! ale#test#GetQflistWithoutModule() abort
-    let l:results = getqflist()
-    call s:RemoveModule(l:results)
-
-    return l:results
-endfunction
-
-function! ale#test#GetPreviewWindowText() abort
-    for l:window in range(1, winnr('$'))
-        if getwinvar(l:window, '&previewwindow', 0)
-            let l:buffer = winbufnr(l:window)
-
-            return getbufline(l:buffer, 1, '$')
-        endif
-    endfor
-endfunction
-
-" This function can be called with a timeout to wait for all jobs to finish.
-" If the jobs to not finish in the given number of milliseconds,
-" an exception will be thrown.
-"
-" The time taken will be a very rough approximation, and more time may be
-" permitted than is specified.
-function! ale#test#WaitForJobs(deadline) abort
-    let l:start_time = ale#events#ClockMilliseconds()
-
-    if l:start_time == 0
-        throw 'Failed to read milliseconds from the clock!'
-    endif
-
-    let l:job_list = []
-
-    " Gather all of the jobs from every buffer.
-    for [l:buffer, l:data] in items(ale#command#GetData())
-        call extend(l:job_list, map(keys(l:data.jobs), 'str2nr(v:val)'))
-    endfor
-
-    " NeoVim has a built-in API for this, so use that.
-    if has('nvim')
-        let l:nvim_code_list = jobwait(l:job_list, a:deadline)
-
-        if index(l:nvim_code_list, -1) >= 0
-            throw 'Jobs did not complete on time!'
-        endif
-
-        return
-    endif
-
-    let l:should_wait_more = 1
-
-    while l:should_wait_more
-        let l:should_wait_more = 0
-
-        for l:job_id in l:job_list
-            if ale#job#IsRunning(l:job_id)
-                let l:now = ale#events#ClockMilliseconds()
-
-                if l:now - l:start_time > a:deadline
-                    " Stop waiting after a timeout, so we don't wait forever.
-                    throw 'Jobs did not complete on time!'
-                endif
-
-                " Wait another 10 milliseconds
-                let l:should_wait_more = 1
-                sleep 10ms
-                break
-            endif
-        endfor
-    endwhile
-
-    " Sleep for a small amount of time after all jobs finish.
-    " This seems to be enough to let handlers after jobs end run, and
-    " prevents the occasional failure where this function exits after jobs
-    " end, but before handlers are run.
-    sleep 10ms
-
-    " We must check the buffer data again to see if new jobs started
-    " for command_chain linters.
-    let l:has_new_jobs = 0
-
-    " Check again to see if any jobs are running.
-    for l:info in values(g:ale_buffer_info)
-        for [l:job_id, l:linter] in get(l:info, 'job_list', [])
-            if ale#job#IsRunning(l:job_id)
-                let l:has_new_jobs = 1
-                break
-            endif
-        endfor
-    endfor
-
-    if l:has_new_jobs
-        " We have to wait more. Offset the timeout by the time taken so far.
-        let l:now = ale#events#ClockMilliseconds()
-        let l:new_deadline = a:deadline - (l:now - l:start_time)
-
-        if l:new_deadline <= 0
-            " Enough time passed already, so stop immediately.
-            throw 'Jobs did not complete on time!'
-        endif
-
-        call ale#test#WaitForJobs(l:new_deadline)
-    endif
-endfunction
-
-function! ale#test#FlushJobs() abort
-    " The variable is checked for in a loop, as calling one series of
-    " callbacks can trigger a further series of callbacks.
-    while exists('g:ale_run_synchronously_callbacks')
-        let l:callbacks = g:ale_run_synchronously_callbacks
-        unlet g:ale_run_synchronously_callbacks
-
-        for l:Callback in l:callbacks
-            call l:Callback()
-        endfor
-    endwhile
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/toggle.vim b/sources_non_forked/ale/autoload/ale/toggle.vim
deleted file mode 100644
index 1311e52..0000000
--- a/sources_non_forked/ale/autoload/ale/toggle.vim
+++ /dev/null
@@ -1,100 +0,0 @@
-function! s:EnablePreamble() abort
-    " Set pattern options again, if enabled.
-    if get(g:, 'ale_pattern_options_enabled', 0)
-        call ale#pattern_options#SetOptions(bufnr(''))
-    endif
-
-    " Lint immediately, including running linters against the file.
-    call ale#Queue(0, 'lint_file')
-endfunction
-
-function! s:DisablePostamble() abort
-    " Remove highlights for the current buffer now.
-    if g:ale_set_highlights
-        call ale#highlight#UpdateHighlights()
-    endif
-
-    if g:ale_virtualtext_cursor
-        call ale#virtualtext#Clear()
-    endif
-endfunction
-
-function! ale#toggle#Toggle() abort
-    let g:ale_enabled = !get(g:, 'ale_enabled')
-
-    if g:ale_enabled
-        call s:EnablePreamble()
-
-        if g:ale_set_balloons
-            call ale#balloon#Enable()
-        endif
-    else
-        call ale#engine#CleanupEveryBuffer()
-        call s:DisablePostamble()
-
-        if exists('*ale#balloon#Disable')
-            call ale#balloon#Disable()
-        endif
-    endif
-
-    call ale#events#Init()
-endfunction
-
-function! ale#toggle#Enable() abort
-    if !g:ale_enabled
-        call ale#toggle#Toggle()
-    endif
-endfunction
-
-function! ale#toggle#Disable() abort
-    if g:ale_enabled
-        call ale#toggle#Toggle()
-    endif
-endfunction
-
-function! ale#toggle#Reset() abort
-    call ale#engine#CleanupEveryBuffer()
-    call ale#highlight#UpdateHighlights()
-endfunction
-
-function! ale#toggle#ToggleBuffer(buffer) abort
-    " Get the new value for the toggle.
-    let l:enabled = !getbufvar(a:buffer, 'ale_enabled', 1)
-
-    " Disabling ALE globally removes autocmd events, so we cannot enable
-    " linting locally when linting is disabled globally
-    if l:enabled && !g:ale_enabled
-        execute 'echom ''ALE cannot be enabled locally when disabled globally'''
-
-        return
-    endif
-
-    call setbufvar(a:buffer, 'ale_enabled', l:enabled)
-
-    if l:enabled
-        call s:EnablePreamble()
-    else
-        " Stop all jobs and clear the results for everything, and delete
-        " all of the data we stored for the buffer.
-        call ale#engine#Cleanup(a:buffer)
-        call s:DisablePostamble()
-    endif
-endfunction
-
-function! ale#toggle#EnableBuffer(buffer) abort
-    " ALE is enabled by default for all buffers.
-    if !getbufvar(a:buffer, 'ale_enabled', 1)
-        call ale#toggle#ToggleBuffer(a:buffer)
-    endif
-endfunction
-
-function! ale#toggle#DisableBuffer(buffer) abort
-    if getbufvar(a:buffer, 'ale_enabled', 1)
-        call ale#toggle#ToggleBuffer(a:buffer)
-    endif
-endfunction
-
-function! ale#toggle#ResetBuffer(buffer) abort
-    call ale#engine#Cleanup(a:buffer)
-    call ale#highlight#UpdateHighlights()
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/uri.vim b/sources_non_forked/ale/autoload/ale/uri.vim
deleted file mode 100644
index 934637d..0000000
--- a/sources_non_forked/ale/autoload/ale/uri.vim
+++ /dev/null
@@ -1,18 +0,0 @@
-" This probably doesn't handle Unicode characters well.
-function! ale#uri#Encode(value) abort
-    return substitute(
-    \   a:value,
-    \   '\([^a-zA-Z0-9\\/$\-_.!*''(),]\)',
-    \   '\=printf(''%%%02x'', char2nr(submatch(1)))',
-    \   'g'
-    \)
-endfunction
-
-function! ale#uri#Decode(value) abort
-    return substitute(
-    \   a:value,
-    \   '%\(\x\x\)',
-    \   '\=nr2char(''0x'' . submatch(1))',
-    \   'g'
-    \)
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/util.vim b/sources_non_forked/ale/autoload/ale/util.vim
deleted file mode 100644
index ee62af2..0000000
--- a/sources_non_forked/ale/autoload/ale/util.vim
+++ /dev/null
@@ -1,519 +0,0 @@
-" Author: w0rp <devw0rp@gmail.com>
-" Description: Contains miscellaneous functions
-
-" A wrapper function for mode() so we can test calls for it.
-function! ale#util#Mode(...) abort
-    return call('mode', a:000)
-endfunction
-
-" A wrapper function for feedkeys so we can test calls for it.
-function! ale#util#FeedKeys(...) abort
-    return call('feedkeys', a:000)
-endfunction
-
-" Show a message in as small a window as possible.
-"
-" Vim 8 does not support echoing long messages from asynchronous callbacks,
-" but NeoVim does. Small messages can be echoed in Vim 8, and larger messages
-" have to be shown in preview windows.
-function! ale#util#ShowMessage(string) abort
-    if !has('nvim')
-        call ale#preview#CloseIfTypeMatches('ale-preview.message')
-    endif
-
-    " We have to assume the user is using a monospace font.
-    if has('nvim') || (a:string !~? "\n" && len(a:string) < &columns)
-        execute 'echo a:string'
-    else
-        call ale#preview#Show(split(a:string, "\n"), {
-        \   'filetype': 'ale-preview.message',
-        \   'stay_here': 1,
-        \})
-    endif
-endfunction
-
-" A wrapper function for execute, so we can test executing some commands.
-function! ale#util#Execute(expr) abort
-    execute a:expr
-endfunction
-
-if !exists('g:ale#util#nul_file')
-    " A null file for sending output to nothing.
-    let g:ale#util#nul_file = '/dev/null'
-
-    if has('win32')
-        let g:ale#util#nul_file = 'nul'
-    endif
-endif
-
-" Given a job, a buffered line of data, a list of parts of lines, a mode data
-" is being read in, and a callback, join the lines of output for a NeoVim job
-" or socket together, and call the callback with the joined output.
-"
-" Note that jobs and IDs are the same thing on NeoVim.
-function! ale#util#JoinNeovimOutput(job, last_line, data, mode, callback) abort
-    if a:mode is# 'raw'
-        call a:callback(a:job, join(a:data, "\n"))
-
-        return ''
-    endif
-
-    let l:lines = a:data[:-2]
-
-    if len(a:data) > 1
-        let l:lines[0] = a:last_line . l:lines[0]
-        let l:new_last_line = a:data[-1]
-    else
-        let l:new_last_line = a:last_line . get(a:data, 0, '')
-    endif
-
-    for l:line in l:lines
-        call a:callback(a:job, l:line)
-    endfor
-
-    return l:new_last_line
-endfunction
-
-" Return the number of lines for a given buffer.
-function! ale#util#GetLineCount(buffer) abort
-    return len(getbufline(a:buffer, 1, '$'))
-endfunction
-
-function! ale#util#GetFunction(string_or_ref) abort
-    if type(a:string_or_ref) is v:t_string
-        return function(a:string_or_ref)
-    endif
-
-    return a:string_or_ref
-endfunction
-
-" Open the file (at the given line).
-" options['open_in'] can be:
-"   current-buffer (default)
-"   tab
-"   split
-"   vsplit
-function! ale#util#Open(filename, line, column, options) abort
-    let l:open_in = get(a:options, 'open_in', 'current-buffer')
-    let l:args_to_open = '+' . a:line . ' ' . fnameescape(a:filename)
-
-    if l:open_in is# 'tab'
-        call ale#util#Execute('tabedit ' . l:args_to_open)
-    elseif l:open_in is# 'split'
-        call ale#util#Execute('split ' . l:args_to_open)
-    elseif l:open_in is# 'vsplit'
-        call ale#util#Execute('vsplit ' . l:args_to_open)
-    elseif bufnr(a:filename) isnot bufnr('')
-        " Open another file only if we need to.
-        call ale#util#Execute('edit ' . l:args_to_open)
-    else
-        normal! m`
-    endif
-
-    call cursor(a:line, a:column)
-    normal! zz
-endfunction
-
-let g:ale#util#error_priority = 5
-let g:ale#util#warning_priority = 4
-let g:ale#util#info_priority = 3
-let g:ale#util#style_error_priority = 2
-let g:ale#util#style_warning_priority = 1
-
-function! ale#util#GetItemPriority(item) abort
-    if a:item.type is# 'I'
-        return g:ale#util#info_priority
-    endif
-
-    if a:item.type is# 'W'
-        if get(a:item, 'sub_type', '') is# 'style'
-            return g:ale#util#style_warning_priority
-        endif
-
-        return g:ale#util#warning_priority
-    endif
-
-    if get(a:item, 'sub_type', '') is# 'style'
-        return g:ale#util#style_error_priority
-    endif
-
-    return g:ale#util#error_priority
-endfunction
-
-" Compare two loclist items for ALE, sorted by their buffers, filenames, and
-" line numbers and column numbers.
-function! ale#util#LocItemCompare(left, right) abort
-    if a:left.bufnr < a:right.bufnr
-        return -1
-    endif
-
-    if a:left.bufnr > a:right.bufnr
-        return 1
-    endif
-
-    if a:left.bufnr == -1
-        if a:left.filename < a:right.filename
-            return -1
-        endif
-
-        if a:left.filename > a:right.filename
-            return 1
-        endif
-    endif
-
-    if a:left.lnum < a:right.lnum
-        return -1
-    endif
-
-    if a:left.lnum > a:right.lnum
-        return 1
-    endif
-
-    if a:left.col < a:right.col
-        return -1
-    endif
-
-    if a:left.col > a:right.col
-        return 1
-    endif
-
-    " When either of the items lacks a problem type, then the two items should
-    " be considered equal. This is important for loclist jumping.
-    if !has_key(a:left, 'type') || !has_key(a:right, 'type')
-        return 0
-    endif
-
-    let l:left_priority = ale#util#GetItemPriority(a:left)
-    let l:right_priority = ale#util#GetItemPriority(a:right)
-
-    if l:left_priority < l:right_priority
-        return -1
-    endif
-
-    if l:left_priority > l:right_priority
-        return 1
-    endif
-
-    return 0
-endfunction
-
-" Compare two loclist items, including the text for the items.
-"
-" This function can be used for de-duplicating lists.
-function! ale#util#LocItemCompareWithText(left, right) abort
-    let l:cmp_value = ale#util#LocItemCompare(a:left, a:right)
-
-    if l:cmp_value
-        return l:cmp_value
-    endif
-
-    if a:left.text < a:right.text
-        return -1
-    endif
-
-    if a:left.text > a:right.text
-        return 1
-    endif
-
-    return 0
-endfunction
-
-" This function will perform a binary search and a small sequential search
-" on the list to find the last problem in the buffer and line which is
-" on or before the column. The index of the problem will be returned.
-"
-" -1 will be returned if nothing can be found.
-function! ale#util#BinarySearch(loclist, buffer, line, column) abort
-    let l:min = 0
-    let l:max = len(a:loclist) - 1
-
-    while 1
-        if l:max < l:min
-            return -1
-        endif
-
-        let l:mid = (l:min + l:max) / 2
-        let l:item = a:loclist[l:mid]
-
-        " Binary search for equal buffers, equal lines, then near columns.
-        if l:item.bufnr < a:buffer
-            let l:min = l:mid + 1
-        elseif l:item.bufnr > a:buffer
-            let l:max = l:mid - 1
-        elseif l:item.lnum < a:line
-            let l:min = l:mid + 1
-        elseif l:item.lnum > a:line
-            let l:max = l:mid - 1
-        else
-            " This part is a small sequential search.
-            let l:index = l:mid
-
-            " Search backwards to find the first problem on the line.
-            while l:index > 0
-            \&& a:loclist[l:index - 1].bufnr == a:buffer
-            \&& a:loclist[l:index - 1].lnum == a:line
-                let l:index -= 1
-            endwhile
-
-            " Find the last problem on or before this column.
-            while l:index < l:max
-            \&& a:loclist[l:index + 1].bufnr == a:buffer
-            \&& a:loclist[l:index + 1].lnum == a:line
-            \&& a:loclist[l:index + 1].col <= a:column
-                let l:index += 1
-            endwhile
-
-            " Scan forwards to find the last item on the column for the item
-            " we found, which will have the most serious problem.
-            let l:item_column = a:loclist[l:index].col
-
-            while l:index < l:max
-            \&& a:loclist[l:index + 1].bufnr == a:buffer
-            \&& a:loclist[l:index + 1].lnum == a:line
-            \&& a:loclist[l:index + 1].col == l:item_column
-                let l:index += 1
-            endwhile
-
-            return l:index
-        endif
-    endwhile
-endfunction
-
-" A function for testing if a function is running inside a sandbox.
-" See :help sandbox
-function! ale#util#InSandbox() abort
-    try
-        let &l:equalprg=&l:equalprg
-    catch /E48/
-        " E48 is the sandbox error.
-        return 1
-    endtry
-
-    return 0
-endfunction
-
-function! ale#util#Tempname() abort
-    let l:clear_tempdir = 0
-
-    if exists('$TMPDIR') && empty($TMPDIR)
-        let l:clear_tempdir = 1
-        let $TMPDIR = '/tmp'
-    endif
-
-    try
-        let l:name = tempname() " no-custom-checks
-    finally
-        if l:clear_tempdir
-            let $TMPDIR = ''
-        endif
-    endtry
-
-    return l:name
-endfunction
-
-" Given a single line, or a List of lines, and a single pattern, or a List
-" of patterns, return all of the matches for the lines(s) from the given
-" patterns, using matchlist().
-"
-" Only the first pattern which matches a line will be returned.
-function! ale#util#GetMatches(lines, patterns) abort
-    let l:matches = []
-    let l:lines = type(a:lines) is v:t_list ? a:lines : [a:lines]
-    let l:patterns = type(a:patterns) is v:t_list ? a:patterns : [a:patterns]
-
-    for l:line in l:lines
-        for l:pattern in l:patterns
-            let l:match = matchlist(l:line, l:pattern)
-
-            if !empty(l:match)
-                call add(l:matches, l:match)
-                break
-            endif
-        endfor
-    endfor
-
-    return l:matches
-endfunction
-
-function! s:LoadArgCount(function) abort
-    try
-        let l:output = execute('function a:function')
-    catch /E123/
-        return 0
-    endtry
-
-    let l:match = matchstr(split(l:output, "\n")[0], '\v\([^)]+\)')[1:-2]
-    let l:arg_list = filter(split(l:match, ', '), 'v:val isnot# ''...''')
-
-    return len(l:arg_list)
-endfunction
-
-" Given the name of a function, a Funcref, or a lambda, return the number
-" of named arguments for a function.
-function! ale#util#FunctionArgCount(function) abort
-    let l:Function = ale#util#GetFunction(a:function)
-    let l:count = s:LoadArgCount(l:Function)
-
-    " If we failed to get the count, forcibly load the autoload file, if the
-    " function is an autoload function. autoload functions aren't normally
-    " defined until they are called.
-    if l:count == 0
-        let l:function_name = matchlist(string(l:Function), 'function([''"]\(.\+\)[''"])')[1]
-
-        if l:function_name =~# '#'
-            execute 'runtime autoload/' . join(split(l:function_name, '#')[:-2], '/') . '.vim'
-            let l:count = s:LoadArgCount(l:Function)
-        endif
-    endif
-
-    return l:count
-endfunction
-
-" Escape a string so the characters in it will be safe for use inside of PCRE
-" or RE2 regular expressions without characters having special meanings.
-function! ale#util#EscapePCRE(unsafe_string) abort
-    return substitute(a:unsafe_string, '\([\-\[\]{}()*+?.^$|]\)', '\\\1', 'g')
-endfunction
-
-" Escape a string so that it can be used as a literal string inside an evaled
-" vim command.
-function! ale#util#EscapeVim(unsafe_string) abort
-    return "'" . substitute(a:unsafe_string, "'", "''", 'g') . "'"
-endfunction
-
-
-" Given a String or a List of String values, try and decode the string(s)
-" as a JSON value which can be decoded with json_decode. If the JSON string
-" is invalid, the default argument value will be returned instead.
-"
-" This function is useful in code where the data can't be trusted to be valid
-" JSON, and where throwing exceptions is mostly just irritating.
-function! ale#util#FuzzyJSONDecode(data, default) abort
-    if empty(a:data)
-        return a:default
-    endif
-
-    let l:str = type(a:data) is v:t_string ? a:data : join(a:data, '')
-
-    try
-        let l:result = json_decode(l:str)
-
-        " Vim 8 only uses the value v:none for decoding blank strings.
-        if !has('nvim') && l:result is v:none
-            return a:default
-        endif
-
-        return l:result
-    catch /E474/
-        return a:default
-    endtry
-endfunction
-
-" Write a file, including carriage return characters for DOS files.
-"
-" The buffer number is required for determining the fileformat setting for
-" the buffer.
-function! ale#util#Writefile(buffer, lines, filename) abort
-    let l:corrected_lines = getbufvar(a:buffer, '&fileformat') is# 'dos'
-    \   ? map(copy(a:lines), 'substitute(v:val, ''\r*$'', ''\r'', '''')')
-    \   : a:lines
-
-    call writefile(l:corrected_lines, a:filename, 'S') " no-custom-checks
-endfunction
-
-if !exists('s:patial_timers')
-    let s:partial_timers = {}
-endif
-
-function! s:ApplyPartialTimer(timer_id) abort
-    if has_key(s:partial_timers, a:timer_id)
-        let [l:Callback, l:args] = remove(s:partial_timers, a:timer_id)
-        call call(l:Callback, [a:timer_id] + l:args)
-    endif
-endfunction
-
-" Given a delay, a callback, a List of arguments, start a timer with
-" timer_start() and call the callback provided with [timer_id] + args.
-"
-" The timer must not be stopped with timer_stop().
-" Use ale#util#StopPartialTimer() instead, which can stop any timer, and will
-" clear any arguments saved for executing callbacks later.
-function! ale#util#StartPartialTimer(delay, callback, args) abort
-    let l:timer_id = timer_start(a:delay, function('s:ApplyPartialTimer'))
-    let s:partial_timers[l:timer_id] = [a:callback, a:args]
-
-    return l:timer_id
-endfunction
-
-function! ale#util#StopPartialTimer(timer_id) abort
-    call timer_stop(a:timer_id)
-
-    if has_key(s:partial_timers, a:timer_id)
-        call remove(s:partial_timers, a:timer_id)
-    endif
-endfunction
-
-" Given a possibly multi-byte string and a 1-based character position on a
-" line, return the 1-based byte position on that line.
-function! ale#util#Col(str, chr) abort
-    if a:chr < 2
-        return a:chr
-    endif
-
-    return strlen(join(split(a:str, '\zs')[0:a:chr - 2], '')) + 1
-endfunction
-
-function! ale#util#FindItemAtCursor(buffer) abort
-    let l:info = get(g:ale_buffer_info, a:buffer, {})
-    let l:loclist = get(l:info, 'loclist', [])
-    let l:pos = getpos('.')
-    let l:index = ale#util#BinarySearch(l:loclist, a:buffer, l:pos[1], l:pos[2])
-    let l:loc = l:index >= 0 ? l:loclist[l:index] : {}
-
-    return [l:info, l:loc]
-endfunction
-
-function! ale#util#Input(message, value) abort
-    return input(a:message, a:value)
-endfunction
-
-function! ale#util#HasBuflineApi() abort
-    return exists('*deletebufline') && exists('*setbufline')
-endfunction
-
-" Sets buffer contents to lines
-function! ale#util#SetBufferContents(buffer, lines) abort
-    let l:has_bufline_api = ale#util#HasBuflineApi()
-
-    if !l:has_bufline_api && a:buffer isnot bufnr('')
-        return
-    endif
-
-    " If the file is in DOS mode, we have to remove carriage returns from
-    " the ends of lines before calling setline(), or we will see them
-    " twice.
-    let l:new_lines = getbufvar(a:buffer, '&fileformat') is# 'dos'
-    \   ? map(copy(a:lines), 'substitute(v:val, ''\r\+$'', '''', '''')')
-    \   : a:lines
-    let l:first_line_to_remove = len(l:new_lines) + 1
-
-    " Use a Vim API for setting lines in other buffers, if available.
-    if l:has_bufline_api
-        call setbufline(a:buffer, 1, l:new_lines)
-        call deletebufline(a:buffer, l:first_line_to_remove, '$')
-    " Fall back on setting lines the old way, for the current buffer.
-    else
-        let l:old_line_length = line('$')
-
-        if l:old_line_length >= l:first_line_to_remove
-            let l:save = winsaveview()
-            silent execute
-            \   l:first_line_to_remove . ',' . l:old_line_length . 'd_'
-            call winrestview(l:save)
-        endif
-
-        call setline(1, l:new_lines)
-    endif
-
-    return l:new_lines
-endfunction
diff --git a/sources_non_forked/ale/autoload/ale/virtualtext.vim b/sources_non_forked/ale/autoload/ale/virtualtext.vim
deleted file mode 100644
index d7c5360..0000000
--- a/sources_non_forked/ale/autoload/ale/virtualtext.vim
+++ /dev/null
@@ -1,135 +0,0 @@
-scriptencoding utf-8
-" Author: w0rp <devw0rp@gmail.com>
-" Author: Luan Santos <cfcluan@gmail.com>
-" Description: Shows lint message for the current line as virtualtext, if any
-
-" Controls the milliseconds delay before showing a message.
-let g:ale_virtualtext_delay = get(g:, 'ale_virtualtext_delay', 10)
-let s:cursor_timer = -1
-let s:last_pos = [0, 0, 0]
-
-if has('nvim-0.3.2')
-    let s:ns_id = nvim_create_namespace('ale')
-endif
-
-if !hlexists('ALEVirtualTextError')
-    highlight link ALEVirtualTextError ALEError
-endif
-
-if !hlexists('ALEVirtualTextStyleError')
-    highlight link ALEVirtualTextStyleError ALEVirtualTextError
-endif
-
-if !hlexists('ALEVirtualTextWarning')
-    highlight link ALEVirtualTextWarning ALEWarning
-endif
-
-if !hlexists('ALEVirtualTextStyleWarning')
-    highlight link ALEVirtualTextStyleWarning ALEVirtualTextWarning
-endif
-
-if !hlexists('ALEVirtualTextInfo')
-    highlight link ALEVirtualTextInfo ALEVirtualTextWarning
-endif
-
-function! ale#virtualtext#Clear() abort
-    if !has('nvim-0.3.2')
-        return
-    endif
-
-    let l:buffer = bufnr('')
-
-    call nvim_buf_clear_highlight(l:buffer, s:ns_id, 0, -1)
-endfunction
-
-function! ale#virtualtext#ShowMessage(message, hl_group) abort
-    if !has('nvim-0.3.2')
-        return
-    endif
-
-    let l:line = line('.')
-    let l:buffer = bufnr('')
-    let l:prefix = get(g:, 'ale_virtualtext_prefix', '> ')
-
-    call nvim_buf_set_virtual_text(l:buffer, s:ns_id, l:line-1, [[l:prefix.a:message, a:hl_group]], {})
-endfunction
-
-function! s:StopCursorTimer() abort
-    if s:cursor_timer != -1
-        call timer_stop(s:cursor_timer)
-        let s:cursor_timer = -1
-    endif
-endfunction
-
-function! ale#virtualtext#ShowCursorWarning(...) abort
-    if !g:ale_virtualtext_cursor
-        return
-    endif
-
-    let l:buffer = bufnr('')
-
-    if mode(1) isnot# 'n'
-        return
-    endif
-
-    if ale#ShouldDoNothing(l:buffer)
-        return
-    endif
-
-    let [l:info, l:loc] = ale#util#FindItemAtCursor(l:buffer)
-
-    call ale#virtualtext#Clear()
-
-    if !empty(l:loc)
-        let l:msg = l:loc.text
-        let l:hl_group = 'ALEVirtualTextInfo'
-        let l:type = get(l:loc, 'type', 'E')
-
-        if l:type is# 'E'
-            if get(l:loc, 'sub_type', '') is# 'style'
-                let l:hl_group = 'ALEVirtualTextStyleError'
-            else
-                let l:hl_group = 'ALEVirtualTextError'
-            endif
-        elseif l:type is# 'W'
-            if get(l:loc, 'sub_type', '') is# 'style'
-                let l:hl_group = 'ALEVirtualTextStyleWarning'
-            else
-                let l:hl_group = 'ALEVirtualTextWarning'
-            endif
-        endif
-
-        call ale#virtualtext#ShowMessage(l:msg, l:hl_group)
-    endif
-endfunction
-
-function! ale#virtualtext#ShowCursorWarningWithDelay() abort
-    let l:buffer = bufnr('')
-
-    if !g:ale_virtualtext_cursor
-        return
-    endif
-
-    if mode(1) isnot# 'n'
-        return
-    endif
-
-    call s:StopCursorTimer()
-
-    let l:pos = getpos('.')[0:2]
-
-    " Check the current buffer, line, and column number against the last
-    " recorded position. If the position has actually changed, *then*
-    " we should show something. Otherwise we can end up doing processing
-    " the show message far too frequently.
-    if l:pos != s:last_pos
-        let l:delay = ale#Var(l:buffer, 'virtualtext_delay')
-
-        let s:last_pos = l:pos
-        let s:cursor_timer = timer_start(
-        \   l:delay,
-        \   function('ale#virtualtext#ShowCursorWarning')
-        \)
-    endif
-endfunction
-
diff --git a/sources_non_forked/ale/autoload/asyncomplete/sources/ale.vim b/sources_non_forked/ale/autoload/asyncomplete/sources/ale.vim
deleted file mode 100644
index ce79377..0000000
--- a/sources_non_forked/ale/autoload/asyncomplete/sources/ale.vim
+++ /dev/null
@@ -1,26 +0,0 @@
-function! asyncomplete#sources#ale#get_source_options(...) abort
-    let l:default = extend({
-    \     'name': 'ale',
-    \     'completor': function('asyncomplete#sources#ale#completor'),
-    \     'whitelist': ['*'],
-    \     'triggers': asyncomplete#sources#ale#get_triggers(),
-    \ }, a:0 >= 1 ? a:1 : {})
-
-    return extend(l:default, {'refresh_pattern': '\k\+$'})
-endfunction
-
-function! asyncomplete#sources#ale#get_triggers() abort
-    let l:triggers = ale#completion#GetAllTriggers()
-    let l:triggers['*'] = l:triggers['<default>']
-
-    return l:triggers
-endfunction
-
-function! asyncomplete#sources#ale#completor(options, context) abort
-    let l:keyword = matchstr(a:context.typed, '\w\+$')
-    let l:startcol = a:context.col - len(l:keyword)
-
-    call ale#completion#GetCompletions('ale-callback', { 'callback': {completions ->
-    \   asyncomplete#complete(a:options.name, a:context, l:startcol, completions)
-    \ }})
-endfunction
diff --git a/sources_non_forked/ale/doc/ale-ada.txt b/sources_non_forked/ale/doc/ale-ada.txt
deleted file mode 100644
index 2ac30c0..0000000
--- a/sources_non_forked/ale/doc/ale-ada.txt
+++ /dev/null
@@ -1,36 +0,0 @@
-===============================================================================
-ALE Ada Integration                                           *ale-ada-options*
-
-
-===============================================================================
-gcc                                                               *ale-ada-gcc*
-
-g:ale_ada_gcc_executable                             *g:ale_ada_gcc_executable*
-                                                     *b:ale_ada_gcc_executable*
-  Type: |String|
-  Default: `'gcc'`
-
-This variable can be changed to use a different executable for gcc.
-
-
-g:ale_ada_gcc_options                                   *g:ale_ada_gcc_options*
-                                                        *b:ale_ada_gcc_options*
-  Type: |String|
-  Default: `'-gnatwa -gnatq'`
-
-  This variable can be set to pass additional options to gcc.
-
-
-===============================================================================
-gnatpp                                                         *ale-ada-gnatpp*
-
-g:ale_ada_gnatpp_options                             *g:ale_ada_gnatpp_options*
-                                                     *b:ale_ada_gnatpp_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be set to pass extra options to the gnatpp fixer.
-
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-ansible.txt b/sources_non_forked/ale/doc/ale-ansible.txt
deleted file mode 100644
index 3a4efaa..0000000
--- a/sources_non_forked/ale/doc/ale-ansible.txt
+++ /dev/null
@@ -1,16 +0,0 @@
-===============================================================================
-ALE Ansible Integration                                   *ale-ansible-options*
-
-
-===============================================================================
-ansible-lint                                         *ale-ansible-ansible-lint*
-
-g:ale_ansible_ansible_lint_executable   *g:ale_ansible_ansible_lint_executable*
-                                        *b:ale_ansible_ansible_lint_executable*
-  Type: |String|
-  Default: `'ansible-lint'`
-
-  This variable can be changed to modify the executable used for ansible-lint.
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-asciidoc.txt b/sources_non_forked/ale/doc/ale-asciidoc.txt
deleted file mode 100644
index 86629fd..0000000
--- a/sources_non_forked/ale/doc/ale-asciidoc.txt
+++ /dev/null
@@ -1,18 +0,0 @@
-===============================================================================
-ALE AsciiDoc Integration                                 *ale-asciidoc-options*
-
-
-===============================================================================
-write-good                                            *ale-asciidoc-write-good*
-
-See |ale-write-good-options|
-
-
-===============================================================================
-textlint                                                *ale-asciidoc-textlint*
-
-See |ale-text-textlint|
-
-
-===============================================================================
-vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-asm.txt b/sources_non_forked/ale/doc/ale-asm.txt
deleted file mode 100644
index a97c6d0..0000000
--- a/sources_non_forked/ale/doc/ale-asm.txt
+++ /dev/null
@@ -1,25 +0,0 @@
-===============================================================================
-ALE ASM Integration                                           *ale-asm-options*
-
-
-===============================================================================
-gcc                                                               *ale-asm-gcc*
-
-g:ale_asm_gcc_executable                             *g:ale_asm_gcc_executable*
-                                                     *b:ale_asm_gcc_executable*
-  Type: |String|
-  Default: `'gcc'`
-
-This variable can be changed to use a different executable for gcc.
-
-
-g:ale_asm_gcc_options                                   *g:ale_asm_gcc_options*
-                                                        *b:ale_asm_gcc_options*
-  Type: |String|
-  Default: `'-Wall'`
-
-  This variable can be set to pass additional options to gcc.
-
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-awk.txt b/sources_non_forked/ale/doc/ale-awk.txt
deleted file mode 100644
index b9c5c34..0000000
--- a/sources_non_forked/ale/doc/ale-awk.txt
+++ /dev/null
@@ -1,25 +0,0 @@
-===============================================================================
-ALE Awk Integration                                           *ale-awk-options*
-
-
-===============================================================================
-gawk                                                             *ale-awk-gawk*
-
-g:ale_awk_gawk_executable                           *g:ale_awk_gawk_executable*
-                                                    *b:ale_awk_gawk_executable*
-  Type: |String|
-  Default: `'gawk'`
-
-  This variable sets executable used for gawk.
-
-
-g:ale_awk_gawk_options                                 *g:ale_awk_gawk_options*
-                                                       *b:ale_awk_gawk_options*
-  Type: |String|
-  Default: `''`
-
-  With this variable we are able to pass extra arguments for gawk
-  for invocation.
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-bats.txt b/sources_non_forked/ale/doc/ale-bats.txt
deleted file mode 100644
index cf2199e..0000000
--- a/sources_non_forked/ale/doc/ale-bats.txt
+++ /dev/null
@@ -1,13 +0,0 @@
-===============================================================================
-ALE Bats Integration                                           *ale-bats-options*
-
-
-===============================================================================
-shellcheck                                                  *ale-bats-shellcheck*
-
-The `shellcheck` linter for Bats uses the sh options for `shellcheck`; see:
-|ale-sh-shellcheck|.
-
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-bib.txt b/sources_non_forked/ale/doc/ale-bib.txt
deleted file mode 100644
index 35998c3..0000000
--- a/sources_non_forked/ale/doc/ale-bib.txt
+++ /dev/null
@@ -1,19 +0,0 @@
-===============================================================================
-ALE BibTeX Integration                                        *ale-bib-options*
-
-
-===============================================================================
-bibclean                                                     *ale-bib-bibclean*
-
-g:ale_bib_bibclean_executable                   *g:ale_bib_bibclean_executable*
-
-  Type: |String|
-  Default: `'bibclean'`
-
-g:ale_bib_bibclean_options                         *g:ale_bib_bibclean_options*
-
-  Type: |String|
-  Default: `'-align-equals'`
-
-===============================================================================
-vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-c.txt b/sources_non_forked/ale/doc/ale-c.txt
deleted file mode 100644
index c9eb79d..0000000
--- a/sources_non_forked/ale/doc/ale-c.txt
+++ /dev/null
@@ -1,333 +0,0 @@
-===============================================================================
-ALE C Integration                                               *ale-c-options*
-
-
-===============================================================================
-Global Options
-
-g:ale_c_build_dir_names                               *g:ale_c_build_dir_names*
-                                                      *b:ale_c_build_dir_names*
-
-  Type: |List|
-  Default: `['build', 'bin']`
-
-  A list of directory names to be used when searching upwards from cpp
-  files to discover compilation databases with. For directory named `'foo'`,
-  ALE will search for `'foo/compile_commands.json'` in all directories on and above
-  the directory containing the cpp file to find path to compilation database.
-  This feature is useful for the clang tools wrapped around LibTooling (namely
-  here, clang-tidy)
-
-
-g:ale_c_build_dir                                           *g:ale_c_build_dir*
-                                                            *b:ale_c_build_dir*
-
-  Type: |String|
-  Default: `''`
-
-  For programs that can read `compile_commands.json` files, this option can be
-  set to the directory containing the file for the project. ALE will try to
-  determine the location of `compile_commands.json` automatically, but if your
-  file exists in some other directory, you can set this option so ALE will
-  know where it is.
-
-  This directory will be searched instead of |g:ale_c_build_dir_names|.
-
-
-g:ale_c_parse_compile_commands                 *g:ale_c_parse_compile_commands*
-                                               *b:ale_c_parse_compile_commands*
-  Type: |Number|
-  Default: `0`
-
-  If set to `1`, ALE will parse `compile_commands.json` files to automatically
-  determine flags for C or C++ compilers. ALE will first search for the
-  nearest `compile_commands.json` file, and then look for
-  `compile_commands.json` files in the directories for
-  |g:ale_c_build_dir_names|.
-
-  If |g:ale_c_parse_makefile| or |b:ale_c_parse_makefile| is set to `1`, the
-  output of `make -n` will be preferred over `compile_commands.json` files.
-
-
-g:ale_c_parse_makefile                                 *g:ale_c_parse_makefile*
-                                                       *b:ale_c_parse_makefile*
-  Type: |Number|
-  Default: `0`
-
-  If set to `1`, ALE will run `make -n` to automatically determine flags to
-  set for C or C++ compilers. This can make it easier to determine the correct
-  build flags to use for different files.
-
-
-===============================================================================
-clang                                                             *ale-c-clang*
-
-g:ale_c_clang_executable                             *g:ale_c_clang_executable*
-                                                     *b:ale_c_clang_executable*
-  Type: |String|
-  Default: `'clang'`
-
-  This variable can be changed to use a different executable for clang.
-
-
-g:ale_c_clang_options                                   *g:ale_c_clang_options*
-                                                        *b:ale_c_clang_options*
-  Type: |String|
-  Default: `'-std=c11 -Wall'`
-
-  This variable can be changed to modify flags given to clang.
-
-
-===============================================================================
-clangd                                                           *ale-c-clangd*
-
-g:ale_c_clangd_executable                           *g:ale_c_clangd_executable*
-                                                    *b:ale_c_clangd_executable*
-  Type: |String|
-  Default: `'clangd'`
-
-  This variable can be changed to use a different executable for clangd.
-
-
-g:ale_c_clangd_options                                 *g:ale_c_clangd_options*
-                                                       *b:ale_c_clangd_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be changed to modify flags given to clangd.
-
-
-===============================================================================
-clang-format                                                *ale-c-clangformat*
-
-g:ale_c_clangformat_executable                 *g:ale_c_clangformat_executable*
-                                               *b:ale_c_clangformat_executable*
-  Type: |String|
-  Default: `'clang-format'`
-
-  This variable can be changed to use a different executable for clang-format.
-
-
-g:ale_c_clangformat_options                       *g:ale_c_clangformat_options*
-                                                  *b:ale_c_clangformat_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be change to modify flags given to clang-format.
-
-
-===============================================================================
-clangtidy                                                     *ale-c-clangtidy*
-
-`clang-tidy` will be run only when files are saved to disk, so that
-`compile_commands.json` files can be used. It is recommended to use this
-linter in combination with `compile_commands.json` files.
-Therefore, `clang-tidy` linter reads the options |g:ale_c_build_dir| and
-|g:ale_c_build_dir_names|. Also, setting |g:ale_c_build_dir| actually
-overrides |g:ale_c_build_dir_names|.
-
-
-g:ale_c_clangtidy_checks                             *g:ale_c_clangtidy_checks*
-                                                     *b:ale_c_clangtidy_checks*
-  Type: |List|
-  Default: `[]`
-
-  The checks to enable for clang-tidy with the `-checks` argument.
-
-  All options will be joined with commas, and escaped appropriately for
-  the shell. The `-checks` flag can be removed entirely by setting this
-  option to an empty List.
-
-  Not all of clangtidy checks are applicable for C. You should consult the
-  clang documentation for an up-to-date list of compatible checks:
-  http://clang.llvm.org/extra/clang-tidy/checks/list.html
-
-
-g:ale_c_clangtidy_executable                     *g:ale_c_clangtidy_executable*
-                                                 *b:ale_c_clangtidy_executable*
-  Type: |String|
-  Default: `'clang-tidy'`
-
-  This variable can be changed to use a different executable for clangtidy.
-
-
-g:ale_c_clangtidy_options                           *g:ale_c_clangtidy_options*
-                                                    *b:ale_c_clangtidy_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be changed to modify compiler flags given to clang-tidy.
-
-  - Setting this variable to a non-empty string,
-  - and working in a buffer where no compilation database is found using
-    |g:ale_c_build_dir_names| or |g:ale_c_build_dir|,
-  will cause the `--` argument to be passed to `clang-tidy`, which will mean
-  that detection of `compile_commands.json` files for compile command
-  databases will be disabled.
-  Only set this option if you want to control compiler flags
-  entirely manually, and no `compile_commands.json` file is in one
-  of the |g:ale_c_build_dir_names| directories of the project tree.
-
-
-g:ale_c_clangtidy_extra_options               *g:ale_c_clangtidy_extra_options*
-                                              *b:ale_c_clangtidy_extra_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be changed to modify flags given to clang-tidy.
-
-
-g:ale_c_clangtidy_fix_errors                     *g:ale_c_clangtidy_fix_errors*
-                                                 *b:ale_c_clangtidy_fix_errors*
-  Type: |Number|
-  Default: `1`
-
-  This variable can be changed to disable the `-fix-errors` option for the
-  |clangtidy| fixer.
-
-
-===============================================================================
-cppcheck                                                       *ale-c-cppcheck*
-
-g:ale_c_cppcheck_executable                       *g:ale_c_cppcheck_executable*
-                                                  *b:ale_c_cppcheck_executable*
-  Type: |String|
-  Default: `'cppcheck'`
-
-  This variable can be changed to use a different executable for cppcheck.
-
-
-g:ale_c_cppcheck_options                             *g:ale_c_cppcheck_options*
-                                                     *b:ale_c_cppcheck_options*
-  Type: |String|
-  Default: `'--enable=style'`
-
-  This variable can be changed to modify flags given to cppcheck.
-
-
-===============================================================================
-cquery                                                           *ale-c-cquery*
-
-g:ale_c_cquery_executable                           *g:ale_c_cquery_executable*
-                                                    *b:ale_c_cquery_executable*
-  Type: |String|
-  Default: `'cquery'`
-
-  This variable can be changed to use a different executable for cquery.
-
-
-g:ale_cpp_cquery_cache_directory               *g:ale_c_cquery_cache_directory*
-                                               *b:ale_c_cquery_cache_directory*
-  Type: |String|
-  Default: `'~/.cache/cquery'`
-
-  This variable can be changed to decide which directory cquery uses for its
-cache.
-
-
-===============================================================================
-flawfinder                                                   *ale-c-flawfinder*
-
-g:ale_c_flawfinder_executable                   *g:ale_c_flawfinder_executable*
-                                                *b:ale_c_flawfinder_executable*
-  Type: |String|
-  Default: `'flawfinder'`
-
-  This variable can be changed to use a different executable for flawfinder.
-
-
-g:ale_c_flawfinder_minlevel                       *g:ale_c_flawfinder_minlevel*
-                                                  *b:ale_c_flawfinder_minlevel*
-  Type: |Number|
-  Default: `1`
-
-  This variable can be changed to ignore risks under the given risk threshold.
-
-
-g:ale_c_flawfinder_options                                 *g:ale-c-flawfinder*
-                                                           *b:ale-c-flawfinder*
-  Type: |String|
-  Default: `''`
-
-  This variable can be used to pass extra options into the flawfinder command.
-
-g:ale_c_flawfinder_error_severity           *g:ale_c_flawfinder_error_severity*
-                                            *b:ale_c_flawfinder_error_severity*
-  Type: |Number|
-  Default: `6`
-
-  This variable can be changed to set the minimum severity to be treated as an
-  error.  This setting also applies to flawfinder for c++.
-
-
-===============================================================================
-gcc                                                                 *ale-c-gcc*
-
-g:ale_c_gcc_executable                                 *g:ale_c_gcc_executable*
-                                                       *b:ale_c_gcc_executable*
-  Type: |String|
-  Default: `'gcc'`
-
-  This variable can be changed to use a different executable for gcc.
-
-
-g:ale_c_gcc_options                                       *g:ale_c_gcc_options*
-                                                          *b:ale_c_gcc_options*
-  Type: |String|
-  Default: `'-std=c11 -Wall'`
-
-  This variable can be change to modify flags given to gcc.
-
-
-===============================================================================
-uncrustify                                                   *ale-c-uncrustify*
-
-g:ale_c_uncrustify_executable                   *g:ale_c_uncrustify_executable*
-                                                *b:ale_c_uncrustify_executable*
-  Type: |String|
-  Default: `'uncrustify'`
-
-  This variable can be changed to use a different executable for uncrustify.
-
-
-g:ale_c_uncrustify_options                         *g:ale_c_uncrustify_options*
-                                                   *b:ale_c_uncrustify_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be change to modify flags given to uncrustify.
-
-
-===============================================================================
-ccls                                                               *ale-c-ccls*
-
-g:ale_c_ccls_executable                               *g:ale_c_ccls_executable*
-                                                      *b:ale_c_ccls_executable*
-  Type: |String|
-  Default: `'ccls'`
-
-  This variable can be changed to use a different executable for ccls.
-
-
-g:ale_c_ccls_init_options                           *g:ale_c_ccls_init_options*
-                                                    *b:ale_c_ccls_init_options*
-  Type: |Dictionary|
-  Default: `{}`
-
-  This variable can be changed to customize ccls initialization options.
-  Example: >
-      {
-    \   'cacheDirectory': '/tmp/ccls',
-    \   'cacheFormat': 'binary',
-    \   'diagnostics': {
-    \     'onOpen': 0,
-    \     'opChange': 1000,
-    \   },
-    \ }
-<
-  Visit https://github.com/MaskRay/ccls/wiki/Initialization-options for all
-  available options and explanations.
-
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-chef.txt b/sources_non_forked/ale/doc/ale-chef.txt
deleted file mode 100644
index 75e144e..0000000
--- a/sources_non_forked/ale/doc/ale-chef.txt
+++ /dev/null
@@ -1,46 +0,0 @@
-===============================================================================
-ALE Chef Integration                                         *ale-chef-options*
-
-
-===============================================================================
-cookstyle                                                  *ale-chef-cookstyle*
-
-g:ale_chef_cookstyle_options                     *g:ale_chef_cookstyle_options*
-                                                 *b:ale_chef_cookstyle_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be changed to modify flags given to cookstyle.
-
-
-g:ale_chef_cookstyle_executable               *g:ale_chef_cookstyle_executable*
-                                              *b:ale_chef_cookstyle_executable*
-  Type: |String|
-  Default: `'cookstyle'`
-
-  This variable can be changed to point to the cookstyle binary in case it's
-  not on the $PATH or a specific version/path must be used.
-
-
-===============================================================================
-foodcritic                                                *ale-chef-foodcritic*
-
-g:ale_chef_foodcritic_options                   *g:ale_chef_foodcritic_options*
-                                                *b:ale_chef_foodcritic_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be changed to modify flags given to foodcritic.
-
-
-g:ale_chef_foodcritic_executable             *g:ale_chef_foodcritic_executable*
-                                             *b:ale_chef_foodcritic_executable*
-  Type: |String|
-  Default: `'foodcritic'`
-
-  This variable can be changed to point to the foodcritic binary in case it's
-  not on the $PATH or a specific version/path must be used.
-
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-clojure.txt b/sources_non_forked/ale/doc/ale-clojure.txt
deleted file mode 100644
index 2bf00c0..0000000
--- a/sources_non_forked/ale/doc/ale-clojure.txt
+++ /dev/null
@@ -1,28 +0,0 @@
-===============================================================================
-ALE Clojure Integration                                   *ale-clojure-options*
-
-
-===============================================================================
-clj-kondo                                               *ale-clojure-clj-kondo*
-
-A minimal and opinionated linter for code that sparks joy.
-
-https://github.com/borkdude/clj-kondo
-
-===============================================================================
-joker                                                       *ale-clojure-joker*
-
-Joker is a small Clojure interpreter and linter written in Go.
-
-https://github.com/candid82/joker
-
-Linting options are not configurable by ale, but instead are controlled by a
-`.joker` file in same directory as the file (or current working directory if
-linting stdin), a parent directory relative to the file, or the users home
-directory.
-
-see https://github.com/candid82/joker#linter-mode for more information.
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
-
diff --git a/sources_non_forked/ale/doc/ale-cloudformation.txt b/sources_non_forked/ale/doc/ale-cloudformation.txt
deleted file mode 100644
index 9724403..0000000
--- a/sources_non_forked/ale/doc/ale-cloudformation.txt
+++ /dev/null
@@ -1,46 +0,0 @@
-===============================================================================
-ALE CloudFormation Integration                      *ale-cloudformation-options*
-
-
-===============================================================================
-cfn-python-lint                             *ale-cloudformation-cfn-python-lint*
-
-cfn-python-lint is a linter for AWS CloudFormation template file.
-
-Website: https://github.com/awslabs/cfn-python-lint
-
-Installation
--------------------------------------------------------------------------------
-
-
-Install cfn-python-lint using either pip or brew: >
-
-`pip install cfn-lint`. If pip is not available, run
-`python setup.py clean --all` then `python setup.py install`.
-
- Homebrew (macOS):
-
-`brew install cfn-lint`
-
-<
-Configuration
--------------------------------------------------------------------------------
-
-To get cloudformation linter to work on only CloudFormation files  we must set
-the buffer |filetype| to yaml.cloudformation.
-This causes ALE to lint the file with linters configured for cloudformation and
-yaml files.
-
-Just put:
-
->
-
- au BufRead,BufNewFile *.template.yaml set filetype=yaml.cloudformation
-
-<
-
-on `ftdetect/cloudformation.vim`
-
-This will get both cloudformation and yaml linters to work on any file with `.template.yaml` ext.
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-cmake.txt b/sources_non_forked/ale/doc/ale-cmake.txt
deleted file mode 100644
index 602637b..0000000
--- a/sources_non_forked/ale/doc/ale-cmake.txt
+++ /dev/null
@@ -1,43 +0,0 @@
-===============================================================================
-ALE CMake Integration                                       *ale-cmake-options*
-
-
-===============================================================================
-cmakelint                                                 *ale-cmake-cmakelint*
-
-g:ale_cmake_cmakelint_executable             *g:ale_cmake_cmakelint_executable*
-                                             *b:ale_cmake_cmakelint_executable*
-  Type: |String|
-  Default: `'cmakelint'`
-
-  This variable can be set to change the path the cmakelint.
-
-
-g:ale_cmake_cmakelint_options                   *g:ale_cmake_cmakelint_options*
-                                                *b:ale_cmake_cmakelint_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be set to pass additional options to cmakelint.
-
-
-===============================================================================
-cmake-format                                            *ale-cmake-cmakeformat*
-
-g:ale_cmake_cmakeformat_executable         *g:ale_cmake_cmakeformat_executable*
-                                           *b:ale_cmake_cmakeformat_executable*
-  Type: |String|
-  Default: `'cmakeformat'`
-
-  This variable can be set to change the path the cmake-format.
-
-
-g:ale_cmake_cmakeformat_options               *g:ale_cmake_cmakeformat_options*
-                                              *b:ale_cmake_cmakeformat_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be set to pass additional options to cmake-format.
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-cpp.txt b/sources_non_forked/ale/doc/ale-cpp.txt
deleted file mode 100644
index ead3be2..0000000
--- a/sources_non_forked/ale/doc/ale-cpp.txt
+++ /dev/null
@@ -1,331 +0,0 @@
-===============================================================================
-ALE C++ Integration                                           *ale-cpp-options*
-
-
-===============================================================================
-Global Options
-
-The following C options also apply to some C++ linters too.
-
-* |g:ale_c_build_dir_names|
-* |g:ale_c_build_dir|
-* |g:ale_c_parse_makefile|
-* |g:ale_c_parse_compile_commands|
-
-
-===============================================================================
-clang                                                           *ale-cpp-clang*
-
-g:ale_cpp_clang_executable                         *g:ale_cpp_clang_executable*
-                                                   *b:ale_cpp_clang_executable*
-  Type: |String|
-  Default: `'clang++'`
-
-  This variable can be changed to use a different executable for clang.
-
-
-g:ale_cpp_clang_options                               *g:ale_cpp_clang_options*
-                                                      *b:ale_cpp_clang_options*
-  Type: |String|
-  Default: `'-std=c++14 -Wall'`
-
-  This variable can be changed to modify flags given to clang.
-
-
-===============================================================================
-clangd                                                         *ale-cpp-clangd*
-
-g:ale_cpp_clangd_executable                       *g:ale_cpp_clangd_executable*
-                                                  *b:ale_cpp_clangd_executable*
-  Type: |String|
-  Default: `'clangd'`
-
-  This variable can be changed to use a different executable for clangd.
-
-
-g:ale_cpp_clangd_options                             *g:ale_cpp_clangd_options*
-                                                     *b:ale_cpp_clangd_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be changed to modify flags given to clangd.
-
-
-===============================================================================
-clangcheck                                                 *ale-cpp-clangcheck*
-
-`clang-check` will be run only when files are saved to disk, so that
-`compile_commands.json` files can be used. It is recommended to use this
-linter in combination with `compile_commands.json` files.
-Therefore, `clang-check` linter reads the options |g:ale_c_build_dir| and
-|g:ale_c_build_dir_names|. Also, setting |g:ale_c_build_dir| actually
-overrides |g:ale_c_build_dir_names|.
-
-
-g:ale_cpp_clangcheck_executable               *g:ale_cpp_clangcheck_executable*
-                                              *b:ale_cpp_clangcheck_executable*
-  Type: |String|
-  Default: `'clang-check'`
-
-  This variable can be changed to use a different executable for clangcheck.
-
-
-g:ale_cpp_clangcheck_options                     *g:ale_cpp_clangcheck_options*
-                                                 *b:ale_cpp_clangcheck_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be changed to modify flags given to clang-check.
-
-  This variable should not be set to point to build subdirectory with
-  `-p path/to/build` option, as it is handled by the |g:ale_c_build_dir|
-  option.
-
-
-===============================================================================
-clang-format                                              *ale-cpp-clangformat*
-
-See |ale-c-clangformat| for information about the available options.
-Note that the C options are also used for C++.
-
-
-===============================================================================
-clangtidy                                                   *ale-cpp-clangtidy*
-
-`clang-tidy` will be run only when files are saved to disk, so that
-`compile_commands.json` files can be used. It is recommended to use this
-linter in combination with `compile_commands.json` files.
-Therefore, `clang-tidy` linter reads the options |g:ale_c_build_dir| and
-|g:ale_c_build_dir_names|. Also, setting |g:ale_c_build_dir| actually
-overrides |g:ale_c_build_dir_names|.
-
-
-g:ale_cpp_clangtidy_checks                         *g:ale_cpp_clangtidy_checks*
-                                                   *b:ale_cpp_clangtidy_checks*
-  Type: |List|
-  Default: `[]`
-
-  The checks to enable for clang-tidy with the `-checks` argument.
-
-  All options will be joined with commas, and escaped appropriately for
-  the shell. The `-checks` flag can be removed entirely by setting this
-  option to an empty List.
-
-
-g:ale_cpp_clangtidy_executable                 *g:ale_cpp_clangtidy_executable*
-                                               *b:ale_cpp_clangtidy_executable*
-  Type: |String|
-  Default: `'clang-tidy'`
-
-  This variable can be changed to use a different executable for clangtidy.
-
-
-g:ale_cpp_clangtidy_options                       *g:ale_cpp_clangtidy_options*
-                                                  *b:ale_cpp_clangtidy_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be changed to modify compiler flags given to clang-tidy.
-
-  - Setting this variable to a non-empty string,
-  - and working in a buffer where no compilation database is found using
-    |g:ale_c_build_dir_names| or |g:ale_c_build_dir|,
-  will cause the `--` argument to be passed to `clang-tidy`, which will mean
-  that detection of `compile_commands.json` files for compile command
-  databases will be disabled.
-  Only set this option if you want to control compiler flags
-  entirely manually, and no `compile_commands.json` file is in one
-  of the |g:ale_c_build_dir_names| directories of the project tree.
-
-
-g:ale_cpp_clangtidy_extra_options           *g:ale_cpp_clangtidy_extra_options*
-                                            *b:ale_cpp_clangtidy_extra_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be changed to modify flags given to clang-tidy.
-
-
-g:ale_cpp_clangtidy_fix_errors                 *g:ale_cpp_clangtidy_fix_errors*
-                                               *b:ale_cpp_clangtidy_fix_errors*
-  Type: |Number|
-  Default: `1`
-
-  This variable can be changed to disable the `-fix-errors` option for the
-  |clangtidy| fixer.
-
-
-===============================================================================
-clazy                                                           *ale-cpp-clazy*
-
-g:ale_cpp_clazy_executable                         *g:ale_cpp_clazy_executable*
-                                                   *b:ale_cpp_clazy_executable*
-  Type: |String|
-  Default: `'clazy-standalone'`
-
-  This variable can be changed to use a different executable for clazy.
-
-
-g:ale_cpp_clazy_checks                                 *g:ale_cpp_clazy_checks*
-                                                       *b:ale_cpp_clazy_checks*
-  Type: |List|
-  Default: `['level1']`
-
-  The checks to enable for clazy with the `-checks` argument.
-
-  All options will be joined with commas, and escaped appropriately for
-  the shell. The `-checks` flag can be removed entirely by setting this
-  option to an empty List.
-
-
-g:ale_cpp_clazy_options                               *g:ale_cpp_clazy_options*
-                                                      *b:ale_cpp_clazy_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be changed to modify flags given to clazy.
-
-
-===============================================================================
-cppcheck                                                     *ale-cpp-cppcheck*
-
-g:ale_cpp_cppcheck_executable                   *g:ale_cpp_cppcheck_executable*
-                                                *b:ale_cpp_cppcheck_executable*
-  Type: |String|
-  Default: `'cppcheck'`
-
-  This variable can be changed to use a different executable for cppcheck.
-
-
-g:ale_cpp_cppcheck_options                         *g:ale_cpp_cppcheck_options*
-                                                   *b:ale_cpp_cppcheck_options*
-  Type: |String|
-  Default: `'--enable=style'`
-
-  This variable can be changed to modify flags given to cppcheck.
-
-
-===============================================================================
-cpplint                                                       *ale-cpp-cpplint*
-
-g:ale_cpp_cpplint_executable                     *g:ale_cpp_cpplint_executable*
-                                                 *b:ale_cpp_cpplint_executable*
-  Type: |String|
-  Default: `'cpplint'`
-
-  This variable can be changed to use a different executable for cpplint.
-
-
-g:ale_cpp_cpplint_options                           *g:ale_cpp_cpplint_options*
-                                                    *b:ale_cpp_cpplint_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be changed to modify flags given to cpplint.
-
-
-===============================================================================
-cquery                                                         *ale-cpp-cquery*
-
-g:ale_cpp_cquery_executable                       *g:ale_cpp_cquery_executable*
-                                                  *b:ale_cpp_cquery_executable*
-  Type: |String|
-  Default: `'cquery'`
-
-  This variable can be changed to use a different executable for cquery.
-
-
-g:ale_cpp_cquery_cache_directory             *g:ale_cpp_cquery_cache_directory*
-                                             *b:ale_cpp_cquery_cache_directory*
-  Type: |String|
-  Default: `'~/.cache/cquery'`
-
-  This variable can be changed to decide which directory cquery uses for its
-  cache.
-
-
-===============================================================================
-flawfinder                                                 *ale-cpp-flawfinder*
-
-g:ale_cpp_flawfinder_executable               *g:ale_cpp_flawfinder_executable*
-                                              *b:ale_cpp_flawfinder_executable*
-  Type: |String|
-  Default: `'flawfinder'`
-
-  This variable can be changed to use a different executable for flawfinder.
-
-
-g:ale_cpp_flawfinder_minlevel                   *g:ale_cpp_flawfinder_minlevel*
-                                                *b:ale_cpp_flawfinder_minlevel*
-  Type: |Number|
-  Default: `1`
-
-  This variable can be changed to ignore risks under the given risk threshold.
-
-
-g:ale_cpp_flawfinder_options                             *g:ale-cpp-flawfinder*
-                                                         *b:ale-cpp-flawfinder*
-  Type: |String|
-  Default: `''`
-
-  This variable can be used to pass extra options into the flawfinder command.
-
-
-===============================================================================
-gcc                                                               *ale-cpp-gcc*
-
-g:ale_cpp_gcc_executable                             *g:ale_cpp_gcc_executable*
-                                                     *b:ale_cpp_gcc_executable*
-  Type: |String|
-  Default: `'gcc'`
-
-  This variable can be changed to use a different executable for gcc.
-
-
-g:ale_cpp_gcc_options                                   *g:ale_cpp_gcc_options*
-                                                        *b:ale_cpp_gcc_options*
-  Type: |String|
-  Default: `'-std=c++14 -Wall'`
-
-  This variable can be changed to modify flags given to gcc.
-
-
-===============================================================================
-uncrustify                                                 *ale-cpp-uncrustify*
-
-See |ale-c-uncrustify| for information about the available options.
-
-
-===============================================================================
-ccls                                                             *ale-cpp-ccls*
-
-g:ale_cpp_ccls_executable                           *g:ale_cpp_ccls_executable*
-                                                    *b:ale_cpp_ccls_executable*
-  Type: |String|
-  Default: `'ccls'`
-
-  This variable can be changed to use a different executable for ccls.
-
-
-g:ale_cpp_ccls_init_options                       *g:ale_cpp_ccls_init_options*
-                                                  *b:ale_cpp_ccls_init_options*
-  Type: |Dictionary|
-  Default: `{}`
-
-  This variable can be changed to customize ccls initialization options.
-  Example: >
-      {
-    \   'cacheDirectory': '/tmp/ccls',
-    \   'cacheFormat': 'binary',
-    \   'diagnostics': {
-    \     'onOpen': 0,
-    \     'opChange': 1000,
-    \   },
-    \ }
-<
-  Visit https://github.com/MaskRay/ccls/wiki/Initialization-options for all
-  available options and explanations.
-
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-cs.txt b/sources_non_forked/ale/doc/ale-cs.txt
deleted file mode 100644
index bb13863..0000000
--- a/sources_non_forked/ale/doc/ale-cs.txt
+++ /dev/null
@@ -1,197 +0,0 @@
-===============================================================================
-ALE C# Integration                                             *ale-cs-options*
-
-
-In addition to the linters that are provided with ALE, C# code can be checked
-with the OmniSharp plugin. See here: https://github.com/OmniSharp/omnisharp-vim
-
-
-===============================================================================
-csc                                                                *ale-cs-csc*
-
-  The |ale-cs-csc| linter checks for semantic errors when files are opened or
-  saved.
-
-  See |ale-lint-file-linters| for more information on linters which do not
-  check for problems while you type.
-
-  The csc linter uses the mono csc compiler, providing full C# 7 and newer
-  support, to generate a temporary module target file (/t:module). The module
-  includes all '*.cs' files contained in the directory tree rooted at the path
-  defined by the |g:ale_cs_csc_source| or |b:ale_cs_csc_source| variable and
-  all sub directories.
-
-  It will in future replace the |ale-cs-mcs| and |ale-cs-mcsc| linters as both
-  utilize the mcsc compiler which, according to the mono project, is no longer
-  actively developed, and only receives maintenance updates. However, because
-  the csc compiler does not support the -syntax option, this linter does not
-  offer any as-you-type syntax checking, similar to the |ale-cs-mcsc| linter.
-
-  The paths to search for additional assembly files can be specified using the
-  |g:ale_cs_csc_assembly_path| or |b:ale_cs_csc_assembly_path| variables.
-
-  NOTE: ALE will not find any errors in files apart from syntax errors if any
-  one of the source files contains a syntax error. Syntax errors must be fixed
-  first before other errors will be shown.
-
-
-g:ale_cs_csc_options                                     *g:ale_cs_csc_options*
-                                                         *b:ale_cs_csc_options*
-  Type: |String|
-  Default: `''`
-
-  This option can be set to pass additional arguments to the `csc` compiler.
-
-  For example, to add the dotnet package which is not added per default: >
-
-      let g:ale_cs_mcs_options = ' /warn:4 /langversion:7.2'
-<
-  NOTE: the `/unsafe` option is always passed to `csc`.
-
-
-g:ale_cs_csc_source                                       *g:ale_cs_csc_source*
-                                                          *b:ale_cs_csc_source*
-  Type: |String|
-  Default: `''`
-
-  This variable defines the root path of the directory tree searched for the
-  '*.cs' files to be linted. If this option is empty, the source file's
-  directory will be used.
-
-  NOTE: Currently it is not possible to specify sub directories and
-  directory sub trees which shall not be searched for *.cs files.
-
-
-g:ale_cs_csc_assembly_path                         *g:ale_cs_csc_assembly_path*
-                                                   *b:ale_cs_csc_assembly_path*
-  Type: |List|
-  Default: `[]`
-
-  This variable defines a list of path strings to be searched for external
-  assembly files. The list is passed to the csc compiler using the `/lib:`
-  flag.
-
-
-g:ale_cs_csc_assemblies                               *g:ale_cs_csc_assemblies*
-                                                      *b:ale_cs_csc_assemblies*
-  Type: |List|
-  Default: `[]`
-
-  This variable defines a list of external assembly (*.dll) files required
-  by the mono mcs compiler to generate a valid module target. The list is
-  passed the csc compiler using the `/r:` flag.
-
-  For example: >
-
-    " Compile C# programs with the Unity engine DLL file on Mac.
-    let g:ale_cs_mcsc_assemblies = [
-    \ '/Applications/Unity/Unity.app/Contents/Frameworks/Managed/UnityEngine.dll',
-    \ 'path-to-unityproject/obj/Debug',
-    \]
-<
-
-===============================================================================
-mcs                                                                *ale-cs-mcs*
-
-  The `mcs` linter looks only for syntax errors while you type. See
-  |ale-cs-mcsc| for the separately configured linter for checking for semantic
-   errors.
-
-
-g:ale_cs_mcs_options                                     *g:ale_cs_mcs_options*
-                                                         *b:ale_cs_mcs_options*
-
-  Type: String
-  Default: `''`
-
-  This variable can be changed to pass additional flags given to mcs.
-
-  NOTE: The -unsafe flag is selected implicitly and thus does not need to be
-  explicitly included in the |g:ale_cs_mcs_options| or |b:ale_cs_mcs_options|
-  parameter.
-
-
-===============================================================================
-mcsc                                                              *ale-cs-mcsc*
-
-  The mcsc linter checks for semantic errors when files are opened or saved
-  See |ale-lint-file-linters| for more information on linters which do not
-  check for problems while you type.
-
-  The mcsc linter uses the mono mcs compiler to generate a temporary module
-  target file (-t:module). The module includes including all '*.cs' files
-  contained in the directory tree rooted at the path defined by the
-  |g:ale_cs_mcsc_source| or |b:ale_cs_mcsc_source| variable.
-  variable and all sub directories.
-
-  The paths to search for additional assembly files can be specified using the
-  |g:ale_cs_mcsc_assembly_path| or |b:ale_cs_mcsc_assembly_path| variables.
-
-  NOTE: ALE will not find any errors in files apart from syntax errors if any
-  one of the source files contains a syntax error. Syntax errors must be fixed
-  first before other errors will be shown.
-
-
-g:ale_cs_mcsc_options                                   *g:ale_cs_mcsc_options*
-                                                        *b:ale_cs_mcsc_options*
-  Type: |String|
-  Default: `''`
-
-  This option can be set to pass additional arguments to the `mcs` compiler.
-
-  For example, to add the dotnet package which is not added per default: >
-
-      let g:ale_cs_mcs_options = '-pkg:dotnet'
-<
-  NOTE: the `-unsafe` option is always passed to `mcs`.
-
-
-g:ale_cs_mcsc_source                                     *g:ale_cs_mcsc_source*
-                                                         *b:ale_cs_mcsc_source*
-  Type: |String|
-  Default: `''`
-
-  This variable defines the root path of the directory tree searched for the
-  '*.cs' files to be linted. If this option is empty, the source file's
-  directory will be used.
-
-  NOTE: Currently it is not possible to specify sub directories and
-  directory sub trees which shall not be searched for *.cs files.
-
-
-g:ale_cs_mcsc_assembly_path                       *g:ale_cs_mcsc_assembly_path*
-                                                  *b:ale_cs_mcsc_assembly_path*
-  Type: |List|
-  Default: `[]`
-
-  This variable defines a list of path strings to be searched for external
-  assembly files. The list is passed to the mcs compiler using the `-lib:`
-  flag.
-
-
-g:ale_cs_mcsc_assemblies                             *g:ale_cs_mcsc_assemblies*
-                                                     *b:ale_cs_mcsc_assemblies*
-  Type: |List|
-  Default: `[]`
-
-  This variable defines a list of external assembly (*.dll) files required
-  by the mono mcs compiler to generate a valid module target. The list is
-  passed the mcs compiler using the `-r:` flag.
-
-  For example: >
-
-    " Compile C# programs with the Unity engine DLL file on Mac.
-    let g:ale_cs_mcsc_assemblies = [
-    \ '/Applications/Unity/Unity.app/Contents/Frameworks/Managed/UnityEngine.dll',
-    \ 'path-to-unityproject/obj/Debug',
-    \]
-<
-
-===============================================================================
-uncrustify                                                  *ale-cs-uncrustify*
-
-See |ale-c-uncrustify| for information about the available options.
-
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-css.txt b/sources_non_forked/ale/doc/ale-css.txt
deleted file mode 100644
index ff74b26..0000000
--- a/sources_non_forked/ale/doc/ale-css.txt
+++ /dev/null
@@ -1,47 +0,0 @@
-===============================================================================
-ALE CSS Integration                                           *ale-css-options*
-
-
-===============================================================================
-fecs                                                             *ale-css-fecs*
-
-`fecs` options for CSS is the same as the options for JavaScript, and both of
-them reads `./.fecsrc` as the default configuration file. See:
-|ale-javascript-fecs|.
-
-
-===============================================================================
-prettier                                                     *ale-css-prettier*
-
-See |ale-javascript-prettier| for information about the available options.
-
-
-===============================================================================
-stylelint                                                   *ale-css-stylelint*
-
-g:ale_css_stylelint_executable                 *g:ale_css_stylelint_executable*
-                                               *b:ale_css_stylelint_executable*
-  Type: |String|
-  Default: `'stylelint'`
-
-  See |ale-integrations-local-executables|
-
-
-g:ale_css_stylelint_options                       *g:ale_css_stylelint_options*
-                                                  *b:ale_css_stylelint_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be set to pass additional options to stylelint.
-
-
-g:ale_css_stylelint_use_global                 *g:ale_css_stylelint_use_global*
-                                               *b:ale_css_stylelint_use_global*
-  Type: |String|
-  Default: `get(g:, 'ale_use_global_executables', 0)`
-
-  See |ale-integrations-local-executables|
-
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-cuda.txt b/sources_non_forked/ale/doc/ale-cuda.txt
deleted file mode 100644
index 0e53f75..0000000
--- a/sources_non_forked/ale/doc/ale-cuda.txt
+++ /dev/null
@@ -1,32 +0,0 @@
-===============================================================================
-ALE CUDA Integration                                         *ale-cuda-options*
-
-
-===============================================================================
-nvcc                                                            *ale-cuda-nvcc*
-
-g:ale_cuda_nvcc_executable                         *g:ale_cuda_nvcc_executable*
-                                                   *b:ale_cuda_nvcc_executable*
-  Type: |String|
-  Default: `'nvcc'`
-
-  This variable can be changed to use a different executable for nvcc.
-  Currently only nvcc 8.0 is supported.
-
-
-g:ale_cuda_nvcc_options                               *g:ale_cuda_nvcc_options*
-                                                      *b:ale_cuda_nvcc_options*
-  Type: |String|
-  Default: `'-std=c++11'`
-
-  This variable can be changed to modify flags given to nvcc.
-
-===============================================================================
-clang-format                                              *ale-cuda-clangformat*
-
-See |ale-c-clangformat| for information about the available options.
-Note that the C options are also used for cuda.
-
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-d.txt b/sources_non_forked/ale/doc/ale-d.txt
deleted file mode 100644
index 72349a2..0000000
--- a/sources_non_forked/ale/doc/ale-d.txt
+++ /dev/null
@@ -1,32 +0,0 @@
-===============================================================================
-ALE D Integration                                               *ale-d-options*
-
-===============================================================================
-dfmt                                                               *ale-d-dfmt*
-
-g:ale_d_dfmt_options                                     *g:ale_d_dfmt_options*
-                                                         *b:ale_d_dfmt_options*
-  Type: |String|
-  Default: `''`
-
-This variable can be set to pass additional options to the dfmt fixer.
-
-===============================================================================
-dls                                                                 *ale-d-dls*
-
-g:ale_d_dls_executable                                 *g:ale_d_dls_executable*
-                                                       *b:ale_d_dls_executable*
-  Type: |String|
-  Default: `dls`
-
-See |ale-integrations-local-executables|
-
-
-===============================================================================
-uncrustify                                                   *ale-d-uncrustify*
-
-See |ale-c-uncrustify| for information about the available options.
-
-
-===============================================================================
-vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-dart.txt b/sources_non_forked/ale/doc/ale-dart.txt
deleted file mode 100644
index a6d88dd..0000000
--- a/sources_non_forked/ale/doc/ale-dart.txt
+++ /dev/null
@@ -1,71 +0,0 @@
-===============================================================================
-ALE Dart Integration                                         *ale-dart-options*
-
-
-===============================================================================
-dartanalyzer                                            *ale-dart-dartanalyzer*
-
-Installation
--------------------------------------------------------------------------------
-
-Install Dart via whatever means. `dartanalyzer` will be included in the SDK.
-
-You can add the SDK to `$PATH`, as described here:
-https://www.dartlang.org/tools/sdk
-
-If you have installed Dart on Linux, you can also try the following: >
-  " Set the executable path for dartanalyzer to the absolute path to it.
-  let g:ale_dart_dartanalyzer_executable = '/usr/lib/dart/bin/dartanalyzer'
-<
-... or similarly for wherever your Dart SDK lives. This should work without
-having to modify `$PATH`.
-
-ALE can only check for problems with `dartanalyzer` with the file on disk.
-See |ale-lint-file-linters|
-
-Options
--------------------------------------------------------------------------------
-
-g:ale_dart_dartanalyzer_executable         *g:ale_dart_dartanalyzer_executable*
-                                           *b:ale_dart_dartanalyzer_executable*
-  Type: |String|
-  Default: `'dartanalyzer'`
-
-  This variable can be set to change the path to dartanalyzer.
-
-
-===============================================================================
-dartfmt                                                      *ale-dart-dartfmt*
-
-Installation
--------------------------------------------------------------------------------
-
-Installing Dart should probably ensure that `dartfmt` is in your `$PATH`.
-
-In case it is not, try to set the executable option to its absolute path. : >
-  " Set the executable path for dartfmt to the absolute path to it.
-  let g:ale_dart_dartfmt_executable = '/usr/lib/dart/bin/dartfmt'
- >
-
-Options
--------------------------------------------------------------------------------
-
-g:ale_dart_dartfmt_executable                   *g:ale_dart_dartfmt_executable*
-                                                *b:ale_dart_dartfmt_executable*
-  Type: |String|
-  Default: `''`
-
-  This variable can be set to specify an absolute path to the
-  dartfmt executable (or to specify an alternate executable).
-
-
-g:ale_dart_dartfmt_options                         *g:ale_dart_dartfmt_options*
-                                                   *b:ale_dart_dartfmt_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be set to pass additional options to the dartfmt fixer.
-
-===============================================================================
-
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-development.txt b/sources_non_forked/ale/doc/ale-development.txt
deleted file mode 100644
index faa570c..0000000
--- a/sources_non_forked/ale/doc/ale-development.txt
+++ /dev/null
@@ -1,357 +0,0 @@
-*ale-development.txt*  For Vim version 8.0.
-*ale-dev*
-*ale-development*
-
-ALE Development Documentation
-
-===============================================================================
-CONTENTS                                             *ale-development-contents*
-
-  1. Introduction.........................|ale-development-introduction|
-  2. Design Goals.........................|ale-design-goals|
-  3. Coding Standards.....................|ale-coding-standards|
-  4. Testing ALE..........................|ale-development-tests|
-    4.1. Writing Linter Tests.............|ale-development-linter-tests|
-    4.2. Writing Fixer Tests..............|ale-development-fixer-tests|
-
-===============================================================================
-1. Introduction                                  *ale-development-introduction*
-
-This document contains helpful information for ALE developers, including
-design goals, information on how to run the tests, coding standards, and so
-on. You should read this document if you want to get involved with ALE
-development.
-
-===============================================================================
-2. Design Goals                                              *ale-design-goals*
-
-This section lists design goals for ALE, in no particular order. They are as
-follows.
-
-ALE code should be almost 100% VimL. This makes the plugin as portable as
-possible.
-
-ALE should run without needing any other plugins to be installed, to make
-installation simple. ALE can integrate with other plugins for more advanced
-functionality, non-essential functionality, or improving on basic first party
-functionality.
-
-ALE should check files with as many tools as possible by default, except where
-they cause security issues or make excessive use of resources on modern
-machines.
-
-ALE should be free of breaking changes to the public API, which is comprised of
-documented functions and options, until a major version is planned. Breaking
-changes should be preceded by a deprecation phase complete with warnings.
-Changes required for security may be an exception.
-
-ALE supports Vim 8 and above, and NeoVim 0.2.0 or newer. These are the
-earliest versions of Vim and NeoVim which support |job|, |timer|, |closure|,
-and |lambda| features. All ALE code should be written so it is compatible with
-these versions of Vim, or with version checks so particular features can
-degrade or fail gracefully.
-
-Just about everything should be documented and covered with tests.
-
-By and large, people shouldn't pay for the functionality they don't use. Care
-should be taken when adding new features, so supporting new features doesn't
-degrade the general performance of anything ALE does.
-
-LSP support will become more important as time goes on. ALE should provide
-better support for LSP features as time goes on.
-
-When merging pull requests, you should respond with `Cheers! :beers:`, purely
-for comedy value.
-
-===============================================================================
-3. Coding Standards                                      *ale-coding-standards*
-
-The following general coding standards should be adhered to for Vim code.
-
-* Check your Vim code with `Vint` and do everything it says. ALE will check
-  your Vim code with Vint automatically. See: https://github.com/Kuniwak/vint
-  Read ALE's `Dockerfile` to see which version of `Vint` it uses.
-* Try to write descriptive and concise names for variables and functions.
-  Names shouldn't be too short or too long. Think about others reading your
-  code later on.
-* Use `snake_case` names for variables and arguments, and `PascalCase` names
-  for functions. Prefix every variable name with its scope. (`l:`, `g:`, etc.)
-* Try to keep lines no longer than 80 characters, but this isn't an absolute
-  requirement.
-* Use 4 spaces for every level of indentation in Vim code.
-* Add a blank line before every `function`, `if`, `for`, `while`, or `return`,
-  which doesn't start a new level of indentation. This makes the logic in
-  your code easier to follow.
-* End every file with a trailing newline character, but not with extra blank
-  lines. Remove trailing whitespace from the ends of lines.
-* Write the full names of commands instead of abbreviations. For example, write
-  `function` instead of `func`, and `endif` instead of `end`.
-* Write functions with `!`, so files can be reloaded. Use the |abort| keyword
-  for all functions, so functions exit on the first error.
-* Make sure to credit yourself in files you have authored with `Author:`
-  and `Description:` comments.
-
-In addition to the above general guidelines for the style of your code, you
-should also follow some additional rules designed to prevent mistakes. Some of
-these are reported with ALE's `custom-linting-rules` script. See
-|ale-development-tests|.
-
-* Don't leave stray `:echo` lines in code. Use `execute 'echo' ...` if you must
-  echo something.
-* For strings use |is#| instead of |==#|, `is?` instead of `==?`, `isnot#`
-  instead of `!=#`, and `isnot?` instead of `!=?`. This is because `'x' ==# 0`
-  returns 1, while `'x' is# 0` returns 0, so you will experience fewer issues
-  when numbers are compared with strings. `is` and `isnot` also do not throw
-  errors when other objects like List or Dictionaries are compared with
-  strings.
-* Don't use the `getcwd()` function in the ALE codebase. Most of ALE's code
-  runs from asynchronous callback functions, and these functions can execute
-  from essentially random buffers. Therefore, the `getcwd()` output is
-  useless. Use `expand('#' . a:buffer . ':p:h')` instead. Don't use
-  `expand('%...')` for the same reason.
-* Don't use the `simplify()` function. It doesn't simplify paths enough. Use
-  `ale#path#Simplify()` instead.
-* Don't use the `shellescape()` function. It doesn't escape arguments properly
-  on Windows. Use `ale#Escape()` instead, which will avoid escaping where it
-  isn't needed, and generally escape arguments better on Windows.
-* Don't use the `tempname()` function. It doesn't work when `$TMPDIR` isn't
-  set. Use `ale#util#Tempname()` instead, which temporarily sets `$TMPDIR`
-  appropriately where needed.
-* Use `snake_case` names for linter names, so they can be used as part of
-  variable names. You can define `aliases` for linters, for other names people
-  might try to configure linters with.
-* Use |v:t_TYPE| variables instead of `type()`, which are more readable.
-
-Apply the following guidelines when writing Vader test files.
-
-* Use 2 spaces for Vader test files, instead of the 4 spaces for Vim files.
-* If you write `Before` and `After` blocks, you should typically write them at
-  the top of the file, so they run for all tests. There may be some tests
-  where it make sense to modify the `Before` and `After` code part of the way
-  through the file.
-* If you modify any settings or global variables, reset them in `After`
-  blocks. The Vader `Save` and `Restore` commands can be useful for this
-  purpose.
-* If you load or define linters in tests, write `call ale#linter#Reset()` in
-  an `After` block.
-* Just write `Execute` blocks for Vader tests, and don't bother writing `Then`
-  blocks. `Then` blocks execute after `After` blocks in older versions, and
-  that can be confusing.
-
-Apply the following rules when writing Bash scripts.
-
-* Run `shellcheck`, and do everything it says.
-  See: https://github.com/koalaman/shellcheck
-* Try to write scripts so they will run on Linux, BSD, or Mac OSX.
-
-===============================================================================
-4. Testing ALE              *ale-development-tests* *ale-dev-tests* *ale-tests*
-
-ALE is tested with a suite of tests executed in Travis CI and AppVeyor. ALE
-runs tests with the following versions of Vim in the following environments.
-
-1. Vim 8.0.0027 on Linux via Travis CI.
-2. Vim 8.1.0519 on Linux via Travis CI.
-3. NeoVim 0.2.0 on Linux via Travis CI.
-4. NeoVim 0.3.5 on Linux via Travis CI.
-5. Vim 8 (stable builds) on Windows via AppVeyor.
-
-If you are developing ALE code on Linux, Mac OSX, or BSD, you can run ALEs
-tests by installing Docker and running the `run-tests` script. Follow the
-instructions on the Docker site for installing Docker.
-See: https://docs.docker.com/install/
-
-NOTE: Don't forget to add your user to the `docker` group on Linux, or Docker
-just won't work. See: https://docs.docker.com/install/linux/linux-postinstall/
-
-If you run simply `./run-tests` from the ALE repository root directory, the
-latest Docker image for tests will be downloaded if needed, and the script
-will run all of the tests in Vader, Vint checks, and several Bash scripts for
-finding extra issues. Run `./run-tests --help` to see all of the options the
-script supports. Note that the script supports selecting particular test files.
-
-Generally write tests for any changes you make. The following types of tests
-are recommended for the following types of code.
-
-* New/edited error handler callbacks -> Write tests in `test/handler`
-* New/edited command callbacks       -> Write tests in `test/command_callback`
-* New/edited fixer functions         -> Write tests in `test/fixers`
-
-Look at existing tests in the codebase for examples of how to write tests.
-Refer to the Vader documentation for general information on how to write Vader
-tests: https://github.com/junegunn/vader.vim
-
-See |ale-development-linter-tests| for more information on how to write linter
-tests.
-
-When you add new linters or fixers, make sure to add them into the tables in
-supported-tools.md and |ale-supported-languages-and-tools.txt|. If you forget to
-keep them both in sync, you should see an error like the following in Travis CI.
->
-  ========================================
-  diff supported-tools.md and doc/ale-supported-languages-and-tools.txt tables
-  ========================================
-  Differences follow:
-
-  --- /tmp/readme.qLjNhJdB        2018-07-01 16:29:55.590331972 +0100
-  +++ /tmp/doc.dAi8zfVE   2018-07-01 16:29:55.582331877 +0100
-  @@ -1 +1 @@
-  - ASM: gcc, foobar
-  + ASM: gcc
-<
-Make sure to list documentation entries for linters and fixers in individual
-help files in the table of contents, and to align help tags to the right
-margin. For example, if you add a heading for an `aardvark` tool to
-`ale-python.txt` with a badly aligned doc tag, you will see errors like so. >
-
-  ========================================
-  Look for badly aligned doc tags
-  ========================================
-  Badly aligned tags follow:
-
-  doc/ale-python.txt:aardvark ...
-  ========================================
-  Look for table of contents issues
-  ========================================
-
-  Check for bad ToC sorting:
-
-  Check for mismatched ToC and headings:
-
-  --- /tmp/table-of-contents.mwCFOgSI     2018-07-01 16:33:25.068811878 +0100
-  +++ /tmp/headings.L4WU0hsO      2018-07-01 16:33:25.076811973 +0100
-  @@ -168,6 +168,7 @@
-   pyrex (cython), ale-pyrex-options
-     cython, ale-pyrex-cython
-   python, ale-python-options
-  +  aardvark, ale-python-aardvark
-     autopep8, ale-python-autopep8
-     black, ale-python-black
-     flake8, ale-python-flake8
-<
-Make sure to make the table of contents match the headings, and to keep the
-doc tags on the right margin.
-
-===============================================================================
-4.1 Writing Linter Tests                         *ale-development-linter-tests*
-
-Tests for ALE linters take two forms.
-
-1. Tests for handling the output of commands.
-2. Tests for checking which commands are run, or connections are made.
-
-Tests of the first form should go in the `test/handler` directory, and should
-be written like so. >
-
-  Before:
-    " Load the file which defines the linter.
-    runtime ale_linters/filetype/linter_name_here.vim
-
-  After:
-    " Unload all linters again.
-    call ale#linter#Reset()
-
-  Execute(The output should be correct):
-
-  " Test that the right loclist items are parsed from the handler.
-  AssertEqual
-  \ [
-  \   {
-  \     'lnum': 1,
-  \     'type': 'E',
-  \     'text': 'Something went wrong',
-  \   },
-  \ ],
-  \ ale_linters#filetype#linter_name#Handle(bufnr(''), [
-  \ '1:Something went wrong',
-  \ ]
-<
-Tests for what ALE runs should go in the `test/command_callback` directory,
-and should be written like so. >
-
-  Before:
-    " Load the linter and set up a series of commands, reset linter variables,
-    " clear caches, etc.
-    "
-    " Vader's 'Save' command will be called here for linter variables.
-    call ale#assert#SetUpLinterTest('filetype', 'linter_name')
-
-  After:
-    " Reset linters, variables, etc.
-    "
-    " Vader's 'Restore' command will be called here.
-    call ale#assert#TearDownLinterTest()
-
-  Execute(The default command should be correct):
-    " AssertLinter checks the executable and command.
-    " Pass expected_executable, expected_command
-    AssertLinter 'some-command', ale#Escape('some-command') . ' --foo'
-
-  Execute(Check chained commands):
-    " GivenCommandOutput can be called with 1 or more list for passing output
-    " to chained commands. The output for each callback defaults to an empty
-    " list.
-    GivenCommandOutput ['v2.1.2']
-    " Given a List of commands, check all of them.
-    " Given a String, only the last command in the chain will be checked.
-    AssertLinter 'some-command', [
-    \ ale#Escape('some-command') . ' --version',
-    \ ale#Escape('some-command') . ' --foo',
-    \]
-<
-The full list of commands that will be temporarily defined for linter tests
-given the above setup are as follows.
-
-`GivenCommandOutput [...]`         - Define output for ale#command#Run.
-`AssertLinter executable, command` - Check the executable and command.
-`AssertLinterNotExecuted`          - Check that linters will not be executed.
-`AssertLSPLanguage language`       - Check the language given to an LSP server.
-`AssertLSPOptions options_dict`    - Check the options given to an LSP server.
-`AssertLSPConfig config_dict`      - Check the config given to an LSP server.
-`AssertLSPProject project_root`    - Check the root given to an LSP server.
-`AssertLSPAddress address`         - Check the address to an LSP server.
-
-
-===============================================================================
-4.2 Writing Fixer Tests                           *ale-development-fixer-tests*
-
-Tests for ALE fixers should go in the `test/fixers` directory, and should
-be written like so. >
-
-  Before:
-    " Load the fixer and set up a series of commands, reset fixer variables,
-    " clear caches, etc.
-    "
-    " Vader's 'Save' command will be called here for fixer variables.
-    call ale#assert#SetUpFixerTest('filetype', 'fixer_name')
-
-  After:
-    " Reset fixers, variables, etc.
-    "
-    " Vader's 'Restore' command will be called here.
-    call ale#assert#TearDownFixerTest()
-
-  Execute(The default command should be correct):
-    " AssertFixer checks the result of the loaded fixer function.
-    AssertFixer {'command': ale#Escape('some-command') . ' --foo'}
-
-  Execute(Check chained commands):
-    " Same as above for linter tests.
-    GivenCommandOutput ['v2.1.2']
-    " Given a List of commands, check all of them.
-    " Given anything else, only the last result will be checked.
-    AssertFixer [
-    \ ale#Escape('some-command') . ' --version',
-    \ {'command': ale#Escape('some-command') . ' --foo'}
-    \]
-<
-The full list of commands that will be temporarily defined for fixer tests
-given the above setup are as follows.
-
-`GivenCommandOutput [...]`         - Define output for ale#command#Run.
-`AssertFixer results`              - Check the fixer results
-`AssertFixerNotExecuted`           - Check that fixers will not be executed.
-
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-dockerfile.txt b/sources_non_forked/ale/doc/ale-dockerfile.txt
deleted file mode 100644
index 284c6a1..0000000
--- a/sources_non_forked/ale/doc/ale-dockerfile.txt
+++ /dev/null
@@ -1,60 +0,0 @@
-===============================================================================
-ALE Dockerfile Integration                             *ale-dockerfile-options*
-
-
-===============================================================================
-dockerfile_lint                                *ale-dockerfile-dockerfile_lint*
-
-g:ale_dockerfile_dockerfile_lint_executable
-                                  *g:ale_dockerfile_dockerfile_lint_executable*
-                                  *b:ale_dockerfile_dockerfile_lint_executable*
-  Type: |String|
-  Default: `'dockerfile_lint'`
-
-  This variable can be changed to specify the executable used to run
-  dockerfile_lint.
-
-
-g:ale_dockerfile_dockerfile_lint_options
-                                     *g:ale_dockerfile_dockerfile_lint_options*
-                                     *b:ale_dockerfile_dockerfile_lint_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be changed to add additional command-line arguments to
-  the dockerfile lint invocation - like custom rule file definitions.
-
-
-===============================================================================
-hadolint                                              *ale-dockerfile-hadolint*
-
-  hadolint can be found at: https://github.com/hadolint/hadolint
-
-
-g:ale_dockerfile_hadolint_use_docker     *g:ale_dockerfile_hadolint_use_docker*
-                                         *b:ale_dockerfile_hadolint_use_docker*
-  Type: |String|
-  Default: `'never'`
-
-  This variable controls if docker and the hadolint image are used to run this
-  linter: if 'never', docker will never be used; 'always' means docker will
-  always be used; 'yes' and docker will be used if the hadolint executable
-  cannot be found.
-
-  For now, the default is 'never'.  This may change as ale's support for using
-  docker to lint evolves.
-
-
-g:ale_dockerfile_hadolint_image               *g:ale_dockerfile_hadolint_image*
-                                              *b:ale_dockerfile_hadolint_image*
-  Type: |String|
-  Default: `'hadolint/hadolint'`
-
-  This variable controls the docker image used to run hadolint.  The default
-  is hadolint's author's build, and can be found at:
-
-    https://hub.docker.com/r/hadolint/hadolint/
-
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-elixir.txt b/sources_non_forked/ale/doc/ale-elixir.txt
deleted file mode 100644
index 5864f72..0000000
--- a/sources_non_forked/ale/doc/ale-elixir.txt
+++ /dev/null
@@ -1,89 +0,0 @@
-===============================================================================
-ALE Elixir Integration                                     *ale-elixir-options*
-
-
-===============================================================================
-mix                                                            *ale-elixir-mix*
-
-
-The `mix` linter is disabled by default, as it can bee too expensive to run.
-See `:help g:ale_linters`
-
-
-g:ale_elixir_mix_options                             *g:ale_elixir_mix_options*
-                                                     *b:ale_elixir_mix_options*
-  Type: |String|
-  Default: `'mix'`
-
-
-  This variable can be changed to specify the mix executable.
-
-===============================================================================
-mix_format                                              *ale-elixir-mix-format*
-
-g:ale_elixir_mix_format_options               *g:ale_elixir_mix_format_options*
-                                              *b:ale_elixir_mix_format_options*
-  Type: |String|
-  Default: `''`
-
-
-  This variable can be changed to specify the mix options passed to the
-  mix_format fixer
-
-===============================================================================
-dialyxir                                                  *ale-elixir-dialyxir*
-
-Dialyzer, a DIscrepancy AnaLYZer for ERlang programs.
-http://erlang.org/doc/man/dialyzer.html
-
-It can be used with elixir through dialyxir
-https://github.com/jeremyjh/dialyxir
-
-Options for dialyzer are not configurable by ale, but they are instead
-configured on your project's `mix.exs`.
-
-See https://github.com/jeremyjh/dialyxir#with-explaining-stuff for more
-information.
-
-===============================================================================
-elixir-ls                                                *ale-elixir-elixir-ls*
-
-Elixir Language Server (https://github.com/JakeBecker/elixir-ls)
-
-g:ale_elixir_elixir_ls_release                 *g:ale_elixir_elixir_ls_release*
-                                               *b:ale_elixir_elixir_ls_release*
-  Type: |String|
-  Default: `'elixir-ls'`
-
-  Location of the elixir-ls release directory. This directory must contain
-  the language server scripts (language_server.sh and language_server.bat).
-
-g:ale_elixir_elixir_ls_config                   *g:ale_elixir_elixir_ls_config*
-                                                *b:ale_elixir_elixir_ls_config*
-  Type: |Dictionary|
-  Default: `{}`
-
-  Dictionary containing configuration settings that will be passed to the
-  language server. For example, to disable Dialyzer: >
-      {
-    \   'elixirLS': {
-    \     'dialyzerEnabled': v:false,
-    \   },
-    \ }
-<
-  Consult the ElixirLS documentation for more information about settings.
-===============================================================================
-credo                                                        *ale-elixir-credo*
-
-Credo (https://github.com/rrrene/credo)
-
-g:ale_elixir_credo_strict                           *g:ale_elixir_credo_strict*
-
-  Type: Integer
-  Default: 0
-
-  Tells credo to run in strict mode or suggest mode.  Set variable to 1 to
-  enable --strict mode.
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-elm.txt b/sources_non_forked/ale/doc/ale-elm.txt
deleted file mode 100644
index b151024..0000000
--- a/sources_non_forked/ale/doc/ale-elm.txt
+++ /dev/null
@@ -1,100 +0,0 @@
-===============================================================================
-ALE Elm Integration                                           *ale-elm-options*
-
-
-===============================================================================
-elm-format                                                 *ale-elm-elm-format*
-
-g:ale_elm_format_executable                       *g:ale_elm_format_executable*
-                                                  *b:ale_elm_format_executable*
-  Type: |String|
-  Default: `'elm-format'`
-
-  See |ale-integrations-local-executables|
-
-
-g:ale_elm_format_use_global                       *g:ale_elm_format_use_global*
-                                                  *b:ale_elm_format_use_global*
-  Type: |Number|
-  Default: `get(g:, 'ale_use_global_executables', 0)`
-
-  See |ale-integrations-local-executables|
-
-
-g:ale_elm_format_options                             *g:ale_elm_format_options*
-                                                     *b:ale_elm_format_options*
-  Type: |String|
-  Default: `'--yes'`
-
-  This variable can be set to pass additional options to elm-format.
-
-===============================================================================
-elm-ls                                                         *ale-elm-elm-ls*
-
-g:ale_elm_ls_executable                               *g:ale_elm_ls_executable*
-                                                      *b:ale_elm_ls_executable*
-  Type: |String|
-  Default: `'elm-language-server'`
-
-  See |ale-integrations-local-executables|
-
-
-g:ale_elm_ls_use_global                               *g:ale_elm_ls_use_global*
-                                                      *b:ale_elm_ls_use_global*
-  Type: |Number|
-  Default: `get(g:, 'ale_use_global_executables', 1)`
-
-  See |ale-integrations-local-executables|
-
-
-g:ale_elm_ls_elm_path                                   *g:ale_elm_ls_elm_path*
-                                                        *b:ale_elm_ls_elm_path*
-  Type: |String|
-  Default: `''`
-
-  See |ale-integrations-local-executables|
-
-
-g:ale_elm_ls_elm_format_path                     *g:ale_elm_ls_elm_format_path*
-                                                 *b:ale_elm_ls_elm_format_path*
-  Type: |String|
-  Default: `''`
-
-  See |ale-integrations-local-executables|
-
-
-g:ale_elm_ls_elm_test_path                         *g:ale_elm_ls_elm_test_path*
-                                                   *b:ale_elm_ls_elm_test_path*
-  Type: |String|
-  Default: `''`
-
-  See |ale-integrations-local-executables|
-
-
-g:ale_elm_ls_elm_analyse_trigger             *g:ale_elm_ls_elm_analyse_trigger*
-                                             *b:ale_elm_ls_elm_analyse_trigger*
-  Type: |String|
-  Default: `'change'`
-
-  One of 'change', 'save' or 'never'
-
-===============================================================================
-elm-make                                                     *ale-elm-elm-make*
-
-g:ale_elm_make_executable                           *g:ale_elm_make_executable*
-                                                    *b:ale_elm_make_executable*
-  Type: |String|
-  Default: `'elm'`
-
-  See |ale-integrations-local-executables|
-
-
-g:ale_elm_make_use_global                           *g:ale_elm_make_use_global*
-                                                    *b:ale_elm_make_use_global*
-  Type: |Number|
-  Default: `get(g:, 'ale_use_global_executables', 0)`
-
-  See |ale-integrations-local-executables|
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-erlang.txt b/sources_non_forked/ale/doc/ale-erlang.txt
deleted file mode 100644
index 59993a9..0000000
--- a/sources_non_forked/ale/doc/ale-erlang.txt
+++ /dev/null
@@ -1,58 +0,0 @@
-===============================================================================
-ALE Erlang Integration                                     *ale-erlang-options*
-
-
-===============================================================================
-dialyzer                                                  *ale-erlang-dialyzer*
-
-g:ale_erlang_dialyzer_executable             *g:ale_erlang_dialyzer_executable*
-                                             *b:ale_erlang_dialyzer_executable*
-  Type: |String|
-  Default: `'dialyzer'`
-
-  This variable can be changed to specify the dialyzer executable.
-
-
-g:ale_erlang_dialyzer_plt_file                 *g:ale_erlang_dialyzer_plt_file*
-                                               *b:ale_erlang_dialyzer_plt_file*
-  Type: |String|
-
-  This variable can be changed to specify the path to the PLT file. By
-  default, it will search for the PLT file inside the `_build` directory. If
-  there isn't one, it will fallback to the path `$REBAR_PLT_DIR/dialyzer/plt`.
-  Otherwise, it will default to `$HOME/.dialyzer_plt`.
-
-
-g:ale_erlang_dialyzer_rebar3_profile     *g:ale_erlang_dialyzer_rebar3_profile*
-                                         *b:ale_erlang_dialyzer_rebar3_profile*
-  Type: |String|
-  Default: `'default'`
-
-  This variable can be changed to specify the profile that is used to
-  run dialyzer with rebar3.
-
--------------------------------------------------------------------------------
-erlc                                                          *ale-erlang-erlc*
-
-g:ale_erlang_erlc_options                           *g:ale_erlang_erlc_options*
-                                                    *b:ale_erlang_erlc_options*
-  Type: |String|
-  Default: `''`
-
-  This variable controls additional parameters passed to `erlc`, such as `-I`
-  or `-pa`.
-
-
--------------------------------------------------------------------------------
-syntaxerl                                                *ale-erlang-syntaxerl*
-
-g:ale_erlang_syntaxerl_executable           *g:ale_erlang_syntaxerl_executable*
-                                            *b:ale_erlang_syntaxerl_executable*
-  Type: |String|
-  Default: `'syntaxerl'`
-
-  This variable can be changed to specify the syntaxerl executable.
-
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-eruby.txt b/sources_non_forked/ale/doc/ale-eruby.txt
deleted file mode 100644
index d75d386..0000000
--- a/sources_non_forked/ale/doc/ale-eruby.txt
+++ /dev/null
@@ -1,37 +0,0 @@
-===============================================================================
-ALE Eruby Integration                                       *ale-eruby-options*
-
-There are four linters for `eruby` files:
-
-- `erb`
-- `erubis`
-- `erubi`
-- `ruumba`
-
-`erb` is in the Ruby standard library and is mostly universal. `erubis` is the
-default parser in Rails between 3.0 and 5.1. `erubi` is the default in Rails
-5.1 and later. `ruumba` can extract Ruby from eruby files and run rubocop on
-the result. To selectively enable a subset, see |g:ale_linters|.
-
-===============================================================================
-ruumba                                                       *ale-eruby-ruumba*
-
-g:ale_eruby_ruumba_executable                   *g:ale_eruby_ruumba_executable*
-                                                *b:ale_eruby_ruumba_executable*
-  Type: String
-  Default: `'ruumba`
-
-  Override the invoked ruumba binary. This is useful for running ruumba
-  from binstubs or a bundle.
-
-
-g:ale_eruby_ruumba_options                          *g:ale_ruby_ruumba_options*
-                                                    *b:ale_ruby_ruumba_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be change to modify flags given to ruumba.
-
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-fish.txt b/sources_non_forked/ale/doc/ale-fish.txt
deleted file mode 100644
index 8450b38..0000000
--- a/sources_non_forked/ale/doc/ale-fish.txt
+++ /dev/null
@@ -1,14 +0,0 @@
-===============================================================================
-ALE Fish Integration                                         *ale-fish-options*
-
-Lints fish files using `fish -n`.
-
-Note that `fish -n` is not foolproof: it sometimes gives false positives or
-errors that are difficult to parse without more context. This integration skips
-displaying errors if an error message is not found.
-
-If ALE is not showing any errors but your file does not run as expected, run
-`fish -n <file.fish>` from the command line.
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-fortran.txt b/sources_non_forked/ale/doc/ale-fortran.txt
deleted file mode 100644
index c9b7e8e..0000000
--- a/sources_non_forked/ale/doc/ale-fortran.txt
+++ /dev/null
@@ -1,55 +0,0 @@
-===============================================================================
-ALE Fortran Integration                                   *ale-fortran-options*
-
-
-===============================================================================
-gcc                                                           *ale-fortran-gcc*
-
-g:ale_fortran_gcc_executable                     *g:ale_fortran_gcc_executable*
-                                                 *b:ale_fortran_gcc_executable*
-  Type: |String|
-  Default: `'gcc'`
-
-  This variable can be changed to modify the executable used for checking
-  Fortran code with GCC.
-
-
-g:ale_fortran_gcc_options                           *g:ale_fortran_gcc_options*
-                                                    *b:ale_fortran_gcc_options*
-  Type: |String|
-  Default: `'-Wall'`
-
-  This variable can be changed to modify flags given to gcc.
-
-
-g:ale_fortran_gcc_use_free_form               *g:ale_fortran_gcc_use_free_form*
-                                              *b:ale_fortran_gcc_use_free_form*
-  Type: |Number|
-  Default: `1`
-
-  When set to `1`, the `-ffree-form` flag will be used for GCC, to check files
-  with the free form layout. When set to `0`, `-ffixed-form` will be used
-  instead, for checking files with fixed form layouts.
-
-
-===============================================================================
-language_server                                    *ale-fortran-language-server*
-
-g:ale_fortran_language_server_executable  *g:ale_fortran_language_server_executable*
-                                         *b:ale_fortran_language_server_executable*
-  Type: |String|
-  Default: `'fortls'`
-
-  This variable can be changed to modify the executable used for the Fortran
-  Language Server.
-
-g:ale_fortran_language_server_use_global  *g:ale_fortran_language_server_use_global*
-                                         *b:ale_fortran_language_server_use_global*
-  Type: |Number|
-  Default: `get(g:, 'ale_use_global_executables', 0)`
-
-  See |ale-integrations-local-executables|
-
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-fountain.txt b/sources_non_forked/ale/doc/ale-fountain.txt
deleted file mode 100644
index ac0870c..0000000
--- a/sources_non_forked/ale/doc/ale-fountain.txt
+++ /dev/null
@@ -1,6 +0,0 @@
-===============================================================================
-ALE Fountain Integration                                 *ale-fountain-options*
-
-
-===============================================================================
-vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-fuse.txt b/sources_non_forked/ale/doc/ale-fuse.txt
deleted file mode 100644
index 0849c37..0000000
--- a/sources_non_forked/ale/doc/ale-fuse.txt
+++ /dev/null
@@ -1,25 +0,0 @@
-===============================================================================
-ALE FusionScript Integration                                 *ale-fuse-options*
-
-
-===============================================================================
-fusion-lint                                               *ale-fuse-fusionlint*
-
-g:ale_fusion_fusionlint_executable           *g:ale_fuse_fusionlint_executable*
-                                             *b:ale_fuse_fusionlint_executable*
-  Type: |String|
-  Default: `'fusion-lint'`
-
-  This variable can be changed to change the path to fusion-lint.
-
-
-g:ale_fuse_fusionlint_options                   *g:ale_fuse_fusionlint_options*
-                                                *b:ale_fuse_fusionlint_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be set to pass additional options to fusion-lint.
-
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-gitcommit.txt b/sources_non_forked/ale/doc/ale-gitcommit.txt
deleted file mode 100644
index 38f3fd9..0000000
--- a/sources_non_forked/ale/doc/ale-gitcommit.txt
+++ /dev/null
@@ -1,44 +0,0 @@
-===============================================================================
-ALE Git Commit Integration                              *ale-gitcommit-options*
-
-
-===============================================================================
-gitlint                                                 *ale-gitcommit-gitlint*
-
-g:ale_gitcommit_gitlint_executable         *g:ale_gitcommit_gitlint_executable*
-                                           *b:ale_gitcommit_gitlint_executable*
-  Type: |String|
-  Default: `'gitlint'`
-
-  This variable can be changed to modify the executable used for gitlint.
-
-
-g:ale_gitcommit_gitlint_options               *g:ale_gitcommit_gitlint_options*
-                                              *b:ale_gitcommit_gitlint_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be changed to add command-line arguments to the gitlint
-  invocation. For example, you can specify the path to a configuration file. >
-
-    let g:ale_gitcommit_gitlint_options = '-C /home/user/.config/gitlint.ini'
-<
-  You can also disable particular error codes using this option. For example,
-  you can ignore errors for git commits with a missing body. >
-
-    let g:ale_gitcommit_gitlint_options = '--ignore B6'
-<
-
-g:ale_gitcommit_gitlint_use_global         *g:ale_gitcommit_gitlint_use_global*
-                                           *b:ale_gitcommit_gitlint_use_global*
-  Type: |Number|
-  Default: `get(g:, 'ale_use_global_executables', 0)`
-
-  This variable controls whether or not ALE will search for gitlint in a
-  virtualenv directory first. If this variable is set to `1`, then ALE will
-  always use |g:ale_gitcommit_gitlint_executable| for the executable path.
-
-  Both variables can be set with `b:` buffer variables instead.
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-glsl.txt b/sources_non_forked/ale/doc/ale-glsl.txt
deleted file mode 100644
index 257de75..0000000
--- a/sources_non_forked/ale/doc/ale-glsl.txt
+++ /dev/null
@@ -1,56 +0,0 @@
-===============================================================================
-ALE GLSL Integration                                         *ale-glsl-options*
-                                                         *ale-integration-glsl*
-
-===============================================================================
-Integration Information
-
-  Since Vim does not detect the glsl file types out-of-the-box, you need the
-  runtime files for glsl from here: https://github.com/tikhomirov/vim-glsl
-
-  Note that the current glslang-based linter expects glslangValidator in
-  standard paths. If it's not installed system-wide you can set
-  |g:ale_glsl_glslang_executable| to a specific path.
-
-
-===============================================================================
-glslang                                                      *ale-glsl-glslang*
-
-g:ale_glsl_glslang_executable                   *g:ale_glsl_glslang_executable*
-                                                *b:ale_glsl_glslang_executable*
-  Type: |String|
-  Default: `'glslangValidator'`
-
-  This variable can be changed to change the path to glslangValidator.
-
-
-g:ale_glsl_glslang_options                         *g:ale_glsl_glslang_options*
-                                                   *b:ale_glsl_glslang_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be set to pass additional options to glslangValidator.
-
-
-===============================================================================
-glslls                                                        *ale-glsl-glslls*
-
-g:ale_glsl_glslls_executable                     *g:ale_glsl_glslls_executable*
-                                                 *b:ale_glsl_glslls_executable*
-  Type: |String|
-  Default: `'glslls'`
-
-  This variable can be changed to change the path to glslls.
-  See |ale-integrations-local-executables|
-
-g:ale_glsl_glslls_logfile                           *g:ale_glsl_glslls_logfile*
-                                                    *b:ale_glsl_glslls_logfile*
-  Type: |String|
-  Default: `''`
-
-  Setting this variable to a writeable file path will enable logging to that
-  file.
-
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-go.txt b/sources_non_forked/ale/doc/ale-go.txt
deleted file mode 100644
index 5c0791b..0000000
--- a/sources_non_forked/ale/doc/ale-go.txt
+++ /dev/null
@@ -1,263 +0,0 @@
-===============================================================================
-ALE Go Integration                                             *ale-go-options*
-
-
-===============================================================================
-Integration Information
-
-The `gometalinter` linter is disabled by default. ALE enables `gofmt`,
-`golint` and `go vet` by default. It also supports `staticcheck`, `go
-build`,  `gosimple`, `golangserver`.
-
-To enable `gometalinter`, update |g:ale_linters| as appropriate:
->
-  " Enable all of the linters you want for Go.
-  let g:ale_linters = {'go': ['gometalinter', 'gofmt']}
-<
-A possible configuration is to enable `gometalinter` and `gofmt` but paired
-with the `--fast` option, set by |g:ale_go_gometalinter_options|. This gets you
-the benefit of running a number of linters, more than ALE would by default,
-while ensuring it doesn't run any linters known to be slow or resource
-intensive.
-
-g:ale_go_go_executable                                    *g:ale_go_go_options*
-                                                          *b:ale_go_go_options*
-
-  Type: |String|
-  Default: `'go'`
-
-  The executable that will be run for the `gobuild` and `govet` linters, and
-  the `gomod` fixer.
-
-
-g:ale_go_go111module                                     *g:ale_go_go111module*
-                                                         *b:ale_go_go111module*
-  Type: |String|
-  Default: `''`
-
-  Override the value of the `$GO111MODULE` environment variable for
-  golang tools.
-
-
-
-===============================================================================
-bingo                                                            *ale-go-bingo*
-
-g:ale_go_bingo_executable                           *g:ale_go_bingo_executable*
-                                                    *b:ale_go_bingo_executable*
-  Type: |String|
-  Default: `'bingo'`
-
-  Location of the bingo binary file.
-
-
-g:ale_go_bingo_options                                 *g:ale_go_bingo_options*
-                                                       *b:ale_go_bingo_options*
-  Type: |String|
-  Default: `''`
-
-
-===============================================================================
-gobuild                                                        *ale-go-gobuild*
-
-g:ale_go_gobuild_options                             *g:ale_go_gobuild_options*
-                                                     *b:ale_go_gobuild_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be set to pass additional options to the gobuild linter.
-  They are injected directly after "go test".
-
-
-===============================================================================
-gofmt                                                            *ale-go-gofmt*
-
-g:ale_go_gofmt_options                                 *g:ale_go_gofmt_options*
-                                                       *b:ale_go_gofmt_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be set to pass additional options to the gofmt fixer.
-
-
-===============================================================================
-golangci-lint                                            *ale-go-golangci-lint*
-
-`golangci-lint` is a `lint_file` linter, which only lints files that are
-written to disk. This differs from the default behavior of linting the buffer.
-See: |ale-lint-file|
-
-g:ale_go_golangci_lint_executable           *g:ale_go_golangci_lint_executable*
-                                            *b:ale_go_golangci_lint_executable*
-  Type: |String|
-  Default: `'golangci-lint'`
-
-  The executable that will be run for golangci-lint.
-
-
-g:ale_go_golangci_lint_options                 *g:ale_go_golangci_lint_options*
-                                               *b:ale_go_golangci_lint_options*
-  Type: |String|
-  Default: `'--enable-all'`
-
-  This variable can be changed to alter the command-line arguments to the
-  golangci-lint invocation.
-
-
-g:ale_go_golangci_lint_package                 *g:ale_go_golangci_lint_package*
-                                               *b:ale_go_golangci_lint_package*
-  Type: |Number|
-  Default: `0`
-
-  When set to `1`, the whole Go package will be checked instead of only the
-  current file.
-
-
-===============================================================================
-golangserver                                              *ale-go-golangserver*
-
-g:ale_go_langserver_executable                 *g:ale_go_langserver_executable*
-                                               *b:ale_go_langserver_executable*
-  Type: |String|
-  Default: `'go-langserver'`
-
-  Location of the go-langserver binary file.
-
-
-g:ale_go_langserver_options                       *g:ale_go_langserver_options*
-                                                  *b:ale_go_langserver_options*
-  Type: |String|
-  Default: `''`
-
-  Additional options passed to the go-langserver command. Note that the
-  `-gocodecompletion` option is ignored because it is handled automatically
-  by the |g:ale_completion_enabled| variable.
-
-
-===============================================================================
-golint                                                          *ale-go-golint*
-
-g:ale_go_golint_executable                         *g:ale_go_golint_executable*
-                                                   *b:ale_go_golint_executable*
-  Type: |String|
-  Default: `'golint'`
-
-  This variable can be set to change the golint executable path.
-
-
-g:ale_go_golint_options                               *g:ale_go_golint_options*
-                                                      *b:ale_go_golint_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be set to pass additional options to the golint linter.
-
-
-===============================================================================
-gometalinter                                              *ale-go-gometalinter*
-
-`gometalinter` is a `lint_file` linter, which only lints files that are
-written to disk. This differs from the default behavior of linting the buffer.
-See: |ale-lint-file|
-
-g:ale_go_gometalinter_executable             *g:ale_go_gometalinter_executable*
-                                             *b:ale_go_gometalinter_executable*
-  Type: |String|
-  Default: `'gometalinter'`
-
-  The executable that will be run for gometalinter.
-
-
-g:ale_go_gometalinter_options                   *g:ale_go_gometalinter_options*
-                                                *b:ale_go_gometalinter_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be changed to alter the command-line arguments to the
-  gometalinter invocation.
-
-  Since `gometalinter` runs a number of linters that can consume a lot of
-  resources it's recommended to set this option to a value of `--fast` if you
-  use `gometalinter` as one of the linters in |g:ale_linters|. This disables a
-  number of linters known to be slow or consume a lot of resources.
-
-
-g:ale_go_gometalinter_lint_package         *g:ale_go_gometalinter_lint_package*
-                                           *b:ale_go_gometalinter_lint_package*
-  Type: |Number|
-  Default: `0`
-
-  When set to `1`, the whole Go package will be checked instead of only the
-  current file.
-
-
-===============================================================================
-gopls                                                            *ale-go-gopls*
-
-g:ale_go_gopls_executable                           *g:ale_go_gopls_executable*
-                                                    *b:ale_go_gopls_executable*
-  Type: |String|
-  Default: `'gopls'`
-
-  Location of the gopls binary file.
-
-
-g:ale_go_gopls_options                                 *g:ale_go_gopls_options*
-                                                       *b:ale_go_gopls_options*
-  Type: |String|
-  Default: `''`
-
-
-===============================================================================
-govet                                                            *ale-go-govet*
-
-g:ale_go_govet_options                                 *g:ale_go_govet_options*
-                                                       *b:ale_go_govet_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be set to pass additional options to the go vet linter.
-
-
-===============================================================================
-revive                                                          *ale-go-revive*
-
-g:ale_go_revive_executable                         *g:ale_go_revive_executable*
-                                                   *b:ale_go_revive_executable*
-  Type: |String|
-  Default: `'revive'`
-
-  This variable can be set to change the revive executable path.
-
-
-g:ale_go_revive_options                               *g:ale_go_revive_options*
-                                                      *b:ale_go_revive_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be set to pass additional options to the revive
-
-
-===============================================================================
-staticcheck                                                *ale-go-staticcheck*
-
-g:ale_go_staticcheck_options                     *g:ale_go_staticcheck_options*
-                                                 *b:ale_go_staticcheck_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be set to pass additional options to the staticcheck
-  linter.
-
-
-g:ale_go_staticcheck_lint_package           *g:ale_go_staticcheck_lint_package*
-                                            *b:ale_go_staticcheck_lint_package*
-  Type: |Number|
-  Default: `0`
-
-  When set to `1`, the whole Go package will be checked instead of only the
-  current file.
-
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-graphql.txt b/sources_non_forked/ale/doc/ale-graphql.txt
deleted file mode 100644
index 603694b..0000000
--- a/sources_non_forked/ale/doc/ale-graphql.txt
+++ /dev/null
@@ -1,22 +0,0 @@
-===============================================================================
-ALE GraphQL Integration                                   *ale-graphql-options*
-
-
-===============================================================================
-eslint                                                     *ale-graphql-eslint*
-
-The `eslint` linter for GraphQL uses the JavaScript options for `eslint`; see:
-|ale-javascript-eslint|.
-
-You will need the GraphQL ESLint plugin installed for this to work.
-
-===============================================================================
-gqlint                                                     *ale-graphql-gqlint*
-
-===============================================================================
-prettier                                                 *ale-graphql-prettier*
-
-See |ale-javascript-prettier| for information about the available options.
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-hack.txt b/sources_non_forked/ale/doc/ale-hack.txt
deleted file mode 100644
index 4776b8c..0000000
--- a/sources_non_forked/ale/doc/ale-hack.txt
+++ /dev/null
@@ -1,51 +0,0 @@
-===============================================================================
-ALE Hack Integration                                         *ale-hack-options*
-                                                         *ale-integration-hack*
-
-  HHAST is disabled by default, as it executes code in the project root.
-
-  Currently linters must be enabled globally.  HHAST can be enabled with:
-
->
-  let g:ale_linters = {'hack': ['hack', 'hhast']}
-<
-
-===============================================================================
-hack                                                            *ale-hack-hack*
-
-g:ale_hack_hack_executable                         *g:ale_hack_hack_executable*
-                                                   *b:ale_hack_hack_executable*
-
-  Type: |String|
-  Default: `'hh_client'`
-
-  This variable can be set to use a specific executable to interact with the
-  Hack typechecker.
-
-
-===============================================================================
-hackfmt                                                      *ale-hack-hackfmt*
-
-g:ale_hack_hackfmt_options                         *g:ale_hack_hackfmt_options*
-                                                   *b:ale_hack_hackfmt_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be set to pass additional options to the hackfmt fixer.
-
-
-===============================================================================
-hhast                                                          *ale-hack-hhast*
-
-g:ale_hack_hhast_executable                       *g:ale_hack_hhast_executable*
-                                                  *b:ale_hack_hhast_executable*
-
-  Type: |String|
-  Default: `'vendor/bin/hhast-lint'`
-
-  This variable can be set to use a specific executable to interact with the
-  Hack typechecker.
-
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-handlebars.txt b/sources_non_forked/ale/doc/ale-handlebars.txt
deleted file mode 100644
index 5daec5b..0000000
--- a/sources_non_forked/ale/doc/ale-handlebars.txt
+++ /dev/null
@@ -1,32 +0,0 @@
-===============================================================================
-ALE Handlebars Integration                             *ale-handlebars-options*
-
-
-===============================================================================
-prettier                                              *ale-handlebars-prettier*
-
-See |ale-javascript-prettier| for information about the available options.
-Uses glimmer parser by default.
-
-
-===============================================================================
-ember-template-lint                          *ale-handlebars-embertemplatelint*
-
-g:ale_handlebars_embertemplatelint_executable
-                                *g:ale_handlebars_embertemplatelint_executable*
-  Type: |String|                  *b:ale_handlebars_embertemplatelint_executable*
-  Default: `'ember-template-lint'`
-
-  See |ale-integrations-local-executables|
-
-
-g:ale_handlebars_embertemplatelint_use_global
-                                *g:ale_handlebars_embertemplatelint_use_global*
-  Type: |Number|                  *b:ale_handlebars_embertemplatelint_use_global*
-  Default: `get(g:, 'ale_use_global_executables', 0)`
-
-  See |ale-integrations-local-executables|
-
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-haskell.txt b/sources_non_forked/ale/doc/ale-haskell.txt
deleted file mode 100644
index 5dd3ec1..0000000
--- a/sources_non_forked/ale/doc/ale-haskell.txt
+++ /dev/null
@@ -1,176 +0,0 @@
-===============================================================================
-ALE Haskell Integration                                   *ale-haskell-options*
-
-
-===============================================================================
-brittany                                                 *ale-haskell-brittany*
-
-g:ale_haskell_brittany_executable           *g:ale_haskell_brittany_executable*
-                                            *b:ale_haskell_brittany_executable*
-  Type: |String|
-  Default: `'brittany'`
-
-  This variable can be changed to use a different executable for brittany.
-
-
-===============================================================================
-floskell                                                 *ale-haskell-floskell*
-
-g:ale_haskell_floskell_executable           *g:ale_haskell_floskell_executable*
-                                            *b:ale_haskell_floskell_executable*
-  Type: |String|
-  Default: `'floskell'`
-
-  This variable can be changed to use a different executable for floskell.
-
-
-===============================================================================
-ghc                                                           *ale-haskell-ghc*
-
-g:ale_haskell_ghc_options                           *g:ale_haskell_ghc_options*
-                                                    *b:ale_haskell_ghc_options*
-  Type: |String|
-  Default: `'-fno-code -v0'`
-
-  This variable can be changed to modify flags given to ghc.
-
-
-===============================================================================
-ghc-mod                                                   *ale-haskell-ghc-mod*
-
-g:ale_haskell_ghc_mod_executable             *g:ale_haskell_ghc_mod_executable*
-                                             *b:ale_haskell_ghc_mod_executable*
-  Type: |String|
-  Default: `'ghc-mod'`
-
-  This variable can be changed to use a different executable for ghc-mod.
-
-
-===============================================================================
-cabal-ghc                                               *ale-haskell-cabal-ghc*
-
-g:ale_haskell_cabal_ghc_options               *g:ale_haskell_cabal_ghc_options*
-                                              *b:ale_haskell_cabal_ghc_options*
-  Type: |String|
-  Default: `'-fno-code -v0'`
-
-  This variable can be changed to modify flags given to ghc through cabal
-  exec.
-
-
-===============================================================================
-hdevtools                                               *ale-haskell-hdevtools*
-
-g:ale_haskell_hdevtools_executable         *g:ale_haskell_hdevtools_executable*
-                                           *b:ale_haskell_hdevtools_executable*
-  Type: |String|
-  Default: `'hdevtools'`
-
-  This variable can be changed to use a different executable for hdevtools.
-
-
-g:ale_haskell_hdevtools_options               *g:ale_haskell_hdevtools_options*
-                                              *b:ale_haskell_hdevtools_options*
-  Type: |String|
-  Default: `get(g:, 'hdevtools_options', '-g -Wall')`
-
-  This variable can be changed to modify flags given to hdevtools.
-
-  The hdevtools documentation recommends setting GHC options for `hdevtools`
-  with `g:hdevtools_options`. ALE will use the value of `g:hdevtools_options`
-  for the value of `g:ale_haskell_hdevtools_options` by default, so this
-  option can be respected and overridden specifically for ALE.
-
-
-===============================================================================
-hfmt                                                         *ale-haskell-hfmt*
-
-g:ale_haskell_hfmt_executable                   *g:ale_haskell_hfmt_executable*
-                                                *b:ale_haskell_hfmt_executable*
-  Type: |String|
-  Default: `'hfmt'`
-
-  This variable can be changed to use a different executable for hfmt.
-
-
-===============================================================================
-hindent                                                   *ale-haskell-hindent*
-
-g:ale_haskell_hindent_executable             *g:ale_haskell_hindent_executable*
-                                             *b:ale_haskell_hindent_executable*
-  Type: |String|
-  Default: `'hindent'`
-
-  This variable can be changed to use a different executable for hindent.
-
-
-===============================================================================
-hlint                                                       *ale-haskell-hlint*
-
-g:ale_haskell_hlint_executable                 *g:ale_haskell_hlint_executable*
-                                               *b:ale_haskell_hlint_executable*
-  Type: |String|
-  Default: `'hlint'`
-
-  This variable can be changed to use a different executable for hlint.
-
-
-g:ale_haskell_hlint_options                       g:ale_haskell_hlint_options
-                                                  b:ale_haskell_hlint_options
-  Type: String
-  Default: ''
-
-  This variable can be used to pass extra options to the underlying hlint
-  executable.
-
-
-===============================================================================
-stack-build                                           *ale-haskell-stack-build*
-
-g:ale_haskell_stack_build_options           *g:ale_haskell_stack_build_options*
-                                            *b:ale_haskell_stack_build_options*
-  Type: |String|
-  Default: `'--fast'`
-
-  We default to using `'--fast'`. Since Stack generates binaries, your
-  programs will be slower unless you separately rebuild them outside of ALE.
-
-
-===============================================================================
-stack-ghc                                               *ale-haskell-stack-ghc*
-
-g:ale_haskell_stack_ghc_options               *g:ale_haskell_stack_ghc_options*
-                                              *b:ale_haskell_stack_ghc_options*
-  Type: |String|
-  Default: `'-fno-code -v0'`
-
-  This variable can be changed to modify flags given to ghc through `stack
-  ghc`
-
-
-===============================================================================
-stylish-haskell                                   *ale-haskell-stylish-haskell*
-
-g:ale_haskell_stylish_haskell_executable
-                                     *g:ale_haskell_stylish_haskell_executable*
-                                     *b:ale_haskell_stylish_haskell_executable*
-  Type: |String|
-  Default: `'stylish-haskell'`
-
-  This variable can be changed to use a different executable for stylish-haskell.
-
-
-===============================================================================
-hie                                                           *ale-haskell-hie*
-
-g:ale_haskell_hie_executable                     *g:ale_haskell_hie_executable*
-                                                 *b:ale_haskell_hie_executable*
-  Type: |String|
-  Default: `'hie'`
-
-  This variable can be changed to use a different executable for the haskell
-  ide engine. i.e. `'hie-wrapper'`
-
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-hcl.txt b/sources_non_forked/ale/doc/ale-hcl.txt
deleted file mode 100644
index 59b0a9d..0000000
--- a/sources_non_forked/ale/doc/ale-hcl.txt
+++ /dev/null
@@ -1,11 +0,0 @@
-===============================================================================
-ALE HCL Integration                                           *ale-hcl-options*
-
-
-===============================================================================
-terraform-fmt                                           *ale-hcl-terraform-fmt*
-
-See |ale-terraform-fmt-fixer| for information about the available options.
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-html.txt b/sources_non_forked/ale/doc/ale-html.txt
deleted file mode 100644
index c78dc4c..0000000
--- a/sources_non_forked/ale/doc/ale-html.txt
+++ /dev/null
@@ -1,140 +0,0 @@
-===============================================================================
-ALE HTML Integration                                         *ale-html-options*
-
-
-===============================================================================
-fecs                                                            *ale-html-fecs*
-
-`fecs` options for HTMl is the same as the options for JavaScript,
-and both of them reads `./.fecsrc` as the default configuration file.
-See: |ale-javascript-fecs|.
-
-===============================================================================
-html-beautify                                               *ale-html-beautify*
-
-g:ale_html_beautify_options                       *g:ale_html_beautify_options*
-                                                  *b:ale_html_beautify_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be changed to modify flags given to html-beautify.
-
-
-===============================================================================
-htmlhint                                                    *ale-html-htmlhint*
-
-g:ale_html_htmlhint_executable                 *g:ale_html_htmlhint_executable*
-                                               *b:ale_html_htmlhint_executable*
-  Type: |String|
-  Default: `'htmlhint'`
-
-  See |ale-integrations-local-executables|
-
-
-g:ale_html_htmlhint_options                       *g:ale_html_htmlhint_options*
-                                                  *b:ale_html_htmlhint_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be changed to modify flags given to HTMLHint.
-
-
-g:ale_html_htmlhint_use_global                 *g:ale_html_htmlhint_use_global*
-                                               *b:ale_html_htmlhint_use_global*
-  Type: |String|
-  Default: `get(g:, 'ale_use_global_executables', 0)`
-
-  See |ale-integrations-local-executables|
-
-
-===============================================================================
-tidy                                                            *ale-html-tidy*
-
-`tidy` is a console application which corrects and cleans up HTML and XML
-documents by fixing markup errors and upgrading legacy code to modern
-standards.
-
-Note:
-`/usr/bin/tidy` on macOS (installed by default) is too old. It was released
-on 31 Oct 2006. It does not consider modern HTML specs (HTML5) and shows
-outdated warnings. So |ale| ignores `/usr/bin/tidy` on macOS.
-
-To use `tidy` on macOS, please install the latest version with Homebrew:
->
-  $ brew install tidy-html5
-<
-`/usr/local/bin/tidy` is installed.
-
-g:ale_html_tidy_executable                         *g:ale_html_tidy_executable*
-                                                   *b:ale_html_tidy_executable*
-  Type: |String|
-  Default: `'tidy'`
-
-  This variable can be changed to change the path to tidy.
-
-
-g:ale_html_tidy_options                               *g:ale_html_tidy_options*
-                                                      *b:ale_html_tidy_options*
-  Type: |String|
-  Default: `'-q -e -language en'`
-
-  This variable can be changed to change the arguments provided to the
-  executable.
-
-  ALE will attempt to automatically detect the appropriate file encoding to
-  provide to html-tidy, and fall back to UTF-8 when encoding detection fails.
-
-  The recognized file encodings are as follows: ascii, big5, cp1252 (win1252),
-  cp850 (ibm858), cp932 (shiftjis), iso-2022-jp (iso-2022), latin1, macroman
-  (mac), sjis (shiftjis), utf-16le, utf-16, utf-8
-
-
-g:ale_html_tidy_use_global                             *g:html_tidy_use_global*
-
-  Type: |Number|
-  Default: `get(g:, 'ale_use_global_executables', 0)`
-
-  See |ale-integrations-local-executables|
-
-
-===============================================================================
-prettier                                                    *ale-html-prettier*
-
-See |ale-javascript-prettier| for information about the available options.
-
-
-===============================================================================
-stylelint                                                  *ale-html-stylelint*
-
-g:ale_html_stylelint_executable               *g:ale_html_stylelint_executable*
-                                              *b:ale_html_stylelint_executable*
-  Type: |String|
-  Default: `'stylelint'`
-
-  See |ale-integrations-local-executables|
-
-
-g:ale_html_stylelint_options                     *g:ale_html_stylelint_options*
-                                                 *b:ale_html_stylelint_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be set to pass additional options to stylelint.
-
-
-g:ale_html_stylelint_use_global               *g:ale_html_stylelint_use_global*
-                                              *b:ale_html_stylelint_use_global*
-  Type: |String|
-  Default: `0`
-
-  See |ale-integrations-local-executables|
-
-
-===============================================================================
-write-good                                                *ale-html-write-good*
-
-See |ale-write-good-options|
-
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-idris.txt b/sources_non_forked/ale/doc/ale-idris.txt
deleted file mode 100644
index c7500b0..0000000
--- a/sources_non_forked/ale/doc/ale-idris.txt
+++ /dev/null
@@ -1,23 +0,0 @@
-===============================================================================
-ALE Idris Integration                                       *ale-idris-options*
-
-===============================================================================
-idris                                                         *ale-idris-idris*
-
-g:ale_idris_idris_executable                     *g:ale_idris_idris_executable*
-                                                 *b:ale_idris_idris_executable*
-  Type: |String|
-  Default: `'idris'`
-
-  This variable can be changed to change the path to idris.
-
-
-g:ale_idris_idris_options                           *g:ale_idris_idris_options*
-                                                    *b:ale_idris_idris_options*
-  Type: |String|
-  Default: `'--total --warnpartial --warnreach --warnipkg'`
-
-  This variable can be changed to modify flags given to idris.
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-ink.txt b/sources_non_forked/ale/doc/ale-ink.txt
deleted file mode 100644
index 9412a09..0000000
--- a/sources_non_forked/ale/doc/ale-ink.txt
+++ /dev/null
@@ -1,40 +0,0 @@
-===============================================================================
-ALE Ink Integration                                           *ale-ink-options*
-
-
-===============================================================================
-ink-language-server                                   *ale-ink-language-server*
-
-Ink Language Server
-  (https://github.com/ephraim/ink-language-server)
-
-g:ale_ink_ls_executable                               g:ale_ink_ls_executable
-                                                      b:ale_ink_ls_executable
-  Type: |String|
-  Default: `'ink-language-server'`
-
-  Ink language server executable.
-
-g:ale_ink_ls_initialization_options
-                                          g:ale_ink_ls_initialization_options
-                                          b:ale_ink_ls_initialization_options
-  Type: |Dictionary|
-  Default: `{}`
-
-  Dictionary containing configuration settings that will be passed to the
-  language server at startup. For certain platforms and certain story
-  structures, the defaults will suffice. However, many projects will need to
-  change these settings - see the ink-language-server website for more
-  information.
-
-  An example of setting non-default options:
-		{
-		\  'ink': {
-		\    'mainStoryPath': 'init.ink',
-		\    'inklecateExecutablePath': '/usr/local/bin/inklecate',
-		\    'runThroughMono': v:false
-		\  }
-		\}
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-ispc.txt b/sources_non_forked/ale/doc/ale-ispc.txt
deleted file mode 100644
index bf30e8e..0000000
--- a/sources_non_forked/ale/doc/ale-ispc.txt
+++ /dev/null
@@ -1,24 +0,0 @@
-===============================================================================
-ALE ISPC Integration                                         *ale-ispc-options*
-
-
-===============================================================================
-ispc                                                            *ale-ispc-ispc*
-
-g:ale_ispc_ispc_executable                         *g:ale_ispc_ispc_executable*
-                                                   *b:ale_ispc_ispc_executable*
-  Type: |String|
-  Default: `'ispc'`
-
-  This variable can be changed to use a different executable for ispc.
-
-
-g:ale_ispc_ispc_options                               *g:ale_ispc_ispc_options*
-                                                      *b:ale_ispc_ispc_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be changed to modify flags given to ispc.
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-java.txt b/sources_non_forked/ale/doc/ale-java.txt
deleted file mode 100644
index d2001ca..0000000
--- a/sources_non_forked/ale/doc/ale-java.txt
+++ /dev/null
@@ -1,268 +0,0 @@
-===============================================================================
-ALE Java Integration                                         *ale-java-options*
-
-
-===============================================================================
-checkstyle                                                *ale-java-checkstyle*
-
-g:ale_java_checkstyle_config                     *g:ale_java_checkstyle_config*
-                                                 *b:ale_java_checkstyle_config*
-
-  Type: |String|
-  Default: `'/google_checks.xml'`
-
-  A path to a checkstyle configuration file.
-
-  If a configuration file is specified with |g:ale_java_checkstyle_options|,
-  it will be preferred over this setting.
-
-  The path to the configuration file can be an absolute path or a relative
-  path. ALE will search for the relative path in parent directories.
-
-
-g:ale_java_checkstyle_executable             *g:ale_java_checkstyle_executable*
-                                             *b:ale_java_checkstyle_executable*
-
-  Type: |String|
-  Default: 'checkstyle'
-
-  This variable can be changed to modify the executable used for checkstyle.
-
-
-g:ale_java_checkstyle_options                   *g:ale_java_checkstyle_options*
-                                                *b:ale_java_checkstyle_options*
-
-  Type: |String|
-  Default: `''`
-
-  This variable can be changed to modify flags given to checkstyle.
-
-  If a configuration file is specified with `-c`, it will be used instead of
-  configuration files set with |g:ale_java_checkstyle_config|.
-
-
-===============================================================================
-javac                                                          *ale-java-javac*
-
-g:ale_java_javac_classpath                         *g:ale_java_javac_classpath*
-                                                   *b:ale_java_javac_classpath*
-  Type: |String| or |List|
-  Default: `''`
-
-  This variable can be set to change the global classpath for Java.
-
-
-g:ale_java_javac_executable                       *g:ale_java_javac_executable*
-                                                  *b:ale_java_javac_executable*
-  Type: |String|
-  Default: `'javac'`
-
-  This variable can be set to change the executable path used for javac.
-
-
-g:ale_java_javac_options                             *g:ale_java_javac_options*
-                                                     *b:ale_java_javac_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be set to pass additional options to javac.
-
-g:ale_java_javac_sourcepath                       *g:ale_java_javac_sourcepath*
-                                                  *b:ale_java_javac_sourcepath*
-  Type: |String| or |List|
-  Default: `''`
-
-This variable can set multiple source code paths, the source code path is a
-relative path (relative to the project root directory).
-
-Example:
-
-String type:
-Note that the unix system separator is a colon(`:`) window system
-is a semicolon(`;`).
->
-  let g:ale_java_javac_sourcepath = 'build/gen/source/xx/main:build/gen/source'
-<
-List type:
->
-  let g:ale_java_javac_sourcepath = [
-    \ 'build/generated/source/querydsl/main',
-    \ 'target/generated-sources/source/querydsl/main'
-  \ ]
-<
-
-
-===============================================================================
-google-java-format                                *ale-java-google-java-format*
-
-
-g:ale_java_google_java_format_executable
-                                     *g:ale_java_google_java_format_executable*
-                                     *b:ale_java_google_java_format_executable*
-  Type: |String|
-  Default: `'google-java-format'`
-
-  See |ale-integrations-local-executables|
-
-
-g:ale_java_google_java_format_options   *g:ale_java_google_java_format_options*
-                                        *b:ale_java_google_java_format_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be set to pass additional options
-
-
-===============================================================================
-pmd                                                              *ale-java-pmd*
-
-g:ale_java_pmd_options                                 *g:ale_java_pmd_options*
-                                                       *b:ale_java_pmd_options*
-
-  Type: String
-  Default: '-R category/java/bestpractices'
-
-  This variable can be changed to modify flags given to PMD. Do not specify -f
-  and -d. They are added automatically.
-
-
-===============================================================================
-javalsp                                                      *ale-java-javalsp*
-
-To enable Java LSP linter you need to download and build the vscode-javac
-language server from https://github.com/georgewfraser/java-language-server.
-Simply download the source code and then build a distribution:
-
-   scripts/link_mac.sh
-
-or
-
-   scripts/link_windows.sh
-
-This generates a dist/mac or dist/windows directory that contains the
-language server. To let ALE use this language server you need to set the
-g:ale_java_javalsp_executable variable to the absolute path of the launcher
-executable in this directory.
-
-g:ale_java_javalsp_executable                   *g:ale_java_javalsp_executable*
-                                                *b:ale_java_javalsp_executable*
-  Type: |String|
-  Default: `''`
-
-This variable must be set to the absolute path of the language server launcher
-executable. For example:
->
-  let g:ale_java_javalsp_executable=/java-language-server/dist/mac/bin/launcher
-<
-
-g:ale_java_javalsp_config                           *g:ale_java_javalsp_config*
-                                                    *b:ale_java_javalsp_config*
-  Type: |Dictionary|
-  Default: `{}`
-
-The javalsp linter automatically detects external depenencies for Maven and
-Gradle projects. In case the javalsp fails to detect some of them, you can
-specify them setting a dictionary to |g:ale_java_javalsp_config| variable.
->
-  let g:ale_java_javalsp_executable =
-  \ {
-  \   'java': {
-  \     'externalDependencies': [
-  \       'junit:junit:jar:4.12:test',   " Maven format
-  \       'junit:junit:4.1'              " Gradle format
-  \     ],
-  \     'classPath': [
-  \       'lib/some-dependency.jar',
-  \       '/android-sdk/platforms/android-28.jar'
-  \     ]
-  \   }
-  \ }
-
-The Java language server will look for the dependencies you specify in
-`externalDependencies` array in your Maven and Gradle caches ~/.m2 and
-~/.gradle.
-
-===============================================================================
-eclipselsp                                                *ale-java-eclipselsp*
-
-To enable Eclipse LSP linter you need to clone and build the eclipse.jdt.ls
-language server from https://github.com/eclipse/eclipse.jdt.ls. Simply
-clone the source code repo and then build the plugin:
-
-   ./mvnw clean verify
-
-Note: currently, the build can only run when launched with JDK 8. JDK 9 or more
-recent versions can be used to run the server though.
-
-After build completes the files required to run the language server will be
-located inside the repository folder `eclipse.jdt.ls`. Please ensure to set
-|g:ale_java_eclipselsp_path| to the absolute path of that folder.
-
-You could customize compiler options and code assists of the server.
-Under your project folder, modify the file `.settings/org.eclipse.jdt.core.prefs`
-with options presented at
-https://help.eclipse.org/neon/topic/org.eclipse.jdt.doc.isv/reference/api/org/eclipse/jdt/core/JavaCore.html.
-
-g:ale_java_eclipselsp_path                         *g:ale_java_eclipselsp_path*
-                                                   *b:ale_java_eclipselsp_path*
-
-  Type: |String|
-  Default: `'$HOME/eclipse.jdt.ls'`
-
-  Absolute path to the location of the eclipse.jdt.ls repository folder. Or if
-  you have VSCode extension installed the absolute path to the VSCode extensions
-  folder (e.g. $HOME/.vscode/extensions/redhat.java-0.4x.0 in Linux).
-
-
-g:ale_java_eclipselsp_executable                *g:ale_java_eclipse_executable*
-                                                *b:ale_java_eclipse_executable*
-  Type: |String|
-  Default: `'java'`
-
-  This variable can be set to change the executable path used for java.
-
-
-g:ale_java_eclipselsp_config_path              *g:ale_java_eclipse_config_path*
-                                               *b:ale_java_eclipse_config_path*
-  Type: |String|
-  Default: `''`
-
-  Set this variable to change the configuration directory path used by
-  eclipselsp (e.g. `$HOME/.jdtls` in Linux).
-  By default ALE will attempt to use the configuration within the installation
-  directory.
-  This setting is particularly useful when eclipselsp is installed in a
-  non-writable directory like `/usr/share/java/jdtls`, as is the case when
-  installed via system package.
-
-
-g:ale_java_eclipselsp_workspace_path     *g:ale_java_eclipselsp_workspace_path*
-                                         *b:ale_java_eclipselsp_workspace_path*
-
-  Type: |String|
-  Default: `''`
-
-  If you have Eclipse installed is good idea to set this variable to the
-  absolute path of the Eclipse workspace. If not set this value will be set to
-  the parent folder of the project root.
-
-g:ale_java_eclipselsp_javaagent               *g:ale_java_eclipselsp_javaagent*
-                                              *b:ale_java_eclipselsp_javaagent*
-
-  Type: |String|
-  Default: `''`
-
-  A variable to add java agent for annotation processing such as Lombok.
-  If you have multiple java agent files, use space to separate them. For example:
->
-  let g:ale_java_eclipselsp_javaagent='/eclipse/lombok.jar /eclipse/jacoco.jar'
-<
-
-===============================================================================
-uncrustify                                                *ale-java-uncrustify*
-
-See |ale-c-uncrustify| for information about the available options.
-
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-javascript.txt b/sources_non_forked/ale/doc/ale-javascript.txt
deleted file mode 100644
index ea0a708..0000000
--- a/sources_non_forked/ale/doc/ale-javascript.txt
+++ /dev/null
@@ -1,336 +0,0 @@
-===============================================================================
-ALE JavaScript Integration                             *ale-javascript-options*
-
-                                        *ale-eslint-nested-configuration-files*
-
-For fixing files with ESLint, nested configuration files with `root: false`
-are not supported. This is because ALE fixes files by writing the contents of
-buffers to temporary files, and then explicitly sets the configuration file.
-Configuration files which are set explicitly must be root configuration files.
-If you are using nested configuration files, you should restructure your
-project so your configuration files use `extends` instead.
-
-See the ESLint documentation here:
-http://eslint.org/docs/user-guide/configuring#extending-configuration-files
-
-You should change the structure of your project from this: >
-  /path/foo/.eslintrc.js # root: true
-  /path/foo/bar/.eslintrc.js # root: false
-<
-To this: >
-  /path/foo/.base-eslintrc.js # Base configuration here
-  /path/foo/.eslintrc.js # extends: ["/path/foo/.base-eslintrc.js"]
-  /path/foo/bar/.eslintrc.js # extends: ["/path/foo/.base-eslintrc.js"]
-<
-
-===============================================================================
-eslint                                                  *ale-javascript-eslint*
-
-g:ale_javascript_eslint_executable         *g:ale_javascript_eslint_executable*
-                                           *b:ale_javascript_eslint_executable*
-  Type: |String|
-  Default: `'eslint'`
-
-  See |ale-integrations-local-executables|
-
-
-g:ale_javascript_eslint_options               *g:ale_javascript_eslint_options*
-                                              *b:ale_javascript_eslint_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be set to pass additional options to eslint.
-
-
-g:ale_javascript_eslint_use_global         *g:ale_javascript_eslint_use_global*
-                                           *b:ale_javascript_eslint_use_global*
-  Type: |Number|
-  Default: `get(g:, 'ale_use_global_executables', 0)`
-
-  See |ale-integrations-local-executables|
-
-
-g:ale_javascript_eslint_suppress_eslintignore
-                                *g:ale_javascript_eslint_suppress_eslintignore*
-                                *b:ale_javascript_eslint_suppress_eslintignore*
-  Type: |Number|
-  Default: `0`
-
-  This variable can be set to `1` to disable warnings for files being ignored
-  by eslint.
-
-
-g:ale_javascript_eslint_suppress_missing_config
-                              *g:ale_javascript_eslint_suppress_missing_config*
-                              *b:ale_javascript_eslint_suppress_missing_config*
-  Type: |Number|
-  Default: `0`
-
-  This variable can be set to `1` to disable errors for missing eslint
-  configuration files.
-
-  When turning this option on, eslint will not report any problems when no
-  configuration files are found.
-
-
-===============================================================================
-fecs                                                      *ale-javascript-fecs*
-
-`fecs` is a lint tool for HTML/CSS/JavaScript, can be installed via:
-
-  `$ npm install --save-dev fecs`
-
-And the configuration file is located at `./fecsrc`, see http://fecs.baidu.com
-for more options.
-
-
-g:ale_javascript_fecs_executable             *g:ale_javascript_fecs_executable*
-                                             *b:ale_javascript_fecs_executable*
-  Type: |String|
-  Default: `'fecs'`
-
-  See |ale-integrations-local-executables|
-
-
-g:ale_javascript_fecs_use_global             *g:ale_javascript_fecs_use_global*
-                                             *b:ale_javascript_fecs_use_global*
-  Type: |Number|
-  Default: `get(g:, 'ale_use_global_executables', 0)`
-
-  See |ale-integrations-local-executables|
-
-
-===============================================================================
-flow                                                      *ale-javascript-flow*
-
-g:ale_javascript_flow_executable             *g:ale_javascript_flow_executable*
-                                             *b:ale_javascript_flow_executable*
-  Type: |String|
-  Default: `'flow'`
-
-  See |ale-integrations-local-executables|
-
-
-g:ale_javascript_flow_use_home_config   *g:ale_javascript_flow_use_home_config*
-                                        *b:ale_javascript_flow_use_home_config*
-  Type: |Number|
-  Default: `0`
-
-  When set to `1`, ALE will allow Flow to be executed with configuration files
-  from your home directory. ALE will not run Flow with home directory
-  configuration files by default, as doing so can lead to Vim consuming all of
-  your RAM and CPU power.
-
-
-g:ale_javascript_flow_use_global             *g:ale_javascript_flow_use_global*
-                                             *b:ale_javascript_flow_use_global*
-  Type: |Number|
-  Default: `get(g:, 'ale_use_global_executables', 0)`
-
-  See |ale-integrations-local-executables|
-
-
-g:ale_javascript_flow_use_respect_pragma
-                                     *g:ale_javascript_flow_use_respect_pragma*
-                                     *b:ale_javascript_flow_use_respect_pragma*
-  Type: |Number|
-  Default: `1`
-
-  By default, ALE will use the `--respect-pragma` option for `flow`, so only
-  files with the `@flow` pragma are checked by ALE. This option can be set to
-  `0` to disable that behaviour, so all files can be checked by `flow`.
-
-
-===============================================================================
-importjs                                              *ale-javascript-importjs*
-
-g:ale_javascript_importjs_executable     *g:ale_javascript_importjs_executable*
-                                         *b:ale_javascript_importjs_executable*
-  Type: |String|
-  Default: `'importjs'`
-
-
-===============================================================================
-jscs                                                      *ale-javascript-jscs*
-
-g:ale_javascript_jscs_executable             *g:ale_javascript_jscs_executable*
-                                             *b:ale_javascript_jscs_executable*
-  Type: |String|
-  Default: `'jscs'`
-
-  See |ale-integrations-local-executables|
-
-
-g:ale_javascript_jscs_use_global             *g:ale_javascript_jscs_use_global*
-                                             *b:ale_javascript_jscs_use_global*
-  Type: |Number|
-  Default: `get(g:, 'ale_use_global_executables', 0)`
-
-  See |ale-integrations-local-executables|
-
-
-===============================================================================
-jshint                                                  *ale-javascript-jshint*
-
-g:ale_javascript_jshint_executable         *g:ale_javascript_jshint_executable*
-                                           *b:ale_javascript_jshint_executable*
-  Type: |String|
-  Default: `'jshint'`
-
-  See |ale-integrations-local-executables|
-
-
-g:ale_javascript_jshint_use_global         *g:ale_javascript_jshint_use_global*
-                                           *b:ale_javascript_jshint_use_global*
-  Type: |Number|
-  Default: `get(g:, 'ale_use_global_executables', 0)`
-
-  See |ale-integrations-local-executables|
-
-
-===============================================================================
-prettier                                              *ale-javascript-prettier*
-
-g:ale_javascript_prettier_executable     *g:ale_javascript_prettier_executable*
-                                         *b:ale_javascript_prettier_executable*
-  Type: |String|
-  Default: `'prettier'`
-
-  See |ale-integrations-local-executables|
-
-
-g:ale_javascript_prettier_options           *g:ale_javascript_prettier_options*
-                                            *b:ale_javascript_prettier_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be set to pass additional options to prettier.
-
-
-g:ale_javascript_prettier_use_global     *g:ale_javascript_prettier_use_global*
-                                         *b:ale_javascript_prettier_use_global*
-  Type: |Number|
-  Default: `get(g:, 'ale_use_global_executables', 0)`
-
-  See |ale-integrations-local-executables|
-
-
-===============================================================================
-prettier-eslint                                *ale-javascript-prettier-eslint*
-
-g:ale_javascript_prettier_eslint_executable
-                                  *g:ale_javascript_prettier_eslint_executable*
-                                  *b:ale_javascript_prettier_eslint_executable*
-  Type: |String|
-  Default: `'prettier-eslint'`
-
-  See |ale-integrations-local-executables|
-
-
-g:ale_javascript_prettier_eslint_options
-                                     *g:ale_javascript_prettier_eslint_options*
-                                     *b:ale_javascript_prettier_eslint_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be set to pass additional options to prettier-eslint.
-
-
-g:ale_javascript_prettier_eslint_use_global
-                                  *g:ale_javascript_prettier_eslint_use_global*
-                                  *b:ale_javascript_prettier_eslint_use_global*
-  Type: |Number|
-  Default: `get(g:, 'ale_use_global_executables', 0)`
-
-  See |ale-integrations-local-executables|
-
-
-===============================================================================
-prettier-standard                            *ale-javascript-prettier-standard*
-
-
-g:ale_javascript_prettier_standard_executable
-                                *g:ale_javascript_prettier_standard_executable*
-                                *b:ale_javascript_prettier_standard_executable*
-  Type: |String|
-  Default: `'prettier-standard'`
-
-  See |ale-integrations-local-executables|
-
-
-g:ale_javascript_prettier_standard_options
-                                   *g:ale_javascript_prettier_standard_options*
-                                   *b:ale_javascript_prettier_standard_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be set to pass additional options to prettier-standard.
-
-
-g:ale_javascript_prettier_standard_use_global
-                                *g:ale_javascript_prettier_standard_use_global*
-                                *b:ale_javascript_prettier_standard_use_global*
-  Type: |Number|
-  Default: `get(g:, 'ale_use_global_executables', 0)`
-
-  See |ale-integrations-local-executables|
-
-
-
-
-===============================================================================
-standard                                              *ale-javascript-standard*
-
-g:ale_javascript_standard_executable     *g:ale_javascript_standard_executable*
-                                         *b:ale_javascript_standard_executable*
-  Type: |String|
-  Default: `'standard'`
-
-  See |ale-integrations-local-executables|
-
-
-g:ale_javascript_standard_options           *g:ale_javascript_standard_options*
-                                            *b:ale_javascript_standard_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be set to pass additional options to standard.
-
-
-g:ale_javascript_standard_use_global     *g:ale_javascript_standard_use_global*
-                                         *b:ale_javascript_standard_use_global*
-  Type: |Number|
-  Default: `get(g:, 'ale_use_global_executables', 0)`
-
-  See |ale-integrations-local-executables|
-
-
-===============================================================================
-xo                                                          *ale-javascript-xo*
-
-g:ale_javascript_xo_executable                 *g:ale_javascript_xo_executable*
-                                               *b:ale_javascript_xo_executable*
-  Type: |String|
-  Default: `'xo'`
-
-  See |ale-integrations-local-executables|
-
-
-g:ale_javascript_xo_options                       *g:ale_javascript_xo_options*
-                                                  *b:ale_javascript_xo_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be set to pass additional options to xo.
-
-
-g:ale_javascript_xo_use_global                 *g:ale_javascript_xo_use_global*
-                                               *b:ale_javascript_xo_use_global*
-  Type: |Number|
-  Default: `get(g:, 'ale_use_global_executables', 0)`
-
-  See |ale-integrations-local-executables|
-
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-json.txt b/sources_non_forked/ale/doc/ale-json.txt
deleted file mode 100644
index 96499a0..0000000
--- a/sources_non_forked/ale/doc/ale-json.txt
+++ /dev/null
@@ -1,105 +0,0 @@
-===============================================================================
-ALE JSON Integration                                         *ale-json-options*
-
-
-===============================================================================
-fixjson                                                      *ale-json-fixjson*
-
-fixjson is a JSON file fixer/formatter for humans using (relaxed) JSON5.
-It provides:
-
-- Pretty-prints JSON input
-- Fixes various failures while humans writing JSON
-  - Fixes trailing commas objects or arrays
-  - Fixes missing commas for elements of objects or arrays
-  - Adds quotes to keys in objects
-  - Newlines in strings
-  - Hex numbers
-  - Fixes single quotes to double quotes
-
-You can install it using npm:
->
-  $ npm install -g fixjson
-<
-ALE provides fixjson integration as a fixer. See |ale-fix|.
-
-g:ale_json_fixjson_executable                   *g:ale_json_fixjson_executable*
-                                                *b:ale_json_fixjson_executable*
-
-  Type: |String|
-  Default: `'fixjson'`
-
-  The executable that will be run for fixjson.
-
-g:ale_json_fixjson_options                         *g:ale_json_fixjson_options*
-                                                   *b:ale_json_fixjson_options*
-
-  Type: |String|
-  Default: `''`
-
-  This variable can add extra options to the command executed for running
-  fixjson.
-
-g:ale_json_fixjson_use_global                   *g:ale_json_fixjson_use_global*
-                                                *b:ale_json_fixjson_use_global*
-
-  Type: |Number|
-  Default: `get(g:, 'ale_use_global_executables', 0)`
-
-  See |ale-integrations-local-executables|
-
-
-===============================================================================
-jsonlint                                                    *ale-json-jsonlint*
-
-g:ale_json_jsonlint_executable                 *g:ale_json_jsonlint_executable*
-                                               *b:ale_json_jsonlint_executable*
-
-  Type: |String|
-  Default: `'jsonlint'`
-
-  The executable that will be run for jsonlint.
-
-g:ale_json_jsonlint_use_global                  *g:ale_json_jsonlint_use_global*
-                                                *b:ale_json_jsonlint_use_global*
-
-  Type: |Number|
-  Default: `get(g:, 'ale_use_global_executables', 0)`
-
-  See |ale-integrations-local-executables|
-
-
-===============================================================================
-jq                                                                *ale-json-jq*
-
-g:ale_json_jq_executable                             *g:ale_json_jq_executable*
-                                                     *b:ale_json_jq_executable*
-  Type: |String|
-  Default: `'jq'`
-
-  This option can be changed to change the path for `jq`.
-
-
-g:ale_json_jq_options                                   *g:ale_json_jq_options*
-                                                        *b:ale_json_jq_options*
-  Type: |String|
-  Default: `''`
-
-  This option can be changed to pass extra options to `jq`.
-
-g:ale_json_jq_filters                                   *g:ale_json_jq_filters*
-                                                        *b:ale_json_jq_filters*
-  Type: |String|
-  Default: `'.'`
-
-  This option can be changed to pass custom filters to `jq`.
-
-
-===============================================================================
-prettier                                                    *ale-json-prettier*
-
-See |ale-javascript-prettier| for information about the available options.
-
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-julia.txt b/sources_non_forked/ale/doc/ale-julia.txt
deleted file mode 100644
index 5153241..0000000
--- a/sources_non_forked/ale/doc/ale-julia.txt
+++ /dev/null
@@ -1,20 +0,0 @@
-===============================================================================
-ALE Julia Integration                                       *ale-julia-options*
-
-===============================================================================
-languageserver                                       *ale-julia-languageserver*
-
-To enable Julia LSP linter you need to install the LanguageServer.jl package
-within julia.
-
-g:ale_julia_executable                                 *g:ale_julia_executable*
-                                                       *b:ale_julia_executable*
-
-  Type: |String|
-  Default: 'julia'
-
-  Path to the julia exetuable.
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
-
diff --git a/sources_non_forked/ale/doc/ale-kotlin.txt b/sources_non_forked/ale/doc/ale-kotlin.txt
deleted file mode 100644
index 4028531..0000000
--- a/sources_non_forked/ale/doc/ale-kotlin.txt
+++ /dev/null
@@ -1,113 +0,0 @@
-===============================================================================
-ALE Kotlin Integration                                     *ale-kotlin-options*
-                                                       *ale-integration-kotlin*
-
-===============================================================================
-Integration Information
-
-  Make sure your setup has support for the kotlin file type. A filetype plugin
-  can be found here: https://github.com/udalov/kotlin-vim
-
-
-  Note: Make sure you have a working kotlin compiler
-
-
-===============================================================================
-kotlinc                                                    *ale-kotlin-kotlinc*
-
-g:ale_kotlin_kotlinc_options                     *g:ale_kotlin_kotlinc_options*
-  Type: |String|
-  Default: `''`
-
-  Additional options to pass to the kotlin compiler
-
-g:ale_kotlin_kotlinc_enable_config         *g:ale_kotlin_kotlinc_enable_config*
-  Type: |Number|
-  Default: `0`
-
-  Setting this variable to `1` tells the linter to load a configuration file.
-  This should be set in your vimrc
-
-g:ale_kotlin_kotlinc_config_file             *g:ale_kotlin_kotlinc_config_file*
-  Type: |String|
-  Default: `'.ale_kotlin_kotlinc_config'`
-
-  Filename of the configuration file. This should be set in your vimrc
-
-g:ale_kotlin_kotlinc_classpath                 *g:ale_kotlin_kotlinc_classpath*
-  Type: |String|
-  Default: `''`
-
-  A string containing the paths (separated by the appropriate path separator)
-  of the source directories.
-
-g:ale_kotlin_kotlinc_sourcepath               *g:ale_kotlin_kotlinc_sourcepath*
-  Type: |String|
-  Default: `''`
-
-  A string containing the paths (separated by space) of the source
-  directories.
-
-g:ale_kotlin_kotlinc_use_module_file     *g:ale_kotlin_kotlinc_use_module_file*
-  Type: |Number|
-  Default: `0`
-
-  This option indicates whether the linter should use a module file. It is off
-  by default.
-
-g:ale_kotlin_kotlinc_module_filename     *g:ale_kotlin_kotlinc_module_filename*
-  Type: |String|
-  Default: `'module.xml'`
-
-  The filename of the module file that the linter should pass to the kotlin
-  compiler.
-
-
-===============================================================================
-ktlint                                                      *ale-kotlin-ktlint*
-
-g:ale_kotlin_ktlint_executable                 *g:ale_kotlin_ktlint_executable*
-  Type: |String|
-  Default: `''`
-
-  The Ktlint executable.
-
-  Posix-compliant shell scripts are the only executables that can be found on
-  Ktlint's github release page. If you are not on such a system, your best
-  bet will be to download the ktlint jar and set this option to something
-  similar to `'java -jar /path/to/ktlint.jar'`
-
-g:ale_kotlin_ktlint_rulesets                     *g:ale_kotlin_ktlint_rulesets*
-  Type: |List| of |String|s
-  Default: []
-
-  This list should contain paths to ruleset jars and/or strings of maven
-  artifact triples. Example:
-  >
-  let g:ale_kotlin_ktlint_rulesets = ['/path/to/custom-ruleset.jar',
-  'com.ktlint.rulesets:mycustomrule:1.0.0']
-
-g:ale_kotlin_ktlint_options                       *g:ale_kotlin_ktlint_options*
-  Type: |String|
-  Default: `''`
-
-  Additional options to pass to ktlint for both linting and fixing. Example:
-  >
-  let g:ale_kotlin_ktlint_options = '--android'
-
-
-===============================================================================
-languageserver                                      *ale-kotlin-languageserver*
-
-g:ale_kotlin_languageserver_executable *g:ale_kotlin_languageserver_executable*
-  Type: |String|
-  Default: `''`
-
-  The kotlin-language-server executable.
-
-  Executables are located inside the bin/ folder of the language server
-  release.
-
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-latex.txt b/sources_non_forked/ale/doc/ale-latex.txt
deleted file mode 100644
index bedbabc..0000000
--- a/sources_non_forked/ale/doc/ale-latex.txt
+++ /dev/null
@@ -1,18 +0,0 @@
-===============================================================================
-ALE LaTeX Integration                                       *ale-latex-options*
-
-
-===============================================================================
-write-good                                               *ale-latex-write-good*
-
-See |ale-write-good-options|
-
-
-===============================================================================
-textlint                                                    *ale-latex-textlint*
-
-See |ale-text-textlint|
-
-
-===============================================================================
-vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-less.txt b/sources_non_forked/ale/doc/ale-less.txt
deleted file mode 100644
index 040e511..0000000
--- a/sources_non_forked/ale/doc/ale-less.txt
+++ /dev/null
@@ -1,66 +0,0 @@
-===============================================================================
-ALE Less Integration                                         *ale-less-options*
-
-
-===============================================================================
-lessc                                                          *ale-less-lessc*
-
-g:ale_less_lessc_executable                       *g:ale_less_lessc_executable*
-                                                  *b:ale_less_lessc_executable*
-  Type: |String|
-  Default: `'lessc'`
-
-  See |ale-integrations-local-executables|
-
-
-g:ale_less_lessc_options                             *g:ale_less_lessc_options*
-                                                     *b:ale_less_lessc_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be set to pass additional options to lessc.
-
-
-g:ale_less_lessc_use_global                       *g:ale_less_lessc_use_global*
-                                                  *b:ale_less_lessc_use_global*
-  Type: |String|
-  Default: `get(g:, 'ale_use_global_executables', 0)`
-
-  See |ale-integrations-local-executables|
-
-
-===============================================================================
-prettier                                                    *ale-less-prettier*
-
-See |ale-javascript-prettier| for information about the available options.
-
-
-===============================================================================
-stylelint                                                  *ale-less-stylelint*
-
-g:ale_less_stylelint_executable               *g:ale_less_stylelint_executable*
-                                              *b:ale_less_stylelint_executable*
-  Type: |String|
-  Default: `'stylelint'`
-
-  See |ale-integrations-local-executables|
-
-
-g:ale_less_stylelint_options                     *g:ale_less_stylelint_options*
-                                                 *b:ale_less_stylelint_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be set to pass additional options to stylelint.
-
-
-g:ale_less_stylelint_use_global               *g:ale_less_stylelint_use_global*
-                                              *b:ale_less_stylelint_use_global*
-  Type: |String|
-  Default: `get(g:, 'ale_use_global_executables', 0)`
-
-  See |ale-integrations-local-executables|
-
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-llvm.txt b/sources_non_forked/ale/doc/ale-llvm.txt
deleted file mode 100644
index 2f4a46b..0000000
--- a/sources_non_forked/ale/doc/ale-llvm.txt
+++ /dev/null
@@ -1,19 +0,0 @@
-===============================================================================
-ALE LLVM Integration                                         *ale-llvm-options*
-
-
-===============================================================================
-llc                                                              *ale-llvm-llc*
-
-g:ale_llvm_llc_executable                           *g:ale_llvm_llc_executable*
-                                                    *b:ale_llvm_llc_executable*
-
-  Type: |String|
-  Default: "llc"
-
-  The command to use for checking. This variable is useful when llc command
-  has suffix like "llc-5.0".
-
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-lua.txt b/sources_non_forked/ale/doc/ale-lua.txt
deleted file mode 100644
index f1286f8..0000000
--- a/sources_non_forked/ale/doc/ale-lua.txt
+++ /dev/null
@@ -1,34 +0,0 @@
-===============================================================================
-ALE Lua Integration                                           *ale-lua-options*
-
-===============================================================================
-luac                                                             *ale-lua-luac*
-
-g:ale_lua_luac_executable                           *g:ale_lua_luac_executable*
-                                                    *b:ale_lua_luac_executable*
-  Type: |String|
-  Default: `'luac'`
-
-  This variable can be changed to change the path to luac.
-
-===============================================================================
-luacheck                                                     *ale-lua-luacheck*
-
-g:ale_lua_luacheck_executable                   *g:ale_lua_luacheck_executable*
-                                                *b:ale_lua_luacheck_executable*
-  Type: |String|
-  Default: `'luacheck'`
-
-  This variable can be changed to change the path to luacheck.
-
-
-g:ale_lua_luacheck_options                         *g:ale_lua_luacheck_options*
-                                                   *b:ale_lua_luacheck_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be set to pass additional options to luacheck.
-
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-markdown.txt b/sources_non_forked/ale/doc/ale-markdown.txt
deleted file mode 100644
index 4e27eb9..0000000
--- a/sources_non_forked/ale/doc/ale-markdown.txt
+++ /dev/null
@@ -1,71 +0,0 @@
-===============================================================================
-ALE Markdown Integration                                 *ale-markdown-options*
-
-
-===============================================================================
-mdl                                                          *ale-markdown-mdl*
-
-g:ale_markdown_mdl_executable                   *g:ale_markdown_mdl_executable*
-                                                *b:ale_markdown_mdl_executable*
-  Type: |String|
-  Default: `'mdl'`
-
-  Override the invoked mdl binary. This is useful for running mdl from
-  binstubs or a bundle.
-
-
-g:ale_markdown_mdl_options                         *g:ale_markdown_mdl_options*
-                                                   *b:ale_markdown_mdl_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be set to pass additional options to mdl.
-
-
-===============================================================================
-prettier                                                *ale-markdown-prettier*
-
-See |ale-javascript-prettier| for information about the available options.
-
-
-===============================================================================
-remark-lint                                          *ale-markdown-remark-lint*
-
-g:ale_markdown_remark_lint_executable   *g:ale_markdown_remark_lint_executable*
-                                        *b:ale_markdown_remark_lint_executable*
-  Type: |String|
-  Default: `'remark'`
-
-  See |ale-integrations-local-executables|
-
-
-g:ale_markdown_remark_lint_options         *g:ale_markdown_remark_lint_options*
-                                           *b:ale_markdown_remark_lint_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be set to pass additional options to remark-lint.
-
-
-g:ale_markdown_remark_lint_use_global   *g:ale_markdown_remark_lint_use_global*
-                                        *b:ale_markdown_remark_lint_use_global*
-  Type: |Number|
-  Default: `get(g:, 'ale_use_global_executables', 0)`
-
-  See |ale-integrations-local-executables|
-
-
-===============================================================================
-textlint                                                *ale-markdown-textlint*
-
-See |ale-text-textlint|
-
-
-===============================================================================
-write-good                                            *ale-markdown-write-good*
-
-See |ale-write-good-options|
-
-
-===============================================================================
-vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-mercury.txt b/sources_non_forked/ale/doc/ale-mercury.txt
deleted file mode 100644
index ca06a0a..0000000
--- a/sources_non_forked/ale/doc/ale-mercury.txt
+++ /dev/null
@@ -1,26 +0,0 @@
-===============================================================================
-ALE Mercury Integration                                   *ale-mercury-options*
-
-
-===============================================================================
-mmc                                                           *ale-mercury-mmc*
-
-
-g:ale_mercury_mmc_executable                     *g:ale_mercury_mmc_executable*
-                                                 *b:ale_mercury_mmc_executable*
-  Type: |String|
-  Default: `'mmc'`
-
-  This variable can be changed to use a different executable for mmc.
-
-
-g:ale_mercury_mmc_options                           *g:ale_mercury_mmc_options*
-                                                    *b:ale_mercury_mmc_options*
-  Type: |String|
-  Default: `'--make --output-compile-error-lines 100'`
-
-  This variable can be set to pass additional options to mmc.
-
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-nasm.txt b/sources_non_forked/ale/doc/ale-nasm.txt
deleted file mode 100644
index 16c024a..0000000
--- a/sources_non_forked/ale/doc/ale-nasm.txt
+++ /dev/null
@@ -1,26 +0,0 @@
-===============================================================================
-ALE NASM Integration                                         *ale-nasm-options*
-
-
-===============================================================================
-nasm                                                            *ale-nasm-nasm*
-
-g:ale_nasm_nasm_executable                         *g:ale_nasm_nasm_executable*
-                                                   *b:ale_nasm_nasm_executable*
-
-  Type: |String|
-  Default `'nasm'`
-
-  This variable can be changed to use different executable for NASM.
-
-
-g:ale_nasm_nasm_options                               *g:ale_nasm_nasm_options*
-                                                      *b:ale_nasm_nasm_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be set to pass additional options to NASM.
-
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-nim.txt b/sources_non_forked/ale/doc/ale-nim.txt
deleted file mode 100644
index 8985aeb..0000000
--- a/sources_non_forked/ale/doc/ale-nim.txt
+++ /dev/null
@@ -1,45 +0,0 @@
-===============================================================================
-ALE Nim Integration                                           *ale-nim-options*
-
-
-===============================================================================
-nimcheck                                                     *ale-nim-nimcheck*
-
-  ALE does not provide additional configuration options for `nimcheck` at this
-  point.
-
-
-===============================================================================
-nimlsp                                                         *ale-nim-nimlsp*
-
-g:nim_nimlsp_nim_sources                             *g:nim_nimlsp_nim_sources*
-
-  Type: |String|
-  Default: `''`
-
-  Sets the path to Nim source repository as the first argument to `nimlsp`
-  command.
-
-
-===============================================================================
-nimpretty                                                   *ale-nim-nimpretty*
-
-
-g:ale_nim_nimpretty_executable                 *g:ale_nim_nimpretty_executable*
-                                               *b:ale_nim_nimpretty_executable*
-  Type: |String|
-  Default: `'nimpretty'`
-
-  This variable can be changed to use a different executable for nimpretty.
-
-
-g:ale_nim_nimpretty_options                       *g:ale_nim_nimpretty_options*
-                                                  *b:ale_nim_nimpretty_options*
-  Type: |String|
-  Default: `'--maxLineLen:80'`
-
-  This variable can be changed to modify flags given to nimpretty.
-
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-nix.txt b/sources_non_forked/ale/doc/ale-nix.txt
deleted file mode 100644
index 5b2bd6c..0000000
--- a/sources_non_forked/ale/doc/ale-nix.txt
+++ /dev/null
@@ -1,24 +0,0 @@
-===============================================================================
-ALE Nix Integration                                           *ale-nix-options*
-
-
-===============================================================================
-nixpkgs-fmt                                                 *ale-nix-nixpkgs-fmt*
-
-g:ale_nix_nixpkgsfmt_executable                *g:ale_nix_nixpkgsfmt_executable*
-                                               *b:ale_nix_nixpkgsfmt_executable*
-  Type: |String|
-  Default: `'nixpkgs-fmt'`
-
-  This variable sets executable used for nixpkgs-fmt.
-
-g:ale_nix_nixpkgsfmt_options                     *g:ale_nix_nixpkgsfmt_options*
-                                                 *b:ale_nix_nixpkgsfmt_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be set to pass additional options to the nixpkgs-fmt fixer.
-
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-nroff.txt b/sources_non_forked/ale/doc/ale-nroff.txt
deleted file mode 100644
index 62ec789..0000000
--- a/sources_non_forked/ale/doc/ale-nroff.txt
+++ /dev/null
@@ -1,12 +0,0 @@
-===============================================================================
-ALE nroff Integration                                       *ale-nroff-options*
-
-
-===============================================================================
-write-good                                               *ale-nroff-write-good*
-
-See |ale-write-good-options|
-
-
-===============================================================================
-vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-objc.txt b/sources_non_forked/ale/doc/ale-objc.txt
deleted file mode 100644
index 0163175..0000000
--- a/sources_non_forked/ale/doc/ale-objc.txt
+++ /dev/null
@@ -1,73 +0,0 @@
-===============================================================================
-ALE Objective-C Integration                                  *ale-objc-options*
-
-
-===============================================================================
-clang                                                          *ale-objc-clang*
-
-g:ale_objc_clang_options                             *g:ale_objc_clang_options*
-                                                     *b:ale_objc_clang_options*
-  Type: |String|
-  Default: `'-std=c11 -Wall'`
-
-  This variable can be changed to modify flags given to clang.
-
-
-===============================================================================
-clangd                                                        *ale-objc-clangd*
-
-g:ale_objc_clangd_executable                     *g:ale_objc_clangd_executable*
-                                                 *b:ale_objc_clangd_executable*
-  Type: |String|
-  Default: `'clangd'`
-
-  This variable can be changed to use a different executable for clangd.
-
-
-g:ale_objc_clangd_options                           *g:ale_objc_clangd_options*
-                                                    *b:ale_objc_clangd_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be changed to modify flags given to clangd.
-
-
-===============================================================================
-uncrustify                                                *ale-objc-uncrustify*
-
-See |ale-c-uncrustify| for information about the available options.
-
-
-===============================================================================
-ccls                                                            *ale-objc-ccls*
-
-g:ale_objc_ccls_executable                         *g:ale_objc_ccls_executable*
-                                                   *b:ale_objc_ccls_executable*
-  Type: |String|
-  Default: `'ccls'`
-
-  This variable can be changed to use a different executable for ccls.
-
-
-g:ale_objc_ccls_init_options                     *g:ale_objc_ccls_init_options*
-                                                 *b:ale_objc_ccls_init_options*
-  Type: |Dictionary|
-  Default: `{}`
-
-  This variable can be changed to customize ccls initialization options.
-  Example: >
-      {
-    \   'cacheDirectory': '/tmp/ccls',
-    \   'cacheFormat': 'binary',
-    \   'diagnostics': {
-    \     'onOpen': 0,
-    \     'opChange': 1000,
-    \   },
-    \ }
-<
-  Visit https://github.com/MaskRay/ccls/wiki/Initialization-options for all
-  available options and explanations.
-
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-objcpp.txt b/sources_non_forked/ale/doc/ale-objcpp.txt
deleted file mode 100644
index cd65ab7..0000000
--- a/sources_non_forked/ale/doc/ale-objcpp.txt
+++ /dev/null
@@ -1,42 +0,0 @@
-===============================================================================
-ALE Objective-C++ Integration                              *ale-objcpp-options*
-
-
-===============================================================================
-clang                                                        *ale-objcpp-clang*
-
-g:ale_objcpp_clang_options                         *g:ale_objcpp_clang_options*
-                                                   *b:ale_objcpp_clang_options*
-  Type: |String|
-  Default: `'-std=c++14 -Wall'`
-
-  This variable can be changed to modify flags given to clang.
-
-
-===============================================================================
-clangd                                                      *ale-objcpp-clangd*
-
-g:ale_objcpp_clangd_executable                 *g:ale_objcpp_clangd_executable*
-                                               *b:ale_objcpp_clangd_executable*
-  Type: |String|
-  Default: `'clangd'`
-
-  This variable can be changed to use a different executable for clangd.
-
-
-g:ale_objcpp_clangd_options                       *g:ale_objcpp_clangd_options*
-                                                  *b:ale_objcpp_clangd_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be changed to modify flags given to clangd.
-
-
-===============================================================================
-uncrustify                                              *ale-objcpp-uncrustify*
-
-See |ale-c-uncrustify| for information about the available options.
-
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-ocaml.txt b/sources_non_forked/ale/doc/ale-ocaml.txt
deleted file mode 100644
index 8b644c1..0000000
--- a/sources_non_forked/ale/doc/ale-ocaml.txt
+++ /dev/null
@@ -1,82 +0,0 @@
-===============================================================================
-ALE OCaml Integration                                       *ale-ocaml-options*
-
-
-===============================================================================
-merlin                                                       *ale-ocaml-merlin*
-
-  To use merlin linter for OCaml source code you need to make sure Merlin for
-  Vim is correctly configured. See the corresponding Merlin wiki page for
-  detailed instructions
-  (https://github.com/the-lambda-church/merlin/wiki/vim-from-scratch).
-
-===============================================================================
-ols                                                             *ale-ocaml-ols*
-
-  The `ocaml-language-server` is the engine that powers OCaml and ReasonML
-  editor support using the Language Server Protocol. See the installation
-  instructions:
-  https://github.com/freebroccolo/ocaml-language-server#installation
-
-g:ale_ocaml_ols_executable                         *g:ale_ocaml_ols_executable*
-                                                   *b:ale_ocaml_ols_executable*
-  Type: |String|
-  Default: `'ocaml-language-server'`
-
-  This variable can be set to change the executable path for `ols`.
-
-g:ale_ocaml_ols_use_global                         *g:ale_ocaml_ols_use_global*
-                                                   *b:ale_ocaml_ols_use_global*
-  Type: |String|
-  Default: `get(g:, 'ale_use_global_executables', 0)`
-
-  This variable can be set to `1` to always use the globally installed
-  executable. See also |ale-integrations-local-executables|.
-
-===============================================================================
-ocamlformat                                             *ale-ocaml-ocamlformat*
-
-g:ale_ocaml_ocamlformat_executable         *g:ale_ocaml_ocamlformat_executable*
-                                           *b:ale_ocaml_ocamlformat_executable*
-  Type: |String|
-  Default: `'ocamlformat'`
-
-  This variable can be set to pass the path of the ocamlformat fixer.
-
-g:ale_ocaml_ocamlformat_options               *g:ale_ocaml_ocamlformat_options*
-                                              *b:ale_ocaml_ocamlformat_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be set to pass additional options to the ocamlformat fixer.
-
-===============================================================================
-ocp-indent                                               *ale-ocaml-ocp-indent*
-
-g:ale_ocaml_ocp_indent_executable           *g:ale_ocaml_ocp_indent_executable*
-                                            *b:ale_ocaml_ocp_indent_executable*
-  Type: |String|
-  Default: `ocp-indent`
-
-  This variable can be set to pass the path of the ocp-indent.
-
-g:ale_ocaml_ocp_indent_options                 *g:ale_ocaml_ocp_indent_options*
-                                               *b:ale_ocaml_ocp_indent_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be set to pass additional options to the ocp-indent.
-
-g:ale_ocaml_ocp_indent_config                   *g:ale_ocaml_ocp_indent_config*
-                                                *b:ale_ocaml_ocp_indent_config*
-  Type: |String|
-  Default: `''`
-
-  This variable can be set to pass additional config to the ocp-indent.
-  Expand after "--config=".
-
-  "ocp-indent" can also be enabled from ocamlformat config.
-
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-pawn.txt b/sources_non_forked/ale/doc/ale-pawn.txt
deleted file mode 100644
index f836df9..0000000
--- a/sources_non_forked/ale/doc/ale-pawn.txt
+++ /dev/null
@@ -1,12 +0,0 @@
-===============================================================================
-ALE Pawn Integration                                         *ale-pawn-options*
-
-
-===============================================================================
-uncrustify                                                *ale-pawn-uncrustify*
-
-See |ale-c-uncrustify| for information about the available options.
-
-
-===============================================================================
-vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-perl.txt b/sources_non_forked/ale/doc/ale-perl.txt
deleted file mode 100644
index 761c273..0000000
--- a/sources_non_forked/ale/doc/ale-perl.txt
+++ /dev/null
@@ -1,91 +0,0 @@
-===============================================================================
-ALE Perl Integration                                         *ale-perl-options*
-
-ALE offers a few ways to check Perl code. Checking code with `perl` is
-disabled by default, as `perl` code cannot be checked without executing it.
-Specifically, we use the `-c` flag to see if `perl` code compiles. This does
-not execute all of the code in a file, but it does run `BEGIN` and `CHECK`
-blocks. See `perl --help` and https://stackoverflow.com/a/12908487/406224
-
-See |g:ale_linters|.
-
-
-===============================================================================
-perl                                                            *ale-perl-perl*
-
-g:ale_perl_perl_executable                         *g:ale_perl_perl_executable*
-                                                   *b:ale_perl_perl_executable*
-  Type: |String|
-  Default: `'perl'`
-
-  This variable can be changed to modify the executable used for linting perl.
-
-
-g:ale_perl_perl_options                               *g:ale_perl_perl_options*
-                                                      *b:ale_perl_perl_options*
-  Type: |String|
-  Default: `'-c -Mwarnings -Ilib'`
-
-  This variable can be changed to alter the command-line arguments to the perl
-  invocation.
-
-
-===============================================================================
-perlcritic                                                *ale-perl-perlcritic*
-
-g:ale_perl_perlcritic_executable              *g:ale_perl_perlcritic_executable*
-                                              *b:ale_perl_perlcritic_executable*
-  Type: |String|
-  Default: `'perlcritic'`
-
-  This variable can be changed to modify the perlcritic executable used for
-  linting perl.
-
-
-g:ale_perl_perlcritic_profile                    *g:ale_perl_perlcritic_profile*
-                                                 *b:ale_perl_perlcritic_profile*
-  Type: |String|
-  Default: `'.perlcriticrc'`
-
-  This variable can be changed to modify the perlcritic profile used for
-  linting perl.  The current directory is checked for the file, then the
-  parent directory, etc, until it finds one.  If no matching file is found, no
-  profile is passed to perlcritic.
-
-  Set to an empty string to disable passing a specific profile to perlcritic
-  with the `'--profile'` option.
-
-  To prevent perlcritic from using any profile, set this variable to an empty
-  string and pass `'--no-profile'`to perlcritic via the
-  |g:ale_perl_perlcritic_options| variable.
-
-
-g:ale_perl_perlcritic_options                    *g:ale_perl_perlcritic_options*
-                                                 *b:ale_perl_perlcritic_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be changed to supply additional command-line arguments to
-  the perlcritic invocation.
-
-
-g:ale_perl_perlcritic_showrules               *g:ale_perl_perlcritic_showrules*
-
-  Type: |Number|
-  Default: 0
-
-  Controls whether perlcritic rule names are shown after the error message.
-  Defaults to off to reduce length of message.
-===============================================================================
-perltidy                                                    *ale-perl-perltidy*
-
-g:ale_perl_perltidy_options                       *g:ale_perl_perltidy_options*
-                                                  *b:ale_perl_perltidy_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be changed to alter the command-line arguments to
-  the perltidy invocation.
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-perl6.txt b/sources_non_forked/ale/doc/ale-perl6.txt
deleted file mode 100644
index 94953db..0000000
--- a/sources_non_forked/ale/doc/ale-perl6.txt
+++ /dev/null
@@ -1,43 +0,0 @@
-===============================================================================
-ALE Perl6 Integration                                       *ale-perl6-options*
-
-Checking code with `perl6` is disabled by default, as `perl6` code cannot be
-checked without executing it. Specifically, we use the `-c` flag to see if
-`perl6` code compiles. This does not execute all of the code in a file, but it
-does run `BEGIN` and `CHECK` blocks. See `perl6 --help`
-
-Full support requires a perl6 implementation that supports the
-PERL6_EXCEPTIONS_HANDLER environment variable and JSON error output,
-which was specified in 6.d. Rakudo version 2018.08 is the first rakudo release
-that supports this. See `perl6 --version` and
-https://docs.perl6.org/programs/03-environment-variables.
-
-Without this variable, errors and warnings will appear at line 1, and can be
-viewed with ALEDetail. This also serves as a fallback for errors and warnings
-that do not trigger JSON output.
-
-See |g:ale_linters|.
-
-
-===============================================================================
-perl6                                                         *ale-perl6-perl6*
-
-g:ale_perl6_perl6_executable                     *g:ale_perl6_perl6_executable*
-                                                 *b:ale_perl6_perl6_executable*
-  Type: |String|
-  Default: `'perl6'`
-
-  This variable can be changed to modify the executable used for linting
-  perl6.
-
-
-g:ale_perl6_perl6_options                           *g:ale_perl6_perl6_options*
-                                                    *b:ale_perl6_perl6_options*
-  Type: |String|
-  Default: `'-c -Ilib'`
-
-  This variable can be changed to alter the command-line arguments to the
-  perl6 invocation.
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-php.txt b/sources_non_forked/ale/doc/ale-php.txt
deleted file mode 100644
index 645decd..0000000
--- a/sources_non_forked/ale/doc/ale-php.txt
+++ /dev/null
@@ -1,234 +0,0 @@
-===============================================================================
-ALE PHP Integration                                           *ale-php-options*
-
-===============================================================================
-langserver                                                 *ale-php-langserver*
-
-g:ale_php_langserver_executable               *g:ale_php_langserver_executable*
-                                              *b:ale_php_langserver_executable*
-  Type: |String|
-  Default: `'php-language-server.php'`
-
-  The variable can be set to configure the executable that will be used for
-  running the PHP language server. `vendor` directory executables will be
-  preferred instead of this setting if |g:ale_php_langserver_use_global| is `0`.
-
-  See: |ale-integrations-local-executables|
-
-
-g:ale_php_langserver_use_global               *g:ale_php_langserver_use_global*
-                                              *b:ale_php_langserver_use_global*
-  Type: |Number|
-  Default: `get(g:, 'ale_use_global_executables', 0)`
-
-  This variable can be set to `1` to force the language server to be run with
-  the executable set for |g:ale_php_langserver_executable|.
-
-  See: |ale-integrations-local-executables|
-
-
-===============================================================================
-phan                                                             *ale-php-phan*
-
-WARNING: please use the phan_client linter if you have an configuration file
-for your project because the phan will look into your entirely project and
-ale will display in the current buffer warnings that may belong to other file.
-
-g:ale_php_phan_minimum_severity               *g:ale_php_phan_minimum_severity*
-                                              *b:ale_php_phan_minimum_severity*
-  Type: |Number|
-  Default: `0`
-
-  This variable defines the minimum severity level.
-
-g:ale_php_phan_executable                           *g:ale_php_phan_executable*
-                                                    *b:ale_php_phan_executable*
-  Type: |String|
-  Default: `'phan'`
-
-  This variable sets executable used for phan or phan_client.
-
-g:ale_php_phan_use_client                           *g:ale_php_phan_use_client*
-                                                    *b:ale_php_phan_use_client*
-  Type: |Number|
-  Default: `get(g:, 'ale_php_phan_use_client', 0)`
-
-  This variable can be set to 1 to use the phan_client with phan daemon mode
-  instead of the phan standalone.
-
-===============================================================================
-phpcbf                                                         *ale-php-phpcbf*
-
-g:ale_php_phpcbf_executable                       *g:ale_php_phpcbf_executable*
-                                                  *b:ale_php_phpcbf_executable*
-  Type: |String|
-  Default: `'phpcbf'`
-
-  See |ale-integrations-local-executables|
-
-
-g:ale_php_phpcbf_standard                           *g:ale_php_phpcbf_standard*
-                                                    *b:ale_php_phpcbf_standard*
-  Type: |String|
-  Default: `''`
-
-  This variable can be set to specify the coding standard used by phpcbf. If no
-  coding standard is specified, phpcbf will default to fixing against the
-  PEAR coding standard, or the standard you have set as the default.
-
-
-g:ale_php_phpcbf_use_global                       *g:ale_php_phpcbf_use_global*
-                                                  *b:ale_php_phpcbf_use_global*
-  Type: |Number|
-  Default: `get(g:, 'ale_use_global_executables', 0)`
-
-  See |ale-integrations-local-executables|
-
-
-===============================================================================
-phpcs                                                           *ale-php-phpcs*
-
-g:ale_php_phpcs_executable                         *g:ale_php_phpcs_executable*
-                                                   *b:ale_php_phpcs_executable*
-  Type: |String|
-  Default: `'phpcs'`
-
-  See |ale-integrations-local-executables|
-
-
-g:ale_php_phpcs_standard                             *g:ale_php_phpcs_standard*
-                                                     *b:ale_php_phpcs_standard*
-  Type: |String|
-  Default: `''`
-
-  This variable can be set to specify the coding standard used by phpcs. If no
-  coding standard is specified, phpcs will default to checking against the
-  PEAR coding standard, or the standard you have set as the default.
-
-
-g:ale_php_phpcs_use_global                         *g:ale_php_phpcs_use_global*
-                                                   *b:ale_php_phpcs_use_global*
-  Type: |Number|
-  Default: `get(g:, 'ale_use_global_executables', 0)`
-
-  See |ale-integrations-local-executables|
-
-
-g:ale_php_phpcs_options                               *g:ale_php_phpcs_options*
-                                                      *b:ale_php_phpcs_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be set to pass additional options to php-cs
-
-===============================================================================
-phpmd                                                           *ale-php-phpmd*
-
-g:ale_php_phpmd_executable                         *g:ale_php_phpmd_executable*
-                                                   *b:ale_php_phpmd_executable*
-  Type: |String|
-  Default: `'phpmd'`
-
-  This variable sets executable used for phpmd.
-
-
-g:ale_php_phpmd_ruleset                               *g:ale_php_phpmd_ruleset*
-                                                      *b:ale_php_phpmd_ruleset*
-  Type: |String|
-  Default: `'cleancode,codesize,controversial,design,naming,unusedcode'`
-
-  This variable controls the ruleset used by phpmd. Default is to use all of
-  the available phpmd rulesets
-
-
-===============================================================================
-phpstan                                                       *ale-php-phpstan*
-
-g:ale_php_phpstan_executable                     *g:ale_php_phpstan_executable*
-                                                 *b:ale_php_phpstan_executable*
-  Type: |String|
-  Default: `'phpstan'`
-
-  This variable sets executable used for phpstan.
-
-
-g:ale_php_phpstan_level                               *g:ale_php_phpstan_level*
-                                                      *b:ale_php_phpstan_level*
-  Type: |String|
-  Default: `''`
-
-  This variable controls the rule levels. 0 is the loosest and 7 is the
-  strictest. If this option isn't set, the rule level will be controlled by
-  the configuration file. If no configuration file can be detected, `'7'` will
-  be used instead.
-
-
-g:ale_php_phpstan_configuration               *g:ale_php_phpstan_configuration*
-                                              *b:ale_php_phpstan_configuration*
-  Type: |String|
-  Default: `''`
-
-  This variable sets path to phpstan configuration file.
-
-
-g:ale_php_phpstan_autoload                         *g:ale_php_phpstan_autoload*
-                                                   *b:ale_php_phpstan_autoload*
-  Type: |String|
-  Default: `''`
-
-  This variable sets path to phpstan autoload file.
-
-
-===============================================================================
-psalm                                                           *ale-php-psalm*
-
-g:ale_php_psalm_executable                         *g:ale_php_psalm_executable*
-                                                   *b:ale_php_psalm_executable*
-  Type: |String|
-  Default: `'psalm'`
-
-  This variable sets the executable used for psalm.
-
-g:ale_psalm_langserver_options                 *g:ale_psalm_langserver_options*
-                                               *b:ale_psalm_langserver_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be set to pass additional options to psalm.
-
-===============================================================================
-php-cs-fixer                                              *ale-php-php-cs-fixer*
-
-g:ale_php_cs_fixer_executable                    *g:ale_php_cs_fixer_executable*
-                                                 *b:ale_php_cs_fixer_executable*
-  Type: |String|
-  Default: `'php-cs-fixer'`
-
-  This variable sets executable used for php-cs-fixer.
-
-g:ale_php_cs_fixer_use_global                    *g:ale_php_cs_fixer_use_global*
-                                                 *b:ale_php_cs_fixer_use_global*
-  Type: |Boolean|
-  Default: `get(g:, 'ale_use_global_executables', 0)`
-
-  This variable force globally installed fixer.
-
-g:ale_php_cs_fixer_options                          *g:ale_php_cs_fixer_options*
-                                                    *b:ale_php_cs_fixer_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be set to pass additional options to php-cs-fixer.
-
-===============================================================================
-php                                                                *ale-php-php*
-
-g:ale_php_php_executable                              *g:ale_php_php_executable*
-                                                      *b:ale_php_php_executable*
-  Type: |String|
-  Default: `'php'`
-
-  This variable sets the executable used for php.
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-po.txt b/sources_non_forked/ale/doc/ale-po.txt
deleted file mode 100644
index 1e03b7b..0000000
--- a/sources_non_forked/ale/doc/ale-po.txt
+++ /dev/null
@@ -1,12 +0,0 @@
-===============================================================================
-ALE PO Integration                                             *ale-po-options*
-
-
-===============================================================================
-write-good                                                  *ale-po-write-good*
-
-See |ale-write-good-options|
-
-
-===============================================================================
-vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-pod.txt b/sources_non_forked/ale/doc/ale-pod.txt
deleted file mode 100644
index c7cc0bb..0000000
--- a/sources_non_forked/ale/doc/ale-pod.txt
+++ /dev/null
@@ -1,12 +0,0 @@
-===============================================================================
-ALE Pod Integration                                           *ale-pod-options*
-
-
-===============================================================================
-write-good                                                 *ale-pod-write-good*
-
-See |ale-write-good-options|
-
-
-===============================================================================
-vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-pony.txt b/sources_non_forked/ale/doc/ale-pony.txt
deleted file mode 100644
index 3b32168..0000000
--- a/sources_non_forked/ale/doc/ale-pony.txt
+++ /dev/null
@@ -1,25 +0,0 @@
-===============================================================================
-ALE Pony Integration                                         *ale-pony-options*
-
-
-===============================================================================
-ponyc                                                          *ale-pony-ponyc*
-
-g:ale_pony_ponyc_executable                       *g:ale_pony_ponyc_executable*
-                                                  *b:ale_pony_ponyc_executable*
-  Type: |String|
-  Default: `'ponyc'`
-
-  See |ale-integrations-local-executables|
-
-
-g:ale_pony_ponyc_options                             *g:ale_pony_ponyc_options*
-                                                     *b:ale_pony_ponyc_options*
-  Type: |String|
-  Default: `'--pass paint'`
-
-  This variable can be set to pass options to ponyc.
-
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-powershell.txt b/sources_non_forked/ale/doc/ale-powershell.txt
deleted file mode 100644
index c28ef9e..0000000
--- a/sources_non_forked/ale/doc/ale-powershell.txt
+++ /dev/null
@@ -1,77 +0,0 @@
-===============================================================================
-ALE PowerShell Integration                             *ale-powershell-options*
-
-
-===============================================================================
-powershell                                          *ale-powershell-powershell*
-
-g:ale_powershell_powershell_executable  *g:ale_powershell_powershell_executable*
-                                        *b:ale_powershell_powershell_executable*
-  Type: String
-  Default: `'pwsh'`
-
-  This variable can be changed to use a different executable for powershell.
-
->
-  " Use powershell.exe rather than the default pwsh
-  let g:ale_powershell_powershell_executable = 'powershell.exe'
->
-
-===============================================================================
-psscriptanalyzer                              *ale-powershell-psscriptanalyzer*
-
-Installation
--------------------------------------------------------------------------------
-
-Install PSScriptAnalyzer by any means, so long as it can be automatically
-imported in PowerShell.
-Some PowerShell plugins set the filetype of files to `ps1`. To continue using
-these plugins, use the ale_linter_aliases global to alias `ps1` to `powershell`
-
->
-  " Allow ps1 filetype to work with powershell linters
-  let g:ale_linter_aliases = {'ps1': 'powershell'}
-<
-
-g:ale_powershell_psscriptanalyzer_executable
-*g:ale_powershell_psscriptanalyzer_executable*
-                                 *b:ale_powershell_psscriptanalyzer_executable*
-  Type: |String|
-  Default: `'pwsh'`
-
-  This variable sets executable used for powershell.
-  
-  For example, on Windows you could set powershell to be Windows Powershell:
->
-  let g:ale_powershell_psscriptanalyzer_executable = 'powershell.exe'
-<
-
-g:ale_powershell_psscriptanalyzer_module
-*g:ale_powershell_psscriptanalyzer_module*
-                                     *b:ale_powershell_psscriptanalyzer_module*
-  Type: |String
-  Default: `'psscriptanalyzer'`
-
-  This variable sets the name of the psscriptanalyzer module.
-  for psscriptanalyzer invocation.
-
-
-g:ale_powershell_psscriptanalyzer_exclusions 
-*g:ale_powershell_psscriptanalyzer_exclusions*
-                                 *b:ale_powershell_psscriptanalyzer_exclusions*
-  Type: |String|
-  Default: `''`
-
-  Set this variable to exclude test(s) for psscriptanalyzer
-  (-ExcludeRule option).  To exclude more than one option, separate them with
-  commas.
-
->
-  " Suppress Write-Host and Global vars warnings
-  let g:ale_powershell_psscriptanalyzer_exclusions =
-  \  'PSAvoidUsingWriteHost,PSAvoidGlobalVars'
-<
-
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-prolog.txt b/sources_non_forked/ale/doc/ale-prolog.txt
deleted file mode 100644
index 14062a5..0000000
--- a/sources_non_forked/ale/doc/ale-prolog.txt
+++ /dev/null
@@ -1,56 +0,0 @@
-===============================================================================
-ALE Prolog Integration                                     *ale-prolog-options*
-
-
-===============================================================================
-swipl                                                        *ale-prolog-swipl*
-
-g:ale_prolog_swipl_executable                   *g:ale_prolog_swipl_executable*
-                                                *b:ale_prolog_swipl_executable*
-  Type: |String|
-  Default: `'swipl'`
-
-  The executable that will be run for the `swipl` linter.
-
-g:ale_prolog_swipl_load                               *g:ale_prolog_swipl_load*
-                                                      *b:ale_prolog_swipl_load*
-  Type: |String|
-  Default: `'current_prolog_flag(argv, [File]), load_files(File, [sandboxed(true)]), halt.'`
-
-  The prolog goals that will be passed to |g:ale_prolog_swipl_executable| with `-g` option.
-
-  It does:
-  1. Takes the first command argument (current file path)
-  2. Checks (syntactic / semantic) problems and output to stderr
-
-  NOTE: `sandboxed(true)` prohibits executing some directives such as 'initialization main'.
-
-g:ale_prolog_swipl_timeout                         *g:ale_prolog_swipl_timeout*
-                                                   *b:ale_prolog_swipl_timeout*
-  Type: |Number|
-  Default: `3`
-
-  Timeout seconds to detect long-running linter.
-  It is done by setting SIGALRM.
-  See |g:ale_prolog_swipl_alarm| and |g:ale_prolog_swipl_alarm_handler|.
-
-g:ale_prolog_swipl_alarm                             *g:ale_prolog_swipl_alarm*
-                                                     *b:ale_prolog_swipl_alarm*
-  Type: |String|
-  Default: `'alarm(%t, (%h), _, [])'`
-
-  The prolog goals to be expected to set SIGALRM.
-  `%t` is replaced by |g:ale_prolog_swipl_timeout|.
-  `%h` is replaced by |g:ale_prolog_swipl_alarm_handler|.
-
-g:ale_prolog_swipl_alarm_handler             *g:ale_prolog_swipl_alarm_handler*
-                                             *b:ale_prolog_swipl_alarm_handler*
-  Type: |String|
-  Default: `'writeln(user_error, "ERROR: Exceeded %t seconds, Please change g:prolog_swipl_timeout to modify the limit."), halt(1)'`
-
-  The prolog goals to be expected that will be run on SIGALRM.
-  `%t` is replaced by |g:ale_prolog_swipl_timeout|.
-
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-proto.txt b/sources_non_forked/ale/doc/ale-proto.txt
deleted file mode 100644
index 734e23d..0000000
--- a/sources_non_forked/ale/doc/ale-proto.txt
+++ /dev/null
@@ -1,33 +0,0 @@
-===============================================================================
-ALE Proto Integration                                         *ale-proto-options*
-
-
-===============================================================================
-Integration Information
-
-Linting of `.proto` files requires that the `protoc` binary is installed in the
-system path and that the `protoc-gen-lint` plugin for the `protoc` binary is also
-installed.
-
-To enable `.proto` file linting, update |g:ale_linters| as appropriate:
->
-  " Enable linter for .proto files
-  let g:ale_linters = {'proto': ['protoc-gen-lint']}
-<
-===============================================================================
-protoc-gen-lint                                      *ale-proto-protoc-gen-lint*
-
-  The linter is a plugin for the `protoc` binary. As long as the binary resides
-  in the system path, `protoc` will find it.
-
-g:ale_proto_protoc_gen_lint_options       *g:ale_proto_protoc_gen_lint_options*
-
-  Type: |String|
-  Default: `''`
-
-  This variable can be changed to modify flags given to protoc. Note that the
-  directory of the linted file is always passed as an include path with '-I'
-  before any user-supplied options.
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-pug.txt b/sources_non_forked/ale/doc/ale-pug.txt
deleted file mode 100644
index e2836f8..0000000
--- a/sources_non_forked/ale/doc/ale-pug.txt
+++ /dev/null
@@ -1,44 +0,0 @@
-===============================================================================
-ALE Pug Integration                                           *ale-pug-options*
-
-
-===============================================================================
-puglint                                                       *ale-pug-puglint*
-
-The puglint linter will detect configuration files based on the path to the
-filename automatically. Configuration files will be loaded in this order:
-
-1. `.pug-lintrc`
-2. `.pug-lintrc.js`
-3. `.pug-lintrc.json`
-4. `package.json`
-
-You might need to create a configuration file for your project to get
-meaningful results.
-
-g:ale_pug_puglint_executable                     *g:ale_pug_puglint_executable*
-                                                 *b:ale_pug_puglint_executable*
-  Type: |String|
-  Default: `'pug-lint'`
-
-  See |ale-integrations-local-executables|
-
-
-g:ale_pug_puglint_options                           *g:ale_pug_puglint_options*
-                                                    *b:ale_pug_puglint_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be set to pass additional options to pug-lint.
-
-
-g:ale_pug_puglint_use_global                     *g:ale_pug_puglint_use_global*
-                                                 *b:ale_pug_puglint_use_global*
-  Type: |Number|
-  Default: `get(g:, 'ale_use_global_executables', 0)`
-
-  See |ale-integrations-local-executables|
-
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-puppet.txt b/sources_non_forked/ale/doc/ale-puppet.txt
deleted file mode 100644
index daa8c10..0000000
--- a/sources_non_forked/ale/doc/ale-puppet.txt
+++ /dev/null
@@ -1,57 +0,0 @@
-===============================================================================
-ALE Puppet Integration                                     *ale-puppet-options*
-
-
-===============================================================================
-puppet                                                      *ale-puppet-puppet*
-
-g:ale_puppet_puppet_executable                 *g:ale_puppet_puppet_executable*
-                                               *b:ale_puppet_puppet_executable*
-  Type: |String|
-  Default: `'puppet'`
-
-  This variable can be changed to specify the executable used for puppet.
-
-
-g:ale_puppet_puppet_options                       *g:ale_puppet_puppet_options*
-                                                  *b:ale_puppet_puppet_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be changed to add command-line arguments to the
-  puppet parser validate invocation.
-
-
-===============================================================================
-puppetlint                                              *ale-puppet-puppetlint*
-
-g:ale_puppet_puppetlint_executable         *g:ale_puppet_puppetlint_executable*
-                                           *b:ale_puppet_puppetlint_executable*
-  Type: |String|
-  Default: `'puppet-lint'`
-
-  This variable can be changed to specify the executable used for puppet-lint.
-
-
-g:ale_puppet_puppetlint_options               *g:ale_puppet_puppetlint_options*
-                                              *b:ale_puppet_puppetlint_options*
-  Type: |String|
-  Default: `'--no-autoloader_layout-check'`
-
-  This variable can be changed to add command-line arguments to the
-  puppet-lint invocation.
-
-
-===============================================================================
-puppet-languageserver                               *ale-puppet-languageserver*
-
-g:ale_puppet_languageserver_executable  *g:ale_puppet_languageserver_executable*
-                                        *b:ale_puppet_languageserver_executable*
-  type: |String|
-  Default: `'puppet-languageserver'`
-
-  This variable can be used to specify the executable used for
-  puppet-languageserver.
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-purescript.txt b/sources_non_forked/ale/doc/ale-purescript.txt
deleted file mode 100644
index e809f2c..0000000
--- a/sources_non_forked/ale/doc/ale-purescript.txt
+++ /dev/null
@@ -1,42 +0,0 @@
-===============================================================================
-ALE PureScript Integration                             *ale-purescript-options*
-
-
-===============================================================================
-purescript-language-server                     *ale-purescript-language-server*
-
-PureScript Language Server
-  (https://github.com/nwolverson/purescript-language-server)
-
-g:ale_purescript_ls_executable                 g:ale_purescript_ls_executable
-                                               b:ale_purescript_ls_executable
-  Type: |String|
-  Default: `'purescript-language-server'`
-
-  PureScript language server executable.
-
-g:ale_purescript_ls_config                         g:ale_purescript_ls_config
-                                                   b:ale_purescript_ls_config
-  Type: |Dictionary|
-  Default: `{}`
-
-  Dictionary containing configuration settings that will be passed to the
-  language server. For example, with a spago project:
-		{
-		\  'purescript': {
-		\    'addSpagoSources': v:true,
-		\    'addNpmPath': v:true,
-		\    'buildCommand': 'spago build -- --json-errors'
-		\  }
-		\}
-===============================================================================
-purty                                                    *ale-purescript-purty*
-
-g:ale_purescript_purty_executable           *g:ale_purescript_purty_executable*
-                                            *b:ale_purescript_purty_executable*
-  Type: |String|
-  Default: `'purty'`
-
-  This variable can be changed to use a different executable for purty.
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-pyrex.txt b/sources_non_forked/ale/doc/ale-pyrex.txt
deleted file mode 100644
index 245e611..0000000
--- a/sources_non_forked/ale/doc/ale-pyrex.txt
+++ /dev/null
@@ -1,25 +0,0 @@
-===============================================================================
-ALE Pyrex (Cython) Integration                              *ale-pyrex-options*
-
-
-===============================================================================
-cython                                                       *ale-pyrex-cython*
-
-g:ale_pyrex_cython_executable                   *g:ale_pyrex_cython_executable*
-                                                *b:ale_pyrex_cython_executable*
-  Type: |String|
-  Default: `'cython'`
-
-  This variable can be changed to use a different executable for cython.
-
-
-g:ale_pyrex_cython_options                         *g:ale_pyrex_cython_options*
-                                                   *b:ale_pyrex_cython_options*
-  Type: |String|
-  Default: `'--warning-extra --warning-errors'`
-
-  This variable can be changed to modify flags given to cython.
-
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-python.txt b/sources_non_forked/ale/doc/ale-python.txt
deleted file mode 100644
index 93f1d66..0000000
--- a/sources_non_forked/ale/doc/ale-python.txt
+++ /dev/null
@@ -1,774 +0,0 @@
-===============================================================================
-ALE Python Integration                                     *ale-python-options*
-
-
-g:ale_python_auto_pipenv                             *g:ale_python_auto_pipenv*
-                                                     *b:ale_python_auto_pipenv*
-  Type: |Number|
-  Default: `0`
-
-  Detect whether the file is inside a pipenv, and set the executable to `pipenv`
-  if true. This is overridden by a manually-set executable.
-
-===============================================================================
-ALE Python Project Root Behavior                              *ale-python-root*
-
-For some linters, ALE will search for a Python project root by looking at the
-files in directories on or above where a file being checked is. ALE applies
-the following methods, in order:
-
-1. Find the first directory containing a common Python configuration file.
-2. If no configuration file can be found, use the first directory which does
-   not contain a readable file named `__init__.py`.
-
-ALE will look for configuration files with the following filenames. >
-
-  MANIFEST.in
-  setup.cfg
-  pytest.ini
-  tox.ini
-  mypy.ini
-  pycodestyle.cfg
-  .flake8
-  .flake8rc
-  pylama.ini
-  pylintrc
-  .pylintrc
-  Pipfile
-  Pipfile.lock
-<
-
-The first directory containing any of the files named above will be used.
-
-
-===============================================================================
-autopep8                                                  *ale-python-autopep8*
-
-g:ale_python_autopep8_executable             *g:ale_python_autopep8_executable*
-                                             *b:ale_python_autopep8_executable*
-  Type: |String|
-  Default: `'autopep8'`
-
-  See |ale-integrations-local-executables|
-
-
-g:ale_python_autopep8_options                   *g:ale_python_autopep8_options*
-                                                *b:ale_python_autopep8_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be set to pass extra options to autopep8.
-
-
-g:ale_python_autopep8_use_global             *g:ale_python_autopep8_use_global*
-                                             *b:ale_python_autopep8_use_global*
-  Type: |Number|
-  Default: `get(g:, 'ale_use_global_executables', 0)`
-
-  See |ale-integrations-local-executables|
-
-
-===============================================================================
-bandit                                                      *ale-python-bandit*
-
-g:ale_python_bandit_executable                 *g:ale_python_bandit_executable*
-                                               *b:ale_python_bandit_executable*
-  Type: |String|
-  Default: `'bandit'`
-
-  See |ale-integrations-local-executables|
-
-  Set this to `'pipenv'` to invoke `'pipenv` `run` `bandit'`.
-
-
-g:ale_python_bandit_options                       *g:ale_python_bandit_options*
-                                                  *b:ale_python_bandit_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be changed to add command-line arguments to the
-  bandit invocation.
-
-
-g:ale_python_bandit_use_config                 *g:ale_python_bandit_use_config*
-                                               *b:ale_python_bandit_use_config*
-  Type: |Number|
-  Default: `1`
-
-  If this variable is true and a `.bandit` file exists in the directory of the
-  file being checked or a parent directory, an `--ini` option is added to the
-  `bandit` command for the nearest `.bandit` file.  Set this variable false to
-  disable adding the `--ini` option automatically.
-
-
-g:ale_python_bandit_use_global                 *g:ale_python_bandit_use_global*
-                                               *b:ale_python_bandit_use_global*
-  Type: |Number|
-  Default: `get(g:, 'ale_use_global_executables', 0)`
-
-  See |ale-integrations-local-executables|
-
-
-g:ale_python_bandit_auto_pipenv               *g:ale_python_bandit_auto_pipenv*
-                                              *b:ale_python_bandit_auto_pipenv*
-  Type: |Number|
-  Default: `0`
-
-  Detect whether the file is inside a pipenv, and set the executable to `pipenv`
-  if true. This is overridden by a manually-set executable.
-
-
-===============================================================================
-black                                                        *ale-python-black*
-
-g:ale_python_black_executable                   *g:ale_python_black_executable*
-                                                *b:ale_python_black_executable*
-  Type: |String|
-  Default: `'black'`
-
-  See |ale-integrations-local-executables|
-
-
-g:ale_python_black_options                         *g:ale_python_black_options*
-                                                   *b:ale_python_black_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be set to pass extra options to black.
-
-
-g:ale_python_black_use_global                   *g:ale_python_black_use_global*
-                                                *b:ale_python_black_use_global*
-  Type: |Number|
-  Default: `get(g:, 'ale_use_global_executables', 0)`
-
-  See |ale-integrations-local-executables|
-
-
-g:ale_python_black_auto_pipenv                 *g:ale_python_black_auto_pipenv*
-                                               *b:ale_python_black_auto_pipenv*
-  Type: |Number|
-  Default: `0`
-
-  Detect whether the file is inside a pipenv, and set the executable to `pipenv`
-  if true. This is overridden by a manually-set executable.
-
-g:ale_python_black_change_directory       *g:ale_python_black_change_directory*
-                                          *b:ale_python_black_change_directory*
-  Type: |Number|
-  Default: `1`
-
-  If set to `1`, ALE will switch to the directory the Python file being
-  checked with `black` is in before checking it. This helps `black` find
-  configuration files more easily. This option can be turned off if you want
-  to control the directory Python is executed from yourself.
-
-
-===============================================================================
-flake8                                                      *ale-python-flake8*
-
-g:ale_python_flake8_change_directory     *g:ale_python_flake8_change_directory*
-                                         *b:ale_python_flake8_change_directory*
-  Type: |Number|
-  Default: `1`
-
-  If set to `1`, ALE will switch to the directory the Python file being
-  checked with `flake8` is in before checking it. This helps `flake8` find
-  configuration files more easily. This option can be turned off if you want
-  to control the directory Python is executed from yourself.
-
-
-g:ale_python_flake8_executable                 *g:ale_python_flake8_executable*
-                                               *b:ale_python_flake8_executable*
-  Type: |String|
-  Default: `'flake8'`
-
-  This variable can be changed to modify the executable used for flake8. Set
-  this to `'pipenv'` to invoke `'pipenv` `run` `flake8'`.
-
-
-g:ale_python_flake8_options                       *g:ale_python_flake8_options*
-                                                  *b:ale_python_flake8_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be changed to add command-line arguments to the flake8
-  invocation.
-
-  For example, to dynamically switch between programs targeting Python 2 and
-  Python 3, you may want to set >
-
-  let g:ale_python_flake8_executable = 'python3'   " or 'python' for Python 2
-  let g:ale_python_flake8_options = '-m flake8'
-<
-  after making sure it's installed for the appropriate Python versions (e.g.
-  `python3 -m pip install --user flake8`).
-
-
-g:ale_python_flake8_use_global                 *g:ale_python_flake8_use_global*
-                                               *b:ale_python_flake8_use_global*
-  Type: |Number|
-  Default: `get(g:, 'ale_use_global_executables', 0)`
-
-  This variable controls whether or not ALE will search for flake8 in a
-  virtualenv directory first. If this variable is set to `1`, then ALE will
-  always use |g:ale_python_flake8_executable| for the executable path.
-
-  Both variables can be set with `b:` buffer variables instead.
-
-
-g:ale_python_flake8_auto_pipenv               *g:ale_python_flake8_auto_pipenv*
-                                              *b:ale_python_flake8_auto_pipenv*
-  Type: |Number|
-  Default: `0`
-
-  Detect whether the file is inside a pipenv, and set the executable to `pipenv`
-  if true. This is overridden by a manually-set executable.
-
-
-===============================================================================
-isort                                                        *ale-python-isort*
-
-g:ale_python_isort_executable                   *g:ale_python_isort_executable*
-                                                *b:ale_python_isort_executable*
-  Type: |String|
-  Default: `'isort'`
-
-  See |ale-integrations-local-executables|
-
-
-g:ale_python_isort_options                         *g:ale_python_isort_options*
-                                                   *b:ale_python_isort_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be set to pass extra options to isort.
-
-
-g:ale_python_isort_use_global                   *g:ale_python_isort_use_global*
-                                                *b:ale_python_isort_use_global*
-  Type: |Number|
-  Default: `get(g:, 'ale_use_global_executables', 0)`
-
-  See |ale-integrations-local-executables|
-
-
-===============================================================================
-mypy                                                          *ale-python-mypy*
-
-The minimum supported version of mypy that ALE supports is v0.4.4. This is
-the first version containing the `--shadow-file` option ALE needs to be able
-to check for errors while you type.
-
-`mypy` will be run from a detected project root, per |ale-python-root|.
-
-
-g:ale_python_mypy_auto_pipenv                   *g:ale_python_mypy_auto_pipenv*
-                                                *b:ale_python_mypy_auto_pipenv*
-  Type: |Number|
-  Default: `0`
-
-  Detect whether the file is inside a pipenv, and set the executable to `pipenv`
-  if true. This is overridden by a manually-set executable.
-
-
-g:ale_python_mypy_executable                     *g:ale_python_mypy_executable*
-                                                 *b:ale_python_mypy_executable*
-  Type: |String|
-  Default: `'mypy'`
-
-  See |ale-integrations-local-executables|
-
-  Set this to `'pipenv'` to invoke `'pipenv` `run` `mypy'`.
-
-
-g:ale_python_mypy_ignore_invalid_syntax
-                                      *g:ale_python_mypy_ignore_invalid_syntax*
-                                      *b:ale_python_mypy_ignore_invalid_syntax*
-  Type: |Number|
-  Default: `0`
-
-  When set to `1`, syntax error messages for mypy will be ignored. This option
-  can be used when running other Python linters which check for syntax errors,
-  as mypy can take a while to finish executing.
-
-
-g:ale_python_mypy_options                           *g:ale_python_mypy_options*
-                                                    *b:ale_python_mypy_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be changed to add command-line arguments to the mypy
-  invocation.
-
-
-g:ale_python_mypy_show_notes                     *g:ale_python_mypy_show_notes*
-                                                 *b:ale_python_mypy_show_notes*
-  Type: |Number|
-  Default: `1`
-
-  If enabled, notes on lines will be displayed as 'I' (info) messages.
-
-
-g:ale_python_mypy_use_global                     *g:ale_python_mypy_use_global*
-                                                 *b:ale_python_mypy_use_global*
-  Type: |Number|
-  Default: `get(g:, 'ale_use_global_executables', 0)`
-
-  See |ale-integrations-local-executables|
-
-
-
-===============================================================================
-prospector                                              *ale-python-prospector*
-
-g:ale_python_prospector_executable         *g:ale_python_prospector_executable*
-                                           *b:ale_python_prospector_executable*
-  Type: |String|
-  Default: `'prospector'`
-
-  See |ale-integrations-local-executables|
-
-  Set this to `'pipenv'` to invoke `'pipenv` `run` `prospector'`.
-
-
-g:ale_python_prospector_options               *g:ale_python_prospector_options*
-                                              *b:ale_python_prospector_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be changed to add command-line arguments to the prospector
-  invocation.
-
-  For example, to dynamically switch between programs targeting Python 2 and
-  Python 3, you may want to set >
-
-  let g:ale_python_prospector_executable = 'python3'
-  " or 'python' for Python 2
-  let g:ale_python_prospector_options = '--rcfile /path/to/.prospector.yaml'
-  " The virtualenv detection needs to be disabled.
-  let g:ale_python_prospector_use_global = 0
-
-  after making sure it's installed for the appropriate Python versions (e.g.
-  `python3 -m pip install --user prospector`).
-
-
-g:ale_python_prospector_use_global         *g:ale_python_prospector_use_global*
-                                           *b:ale_python_prospector_use_global*
-  Type: |Number|
-  Default: `get(g:, 'ale_use_global_executables', 0)`
-
-  See |ale-integrations-local-executables|
-
-
-g:ale_python_prospector_auto_pipenv       *g:ale_python_prospector_auto_pipenv*
-                                          *b:ale_python_prospector_auto_pipenv*
-  Type: |Number|
-  Default: `0`
-
-  Detect whether the file is inside a pipenv, and set the executable to `pipenv`
-  if true. This is overridden by a manually-set executable.
-
-
-===============================================================================
-pycodestyle                                            *ale-python-pycodestyle*
-
-
-g:ale_python_pycodestyle_executable       *g:ale_python_pycodestyle_executable*
-                                          *b:ale_python_pycodestyle_executable*
-  Type: |String|
-  Default: `'pycodestyle'`
-
-  See |ale-integrations-local-executables|
-
-  Set this to `'pipenv'` to invoke `'pipenv` `run` `pycodestyle'`.
-
-
-g:ale_python_pycodestyle_options             *g:ale_python_pycodestyle_options*
-                                             *b:ale_python_pycodestyle_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be changed to add command-line arguments to the
-  pycodestyle invocation.
-
-
-g:ale_python_pycodestyle_use_global       *g:ale_python_pycodestyle_use_global*
-                                          *b:ale_python_pycodestyle_use_global*
-  Type: |Number|
-  Default: `get(g:, 'ale_use_global_executables', 0)`
-
-  See |ale-integrations-local-executables|
-
-
-g:ale_python_pycodestyle_auto_pipenv     *g:ale_python_pycodestyle_auto_pipenv*
-                                         *b:ale_python_pycodestyle_auto_pipenv*
-  Type: |Number|
-  Default: `0`
-
-  Detect whether the file is inside a pipenv, and set the executable to `pipenv`
-  if true. This is overridden by a manually-set executable.
-
-
-===============================================================================
-pydocstyle                                              *ale-python-pydocstyle*
-
-
-g:ale_python_pydocstyle_executable         *g:ale_python_pydocstyle_executable*
-                                           *b:ale_python_pydocstyle_executable*
-  Type: |String|
-  Default: `'pydocstyle'`
-
-  See |ale-integrations-local-executables|
-
-  Set this to `'pipenv'` to invoke `'pipenv` `run` `pydocstyle'`.
-
-
-g:ale_python_pydocstyle_options               *g:ale_python_pydocstyle_options*
-                                              *b:ale_python_pydocstyle_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be changed to add command-line arguments to the
-  pydocstyle invocation.
-
-
-g:ale_python_pydocstyle_use_global         *g:ale_python_pydocstyle_use_global*
-                                           *b:ale_python_pydocstyle_use_global*
-  Type: |Number|
-  Default: `get(g:, 'ale_use_global_executables', 0)`
-
-  See |ale-integrations-local-executables|
-
-
-g:ale_python_pydocstyle_auto_pipenv       *g:ale_python_pydocstyle_auto_pipenv*
-                                          *b:ale_python_pydocstyle_auto_pipenv*
-  Type: |Number|
-  Default: `0`
-
-  Detect whether the file is inside a pipenv, and set the executable to `pipenv`
-  if true. This is overridden by a manually-set executable.
-
-
-===============================================================================
-pyflakes                                                  *ale-python-pyflakes*
-
-
-g:ale_python_pyflakes_executable             *g:ale_python_pyflakes_executable*
-                                             *b:ale_python_pyflakes_executable*
-  Type: |String|
-  Default: `'pyflakes'`
-
-  See |ale-integrations-local-executables|
-
-  Set this to `'pipenv'` to invoke `'pipenv` `run` `pyflakes'`.
-
-
-g:ale_python_pyflakes_auto_pipenv           *g:ale_python_pyflakes_auto_pipenv*
-                                            *b:ale_python_pyflakes_auto_pipenv*
-  Type: |Number|
-  Default: `0`
-
-  Detect whether the file is inside a pipenv, and set the executable to `pipenv`
-  if true. This is overridden by a manually-set executable.
-
-
-===============================================================================
-pylama                                                      *ale-python-pylama*
-
-g:ale_python_pylama_change_directory     *g:ale_python_pylama_change_directory*
-                                         *b:ale_python_pylama_change_directory*
-  Type: |Number|
-  Default: `1`
-
-  If set to `1`, `pylama` will be run from a detected project root, per
-  |ale-python-root|.  This is useful because `pylama` only searches for
-  configuration files in its current directory and applies file masks using
-  paths relative to its current directory.  This option can be turned off if
-  you want to control the directory in which `pylama` is executed.
-
-
-g:ale_python_pylama_executable                 *g:ale_python_pylama_executable*
-                                               *b:ale_python_pylama_executable*
-  Type: |String|
-  Default: `'pylama'`
-
-  This variable can be changed to modify the executable used for pylama. Set
-  this to `'pipenv'` to invoke `'pipenv` `run` `pylama'`.
-
-
-g:ale_python_pylama_options                       *g:ale_python_pylama_options*
-                                                  *b:ale_python_pylama_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be changed to add command-line arguments to the pylama
-  invocation.
-
-
-g:ale_python_pylama_use_global                 *g:ale_python_pylama_use_global*
-                                               *b:ale_python_pylama_use_global*
-  Type: |Number|
-  Default: `get(g:, 'ale_use_global_executables', 0)`
-
-  This variable controls whether or not ALE will search for pylama in a
-  virtualenv directory first. If this variable is set to `1`, then ALE will
-  always use |g:ale_python_pylama_executable| for the executable path.
-
-  Both variables can be set with `b:` buffer variables instead.
-
-
-g:ale_python_pylama_auto_pipenv               *g:ale_python_pylama_auto_pipenv*
-                                              *b:ale_python_pylama_auto_pipenv*
-  Type: |Number|
-  Default: `0`
-
-  Detect whether the file is inside a pipenv, and set the executable to `pipenv`
-  if true. This is overridden by a manually-set executable.
-
-
-===============================================================================
-pylint                                                      *ale-python-pylint*
-
-g:ale_python_pylint_change_directory     *g:ale_python_pylint_change_directory*
-                                         *b:ale_python_pylint_change_directory*
-  Type: |Number|
-  Default: `1`
-
-  If set to `1`, `pylint` will be run from a detected project root, per
-  |ale-python-root|.  Since `pylint` only checks for `pylintrc` in the packages
-  above its current directory before falling back to user and global `pylintrc`
-  files, this is necessary for `pylint` to use a project `pylintrc` file, if
-  present.  This option can be turned off if you want to control the directory
-  Python is executed from yourself.
-
-
-g:ale_python_pylint_executable                 *g:ale_python_pylint_executable*
-                                               *b:ale_python_pylint_executable*
-  Type: |String|
-  Default: `'pylint'`
-
-  See |ale-integrations-local-executables|
-
-  Set this to `'pipenv'` to invoke `'pipenv` `run` `pylint'`.
-
-
-g:ale_python_pylint_options                       *g:ale_python_pylint_options*
-                                                  *b:ale_python_pylint_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be changed to add command-line arguments to the pylint
-  invocation.
-
-  For example, to dynamically switch between programs targeting Python 2 and
-  Python 3, you may want to set >
-
-  let g:ale_python_pylint_executable = 'python3'   " or 'python' for Python 2
-  let g:ale_python_pylint_options = '--rcfile /path/to/pylint.rc'
-  " The virtualenv detection needs to be disabled.
-  let g:ale_python_pylint_use_global = 0
-
-  after making sure it's installed for the appropriate Python versions (e.g.
-  `python3 -m pip install --user pylint`).
-
-
-g:ale_python_pylint_use_global                 *g:ale_python_pylint_use_global*
-                                               *b:ale_python_pylint_use_global*
-  Type: |Number|
-  Default: `get(g:, 'ale_use_global_executables', 0)`
-
-  See |ale-integrations-local-executables|
-
-
-g:ale_python_pylint_auto_pipenv               *g:ale_python_pylint_auto_pipenv*
-                                              *b:ale_python_pylint_auto_pipenv*
-  Type: |Number|
-  Default: `0`
-
-  Detect whether the file is inside a pipenv, and set the executable to `pipenv`
-  if true. This is overridden by a manually-set executable.
-
-
-g:ale_python_pylint_use_msg_id                 *g:ale_python_pylint_use_msg_id*
-                                               *b:ale_python_pylint_use_msg_id*
-  Type: |Number|
-  Default: `0`
-
-  Use message for output (e.g. I0011) instead of symbolic name of the message
-  (e.g. locally-disabled).
-
-===============================================================================
-pyls                                                          *ale-python-pyls*
-
-`pyls` will be run from a detected project root, per |ale-python-root|.
-
-
-g:ale_python_pyls_executable                     *g:ale_python_pyls_executable*
-                                                 *b:ale_python_pyls_executable*
-  Type: |String|
-  Default: `'pyls'`
-
-  See |ale-integrations-local-executables|
-
-  Set this to `'pipenv'` to invoke `'pipenv` `run` `pyls'`.
-
-
-g:ale_python_pyls_use_global                     *g:ale_python_pyls_use_global*
-                                                 *b:ale_python_pyls_use_global*
-  Type: |Number|
-  Default: `get(g:, 'ale_use_global_executables', 0)`
-
-  See |ale-integrations-local-executables|
-
-
-g:ale_python_pyls_auto_pipenv                   *g:ale_python_pyls_auto_pipenv*
-                                                *b:ale_python_pyls_auto_pipenv*
-  Type: |Number|
-  Default: `0`
-
-  Detect whether the file is inside a pipenv, and set the executable to `pipenv`
-  if true. This is overridden by a manually-set executable.
-
-
-g:ale_python_pyls_config                             *g:ale_python_pyls_config*
-                                                     *b:ale_python_pyls_config*
-  Type: |Dictionary|
-  Default: `{}`
-
-  Dictionary with configuration settings for pyls. For example, to disable
-  the pycodestyle linter: >
-        {
-      \   'pyls': {
-      \     'plugins': {
-      \       'pycodestyle': {
-      \         'enabled': v:false
-      \       }
-      \     }
-      \   },
-      \ }
-<
-
-===============================================================================
-pyre                                                          *ale-python-pyre*
-
-`pyre` will be run from a detected project root, per |ale-python-root|.
-
-
-g:ale_python_pyre_executable                     *g:ale_python_pyre_executable*
-                                                 *b:ale_python_pyre_executable*
-  Type: |String|
-  Default: `'pyre'`
-
-  See |ale-integrations-local-executables|
-
-  Set this to `'pipenv'` to invoke `'pipenv` `run` `pyre'`.
-
-
-g:ale_python_pyre_use_global                     *g:ale_python_pyre_use_global*
-                                                 *b:ale_python_pyre_use_global*
-  Type: |Number|
-  Default: `get(g:, 'ale_use_global_executables', 0)`
-
-  See |ale-integrations-local-executables|
-
-
-g:ale_python_pyre_auto_pipenv                   *g:ale_python_pyre_auto_pipenv*
-                                                *b:ale_python_pyre_auto_pipenv*
-  Type: |Number|
-  Default: `0`
-
-  Detect whether the file is inside a pipenv, and set the executable to `pipenv`
-  if true. This is overridden by a manually-set executable.
-
-
-===============================================================================
-reorder-python-imports                      *ale-python-reorder_python_imports*
-
-g:ale_python_reorder_python_imports_executable
-                               *g:ale_python_reorder_python_imports_executable*
-                               *b:ale_python_reorder_python_imports_executable*
-  Type: |String|
-  Default: `'reorder-python-imports'`
-
-  See |ale-integrations-local-executables|
-
-
-g:ale_python_reorder_python_imports_options
-                                  *g:ale_python_reorder_python_imports_options*
-                                  *b:ale_python_reorder_python_imports_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be set to pass extra options to reorder-python-imports.
-
-
-g:ale_python_reorder_python_imports_use_global
-                               *g:ale_python_reorder_python_imports_use_global*
-                               *b:ale_python_reorder_python_imports_use_global*
-  Type: |Number|
-  Default: `get(g:, 'ale_use_global_executables', 0)`
-
-  See |ale-integrations-local-executables|
-
-
-===============================================================================
-vulture                                                    *ale-python-vulture*
-
-g:ale_python_vulture_change_directory   *g:ale_python_vulture_change_directory*
-                                        *b:ale_python_vulture_change_directory*
-  Type: |Number|
-  Default: `1`
-
-  If set to `1`, ALE will switch to the directory the Python file being
-  checked with `vulture` is in before checking it and check the whole project
-  directory instead of checking only the file opened in the current buffer.
-  This helps `vulture` to know the context and avoid false-negative results.
-
-
-g:ale_python_vulture_executable               *g:ale_python_vulture_executable*
-                                              *b:ale_python_vulture_executable*
-  Type: |String|
-  Default: `'vulture'`
-
-  See |ale-integrations-local-executables|
-
-
-g:ale_python_vulture_options                     *g:ale_python_vulture_options*
-                                                 *b:ale_python_vulture_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be changed to add command-line arguments to the vulture
-  invocation.
-
-
-g:ale_python_vulture_use_global               *g:ale_python_vulture_use_global*
-                                              *b:ale_python_vulture_use_global*
-  Type: |Number|
-  Default: `get(g:, 'ale_use_global_executables', 0)`
-
-  See |ale-integrations-local-executables|
-
-
-===============================================================================
-yapf                                                          *ale-python-yapf*
-
-g:ale_python_yapf_executable                     *g:ale_python_yapf_executable*
-                                                 *b:ale_python_yapf_executable*
-  Type: |String|
-  Default: `'yapf'`
-
-  See |ale-integrations-local-executables|
-
-
-g:ale_python_yapf_use_global                     *g:ale_python_yapf_use_global*
-                                                 *b:ale_python_yapf_use_global*
-  Type: |Number|
-  Default: `get(g:, 'ale_use_global_executables', 0)`
-
-  See |ale-integrations-local-executables|
-
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-qml.txt b/sources_non_forked/ale/doc/ale-qml.txt
deleted file mode 100644
index f6d715a..0000000
--- a/sources_non_forked/ale/doc/ale-qml.txt
+++ /dev/null
@@ -1,18 +0,0 @@
-===============================================================================
-ALE QML Integration                                           *ale-qml-options*
-
-
-===============================================================================
-qmlfmt                                                         *ale-qml-qmlfmt*
-
-g:ale_qml_qmlfmt_executable                       *g:ale_qml_qmlfmt_executable*
-                                                  *b:ale_qml_qmlfmt_executable*
-  Type: |String|
-  Default: `'qmlfmt'`
-
-  This variable can be set to change the path to qmlfmt.
-
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
-
diff --git a/sources_non_forked/ale/doc/ale-r.txt b/sources_non_forked/ale/doc/ale-r.txt
deleted file mode 100644
index b5ccebe..0000000
--- a/sources_non_forked/ale/doc/ale-r.txt
+++ /dev/null
@@ -1,45 +0,0 @@
-===============================================================================
-ALE R Integration                                               *ale-r-options*
-
-
-===============================================================================
-lintr                                                             *ale-r-lintr*
-
-g:ale_r_lintr_options                                   *g:ale_r_lintr_options*
-                                                        *b:ale_r_lintr_options*
-  Type: |String|
-  Default: `'lintr::with_defaults()'`
-
-  This option can be configured to change the options for lintr.
-
-  The value of this option will be run with `eval` for the `lintr::lint`
-  options. Consult the lintr documentation for more information.
-
-
-g:ale_r_lintr_lint_package                         *g:ale_r_lintr_lint_package*
-                                                   *b:ale_r_lintr_lint_package*
-  Type: |Number|
-  Default: `0`
-
-  When set to `1`, the file will be checked with `lintr::lint_package` instead
-  of `lintr::lint`. This prevents erroneous namespace warnings when linting 
-  package files.
-
-
-===============================================================================
-styler                                                           *ale-r-styler*
-
-g:ale_r_styler_options                                 *g:ale_r_styler_options*
-                                                       *b:ale_r_styler_options*
-  Type: |String|
-  Default: `'styler::tidyverse_style'`
-
-  This option can be configured to change the options for styler.
-
-  The value of this option will be used as the `style` argument for the 
-  `styler::style_file` options. Consult the styler documentation 
-  for more information.
-
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-reasonml.txt b/sources_non_forked/ale/doc/ale-reasonml.txt
deleted file mode 100644
index b8729a5..0000000
--- a/sources_non_forked/ale/doc/ale-reasonml.txt
+++ /dev/null
@@ -1,76 +0,0 @@
-===============================================================================
-ALE ReasonML Integration                                 *ale-reasonml-options*
-
-
-===============================================================================
-merlin                                                    *ale-reasonml-merlin*
-
-To use merlin linter for ReasonML source code you need to make sure Merlin for
-Vim is correctly configured. See the corresponding Merlin wiki page for
-detailed instructions:
-https://github.com/the-lambda-church/merlin/wiki/vim-from-scratch
-
-===============================================================================
-ols                                                          *ale-reasonml-ols*
-
-The `ocaml-language-server` is the engine that powers OCaml and ReasonML
-editor support using the Language Server Protocol. See the installation
-instructions:
-https://github.com/freebroccolo/ocaml-language-server#installation
-
-
-g:ale_reason_ols_executable                       *g:ale_reason_ols_executable*
-                                                  *b:ale_reason_ols_executable*
-  Type: |String|
-  Default: `'ocaml-language-server'`
-
-  This variable can be set to change the executable path for `ols`.
-
-
-g:ale_reason_ols_use_global                       *g:ale_reason_ols_use_global*
-                                                  *b:ale_reason_ols_use_global*
-  Type: |String|
-  Default: `get(g:, 'ale_use_global_executables', 0)`
-
-  This variable can be set to `1` to always use the globally installed
-  executable. See also |ale-integrations-local-executables|.
-
-
-===============================================================================
-reason-language-server                           *ale-reasonml-language-server*
-
-Note: You must set an executable - there is no 'default' install location.
-Go to https://github.com/jaredly/reason-language-server and download the
-latest release. You can place it anywhere, but ensure you set the executable
-path.
-
-
-g:ale_reason_ls_executable                         *g:ale_reason_ls_executable*
-                                                   *b:ale_reason_ls_executable*
-  Type: |String|
-
-  This variable defines the standard location of the language server
-  executable. This must be set.
-
-
-===============================================================================
-refmt                                                      *ale-reasonml-refmt*
-
-g:ale_reasonml_refmt_executable               *g:ale_reasonml_refmt_executable*
-                                              *b:ale_reasonml_refmt_executable*
-  Type: |String|
-  Default: `'refmt'`
-
-  This variable can be set to pass the path of the refmt fixer.
-
-
-g:ale_reasonml_refmt_options                     *g:ale_reasonml_refmt_options*
-                                                 *b:ale_reasonml_refmt_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be set to pass additional options to the refmt fixer.
-
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-restructuredtext.txt b/sources_non_forked/ale/doc/ale-restructuredtext.txt
deleted file mode 100644
index e308b07..0000000
--- a/sources_non_forked/ale/doc/ale-restructuredtext.txt
+++ /dev/null
@@ -1,26 +0,0 @@
-===============================================================================
-ALE reStructuredText Integration                 *ale-restructuredtext-options*
-
-
-===============================================================================
-textlint                                        *ale-restructuredtext-textlint*
-
-To use textlint at reStructuredText, please install `textlint-plugin-rst`.
-https://github.com/jimo1001/textlint-plugin-rst
->
-  $ npm install textlint-plugin-rst
-
-To install `textlint-plugin-rst`, `docutils-ast-writer` python package
-must be installed.
-See: https://github.com/jimo1001/docutils-ast-writer
-
-See |ale-text-textlint|
-
-===============================================================================
-write-good                                    *ale-restructuredtext-write-good*
-
-See |ale-write-good-options|
-
-
-===============================================================================
-vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-ruby.txt b/sources_non_forked/ale/doc/ale-ruby.txt
deleted file mode 100644
index a27a20b..0000000
--- a/sources_non_forked/ale/doc/ale-ruby.txt
+++ /dev/null
@@ -1,195 +0,0 @@
-===============================================================================
-ALE Ruby Integration                                         *ale-ruby-options*
-
-
-===============================================================================
-brakeman                                                    *ale-ruby-brakeman*
-
-g:ale_ruby_brakeman_executable                 *g:ale_ruby_brakeman_executable*
-                                               *b:ale_ruby_brakeman_executable*
-  Type: String
-  Default: `'brakeman'`
-
-  Override the invoked brakeman binary. Set this to `'bundle'` to invoke
-  `'bundle` `exec` brakeman'.
-
-
-g:ale_ruby_brakeman_options                       *g:ale_ruby_brakeman_options*
-                                                  *b:ale_ruby_brakeman_options*
-  Type: |String|
-  Default: `''`
-
-  The contents of this variable will be passed through to brakeman.
-
-===============================================================================
-debride                                                      *ale-ruby-debride*
-
-g:ale_ruby_debride_executable                   *g:ale_ruby_debride_executable*
-                                                *b:ale_ruby_debride_executable*
-  Type: String
-  Default: `'debride'`
-
-  Override the invoked debride binary. Set this to `'bundle'` to invoke
-  `'bundle` `exec` debride'.
-
-
-g:ale_ruby_debride_options                         *g:ale_ruby_debride_options*
-                                                   *b:ale_ruby_debride_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be changed to modify flags given to debride.
-
-
-
-===============================================================================
-rails_best_practices                            *ale-ruby-rails_best_practices*
-
-g:ale_ruby_rails_best_practices_executable
-                                   *g:ale_ruby_rails_best_practices_executable*
-                                   *b:ale_ruby_rails_best_practices_executable*
-  Type: String
-  Default: `'rails_best_practices'`
-
-  Override the invoked rails_best_practices binary. Set this to `'bundle'` to
-  invoke `'bundle` `exec` rails_best_practices'.
-
-
-g:ale_ruby_rails_best_practices_options
-                                      *g:ale_ruby_rails_best_practices_options*
-                                      *b:ale_ruby_rails_best_practices_options*
-  Type: |String|
-  Default: `''`
-
-  The contents of this variable will be passed through to rails_best_practices.
-
-
-===============================================================================
-reek                                                            *ale-ruby-reek*
-
-g:ale_ruby_reek_executable                         *g:ale_ruby_reek_executable*
-                                                   *b:ale_ruby_reek_executable*
-  Type: String
-  Default: `'reek'`
-
-  Override the invoked reek binary. Set this to `'bundle'` to invoke
-  `'bundle` `exec` reek'.
-
-
-g:ale_ruby_reek_show_context                     *g:ale_ruby_reek_show_context*
-                                                 *b:ale_ruby_reek_show_context*
-  Type: |Number|
-  Default: 0
-
-  Controls whether context is included in the linter message. Defaults to off
-  because context is usually obvious while viewing a file.
-
-
-g:ale_ruby_reek_show_wiki_link                 *g:ale_ruby_reek_show_wiki_link*
-                                               *b:ale_ruby_reek_show_wiki_link*
-  Type: |Number|
-  Default: 0
-
-  Controls whether linter messages contain a link to an explanatory wiki page
-  for the type of code smell. Defaults to off to improve readability.
-
-
-===============================================================================
-rubocop                                                      *ale-ruby-rubocop*
-
-g:ale_ruby_rubocop_executable                   *g:ale_ruby_rubocop_executable*
-                                                *b:ale_ruby_rubocop_executable*
-  Type: String
-  Default: `'rubocop'`
-
-  Override the invoked rubocop binary. Set this to `'bundle'` to invoke
-  `'bundle` `exec` rubocop'.
-
-
-g:ale_ruby_rubocop_options                         *g:ale_ruby_rubocop_options*
-                                                   *b:ale_ruby_rubocop_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be changed to modify flags given to rubocop.
-
-
-===============================================================================
-ruby                                                            *ale-ruby-ruby*
-
-g:ale_ruby_ruby_executable                         *g:ale_ruby_ruby_executable*
-                                                   *b:ale_ruby_ruby_executable*
-  Type: String
-  Default: `'ruby'`
-
-  This variable can be changed to use a different executable for ruby.
-
-
-===============================================================================
-rufo                                                            *ale-ruby-rufo*
-
-g:ale_ruby_rufo_executable                         *g:ale_ruby_rufo_executable*
-                                                   *b:ale_ruby_rufo_executable*
-  Type: String
-  Default: `'rufo'`
-
-  Override the invoked rufo binary. This is useful for running rufo from
-  binstubs or a bundle.
-
-
-===============================================================================
-solargraph                                                *ale-ruby-solargraph*
-
-g:ale_ruby_solargraph_executable             *g:ale_ruby_solargraph_executable*
-                                             *b:ale_ruby_solargraph_executable*
-  Type: String
-  Default: `'solargraph'`
-
-  Override the invoked solargraph binary. This is useful for running solargraph
-  from binstubs or a bundle.
-
-
-===============================================================================
-sorbet                                                        *ale-ruby-sorbet*
-
-g:ale_ruby_sorbet_executable                     *g:ale_ruby_sorbet_executable*
-                                                 *b:ale_ruby_sorbet_executable*
-  Type: String
-  Default: `'srb'`
-
-  Override the invoked sorbet binary. Set this to `'bundle'` to invoke
-  `'bundle` `exec` srb'.
-
-
-g:ale_ruby_sorbet_options                           *g:ale_ruby_sorbet_options*
-                                                    *b:ale_ruby_sorbet_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be changed to modify flags given to sorbet.
-
-
-===============================================================================
-standardrb                                                *ale-ruby-standardrb*
-
-g:ale_ruby_standardrb_executable              *g:ale_ruby_standardrb_executable*
-                                              *b:ale_ruby_standardrb_executable*
-  Type: String
-  Default: `'standardrb'`
-
-  Override the invoked standardrb binary. Set this to `'bundle'` to invoke
-  `'bundle` `exec` standardrb'.
-
-
-g:ale_ruby_standardrb_options                   *g:ale_ruby_standardrb_options*
-                                                *b:ale_ruby_standardrb_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be changed to modify flags given to standardrb.
-
-
-===============================================================================
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-rust.txt b/sources_non_forked/ale/doc/ale-rust.txt
deleted file mode 100644
index 46d4714..0000000
--- a/sources_non_forked/ale/doc/ale-rust.txt
+++ /dev/null
@@ -1,272 +0,0 @@
-===============================================================================
-ALE Rust Integration                                         *ale-rust-options*
-                                                         *ale-integration-rust*
-
-===============================================================================
-Integration Information
-
-  If Vim does not detect the Rust file type out-of-the-box, you need the runtime
-  files for Rust distributed in Vim >=8.0.0501 or upstream:
-  https://github.com/rust-lang/rust.vim
-
-  Note that there are several possible linters and fixers for Rust files:
-
-  1. rustc -- The Rust compiler is used to check the currently edited file.
-     So, if your project consists of multiple files, you will get some errors
-     when you use e.g. a struct which is defined in another file. You can use
-     |g:ale_rust_ignore_error_codes| to ignore some of these errors.
-  2. cargo -- If your project is managed by Cargo, the whole project is
-     checked. That means that all errors are properly shown, but cargo can
-     only operate on the files written on disk, so errors will not be reported
-     while you type.
-  3. rls -- If you have `rls` installed, you might prefer using this linter
-     over cargo. rls implements the Language Server Protocol for incremental
-     compilation of Rust code, and can check Rust files while you type. `rls`
-     requires Rust files to contained in Cargo projects.
-  4. analyzer -- If you have rust-analyzer installed, you might prefer using
-     this linter over cargo and rls. rust-analyzer also implements the
-     Language Server Protocol for incremental compilation of Rust code, and is
-     the next iteration of rls. rust-analyzer, like rls, requires Rust files
-     to contained in Cargo projects.
-  5. rustfmt -- If you have `rustfmt` installed, you can use it as a fixer to
-     consistently reformat your Rust code.
-
-  Only cargo is enabled by default. To switch to using rustc instead of cargo,
-  configure |g:ale_linters| appropriately: >
-
-  " See the help text for the option for more information.
-  let g:ale_linters = {'rust': ['rustc']}
-<
-
-  Also note that rustc 1.12. or later is needed.
-
-
-===============================================================================
-analyzer                                                    *ale-rust-analyzer*
-
-g:ale_rust_analyzer_executable                 *g:ale_rust_analyzer_executable*
-                                               *b:ale_rust_analyzer_executable*
-  Type: |String|
-  Default: `'rust-analyzer'`
-
-  This variable can be modified to change the executable path for
-  `rust-analyzer`.
-
-
-g:ale_rust_analyzer_config                         *g:ale_rust_analyzer_config*
-                                                   *b:ale_rust_analyzer_config*
-  Type: |Dictionary|
-  Default: `{}`
-
-  Dictionary with configuration settings for rust-analyzer.
-
-===============================================================================
-cargo                                                          *ale-rust-cargo*
-
-g:ale_rust_cargo_use_check                         *g:ale_rust_cargo_use_check*
-                                                   *b:ale_rust_cargo_use_check*
-  Type: |Number|
-  Default: `1`
-
-  When set to `1`, this option will cause ALE to use `cargo check` instead of
-  `cargo build` . `cargo check` is supported since version 1.16.0 of Rust.
-
-  ALE will never use `cargo check` when the version of `cargo` is less than
-  0.17.0.
-
-
-g:ale_rust_cargo_check_all_targets         *g:ale_rust_cargo_check_all_targets*
-                                           *b:ale_rust_cargo_check_all_targets*
-  Type: |Number|
-  Default: `0`
-
-  When set to `1`, ALE will set the `--all-targets` option when `cargo check`
-  is used. See |g:ale_rust_cargo_use_check|,
-
-
-g:ale_rust_cargo_check_tests                     *g:ale_rust_cargo_check_tests*
-                                                 *b:ale_rust_cargo_check_tests*
-  Type: |Number|
-  Default: `0`
-
-  When set to `1`, ALE will set the `--tests` option when `cargo check`
-  is used. This allows for linting of tests which are normally excluded.
-  See |g:ale_rust_cargo_use_check|,
-
-
-g:ale_rust_cargo_check_examples               *g:ale_rust_cargo_check_examples*
-                                              *b:ale_rust_cargo_check_examples*
-  Type: |Number|
-  Default: `0`
-
-  When set to `1`, ALE will set the `--examples` option when `cargo check`
-  is used. This allows for linting of examples which are normally excluded.
-  See |g:ale_rust_cargo_use_check|,
-
-
-g:ale_rust_cargo_default_feature_behavior
-                                    *g:ale_rust_cargo_default_feature_behavior*
-                                    *b:ale_rust_cargo_default_feature_behavior*
-  Type: |String|
-  Default: `default`
-
-  When set to `none`, ALE will set the `--no-default-features` option when
-  invoking `cargo`. Only the features specified in
-  |g:ale_rust_cargo_include_features| will be included when performing the
-  lint check.
-
-  When set to `default`, ALE will instruct `cargo` to build all default
-  features specified in the project's `Cargo.toml` file, in addition to
-  including any additional features defined in
-  |g:ale_rust_cargo_include_features|.
-
-  When set to `all`, ALE will set the `--all-features` option when
-  invoking `cargo`, which will include all features defined in the project's
-  `Cargo.toml` file when performing the lint check.
-
-
-g:ale_rust_cargo_include_features           *g:ale_rust_cargo_include_features*
-                                            *b:ale_rust_cargo_include_features*
-  Type: |String|
-  Default: `''`
-
-  When defined, ALE will set the `--features` option when invoking `cargo` to
-  perform the lint check. See |g:ale_rust_cargo_default_feature_behavior|.
-
-
-g:ale_rust_cargo_avoid_whole_workspace *g:ale_rust_cargo_avoid_whole_workspace*
-                                       *b:ale_rust_cargo_avoid_whole_workspace*
-  Type: |Number|
-  Default: `1`
-
-  When set to 1, and ALE is used to edit a crate that is part of a Cargo
-  workspace, avoid building the entire workspace by invoking `cargo` directly
-  in the crate's directory. Otherwise, behave as usual.
-
-
-g:ale_rust_cargo_use_clippy
-                                                  *g:ale_rust_cargo_use_clippy*
-                                                  *b:ale_rust_cargo_use_clippy*
-  Type: |Number|
-  Default: `0`
-
-  When set to 1, `cargo clippy` will be used instead of `cargo check` or
-  `cargo build` as linter.
-  For details of `cargo clippy`, please visit the following link:
-
-  https://github.com/rust-lang-nursery/rust-clippy
-
-  Since `cargo clippy` is optional toolchain, it's safer to check whether
-  `cargo-clippy` is executable as follows:
->
-    let g:ale_rust_cargo_use_clippy = executable('cargo-clippy')
-<
-
-g:ale_rust_cargo_clippy_options
-                                              *g:ale_rust_cargo_clippy_options*
-                                              *b:ale_rust_cargo_clippy_options*
-
-  Type: |String|
-  Default: `''`
-
-  When `cargo clippy` is used, this value will be added to a command line to run
-  it. This variable is useful when you want to add some extra options which
-  only `cargo clippy` supports (e.g. `--deny`).
-
-
-===============================================================================
-rls                                                              *ale-rust-rls*
-
-g:ale_rust_rls_executable                           *g:ale_rust_rls_executable*
-                                                    *b:ale_rust_rls_executable*
-  Type: |String|
-  Default: `'rls'`
-
-  This variable can be modified to change the executable path for `rls`.
-
-
-g:ale_rust_rls_toolchain                             *g:ale_rust_rls_toolchain*
-                                                     *b:ale_rust_rls_toolchain*
-  Type: |String|
-  Default: `''`
-
-  This option can be set to change the toolchain used for `rls`. Possible
-  values include `'nightly'`, `'beta'`, `'stable'`, and `''`. When using
-  option `''`, rls will automatically find the default toolchain set by
-  rustup. If you want to use `rls` from a specific toolchain version, you may
-  also use values like `'channel-yyyy-mm-dd-arch-target'` as long as
-  `'rls +{toolchain_name} -V'` runs correctly in your command line.
-
-  The `rls` server will only be started once per executable.
-
-
-g:ale_rust_rls_config                                   *g:ale_rust_rls_config*
-                                                        *b:ale_rust_rls_config*
-  Type: |Dictionary|
-  Default: `{}`
-
-  Dictionary with configuration settings for rls. For example, to force
-  using clippy as linter: >
-        {
-      \   'rust': {
-      \     'clippy_preference': 'on'
-      \   }
-      \ }
-
-
-===============================================================================
-rustc                                                          *ale-rust-rustc*
-
-
-g:ale_rust_rustc_options                             *g:ale_rust_rustc_options*
-                                                     *b:ale_rust_rustc_options*
-  Type: |String|
-  Default: `'-Z no-codegen'`
-
-  The variable can be used to change the options passed to `rustc`.
-
-  `-Z no-codegen` should only work with nightly builds of Rust. Be careful when
-  setting the options, as running `rustc` could execute code or generate
-  binary files.
-
-
-g:ale_rust_ignore_error_codes                   *g:ale_rust_ignore_error_codes*
-                                                *b:ale_rust_ignore_error_codes*
-  Type: |List| of |String|s
-  Default: `[]`
-
-  This variable can contain error codes which will be ignored. For example, to
-  ignore most errors regarding failed imports, put this in your .vimrc
-  >
-  let g:ale_rust_ignore_error_codes = ['E0432', 'E0433']
-
-g:ale_rust_ignore_secondary_spans           *g:ale_rust_ignore_secondary_spans*
-                                            *b:ale_rust_ignore_secondary_spans*
-  Type: Number
-  Default: 0
-
-	When set to 1, instructs the Rust error repporting to ignore secondary
-	spans. The problem with secondary spans is that they sometimes appear in
-	error messages before the main cause of the error, for example: >
-
-  1 src/main.rs|98 col 5 error| this function takes 4 parameters but 5
-	parameters were supplied: defined here
-  2 src/main.rs|430 col 32 error| this function takes 4 parameters but 5
-	parameters were supplied: expected 4 parameters
-<
-  This is due to the sorting by line numbers. With this option set to 1,
-  the 'defined here' span will not be presented.
-
-===============================================================================
-rustfmt                                                      *ale-rust-rustfmt*
-
-g:ale_rust_rustfmt_options                         *g:ale_rust_rustfmt_options*
-                                                   *b:ale_rust_rustfmt_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be set to pass additional options to the rustfmt fixer.
-
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-sass.txt b/sources_non_forked/ale/doc/ale-sass.txt
deleted file mode 100644
index 22d7c47..0000000
--- a/sources_non_forked/ale/doc/ale-sass.txt
+++ /dev/null
@@ -1,31 +0,0 @@
-===============================================================================
-ALE Sass Integration                                         *ale-sass-options*
-
-
-===============================================================================
-sasslint                                                    *ale-sass-sasslint*
-
-See |ale-scss-sasslint| for information about the available options.
-
-
-===============================================================================
-stylelint                                                  *ale-sass-stylelint*
-
-g:ale_sass_stylelint_executable               *g:ale_sass_stylelint_executable*
-                                              *b:ale_sass_stylelint_executable*
-  Type: |String|
-  Default: `'stylelint'`
-
-  See |ale-integrations-local-executables|
-
-
-g:ale_sass_stylelint_use_global               *g:ale_sass_stylelint_use_global*
-                                              *b:ale_sass_stylelint_use_global*
-  Type: |String|
-  Default: `get(g:, 'ale_use_global_executables', 0)`
-
-  See |ale-integrations-local-executables|
-
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-scala.txt b/sources_non_forked/ale/doc/ale-scala.txt
deleted file mode 100644
index c9638ba..0000000
--- a/sources_non_forked/ale/doc/ale-scala.txt
+++ /dev/null
@@ -1,124 +0,0 @@
-===============================================================================
-ALE Scala Integration                                       *ale-scala-options*
-
-
-===============================================================================
-metals                                                       *ale-scala-metals*
-
-`metals` requires either an SBT project, a Mill project, or a running Bloop
-server.
-
-
-g:ale_scala_metals_executable                    *g:ale_scala_metals_executable*
-                                                 *b:ale_scala_metals_executable*
-  Type: |String|
-  Default: `'metals-vim'`
-
-  Override the invoked `metals` binary.
-
-
-g:ale_scala_metals_project_root                *g:ale_scala_metals_project_root*
-                                               *b:ale_scala_metals_project_root*
-  Type: |String|
-  Default: `''`
-
-  By default the project root is found by searching upwards for `build.sbt`,
-  `build.sc`, `.bloop` or `.metals`.
-  If the project root is elsewhere, you can override the project root
-  directory.
-
-
-===============================================================================
-sbtserver                                                 *ale-scala-sbtserver*
-
-`sbtserver` requires a running ^1.1.x sbt shell to connect to. It will attempt
-to connect via TCP to the address defined in `g:ale_scala_sbtserver_address`.
-As `sbt` defaults to listening via unix sockets, place these settings into
-your `~/.sbt/1.0/global.sbt` to ensure that ale will always attempt to connect
-to the right socket:
-
-`serverConnectionType := ConnectionType.Tcp` and `serverPort := 4273`
-
-
-g:ale_scala_sbtserver_address                   *g:ale_scala_sbtserver_address*
-                                                *b:ale_scala_sbtserver_address*
-  Type: |String|
-  Default: `'127.0.0.1:4273'`
-
-  By default the address is found by parsing `active.json`, however, reading a
-  file is a blocking operation which should be avoided in ale. The easy way
-  around this is to configure sbt to always connect to the same port, which
-  the instructions above describe.
-
-
-g:ale_scala_sbtserver_project_root         *g:ale_scala_sbtserver_project_root*
-                                           *b:ale_scala_sbtserver_project_root*
-  Type: |String|
-  Default: `''`
-
-  By default the project root is found by searching upwards for `build.sbt`.
-  If the project root is elsewhere, you can override the project root
-  directory.
-
-
-===============================================================================
-scalafmt                                                   *ale-scala-scalafmt*
-
-If Nailgun is used, override `g:ale_scala_scalafmt_executable` like so: >
-  let g:ale_scala_scalafmt_executable = 'ng'
-
-
-g:ale_scala_scalafmt_executable               *g:ale_scala_scalafmt_executable*
-                                              *b:ale_scala_scalafmt_executable*
-  Type: |String|
-  Default: `'scalafmt'`
-
-  Override the invoked `scalafmt` binary. This is useful for running `scalafmt`
-  with Nailgun.
-
-
-g:ale_scala_scalafmt_options                     *g:ale_scala_scalafmt_options*
-                                                 *b:ale_scala_scalafmt_options*
-  Type: |String|
-  Default: `''`
-
-  A string containing additional options to pass to `'scalafmt'`, or
-  `'ng scalafmt'` if Nailgun is used.
-
-
-===============================================================================
-scalastyle                                               *ale-scala-scalastyle*
-
-`scalastyle` requires a configuration file for a project to run. When no
-configuration file can be found, ALE will report a problem saying that a
-configuration file is required at line 1.
-
-To disable `scalastyle` globally, use |g:ale_linters| like so: >
-  let g:ale_linters = {'scala': ['scalac']} " Enable only scalac instead
-<
-
-See |g:ale_linters| for more information on disabling linters.
-
-
-g:ale_scala_scalastyle_config                   *g:ale_scala_scalastyle_config*
-                                                *b:ale_scala_scalastyle_config*
-  Type: |String|
-  Default: `''`
-
-  A string containing the location of a global fallback configuration file.
-
-  By default, ALE will look for a configuration file named
-  `scalastyle_config.xml` or `scalastyle-config.xml` in the current file's
-  directory or parent directories.
-
-
-g:ale_scala_scalastyle_options                 *g:ale_scala_scalastyle_options*
-                                               *b:ale_scala_scalastyle_options*
-  Type: |String|
-  Default: `''`
-
-  A string containing additional options to pass to scalastyle.
-
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-scss.txt b/sources_non_forked/ale/doc/ale-scss.txt
deleted file mode 100644
index 07a94fe..0000000
--- a/sources_non_forked/ale/doc/ale-scss.txt
+++ /dev/null
@@ -1,64 +0,0 @@
-===============================================================================
-ALE SCSS Integration                                         *ale-scss-options*
-
-
-===============================================================================
-prettier                                                    *ale-scss-prettier*
-
-See |ale-javascript-prettier| for information about the available options.
-
-
-===============================================================================
-sasslint                                                    *ale-scss-sasslint*
-
-g:ale_scss_sasslint_executable                 *g:ale_scss_sasslint_executable*
-                                               *b:ale_scss_sasslint_executable*
-  Type: |String|
-  Default: `'sass-lint'`
-
-  See |ale-integrations-local-executables|
-
-
-g:ale_scss_sasslint_options                       *g:ale_scss_sasslint_options*
-                                                  *b:ale_scss_sasslint_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be set to pass additional options to sass-lint.
-
-
-g:ale_scss_sasslint_use_global                 *g:ale_scss_sasslint_use_global*
-                                               *b:ale_scss_sasslint_use_global*
-  Type: |Number|
-  Default: `get(g:, 'ale_use_global_executables', 0)`
-
-  See |ale-integrations-local-executables|
-
-
-===============================================================================
-stylelint                                                  *ale-scss-stylelint*
-
-g:ale_scss_stylelint_executable               *g:ale_scss_stylelint_executable*
-                                              *b:ale_scss_stylelint_executable*
-  Type: |String|
-  Default: `'stylelint'`
-
-  See |ale-integrations-local-executables|
-
-g:ale_scss_stylelint_options                     *g:ale_scss_stylelint_options*
-                                                 *b:ale_scss_stylelint_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be set to pass additional options to stylelint.
-
-g:ale_scss_stylelint_use_global               *g:ale_scss_stylelint_use_global*
-                                              *b:ale_scss_stylelint_use_global*
-  Type: |String|
-  Default: `get(g:, 'ale_use_global_executables', 0)`
-
-  See |ale-integrations-local-executables|
-
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-sh.txt b/sources_non_forked/ale/doc/ale-sh.txt
deleted file mode 100644
index 3eac903..0000000
--- a/sources_non_forked/ale/doc/ale-sh.txt
+++ /dev/null
@@ -1,115 +0,0 @@
-===============================================================================
-ALE Shell Integration                                          *ale-sh-options*
-
-
-===============================================================================
-sh-language-server                                     *ale-sh-language-server*
-
-g:ale_sh_language_server_executable        *g:ale_sh_language_server_executable*
-                                           *b:ale_sh_language_server_executable*
-  Type: |String|
-  Default: `'bash-language-server'`
-
-  See |ale-integrations-local-executables|
-
-
-g:ale_sh_language_server_use_global        *g:ale_sh_language_server_use_global*
-                                           *b:ale_sh_language_server_use_global*
-  Type: |Number|
-  Default: `get(g:, 'ale_use_global_executables', 0)`
-
-  See |ale-integrations-local-executables|
-
-
-===============================================================================
-shell                                                            *ale-sh-shell*
-
-g:ale_sh_shell_default_shell                     *g:ale_sh_shell_default_shell*
-                                                 *b:ale_sh_shell_default_shell*
-  Type: |String|
-  Default: The current shell (`$SHELL`). Falls back to `'bash'` if that cannot be
-  read or if the current shell is `'fish'`.
-
-  When ALE runs the linter for shells with the `-n` flag, it will attempt to
-  read the shell from the shebang (`#!`) line from the shell script to
-  determine the shell program to run. When this detection fails, this variable
-  will be used instead.
-
-
-===============================================================================
-shellcheck                                                  *ale-sh-shellcheck*
-
-g:ale_sh_shellcheck_executable                 *g:ale_sh_shellcheck_executable*
-                                               *b:ale_sh_shellcheck_executable*
-  Type: |String|
-  Default: `'shellcheck'`
-
-  This variable sets executable used for shellcheck.
-
-
-g:ale_sh_shellcheck_options                       *g:ale_sh_shellcheck_options*
-                                                  *b:ale_sh_shellcheck_options*
-  Type: |String|
-  Default: `''`
-
-  With this variable we are able to pass extra arguments for shellcheck
-  for shellcheck invocation.
-
-  For example, if we want shellcheck to follow external sources (`see SC1091`)
-  we can set the variable as such:
->
-  let g:ale_sh_shellcheck_options = '-x'
-<
-
-
-g:ale_sh_shellcheck_change_directory     *g:ale_sh_shellcheck_change_directory*
-                                         *b:ale_sh_shellcheck_change_directory*
-  Type: |Number|
-  Default: `1`
-
-  If set to `1`, ALE will switch to the directory the shell file being
-  checked with `shellcheck` is in before checking it. This helps `shellcheck`
-  determine the path to sourced files more easily. This option can be turned
-  off if you want to control the directory `shellcheck` is executed from
-  yourself.
-
-
-g:ale_sh_shellcheck_dialect                       *g:ale_sh_shellcheck_dialect*
-                                                  *b:ale_sh_shellcheck_dialect*
-  Type: |String|
-  Default: `'auto'`
-
-  This variable specifies the shellcheck dialect (`-s` option).  The value
-  `'auto'` causes ALE to detect the dialect automatically, based on the shebang
-  line (if present) or the value of `b:is_bash`, `b:is_sh`, or `b:is_kornshell`
-  (set and used by |sh.vim|).
-
-
-g:ale_sh_shellcheck_exclusions                 *g:ale_sh_shellcheck_exclusions*
-                                               *b:ale_sh_shellcheck_exclusions*
-  Type: |String|
-  Default: `''`
-
-  Set this variable to exclude test(s) for shellcheck (-e/--exclude option).
-  To exclude more than one option, separate them with commas.
-
-  For example, to ignore some warnings that aren't applicable to files that
-  will be sourced by other scripts, use the buffer-local variant:
->
-    autocmd BufEnter PKGBUILD,.env
-    \   let b:ale_sh_shellcheck_exclusions = 'SC2034,SC2154,SC2164'
-<
-
-===============================================================================
-shfmt                                                            *ale-sh-shfmt*
-
-g:ale_sh_shfmt_options                                 *g:ale_sh_shfmt_options*
-                                                       *b:ale_sh_shfmt_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be set to pass additional options to the shfmt fixer.
-
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-sml.txt b/sources_non_forked/ale/doc/ale-sml.txt
deleted file mode 100644
index cc8d679..0000000
--- a/sources_non_forked/ale/doc/ale-sml.txt
+++ /dev/null
@@ -1,36 +0,0 @@
-===============================================================================
-ALE SML Integration                                           *ale-sml-options*
-
-===============================================================================
-smlnj                                                           *ale-sml-smlnj*
-                                                             *ale-sml-smlnj-cm*
-
-There are two SML/NJ powered checkers:
-
-- one using Compilation Manager that works on whole projects, but requires you
-  to save before errors show up
-- one using the SML/NJ REPL that works as you change the text, but might fail
-  if your project can only be built with CM.
-
-We dynamically select which one to use based whether we find a `*.cm` file at
-or above the directory of the file being checked. Only one checker (`smlnj`,
-`smlnj-cm`) will be enabled at a time.
-
--------------------------------------------------------------------------------
-
-g:ale_sml_smlnj_cm_file                               *g:ale_sml_smlnj_cm_file*
-                                                      *b:ale_sml_smlnj_cm_file*
-  Type: |String|
-  Default: `'*.cm'`
-
-  By default, ALE will look for a `*.cm` file in your current directory,
-  searching upwards. It stops when it finds at least one `*.cm` file (taking
-  the first file if there are more than one).
-
-  Change this option (in the buffer or global scope) to control how ALE finds
-  CM files. For example, to always search for a CM file named `sandbox.cm`:
->
-      let g:ale_sml_smlnj_cm_file = 'sandbox.cm'
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-solidity.txt b/sources_non_forked/ale/doc/ale-solidity.txt
deleted file mode 100644
index b6e4867..0000000
--- a/sources_non_forked/ale/doc/ale-solidity.txt
+++ /dev/null
@@ -1,36 +0,0 @@
-===============================================================================
-ALE Solidity Integration                                 *ale-solidity-options*
-
-
-===============================================================================
-solc                                                        *ale-solidity-solc*
-
-
-g:ale_solidity_solc_options                       *g:ale_solidity_solc_options*
-                                                  *b:ale_solidity_solc_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be set to pass extra options to solc.
-
-
-===============================================================================
-solhint                                                  *ale-solidity-solhint*
-
-  Solhint should work out-of-the-box. You can further configure it using a
-  `.solihint.json` file. See https://github.com/protofire/solhint for more
-  information.
-
-
-===============================================================================
-solium                                                    *ale-solidity-solium*
-
-  Use of Solium linter for Solidity source code requires a .soliumrc.json
-  file in project root. This file can be generated by running `solium --init`.
-  See the corresponding solium usage for detailed instructions
-  (https://github.com/duaraghav8/Solium#usage).
-
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
-
diff --git a/sources_non_forked/ale/doc/ale-spec.txt b/sources_non_forked/ale/doc/ale-spec.txt
deleted file mode 100644
index 3da950c..0000000
--- a/sources_non_forked/ale/doc/ale-spec.txt
+++ /dev/null
@@ -1,43 +0,0 @@
-===============================================================================
-ALE Spec Integration                                         *ale-spec-options*
-                                                         *ale-integration-spec*
-
-===============================================================================
-Integration Information
-
-  The rpmlint linter is disabled by default, because running rpmlint can
-  result in the execution of code embedded in the spec file and rpmlint makes
-  no distinction between checks which are safe to run on untrusted files and
-  those which are not.
-
-  Currently linters must be enabled globally.  The rpmlint linter can be
-  enabled with:
->
-  let g:ale_linters = {'spec': ['rpmlint']}
-<
-
-===============================================================================
-rpmlint                                                      *ale-spec-rpmlint*
-
-g:ale_spec_rpmlint_executable                   *g:ale_spec_rpmlint_executable*
-                                                *b:ale_spec_rpmlint_executable*
-  Type: |String|
-  Default: `'rpmlint'`
-
-  This variable sets executable used for rpmlint.
-
-
-g:ale_spec_rpmlint_options                         *g:ale_spec_rpmlint_options*
-                                                   *b:ale_spec_rpmlint_options*
-  Type: |String|
-  Default: `''`
-
-  Set this to pass extra arguments to rpmlint.
-
-  For example, to instruct rpmlint to use a specific configuration file:
->
-  let g:ale_spec_rpmlint_options = '-f custom.cf'
-<
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-sql.txt b/sources_non_forked/ale/doc/ale-sql.txt
deleted file mode 100644
index 2807271..0000000
--- a/sources_non_forked/ale/doc/ale-sql.txt
+++ /dev/null
@@ -1,61 +0,0 @@
-===============================================================================
-ALE SQL Integration                                           *ale-sql-options*
-
-
-===============================================================================
-pgformatter                                                 *ale-sql-pgformatter*
-
-g:ale_sql_pgformatter_executable             *g:ale_sql_pgformatter_executable*
-                                             *b:ale_sql_pgformatter_executable*
-  Type: |String|
-  Default: `'pg_format'`
-
-  This variable sets executable used for pgformatter.
-
-g:ale_sql_pgformatter_options                   *g:ale_sql_pgformatter_options*
-                                                *b:ale_sql_pgformatter_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be set to pass additional options to the pgformatter fixer.
-
-
-===============================================================================
-sqlfmt                                                         *ale-sql-sqlfmt*
-
-g:ale_sql_sqlfmt_executable                       *g:ale_sql_sqlfmt_executable*
-                                                  *b:ale_sql_sqlfmt_executable*
-  Type: |String|
-  Default: `'sqlfmt'`
-
-  This variable sets executable used for sqlfmt.
-
-g:ale_sql_sqlfmt_options                             *g:ale_sql_sqlfmt_options*
-                                                     *b:ale_sql_sqlfmt_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be set to pass additional options to the sqlfmt fixer.
-  At this time only the -u flag is available to format with upper-case.
-
-
-===============================================================================
-sqlformat                                                   *ale-sql-sqlformat*
-
-g:ale_sql_sqlformat_executable                 *g:ale_sql_sqlformat_executable*
-                                               *b:ale_sql_sqlformat_executable*
-  Type: |String|
-  Default: `'sqlformat'`
-
-  This variable sets executable used for sqlformat.
-
-g:ale_sql_sqlformat_options                       *g:ale_sql_sqlformat_options*
-                                                  *b:ale_sql_sqlformat_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be set to pass additional options to the sqlformat fixer.
-
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-stylus.txt b/sources_non_forked/ale/doc/ale-stylus.txt
deleted file mode 100644
index 3e6ba90..0000000
--- a/sources_non_forked/ale/doc/ale-stylus.txt
+++ /dev/null
@@ -1,33 +0,0 @@
-===============================================================================
-ALE Stylus Integration                                     *ale-stylus-options*
-
-
-===============================================================================
-stylelint                                                *ale-stylus-stylelint*
-
-g:ale_stylus_stylelint_executable           *g:ale_stylus_stylelint_executable*
-                                            *b:ale_stylus_stylelint_executable*
-  Type: |String|
-  Default: `'stylelint'`
-
-  See |ale-integrations-local-executables|
-
-
-g:ale_stylus_stylelint_options                 *g:ale_stylus_stylelint_options*
-                                               *b:ale_stylus_stylelint_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be set to pass additional options to stylelint.
-
-
-g:ale_stylus_stylelint_use_global           *g:ale_stylus_stylelint_use_global*
-                                            *b:ale_stylus_stylelint_use_global*
-  Type: |String|
-  Default: `get(g:, 'ale_use_global_executables', 0)`
-
-  See |ale-integrations-local-executables|
-
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-sugarss.txt b/sources_non_forked/ale/doc/ale-sugarss.txt
deleted file mode 100644
index 8e991e5..0000000
--- a/sources_non_forked/ale/doc/ale-sugarss.txt
+++ /dev/null
@@ -1,31 +0,0 @@
-===============================================================================
-ALE SugarSS Integration                                    *ale-sugarss-options*
-
-
-===============================================================================
-stylelint                                                  *ale-sugarss-stylelint*
-
-g:ale_sugarss_stylelint_executable            *g:ale_sugarss_stylelint_executable*
-                                              *b:ale_sugarss_stylelint_executable*
-  Type: |String|
-  Default: `'stylelint'`
-
-  See |ale-integrations-local-executables|
-
-g:ale_sugarss_stylelint_options                  *g:ale_sugarss_stylelint_options*
-                                                 *b:ale_sugarss_stylelint_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be set to pass additional options to stylelint.
-
-g:ale_sugarss_stylelint_use_global            *g:ale_sugarss_stylelint_use_global*
-                                              *b:ale_sugarss_stylelint_use_global*
-  Type: |String|
-  Default: `get(g:, 'ale_use_global_executables', 0)`
-
-  See |ale-integrations-local-executables|
-
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-supported-languages-and-tools.txt b/sources_non_forked/ale/doc/ale-supported-languages-and-tools.txt
deleted file mode 100644
index 4525229..0000000
--- a/sources_non_forked/ale/doc/ale-supported-languages-and-tools.txt
+++ /dev/null
@@ -1,512 +0,0 @@
-*ale-supported-languages-and-tools.txt*  For Vim version 8.0.
-*ale-supported-list*
-
-ALE Supported Languages and Tools
-
-===============================================================================
-
-The following languages and tools are supported by ALE.
-
-Notes:
-
-`^` No linters for text or Vim help filetypes are enabled by default.
-`!!` These linters check only files on disk. See |ale-lint-file-linters|
-
-* Ada
-  * `gcc`
-  * `gnatpp`
-* Ansible
-  * `ansible-lint`
-* API Blueprint
-  * `drafter`
-* AsciiDoc
-  * `alex`!!
-  * `proselint`
-  * `redpen`
-  * `textlint`
-  * `vale`
-  * `write-good`
-* ASM
-  * `gcc`
-* Awk
-  * `gawk`
-* Bash
-  * `language-server`
-  * `shell` (-n flag)
-  * `shellcheck`
-  * `shfmt`
-* Bats
-  * `shellcheck`
-* BibTeX
-  * `bibclean`
-* Bourne Shell
-  * `shell` (-n flag)
-  * `shellcheck`
-  * `shfmt`
-* C
-  * `ccls`
-  * `clang`
-  * `clangd`
-  * `clang-format`
-  * `clangtidy`!!
-  * `cppcheck`
-  * `cpplint`!!
-  * `cquery`
-  * `flawfinder`
-  * `gcc`
-  * `uncrustify`
-* C#
-  * `csc`!!
-  * `mcs`
-  * `mcsc`!!
-  * `uncrustify`
-* C++ (filetype cpp)
-  * `ccls`
-  * `clang`
-  * `clangcheck`!!
-  * `clangd`
-  * `clang-format`
-  * `clangtidy`!!
-  * `clazy`!!
-  * `cppcheck`
-  * `cpplint`!!
-  * `cquery`
-  * `flawfinder`
-  * `gcc`
-  * `uncrustify`
-* Chef
-  * `cookstyle`
-  * `foodcritic`
-* Clojure
-  * `clj-kondo`
-  * `joker`
-* CloudFormation
-  * `cfn-python-lint`
-* CMake
-  * `cmake-format`
-  * `cmakelint`
-* CoffeeScript
-  * `coffee`
-  * `coffeelint`
-* Crystal
-  * `ameba`!!
-  * `crystal`!!
-* CSS
-  * `csslint`
-  * `fecs`
-  * `prettier`
-  * `stylelint`
-* Cucumber
-  * `cucumber`
-* CUDA
-  * `nvcc`!!
-* Cypher
-  * `cypher-lint`
-* Cython (pyrex filetype)
-  * `cython`
-* D
-  * `dfmt`
-  * `dls`
-  * `dmd`
-  * `uncrustify`
-* Dafny
-  * `dafny`!!
-* Dart
-  * `dartanalyzer`!!
-  * `dartfmt`!!
-  * `language_server`
-* Dockerfile
-  * `dockerfile_lint`
-  * `hadolint`
-* Elixir
-  * `credo`
-  * `dialyxir`
-  * `dogma`
-  * `elixir-ls`
-  * `mix`!!
-* Elm
-  * `elm-format`
-  * `elm-ls`
-  * `elm-make`
-* Erb
-  * `erb`
-  * `erubi`
-  * `erubis`
-  * `ruumba`
-* Erlang
-  * `erlc`
-  * `SyntaxErl`
-* Fish
-  * `fish` (-n flag)
-* Fortran
-  * `gcc`
-  * `language_server`
-* Fountain
-  * `proselint`
-* FusionScript
-  * `fusion-lint`
-* Git Commit Messages
-  * `gitlint`
-* GLSL
-  * glslang
-  * `glslls`
-* Go
-  * `bingo`
-  * `go build`!!
-  * `gofmt`
-  * `goimports`
-  * `golangci-lint`!!
-  * `golangserver`
-  * `golint`
-  * `gometalinter`!!
-  * `go mod`!!
-  * `gopls`
-  * `gosimple`!!
-  * `gotype`!!
-  * `go vet`!!
-  * `revive`!!
-  * `staticcheck`!!
-* GraphQL
-  * `eslint`
-  * `gqlint`
-  * `prettier`
-* Hack
-  * `hack`
-  * `hackfmt`
-  * `hhast`
-* Haml
-  * `haml-lint`
-* Handlebars
-  * `ember-template-lint`
-* Haskell
-  * `brittany`
-  * `cabal-ghc`
-  * `floskell`
-  * `ghc`
-  * `ghc-mod`
-  * `hdevtools`
-  * `hfmt`
-  * `hie`
-  * `hindent`
-  * `hlint`
-  * `stack-build`!!
-  * `stack-ghc`
-  * `stylish-haskell`
-* HCL
-  * `terraform-fmt`
-* HTML
-  * `alex`!!
-  * `fecs`
-  * `html-beautify`
-  * `HTMLHint`
-  * `prettier`
-  * `proselint`
-  * `tidy`
-  * `write-good`
-* Idris
-  * `idris`
-* Ink
-  * `ink-language-server`
-* ISPC
-  * `ispc`!!
-* Java
-  * `checkstyle`
-  * `eclipselsp`
-  * `google-java-format`
-  * `javac`
-  * `javalsp`
-  * `PMD`
-  * `uncrustify`
-* JavaScript
-  * `eslint`
-  * `fecs`
-  * `flow`
-  * `jscs`
-  * `jshint`
-  * `prettier`
-  * `prettier-eslint`
-  * `prettier-standard`
-  * `standard`
-  * `tsserver`
-  * `xo`
-* JSON
-  * `fixjson`
-  * `jq`
-  * `jsonlint`
-  * `prettier`
-* Julia
-  * `languageserver`
-* Kotlin
-  * `kotlinc`!!
-  * `ktlint`!!
-  * `languageserver`
-* LaTeX (tex)
-  * `alex`!!
-  * `chktex`
-  * `lacheck`
-  * `proselint`
-  * `redpen`
-  * `texlab`
-  * `textlint`
-  * `vale`
-  * `write-good`
-* Less
-  * `lessc`
-  * `prettier`
-  * `stylelint`
-* LLVM
-  * `llc`
-* Lua
-  * `luac`
-  * `luacheck`
-* Mail
-  * `alex`!!
-  * `languagetool`!!
-  * `proselint`
-  * `vale`
-* Make
-  * `checkmake`
-* Markdown
-  * `alex`!!
-  * `languagetool`!!
-  * `markdownlint`!!
-  * `mdl`
-  * `prettier`
-  * `proselint`
-  * `redpen`
-  * `remark-lint`
-  * `textlint`
-  * `vale`
-  * `write-good`
-* MATLAB
-  * `mlint`
-* Mercury
-  * `mmc`!!
-* NASM
-  * `nasm`!!
-* Nim
-  * `nim check`!!
-  * `nimlsp`
-  * `nimpretty`
-* nix
-  * `nix-instantiate`
-  * `nixpkgs-fmt`
-* nroff
-  * `alex`!!
-  * `proselint`
-  * `write-good`
-* Objective-C
-  * `ccls`
-  * `clang`
-  * `clangd`
-  * `uncrustify`
-* Objective-C++
-  * `clang`
-  * `clangd`
-  * `uncrustify`
-* OCaml
-  * `merlin` (see |ale-ocaml-merlin|)
-  * `ocamlformat`
-  * `ocp-indent`
-  * `ols`
-* Pawn
-  * `uncrustify`
-* Perl
-  * `perl -c`
-  * `perl-critic`
-  * `perltidy`
-* Perl6
-  * `perl6 -c`
-* PHP
-  * `langserver`
-  * `phan`
-  * `phpcbf`
-  * `phpcs`
-  * `php-cs-fixer`
-  * `php -l`
-  * `phpmd`
-  * `phpstan`
-  * `psalm`!!
-* PO
-  * `alex`!!
-  * `msgfmt`
-  * `proselint`
-  * `write-good`
-* Pod
-  * `alex`!!
-  * `proselint`
-  * `write-good`
-* Pony
-  * `ponyc`
-* PowerShell
-  * `powershell`
-  * `psscriptanalyzer`
-* Prolog
-  * `swipl`
-* proto
-  * `protoc-gen-lint`
-* Pug
-  * `pug-lint`
-* Puppet
-  * `languageserver`
-  * `puppet`
-  * `puppet-lint`
-* PureScript
-  * `purescript-language-server`
-  * `purty`
-* Python
-  * `autopep8`
-  * `bandit`
-  * `black`
-  * `flake8`
-  * `isort`
-  * `mypy`
-  * `prospector`
-  * `pycodestyle`
-  * `pydocstyle`
-  * `pyflakes`
-  * `pylama`!!
-  * `pylint`!!
-  * `pyls`
-  * `pyre`
-  * `reorder-python-imports`
-  * `vulture`!!
-  * `yapf`
-* QML
-  * `qmlfmt`
-  * `qmllint`
-* R
-  * `lintr`
-  * `styler`
-* Racket
-  * `raco`
-* ReasonML
-  * `merlin`
-  * `ols`
-  * `reason-language-server`
-  * `refmt`
-* reStructuredText
-  * `alex`!!
-  * `proselint`
-  * `redpen`
-  * `rstcheck`
-  * `textlint`
-  * `vale`
-  * `write-good`
-* Re:VIEW
-  * `redpen`
-* RPM spec
-  * `rpmlint`
-* Ruby
-  * `brakeman`
-  * `debride`
-  * `rails_best_practices`!!
-  * `reek`
-  * `rubocop`
-  * `ruby`
-  * `rufo`
-  * `solargraph`
-  * `sorbet`
-  * `standardrb`
-* Rust
-  * `cargo`!!
-  * `rls`
-  * `rust-analyzer`
-  * `rustc` (see |ale-integration-rust|)
-  * `rustfmt`
-* Sass
-  * `sass-lint`
-  * `stylelint`
-* Scala
-  * `fsc`
-  * `metals`
-  * `sbtserver`
-  * `scalac`
-  * `scalafmt`
-  * `scalastyle`
-* SCSS
-  * `prettier`
-  * `sass-lint`
-  * `scss-lint`
-  * `stylelint`
-* Slim
-  * `slim-lint`
-* SML
-  * `smlnj`
-* Solidity
-  * `solc`
-  * `solhint`
-  * `solium`
-* SQL
-  * `pgformatter`
-  * `sqlfmt`
-  * `sqlformat`
-  * `sqlint`
-* Stylus
-  * `stylelint`
-* SugarSS
-  * `stylelint`
-* Swift
-  * `sourcekit-lsp`
-  * `swiftformat`
-  * `swiftlint`
-* Tcl
-  * `nagelfar`!!
-* Terraform
-  * `fmt`
-  * `tflint`
-* Texinfo
-  * `alex`!!
-  * `proselint`
-  * `write-good`
-* Text^
-  * `alex`!!
-  * `languagetool`!!
-  * `proselint`
-  * `redpen`
-  * `textlint`
-  * `vale`
-  * `write-good`
-* Thrift
-  * `thrift`
-* TypeScript
-  * `eslint`
-  * `fecs`
-  * `prettier`
-  * `standard`
-  * `tslint`
-  * `tsserver`
-  * `typecheck`
-* VALA
-  * `uncrustify`
-* Verilog
-  * `iverilog`
-  * `verilator`
-  * `vlog`
-  * `xvlog`
-* VHDL
-  * `ghdl`
-  * `vcom`
-  * `xvhdl`
-* Vim
-  * `vimls`
-  * `vint`
-* Vim help^
-  * `alex`!!
-  * `proselint`
-  * `write-good`
-* Vue
-  * `prettier`
-  * `vls`
-* XHTML
-  * `alex`!!
-  * `proselint`
-  * `write-good`
-* XML
-  * `xmllint`
-* YAML
-  * `prettier`
-  * `swaglint`
-  * `yamllint`
-* YANG
-  * `yang-lsp`
diff --git a/sources_non_forked/ale/doc/ale-swift.txt b/sources_non_forked/ale/doc/ale-swift.txt
deleted file mode 100644
index 8fa0c06..0000000
--- a/sources_non_forked/ale/doc/ale-swift.txt
+++ /dev/null
@@ -1,21 +0,0 @@
-===============================================================================
-ALE Swift Integration                                       *ale-swift-options*
-
-
-===============================================================================
-sourcekitlsp                                           *ale-swift-sourcekitlsp*
-
-To enable the SourceKit-LSP you need to install and build the executable as
-described here: https://github.com/apple/sourcekit-lsp#building-sourcekit-lsp
-
-
-g:ale_sourcekit_lsp_executable                 *g:ale_sourcekit_lsp_executable*
-                                               *b:ale_sourcekit_lsp_executable*
-  Type: |String|
-  Default: `'sourcekit-lsp'`
-
-  See |ale-integrations-local-executables|
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
-
diff --git a/sources_non_forked/ale/doc/ale-tcl.txt b/sources_non_forked/ale/doc/ale-tcl.txt
deleted file mode 100644
index 497c9fd..0000000
--- a/sources_non_forked/ale/doc/ale-tcl.txt
+++ /dev/null
@@ -1,25 +0,0 @@
-===============================================================================
-ALE Tcl Integration                                           *ale-tcl-options*
-
-
-===============================================================================
-nagelfar                                                     *ale-tcl-nagelfar*
-
-g:ale_tcl_nagelfar_executable                   *g:ale_tcl_nagelfar_executable*
-                                                *b:ale_tcl_nagelfar_executable*
-  Type: |String|
-  Default: `'nagelfar.tcl'`
-
-  This variable can be changed to change the path to nagelfar.
-
-
-g:ale_tcl_nagelfar_options                         *g:ale_tcl_nagelfar_options*
-                                                   *b:ale_tcl_nagelfar_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be changed to modify flags given to nagelfar.
-
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-terraform.txt b/sources_non_forked/ale/doc/ale-terraform.txt
deleted file mode 100644
index f62db19..0000000
--- a/sources_non_forked/ale/doc/ale-terraform.txt
+++ /dev/null
@@ -1,78 +0,0 @@
-===============================================================================
-ALE Terraform Integration                               *ale-terraform-options*
-
-
-===============================================================================
-terraform-fmt-fixer                                   *ale-terraform-fmt-fixer*
-
-g:ale_terraform_fmt_executable                 *g:ale_terraform_fmt_executable*
-                                               *b:ale_terraform_fmt_executable*
-
-  Type: |String|
-  Default: `'terraform'`
-
-  This variable can be changed to use a different executable for terraform.
-
-
-g:ale_terraform_fmt_options                       *g:ale_terraform_fmt_options*
-                                                  *b:ale_terraform_fmt_options*
-  Type: |String|
-  Default: `''`
-
-
-===============================================================================
-terraform                                             *ale-terraform-terraform*
-
-g:ale_terraform_terraform_executable     *g:ale_terraform_terraform_executable*
-                                         *b:ale_terraform_terraform_executable*
-
-  Type: |String|
-  Default: `'terraform'`
-
-  This variable can be changed to use a different executable for terraform.
-
-
-===============================================================================
-terraform-lsp                                     *ale-terraform-terraform-lsp*
-
-g:ale_terraform_langserver_executable   *g:ale_terraform_langserver_executable*
-                                        *b:ale_terraform_langserver_executable*
-  Type: |String|
-  Default: `'terraform-lsp'`
-
-  This variable can be changed to use a different executable for terraform-lsp.
-
-
-g:ale_terraform_langserver_options         *g:ale_terraform_langserver_options*
-                                           *b:ale_terraform_langserver_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be changed to pass custom CLI flags to terraform-lsp.
-
-
-===============================================================================
-tflint                                                   *ale-terraform-tflint*
-
-g:ale_terraform_tflint_executable           *g:ale_terraform_tflint_executable*
-                                            *b:ale_terraform_tflint_executable*
-
-  Type: |String|
-  Default: `'tflint'`
-
-  This variable can be changed to use a different executable for tflint.
-
-
-g:ale_terraform_tflint_options                 *g:ale_terraform_tflint_options*
-                                               *b:ale_terraform_tflint_options*
-  Type: |String|
-  Default: `'-f json'`
-
-  This variable can be changed to pass different options to tflint. Ale does
-  expect json output from tflint, so if you change this, you'll probably want
-  to include '-f json' in your new value.
-
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
-
diff --git a/sources_non_forked/ale/doc/ale-tex.txt b/sources_non_forked/ale/doc/ale-tex.txt
deleted file mode 100644
index ceb9fa8..0000000
--- a/sources_non_forked/ale/doc/ale-tex.txt
+++ /dev/null
@@ -1,77 +0,0 @@
-===============================================================================
-ALE TeX Integration                                           *ale-tex-options*
-
-
-===============================================================================
-chktex                                                         *ale-tex-chktex*
-
-g:ale_tex_chktex_executable                       *g:ale_tex_chktex_executable*
-                                                  *b:ale_tex_chktex_executable*
-  Type: |String|
-  Default: `'chktex'`
-
-  This variable can be changed to change the path to chktex.
-
-
-g:ale_tex_chktex_options                             *g:ale_tex_chktex_options*
-                                                     *b:ale_tex_chktex_options*
-  Type: |String|
-  Default: `'-I'`
-
-  This variable can be changed to modify flags given to chktex.
-
-
-------------------------------------------------------------------------------
-lacheck                                                       *ale-tex-lacheck*
-
-g:ale_lacheck_executable                             *g:ale_lacheck_executable*
-                                                     *b:ale_lacheck_executable*
-  Type: |String|
-  Default: '`lacheck`'
-
-  This variable can be changed to change the path to lacheck.
-
-
-
-===============================================================================
-latexindent                                                *ale-tex-latexindent*
-
-g:ale_tex_latexindent_executable              *g:ale_tex_latexindent_executable*
-                                              *b:ale_tex_latexindent_executable*
-  Type: |String|
-  Default: `'latexindent'`
-
-  This variable can be changed to change the path to latexindent.
-
-
-g:ale_tex_latexindent_options                   *g:ale_tex_latexindent_options*
-                                                *b:ale_tex_latexindent_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be changed to modify flags given to latexindent.
-
-
-
-===============================================================================
-texlab                                                          *ale-tex-texlab*
-
-g:ale_tex_texlab_executable                        *g:ale_tex_texlab_executable*
-                                                   *b:ale_tex_texlab_executable*
-  Type: |String|
-  Default: `'texlab'`
-
-  This variable can be changed to change the path to texlab.
-
-
-g:ale_tex_texlab_options                              *g:ale_tex_texlab_options*
-                                                      *b:ale_tex_texlab_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be changed to modify flags given to texlab.
-
-
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-texinfo.txt b/sources_non_forked/ale/doc/ale-texinfo.txt
deleted file mode 100644
index f8ed342..0000000
--- a/sources_non_forked/ale/doc/ale-texinfo.txt
+++ /dev/null
@@ -1,12 +0,0 @@
-===============================================================================
-ALE Texinfo Integration                                   *ale-texinfo-options*
-
-
-===============================================================================
-write-good                                             *ale-texinfo-write-good*
-
-See |ale-write-good-options|
-
-
-===============================================================================
-vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-text.txt b/sources_non_forked/ale/doc/ale-text.txt
deleted file mode 100644
index 913d7e6..0000000
--- a/sources_non_forked/ale/doc/ale-text.txt
+++ /dev/null
@@ -1,42 +0,0 @@
-===============================================================================
-ALE Text Integration                                         *ale-text-options*
-
-
-===============================================================================
-textlint                                                    *ale-text-textlint*
-
-The options for the textlint linter are global because it does not make
-sense to have them specified on a per-language basis.
-
-g:ale_textlint_executable                           *g:ale_textlint_executable*
-                                                    *b:ale_textlint_executable*
-  Type: |String|
-  Default: `'textlint'`
-
-  See |ale-integrations-local-executables|
-
-
-g:ale_textlint_options                                 *g:ale_textlint_options*
-                                                       *b:ale_textlint_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be set to pass additional options to textlint.
-
-
-g:ale_textlint_use_global                           *g:ale_textlint_use_global*
-                                                    *b:ale_textlint_use_global*
-  Type: |Number|
-  Default: `get(g:, 'ale_use_global_executables', 0)`
-
-  See |ale-integrations-local-executables|
-
-
-===============================================================================
-write-good                                                *ale-text-write-good*
-
-See |ale-write-good-options|
-
-
-===============================================================================
-vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-thrift.txt b/sources_non_forked/ale/doc/ale-thrift.txt
deleted file mode 100644
index bb2ec05..0000000
--- a/sources_non_forked/ale/doc/ale-thrift.txt
+++ /dev/null
@@ -1,46 +0,0 @@
-===============================================================================
-ALE Thrift Integration                                     *ale-thrift-options*
-
-
-===============================================================================
-thrift                                                      *ale-thrift-thrift*
-
-The `thrift` linter works by compiling the buffer's contents and reporting any
-errors reported by the parser and the configured code generator(s).
-
-g:ale_thrift_thrift_executable                 *g:ale_thrift_thrift_executable*
-                                               *b:ale_thrift_thrift_executable*
-  Type: |String|
-  Default: `'thrift'`
-
-  See |ale-integrations-local-executables|
-
-
-g:ale_thrift_thrift_generators                 *g:ale_thrift_thrift_generators*
-                                               *b:ale_thrift_thrift_generators*
-  Type: |List| of |String|s
-  Default: `['cpp']`
-
-  This list must contain one or more named code generators. Generator options
-  can be included as part of each string, e.g. `['py:dynamic']`.
-
-
-g:ale_thrift_thrift_includes                     *g:ale_thrift_thrift_includes*
-                                                 *b:ale_thrift_thrift_includes*
-  Type: |List| of |String|s
-  Default: `['.']`
-
-  This list contains paths that will be searched for thrift `include`
-  directives.
-
-
-g:ale_thrift_thrift_options                       *g:ale_thrift_thrift_options*
-                                                  *b:ale_thrift_thrift_options*
-  Type: |String|
-  Default: `'-strict'`
-
-  This variable can be changed to customize the additional command-line
-  arguments that are passed to the thrift compiler.
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-typescript.txt b/sources_non_forked/ale/doc/ale-typescript.txt
deleted file mode 100644
index 2c50d11..0000000
--- a/sources_non_forked/ale/doc/ale-typescript.txt
+++ /dev/null
@@ -1,142 +0,0 @@
-===============================================================================
-ALE TypeScript Integration                             *ale-typescript-options*
-
-
-===============================================================================
-eslint                                                  *ale-typescript-eslint*
-
-Because of how TypeScript compiles code to JavaScript and how interrelated
-the two languages are, the `eslint` linter for TypeScript uses the JavaScript
-options for `eslint` too. See: |ale-javascript-eslint|.
-
-
-===============================================================================
-prettier                                              *ale-typescript-prettier*
-
-See |ale-javascript-prettier| for information about the available options.
-
-
-===============================================================================
-standard                                              *ale-typescript-standard*
-
-g:ale_typescript_standard_executable     *g:ale_typescript_standard_executable*
-                                         *b:ale_typescript_standard_executable*
-  Type: |String|
-  Default: `'standard'`
-
-  See |ale-integrations-local-executables|
-
-
-g:ale_typescript_standard_options           *g:ale_typescript_standard_options*
-                                            *b:ale_typescript_standard_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be set to pass additional options to standard.
-
-
-g:ale_typescript_standard_use_global     *g:ale_typescript_standard_use_global*
-                                         *b:ale_typescript_standard_use_global*
-  Type: |Number|
-  Default: `get(g:, 'ale_use_global_executables', 0)`
-
-  See |ale-integrations-local-executables|
-
-
-===============================================================================
-tslint                                                  *ale-typescript-tslint*
-
-This linter isn't recommended, because TSLint can't be used for checking for
-problems while you type. You should probably use the tsserver plugin instead.
-tsserver plugins are described here:
-https://github.com/Microsoft/TypeScript/wiki/Writing-a-Language-Service-Plugin
-
-Follow the instructions on the plugin website for installing it:
-https://github.com/Microsoft/typescript-tslint-plugin
-
-Then disable TSLint in vimrc or any other Vim configuration file. >
-  let g:ale_linters_ignore = {'typescript': ['tslint']}
-<
-
-g:ale_typescript_tslint_executable         *g:ale_typescript_tslint_executable*
-                                           *b:ale_typescript_tslint_executable*
-  Type: |String|
-  Default: `'tslint'`
-
-  See |ale-integrations-local-executables|
-
-
-g:ale_typescript_tslint_config_path       *g:ale_typescript_tslint_config_path*
-                                          *b:ale_typescript_tslint_config_path*
-  Type: |String|
-  Default: `''`
-
-  ALE will first discover the tslint.json path in an ancestor directory. If no
-  such path exists, this variable will be used instead.
-
-
-g:ale_typescript_tslint_ignore_empty_files
-                                   *g:ale_typescript_tslint_ignore_empty_files*
-                                   *b:ale_typescript_tslint_ignore_empty_files*
-  Type: |Number|
-  Default: `0`
-
-  When set to `1`, ALE will not report any problems for empty files with
-  TSLint. ALE will still execute TSLint for the files, but ignore any problems
-  reported. This stops ALE from complaining about newly created files,
-  and files where lines have been added and then removed.
-
-
-g:ale_typescript_tslint_rules_dir           *g:ale_typescript_tslint_rules_dir*
-                                            *b:ale_typescript_tslint_rules_dir*
-  Type: |String|
-  Default: `''`
-
-  If this variable is set, ALE will use it as the rules directory for tslint.
-
-
-g:ale_typescript_tslint_use_global         *g:ale_typescript_tslint_use_global*
-                                           *b:ale_typescript_tslint_use_global*
-  Type: |Number|
-  Default: `get(g:, 'ale_use_global_executables', 0)`
-
-  See |ale-integrations-local-executables|
-
-
-===============================================================================
-tsserver                                              *ale-typescript-tsserver*
-
-g:ale_typescript_tsserver_executable     *g:ale_typescript_tsserver_executable*
-                                         *b:ale_typescript_tsserver_executable*
-  Type: |String|
-  Default: `'tsserver'`
-
-  ALE will first discover the tsserver path in an ancestor node_modules
-  directory. If no such path exists, this variable will be used instead.
-
-  If you wish to use only a globally installed version of tsserver, set
-  |g:ale_typescript_tsserver_use_global| to `1`.
-
-
-g:ale_typescript_tsserver_config_path   *g:ale_typescript_tsserver_config_path*
-                                        *b:ale_typescript_tsserver_config_path*
-  Type: |String|
-  Default: `''`
-
-  ALE will first discover the tsserver.json path in an ancestor directory. If
-  no such path exists, this variable will be used instead.
-
-
-g:ale_typescript_tsserver_use_global     *g:ale_typescript_tsserver_use_global*
-                                         *b:ale_typescript_tsserver_use_global*
-  Type: |Number|
-  Default: `get(g:, 'ale_use_global_executables', 0)`
-
-  This variable controls whether or not ALE will search for a local path for
-  tsserver first. If this variable is set to `1`, then ALE will always use the
-  global version of tsserver, in preference to locally installed versions of
-  tsserver in node_modules.
-
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-vala.txt b/sources_non_forked/ale/doc/ale-vala.txt
deleted file mode 100644
index ca24bcf..0000000
--- a/sources_non_forked/ale/doc/ale-vala.txt
+++ /dev/null
@@ -1,12 +0,0 @@
-===============================================================================
-ALE VALA Integration                                         *ale-vala-options*
-
-
-===============================================================================
-uncrustify                                                *ale-vala-uncrustify*
-
-See |ale-c-uncrustify| for information about the available options.
-
-
-===============================================================================
-vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-verilog.txt b/sources_non_forked/ale/doc/ale-verilog.txt
deleted file mode 100644
index 94b820b..0000000
--- a/sources_non_forked/ale/doc/ale-verilog.txt
+++ /dev/null
@@ -1,102 +0,0 @@
-===============================================================================
-ALE Verilog/SystemVerilog Integration                     *ale-verilog-options*
-
-
-===============================================================================
-ALE can use four different linters for Verilog HDL:
-
-  iverilog:
-    Using `iverilog -t null -Wall`
-
-  verilator
-    Using `verilator --lint-only -Wall`
-
-  ModelSim/Questa
-    Using `vlog -quiet -lint`
-
-  Vivado
-    Using `xvlog`
-
-By default, both 'verilog' and 'systemverilog' filetypes are checked.
-
-You can limit 'systemverilog' files to be checked using only 'verilator' by
-defining 'g:ale_linters' variable:
->
-    au FileType systemverilog
-    \ let g:ale_linters = {'systemverilog' : ['verilator'],}
-<
-
-Linters/compilers that utilize a "work" directory for analyzing designs- such
-as ModelSim and Vivado- can be passed the location of these directories as
-part of their respective option strings listed below. This is useful for
-holistic analysis of a file (e.g. a design with components, packages, or other
-code defined external to the current file as part of a larger project) or
-when wanting to simply pass an alternative location for the auto-generated
-work directories (such as '/tmp') so as to not muddle the current directory.
-Since these type of linters often use this work directory for holding compiled
-design data as part of a single build process, they sometimes cannot handle
-the frequent, asynchronous application launches when linting while text is
-changing. This can happen in the form of hangs or crashes. To help prevent
-this when using these linters, it may help to run linting less frequently; for
-example, only when a file is saved.
-
-===============================================================================
-iverilog                                                 *ale-verilog-iverilog*
-
-  No additional options
-
-
-===============================================================================
-verilator                                               *ale-verilog-verilator*
-
-g:ale_verilog_verilator_options               *g:ale_verilog_verilator_options*
-                                              *b:ale_verilog_verilator_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be changed to modify 'verilator' command arguments
-
-  For example `'-sv --default-language "1800-2012"'` if you want to enable
-  SystemVerilog parsing and select the 2012 version of the language.
-
-
-===============================================================================
-vlog                                                         *ale-verilog-vlog*
-
-g:ale_verilog_vlog_executable                   *g:ale_verilog_vlog_executable*
-                                                *b:ale_verilog_vlog_executable*
-  Type: |String|
-  Default: `'vlog'`
-
-  This variable can be changed to the path to the 'vlog' executable.
-
-
-g:ale_verilog_vlog_options                         *g:ale_verilog_vlog_options*
-                                                   *b:ale_verilog_vlog_options*
-  Type: |String|
-  Default: `'-quiet -lint'`
-
-  This variable can be changed to modify the flags/options passed to 'vlog'.
-
-
-===============================================================================
-xvlog                                                       *ale-verilog-xvlog*
-
-g:ale_verilog_xvlog_executable                 *g:ale_verilog_xvlog_executable*
-                                               *b:ale_verilog_xvlog_executable*
-  Type: |String|
-  Default: `'xvlog'`
-
-  This variable can be changed to the path to the 'xvlog' executable.
-
-
-g:ale_verilog_xvlog_options                       *g:ale_verilog_xvlog_options*
-                                                  *b:ale_verilog_xvlog_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be changed to modify the flags/options passed to 'xvlog'.
-
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-vhdl.txt b/sources_non_forked/ale/doc/ale-vhdl.txt
deleted file mode 100644
index 3fea947..0000000
--- a/sources_non_forked/ale/doc/ale-vhdl.txt
+++ /dev/null
@@ -1,92 +0,0 @@
-===============================================================================
-ALE VHDL Integration                                         *ale-vhdl-options*
-
-
-===============================================================================
-ALE can use three different linters for VHDL:
-
-  iverilog:
-    Using `iverilog -t null -Wall`
-
-  ModelSim/Questa
-    Using `vcom -2008 -quiet -lint`
-
-  Vivado
-    Using `xvhdl --2008`
-
-Note all linters default to VHDL-2008 support. This, and other options, can be
-changed with each linter's respective option variable.
-
-Linters/compilers that utilize a "work" directory for analyzing designs- such
-as ModelSim and Vivado- can be passed the location of these directories as
-part of their respective option strings listed below. This is useful for
-holistic analysis of a file (e.g. a design with components, packages, or other
-code defined external to the current file as part of a larger project) or
-when wanting to simply pass an alternative location for the auto-generated
-work directories (such as '/tmp') so as to not muddle the current directory.
-Since these type of linters often use this work directory for holding compiled
-design data as part of a single build process, they sometimes cannot handle
-the frequent, asynchronous application launches when linting while text is
-changing. This can happen in the form of hangs or crashes. To help prevent
-this when using these linters, it may help to run linting less frequently; for
-example, only when a file is saved.
-
-===============================================================================
-ghdl                                                            *ale-vhdl-ghdl*
-
-g:ale_vhdl_ghdl_executable                         *g:ale_vhdl_ghdl_executable*
-                                                   *b:ale_vhdl_ghdl_executable*
-  Type: |String|
-  Default: `'ghdl'`
-
-  This variable can be changed to the path to the 'ghdl' executable.
-
-
-g:ale_vhdl_ghdl_options                               *g:ale_vhdl_ghdl_options*
-                                                      *b:ale_vhdl_ghdl_options*
-  Type: |String|
-  Default: `'--std=08'`
-
-  This variable can be changed to modify the flags/options passed to 'ghdl'.
-
-
-===============================================================================
-vcom                                                            *ale-vhdl-vcom*
-
-g:ale_vhdl_vcom_executable                         *g:ale_vhdl_vcom_executable*
-                                                   *b:ale_vhdl_vcom_executable*
-  Type: |String|
-  Default: `'vcom'`
-
-  This variable can be changed to the path to the 'vcom' executable.
-
-
-g:ale_vhdl_vcom_options                               *g:ale_vhdl_vcom_options*
-                                                      *b:ale_vhdl_vcom_options*
-  Type: |String|
-  Default: `'-2008 -quiet -lint'`
-
-  This variable can be changed to modify the flags/options passed to 'vcom'.
-
-
-===============================================================================
-xvhdl                                                          *ale-vhdl-xvhdl*
-
-g:ale_vhdl_xvhdl_executable                       *g:ale_vhdl_xvhdl_executable*
-                                                  *b:ale_vhdl_xvhdl_executable*
-  Type: |String|
-  Default: `'xvhdl'`
-
-  This variable can be changed to the path to the 'xvhdl' executable.
-
-
-g:ale_vhdl_xvhdl_options                             *g:ale_vhdl_xvhdl_options*
-                                                     *b:ale_vhdl_xvhdl_options*
-  Type: |String|
-  Default: `'--2008'`
-
-  This variable can be changed to modify the flags/options passed to 'xvhdl'.
-
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-vim-help.txt b/sources_non_forked/ale/doc/ale-vim-help.txt
deleted file mode 100644
index 3cbe20d..0000000
--- a/sources_non_forked/ale/doc/ale-vim-help.txt
+++ /dev/null
@@ -1,12 +0,0 @@
-===============================================================================
-ALE Vim help Integration                                 *ale-vim-help-options*
-
-
-===============================================================================
-write-good                                            *ale-vim-help-write-good*
-
-See |ale-write-good-options|
-
-
-===============================================================================
-vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-vim.txt b/sources_non_forked/ale/doc/ale-vim.txt
deleted file mode 100644
index f85b43e..0000000
--- a/sources_non_forked/ale/doc/ale-vim.txt
+++ /dev/null
@@ -1,82 +0,0 @@
-===============================================================================
-ALE Vim Integration                                           *ale-vim-options*
-
-
-===============================================================================
-vimls                                                           *ale-vim-vimls*
-
-  The `vim-language-server` is the engine that powers VimL editor support
-  using the Language Server Protocol.  See the installation instructions:
-  https://github.com/iamcco/vim-language-server#install
-
-g:ale_vim_vimls_executable                         *g:ale_vim_vimls_executable*
-                                                   *b:ale_vim_vimls_executable*
-  Type: |String|
-  Default: `'vim-language-server'`
-
-  This option can be set to change the executable path for vimls.
-
-
-g:ale_vim_vimls_config                                 *g:ale_vim_vimls_config*
-                                                       *b:ale_vim_vimls_config*
-  Type: |Dictionary|
-  Default: `{}`
-
-  Dictionary containing configuration settings that will be passed to the
-  language server. For example: >
-    {
-    \  'vim': {
-    \    'iskeyword': '@,48-57,_,192-255,-#',
-    \    'vimruntime': '',
-    \    'runtimepath': '',
-    \    'diagnostic': {
-    \      'enable': v:true
-    \    },
-    \    'indexes': {
-    \      'runtimepath': v:true,
-    \      'gap': 100,
-    \      'count': 3,
-    \      'projectRootPatterns' : ['.git', 'autoload', 'plugin']
-    \    },
-    \    'suggest': {
-    \      'fromVimruntime': v:true,
-    \      'fromRuntimepath': v:false
-    \    },
-    \  }
-    \}
-<
-  Consult the vim-language-server documentation for more information about
-  settings.
-
-
-g:ale_vim_vimls_use_global                         *g:ale_vim_vimls_use_global*
-                                                   *b:ale_vim_vimls_use_global*
-  Type: |Number|
-  Default: `get(g:, 'ale_use_global_executables', 0)`
-
-  See |ale-integrations-local-executables|
-
-
-===============================================================================
-vint                                                             *ale-vim-vint*
-
-g:ale_vim_vint_executable                           *g:ale_vim_vint_executable*
-                                                    *b:ale_vim_vint_executable*
-  Type: |String|
-  Default: `'vint'`
-
-  This option can be set to change the executable path for Vint.
-
-
-g:ale_vim_vint_show_style_issues             *g:ale_vim_vint_show_style_issues*
-                                             *b:ale_vim_vint_show_style_issues*
-  Type: |Number|
-  Default: `1`
-
-  This variable will enable/disable style issues for Vint. When this option
-  is disabled, only warnings and errors which are not purely style issues
-  will be reported.
-
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-vue.txt b/sources_non_forked/ale/doc/ale-vue.txt
deleted file mode 100644
index a2c2786..0000000
--- a/sources_non_forked/ale/doc/ale-vue.txt
+++ /dev/null
@@ -1,31 +0,0 @@
-===============================================================================
-ALE Vue Integration                                           *ale-vue-options*
-
-
-===============================================================================
-prettier                                                     *ale-vue-prettier*
-
-See |ale-javascript-prettier| for information about the available options.
-
-
-===============================================================================
-vls                                                               *ale-vue-vls*
-
-g:ale_vue_vls_executable                             *g:ale_vue_vls_executable*
-                                                     *b:ale_vue_vls_executable*
-  Type: |String|
-  Default: `'vls'`
-
-  See |ale-integrations-local-executables|
-
-
-g:ale_vue_vls_use_global                             *g:ale_vue_vls_use_global*
-                                                     *b:ale_vue_vls_use_global*
-  Type: |Number|
-  Default: `get(g:, 'ale_use_global_executables', 0)`
-
-  See |ale-integrations-local-executables|
-
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-xhtml.txt b/sources_non_forked/ale/doc/ale-xhtml.txt
deleted file mode 100644
index 3cc639e..0000000
--- a/sources_non_forked/ale/doc/ale-xhtml.txt
+++ /dev/null
@@ -1,12 +0,0 @@
-===============================================================================
-ALE XHTML Integration                                       *ale-xhtml-options*
-
-
-===============================================================================
-write-good                                               *ale-xhtml-write-good*
-
-See |ale-write-good-options|
-
-
-===============================================================================
-vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-xml.txt b/sources_non_forked/ale/doc/ale-xml.txt
deleted file mode 100644
index e43fdef..0000000
--- a/sources_non_forked/ale/doc/ale-xml.txt
+++ /dev/null
@@ -1,34 +0,0 @@
-===============================================================================
-ALE XML Integration                                           *ale-xml-options*
-
-
-===============================================================================
-xmllint                                                       *ale-xml-xmllint*
-
-g:ale_xml_xmllint_executable                     *g:ale_xml_xmllint_executable*
-                                                 *b:ale_xml_xmllint_executable*
-  Type: |String|
-  Default: `'xmllint'`
-
-  This variable can be set to change the path to xmllint.
-
-
-g:ale_xml_xmllint_options                           *g:ale_xml_xmllint_options*
-                                                    *b:ale_xml_xmllint_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be set to pass additional options to xmllint.
-
-
-g:ale_xml_xmllint_indentsize                     *g:ale_xml_xmllint_indentsize*
-                                                 *b:ale_xml_xmllint_indentsize*
-  Type: |Number|
-  Default: 2
-
-  This variable can be sent to specify the amount of spaces used for
-  indentation.
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
-
diff --git a/sources_non_forked/ale/doc/ale-yaml.txt b/sources_non_forked/ale/doc/ale-yaml.txt
deleted file mode 100644
index c9a12ea..0000000
--- a/sources_non_forked/ale/doc/ale-yaml.txt
+++ /dev/null
@@ -1,92 +0,0 @@
-===============================================================================
-ALE YAML Integration                                         *ale-yaml-options*
-
-===============================================================================
-prettier                                                    *ale-yaml-prettier*
-
-Website: https://github.com/prettier/prettier
-
-
-Installation
--------------------------------------------------------------------------------
-
-Install prettier either globally or locally: >
-
-  npm install prettier -g  # global
-  npm install prettier     # local
-<
-  
-===============================================================================
-swaglint                                                    *ale-yaml-swaglint*
-
-Website: https://github.com/byCedric/swaglint
-
-
-Installation
--------------------------------------------------------------------------------
-
-Install swaglint either globally or locally: >
-
-  npm install swaglint -g  # global
-  npm install swaglint     # local
-<
-
-Options
--------------------------------------------------------------------------------
-
-g:ale_yaml_swaglint_executable                 *g:ale_yaml_swaglint_executable*
-                                               *b:ale_yaml_swaglint_executable*
-  Type: |String|
-  Default: `'swaglint'`
-
-  This variable can be set to change the path to swaglint.
-
-
-g:ale_yaml_swaglint_use_global                 *g:ale_yaml_swaglint_use_global*
-                                               *b:ale_yaml_swaglint_use_global*
-  Type: |String|
-  Default: `get(g:, 'ale_use_global_executables', 0)`
-
-  See |ale-integrations-local-executables|
-
-
-===============================================================================
-yamllint                                                    *ale-yaml-yamllint*
-
-Website: https://github.com/adrienverge/yamllint
-
-
-Installation
--------------------------------------------------------------------------------
-
-Install yamllint in your a virtualenv directory, locally, or globally: >
-
-  pip install yamllint # After activating virtualenv
-  pip install --user yamllint # Install to ~/.local/bin
-  sudo pip install yamllint # Install globally
-
-See |g:ale_virtualenv_dir_names| for configuring how ALE searches for
-virtualenv directories.
-
-
-Options
--------------------------------------------------------------------------------
-
-g:ale_yaml_yamllint_executable                 *g:ale_yaml_yamllint_executable*
-                                               *b:ale_yaml_yamllint_executable*
-  Type: |String|
-  Default: `'yamllint'`
-
-  This variable can be set to change the path to yamllint.
-
-
-g:ale_yaml_yamllint_options                       *g:ale_yaml_yamllint_options*
-                                                  *b:ale_yaml_yamllint_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be set to pass additional options to yamllint.
-
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale-yang.txt b/sources_non_forked/ale/doc/ale-yang.txt
deleted file mode 100644
index ad61973..0000000
--- a/sources_non_forked/ale/doc/ale-yang.txt
+++ /dev/null
@@ -1,17 +0,0 @@
-===============================================================================
-ALE YANG Integration                                         *ale-yang-options*
-
-
-===============================================================================
-yang-lsp                                                         *ale-yang-lsp*
-
-g:ale_yang_lsp_executable                           *g:ale_yang_lsp_executable*
-                                                    *b:ale_yang_lsp_executable*
-  Type: |String|
-  Default: `'yang-language-server'`
-
-  This variable can be changed to use a different executable for yang-lsp.
-
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/doc/ale.txt b/sources_non_forked/ale/doc/ale.txt
deleted file mode 100644
index 724da57..0000000
--- a/sources_non_forked/ale/doc/ale.txt
+++ /dev/null
@@ -1,3750 +0,0 @@
-*ale.txt*	Plugin to lint and fix files asynchronously
-*ale*
-
-ALE - Asynchronous Lint Engine
-
-===============================================================================
-CONTENTS                                                         *ale-contents*
-
-  1. Introduction.........................|ale-introduction|
-  2. Supported Languages & Tools..........|ale-support|
-  3. Linting..............................|ale-lint|
-    3.1 Adding Language Servers...........|ale-lint-language-servers|
-    3.2 Other Sources.....................|ale-lint-other-sources|
-  4. Fixing Problems......................|ale-fix|
-  5. Language Server Protocol Support.....|ale-lsp|
-    5.1 Completion........................|ale-completion|
-    5.2 Go To Definition..................|ale-go-to-definition|
-    5.3 Go To Type Definition.............|ale-go-to-type-definition|
-    5.4 Find References...................|ale-find-references|
-    5.5 Hovering..........................|ale-hover|
-    5.6 Symbol Search.....................|ale-symbol-search|
-  6. Global Options.......................|ale-options|
-    6.1 Highlights........................|ale-highlights|
-  7. Linter/Fixer Options.................|ale-integration-options|
-    7.1 Options for alex..................|ale-alex-options|
-    7.2 Options for languagetool..........|ale-languagetool-options|
-    7.3 Options for write-good............|ale-write-good-options|
-    7.4 Other Linter/Fixer Options........|ale-other-integration-options|
-  8. Commands/Keybinds....................|ale-commands|
-  9. API..................................|ale-api|
-  10. Special Thanks......................|ale-special-thanks|
-  11. Contact.............................|ale-contact|
-
-===============================================================================
-1. Introduction                                              *ale-introduction*
-
-ALE provides the means to run linters asynchronously in Vim in a variety of
-languages and tools. ALE sends the contents of buffers to linter programs
-using the |job-control| features available in Vim 8 and NeoVim. For Vim 8,
-Vim must be compiled with the |job| and |channel| and |timers| features
-as a minimum.
-
-ALE supports the following key features for linting:
-
-1. Running linters when text is changed.
-2. Running linters when files are opened.
-3. Running linters when files are saved. (When a global flag is set.)
-4. Populating the |loclist| with warning and errors.
-5. Setting |signs| with warnings and errors for error markers.
-6. Using |echo| to show error messages when the cursor moves.
-7. Setting syntax highlights for errors.
-
-ALE can fix problems with files with the |ALEFix| command, using the same job
-control functionality used for checking for problems. Try using the
-|ALEFixSuggest| command for browsing tools that can be used to fix problems
-for the current buffer.
-
-If you are interested in contributing to the development of ALE, read the
-developer documentation. See |ale-development|
-
-===============================================================================
-2. Supported Languages & Tools                                    *ale-support*
-
-ALE supports a wide variety of languages and tools. See |ale-supported-list|
-for the full list.
-
-===============================================================================
-3. Linting                                                           *ale-lint*
-
-ALE's primary focus is on checking for problems with your code with various
-programs via some Vim code for integrating with those programs, referred to
-as 'linters.' ALE supports a wide array of programs for linting by default,
-but additional programs can be added easily by defining files in |runtimepath|
-with the filename pattern `ale_linters/<filetype>/<filename>.vim`. For more
-information on defining new linters, see the extensive documentation
-for |ale#linter#Define()|.
-
-Without any configuration, ALE will attempt to check all of the code for every
-file you open in Vim with all available tools by default. To see what ALE
-is doing, and what options have been set, try using the |:ALEInfo| command.
-
-Most of the linters ALE runs will check the Vim buffer you are editing instead
-of the file on disk. This allows you to check your code for errors before you
-have even saved your changes. ALE will check your code in the following
-circumstances, which can be configured with the associated options.
-
-* When you modify a buffer.                - |g:ale_lint_on_text_changed|
-* On leaving insert mode.                  - |g:ale_lint_on_insert_leave|
-* When you open a new or modified buffer.  - |g:ale_lint_on_enter|
-* When you save a buffer.                  - |g:ale_lint_on_save|
-* When the filetype changes for a buffer.  - |g:ale_lint_on_filetype_changed|
-* If ALE is used to check code manually.   - |:ALELint|
-
-                                                 *ale-lint-settings-on-startup*
-
-It is worth reading the documentation for every option. You should configure
-which events ALE will use before ALE is loaded, so it can optimize which
-autocmd commands to run. You can force autocmd commands to be reloaded with
-`:ALEDisable | ALEEnable`
-
-This also applies to the autocmd commands used for |g:ale_echo_cursor|.
-
-                                                        *ale-lint-file-linters*
-
-Some programs must be run against files which have been saved to disk, and
-simply do not support reading temporary files or stdin, either of which are
-required for ALE to be able to check for errors as you type. The programs
-which behave this way are documented in the lists and tables of supported
-programs. ALE will only lint files with these programs in the following
-circumstances.
-
-* When you open a new or modified buffer.  - |g:ale_lint_on_enter|
-* When you save a buffer.                  - |g:ale_lint_on_save|
-* When the filetype changes for a buffer.  - |g:ale_lint_on_filetype_changed|
-* If ALE is used to check code manually.   - |:ALELint|
-
-ALE will report problems with your code in the following ways, listed with
-their relevant options.
-
-* By updating loclist. (On by default)             - |g:ale_set_loclist|
-* By updating quickfix. (Off by default)           - |g:ale_set_quickfix|
-* By setting error highlights.                     - |g:ale_set_highlights|
-* By creating signs in the sign column.            - |g:ale_set_signs|
-* By echoing messages based on your cursor.        - |g:ale_echo_cursor|
-* By inline text based on your cursor.             - |g:ale_virtualtext_cursor|
-* By displaying the preview based on your cursor.  - |g:ale_cursor_detail|
-* By showing balloons for your mouse cursor        - |g:ale_set_balloons|
-
-Please consult the documentation for each option, which can reveal some other
-ways of tweaking the behaviour of each way of displaying problems. You can
-disable or enable whichever options you prefer.
-
-Most settings can be configured for each buffer. (|b:| instead of |g:|),
-including disabling ALE for certain buffers with |b:ale_enabled|. The
-|g:ale_pattern_options| setting can be used to configure files differently
-based on regular expressions for filenames. For configuring entire projects,
-the buffer-local options can be used with external plugins for reading Vim
-project configuration files. Buffer-local settings can also be used in
-ftplugin files for different filetypes.
-
-ALE offers several options for controlling which linters are run.
-
-* Selecting linters to run.            - |g:ale_linters|
-* Aliasing filetypes for linters       - |g:ale_linter_aliases|
-* Only running linters you asked for.  - |g:ale_linters_explicit|
-* Disabling only a subset of linters.  - |g:ale_linters_ignore|
-* Disabling LSP linters and `tsserver`.  - |g:ale_disable_lsp|
-
-
--------------------------------------------------------------------------------
-3.1 Adding Language Servers                         *ale-lint-language-servers*
-
-ALE comes with many default configurations for language servers, so they can
-be detected and run automatically. ALE can connect to other language servers
-by defining a new linter for a filetype. New linters can be defined in |vimrc|,
-in plugin files, or `ale_linters` directories in |runtimepath|.
-
-See |ale-linter-loading-behavior| for more information on loading linters.
-
-A minimal configuration for a language server linter might look so. >
-
-  call ale#linter#Define('filetype_here', {
-  \   'name': 'any_name_you_want',
-  \   'lsp': 'stdio',
-  \   'executable': '/path/to/executable',
-  \   'command': '%e run',
-  \   'project_root': '/path/to/root_of_project',
-  \})
-<
-For language servers that use a TCP socket connection, you should define the
-address to connect to instead. >
-
-  call ale#linter#Define('filetype_here', {
-  \   'name': 'any_name_you_want',
-  \   'lsp': 'socket',
-  \   'address': 'servername:1234',
-  \   'project_root': '/path/to/root_of_project',
-  \})
-<
-  Most of the options for a language server can be replaced with a |Funcref|
-  for a function accepting a buffer number for dynamically computing values
-  such as the executable path, the project path, the server address, etc,
-  most of which can also be determined based on executing some other
-  asynchronous task. See |ale#command#Run()| for computing linter options
-  based on asynchronous results.
-
-  See |ale#linter#Define()| for a detailed explanation of all of the options
-  for configuring linters.
-
-
--------------------------------------------------------------------------------
-3.2 Other Sources                                      *ale-lint-other-sources*
-
-Problems for a buffer can be taken from other sources and rendered by ALE.
-This allows ALE to be used in combination with other plugins which also want
-to display any problems they might find with a buffer. ALE's API includes the
-following components for making this possible.
-
-* |ale#other_source#StartChecking()| - Tell ALE that a buffer is being checked.
-* |ale#other_source#ShowResults()|   - Show results from another source.
-* |ALEWantResults|                   - A signal for when ALE wants results.
-
-Other resources can provide results for ALE to display at any time, following
-ALE's loclist format. (See |ale-loclist-format|) For example: >
-
-  " Tell ALE to show some results.
-  " This function can be called at any time.
-  call ale#other_source#ShowResults(bufnr(''), 'some-linter-name', [
-  \ {'text': 'Something went wrong', 'lnum': 13},
-  \])
-<
-
-Other sources should use a unique name for identifying themselves. A single
-linter name can be used for all problems from another source, or a series of
-unique linter names can be used. Results can be cleared for that source by
-providing an empty List.
-
-|ale#other_source#StartChecking()| should be called whenever another source
-starts checking a buffer, so other tools can know that a buffer is being
-checked by some plugin. The |ALEWantResults| autocmd event can be used to
-start checking a buffer for problems every time that ALE does. When
-|ALEWantResults| is signaled, |g:ale_want_results_buffer| will be set to the
-number of the buffer that ALE wants to check.
-|ale#other_source#StartChecking()| should be called synchronously, and other
-sources should perform their checks on a buffer in the background
-asynchronously, so they don't interrupt editing.
-
-A plugin might integrate its own checks with ALE like so: >
-
-  augroup SomeGroupName
-    autocmd!
-    autocmd User ALEWantResults call Hook(g:ale_want_results_buffer)
-  augroup END
-
-  function! DoBackgroundWork(buffer) abort
-    " Start some work in the background here.
-    " ...
-    " Then call WorkDone(a:buffer, results)
-  endfunction
-
-  function! Hook(buffer) abort
-    " Tell ALE we're going to check this buffer.
-    call ale#other_source#StartChecking(a:buffer, 'some-name')
-    call DoBackgroundWork(a:buffer)
-  endfunction
-
-  function! WorkDone(buffer, results) abort
-    " Send results to ALE after they have been collected.
-    call ale#other_source#ShowResults(buffer, 'some-name', a:results)
-  endfunction
-<
-
-===============================================================================
-4. Fixing Problems                                                    *ale-fix*
-
-ALE can fix problems with files with the |ALEFix| command. |ALEFix|
-accepts names of fixers to be applied as arguments. Alternatively,
-when no arguments are provided, the variable |g:ale_fixers| will be
-read for getting a |List| of commands for filetypes, split on `.`, and
-the functions named in |g:ale_fixers| will be executed for fixing the
-errors.
-
-The |ALEFixSuggest| command can be used to suggest tools that be used to
-fix problems for the current buffer.
-
-The values for `g:ale_fixers` can be a list of |String|, |Funcref|, or
-|lambda| values. String values must either name a function, or a short name
-for a function set in the ALE fixer registry.
-
-Each function for fixing errors must accept either one argument `(buffer)` or
-two arguments `(buffer, lines)`, representing the buffer being fixed and the
-lines to fix. The functions must return either `0`, for changing nothing, a
-|List| for new lines to set, a |Dictionary| for describing a command to be
-run in the background, or the result of |ale#command#Run()|.
-
-Functions receiving a variable number of arguments will not receive the second
-argument `lines`. Functions should name two arguments if the `lines` argument
-is desired. This is required to avoid unnecessary copying of the lines of
-the buffers being checked.
-
-When a |Dictionary| is returned for an |ALEFix| callback, the following keys
-are supported for running the commands.
-
-  `command`             A |String| for the command to run. This key is required.
-
-                      When `%t` is included in a command string, a temporary
-                      file will be created, containing the lines from the file
-                      after previous adjustment have been done.
-
-  `read_temporary_file` When set to `1`, ALE will read the contents of the
-                      temporary file created for `%t`. This option can be used
-                      for commands which need to modify some file on disk in
-                      order to fix files.
-
-  `process_with`        An optional callback for post-processing.
-
-                      The callback must accept two arguments,
-                      `(buffer, output)`, which can be used for converting
-                      the output from a command into lines to replace the
-                      buffer's contents with.
-
-                      A |List| of |String|s must be returned.
-
-  `read_buffer`         An optional key for disabling reading the buffer.
-
-                      When set to `0`, ALE will not pipe the buffer's data
-                      into the command via stdin. This option is ignored and
-                      the buffer is not read when `read_temporary_file` is
-                      `1`.
-
-                      This option defaults to `1`.
-
-                                                        *ale-fix-configuration*
-
-Synchronous functions and asynchronous jobs will be run in a sequence for
-fixing files, and can be combined. For example:
->
-  let g:ale_fixers = {
-  \   'javascript': [
-  \       'DoSomething',
-  \       'eslint',
-  \       {buffer, lines -> filter(lines, 'v:val !=~ ''^\s*//''')},
-  \   ],
-  \}
-
-  ALEFix
-<
-The above example will call a function called `DoSomething` which could act
-upon some lines immediately, then run `eslint` from the ALE registry, and
-then call a lambda function which will remove every single line comment
-from the file.
-
-For buffer-local settings, such as in |g:ale_pattern_options| or in ftplugin
-files, a |List| may be used for configuring the fixers instead.
->
-  " Same as the above, only a List can be used instead of a Dictionary.
-  let b:ale_fixers = [
-  \   'DoSomething',
-  \   'eslint',
-  \   {buffer, lines -> filter(lines, 'v:val !=~ ''^\s*//''')},
-  \]
-
-  ALEFix
-<
-For convenience, a plug mapping is defined for |ALEFix|, so you can set up a
-keybind easily for fixing files. >
-
-  " Bind F8 to fixing problems with ALE
-  nmap <F8> <Plug>(ale_fix)
-<
-Files can be fixed automatically with the following options, which are all off
-by default.
-
-|g:ale_fix_on_save| - Fix files when they are saved.
-
-Fixers can be disabled on save with |g:ale_fix_on_save_ignore|. They will
-still be run when you manually run |ALEFix|.
-
-
-===============================================================================
-5. Language Server Protocol Support                                   *ale-lsp*
-
-ALE offers some support for integrating with Language Server Protocol (LSP)
-servers. LSP linters can be used in combination with any other linter, and
-will automatically connect to LSP servers when needed. ALE also supports
-`tsserver` for TypeScript, which uses a different but very similar protocol.
-
-If you want to use another plugin for LSP features and tsserver, you can use
-the |g:ale_disable_lsp| setting to disable ALE's own LSP integrations, or
-ignore particular linters with |g:ale_linters_ignore|.
-
--------------------------------------------------------------------------------
-5.1 Completion                                                 *ale-completion*
-
-ALE offers support for automatic completion of code while you type.
-Completion is only supported while at least one LSP linter is enabled. ALE
-will only suggest symbols provided by the LSP servers.
-
-                                                     *ale-deoplete-integration*
-
-ALE integrates with Deoplete for offering automatic completion data. ALE's
-completion source for Deoplete is named `'ale'`, and should enabled
-automatically if Deoplete is enabled and configured correctly. Deoplete
-integration should not be combined with ALE's own implementation.
-
-                                                 *ale-asyncomplete-integration*
-
-ALE additionally integrates with asyncomplete.vim for offering automatic
-completion data. ALE's asyncomplete source requires registration and should
-use the defaults provided by the|asyncomplete#sources#ale#get_source_options| function >
-
-  " Use ALE's function for asyncomplete defaults
-  au User asyncomplete_setup call asyncomplete#register_source(asyncomplete#sources#ale#get_source_options({
-      \ 'priority': 10, " Provide your own overrides here
-      \ }))
->
-ALE also offers its own completion implementation, which does not require any
-other plugins. Suggestions will be made while you type after completion is
-enabled. ALE's own completion implementation can be enabled by setting
-|g:ale_completion_enabled| to `1`. This setting must be set to `1` before ALE
-is loaded. The delay for completion can be configured with
-|g:ale_completion_delay|. This setting should not be enabled if you wish to
-use ALE as a completion source for other plugins.
-
-ALE provides an 'omnifunc' function |ale#completion#OmniFunc| for triggering
-completion manually with CTRL-X CTRL-O. |i_CTRL-X_CTRL-O| >
-
-  " Use ALE's function for omnicompletion.
-  set omnifunc=ale#completion#OmniFunc
-<
-ALE will only suggest so many possible matches for completion. The maximum
-number of items can be controlled with |g:ale_completion_max_suggestions|.
-
-If you don't like some of the suggestions you see, you can filter them out
-with |g:ale_completion_excluded_words| or |b:ale_completion_excluded_words|.
-
-The |ALEComplete| command can be used to show completion suggestions manually,
-even when |g:ale_completion_enabled| is set to `0`. For manually requesting
-completion information with Deoplete, consult Deoplete's documentation.
-
-When working with TypeScript files, ALE by can support automatic imports
-from external modules. This behavior can be enabled by setting the
-|g:ale_completion_tsserver_autoimport| variable to `1`.
-
-                                               *ale-completion-completeopt-bug*
-
-ALE Automatic completion implementation replaces |completeopt| before opening
-the omnicomplete menu with <C-x><C-o>. In some versions of Vim, the value set
-for the option will not be respected. If you experience issues with Vim
-automatically inserting text while you type, set the following option in
-vimrc, and your issues should go away. >
-
-  set completeopt=menu,menuone,preview,noselect,noinsert
-<
-
-Or alternatively, if you want to show documentation in popups: >
-
-  set completeopt=menu,menuone,popup,noselect,noinsert
-<
-                                                                  *ale-symbols*
-
-ALE provides a set of basic completion symbols. If you want to replace those
-symbols with others, you can set the variable |g:ale_completion_symbols| with
-a mapping of the type of completion to the symbol or other string that you
-would like to use. An example here shows the available options for symbols  >
-
-  let g:ale_completion_symbols = {
-  \ 'text': '',
-  \ 'method': '',
-  \ 'function': '',
-  \ 'constructor': '',
-  \ 'field': '',
-  \ 'variable': '',
-  \ 'class': '',
-  \ 'interface': '',
-  \ 'module': '',
-  \ 'property': '',
-  \ 'unit': 'unit',
-  \ 'value': 'val',
-  \ 'enum': '',
-  \ 'keyword': 'keyword',
-  \ 'snippet': '',
-  \ 'color': 'color',
-  \ 'file': '',
-  \ 'reference': 'ref',
-  \ 'folder': '',
-  \ 'enum member': '',
-  \ 'constant': '',
-  \ 'struct': '',
-  \ 'event': 'event',
-  \ 'operator': '',
-  \ 'type_parameter': 'type param',
-  \ '<default>': 'v'
-  \ }
-<
--------------------------------------------------------------------------------
-5.2 Go To Definition                                     *ale-go-to-definition*
-
-ALE supports jumping to the files and locations where symbols are defined
-through any enabled LSP linters. The locations ALE will jump to depend on the
-information returned by LSP servers. The |ALEGoToDefinition| command will jump
-to the definition of symbols under the cursor. See the documentation for the
-command for configuring how the location will be displayed.
-
-ALE will update Vim's |tagstack| automatically unless |g:ale_update_tagstack| is
-set to `0`.
-
--------------------------------------------------------------------------------
-5.3 Go To Type Definition                           *ale-go-to-type-definition*
-
-ALE supports jumping to the files and locations where symbols' types are
-defined through any enabled LSP linters. The locations ALE will jump to depend
-on the information returned by LSP servers. The |ALEGoToTypeDefinition|
-command will jump to the definition of symbols under the cursor. See the
-documentation for the command for configuring how the location will be
-displayed.
-
--------------------------------------------------------------------------------
-5.4 Find References                                       *ale-find-references*
-
-ALE supports finding references for symbols though any enabled LSP linters.
-ALE will display a preview window showing the places where a symbol is
-referenced in a codebase when a command is run. The following commands are
-supported:
-
-|ALEFindReferences| - Find references for the word under the cursor.
-
-Options:
-  `-relative`       Show file paths in the results relative to the working dir
-
--------------------------------------------------------------------------------
-5.5 Hovering                                                        *ale-hover*
-
-ALE supports "hover" information for printing brief information about symbols
-at the cursor taken from LSP linters. The following commands are supported:
-
-|ALEHover| - Print information about the symbol at the cursor.
-
-If |g:ale_set_balloons| is set to `1` and your version of Vim supports the
-|balloon_show()| function, then "hover" information also show up when you move
-the mouse over a symbol in a buffer. Diagnostic information will take priority
-over hover information for balloons. If a line contains a problem, that
-problem will be displayed in a balloon instead of hover information.
-
-Hover information can be displayed in the preview window instead by setting
-|g:ale_hover_to_preview| to `1`.
-
-For Vim 8.1+ terminals, mouse hovering is disabled by default. Enabling
-|balloonexpr| commands in terminals can cause scrolling issues in terminals,
-so ALE will not attempt to show balloons unless |g:ale_set_balloons| is set to
-`1` before ALE is loaded.
-
-For enabling mouse support in terminals, you may have to change your mouse
-settings. For example: >
-
-  " Example mouse settings.
-  " You will need to try different settings, depending on your terminal.
-  set mouse=a
-  set ttymouse=xterm
-<
-
-Documentation for symbols at the cursor can be retrieved using the
-|ALEDocumentation| command. This command is only available for `tsserver`.
-
--------------------------------------------------------------------------------
-5.6 Symbol Search                                           *ale-symbol-search*
-
-ALE supports searching for workspace symbols via LSP linters. The following
-commands are supported:
-
-|ALESymbolSearch| - Search for symbols in the workspace.
-
-Options:
-  `-relative`     Show file paths in the results relative to the working dir
-
-===============================================================================
-6. Global Options                                                 *ale-options*
-
-g:airline#extensions#ale#enabled             *g:airline#extensions#ale#enabled*
-
-  Type: |Number|
-  Default: `1`
-
-  Enables or disables the |airline|'s native extension for ale, which displays
-  warnings and errors in the status line, prefixed by
-  |airline#extensions#ale#error_symbol| and
-  |airline#extensions#ale#warning_symbol|.
-
-
-g:ale_cache_executable_check_failures   *g:ale_cache_executable_check_failures*
-
-  Type: |Number|
-  Default: undefined
-
-  When set to `1`, ALE will cache failing executable checks for linters. By
-  default, only executable checks which succeed will be cached.
-
-  When this option is set to `1`, Vim will have to be restarted after new
-  executables are installed for ALE to be able to run linters for those
-  executables.
-
-
-g:ale_change_sign_column_color                 *g:ale_change_sign_column_color*
-
-  Type: |Number|
-  Default: `0`
-
-  When set to `1`, this option will set different highlights for the sign
-  column itself when ALE reports problems with a file. This option can be
-  combined with |g:ale_sign_column_always|.
-
-  ALE uses the following highlight groups for highlighting the sign column:
-
-  `ALESignColumnWithErrors`    -  Links to `error` by default.
-  `ALESignColumnWithoutErrors` -  Uses the value for `SignColumn` by default.
-
-  The sign column color can only be changed globally in Vim. The sign column
-  might produce unexpected results if editing different files in split
-  windows.
-
-
-g:ale_close_preview_on_insert                   *g:ale_close_preview_on_insert*
-
-  Type: |Number|
-  Default: `0`
-
-  When this option is set to `1`, ALE's |preview-window| will be automatically
-  closed upon entering Insert Mode. This option can be used in combination
-  with |g:ale_cursor_detail| for automatically displaying the preview window
-  on problem lines, and automatically closing it again when editing text.
-
-  This setting must be set to `1` before ALE is loaded for this behavior
-  to be enabled. See |ale-lint-settings-on-startup|.
-
-
-g:ale_command_wrapper                                   *g:ale_command_wrapper*
-                                                        *b:ale_command_wrapper*
-  Type: |String|
-  Default: `''`
-
-  An option for wrapping all commands that ALE runs, for linters, fixers,
-  and LSP commands. This option can be set globally, or for specific buffers.
-
-  This option can be used to apply nice to all commands. For example: >
-
-    " Prefix all commands with nice.
-    let g:ale_command_wrapper = 'nice -n5'
-<
-  Use the |ALEInfo| command to view the commands that are run. All of the
-  arguments for commands will be put on the end of the wrapped command by
-  default. A `%*` marker can be used to spread the arguments in the wrapped
-  command. >
-
-    " Has the same effect as the above.
-    let g:ale_command_wrapper = 'nice -n5 %*'
-<
-
-  For passing all of the arguments for a command as one argument to a wrapper,
-  `%@` can be used instead. >
-
-    " Will result in say: /bin/bash -c 'other-wrapper -c "some command" -x'
-    let g:ale_command_wrapper = 'other-wrapper -c %@ -x'
-<
-  For commands including `&&` or `;`, only the last command in the list will
-  be passed to the wrapper. `&&` is most commonly used in ALE to change the
-  working directory before running a command.
-
-
-g:ale_completion_delay                                 *g:ale_completion_delay*
-
-  Type: |Number|
-  Default: `100`
-
-  The number of milliseconds before ALE will send a request to a language
-  server for completions after you have finished typing.
-
-  See |ale-completion|
-
-
-g:ale_completion_enabled                             *g:ale_completion_enabled*
-                                                     *b:ale_completion_enabled*
-
-  Type: |Number|
-  Default: `0`
-
-  When this option is set to `1`, completion support will be enabled.
-
-  This setting must be set to `1` before ALE is loaded for this behavior
-  to be enabled.
-
-  This setting should not be enabled if you wish to use ALE as a completion
-  source for other completion plugins.
-
-  A buffer-local version of this setting `b:ale_completion_enabled` can be set
-  to `0` to disable ALE's automatic completion support for a single buffer.
-  ALE's completion support must be enabled globally to be enabled locally.
-
-  See |ale-completion|
-
-
-g:ale_completion_tsserver_autoimport     *g:ale_completion_tsserver_autoimport*
-
-  Type: Number
-  Default: `0`
-
-  When this option is set to `0`, ALE will not try to automatically import
-  completion results from external modules. It can be enabled by setting it
-  to `1`.
-
-
-g:ale_completion_excluded_words               *g:ale_completion_excluded_words*
-                                              *b:ale_completion_excluded_words*
-  Type: |List|
-  Default: `[]`
-
-  This option can be set to a list of |String| values for "words" to exclude
-  from completion results, as in the words for |complete-items|. The strings
-  will be matched exactly in a case-sensitive manner. (|==#|)
-
-  This setting can be configured in ftplugin files with buffer variables, so
-  that different lists can be used for different filetypes. For example: >
-
-  " In ~/.vim/ftplugin/typescript.vim
-
-  " Don't suggest `it` or `describe` so we can use snippets for those words.
-  let b:ale_completion_excluded_words = ['it', 'describe']
-<
-
-g:ale_completion_symbols                             *g:ale_completion_symbols*
-
-  Type: |Dictionary|
-
-
-  A mapping from completion types to symbols for completions. See
-  |ale-symbols| for more information.
-
-  By default, this mapping only uses built in Vim completion kinds, but it can
-  be updated to use any unicode character for the completion kind. For
-  example: >
-    let g:ale_completion_symbols = {
-    \ 'text': '',
-    \ 'method': '',
-    \ 'function': '',
-    \ 'constructor': '',
-    \ 'field': '',
-    \ 'variable': '',
-    \ 'class': '',
-    \ 'interface': '',
-    \ 'module': '',
-    \ 'property': '',
-    \ 'unit': 'v',
-    \ 'value': 'v',
-    \ 'enum': 't',
-    \ 'keyword': 'v',
-    \ 'snippet': 'v',
-    \ 'color': 'v',
-    \ 'file': 'v',
-    \ 'reference': 'v',
-    \ 'folder': 'v',
-    \ 'enum_member': 'm',
-    \ 'constant': 'm',
-    \ 'struct': 't',
-    \ 'event': 'v',
-    \ 'operator': 'f',
-    \ 'type_parameter': 'p',
-    \ '<default>': 'v'
-    \ })
-<
-
-g:ale_completion_max_suggestions             *g:ale_completion_max_suggestions*
-
-  Type: |Number|
-  Default: `50`
-
-  The maximum number of items ALE will suggest in completion menus for
-  automatic completion.
-
-  Setting this number higher will require more processing time, and may
-  suggest too much noise. Setting this number lower will require less
-  processing time, but some suggestions will not be included, so you might not
-  be able to see the suggestions you want.
-
-  Adjust this option as needed, depending on the complexity of your codebase
-  and your available processing power.
-
-g:ale_cursor_detail                                       *g:ale_cursor_detail*
-
-  Type: |Number|
-  Default: `0`
-
-  When this option is set to `1`, ALE's |preview-window| will be automatically
-  opened when the cursor moves onto lines with problems. ALE will search for
-  problems using the same logic that |g:ale_echo_cursor| uses. The preview
-  window will be closed automatically when you move away from the line.
-
-  Messages are only displayed after a short delay. See |g:ale_echo_delay|.
-
-  The preview window is opened without stealing focus, which means your cursor
-  will stay in the same buffer as it currently is.
-
-  The preview window can be closed automatically upon entering Insert mode
-  by setting |g:ale_close_preview_on_insert| to `1`.
-
-  Either this setting or |g:ale_echo_cursor| must be set to `1` before ALE is
-  loaded for messages to be displayed. See |ale-lint-settings-on-startup|.
-
-
-g:ale_default_navigation                             *g:ale_default_navigation*
-                                                     *b:ale_default_navigation*
-
-  Type: |String|
-  Default: `'buffer'`
-
-  The default method for navigating away from the current buffer to another
-  buffer, such as for |ALEFindReferences:|, or |ALEGoToDefinition|.
-
-
-g:ale_disable_lsp                                           *g:ale_disable_lsp*
-                                                            *b:ale_disable_lsp*
-
-  Type: |Number|
-  Default: `0`
-
-  When this option is set to `1`, ALE ignores all linters powered by LSP,
-  and also `tsserver`.
-
-  Please see also |ale-lsp|.
-
-
-g:ale_echo_cursor                                           *g:ale_echo_cursor*
-
-  Type: |Number|
-  Default: `1`
-
-  When this option is set to `1`, a truncated message will be echoed when a
-  cursor is near a warning or error. ALE will attempt to find the warning or
-  error at a column nearest to the cursor when the cursor is resting on a line
-  which contains a warning or error. This option can be set to `0` to disable
-  this behavior.
-
-  Messages are only displayed after a short delay. See |g:ale_echo_delay|.
-
-  The format of the message can be customized with |g:ale_echo_msg_format|.
-
-  Either this setting or |g:ale_cursor_detail| must be set to `1` before ALE
-  is loaded for messages to be displayed. See |ale-lint-settings-on-startup|.
-
-
-g:ale_echo_delay                                             *g:ale_echo_delay*
-                                                             *b:ale_echo_delay*
-  Type: |Number|
-  Default: `10`
-
-  Given any integer, this option controls the number of milliseconds before
-  ALE will echo or preview a message for a problem near the cursor.
-
-  The value can be increased to decrease the amount of processing ALE will do
-  for files displaying a large number of problems.
-
-
-g:ale_echo_msg_error_str                             *g:ale_echo_msg_error_str*
-
-  Type: |String|
-  Default: `'Error'`
-
-  The string used for `%severity%` for errors. See |g:ale_echo_msg_format|
-
-
-g:ale_echo_msg_format                                   *g:ale_echo_msg_format*
-                                                        *b:ale_echo_msg_format*
-
-  Type: |String|
-  Default: `'%code: %%s'`
-
-  This variable defines a message format for echoed messages. The following
-  sequences of characters will be replaced.
-
-    `%s`           - replaced with the text for the problem
-    `%...code...% `- replaced with the error code
-    `%linter%`     - replaced with the name of the linter
-    `%severity%`   - replaced with the severity of the problem
-
-  The strings for `%severity%` can be configured with the following options.
-
-    |g:ale_echo_msg_error_str|   - Defaults to `'Error'`
-    |g:ale_echo_msg_info_str|    - Defaults to `'Info'`
-    |g:ale_echo_msg_warning_str| - Defaults to `'Warning'`
-
-  `%code%` is replaced with the error code, and replaced with an empty string
-  when there is no error code. Any extra characters between the percent signs
-  will be printed when an error code is present. For example, a message like
-  `(error code): message` will be printed for `'%(code): %%s'` and simply the
-  message will be printed when there is no code.
-
-  |g:ale_echo_cursor| needs to be set to 1 for messages to be displayed.
-
-  The echo message format can also be configured separately for each buffer,
-  so different formats can be used for different languages. (Say in ftplugin
-  files.)
-
-
-g:ale_echo_msg_info_str                               *g:ale_echo_msg_info_str*
-
-  Type: |String|
-  Default: `'Info'`
-
-  The string used for `%severity%` for info. See |g:ale_echo_msg_format|
-
-
-g:ale_echo_msg_log_str                                 *g:ale_echo_msg_log_str*
-
-  Type: |String|
-  Default: `'Log'`
-
-  The string used for `%severity%` for log, used only for handling LSP show
-  message requests. See |g:ale_lsp_show_message_format|
-
-
-g:ale_echo_msg_warning_str                         *g:ale_echo_msg_warning_str*
-
-  Type: |String|
-  Default: `'Warning'`
-
-  The string used for `%severity%` for warnings. See |g:ale_echo_msg_format|
-
-
-g:ale_enabled                                                   *g:ale_enabled*
-                                                                *b:ale_enabled*
-
-  Type: |Number|
-  Default: `1`
-
-  When set to `0`, this option will completely disable ALE, such that no
-  error checking will be performed, etc. ALE can be toggled on and off with
-  the |ALEToggle| command, which changes this option.
-
-  ALE can be disabled in each buffer by setting `let b:ale_enabled = 0`
-  Disabling ALE based on filename patterns can be accomplished by setting
-  a regular expression for |g:ale_pattern_options|. For example: >
-
-  " Disable linting for all minified JS files.
-  let g:ale_pattern_options = {'\.min.js$': {'ale_enabled': 0}}
-<
-
-  See |g:ale_pattern_options| for more information on that option.
-
-
-g:ale_exclude_highlights                             *g:ale_exclude_highlights*
-                                                     *b:ale_exclude_highlights*
-
-  Type: |List|
-  Default: `[]`
-
-  A list of regular expressions for matching against highlight messages to
-  remove. For example: >
-
-  " Do not highlight messages matching strings like these.
-  let b:ale_exclude_highlights = ['line too long', 'foo.*bar']
-<
-  See also: |g:ale_set_highlights|
-
-
-g:ale_fixers                                                     *g:ale_fixers*
-                                                                 *b:ale_fixers*
-
-  Type: |Dictionary|
-  Default: `{}`
-
-  A mapping from filetypes to |List| values for functions for fixing errors.
-  See |ale-fix| for more information.
-
-  This variable can be overridden with variables in each buffer.
-  `b:ale_fixers` can be set to a |List| of callbacks instead, which can be
-  more convenient.
-
-  A special `'*'` key be used as a wildcard filetype for configuring fixers
-  for every other type of file. For example: >
-
-    " Fix Python files with 'bar'.
-    " Don't fix 'html' files.
-    " Fix everything else with 'foo'.
-    let g:ale_fixers = {'python': ['bar'], 'html': [], '*': ['foo']}
-<
-
-g:ale_fix_on_save                                           *g:ale_fix_on_save*
-                                                            *b:ale_fix_on_save*
-
-  Type: |Number|
-  Default: `0`
-
-  When set to 1, ALE will fix files when they are saved.
-
-  If |g:ale_lint_on_save| is set to 1, files will be checked with linters
-  after files are fixed, only when the buffer is open, or re-opened. Changes
-  to the file will be saved to the file on disk.
-
-  Files will not be fixed on `:wq`, so you should check your code before
-  closing a buffer.
-
-  Fixing files can be disabled or enabled for individual buffers by setting
-  `b:ale_fix_on_save` to `0` or `1`.
-
-  Some fixers can be excluded from being run automatically when you save files
-  with the |g:ale_fix_on_save_ignore| setting.
-
-
-g:ale_fix_on_save_ignore                             *g:ale_fix_on_save_ignore*
-                                                     *b:ale_fix_on_save_ignore*
-
-  Type: |Dictionary| or |List|
-  Default: `{}`
-
-  Given a |Dictionary| mapping filetypes to |Lists| of fixers to ignore, or
-  just a |List| of fixers to ignore, exclude those fixers from being run
-  automatically when files are saved.
-
-  You can disable some fixers in your ftplugin file: >
-
-  " Disable fixers 'b' and 'c' when fixing on safe for this buffer.
-  let b:ale_fix_on_save_ignore = ['b', 'c']
-  " Alternatively, define ignore lists for different filetypes.
-  let b:ale_fix_on_save_ignore = {'foo': ['b'], 'bar': ['c']}
-<
-  You can disable some fixers globally per filetype like so: >
-
-  let g:ale_fixers = {'foo': ['a', 'b'], 'bar': ['c', 'd']}
-  let g:ale_fix_on_save = 1
-  " For filetype `foo.bar`, only fixers 'b' and 'd' will be run on save.
-  let g:ale_fix_on_save_ignore = {'foo': ['a'], 'bar': ['c']}
-  " Alternatively, disable these fixers on save for all filetypes.
-  let g:ale_fix_on_save_ignore = ['a', 'c']
-<
-  You can ignore fixers based on matching |Funcref| values too: >
-
-  let g:AddBar = {buffer, lines -> lines + ['bar']}
-  let g:ale_fixers = {'foo': g:AddBar}
-  " The lambda fixer will be ignored, as it will be found in the ignore list.
-  let g:ale_fix_on_save_ignore = [g:AddBar]
-<
-
-g:ale_history_enabled                                   *g:ale_history_enabled*
-
-  Type: |Number|
-  Default: `1`
-
-  When set to `1`, ALE will remember the last few commands which were run
-  for every buffer which is open. This information can be viewed with the
-  |ALEInfo| command. The size of the buffer can be controlled with the
-  |g:ale_max_buffer_history_size| option.
-
-  This option can be disabled if storing a command history is not desired.
-
-
-g:ale_history_log_output                             *g:ale_history_log_output*
-
-  Type: |Number|
-  Default: `1`
-
-  When set to `1`, ALE will store the output of commands which have completed
-  successfully in the command history, and the output will be displayed when
-  using |ALEInfo|.
-
-  |g:ale_history_enabled| must be set to `1` for this output to be stored or
-  printed.
-
-  Some memory will be consumed by this option. It is very useful for figuring
-  out what went wrong with linters, and for bug reports. Turn this option off
-  if you want to save on some memory usage.
-
-
-g:ale_hover_to_preview                                 *g:ale_hover_to_preview*
-                                                       *b:ale_hover_to_preview*
-
-  Type: |Number|
-  Default: `0`
-
-  If set to `1`, hover messages will be displayed in the preview window,
-  instead of in balloons or the message line.
-
-
-g:ale_keep_list_window_open                       *g:ale_keep_list_window_open*
-                                                  *b:ale_keep_list_window_open*
-  Type: |Number|
-  Default: `0`
-
-  When set to `1`, this option will keep the loclist or quickfix windows event
-  after all warnings/errors have been removed for files. By default the
-  loclist or quickfix windows will be closed automatically when there are no
-  warnings or errors.
-
-  See |g:ale_open_list|
-
-
-g:ale_list_window_size                                 *g:ale_list_window_size*
-                                                       *b:ale_list_window_size*
-  Type: |Number|
-  Default: `10`
-
-  This number configures the number of lines to set for the height of windows
-  opened automatically for ALE problems. The default of `10` matches the Vim
-  default height.
-
-  See |g:ale_open_list| for information on automatically opening windows
-  for quickfix or the loclist.
-
-
-g:ale_lint_delay                                             *g:ale_lint_delay*
-
-  Type: |Number|
-  Default: `200`
-
-  This variable controls the milliseconds delay after which the linters will
-  be run after text is changed. This option is only meaningful with the
-  |g:ale_lint_on_text_changed| variable set to `always`, `insert`, or `normal`.
-
-
-g:ale_lint_on_enter                                       *g:ale_lint_on_enter*
-
-  Type: |Number|
-  Default: `1`
-
-  When this option is set to `1`, the |BufWinEnter| event will be used to
-  apply linters when buffers are first opened. If this is not desired, this
-  variable can be set to `0` in your vimrc file to disable this behavior.
-
-  The |FileChangedShellPost| and |BufEnter| events will be used to check if
-  files have been changed outside of Vim. If a file is changed outside of
-  Vim, it will be checked when it is next opened.
-
-  You should set this setting once before ALE is loaded, and restart Vim if
-  you want to change your preferences. See |ale-lint-settings-on-startup|.
-
-
-g:ale_lint_on_filetype_changed                 *g:ale_lint_on_filetype_changed*
-
-  Type: |Number|
-  Default: `1`
-
-  This option will cause ALE to run when the filetype for a file is changed
-  after a buffer has first been loaded. A short delay will be used before
-  linting will be done, so the filetype can be changed quickly several times
-  in a row, but resulting in only one lint cycle.
-
-  You should set this setting once before ALE is loaded, and restart Vim if
-  you want to change your preferences. See |ale-lint-settings-on-startup|.
-
-
-g:ale_lint_on_save                                         *g:ale_lint_on_save*
-
-  Type: |Number|
-  Default: `1`
-
-  This option will make ALE run the linters whenever a file is saved when it
-  it set to `1` in your vimrc file. This option can be used in combination
-  with the |g:ale_lint_on_enter| and |g:ale_lint_on_text_changed| options to
-  make ALE only check files after that have been saved, if that is what is
-  desired.
-
-
-g:ale_lint_on_text_changed                         *g:ale_lint_on_text_changed*
-
-  Type: |String|
-  Default: `'normal'`
-
-  This option controls how ALE will check your files as you make changes.
-  The following values can be used.
-
-  `'always'`, `'1'`, or `1` - Check buffers on |TextChanged| or |TextChangedI|.
-  `'normal'`            - Check buffers only on |TextChanged|.
-  `'insert'`            - Check buffers only on |TextChangedI|.
-  `'never'`, `'0'`, or `0`  - Never check buffers on changes.
-
-  ALE will check buffers after a short delay, with a timer which resets on
-  each change. The delay can be configured by adjusting the |g:ale_lint_delay|
-  variable.
-                                               *ale-linting-interrupts-mapping*
-
-  Due to a bug in Vim, ALE can interrupt mappings with pending key presses,
-  per |timeoutlen|. If this happens, follow the advice for enabling
-  |g:ale_lint_on_insert_leave| below, and set this option to `'normal'`, or
-  disable it entirely.
-
-  You should set this setting once before ALE is loaded, and restart Vim if
-  you want to change your preferences. See |ale-lint-settings-on-startup|.
-
-
-g:ale_lint_on_insert_leave                         *g:ale_lint_on_insert_leave*
-                                                   *b:ale_lint_on_insert_leave*
-
-  Type: |Number|
-  Default: `1`
-
-  When set to `1` in your vimrc file, this option will cause ALE to run
-  linters when you leave insert mode.
-
-  ALE will not lint files when you escape insert mode with |CTRL-C| by
-  default. You can make ALE lint files with this option when you use |CTRL-C|
-  with the following mapping. >
-
-    " Make using Ctrl+C do the same as Escape, to trigger autocmd commands
-    inoremap <C-c> <Esc>
-<
-  A buffer-local version of this setting `b:ale_lint_on_insert_leave` can be
-  set to `0` to disable linting when leaving insert mode. The setting must
-  be enabled globally to be enabled locally.
-
-  You should set this setting once before ALE is loaded, and restart Vim if
-  you want to change your preferences. See |ale-lint-settings-on-startup|.
-
-
-g:ale_linter_aliases                                     *g:ale_linter_aliases*
-                                                         *b:ale_linter_aliases*
-  Type: |Dictionary|
-  Default: `{}`
-
-  The |g:ale_linter_aliases| option can be used to set aliases from one
-  filetype to another. A given filetype can be mapped to use the linters
-  run for another given filetype.
-
-  This |Dictionary| will be merged with a default dictionary containing the
-  following values: >
-
-  {
-  \   'Dockerfile': 'dockerfile',
-  \   'csh': 'sh',
-  \   'javascriptreact': ['javascript', 'jsx'],
-  \   'plaintex': 'tex',
-  \   'rmarkdown': 'r',
-  \   'rmd': 'r',
-  \   'systemverilog': 'verilog',
-  \   'typescriptreact': ['typescript', 'tsx'],
-  \   'verilog_systemverilog': ['verilog_systemverilog', 'verilog'],
-  \   'vimwiki': 'markdown',
-  \   'vue': ['vue', 'javascript'],
-  \   'xsd': ['xsd', 'xml'],
-  \   'xslt': ['xslt', 'xml'],
-  \   'zsh': 'sh',
-  \}
-<
-  For example, if you wish to map a new filetype `'foobar'` to run the `'php'`
-  linters, you could set the following: >
-
-  let g:ale_linter_aliases = {'foobar': 'php'}
-<
-  When combined with the |g:ale_linters| option, the original filetype
-  (`'foobar'`) will be used for determining which linters to run,
-  not the aliased type (`'php'`). This allows an aliased type to run a
-  different set of linters from the type it is being mapped to.
-
-  Passing a list of filetypes is also supported. Say you want to lint
-  javascript and css embedded in HTML (using linters that support that).
-  You could alias `html` like so:
-
-  `let g:ale_linter_aliases = {'html': ['html', 'javascript', 'css']}`
-
-  Note that `html` itself was included as an alias. That is because aliases
-  will override the original linters for the aliased filetype.
-
-  Linter aliases can be configured in each buffer with buffer-local variables.
-  ALE will first look for aliases for filetypes in the `b:ale_linter_aliases`
-  variable, then `g:ale_linter_aliases`, and then a default Dictionary.
-
-  `b:ale_linter_aliases` can be set to a |List| or a |String|, to tell ALE to
-  load the linters for specific filetypes for a given buffer. >
-
-  let b:ale_linter_aliases = ['html', 'javascript', 'css']
-  " OR, Alias a filetype to only a single filetype with a String.
-  let b:ale_linter_aliases = 'javascript'
-<
-  No linters will be loaded when the buffer's filetype is empty.
-
-g:ale_linters                                                   *g:ale_linters*
-                                                                *b:ale_linters*
-  Type: |Dictionary|
-  Default: `{}`
-
-  The |g:ale_linters| option sets a |Dictionary| mapping a filetype to a
-  |List| of linter programs to be run when checking particular filetypes.
-
-  This |Dictionary| will be merged with a default dictionary containing the
-  following values: >
-
-  {
-  \   'csh': ['shell'],
-  \   'elixir': ['credo', 'dialyxir', 'dogma'],
-  \   'go': ['gofmt', 'golint', 'go vet'],
-  \   'hack': ['hack'],
-  \   'help': [],
-  \   'perl': ['perlcritic'],
-  \   'perl6': [],
-  \   'python': ['flake8', 'mypy', 'pylint'],
-  \   'rust': ['cargo'],
-  \   'spec': [],
-  \   'text': [],
-  \   'vue': ['eslint', 'vls'],
-  \   'zsh': ['shell'],
-  \}
-<
-  This option can be used to enable only a particular set of linters for a
-  file. For example, you can enable only `eslint` for JavaScript files: >
-
-  let g:ale_linters = {'javascript': ['eslint']}
-<
-  If you want to disable all linters for a particular filetype, you can pass
-  an empty list of linters as the value: >
-
-  let g:ale_linters = {'javascript': []}
-<
-  All linters will be run for unspecified filetypes. All available linters can
-  be enabled explicitly for a given filetype by passing the string `'all'`,
-  instead of a List. >
-
-  let g:ale_linters = {'c': 'all'}
-<
-  Linters can be configured in each buffer with buffer-local variables. ALE
-  will first look for linters for filetypes in the `b:ale_linters` variable,
-  then `g:ale_linters`, and then the default Dictionary mentioned above.
-
-  `b:ale_linters` can be set to a List, or the string `'all'`. When linters
-  for two different filetypes share the same name, the first linter loaded
-  will be used. Any ambiguity can be resolved by using a Dictionary specifying
-  which linter to run for which filetype instead. >
-
-  " Use ESLint for the buffer if the filetype includes 'javascript'.
-  let b:ale_linters = {'javascript': ['eslint'], 'html': ['tidy']}
-  " Use a List for the same setting. This will work in most cases.
-  let b:ale_linters = ['eslint', 'tidy']
-  " Disable all linters for the buffer.
-  let b:ale_linters = []
-  " Explicitly enable all available linters for the filetype.
-  let b:ale_linters = 'all'
-<
-  ALE can be configured to disable all linters unless otherwise specified with
-  `g:ale_enabled` or `b:ale_enabled` with the option |g:ale_linters_explicit|.
-
-
-g:ale_linters_explicit                                 *g:ale_linters_explicit*
-
-  Type: |Number|
-  Default: `0`
-
-  When set to `1`, only the linters from |g:ale_linters| and |b:ale_linters|
-  will be enabled. The default behavior for ALE is to enable as many linters
-  as possible, unless otherwise specified.
-
-
-g:ale_linters_ignore                                     *g:ale_linters_ignore*
-                                                         *b:ale_linters_ignore*
-
-  Type: |Dictionary| or |List|
-  Default: `{}`
-
-  Linters to ignore. Commands for ignored linters will not be run, and
-  diagnostics for LSP linters will be ignored. (See |ale-lsp|)
-
-  This setting can be set to a |Dictionary| mapping filetypes to linter names,
-  just like |g:ale_linters|, to list linters to ignore. Ignore lists will be
-  applied after everything else. >
-
-  " Select flake8 and pylint, and ignore pylint, so only flake8 is run.
-  let g:ale_linters = {'python': ['flake8', 'pylint']}
-  let g:ale_linters_ignore = {'python': ['pylint']}
-<
-  This setting can be set to simply a |List| of linter names, which is
-  especially more convenient when using the setting in ftplugin files for
-  particular buffers. >
-
-  " The same as above, in a ftplugin/python.vim.
-  let b:ale_linters = ['flake8', 'pylint']
-  let b:ale_linters_ignore = ['pylint']
-<
-
-g:ale_list_vertical                                       *g:ale_list_vertical*
-                                                          *b:ale_list_vertical*
-  Type: |Number|
-  Default: `0`
-
-  When set to `1`, this will cause ALE to open any windows (loclist or
-  quickfix) vertically instead of horizontally (|vert| |lopen|) or (|vert|
-  |copen|)
-
-
-g:ale_loclist_msg_format                             *g:ale_loclist_msg_format*
-                                                     *b:ale_loclist_msg_format*
-
-  Type: |String|
-  Default: `g:ale_echo_msg_format`
-
-  This option is the same as |g:ale_echo_msg_format|, but for formatting the
-  message used for the loclist and the quickfix list.
-
-  The strings for configuring `%severity%` are also used for this option.
-
-
-g:ale_lsp_show_message_format                   *g:ale_lsp_show_message_format*
-
-  Type: |String|
-  Default: `'%severity%:%linter%: %s'`
-
-  This variable defines the format that messages received from an LSP will
-  have when echoed. The following sequences of characters will be replaced.
-
-    `%s`           - replaced with the message text
-    `%linter%`     - replaced with the name of the linter
-    `%severity%`   - replaced with the severity of the message
-
-  The strings for `%severity%` levels "error", "info" and "warning" are shared
-  with |g:ale_echo_msg_format|. Severity "log" is unique to
-  |g:ale_lsp_show_message_format| and it can be configured via
-
-    |g:ale_echo_msg_log_str|     - Defaults to `'Log'`
-
-  Please note that |g:ale_lsp_show_message_format| *can not* be configured
-  separately for each buffer like |g:ale_echo_msg_format| can.
-
-
-g:ale_lsp_show_message_severity               *g:ale_lsp_show_message_severity*
-
-  Type: |String|
-  Default: `'error'`
-
-  This variable defines the minimum severity level an LSP message needs to be
-  displayed. Messages below this level are discarded; please note that
-  messages with `Log` severity level are always discarded.
-
-  Possible values follow the LSP spec `MessageType` definition:
-
-  `'error'`       - Displays only errors.
-  `'warning'`     - Displays errors and warnings.
-  `'information'` - Displays errors, warnings and infos
-  `'log'`         - Same as `'information'`
-  `'disabled'`    - Doesn't display any information at all.
-
-
-g:ale_lsp_root                                                 *g:ale_lsp_root*
-                                                               *b:ale_lsp_root*
-
-  Type: |Dictionary| or |String|
-  Default: {}
-
-  This option is used to determine the project root for the LSP linter. If the
-  value is a |Dictionary|, it maps a linter to either a string containing the
-  project root or a |Funcref| to call to look up the root. The funcref is
-  provided the buffer number as its argument.
-
-  The buffer-specific variable may additionally be a string containing the
-  project root itself.
-
-  If neither variable yields a result, a linter-specific function is invoked to
-  detect a project root. If this, too, yields no result, the linter is disabled.
-
-g:ale_max_buffer_history_size                   *g:ale_max_buffer_history_size*
-
-  Type: |Number|
-  Default: `20`
-
-  This setting controls the maximum number of commands which will be stored in
-  the command history used for |ALEInfo|. Command history will be rotated in
-  a FIFO manner. If set to a number <= 0, then the history will be
-  continuously set to an empty |List|.
-
-  History can be disabled completely with |g:ale_history_enabled|.
-
-
-g:ale_max_signs                                               *g:ale_max_signs*
-                                                              *b:ale_max_signs*
-  Type: |Number|
-  Default: `-1`
-
-  When set to any positive integer, ALE will not render any more than the
-  given number of signs for any one buffer.
-
-  When set to `0`, no signs will be set, but sign processing will still be
-  done, so existing signs can be removed.
-
-  When set to any other value, no limit will be imposed on the number of signs
-  set.
-
-  For disabling sign processing, see |g:ale_set_signs|.
-
-
-g:ale_maximum_file_size                               *g:ale_maximum_file_size*
-                                                      *b:ale_maximum_file_size*
-  Type: |Number|
-  Default: undefined
-
-  A maximum file size in bytes for ALE to check. If set to any positive
-  number, ALE will skip checking files larger than the given size.
-
-
-g:ale_open_list                                               *g:ale_open_list*
-                                                              *b:ale_open_list*
-  Type: |Number| or |String|
-  Default: `0`
-
-  When set to `1`, this will cause ALE to automatically open a window for the
-  loclist (|lopen|) or for the quickfix list instead if |g:ale_set_quickfix|
-  is `1`. (|copen|)
-
-  When set to `'on_save'`, ALE will only open the loclist after buffers have
-  been saved. The list will be opened some time after buffers are saved and
-  any linter for a buffer returns results.
-
-  The window will be kept open until all warnings or errors are cleared,
-  including those not set by ALE, unless |g:ale_keep_list_window_open| is set
-  to `1`, in which case the window will be kept open when no problems are
-  found.
-
-  The window size can be configured with |g:ale_list_window_size|.
-
-  Windows can be opened vertically with |g:ale_list_vertical|.
-
-  If you want to close the loclist window automatically when the buffer is
-  closed, you can set up the following |autocmd| command: >
-
-  augroup CloseLoclistWindowGroup
-    autocmd!
-    autocmd QuitPre * if empty(&buftype) | lclose | endif
-  augroup END
-<
-
-g:ale_pattern_options                                   *g:ale_pattern_options*
-
-  Type: |Dictionary|
-  Default: undefined
-
-  This option maps regular expression patterns to |Dictionary| values for
-  buffer variables. This option can be set to automatically configure
-  different settings for different files. For example: >
-
-  " Use just ESLint for linting and fixing files which end in '.foo.js'
-  let g:ale_pattern_options = {
-  \   '\.foo\.js$': {
-  \       'ale_linters': ['eslint'],
-  \       'ale_fixers': ['eslint'],
-  \   },
-  \}
-<
-  See |b:ale_linters| and |b:ale_fixers| for information for those options.
-
-  Filenames are matched with |match()|, and patterns depend on the |magic|
-  setting, unless prefixed with the special escape sequences like `'\v'`, etc.
-  The patterns can match any part of a filename. The absolute path of the
-  filename will be used for matching, taken from `expand('%:p')`.
-
-  The options for every match for the filename will be applied, with the
-  pattern keys sorted in alphabetical order. Options for `'zebra'` will
-  override the options for `'alpha'` for a filename `alpha-zebra`.
-
-
-g:ale_pattern_options_enabled                   *g:ale_pattern_options_enabled*
-
-  Type: |Number|
-  Default: undefined
-
-  This option can be used for disabling pattern options. If set to `0`, ALE
-  will not set buffer variables per |g:ale_pattern_options|.
-
-
-g:ale_rename_tsserver_find_in_comments *g:ale_rename_tsserver_find_in_comments*
-
-  Type: |Number|
-  Default: `0`
-
-  If enabled, this option will tell tsserver to find and replace text in
-  comments when calling |ALERename|. It can be enabled by settings the value
-  to `1`.
-
-
-g:ale_rename_tsserver_find_in_strings   *g:ale_rename_tsserver_find_in_strings*
-
-
-  Type: |Number|
-  Default: `0`
-
-  If enabled, this option will tell tsserver to find and replace text in
-  strings when calling |ALERename|. It can be enabled by settings the value to
-  `1`.
-
-
-g:ale_set_balloons                                         *g:ale_set_balloons*
-                                                           *b:ale_set_balloons*
-
-  Type: |Number|
-  Default: `has('balloon_eval') && has('gui_running')`
-
-  When this option is set to `1`, balloon messages will be displayed for
-  problems or hover information if available.
-
-  Problems nearest to the line the mouse cursor is over will be displayed. If
-  there are no problems to show, and one of the linters is an LSP linter
-  supporting "Hover" information, per |ale-hover|, then brief information
-  about the symbol under the cursor will be displayed in a balloon.
-
-  Balloons can be enabled for terminal versions of Vim that support balloons,
-  but some versions of Vim will produce strange mouse behavior when balloons
-  are enabled. To configure balloons for your terminal, you should first
-  configure your |ttymouse| setting, and then consider setting
-  `g:ale_set_balloons` to `1` before ALE is loaded.
-
-  `b:ale_set_balloons` can be set to `0` to disable balloons for a buffer.
-  Balloons cannot be enabled for a specific buffer when not initially enabled
-  globally.
-
-  Balloons will not be shown when |g:ale_enabled| or |b:ale_enabled| is `0`.
-
-
-g:ale_set_balloons_legacy_echo                 *g:ale_set_balloons_legacy_echo*
-                                               *b:ale_set_balloons_legacy_echo*
-  Type: |Number|
-  Default: undefined
-
-  If set to `1`, moving your mouse over documents in Vim will make ALE ask
-  `tsserver` or `LSP` servers for information about the symbol where the mouse
-  cursor is, and print that information into Vim's echo line. This is an
-  option for supporting older versions of Vim which do not properly support
-  balloons in an asynchronous manner.
-
-  If your version of Vim supports the |balloon_show| function, then this
-  option does nothing meaningful.
-
-
-g:ale_set_highlights                                     *g:ale_set_highlights*
-
-  Type: |Number|
-  Default: `has('syntax')`
-
-  When this option is set to `1`, highlights will be set for problems.
-
-  ALE will use the following highlight groups for problems:
-
-  |ALEError|        - Items with `'type': 'E'`
-  |ALEWarning|      - Items with `'type': 'W'`
-  |ALEInfo.|        - Items with `'type': 'I'`
-  |ALEStyleError|   - Items with `'type': 'E'` and `'sub_type': 'style'`
-  |ALEStyleWarning| - Items with `'type': 'W'` and `'sub_type': 'style'`
-
-  When |g:ale_set_signs| is set to `0`, the following highlights for entire
-  lines will be set.
-
-  |ALEErrorLine|   - All items with `'type': 'E'`
-  |ALEWarningLine| - All items with `'type': 'W'`
-  |ALEInfoLine|    - All items with `'type': 'I'`
-
-  Vim can only highlight the characters up to the last column in a buffer for
-  match highlights, whereas the line highlights when signs are enabled will
-  run to the edge of the screen.
-
-  Highlights can be excluded with the |g:ale_exclude_highlights| option.
-
-
-g:ale_set_loclist                                           *g:ale_set_loclist*
-
-  Type: |Number|
-  Default: `1`
-
-  When this option is set to `1`, the |loclist| will be populated with any
-  warnings and errors which are found by ALE. This feature can be used to
-  implement jumping between errors through typical use of |lnext| and |lprev|.
-
-
-g:ale_set_quickfix                                         *g:ale_set_quickfix*
-
-  Type: |Number|
-  Default: `0`
-
-  When this option is set to `1`, the |quickfix| list will be populated with
-  any problems which are found by ALE, instead of the |loclist|. The loclist
-  will never be populated when this option is on.
-
-  Problems from every buffer ALE has checked will be included in the quickfix
-  list, which can be checked with |:copen|. Problems will be de-duplicated.
-
-  This feature should not be used in combination with tools for searching for
-  matches and commands like |:cfdo|, as ALE will replace the quickfix list
-  pretty frequently. If you wish to use such tools, you should populate the
-  loclist instead.
-
-
-g:ale_set_signs                                               *g:ale_set_signs*
-
-  Type: |Number|
-  Default: `has('signs')`
-
-  When this option is set to `1`, the |sign| column will be populated with
-  signs marking where problems appear in the file.
-
-  ALE will use the following highlight groups for problems:
-
-  |ALEErrorSign|        - Items with `'type': 'E'`
-  |ALEWarningSign|      - Items with `'type': 'W'`
-  |ALEInfoSign|         - Items with `'type': 'I'`
-  |ALEStyleErrorSign|   - Items with `'type': 'E'` and `'sub_type': 'style'`
-  |ALEStyleWarningSign| - Items with `'type': 'W'` and `'sub_type': 'style'`
-
-  In addition to the style of the signs, the style of lines where signs appear
-  can be configured with the following highlights:
-
-  |ALEErrorLine|   - All items with `'type': 'E'`
-  |ALEWarningLine| - All items with `'type': 'W'`
-  |ALEInfoLine|    - All items with `'type': 'I'`
-
-  With Neovim 0.3.2 or higher, ALE can use the `numhl` option to highlight the
-  'number' column. It uses the following highlight groups.
-
-  |ALEErrorSignLineNr|        - Items with `'type': 'E'`
-  |ALEWarningSignLineNr|      - Items with `'type': 'W'`
-  |ALEInfoSignLineNr|         - Items with `'type': 'I'`
-  |ALEStyleErrorSignLineNr|   - Items with `'type': 'E'` and `'sub_type': 'style'`
-  |ALEStyleWarningSignLineNr| - Items with `'type': 'W'` and `'sub_type': 'style'`
-
-  To enable line number highlighting |g:ale_sign_highlight_linenrs| must be
-  set to `1` before ALE is loaded.
-
-  The markers for the highlights can be customized with the following options:
-
-  |g:ale_sign_error|
-  |g:ale_sign_warning|
-  |g:ale_sign_info|
-  |g:ale_sign_style_error|
-  |g:ale_sign_style_warning|
-
-  When multiple problems exist on the same line, the signs will take
-  precedence in the order above, from highest to lowest.
-
-  To limit the number of signs ALE will set, see |g:ale_max_signs|.
-
-
-g:ale_sign_priority                                       *g:ale_sign_priority*
-
-  Type: |Number|
-  Default: `30`
-
-  From Neovim 0.4.0 and Vim 8.1, ALE can set sign priority to all signs. The
-  larger this value is, the higher priority ALE signs have over other plugin
-  signs. See |sign-priority| for further details on how priority works.
-
-
-g:ale_shell                                                       *g:ale_shell*
-
-  Type: |String|
-  Default: not set
-
-  Override the shell used by ALE for executing commands. ALE uses 'shell' by
-  default, but falls back in `/bin/sh` if the default shell looks like `fish`
-  or `pwsh`, which are not compatible with all of the commands run by ALE. The
-  shell specified with this option will be used even if it might not work in
-  all cases.
-
-  For Windows, ALE uses `cmd` when this option isn't set. Setting this option
-  will apply shell escaping to the command string, even on Windows.
-
-  NOTE: Consider setting |g:ale_shell_arguments| if this option is defined.
-
-
-g:ale_shell_arguments                                   *g:ale_shell_arguments*
-
-  Type: |String|
-  Default: not set
-
-  This option specifies the arguments to use for executing a command with a
-  custom shell, per |g:ale_shell|. If this option is not set, 'shellcmdflag'
-  will be used instead.
-
-
-g:ale_sign_column_always                             *g:ale_sign_column_always*
-
-  Type: |Number|
-  Default: `0`
-
-  By default, the sign gutter will disappear when all warnings and errors have
-  been fixed for a file. When this option is set to `1`, the sign column will
-  remain open. This can be preferable if you don't want the text in your file
-  to move around as you edit a file.
-
-
-g:ale_sign_error                                             *g:ale_sign_error*
-
-  Type: |String|
-  Default: `'>>'`
-
-  The sign for errors in the sign gutter.
-
-
-g:ale_sign_info                                               *g:ale_sign_info*
-
-  Type: |String|
-  Default: `g:ale_sign_warning`
-
-  The sign for "info" markers in the sign gutter.
-
-
-g:ale_sign_style_error                                 *g:ale_sign_style_error*
-
-  Type: |String|
-  Default: `g:ale_sign_error`
-
-  The sign for style errors in the sign gutter.
-
-
-g:ale_sign_style_warning                             *g:ale_sign_style_warning*
-
-  Type: |String|
-  Default: `g:ale_sign_warning`
-
-  The sign for style warnings in the sign gutter.
-
-
-g:ale_sign_offset                                           *g:ale_sign_offset*
-
-  Type: |Number|
-  Default: `1000000`
-
-  This variable controls offset from which numeric IDs will be generated for
-  new signs. Signs cannot share the same ID values, so when two Vim plugins
-  set signs at the same time, the IDs have to be configured such that they do
-  not conflict with one another. If the IDs used by ALE are found to conflict
-  with some other plugin, this offset value can be changed, and hopefully both
-  plugins will work together. See |sign-place| for more information on how
-  signs are set.
-
-
-g:ale_sign_warning                                         *g:ale_sign_warning*
-
-  Type: |String|
-  Default: `'--'`
-
-  The sign for warnings in the sign gutter.
-
-
-g:ale_sign_highlight_linenrs                     *g:ale_sign_highlight_linenrs*
-
-  Type: |Number|
-  Default: `0`
-
-  When set to `1`, this option enables highlighting problems on the 'number'
-  column in Vim versions that support `numhl` highlights. This option must be
-  configured before ALE is loaded.
-
-
-g:ale_update_tagstack                                   *g:ale_update_tagstack*
-                                                        *b:ale_update_tagstack*
- Type: |Number|
- Default: `1`
-
- This option can be set to disable updating Vim's |tagstack| automatically.
-
-
-g:ale_type_map                                                 *g:ale_type_map*
-                                                               *b:ale_type_map*
-  Type: |Dictionary|
-  Default: `{}`
-
-  This option can be set re-map problem types for linters. Each key in the
-  |Dictionary| should be the name of a linter, and each value must be a
-  |Dictionary| mapping problem types from one type to another. The following
-  types are supported:
-
-  `'E'`  - `{'type': 'E'}`
-  `'ES'` - `{'type': 'E', 'sub_type': 'style'}`
-  `'W'`  - `{'type': 'W'}`
-  `'WS'` - `{'type': 'W', 'sub_type': 'style'}`
-  `'I'`  - `{'type': 'I'}`
-
-  For example, if you want to turn flake8 errors into warnings, you can write
-  the following: >
-
-  let g:ale_type_map = {'flake8': {'ES': 'WS', 'E': 'W'}}
-<
-  If you wanted to turn style errors and warnings into regular errors and
-  warnings, you can write the following: >
-
-  let g:ale_type_map = {'flake8': {'ES': 'E', 'WS': 'W'}}
-<
-  Type maps can be set per-buffer with `b:ale_type_map`.
-
-
-g:ale_use_global_executables                     *g:ale_use_global_executables*
-
-  Type: |Number|
-  Default: not set
-
-  This option can be set to change the default for all `_use_global` options.
-  This option must be set before ALE is loaded, preferably in a vimrc file.
-
-  See |ale-integrations-local-executables| for more information on those
-  options.
-
-
-g:ale_virtualtext_cursor                             *g:ale_virtualtext_cursor*
-
-  Type: |Number|
-  Default: `0`
-
-  This option only has any effect in NeoVim.
-
-  When this option is set to `1`, a message will be shown when a cursor is
-  near a warning or error. ALE will attempt to find the warning or error at a
-  column nearest to the cursor when the cursor is resting on a line which
-  contains a warning or error. This option can be set to `0` to disable this
-  behavior.
-
-  Messages are only displayed after a short delay. See |g:ale_virtualtext_delay|.
-
-  Messages can be prefixed prefixed with a string. See |g:ale_virtualtext_prefix|.
-
-  ALE will use the following highlight groups for problems:
-
-  |ALEVirtualTextError|        - Items with `'type': 'E'`
-  |ALEVirtualTextWarning|      - Items with `'type': 'W'`
-  |ALEVirtualTextInfo|         - Items with `'type': 'I'`
-  |ALEVirtualTextStyleError|   - Items with `'type': 'E'` and `'sub_type': 'style'`
-  |ALEVirtualTextStyleWarning| - Items with `'type': 'W'` and `'sub_type': 'style'`
-
-
-g:ale_virtualtext_delay                               *g:ale_virtualtext_delay*
-                                                      *b:ale_virtualtext_delay*
-
-  Type: |Number|
-  Default: `10`
-
-  Given any integer, this option controls the number of milliseconds before
-  ALE will show a message for a problem near the cursor.
-
-  The value can be increased to decrease the amount of processing ALE will do
-  for files displaying a large number of problems.
-
-
-g:ale_virtualtext_prefix                             *g:ale_virtualtext_prefix*
-
-  Type: |String|
-  Default: `'> '`
-
-  Prefix to be used with |g:ale_virtualtext_cursor|.
-
-g:ale_virtualenv_dir_names                         *g:ale_virtualenv_dir_names*
-                                                   *b:ale_virtualenv_dir_names*
-
-  Type: |List|
-  Default: `['.env', '.venv', 'env', 've-py3', 've', 'virtualenv', 'venv']`
-
-  A list of directory names to be used when searching upwards from Python
-  files to discover virtulenv directories with.
-
-  For directory named `'foo'`, ALE will search for `'foo/bin/activate'`
-  (`foo\Scripts\activate\` on Windows) in all directories on and above the
-  directory containing the Python file to find virtualenv paths.
-
-
-g:ale_warn_about_trailing_blank_lines   *g:ale_warn_about_trailing_blank_lines*
-                                        *b:ale_warn_about_trailing_blank_lines*
-
-  Type: |Number|
-  Default: `1`
-
-  When this option is set to `1`, warnings about trailing blank lines will be
-  shown.
-
-  This option behaves similarly to |g:ale_warn_about_trailing_whitespace|.
-
-
-g:ale_warn_about_trailing_whitespace     *g:ale_warn_about_trailing_whitespace*
-                                         *b:ale_warn_about_trailing_whitespace*
-
-  Type: |Number|
-  Default: `1`
-
-  When this option is set to `1`, warnings relating to trailing whitespace on
-  lines will be shown. If warnings are too irritating while editing buffers,
-  and you have configured Vim to automatically remove trailing whitespace,
-  you can disable these warnings by setting this option to `0`.
-
-  Not all linters may respect this option. If a linter does not, please file a
-  bug report, and it may be possible to add such support.
-
-  This option may be configured on a per buffer basis.
-
-
-g:ale_windows_node_executable_path         *g:ale_windows_node_executable_path*
-                                           *b:ale_windows_node_executable_path*
-
-  Type: |String|
-  Default: `'node.exe'`
-
-  This variable is used as the path to the executable to use for executing
-  scripts with Node.js on Windows.
-
-  For Windows, any file with a `.js` file extension needs to be executed with
-  the node executable explicitly. Otherwise, Windows could try and open the
-  scripts with other applications, like a text editor. Therefore, these
-  scripts are executed with whatever executable is configured with this
-  setting.
-
-
--------------------------------------------------------------------------------
-6.1. Highlights                                                *ale-highlights*
-
-ALEError                                                             *ALEError*
-
-  Default: `highlight link ALEError SpellBad`
-
-  The highlight for highlighted errors. See |g:ale_set_highlights|.
-
-
-ALEErrorLine                                                     *ALEErrorLine*
-
-  Default: Undefined
-
-  The highlight for an entire line where errors appear. Only the first
-  line for a problem will be highlighted.
-
-  See |g:ale_set_signs| and |g:ale_set_highlights|.
-
-
-ALEErrorSign                                                     *ALEErrorSign*
-
-  Default: `highlight link ALEErrorSign error`
-
-  The highlight for error signs. See |g:ale_set_signs|.
-
-
-ALEErrorSignLineNr                                         *ALEErrorSignLineNr*
-
-  Default: `highlight link ALEErrorSignLineNr CursorLineNr`
-
-  The highlight for error signs. See |g:ale_set_signs|.
-
-  NOTE: This highlight is only available on Neovim 0.3.2 or higher.
-
-
-ALEInfo                                                              *ALEInfo.*
-                                                            *ALEInfo-highlight*
-  Default: `highlight link ALEInfo ALEWarning`
-
-  The highlight for highlighted info messages. See |g:ale_set_highlights|.
-
-
-ALEInfoSign                                                       *ALEInfoSign*
-
-  Default: `highlight link ALEInfoSign ALEWarningSign`
-
-  The highlight for info message signs. See |g:ale_set_signs|.
-
-
-ALEInfoLine                                                       *ALEInfoLine*
-
-  Default: Undefined
-
-  The highlight for entire lines where info messages appear. Only the first
-  line for a problem will be highlighted.
-
-  See |g:ale_set_signs| and |g:ale_set_highlights|.
-
-
-ALEInfoSignLineNr                                           *ALEInfoSignLineNr*
-
-  Default: `highlight link ALEInfoSignLineNr CursorLineNr`
-
-  The highlight for error signs. See |g:ale_set_signs|.
-
-  NOTE: This highlight is only available on Neovim 0.3.2 or higher.
-
-
-ALEStyleError                                                   *ALEStyleError*
-
-  Default: `highlight link ALEStyleError ALEError`
-
-  The highlight for highlighted style errors. See |g:ale_set_highlights|.
-
-
-ALEStyleErrorSign                                           *ALEStyleErrorSign*
-
-  Default: `highlight link ALEStyleErrorSign ALEErrorSign`
-
-  The highlight for style error signs. See |g:ale_set_signs|.
-
-
-ALEStyleErrorSignLineNr                               *ALEStyleErrorSignLineNr*
-
-  Default: `highlight link ALEStyleErrorSignLineNr CursorLineNr`
-
-  The highlight for error signs. See |g:ale_set_signs|.
-
-  NOTE: This highlight is only available on Neovim 0.3.2 or higher.
-
-
-ALEStyleWarning                                               *ALEStyleWarning*
-
-  Default: `highlight link ALEStyleWarning ALEError`
-
-  The highlight for highlighted style warnings. See |g:ale_set_highlights|.
-
-
-ALEStyleWarningSign                                       *ALEStyleWarningSign*
-
-  Default: `highlight link ALEStyleWarningSign ALEWarningSign`
-
-  The highlight for style warning signs. See |g:ale_set_signs|.
-
-
-ALEStyleWarningSignLineNr                           *ALEStyleWarningSignLineNr*
-
-  Default: `highlight link ALEStyleWarningSignLineNr CursorLineNr`
-
-  The highlight for error signs. See |g:ale_set_signs|.
-
-  NOTE: This highlight is only available on Neovim 0.3.2 or higher.
-
-
-ALEVirtualTextError                                       *ALEVirtualTextError*
-
-  Default: `highlight link ALEVirtualTextError ALEError`
-
-  The highlight for virtualtext errors. See |g:ale_virtualtext_cursor|.
-
-
-ALEVirtualTextInfo                                         *ALEVirtualTextInfo*
-
-  Default: `highlight link ALEVirtualTextInfo ALEVirtualTextWarning`
-
-  The highlight for virtualtext info. See |g:ale_virtualtext_cursor|.
-
-
-ALEVirtualTextStyleError                             *ALEVirtualTextStyleError*
-
-  Default: `highlight link ALEVirtualTextStyleError ALEVirtualTextError`
-
-  The highlight for virtualtext style errors. See |g:ale_virtualtext_cursor|.
-
-
-ALEVirtualTextStyleWarning                         *ALEVirtualTextStyleWarning*
-
-  Default: `highlight link ALEVirtualTextStyleWarning ALEVirtualTextWarning`
-
-  The highlight for virtualtext style warnings. See |g:ale_virtualtext_cursor|.
-
-
-ALEVirtualTextWarning                                   *ALEVirtualTextWarning*
-
-  Default: `highlight link ALEVirtualTextWarning ALEWarning`
-
-  The highlight for virtualtext errors. See |g:ale_virtualtext_cursor|.
-
-
-ALEWarning                                                         *ALEWarning*
-
-  Default: `highlight link ALEWarning SpellCap`
-
-  The highlight for highlighted warnings. See |g:ale_set_highlights|.
-
-
-ALEWarningLine                                                 *ALEWarningLine*
-
-  Default: Undefined
-
-  The highlight for entire lines where warnings appear. Only the first line
-  for a problem will be highlighted.
-
-  See |g:ale_set_signs| and |g:ale_set_highlights|.
-
-
-ALEWarningSign                                                 *ALEWarningSign*
-
-  Default: `highlight link ALEWarningSign todo`
-
-  The highlight for warning signs. See |g:ale_set_signs|.
-
-
-ALEWarningSignLineNr                                     *ALEWarningSignLineNr*
-
-  Default: `highlight link ALEWarningSignLineNr CursorLineNr`
-
-  The highlight for error signs. See |g:ale_set_signs|.
-
-  NOTE: This highlight is only available on Neovim 0.3.2 or higher.
-
-
-===============================================================================
-7. Linter/Fixer Options                               *ale-integration-options*
-
-Linter and fixer options are documented below and in individual help files.
-
-Every option for programs can be set globally, or individually for each
-buffer. For example, `b:ale_python_flake8_executable` will override any
-values set for `g:ale_python_flake8_executable`.
-
-                                           *ale-integrations-local-executables*
-
-Some tools will prefer to search for locally-installed executables, unless
-configured otherwise. For example, the `eslint` linter will search for
-various executable paths in `node_modules`. The `flake8` linter will search
-for virtualenv directories.
-
-If you prefer to use global executables for those tools, set the relevant
-`_use_global` and `_executable` options for those linters. >
-
-  " Use the global executable with a special name for eslint.
-  let g:ale_javascript_eslint_executable = 'special-eslint'
-  let g:ale_javascript_eslint_use_global = 1
-
-  " Use the global executable with a special name for flake8.
-  let g:ale_python_flake8_executable = '/foo/bar/flake8'
-  let g:ale_python_flake8_use_global = 1
-<
-|g:ale_use_global_executables| can be set to `1` in your vimrc file to make
-ALE use global executables for all linters by default.
-
-The option |g:ale_virtualenv_dir_names| controls the local virtualenv paths
-ALE will use to search for Python executables.
-
-
--------------------------------------------------------------------------------
-7.1. Options for alex                                        *ale-alex-options*
-
-The options for `alex` are shared between all filetypes, so options can be
-configured once.
-
-g:ale_alex_executable                                   *g:ale_alex_executable*
-                                                        *b:ale_alex_executable*
-  Type: |String|
-  Default: `'alex'`
-
-  See |ale-integrations-local-executables|
-
-
-g:ale_alex_use_global                                   *g:ale_alex_use_global*
-                                                        *b:ale_alex_use_global*
-  Type: |Number|
-  Default: `get(g:, 'ale_use_global_executables', 0)`
-
-  See |ale-integrations-local-executables|
-
-
--------------------------------------------------------------------------------
-7.2. Options for languagetool                        *ale-languagetool-options*
-
-g:ale_languagetool_executable                   *g:ale_languagetool_executable*
-                                                *b:ale_languagetool_executable*
-
-  Type: |String|
-  Default: `'languagetool'`
-
-  The executable to run for languagetool.
-
-
-g:ale_languagetool_options                         *g:ale_languagetool_options*
-                                                   *b:ale_languagetool_options*
-  Type: |String|
-  Default: `'--autoDetect'`
-
-  This variable can be set to pass additional options to languagetool.
-
-
--------------------------------------------------------------------------------
-7.3. Options for write-good                            *ale-write-good-options*
-
-The options for `write-good` are shared between all filetypes, so options can
-be configured once.
-
-g:ale_writegood_executable                         *g:ale_writegood_executable*
-                                                   *b:ale_writegood_executable*
-  Type: |String|
-  Default: `'writegood'`
-
-  See |ale-integrations-local-executables|
-
-
-g:ale_writegood_options                               *g:ale_writegood_options*
-                                                      *b:ale_writegood_options*
-  Type: |String|
-  Default: `''`
-
-  This variable can be set to pass additional options to writegood.
-
-
-g:ale_writegood_use_global                         *g:ale_writegood_use_global*
-                                                   *b:ale_writegood_use_global*
-  Type: |Number|
-  Default: `get(g:, 'ale_use_global_executables', 0)`
-
-  See |ale-integrations-local-executables|
-
-
--------------------------------------------------------------------------------
-7.4. Other Linter/Fixer Options                 *ale-other-integration-options*
-
-ALE supports a very wide variety of tools. Other linter or fixer options are
-documented in additional help files.
-
-  ada.....................................|ale-ada-options|
-    gcc...................................|ale-ada-gcc|
-    gnatpp................................|ale-ada-gnatpp|
-  ansible.................................|ale-ansible-options|
-    ansible-lint..........................|ale-ansible-ansible-lint|
-  asciidoc................................|ale-asciidoc-options|
-    write-good............................|ale-asciidoc-write-good|
-    textlint..............................|ale-asciidoc-textlint|
-  asm.....................................|ale-asm-options|
-    gcc...................................|ale-asm-gcc|
-  awk.....................................|ale-awk-options|
-    gawk..................................|ale-awk-gawk|
-  bats....................................|ale-bats-options|
-    shellcheck............................|ale-bats-shellcheck|
-  bib.....................................|ale-bib-options|
-    bibclean..............................|ale-bib-bibclean|
-  c.......................................|ale-c-options|
-    clang.................................|ale-c-clang|
-    clangd................................|ale-c-clangd|
-    clang-format..........................|ale-c-clangformat|
-    clangtidy.............................|ale-c-clangtidy|
-    cppcheck..............................|ale-c-cppcheck|
-    cquery................................|ale-c-cquery|
-    flawfinder............................|ale-c-flawfinder|
-    gcc...................................|ale-c-gcc|
-    uncrustify............................|ale-c-uncrustify|
-    ccls..................................|ale-c-ccls|
-  chef....................................|ale-chef-options|
-    cookstyle.............................|ale-chef-cookstyle|
-    foodcritic............................|ale-chef-foodcritic|
-  clojure.................................|ale-clojure-options|
-    clj-kondo.............................|ale-clojure-clj-kondo|
-    joker.................................|ale-clojure-joker|
-  cloudformation..........................|ale-cloudformation-options|
-    cfn-python-lint.......................|ale-cloudformation-cfn-python-lint|
-  cmake...................................|ale-cmake-options|
-    cmakelint.............................|ale-cmake-cmakelint|
-    cmake-format..........................|ale-cmake-cmakeformat|
-  cpp.....................................|ale-cpp-options|
-    clang.................................|ale-cpp-clang|
-    clangd................................|ale-cpp-clangd|
-    clangcheck............................|ale-cpp-clangcheck|
-    clang-format..........................|ale-cpp-clangformat|
-    clangtidy.............................|ale-cpp-clangtidy|
-    clazy.................................|ale-cpp-clazy|
-    cppcheck..............................|ale-cpp-cppcheck|
-    cpplint...............................|ale-cpp-cpplint|
-    cquery................................|ale-cpp-cquery|
-    flawfinder............................|ale-cpp-flawfinder|
-    gcc...................................|ale-cpp-gcc|
-    uncrustify............................|ale-cpp-uncrustify|
-    ccls..................................|ale-cpp-ccls|
-  c#......................................|ale-cs-options|
-    csc...................................|ale-cs-csc|
-    mcs...................................|ale-cs-mcs|
-    mcsc..................................|ale-cs-mcsc|
-    uncrustify............................|ale-cs-uncrustify|
-  css.....................................|ale-css-options|
-    fecs..................................|ale-css-fecs|
-    prettier..............................|ale-css-prettier|
-    stylelint.............................|ale-css-stylelint|
-  cuda....................................|ale-cuda-options|
-    nvcc..................................|ale-cuda-nvcc|
-    clang-format..........................|ale-cuda-clangformat|
-  d.......................................|ale-d-options|
-    dfmt..................................|ale-d-dfmt|
-    dls...................................|ale-d-dls|
-    uncrustify............................|ale-d-uncrustify|
-  dart....................................|ale-dart-options|
-    dartanalyzer..........................|ale-dart-dartanalyzer|
-    dartfmt...............................|ale-dart-dartfmt|
-  dockerfile..............................|ale-dockerfile-options|
-    dockerfile_lint.......................|ale-dockerfile-dockerfile_lint|
-    hadolint..............................|ale-dockerfile-hadolint|
-  elixir..................................|ale-elixir-options|
-    mix...................................|ale-elixir-mix|
-    mix_format............................|ale-elixir-mix-format|
-    dialyxir..............................|ale-elixir-dialyxir|
-    elixir-ls.............................|ale-elixir-elixir-ls|
-    credo.................................|ale-elixir-credo|
-  elm.....................................|ale-elm-options|
-    elm-format............................|ale-elm-elm-format|
-    elm-ls................................|ale-elm-elm-ls|
-    elm-make..............................|ale-elm-elm-make|
-  erlang..................................|ale-erlang-options|
-    dialyzer..............................|ale-erlang-dialyzer|
-    erlc..................................|ale-erlang-erlc|
-    syntaxerl.............................|ale-erlang-syntaxerl|
-  eruby...................................|ale-eruby-options|
-    ruumba................................|ale-eruby-ruumba|
-  fish....................................|ale-fish-options|
-  fortran.................................|ale-fortran-options|
-    gcc...................................|ale-fortran-gcc|
-    language_server.......................|ale-fortran-language-server|
-  fountain................................|ale-fountain-options|
-  fusionscript............................|ale-fuse-options|
-    fusion-lint...........................|ale-fuse-fusionlint|
-  git commit..............................|ale-gitcommit-options|
-    gitlint...............................|ale-gitcommit-gitlint|
-  glsl....................................|ale-glsl-options|
-    glslang...............................|ale-glsl-glslang|
-    glslls................................|ale-glsl-glslls|
-  go......................................|ale-go-options|
-    bingo.................................|ale-go-bingo|
-    gobuild...............................|ale-go-gobuild|
-    gofmt.................................|ale-go-gofmt|
-    golangci-lint.........................|ale-go-golangci-lint|
-    golangserver..........................|ale-go-golangserver|
-    golint................................|ale-go-golint|
-    gometalinter..........................|ale-go-gometalinter|
-    gopls.................................|ale-go-gopls|
-    govet.................................|ale-go-govet|
-    revive................................|ale-go-revive|
-    staticcheck...........................|ale-go-staticcheck|
-  graphql.................................|ale-graphql-options|
-    eslint................................|ale-graphql-eslint|
-    gqlint................................|ale-graphql-gqlint|
-    prettier..............................|ale-graphql-prettier|
-  hack....................................|ale-hack-options|
-    hack..................................|ale-hack-hack|
-    hackfmt...............................|ale-hack-hackfmt|
-    hhast.................................|ale-hack-hhast|
-  handlebars..............................|ale-handlebars-options|
-    prettier..............................|ale-handlebars-prettier|
-    ember-template-lint...................|ale-handlebars-embertemplatelint|
-  haskell.................................|ale-haskell-options|
-    brittany..............................|ale-haskell-brittany|
-    floskell..............................|ale-haskell-floskell|
-    ghc...................................|ale-haskell-ghc|
-    ghc-mod...............................|ale-haskell-ghc-mod|
-    cabal-ghc.............................|ale-haskell-cabal-ghc|
-    hdevtools.............................|ale-haskell-hdevtools|
-    hfmt..................................|ale-haskell-hfmt|
-    hindent...............................|ale-haskell-hindent|
-    hlint.................................|ale-haskell-hlint|
-    stack-build...........................|ale-haskell-stack-build|
-    stack-ghc.............................|ale-haskell-stack-ghc|
-    stylish-haskell.......................|ale-haskell-stylish-haskell|
-    hie...................................|ale-haskell-hie|
-  hcl.....................................|ale-hcl-options|
-    terraform-fmt.........................|ale-hcl-terraform-fmt|
-  html....................................|ale-html-options|
-    fecs..................................|ale-html-fecs|
-    html-beautify.........................|ale-html-beautify|
-    htmlhint..............................|ale-html-htmlhint|
-    tidy..................................|ale-html-tidy|
-    prettier..............................|ale-html-prettier|
-    stylelint.............................|ale-html-stylelint|
-    write-good............................|ale-html-write-good|
-  idris...................................|ale-idris-options|
-    idris.................................|ale-idris-idris|
-  ink.....................................|ale-ink-options|
-    ink-language-server...................|ale-ink-language-server|
-  ispc....................................|ale-ispc-options|
-    ispc..................................|ale-ispc-ispc|
-  java....................................|ale-java-options|
-    checkstyle............................|ale-java-checkstyle|
-    javac.................................|ale-java-javac|
-    google-java-format....................|ale-java-google-java-format|
-    pmd...................................|ale-java-pmd|
-    javalsp...............................|ale-java-javalsp|
-    eclipselsp............................|ale-java-eclipselsp|
-    uncrustify............................|ale-java-uncrustify|
-  javascript..............................|ale-javascript-options|
-    eslint................................|ale-javascript-eslint|
-    fecs..................................|ale-javascript-fecs|
-    flow..................................|ale-javascript-flow|
-    importjs..............................|ale-javascript-importjs|
-    jscs..................................|ale-javascript-jscs|
-    jshint................................|ale-javascript-jshint|
-    prettier..............................|ale-javascript-prettier|
-    prettier-eslint.......................|ale-javascript-prettier-eslint|
-    prettier-standard.....................|ale-javascript-prettier-standard|
-    standard..............................|ale-javascript-standard|
-    xo....................................|ale-javascript-xo|
-  json....................................|ale-json-options|
-    fixjson...............................|ale-json-fixjson|
-    jsonlint..............................|ale-json-jsonlint|
-    jq....................................|ale-json-jq|
-    prettier..............................|ale-json-prettier|
-  julia...................................|ale-julia-options|
-    languageserver........................|ale-julia-languageserver|
-  kotlin..................................|ale-kotlin-options|
-    kotlinc...............................|ale-kotlin-kotlinc|
-    ktlint................................|ale-kotlin-ktlint|
-    languageserver........................|ale-kotlin-languageserver|
-  latex...................................|ale-latex-options|
-    write-good............................|ale-latex-write-good|
-    textlint..............................|ale-latex-textlint|
-  less....................................|ale-less-options|
-    lessc.................................|ale-less-lessc|
-    prettier..............................|ale-less-prettier|
-    stylelint.............................|ale-less-stylelint|
-  llvm....................................|ale-llvm-options|
-    llc...................................|ale-llvm-llc|
-  lua.....................................|ale-lua-options|
-    luac..................................|ale-lua-luac|
-    luacheck..............................|ale-lua-luacheck|
-  markdown................................|ale-markdown-options|
-    mdl...................................|ale-markdown-mdl|
-    prettier..............................|ale-markdown-prettier|
-    remark-lint...........................|ale-markdown-remark-lint|
-    textlint..............................|ale-markdown-textlint|
-    write-good............................|ale-markdown-write-good|
-  mercury.................................|ale-mercury-options|
-    mmc...................................|ale-mercury-mmc|
-  nasm....................................|ale-nasm-options|
-    nasm..................................|ale-nasm-nasm|
-  nim.....................................|ale-nim-options|
-    nimcheck..............................|ale-nim-nimcheck|
-    nimlsp................................|ale-nim-nimlsp|
-    nimpretty.............................|ale-nim-nimpretty|
-  nix.....................................|ale-nix-options|
-    nixpkgs-fmt...........................|ale-nix-nixpkgs-fmt|
-  nroff...................................|ale-nroff-options|
-    write-good............................|ale-nroff-write-good|
-  objc....................................|ale-objc-options|
-    clang.................................|ale-objc-clang|
-    clangd................................|ale-objc-clangd|
-    uncrustify............................|ale-objc-uncrustify|
-    ccls..................................|ale-objc-ccls|
-  objcpp..................................|ale-objcpp-options|
-    clang.................................|ale-objcpp-clang|
-    clangd................................|ale-objcpp-clangd|
-    uncrustify............................|ale-objcpp-uncrustify|
-  ocaml...................................|ale-ocaml-options|
-    merlin................................|ale-ocaml-merlin|
-    ols...................................|ale-ocaml-ols|
-    ocamlformat...........................|ale-ocaml-ocamlformat|
-    ocp-indent............................|ale-ocaml-ocp-indent|
-  pawn....................................|ale-pawn-options|
-    uncrustify............................|ale-pawn-uncrustify|
-  perl....................................|ale-perl-options|
-    perl..................................|ale-perl-perl|
-    perlcritic............................|ale-perl-perlcritic|
-    perltidy..............................|ale-perl-perltidy|
-  perl6...................................|ale-perl6-options|
-    perl6.................................|ale-perl6-perl6|
-  php.....................................|ale-php-options|
-    langserver............................|ale-php-langserver|
-    phan..................................|ale-php-phan|
-    phpcbf................................|ale-php-phpcbf|
-    phpcs.................................|ale-php-phpcs|
-    phpmd.................................|ale-php-phpmd|
-    phpstan...............................|ale-php-phpstan|
-    psalm.................................|ale-php-psalm|
-    php-cs-fixer..........................|ale-php-php-cs-fixer|
-    php...................................|ale-php-php|
-  po......................................|ale-po-options|
-    write-good............................|ale-po-write-good|
-  pod.....................................|ale-pod-options|
-    write-good............................|ale-pod-write-good|
-  pony....................................|ale-pony-options|
-    ponyc.................................|ale-pony-ponyc|
-  powershell............................|ale-powershell-options|
-    powershell..........................|ale-powershell-powershell|
-    psscriptanalyzer....................|ale-powershell-psscriptanalyzer|
-  prolog..................................|ale-prolog-options|
-    swipl.................................|ale-prolog-swipl|
-  proto...................................|ale-proto-options|
-    protoc-gen-lint.......................|ale-proto-protoc-gen-lint|
-  pug.....................................|ale-pug-options|
-    puglint...............................|ale-pug-puglint|
-  puppet..................................|ale-puppet-options|
-    puppet................................|ale-puppet-puppet|
-    puppetlint............................|ale-puppet-puppetlint|
-    puppet-languageserver.................|ale-puppet-languageserver|
-  purescript..............................|ale-purescript-options|
-    purescript-language-server............|ale-purescript-language-server|
-    purty.................................|ale-purescript-purty|
-  pyrex (cython)..........................|ale-pyrex-options|
-    cython................................|ale-pyrex-cython|
-  python..................................|ale-python-options|
-    autopep8..............................|ale-python-autopep8|
-    bandit................................|ale-python-bandit|
-    black.................................|ale-python-black|
-    flake8................................|ale-python-flake8|
-    isort.................................|ale-python-isort|
-    mypy..................................|ale-python-mypy|
-    prospector............................|ale-python-prospector|
-    pycodestyle...........................|ale-python-pycodestyle|
-    pydocstyle............................|ale-python-pydocstyle|
-    pyflakes..............................|ale-python-pyflakes|
-    pylama................................|ale-python-pylama|
-    pylint................................|ale-python-pylint|
-    pyls..................................|ale-python-pyls|
-    pyre..................................|ale-python-pyre|
-    reorder-python-imports................|ale-python-reorder_python_imports|
-    vulture...............................|ale-python-vulture|
-    yapf..................................|ale-python-yapf|
-  qml.....................................|ale-qml-options|
-    qmlfmt................................|ale-qml-qmlfmt|
-  r.......................................|ale-r-options|
-    lintr.................................|ale-r-lintr|
-    styler................................|ale-r-styler|
-  reasonml................................|ale-reasonml-options|
-    merlin................................|ale-reasonml-merlin|
-    ols...................................|ale-reasonml-ols|
-    reason-language-server................|ale-reasonml-language-server|
-    refmt.................................|ale-reasonml-refmt|
-  restructuredtext........................|ale-restructuredtext-options|
-    textlint..............................|ale-restructuredtext-textlint|
-    write-good............................|ale-restructuredtext-write-good|
-  ruby....................................|ale-ruby-options|
-    brakeman..............................|ale-ruby-brakeman|
-    debride...............................|ale-ruby-debride|
-    rails_best_practices..................|ale-ruby-rails_best_practices|
-    reek..................................|ale-ruby-reek|
-    rubocop...............................|ale-ruby-rubocop|
-    ruby..................................|ale-ruby-ruby|
-    rufo..................................|ale-ruby-rufo|
-    solargraph............................|ale-ruby-solargraph|
-    sorbet................................|ale-ruby-sorbet|
-    standardrb............................|ale-ruby-standardrb|
-  rust....................................|ale-rust-options|
-    analyzer..............................|ale-rust-analyzer|
-    cargo.................................|ale-rust-cargo|
-    rls...................................|ale-rust-rls|
-    rustc.................................|ale-rust-rustc|
-    rustfmt...............................|ale-rust-rustfmt|
-  sass....................................|ale-sass-options|
-    sasslint..............................|ale-sass-sasslint|
-    stylelint.............................|ale-sass-stylelint|
-  scala...................................|ale-scala-options|
-    metals................................|ale-scala-metals|
-    sbtserver.............................|ale-scala-sbtserver|
-    scalafmt..............................|ale-scala-scalafmt|
-    scalastyle............................|ale-scala-scalastyle|
-  scss....................................|ale-scss-options|
-    prettier..............................|ale-scss-prettier|
-    sasslint..............................|ale-scss-sasslint|
-    stylelint.............................|ale-scss-stylelint|
-  sh......................................|ale-sh-options|
-    sh-language-server....................|ale-sh-language-server|
-    shell.................................|ale-sh-shell|
-    shellcheck............................|ale-sh-shellcheck|
-    shfmt.................................|ale-sh-shfmt|
-  sml.....................................|ale-sml-options|
-    smlnj.................................|ale-sml-smlnj|
-  solidity................................|ale-solidity-options|
-    solc..................................|ale-solidity-solc|
-    solhint...............................|ale-solidity-solhint|
-    solium................................|ale-solidity-solium|
-  spec....................................|ale-spec-options|
-    rpmlint...............................|ale-spec-rpmlint|
-  sql.....................................|ale-sql-options|
-    pgformatter...........................|ale-sql-pgformatter|
-    sqlfmt................................|ale-sql-sqlfmt|
-    sqlformat.............................|ale-sql-sqlformat|
-  stylus..................................|ale-stylus-options|
-    stylelint.............................|ale-stylus-stylelint|
-  sugarss.................................|ale-sugarss-options|
-    stylelint.............................|ale-sugarss-stylelint|
-  swift...................................|ale-swift-options|
-    sourcekitlsp..........................|ale-swift-sourcekitlsp|
-  tcl.....................................|ale-tcl-options|
-    nagelfar..............................|ale-tcl-nagelfar|
-  terraform...............................|ale-terraform-options|
-    terraform-fmt-fixer...................|ale-terraform-fmt-fixer|
-    terraform.............................|ale-terraform-terraform|
-    terraform-lsp.........................|ale-terraform-terraform-lsp|
-    tflint................................|ale-terraform-tflint|
-  tex.....................................|ale-tex-options|
-    chktex................................|ale-tex-chktex|
-    lacheck...............................|ale-tex-lacheck|
-    latexindent...........................|ale-tex-latexindent|
-    texlab................................|ale-tex-texlab|
-  texinfo.................................|ale-texinfo-options|
-    write-good............................|ale-texinfo-write-good|
-  text....................................|ale-text-options|
-    textlint..............................|ale-text-textlint|
-    write-good............................|ale-text-write-good|
-  thrift..................................|ale-thrift-options|
-    thrift................................|ale-thrift-thrift|
-  typescript..............................|ale-typescript-options|
-    eslint................................|ale-typescript-eslint|
-    prettier..............................|ale-typescript-prettier|
-    standard..............................|ale-typescript-standard|
-    tslint................................|ale-typescript-tslint|
-    tsserver..............................|ale-typescript-tsserver|
-  vala....................................|ale-vala-options|
-    uncrustify............................|ale-vala-uncrustify|
-  verilog/systemverilog...................|ale-verilog-options|
-    iverilog..............................|ale-verilog-iverilog|
-    verilator.............................|ale-verilog-verilator|
-    vlog..................................|ale-verilog-vlog|
-    xvlog.................................|ale-verilog-xvlog|
-  vhdl....................................|ale-vhdl-options|
-    ghdl..................................|ale-vhdl-ghdl|
-    vcom..................................|ale-vhdl-vcom|
-    xvhdl.................................|ale-vhdl-xvhdl|
-  vim.....................................|ale-vim-options|
-    vimls.................................|ale-vim-vimls|
-    vint..................................|ale-vim-vint|
-  vim help................................|ale-vim-help-options|
-    write-good............................|ale-vim-help-write-good|
-  vue.....................................|ale-vue-options|
-    prettier..............................|ale-vue-prettier|
-    vls...................................|ale-vue-vls|
-  xhtml...................................|ale-xhtml-options|
-    write-good............................|ale-xhtml-write-good|
-  xml.....................................|ale-xml-options|
-    xmllint...............................|ale-xml-xmllint|
-  yaml....................................|ale-yaml-options|
-    prettier..............................|ale-yaml-prettier|
-    swaglint..............................|ale-yaml-swaglint|
-    yamllint..............................|ale-yaml-yamllint|
-  yang....................................|ale-yang-options|
-    yang-lsp..............................|ale-yang-lsp|
-
-
-===============================================================================
-8. Commands/Keybinds                                             *ale-commands*
-
-ALEComplete                                                       *ALEComplete*
-
-  Manually trigger LSP autocomplete and show the menu. Works only when called
-  from insert mode. >
-
-    inoremap <silent> <C-Space> <C-\><C-O>:AleComplete<CR>
-<
-  A plug mapping `<Plug>(ale_complete)` is defined for this command. >
-
-    imap <C-Space> <Plug>(ale_complete)
-<
-ALEDocumentation                                             *ALEDocumentation*
-
-  Similar to the |ALEHover| command, retrieve documentation information for
-  the symbol at the cursor. Documentation data will always be shown in a
-  preview window, no matter how small the documentation content is.
-
-  NOTE: This command is only available for `tsserver`.
-
-  A plug mapping `<Plug>(ale_documentation)` is defined for this command.
-
-
-ALEFindReferences                                           *ALEFindReferences*
-
-  Find references in the codebase for the symbol under the cursor using the
-  enabled LSP linters for the buffer. ALE will display a preview window
-  containing the results if some references are found.
-
-  The window can be navigated using the usual Vim navigation commands. The
-  Enter key (`<CR>`) can be used to jump to a referencing location, or the `t`
-  key can be used to jump to the location in a new tab.
-
-  The locations opened in different ways using the following variations.
-
-  `:ALEFindReferences -tab`    - Open the location in a new tab.
-  `:ALEFindReferences -split`  - Open the location in a horizontal split.
-  `:ALEFindReferences -vsplit` - Open the location in a vertical split.
-
-  The default method used for navigating to a new location can be changed
-  by modifying |g:ale_default_navigation|.
-
-  The selection can be opened again with the |ALERepeatSelection| command.
-
-  You can jump back to the position you were at before going to a reference of
-  something with jump motions like CTRL-O. See |jump-motions|.
-
-  A plug mapping `<Plug>(ale_find_references)` is defined for this command.
-
-
-ALEFix                                                                 *ALEFix*
-
-  Fix problems with the current buffer. See |ale-fix| for more information.
-
-  A plug mapping `<Plug>(ale_fix)` is defined for this command.
-
-
-ALEFixSuggest                                                   *ALEFixSuggest*
-
-  Suggest tools that can be used to fix problems in the current buffer.
-
-  See |ale-fix| for more information.
-
-
-ALEGoToDefinition `<options>`                               *ALEGoToDefinition*
-
-  Jump to the definition of a symbol under the cursor using the enabled LSP
-  linters for the buffer. ALE will jump to a definition if an LSP server
-  provides a location to jump to. Otherwise, ALE will do nothing.
-
-  The locations opened in different ways using the following variations.
-
-  `:ALEGoToDefinition -tab`    - Open the location in a new tab.
-  `:ALEGoToDefinition -split`  - Open the location in a horizontal split.
-  `:ALEGoToDefinition -vsplit` - Open the location in a vertical split.
-
-  The default method used for navigating to a new location can be changed
-  by modifying |g:ale_default_navigation|.
-
-  You can jump back to the position you were at before going to the definition
-  of something with jump motions like CTRL-O. See |jump-motions|.
-
-  You should consider using the 'hidden' option in combination with this
-  command. Otherwise, Vim will refuse to leave the buffer you're jumping from
-  unless you have saved your edits.
-
-  A plug mapping `<Plug>(ale_go_to_definition)` is defined for this command.
-
-
-ALEGoToTypeDefinition                                   *ALEGoToTypeDefinition*
-
-  This works similar to |ALEGoToDefinition| but instead jumps to the
-  definition of a type of a symbol under the cursor. ALE will jump to a
-  definition if an LSP server provides a location to jump to. Otherwise, ALE
-  will do nothing.
-
-  The locations opened in different ways using the following variations.
-
-  `:ALEGoToTypeDefinition -tab`    - Open the location in a new tab.
-  `:ALEGoToTypeDefinition -split`  - Open the location in a horizontal split.
-  `:ALEGoToTypeDefinition -vsplit` - Open the location in a vertical split.
-
-  The default method used for navigating to a new location can be changed
-  by modifying |g:ale_default_navigation|.
-
-  You can jump back to the position you were at before going to the definition
-  of something with jump motions like CTRL-O. See |jump-motions|.
-
-  A plug mapping `<Plug>(ale_go_to_type_definition)` is defined for this
-  command.
-
-
-ALEHover                                                             *ALEHover*
-
-  Print brief information about the symbol under the cursor, taken from any
-  available LSP linters. There may be a small non-blocking delay before
-  information is printed.
-
-  NOTE: In Vim 8, long messages will be shown in a preview window, as Vim 8
-  does not support showing a prompt to press enter to continue for long
-  messages from asynchronous callbacks.
-
-  A plug mapping `<Plug>(ale_hover)` is defined for this command.
-
-
-ALEOrganizeImports                                         *ALEOrganizeImports*
-
-  Organize imports using tsserver. Currently not implemented for LSPs.
-
-
-ALERename                                                           *ALERename*
-
-  Rename a symbol using TypeScript server or Language Server.
-
-  The user will be prompted for a new name.
-
-
-ALERepeatSelection                                         *ALERepeatSelection*
-
-  Repeat the last selection displayed in the preview window.
-
-
-ALESymbolSearch `<query>`                                     *ALESymbolSearch*
-
-  Search for symbols in the workspace, taken from any available LSP linters.
-
-  The arguments provided to this command will be used as a search query for
-  finding symbols in the workspace, such as functions, types, etc.
-
-                                                                     *:ALELint*
-ALELint                                                               *ALELint*
-
-  Run ALE once for the current buffer. This command can be used to run ALE
-  manually, instead of automatically, if desired.
-
-  This command will also run linters where `lint_file` is set to `1`, or in
-  other words linters which check the file instead of the Vim buffer.
-
-  A plug mapping `<Plug>(ale_lint)` is defined for this command.
-
-
-ALEPrevious                                                       *ALEPrevious*
-ALEPreviousWrap                                               *ALEPreviousWrap*
-ALENext                                                               *ALENext*
-ALENextWrap                                                       *ALENextWrap*
-ALEFirst                                                             *ALEFirst*
-ALELast                                                               *ALELast*
-                                                      *ale-navigation-commands*
-
-  Move between warnings or errors in a buffer. ALE will only navigate between
-  the errors or warnings it generated, even if both |g:ale_set_quickfix|
-  and |g:ale_set_loclist| are set to `0`.
-
-  `ALEPrevious` and `ALENext` will stop at the top and bottom of a file, while
-  `ALEPreviousWrap` and `ALENextWrap` will wrap around the file to find
-  the last or first warning or error in the file, respectively.
-
-  `ALEPrevious` and `ALENext` take optional flags arguments to custom their
-  behaviour :
-  `-wrap` enable wrapping around the file
-  `-error`, `-warning` and `-info` enable jumping to errors, warnings or infos
-    respectively, ignoring anything else. They are mutually exclusive and if
-    several are provided the priority is the following: error > warning > info.
-  `-style` and `-nostyle` allow you to jump respectively to style error or
-    warning and to not style error or warning. They also are mutually
-    exclusive and nostyle has priority over style.
-
-  Flags can be combined to create create custom jumping. Thus you can use
-  ":ALENext -wrap -error -nosyle" to jump to the next error which is not a
-  style error while going back to the beginning of the file if needed.
-
-  `ALEFirst` goes to the first error or warning in the buffer, while `ALELast`
-  goes to the last one.
-
-  The following |<Plug>| mappings are defined for the commands: >
-  <Plug>(ale_previous) - ALEPrevious
-  <Plug>(ale_previous_wrap) - ALEPreviousWrap
-  <Plug>(ale_previous_error) - ALEPrevious -error
-  <Plug>(ale_previous_wrap_error) - ALEPrevious -wrap -error
-  <Plug>(ale_previous_warning) - ALEPrevious -warning
-  <Plug>(ale_previous_wrap_warning) - ALEPrevious -wrap -warning
-  <Plug>(ale_next) - ALENext
-  <Plug>(ale_next_wrap) - ALENextWrap
-  <Plug>(ale_next_error) - ALENext -error
-  <Plug>(ale_next_wrap_error) - ALENext -wrap -error
-  <Plug>(ale_next_warning) - ALENext -warning
-  <Plug>(ale_next_wrap_warning) - ALENext -wrap -warning
-  <Plug>(ale_first) - ALEFirst
-  <Plug>(ale_last) - ALELast
-<
-  For example, these commands could be bound to the keys Ctrl + j
-  and Ctrl + k: >
-
-  " Map movement through errors without wrapping.
-  nmap <silent> <C-k> <Plug>(ale_previous)
-  nmap <silent> <C-j> <Plug>(ale_next)
-  " OR map keys to use wrapping.
-  nmap <silent> <C-k> <Plug>(ale_previous_wrap)
-  nmap <silent> <C-j> <Plug>(ale_next_wrap)
-<
-
-ALEToggle                                                           *ALEToggle*
-ALEEnable                                                           *ALEEnable*
-ALEDisable                                                         *ALEDisable*
-ALEToggleBuffer                                               *ALEToggleBuffer*
-ALEEnableBuffer                                               *ALEEnableBuffer*
-ALEDisableBuffer                                             *ALEDisableBuffer*
-
-  `ALEToggle`, `ALEEnable`, and `ALEDisable` enable or disable ALE linting,
-  including all of its autocmd events, loclist items, quickfix items, signs,
-  current jobs, etc., globally. Executing any of these commands will change
-  the |g:ale_enabled| variable.
-
-  ALE can be disabled or enabled for only a single buffer with
-  `ALEToggleBuffer`, `ALEEnableBuffer`, and `ALEDisableBuffer`. Disabling ALE
-  for a buffer will not remove autocmd events, but will prevent ALE from
-  checking for problems and reporting problems for whatever buffer the
-  `ALEDisableBuffer` or `ALEToggleBuffer` command is executed from. These
-  commands can be used for temporarily disabling ALE for a buffer. These
-  commands will modify the |b:ale_enabled| variable.
-
-  ALE linting cannot be enabled for a single buffer when it is disabled
-  globally, as disabling ALE globally removes the autocmd events needed to
-  perform linting with.
-
-  The following plug mappings are defined, for conveniently defining keybinds:
-
-  |ALEToggle|        - `<Plug>(ale_toggle)`
-  |ALEEnable|        - `<Plug>(ale_enable)`
-  |ALEDisable|       - `<Plug>(ale_disable)`
-  |ALEToggleBuffer|  - `<Plug>(ale_toggle_buffer)`
-  |ALEEnableBuffer|  - `<Plug>(ale_enable_buffer)`
-  |ALEDisableBuffer| - `<Plug>(ale_disable_buffer)`
-
-  For removing problems reported by ALE, but leaving ALE enabled, see
-  |ALEReset| and |ALEResetBuffer|.
-
-                                                                   *:ALEDetail*
-ALEDetail                                                           *ALEDetail*
-
-  Show the full linter message for the problem nearest to the cursor on the
-  given line in the preview window. The preview window can be easily closed
-  with the `q` key. If there is no message to show, the window will not be
-  opened.
-
-  If a loclist item has a `detail` key set, the message for that key will be
-  preferred over `text`. See |ale-loclist-format|.
-
-  A plug mapping `<Plug>(ale_detail)` is defined for this command.
-
-
-                                                                     *:ALEInfo*
-ALEInfo                                                               *ALEInfo*
-ALEInfoToClipboard                                         *ALEInfoToClipboard*
-
-  Print runtime information about ALE, including the values of global and
-  buffer-local settings for ALE, the linters that are enabled, the commands
-  that have been run, and the output of commands.
-
-  ALE will log the commands that are run by default. If you wish to disable
-  this, set |g:ale_history_enabled| to `0`. Because it could be expensive, ALE
-  does not remember the output of recent commands by default. Set
-  |g:ale_history_log_output| to `1` to enable logging of output for commands.
-  ALE will only log the output captured for parsing problems, etc.
-
-  The command `:ALEInfoToClipboard` can be used to output ALEInfo directly to
-  your clipboard. This might not work on every machine.
-
-  `:ALEInfoToFile` will write the ALE runtime information to a given filename.
-  The filename works just like |:w|.
-
-
-ALEReset                                                             *ALEReset*
-ALEResetBuffer                                                 *ALEResetBuffer*
-
-  `ALEReset` will remove all problems reported by ALE for all buffers.
-  `ALEResetBuffer` will remove all problems reported for a single buffer.
-
-  Either command will leave ALE linting enabled, so ALE will report problems
-  when linting is performed again. See |ale-lint| for more information.
-
-  The following plug mappings are defined, for conveniently defining keybinds:
-
-  |ALEReset|       - `<Plug>(ale_reset)`
-  |ALEResetBuffer| - `<Plug>(ale_reset_buffer)`
-
-  ALE can be disabled globally or for a buffer with |ALEDisable| or
-  |ALEDisableBuffer|.
-
-
-ALEStopAllLSPs                                                 *ALEStopAllLSPs*
-
-  `ALEStopAllLSPs` will close and stop all channels and jobs for all LSP-like
-  clients, including tsserver, remove all of the data stored for them, and
-  delete all of the problems found for them, updating every linted buffer.
-
-  This command can be used when LSP clients mess up and need to be restarted.
-
-
-===============================================================================
-9. API                                                                *ale-api*
-
-ALE offers a number of functions for running linters or fixers, or defining
-them. The following functions are part of the publicly documented part of that
-API, and should be expected to continue to work.
-
-
-ale#Env(variable_name, value)                                       *ale#Env()*
-
-  Given a variable name and a string value, produce a string for including in
-  a command for setting environment variables. This function can be used for
-  building a command like so. >
-
-    :echo string(ale#Env('VAR', 'some value') . 'command')
-    'VAR=''some value'' command'      # On Linux or Mac OSX
-    'set VAR="some value" && command' # On Windows
-
-
-ale#Has(feature)                                                    *ale#Has()*
-
-  Return `1` if ALE supports a given feature, like |has()| for Vim features.
-
-  ALE versions can be checked with version strings in the format
-  `ale#Has('ale-x.y.z')`, such as `ale#Has('ale-2.4.0')`.
-
-
-ale#Pad(string)                                                     *ale#Pad()*
-
-  Given a string or any |empty()| value, return either the string prefixed
-  with a single space, or an empty string. This function can be used to build
-  parts of a command from variables.
-
-
-ale#Queue(delay, [linting_flag, buffer_number])                   *ale#Queue()*
-
-  Run linters for the current buffer, based on the filetype of the buffer,
-  with a given `delay`. A `delay` of `0` will run the linters immediately.
-  The linters will always be run in the background. Calling this function
-  again from the same buffer
-
-  An optional `linting_flag` argument can be given. If `linting_flag`
-  is `'lint_file'`, then linters where the `lint_file` option is set to `1` will be
-  run. Linters with `lint_file` set to `1` are not run by default.
-
-  An optional `buffer_number` argument can be given for specifying the buffer
-  to check. The active buffer (`bufnr('')`) will be checked by default.
-
-                                                                *ale-cool-down*
-  If an exception is thrown when queuing/running ALE linters, ALE will enter
-  a cool down period where it will stop checking anything for a short period
-  of time. This is to prevent ALE from seriously annoying users if a linter
-  is broken, or when developing ALE itself.
-
-
-ale#command#CreateDirectory(buffer)             *ale#command#CreateDirectory()*
-
-  Create a new temporary directory with a unique name, and manage that
-  directory with |ale#command#ManageDirectory()|, so it will be removed as soon
-  as possible.
-
-  It is advised to only call this function from a callback function for
-  returning a linter command to run.
-
-
-ale#command#CreateFile(buffer)                       *ale#command#CreateFile()*
-
-  Create a new temporary file with a unique name, and manage that file with
-  |ale#command#ManageFile()|, so it will be removed as soon as possible.
-
-  It is advised to only call this function from a callback function for
-  returning a linter command to run.
-
-
-ale#command#Run(buffer, command, callback, [options])       *ale#command#Run()*
-
-  Start running a job in the background, and pass the results to the given
-  callback later.
-
-  This function can be used for computing the results of ALE linter or fixer
-  functions asynchronously with jobs. `buffer` must match the buffer being
-  linted or fixed, `command` must be a |String| for a shell command to
-  execute, `callback` must be defined as a |Funcref| to call later with the
-  results, and an optional |Dictionary| of `options` can be provided.
-
-  The `callback` will receive the arguments `(buffer, output, metadata)`,
-  where the `buffer` will match the buffer given to the function, the `output`
-  will be a `List` of lines of output from the job that was run, and the
-  `metadata` will be a |Dictionary| with additional information about the job
-  that was run, including:
-
-    `exit_code` - A |Number| with the exit code for the program that was run.
-
-  The result of this function is either a special |Dictionary| ALE will use
-  for waiting for the command to finish, or `0` if the job is not started. The
-  The return value of the `callback` will be used as the eventual result for
-  whatever value is being given to ALE. For example: >
-
-    function! s:GetCommand(buffer, output, meta) abort
-        " Do something with a:output here, from the foo command.
-
-        " This is used as the command to run for linting.
-        return 'final command'
-    endfunction
-
-    " ...
-
-    'command': {b -> ale#command#Run(b, 'foo', function('s:GetCommand'))}
-<
-  The result of a callback can also be the result of another call to this
-  function, so that several commands can be arbitrarily chained together. For
-  example: >
-
-    function! s:GetAnotherCommand(buffer, output, meta) abort
-        " We can finally return this command.
-        return 'last command'
-    endfunction
-
-    function! s:GetCommand(buffer, output, meta) abort
-        " We can return another deferred result.
-        return ale#command#Run(
-        \   a:buffer,
-        \   'second command',
-        \   function('s:GetAnotherCommand')
-        \)
-    endfunction
-
-    " ...
-
-    'command': {b -> ale#command#Run(b, 'foo', function('s:GetCommand'))}
-<
-  The following `options` can be provided.
-
-    `output_stream` - Either `'stdout'`, `'stderr'`, `'both'`, or `'none`' for
-                    selecting which output streams to read lines from.
-
-                    The default is `'stdout'`
-
-    `executable`    - An executable for formatting into `%e` in the command.
-                    If this option is not provided, formatting commands with
-                    `%e` will not work.
-
-    `read_buffer`   - If set to `1`, the buffer will be piped into the
-                    command.
-
-                    The default is `0`.
-
-    `input`         - When creating temporary files with `%t` or piping text
-                    into a command `input` can be set to a |List| of text to
-                    use instead of the buffer's text.
-
-
-ale#command#EscapeCommandPart(command_part)   *ale#command#EscapeCommandPart()*
-
-  Given a |String|, return a |String| with all `%` characters replaced with
-  `%%` instead. This function can be used to escape strings which are
-  dynamically generated for commands before handing them over to ALE,
-  so that ALE doesn't treat any strings with `%` formatting sequences
-  specially.
-
-
-ale#command#ManageDirectory(buffer, directory)  *ale#command#ManageDirectory()*
-
-  Like |ale#command#ManageFile()|, but directories and all of their contents
-  will be deleted, akin to `rm -rf directory`, which could lead to loss of
-  data if mistakes are made. This command will also delete any temporary
-  filenames given to it.
-
-  It is advised to use |ale#command#ManageFile()| instead for deleting single
-  files.
-
-
-ale#command#ManageFile(buffer, filename)             *ale#command#ManageFile()*
-
-  Given a buffer number for a buffer currently running some linting or fixing
-  tasks and a filename, register a filename with ALE for automatic deletion
-  after linting or fixing is complete, or when Vim exits.
-
-  If Vim exits suddenly, ALE will try its best to remove temporary files, but
-  ALE cannot guarantee with absolute certainty that the files will be removed.
-  It is advised to create temporary files in the operating system's managed
-  temporary file directory, such as with |tempname()|.
-
-  Directory names should not be given to this function. ALE will only delete
-  files and symlinks given to this function. This is to prevent entire
-  directories from being accidentally deleted, say in cases of writing
-  `dir . '/' . filename` where `filename` is actually `''`, etc. ALE instead
-  manages directories separately with the |ale#command#ManageDirectory| function.
-
-
-ale#completion#OmniFunc(findstart, base)            *ale#completion#OmniFunc()*
-
-  A completion function to use with 'omnifunc'.
-
-  See |ale-completion|.
-
-
-ale#engine#GetLoclist(buffer)                         *ale#engine#GetLoclist()*
-
-  Given a buffer number, this function will return the list of problems
-  reported by ALE for a given buffer in the format accepted by |setqflist()|.
-
-  A reference to the buffer's list of problems will be returned. The list must
-  be copied before applying |map()| or |filter()|.
-
-
-ale#engine#IsCheckingBuffer(buffer)             *ale#engine#IsCheckingBuffer()*
-
-  Given a buffer number, returns `1` when ALE is busy checking that buffer.
-
-  This function can be used for status lines, tab names, etc.
-
-
-ale#fix#registry#Add(name, func, filetypes, desc, [aliases])
-                                                       *ale#fix#registry#Add()*
-
-  Given a |String| `name` for a name to add to the registry, a |String| `func`
-  for a function name, a |List| `filetypes` for a list of filetypes to
-  set for suggestions, and a |String| `desc` for a short description of
-  the fixer, register a fixer in the registry.
-
-  The `name` can then be used for |g:ale_fixers| in place of the function
-  name, and suggested for fixing files.
-
-  An optional |List| of |String|s for aliases can be passed as the `aliases`
-  argument. These aliases can also be used for looking up a fixer function.
-  ALE will search for fixers in the registry first by `name`, then by their
-  `aliases`.
-
-
-ale#linter#Define(filetype, linter)                       *ale#linter#Define()*
-
-  Given a |String| for a filetype and a |Dictionary| Describing a linter
-  configuration, add a linter for the given filetype. The dictionaries each
-  offer the following options:
-
-  `name`                   The name of the linter. These names will be used by
-                         |g:ale_linters| option for enabling/disabling
-                         particular linters.
-
-                         This argument is required.
-
-  `callback`               A |String| or |Funcref| for a callback function
-                         accepting two arguments (buffer, lines), for a
-                         buffer number the output is for, and the lines of
-                         output from a linter.
-
-                         This callback function should return a |List| of
-                         |Dictionary| objects in the format accepted by
-                         |setqflist()|. The |List| will be sorted by line and
-                         then column order so it can be searched with a binary
-                         search by in future before being passed on to the
-                         |loclist|, etc.
-
-                         This argument is required, unless the linter is an
-                         LSP linter. In which case, this argument must not be
-                         defined, as LSP linters handle diagnostics
-                         automatically. See |ale-lsp-linters|.
-
-                         If the function named does not exist, including if
-                         the function is later deleted, ALE will behave as if
-                         the callback returned an empty list.
-
-                         The keys for each item in the List will be handled in
-                         the following manner:
-                                                           *ale-loclist-format*
-                         `text` - This error message is required.
-                         `detail` - An optional, more descriptive message.
-                           This message can be displayed with the |ALEDetail|
-                           command instead of the message for `text`, if set.
-                         `lnum` - The line number is required. Any strings
-                           will be automatically converted to numbers by
-                           using `str2nr()`.
-
-                           Line 0 will be moved to line 1, and lines beyond
-                           the end of the file will be moved to the end.
-                         `col` - The column number is optional and will
-                           default to `0`. Any strings will be automatically
-                           converted to number using `str2nr()`.
-                         `end_col` - An optional end column number.
-                           This key can be set to specify the column problems
-                           end on, for improved highlighting.
-                         `end_lnum` - An optional end line number.
-                           This key can set along with `end_col` for
-                           highlighting multi-line problems.
-                         `bufnr` - This key represents the buffer number the
-                           problems are for. This value will default to
-                           the buffer number being checked.
-
-                           The `filename` key can be set instead of this key,
-                           and then the eventual `bufnr` value in the final
-                           list will either represent the number for an open
-                           buffer or `-1` for a file not open in any buffer.
-                         `filename` - An optional filename for the file the
-                           problems are for. This should be an absolute path to
-                           a file.
-
-                           Problems for files which have not yet been opened
-                           will be set in those files after they are opened
-                           and have been checked at least once.
-
-                           Temporary files in directories used for Vim
-                           temporary files with `tempname()` will be assumed
-                           to be the buffer being checked, unless the `bufnr`
-                           key is also set with a valid number for some other
-                           buffer.
-                         `vcol` - Defaults to `0`.
-
-                           If set to `1`, ALE will convert virtual column
-                           positions for `col` and `end_col` to byte column
-                           positions. If the buffer is changed in-between
-                           checking it and displaying the results, the
-                           calculated byte column positions will probably be
-                           wrong.
-                         `type` - Defaults to `'E'`.
-                         `nr` - Defaults to `-1`.
-
-                           Numeric error code. If `nr` is not `-1`, `code`
-                           likely should contain the string representation of
-                           the same value.
-                         `code` - No default; may be unset.
-
-                           Human-readable |String| error code.
-
-  `executable`             A |String| naming the executable itself which
-                         will be run, or a |Funcref| for a function to call
-                         for computing the executable, accepting a buffer
-                         number.
-
-                         The result can be computed with |ale#command#Run()|.
-
-                         This value will be used to check if the program
-                         requested is installed or not.
-
-                         If an `executable` is not defined, the command will
-                         be run without checking if a program is executable
-                         first. Defining an executable path is recommended to
-                         avoid starting too many processes.
-
-  `command`                A |String| for a command to run asynchronously, or a
-                         |Funcref| for a function to call for computing the
-                         command, accepting a buffer number.
-
-                         The result can be computed with |ale#command#Run()|.
-
-                         This command will be fed the lines from the buffer to
-                         check, and will produce the lines of output given to
-                         the `callback`.
-
-  `output_stream`          A |String| for the output stream the lines of output
-                         should be read from for the command which is run. The
-                         accepted values are `'stdout'`, `'stderr'`, and
-                         `'both'`. This argument defaults to `'stdout'`. This
-                         argument can be set for linter programs which output
-                         their errors and warnings to the stderr stream
-                         instead of stdout. The option `'both'` will read
-                         from both stder and stdout at the same time.
-
-  `read_buffer`            A |Number| (`0` or `1`) indicating whether a command
-                         should read the Vim buffer as input via stdin. This
-                         option is set to `1` by default, and can be disabled
-                         if a command manually reads from a temporary file
-                         instead, etc.
-
-                                                                *ale-lint-file*
-  `lint_file`              A |Number| (`0` or `1`) indicating whether a command
-                         should read the file instead of the Vim buffer. This
-                         option can be used for linters which must check the
-                         file on disk, and which cannot check a Vim buffer
-                         instead.
-
-                         Linters set with this option will not be run as a
-                         user types, per |g:ale_lint_on_text_changed|. Linters
-                         will instead be run only when events occur against
-                         the file on disk, including |g:ale_lint_on_enter|
-                         and |g:ale_lint_on_save|. Linters with this option
-                         set to `1` will also be run when linters are run
-                         manually, per |ALELintPost-autocmd|.
-
-                         When this option is set to `1`, `read_buffer` will
-                         be set automatically to `0`. The two options cannot
-                         be used together.
-
-                                                              *ale-lsp-linters*
-  `lsp`                    A |String| for defining LSP (Language Server Protocol)
-                         linters.
-
-                         This argument may be omitted or `''` when a linter
-                         does not represent an LSP linter.
-
-                         When this argument is set to `'stdio'`, then the
-                         linter will be defined as an LSP linter which keeps a
-                         process for a language server running, and
-                         communicates with it directly via a |channel|.
-                         `executable` and `command` must be set.
-
-                         When this argument is set to `'socket'`, then the
-                         linter will be defined as an LSP linter via a TCP
-                         socket connection. `address` must be set.
-
-                         ALE will not start a server automatically.
-
-                         When this argument is not empty `project_root` must
-                         be defined.
-
-                         `language` can be defined to describe the language
-                         for a file. The filetype will be used as the language
-                         by default.
-
-                         LSP linters handle diagnostics automatically, so
-                         the `callback` argument must not be defined.
-
-                         An optional `completion_filter` callback may be
-                         defined for filtering completion results.
-
-                         `initialization_options` may be defined to pass
-                         initialization options to the LSP.
-
-                         `lsp_config` may be defined to pass configuration
-                         settings to the LSP.
-
-  `address`                A |String| representing an address to connect to,
-                         or a |Funcref| accepting a buffer number and
-                         returning the |String|.
-
-                         The result can be computed with |ale#command#Run()|.
-
-                         This argument must only be set if the `lsp` argument
-                         is set to `'socket'`.
-
-  `project_root`           A |String| representing a path to the project for
-                         the file being checked with the language server, or
-                         a |Funcref| accepting a buffer number and returning
-                         the |String|.
-
-                         If an empty string is returned, the file will not be
-                         checked at all.
-
-                         This argument must only be set if the `lsp` argument
-                         is also set to a non-empty string.
-
-  `language`               A |String| representing the name of the language
-                         being checked, or a |Funcref| accepting a buffer
-                         number and returning the |String|. This string will
-                         be sent to the LSP to tell it what type of language
-                         is being checked.
-
-                         If a language isn't provided, the language will
-                         default to the value of the filetype given to
-                         |ale#linter#Define|.
-
-  `completion_filter`      A |String| or |Funcref| for a callback function
-                         accepting a buffer number and a completion item.
-
-                         The completion item will be a |Dictionary| following
-                         the Language Server Protocol `CompletionItem`
-                         interface as described in the specification,
-                         available online here:
-                         https://microsoft.github.io/language-server-protocol
-
-  `aliases`                A |List| of aliases for the linter name.
-
-                         This argument can be set with alternative names for
-                         selecting the linter with |g:ale_linters|. This
-                         setting can make it easier to guess the linter name
-                         by offering a few alternatives.
-
-  `initialization_options` A |Dictionary| of initialization options for LSPs,
-                         or a |Funcref| for a callback function accepting
-                         a buffer number and returning the |Dictionary|.
-
-                         This will be fed (as JSON) to the LSP in the
-                         initialize command.
-
-  `lsp_config`             A |Dictionary| for configuring a language server,
-                         or a |Funcref| for a callback function accepting
-                         a buffer number and returning the |Dictionary|.
-
-                         This will be fed (as JSON) to the LSP in the
-                         workspace/didChangeConfiguration command.
-
-  If temporary files or directories are created for commands run with
-  `command`, then these temporary files or directories can be managed by ALE,
-  for automatic deletion. See |ale#command#ManageFile()| and
-  |ale#command#ManageDirectory| for more information.
-
-                                                   *ale-command-format-strings*
-
-  All command strings will be formatted for special character sequences.
-  Any substring `%s` will be replaced with the full path to the current file
-  being edited. This format option can be used to pass the exact filename
-  being edited to a program.
-
-  For example: >
-  'command': 'eslint -f unix --stdin --stdin-filename %s'
-<
-  Any substring `%t` will be replaced with a path to a temporary file. Merely
-  adding `%t` will cause ALE to create a temporary file containing the
-  contents of the buffer being checked. All occurrences of `%t` in command
-  strings will reference the one temporary file. The temporary file will be
-  created inside a temporary directory, and the entire temporary directory
-  will be automatically deleted, following the behaviour of
-  |ale#command#ManageDirectory|. This option can be used for some linters which
-  do not support reading from stdin.
-
-  For example: >
-  'command': 'ghc -fno-code -v0 %t',
-<
-  Any substring `%e` will be replaced with the escaped executable supplied
-  with `executable`. This provides a convenient way to define a command string
-  which needs to include a dynamic executable name, but which is otherwise
-  static.
-
-  For example: >
-  'command': '%e --some-argument',
-<
-  The character sequence `%%` can be used to emit a literal `%` into a
-  command, so literal character sequences `%s` and `%t` can be escaped by
-  using `%%s` and `%%t` instead, etc.
-
-  If a callback for a command generates part of a command string which might
-  possibly contain `%%`, `%s`, `%t`, or `%e`, where the special formatting
-  behavior is not desired, the |ale#command#EscapeCommandPart()| function can
-  be used to replace those characters to avoid formatting issues.
-
-                                                  *ale-linter-loading-behavior*
-                                                 *ale-linter-loading-behaviour*
-
-  Linters for ALE will be loaded by searching |runtimepath| in the following
-  format: >
-
-  ale_linters/<filetype>/<linter_name>.vim
-<
-  Any linters which exist anywhere in |runtimepath| with that directory
-  structure will be automatically loaded for the matching |filetype|. Filetypes
-  containing `.` characters will be split into individual parts, and files
-  will be loaded for each filetype between the `.` characters.
-
-  Linters can be defined from vimrc and other files as long as this function
-  is loaded first. For example, the following code will define a Hello World
-  linter in vimrc in Vim 8: >
-
-  " Plugins have to be loaded first.
-  " If you are using a plugin manager, run that first.
-  packloadall
-
-  call ale#linter#Define('vim', {
-  \   'name': 'echo-test',
-  \   'executable': 'echo',
-  \   'command': 'echo hello world',
-  \   'callback': {buffer, lines -> map(lines, '{"text": v:val, "lnum": 1}')},
-  \})
-<
-
-ale#linter#Get(filetype)                                     *ale#linter#Get()*
-
-  Return all of linters configured for a given filetype as a |List| of
-  |Dictionary| values in the format specified by |ale#linter#Define()|.
-
-  Filetypes may be dot-separated to invoke linters for multiple filetypes:
-  for instance, the filetype `javascript.jsx` will return linters for both the
-  `javascript` and `jsx` filetype.
-
-  Aliases may be defined in as described in |g:ale_linter_aliases|. Aliases
-  are applied after dot-separated filetypes are broken up into their
-  components.
-
-
-ale#linter#PreventLoading(filetype)               *ale#linter#PreventLoading()*
-
-  Given a `filetype`, prevent any more linters from being loaded from
-  |runtimepath| for that filetype. This function can be called from vimrc or
-  similar to prevent ALE from loading linters.
-
-
-ale#lsp_linter#SendRequest(buffer, linter_name, message, [Handler])
-                                                 *ale#lsp_linter#SendRequest()*
-
-  Send a custom request to an LSP linter. The arguments are defined as
-  follows:
-
-  `buffer`       A valid buffer number.
-
-  `linter_name`  A |String| identifying an LSP linter that is available and
-                 enabled for the |filetype| of `buffer`.
-
-  `message`      A |List| in the form `[is_notification, method, parameters]`,
-                 containing three elements:
-                 `is_notification` - an |Integer| that has value 1 if the
-                   request is a notification, 0 otherwise;
-                 `method` - a |String|, identifying an LSP method supported
-                   by `linter`;
-                 `parameters` - a |dictionary| of LSP parameters that are
-                   applicable to `method`.
-
-  `Handler`      Optional argument, meaningful only when `message[0]` is 0.
-                 A |Funcref| that is called when a response to the request is
-                 received, and takes as unique argument a dictionary
-                 representing the response obtained from the server.
-
-
-ale#other_source#ShowResults(buffer, linter_name, loclist)
-                                               *ale#other_source#ShowResults()*
-
-  Show results from another source of information.
-
-  `buffer` must be a valid buffer number, and `linter_name` must be a unique
-  name for identifying another source of information. The `loclist` given
-  where the problems in a buffer are, and should be provided in the format ALE
-  uses for regular linter results. See |ale-loclist-format|.
-
-
-ale#other_source#StartChecking(buffer, linter_name)
-                                             *ale#other_source#StartChecking()*
-
-  Tell ALE that another source of information has started checking a buffer.
-
-  `buffer` must be a valid buffer number, and `linter_name` must be a unique
-  name for identifying another source of information.
-
-
-ale#statusline#Count(buffer)                           *ale#statusline#Count()*
-
-  Given the number of a buffer which may have problems, return a |Dictionary|
-  containing information about the number of problems detected by ALE. The
-  following keys are supported:
-
-  `error`         -> The number of problems with type `E` and `sub_type != 'style'`
-  `warning`       -> The number of problems with type `W` and `sub_type != 'style'`
-  `info`          -> The number of problems with type `I`
-  `style_error`   -> The number of problems with type `E` and `sub_type == 'style'`
-  `style_warning` -> The number of problems with type `W` and `sub_type == 'style'`
-  `total`         -> The total number of problems.
-
-
-ale#statusline#FirstProblem(buffer, type)       *ale#statusline#FirstProblem()*
-
-  Returns a copy of the first entry in the `loclist` that matches the supplied
-  buffer number and problem type. If there is no such entry, an empty dictionary
-  is returned.
-  Problem type should be one of the strings listed below:
-
-  `error`         -> Returns the first `loclist` item with type `E` and
-                     `sub_type != 'style'`
-  `warning`       -> First item with type `W` and `sub_type != 'style'`
-  `info`          -> First item with type `I`
-  `style_error`   -> First item with type `E` and `sub_type == 'style'`
-  `style_warning` -> First item with type `W` and `sub_type == 'style'`
-
-
-b:ale_linted                                                     *b:ale_linted*
-
-  `b:ale_linted` is set to the number of times a buffer has been checked by
-  ALE after all linters for one lint cycle have finished checking a buffer.
-  This variable may not be defined until ALE first checks a buffer, so it
-  should be accessed with |get()| or |getbufvar()|. For example: >
-
-    " Print a message indicating how many times ALE has checked this buffer.
-    echo 'ALE has checked this buffer ' . get(b:, 'ale_linted') . ' time(s).'
-    " Print 'checked' using getbufvar() if a buffer has been checked.
-    echo getbufvar(bufnr(''), 'ale_linted', 0) > 0 ? 'checked' : 'not checked'
-<
-
-g:ale_want_results_buffer                           *g:ale_want_results_buffer*
-
-  `g:ale_want_results_buffer` is set to the number of the buffer being checked
-  when the |ALEWantResults| event is signaled. This variable should be read to
-  figure out which buffer other sources should lint.
-
-
-ALELintPre                                                 *ALELintPre-autocmd*
-                                                                   *ALELintPre*
-ALELintPost                                               *ALELintPost-autocmd*
-                                                                  *ALELintPost*
-ALEFixPre                                                   *ALEFixPre-autocmd*
-                                                                    *ALEFixPre*
-ALEFixPost                                                 *ALEFixPost-autocmd*
-                                                                   *ALEFixPost*
-
-  These |User| autocommands are triggered before and after every lint or fix
-  cycle. They can be used to update statuslines, send notifications, etc.
-  The autocmd commands are run with |:silent|, so |:unsilent| is required for
-  echoing messges.
-
-  For example to change the color of the statusline while the linter is
-  running:
->
-    augroup ALEProgress
-        autocmd!
-        autocmd User ALELintPre  hi Statusline ctermfg=darkgrey
-        autocmd User ALELintPost hi Statusline ctermfg=NONE
-    augroup END
-<
-  Or to display the progress in the statusline:
->
-    let s:ale_running = 0
-    let l:stl .= '%{s:ale_running ? "[linting]" : ""}'
-    augroup ALEProgress
-        autocmd!
-        autocmd User ALELintPre  let s:ale_running = 1 | redrawstatus
-        autocmd User ALELintPost let s:ale_running = 0 | redrawstatus
-    augroup END
-
-<
-ALEJobStarted                                           *ALEJobStarted-autocmd*
-                                                                *ALEJobStarted*
-
-  This |User| autocommand is triggered immediately after a job is successfully
-  run. This provides better accuracy for checking linter status with
-  |ale#engine#IsCheckingBuffer()| over |ALELintPre-autocmd|, which is actually
-  triggered before any linters are executed.
-
-
-ALEWantResults                                         *ALEWantResults-autocmd*
-                                                               *ALEWantResults*
-
-  This |User| autocommand is triggered before ALE begins a lint cycle. Another
-  source can respond by calling |ale#other_source#StartChecking()|, and
-  |ALELintPre| will be signaled thereafter, to allow other plugins to know
-  that another source is checking the buffer.
-
-  |g:ale_want_results_buffer| will be set to the number for a buffer being
-  checked when the event is signaled, and deleted after the event is done.
-  This variable should be read to know which buffer to check.
-
-  Other plugins can use this event to start checking buffers when ALE events
-  for checking buffers are triggered.
-
-
-===============================================================================
-10. Special Thanks                                         *ale-special-thanks*
-
-Special thanks to Mark Grealish (https://www.bhalash.com/) for providing ALE's
-snazzy looking ale glass logo. Cheers, Mark!
-
-===============================================================================
-11. Contact                                                       *ale-contact*
-
-If you like this plugin, and wish to get in touch, check out the GitHub
-page for issues and more at https://github.com/dense-analysis/ale
-
-If you wish to contact the author of this plugin directly, please feel
-free to send an email to devw0rp@gmail.com.
-
-Please drink responsibly, or not at all, which is ironically the preference
-of w0rp, who is teetotal.
-
-===============================================================================
-  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:
diff --git a/sources_non_forked/ale/ftplugin/ale-fix-suggest.vim b/sources_non_forked/ale/ftplugin/ale-fix-suggest.vim
deleted file mode 100644
index 189a4dc..0000000
--- a/sources_non_forked/ale/ftplugin/ale-fix-suggest.vim
+++ /dev/null
@@ -1,2 +0,0 @@
-" Close the ALEFixSuggest window with the q key.
-noremap <buffer> q :q!<CR>
diff --git a/sources_non_forked/ale/ftplugin/ale-preview-selection.vim b/sources_non_forked/ale/ftplugin/ale-preview-selection.vim
deleted file mode 100644
index 7ec8406..0000000
--- a/sources_non_forked/ale/ftplugin/ale-preview-selection.vim
+++ /dev/null
@@ -1,16 +0,0 @@
-" Close the ALEPreviewWindow window with the q key.
-noremap <buffer> q :q!<CR>
-" Disable some keybinds for the selection window.
-noremap <buffer> v <NOP>
-noremap <buffer> i <NOP>
-noremap <buffer> I <NOP>
-noremap <buffer> <C-q> <NOP>
-noremap <buffer> <C-v> <NOP>
-noremap <buffer> <S-v> <NOP>
-noremap <buffer> a <NOP>
-noremap <buffer> A <NOP>
-noremap <buffer> o <NOP>
-noremap <buffer> O <NOP>
-" Keybinds for opening selection items.
-noremap <buffer> <CR> :call ale#preview#OpenSelection()<CR>
-noremap <buffer> t :call ale#preview#OpenSelectionInTab()<CR>
diff --git a/sources_non_forked/ale/ftplugin/ale-preview.vim b/sources_non_forked/ale/ftplugin/ale-preview.vim
deleted file mode 100644
index ffbffbd..0000000
--- a/sources_non_forked/ale/ftplugin/ale-preview.vim
+++ /dev/null
@@ -1,2 +0,0 @@
-" Close the ALEPreviewWindow window with the q key.
-noremap <buffer> q :q!<CR>
diff --git a/sources_non_forked/ale/plugin/ale.vim b/sources_non_forked/ale/plugin/ale.vim
deleted file mode 100644
index e1ddf7b..0000000
--- a/sources_non_forked/ale/plugin/ale.vim
+++ /dev/null
@@ -1,300 +0,0 @@
-" Author: w0rp <devw0rp@gmail.com>
-" Description: Main entry point for the plugin: sets up prefs and autocommands
-"   Preferences can be set in vimrc files and so on to configure ale
-
-" Sanity Checks
-
-if exists('g:loaded_ale_dont_use_this_in_other_plugins_please')
-    finish
-endif
-
-" Set a special flag used only by this plugin for preventing doubly
-" loading the script.
-let g:loaded_ale_dont_use_this_in_other_plugins_please = 1
-
-" A flag for detecting if the required features are set.
-if has('nvim')
-    let s:has_features = has('timers') && has('nvim-0.2.0')
-else
-    " Check if Job and Channel functions are available, instead of the
-    " features. This works better on old MacVim versions.
-    let s:has_features = has('timers') && exists('*job_start') && exists('*ch_close_in')
-endif
-
-if !s:has_features
-    " Only output a warning if editing some special files.
-    if index(['', 'gitcommit'], &filetype) == -1
-        execute 'echoerr ''ALE requires NeoVim >= 0.2.0 or Vim 8 with +timers +job +channel'''
-        execute 'echoerr ''Please update your editor appropriately.'''
-    endif
-
-    " Stop here, as it won't work.
-    finish
-endif
-
-" Set this flag so that other plugins can use it, like airline.
-let g:loaded_ale = 1
-
-" This global variable is used internally by ALE for tracking information for
-" each buffer which linters are being run against.
-let g:ale_buffer_info = {}
-" This global Dictionary tracks data for fixing code. Don't mess with it.
-let g:ale_fix_buffer_data = {}
-
-" User Configuration
-
-" This option prevents ALE autocmd commands from being run for particular
-" filetypes which can cause issues.
-let g:ale_filetype_blacklist = [
-\   'dirvish',
-\   'nerdtree',
-\   'qf',
-\   'tags',
-\   'unite',
-\]
-
-" This Dictionary configures which linters are enabled for which languages.
-let g:ale_linters = get(g:, 'ale_linters', {})
-" This option can be changed to only enable explicitly selected linters.
-let g:ale_linters_explicit = get(g:, 'ale_linters_explicit', 0)
-
-" This Dictionary configures which functions will be used for fixing problems.
-let g:ale_fixers = get(g:, 'ale_fixers', {})
-
-" This Dictionary allows users to set up filetype aliases for new filetypes.
-let g:ale_linter_aliases = get(g:, 'ale_linter_aliases', {})
-
-" This flag can be set with a number of milliseconds for delaying the
-" execution of a linter when text is changed. The timeout will be set and
-" cleared each time text is changed, so repeated edits won't trigger the
-" jobs for linting until enough time has passed after editing is done.
-let g:ale_lint_delay = get(g:, 'ale_lint_delay', 200)
-
-" This flag can be set to 'never' to disable linting when text is changed.
-" This flag can also be set to 'always' or 'insert' to lint when text is
-" changed in both normal and insert mode, or only in insert mode respectively.
-let g:ale_lint_on_text_changed = get(g:, 'ale_lint_on_text_changed', 'normal')
-
-" This flag can be set to 1 to enable linting when leaving insert mode.
-let g:ale_lint_on_insert_leave = get(g:, 'ale_lint_on_insert_leave', 1)
-
-" This flag can be set to 0 to disable linting when the buffer is entered.
-let g:ale_lint_on_enter = get(g:, 'ale_lint_on_enter', 1)
-
-" This flag can be set to 1 to enable linting when a buffer is written.
-let g:ale_lint_on_save = get(g:, 'ale_lint_on_save', 1)
-
-" This flag can be set to 1 to enable linting when the filetype is changed.
-let g:ale_lint_on_filetype_changed = get(g:, 'ale_lint_on_filetype_changed', 1)
-
-" This Dictionary configures the default LSP roots for various linters.
-let g:ale_lsp_root = get(g:, 'ale_lsp_root', {})
-
-" This flag can be set to 1 to enable automatically fixing files on save.
-let g:ale_fix_on_save = get(g:, 'ale_fix_on_save', 0)
-
-" This flag may be set to 0 to disable ale. After ale is loaded, :ALEToggle
-" should be used instead.
-let g:ale_enabled = get(g:, 'ale_enabled', 1)
-
-" These flags dictates if ale uses the quickfix or the loclist (loclist is the
-" default, quickfix overrides loclist).
-let g:ale_set_loclist = get(g:, 'ale_set_loclist', 1)
-let g:ale_set_quickfix = get(g:, 'ale_set_quickfix', 0)
-
-" This flag can be set to 0 to disable setting signs.
-" This is enabled by default only if the 'signs' feature exists.
-let g:ale_set_signs = get(g:, 'ale_set_signs', has('signs'))
-
-" This flag can be set to 0 to disable setting error highlights.
-let g:ale_set_highlights = get(g:, 'ale_set_highlights', has('syntax'))
-
-" This List can be configured to exclude particular highlights.
-let g:ale_exclude_highlights = get(g:, 'ale_exclude_highlights', [])
-
-" This flag can be set to 0 to disable echoing when the cursor moves.
-let g:ale_echo_cursor = get(g:, 'ale_echo_cursor', 1)
-
-" This flag can be set to 1 to automatically show errors in the preview window.
-let g:ale_cursor_detail = get(g:, 'ale_cursor_detail', 0)
-
-" This flag can be set to 1 to enable virtual text when the cursor moves.
-let g:ale_virtualtext_cursor = get(g:, 'ale_virtualtext_cursor', 0)
-
-" This flag can be set to 1 to automatically close the preview window upon
-" entering Insert Mode.
-let g:ale_close_preview_on_insert = get(g:, 'ale_close_preview_on_insert', 0)
-
-" This flag can be set to 0 to disable balloon support.
-let g:ale_set_balloons = get(g:, 'ale_set_balloons', has('balloon_eval') && has('gui_running'))
-
-" Use preview window for hover messages.
-let g:ale_hover_to_preview = get(g:, 'ale_hover_to_preview', 0)
-
-" This flag can be set to 0 to disable warnings for trailing whitespace
-let g:ale_warn_about_trailing_whitespace = get(g:, 'ale_warn_about_trailing_whitespace', 1)
-" This flag can be set to 0 to disable warnings for trailing blank lines
-let g:ale_warn_about_trailing_blank_lines = get(g:, 'ale_warn_about_trailing_blank_lines', 1)
-
-" A flag for enabling or disabling the command history.
-let g:ale_history_enabled = get(g:, 'ale_history_enabled', 1)
-
-" A flag for storing the full output of commands in the history.
-let g:ale_history_log_output = get(g:, 'ale_history_log_output', 1)
-
-" Enable automatic completion with LSP servers and tsserver
-let g:ale_completion_enabled = get(g:, 'ale_completion_enabled', 0)
-
-" Enable automatic detection of pipenv for Python linters.
-let g:ale_python_auto_pipenv = get(g:, 'ale_python_auto_pipenv', 0)
-
-" This variable can be overridden to set the GO111MODULE environment variable.
-let g:ale_go_go111module = get(g:, 'ale_go_go111module', '')
-
-if g:ale_set_balloons
-    call ale#balloon#Enable()
-endif
-
-if g:ale_completion_enabled
-    call ale#completion#Enable()
-endif
-
-" Define commands for moving through warnings and errors.
-command! -bar -nargs=* ALEPrevious
-\    :call ale#loclist_jumping#WrapJump('before', <q-args>)
-command! -bar -nargs=* ALENext
-\    :call ale#loclist_jumping#WrapJump('after', <q-args>)
-
-command! -bar ALEPreviousWrap :call ale#loclist_jumping#Jump('before', 1)
-command! -bar ALENextWrap :call ale#loclist_jumping#Jump('after', 1)
-command! -bar ALEFirst :call ale#loclist_jumping#JumpToIndex(0)
-command! -bar ALELast :call ale#loclist_jumping#JumpToIndex(-1)
-
-" A command for showing error details.
-command! -bar ALEDetail :call ale#cursor#ShowCursorDetail()
-
-" Define commands for turning ALE on or off.
-command! -bar ALEToggle :call ale#toggle#Toggle()
-command! -bar ALEEnable :call ale#toggle#Enable()
-command! -bar ALEDisable :call ale#toggle#Disable()
-command! -bar ALEReset :call ale#toggle#Reset()
-" Commands for turning ALE on or off for a buffer.
-command! -bar ALEToggleBuffer :call ale#toggle#ToggleBuffer(bufnr(''))
-command! -bar ALEEnableBuffer :call ale#toggle#EnableBuffer(bufnr(''))
-command! -bar ALEDisableBuffer :call ale#toggle#DisableBuffer(bufnr(''))
-command! -bar ALEResetBuffer :call ale#toggle#ResetBuffer(bufnr(''))
-" A command to stop all LSP-like clients, including tsserver.
-command! -bar ALEStopAllLSPs :call ale#lsp#reset#StopAllLSPs()
-
-" A command for linting manually.
-command! -bar ALELint :call ale#Queue(0, 'lint_file')
-
-" Define a command to get information about current filetype.
-command! -bar ALEInfo :call ale#debugging#Info()
-" The same, but copy output to your clipboard.
-command! -bar ALEInfoToClipboard :call ale#debugging#InfoToClipboard()
-" Copy ALE information to a file.
-command! -bar -nargs=1 ALEInfoToFile :call ale#debugging#InfoToFile(<f-args>)
-
-" Fix problems in files.
-command! -bar -nargs=* -complete=customlist,ale#fix#registry#CompleteFixers ALEFix :call ale#fix#Fix(bufnr(''), '', <f-args>)
-" Suggest registered functions to use for fixing problems.
-command! -bar ALEFixSuggest :call ale#fix#registry#Suggest(&filetype)
-
-" Go to definition for tsserver and LSP
-command! -bar -nargs=* ALEGoToDefinition :call ale#definition#GoToCommandHandler('', <f-args>)
-
-" Deprecated commands we have to keep for now.
-command! -bar ALEGoToDefinitionInTab :call ale#definition#GoTo({'open_in': 'tab', 'deprecated_command': 'ALEGoToDefinitionInTab'})
-command! -bar ALEGoToDefinitionInSplit :call ale#definition#GoTo({'open_in': 'split', 'deprecated_command': 'ALEGoToDefinitionInSplit'})
-command! -bar ALEGoToDefinitionInVSplit :call ale#definition#GoTo({'open_in': 'vsplit', 'deprecated_command': 'ALEGoToDefinitionInVSplit'})
-
-" Go to type definition for tsserver and LSP
-command! -bar -nargs=* ALEGoToTypeDefinition :call ale#definition#GoToCommandHandler('type', <f-args>)
-
-" Deprecated commands we have to keep for now.
-command! -bar ALEGoToTypeDefinitionInTab :call ale#definition#GoToType({'open_in': 'tab', 'deprecated_command': 'ALEGoToTypeDefinitionInTab'})
-command! -bar ALEGoToTypeDefinitionInSplit :call ale#definition#GoToType({'open_in': 'split', 'deprecated_command': 'ALEGoToTypeDefinitionInSplit'})
-command! -bar ALEGoToTypeDefinitionInVSplit :call ale#definition#GoToType({'open_in': 'vsplit', 'deprecated_command': 'ALEGoToTypeDefinitionInVSplit'})
-
-" Repeat a previous selection in the preview window
-command! -bar ALERepeatSelection :call ale#preview#RepeatSelection()
-
-" Find references for tsserver and LSP
-command! -bar -nargs=* ALEFindReferences :call ale#references#Find(<f-args>)
-
-" Show summary information for the cursor.
-command! -bar ALEHover :call ale#hover#ShowAtCursor()
-
-" Show documentation for the cursor.
-command! -bar ALEDocumentation :call ale#hover#ShowDocumentationAtCursor()
-
-" Search for appearances of a symbol, such as a type name or function name.
-command! -nargs=1 ALESymbolSearch :call ale#symbol#Search(<q-args>)
-
-command! -bar ALEComplete :call ale#completion#GetCompletions('ale-manual')
-
-" Rename symbols using tsserver and LSP
-command! -bar ALERename :call ale#rename#Execute()
-
-" Organize import statements using tsserver
-command! -bar ALEOrganizeImports :call ale#organize_imports#Execute()
-
-" <Plug> mappings for commands
-nnoremap <silent> <Plug>(ale_previous) :ALEPrevious<Return>
-nnoremap <silent> <Plug>(ale_previous_wrap) :ALEPreviousWrap<Return>
-nnoremap <silent> <Plug>(ale_previous_error) :ALEPrevious -error<Return>
-nnoremap <silent> <Plug>(ale_previous_wrap_error) :ALEPrevious -wrap -error<Return>
-nnoremap <silent> <Plug>(ale_previous_warning) :ALEPrevious -warning<Return>
-nnoremap <silent> <Plug>(ale_previous_wrap_warning) :ALEPrevious -wrap -warning<Return>
-nnoremap <silent> <Plug>(ale_next) :ALENext<Return>
-nnoremap <silent> <Plug>(ale_next_wrap) :ALENextWrap<Return>
-nnoremap <silent> <Plug>(ale_next_error) :ALENext -error<Return>
-nnoremap <silent> <Plug>(ale_next_wrap_error) :ALENext -wrap -error<Return>
-nnoremap <silent> <Plug>(ale_next_warning) :ALENext -warning<Return>
-nnoremap <silent> <Plug>(ale_next_wrap_warning) :ALENext -wrap -warning<Return>
-nnoremap <silent> <Plug>(ale_first) :ALEFirst<Return>
-nnoremap <silent> <Plug>(ale_last) :ALELast<Return>
-nnoremap <silent> <Plug>(ale_toggle) :ALEToggle<Return>
-nnoremap <silent> <Plug>(ale_enable) :ALEEnable<Return>
-nnoremap <silent> <Plug>(ale_disable) :ALEDisable<Return>
-nnoremap <silent> <Plug>(ale_reset) :ALEReset<Return>
-nnoremap <silent> <Plug>(ale_toggle_buffer) :ALEToggleBuffer<Return>
-nnoremap <silent> <Plug>(ale_enable_buffer) :ALEEnableBuffer<Return>
-nnoremap <silent> <Plug>(ale_disable_buffer) :ALEDisableBuffer<Return>
-nnoremap <silent> <Plug>(ale_reset_buffer) :ALEResetBuffer<Return>
-nnoremap <silent> <Plug>(ale_lint) :ALELint<Return>
-nnoremap <silent> <Plug>(ale_detail) :ALEDetail<Return>
-nnoremap <silent> <Plug>(ale_fix) :ALEFix<Return>
-nnoremap <silent> <Plug>(ale_go_to_definition) :ALEGoToDefinition<Return>
-nnoremap <silent> <Plug>(ale_go_to_type_definition) :ALEGoToTypeDefinition<Return>
-nnoremap <silent> <Plug>(ale_find_references) :ALEFindReferences<Return>
-nnoremap <silent> <Plug>(ale_hover) :ALEHover<Return>
-nnoremap <silent> <Plug>(ale_documentation) :ALEDocumentation<Return>
-inoremap <silent> <Plug>(ale_complete) <C-\><C-O>:ALEComplete<Return>
-nnoremap <silent> <Plug>(ale_rename) :ALERename<Return>
-nnoremap <silent> <Plug>(ale_repeat_selection) :ALERepeatSelection<Return>
-
-" Deprecated <Plug> mappings
-nnoremap <silent> <Plug>(ale_go_to_definition_in_tab) :ALEGoToDefinitionInTab<Return>
-nnoremap <silent> <Plug>(ale_go_to_definition_in_split) :ALEGoToDefinitionInSplit<Return>
-nnoremap <silent> <Plug>(ale_go_to_definition_in_vsplit) :ALEGoToDefinitionInVSplit<Return>
-nnoremap <silent> <Plug>(ale_go_to_type_definition_in_tab) :ALEGoToTypeDefinitionInTab<Return>
-nnoremap <silent> <Plug>(ale_go_to_type_definition_in_split) :ALEGoToTypeDefinitionInSplit<Return>
-nnoremap <silent> <Plug>(ale_go_to_type_definition_in_vsplit) :ALEGoToTypeDefinitionInVSplit<Return>
-
-" Set up autocmd groups now.
-call ale#events#Init()
-
-" Housekeeping
-
-augroup ALECleanupGroup
-    autocmd!
-    " Clean up buffers automatically when they are unloaded.
-    autocmd BufDelete * if exists('*ale#engine#Cleanup') | call ale#engine#Cleanup(str2nr(expand('<abuf>'))) | endif
-    autocmd QuitPre * call ale#events#QuitEvent(str2nr(expand('<abuf>')))
-
-    if exists('##VimSuspend')
-        autocmd VimSuspend * if exists('*ale#engine#CleanupEveryBuffer') | call ale#engine#CleanupEveryBuffer() | endif
-    endif
-augroup END
diff --git a/sources_non_forked/ale/rplugin/python3/deoplete/sources/ale.py b/sources_non_forked/ale/rplugin/python3/deoplete/sources/ale.py
deleted file mode 100644
index ae1f403..0000000
--- a/sources_non_forked/ale/rplugin/python3/deoplete/sources/ale.py
+++ /dev/null
@@ -1,60 +0,0 @@
-"""
-A Deoplete source for ALE completion via tsserver and LSP.
-"""
-__author__ = 'Joao Paulo, w0rp'
-
-try:
-    from deoplete.source.base import Base
-except ImportError:
-    # Mock the Base class if deoplete isn't available, as mock isn't available
-    # in the Docker image.
-    class Base(object):
-        def __init__(self, vim):
-            pass
-
-
-# Make sure this code is valid in Python 2, used for running unit tests.
-class Source(Base):
-
-    def __init__(self, vim):
-        super(Source, self).__init__(vim)
-
-        self.name = 'ale'
-        self.mark = '[L]'
-        self.rank = 1000
-        self.is_bytepos = True
-        self.min_pattern_length = 1
-        self.is_volatile = True
-        # Do not forget to update s:trigger_character_map in completion.vim in
-        # updating entries in this map.
-        self.input_patterns = {
-            '_': r'\.\w*$',
-            'rust': r'(\.|::)\w*$',
-            'typescript': r'(\.|\'|")\w*$',
-            'cpp': r'(\.|::|->)\w*$',
-        }
-
-    # Returns an integer for the start position, as with omnifunc.
-    def get_complete_position(self, context):
-        return self.vim.call(
-            'ale#completion#GetCompletionPositionForDeoplete', context['input']
-        )
-
-    def gather_candidates(self, context):
-        # Stop early if ALE can't provide completion data for this buffer.
-        if not self.vim.call('ale#completion#CanProvideCompletions'):
-            return None
-
-        event = context.get('event')
-
-        if event == 'Async':
-            result = self.vim.call('ale#completion#GetCompletionResult')
-            return result or []
-
-        if context.get('is_refresh'):
-            self.vim.command(
-                "call ale#completion#GetCompletions('ale-callback', " + \
-                "{'callback': {completions -> deoplete#auto_complete() }})"
-            )
-
-        return []
diff --git a/sources_non_forked/ale/supported-tools.md b/sources_non_forked/ale/supported-tools.md
deleted file mode 100644
index 7d2f528..0000000
--- a/sources_non_forked/ale/supported-tools.md
+++ /dev/null
@@ -1,521 +0,0 @@
-# ALE Supported Languages and Tools
-
-This plugin supports the following languages and tools. All available
-tools will be run in combination, so they can be complementary.
-
-<!--
-Keep the table rows sorted alphabetically by the language name,
-and the tools in the tools column sorted alphabetically by the tool
-name. That seems to be the fairest way to arrange this table.
-
-Remember to also update doc/ale.txt, which has a similar list with different
-formatting.
--->
-
-**Legend**
-
-|      Key      |             Definition           |
-| ------------- | -------------------------------- |
-| :floppy_disk: | Only checked when saved to disk  |
-|   :warning:   | Disabled by default              |
-
----
-
-* Ada
-  * [gcc](https://gcc.gnu.org)
-  * [gnatpp](https://docs.adacore.com/gnat_ugn-docs/html/gnat_ugn/gnat_ugn/gnat_utility_programs.html#the-gnat-pretty-printer-gnatpp) :floppy_disk:
-* Ansible
-  * [ansible-lint](https://github.com/willthames/ansible-lint)
-* API Blueprint
-  * [drafter](https://github.com/apiaryio/drafter)
-* AsciiDoc
-  * [alex](https://github.com/wooorm/alex) :floppy_disk:
-  * [proselint](http://proselint.com/)
-  * [redpen](http://redpen.cc/)
-  * [textlint](https://textlint.github.io/)
-  * [vale](https://github.com/ValeLint/vale)
-  * [write-good](https://github.com/btford/write-good)
-* ASM
-  * [gcc](https://gcc.gnu.org)
-* Awk
-  * [gawk](https://www.gnu.org/software/gawk/)
-* Bash
-  * [language-server](https://github.com/mads-hartmann/bash-language-server)
-  * shell [-n flag](https://www.gnu.org/software/bash/manual/bash.html#index-set)
-  * [shellcheck](https://www.shellcheck.net/)
-  * [shfmt](https://github.com/mvdan/sh)
-* Bats
-  * [shellcheck](https://www.shellcheck.net/)
-* BibTeX
-  * [bibclean](http://ftp.math.utah.edu/pub/bibclean/)
-* Bourne Shell
-  * shell [-n flag](http://linux.die.net/man/1/sh)
-  * [shellcheck](https://www.shellcheck.net/)
-  * [shfmt](https://github.com/mvdan/sh)
-* C
-  * [ccls](https://github.com/MaskRay/ccls)
-  * [clang](http://clang.llvm.org/)
-  * [clangd](https://clang.llvm.org/extra/clangd.html)
-  * [clang-format](https://clang.llvm.org/docs/ClangFormat.html)
-  * [clangtidy](http://clang.llvm.org/extra/clang-tidy/) :floppy_disk:
-  * [cppcheck](http://cppcheck.sourceforge.net)
-  * [cpplint](https://github.com/google/styleguide/tree/gh-pages/cpplint)
-  * [cquery](https://github.com/cquery-project/cquery)
-  * [flawfinder](https://www.dwheeler.com/flawfinder/)
-  * [gcc](https://gcc.gnu.org/)
-  * [uncrustify](https://github.com/uncrustify/uncrustify)
-* C#
-  * [csc](http://www.mono-project.com/docs/about-mono/languages/csharp/) :floppy_disk: see:`help ale-cs-csc` for details and configuration
-  * [mcs](http://www.mono-project.com/docs/about-mono/languages/csharp/) see:`help ale-cs-mcs` for details
-  * [mcsc](http://www.mono-project.com/docs/about-mono/languages/csharp/) :floppy_disk: see:`help ale-cs-mcsc` for details and configuration
-  * [uncrustify](https://github.com/uncrustify/uncrustify)
-* C++ (filetype cpp)
-  * [ccls](https://github.com/MaskRay/ccls)
-  * [clang](http://clang.llvm.org/)
-  * [clangcheck](http://clang.llvm.org/docs/ClangCheck.html) :floppy_disk:
-  * [clangd](https://clang.llvm.org/extra/clangd.html)
-  * [clang-format](https://clang.llvm.org/docs/ClangFormat.html)
-  * [clangtidy](http://clang.llvm.org/extra/clang-tidy/) :floppy_disk:
-  * [clazy](https://github.com/KDE/clazy) :floppy_disk:
-  * [cppcheck](http://cppcheck.sourceforge.net)
-  * [cpplint](https://github.com/google/styleguide/tree/gh-pages/cpplint) :floppy_disk:
-  * [cquery](https://github.com/cquery-project/cquery)
-  * [flawfinder](https://www.dwheeler.com/flawfinder/)
-  * [gcc](https://gcc.gnu.org/)
-  * [uncrustify](https://github.com/uncrustify/uncrustify)
-* Chef
-  * [cookstyle](https://docs.chef.io/cookstyle.html)
-  * [foodcritic](http://www.foodcritic.io/)
-* Clojure
-  * [clj-kondo](https://github.com/borkdude/clj-kondo)
-  * [joker](https://github.com/candid82/joker)
-* CloudFormation
-  * [cfn-python-lint](https://github.com/awslabs/cfn-python-lint)
-* CMake
-  * [cmake-format](https://github.com/cheshirekow/cmake_format)
-  * [cmakelint](https://github.com/richq/cmake-lint)
-* CoffeeScript
-  * [coffee](http://coffeescript.org/)
-  * [coffeelint](https://www.npmjs.com/package/coffeelint)
-* Crystal
-  * [ameba](https://github.com/veelenga/ameba) :floppy_disk:
-  * [crystal](https://crystal-lang.org/) :floppy_disk:
-* CSS
-  * [csslint](http://csslint.net/)
-  * [fecs](http://fecs.baidu.com/)
-  * [prettier](https://github.com/prettier/prettier)
-  * [stylelint](https://github.com/stylelint/stylelint)
-* Cucumber
-  * [cucumber](https://cucumber.io/)
-* CUDA
-  * [nvcc](http://docs.nvidia.com/cuda/cuda-compiler-driver-nvcc/index.html)
-* Cypher
-  * [cypher-lint](https://github.com/cleishm/libcypher-parser)
-* Cython (pyrex filetype)
-  * [cython](http://cython.org/)
-* D
-  * [dfmt](https://github.com/dlang-community/dfmt)
-  * [dls](https://github.com/d-language-server/dls)
-  * [dmd](https://dlang.org/dmd-linux.html)
-  * [uncrustify](https://github.com/uncrustify/uncrustify)
-* Dafny
-  * [dafny](https://rise4fun.com/Dafny) :floppy_disk:
-* Dart
-  * [dartanalyzer](https://github.com/dart-lang/sdk/tree/master/pkg/analyzer_cli) :floppy_disk:
-  * [dartfmt](https://github.com/dart-lang/sdk/tree/master/utils/dartfmt)
-  * [language_server](https://github.com/natebosch/dart_language_server)
-* Dockerfile
-  * [dockerfile_lint](https://github.com/projectatomic/dockerfile_lint)
-  * [hadolint](https://github.com/hadolint/hadolint)
-* Elixir
-  * [credo](https://github.com/rrrene/credo)
-  * [dialyxir](https://github.com/jeremyjh/dialyxir) :floppy_disk:
-  * [dogma](https://github.com/lpil/dogma) :floppy_disk:
-  * [elixir-ls](https://github.com/JakeBecker/elixir-ls) :warning:
-  * [mix](https://hexdocs.pm/mix/Mix.html) :warning: :floppy_disk:
-* Elm
-  * [elm-format](https://github.com/avh4/elm-format)
-  * [elm-ls](https://github.com/elm-tooling/elm-language-server)
-  * [elm-make](https://github.com/elm/compiler)
-* Erb
-  * [erb](https://apidock.com/ruby/ERB)
-  * [erubi](https://github.com/jeremyevans/erubi)
-  * [erubis](https://github.com/kwatch/erubis)
-  * [ruumba](https://github.com/ericqweinstein/ruumba)
-* Erlang
-  * [erlc](http://erlang.org/doc/man/erlc.html)
-  * [SyntaxErl](https://github.com/ten0s/syntaxerl)
-* Fish
-  * fish [-n flag](https://linux.die.net/man/1/fish)
-* Fortran
-  * [gcc](https://gcc.gnu.org/)
-  * [language_server](https://github.com/hansec/fortran-language-server)
-* Fountain
-  * [proselint](http://proselint.com/)
-* FusionScript
-  * [fusion-lint](https://github.com/RyanSquared/fusionscript)
-* Git Commit Messages
-  * [gitlint](https://github.com/jorisroovers/gitlint)
-* GLSL
-  * [glslang](https://github.com/KhronosGroup/glslang)
-  * [glslls](https://github.com/svenstaro/glsl-language-server)
-* Go
-  * [bingo](https://github.com/saibing/bingo) :warning:
-  * [go build](https://golang.org/cmd/go/) :warning: :floppy_disk:
-  * [gofmt](https://golang.org/cmd/gofmt/)
-  * [goimports](https://godoc.org/golang.org/x/tools/cmd/goimports) :warning:
-  * [golangci-lint](https://github.com/golangci/golangci-lint) :warning: :floppy_disk:
-  * [golangserver](https://github.com/sourcegraph/go-langserver) :warning:
-  * [golint](https://godoc.org/github.com/golang/lint)
-  * [gometalinter](https://github.com/alecthomas/gometalinter) :warning: :floppy_disk:
-  * [go mod](https://golang.org/cmd/go/) :warning: :floppy_disk:
-  * [gopls](https://github.com/golang/go/wiki/gopls) :warning:
-  * [gosimple](https://github.com/dominikh/go-tools/tree/master/cmd/gosimple) :warning: :floppy_disk:
-  * [gotype](https://godoc.org/golang.org/x/tools/cmd/gotype) :warning: :floppy_disk:
-  * [go vet](https://golang.org/cmd/vet/) :floppy_disk:
-  * [revive](https://github.com/mgechev/revive) :warning: :floppy_disk:
-  * [staticcheck](https://github.com/dominikh/go-tools/tree/master/cmd/staticcheck) :warning: :floppy_disk:
-* GraphQL
-  * [eslint](http://eslint.org/)
-  * [gqlint](https://github.com/happylinks/gqlint)
-  * [prettier](https://github.com/prettier/prettier)
-* Hack
-  * [hack](http://hacklang.org/)
-  * [hackfmt](https://github.com/facebook/hhvm/tree/master/hphp/hack/hackfmt)
-  * [hhast](https://github.com/hhvm/hhast) :warning: (see `:help ale-integration-hack`)
-* Haml
-  * [haml-lint](https://github.com/brigade/haml-lint)
-* Handlebars
-  * [ember-template-lint](https://github.com/rwjblue/ember-template-lint)
-* Haskell
-  * [brittany](https://github.com/lspitzner/brittany)
-  * [cabal-ghc](https://www.haskell.org/cabal/)
-  * [floskell](https://github.com/ennocramer/floskell)
-  * [ghc](https://www.haskell.org/ghc/)
-  * [ghc-mod](https://github.com/DanielG/ghc-mod)
-  * [hdevtools](https://hackage.haskell.org/package/hdevtools)
-  * [hfmt](https://github.com/danstiner/hfmt)
-  * [hie](https://github.com/haskell/haskell-ide-engine)
-  * [hindent](https://hackage.haskell.org/package/hindent)
-  * [hlint](https://hackage.haskell.org/package/hlint)
-  * [stack-build](https://haskellstack.org/) :floppy_disk:
-  * [stack-ghc](https://haskellstack.org/)
-  * [stylish-haskell](https://github.com/jaspervdj/stylish-haskell)
-* HCL
-  * [terraform-fmt](https://github.com/hashicorp/terraform)
-* HTML
-  * [alex](https://github.com/wooorm/alex) :floppy_disk:
-  * [fecs](http://fecs.baidu.com/)
-  * [html-beautify](https://beautifier.io/)
-  * [HTMLHint](http://htmlhint.com/)
-  * [prettier](https://github.com/prettier/prettier)
-  * [proselint](http://proselint.com/)
-  * [tidy](http://www.html-tidy.org/)
-  * [write-good](https://github.com/btford/write-good)
-* Idris
-  * [idris](http://www.idris-lang.org/)
-* Ink
-  * [ink-language-server](https://github.com/ephread/ink-language-server)
-* ISPC
-  * [ispc](https://ispc.github.io/) :floppy_disk:
-* Java
-  * [checkstyle](http://checkstyle.sourceforge.net)
-  * [eclipselsp](https://github.com/eclipse/eclipse.jdt.ls)
-  * [google-java-format](https://github.com/google/google-java-format)
-  * [javac](http://www.oracle.com/technetwork/java/javase/downloads/index.html)
-  * [javalsp](https://github.com/georgewfraser/vscode-javac)
-  * [PMD](https://pmd.github.io/)
-  * [uncrustify](https://github.com/uncrustify/uncrustify)
-* JavaScript
-  * [eslint](http://eslint.org/)
-  * [fecs](http://fecs.baidu.com/)
-  * [flow](https://flowtype.org/)
-  * [jscs](https://jscs-dev.github.io/)
-  * [jshint](http://jshint.com/)
-  * [prettier](https://github.com/prettier/prettier)
-  * [prettier-eslint](https://github.com/prettier/prettier-eslint-cli)
-  * [prettier-standard](https://github.com/sheerun/prettier-standard)
-  * [standard](http://standardjs.com/)
-  * [tsserver](https://github.com/Microsoft/TypeScript/wiki/Standalone-Server-%28tsserver%29)
-  * [xo](https://github.com/sindresorhus/xo)
-* JSON
-  * [fixjson](https://github.com/rhysd/fixjson)
-  * [jq](https://stedolan.github.io/jq/)
-  * [jsonlint](http://zaa.ch/jsonlint/)
-  * [prettier](https://github.com/prettier/prettier)
-* Julia
-  * [languageserver](https://github.com/JuliaEditorSupport/LanguageServer.jl)
-* Kotlin
-  * [kotlinc](https://kotlinlang.org) :floppy_disk:
-  * [ktlint](https://ktlint.github.io) :floppy_disk:
-  * [languageserver](https://github.com/fwcd/KotlinLanguageServer) see `:help ale-integration-kotlin` for configuration instructions
-* LaTeX
-  * [alex](https://github.com/wooorm/alex) :floppy_disk:
-  * [chktex](http://www.nongnu.org/chktex/)
-  * [lacheck](https://www.ctan.org/pkg/lacheck)
-  * [proselint](http://proselint.com/)
-  * [redpen](http://redpen.cc/)
-  * [texlab](https://texlab.netlify.com)
-  * [textlint](https://textlint.github.io/)
-  * [vale](https://github.com/ValeLint/vale)
-  * [write-good](https://github.com/btford/write-good)
-* Less
-  * [lessc](https://www.npmjs.com/package/less)
-  * [prettier](https://github.com/prettier/prettier)
-  * [stylelint](https://github.com/stylelint/stylelint)
-* LLVM
-  * [llc](https://llvm.org/docs/CommandGuide/llc.html)
-* Lua
-  * [luac](https://www.lua.org/manual/5.1/luac.html)
-  * [luacheck](https://github.com/mpeterv/luacheck)
-* Mail
-  * [alex](https://github.com/wooorm/alex) :floppy_disk:
-  * [languagetool](https://languagetool.org/) :floppy_disk:
-  * [proselint](http://proselint.com/)
-  * [vale](https://github.com/ValeLint/vale)
-* Make
-  * [checkmake](https://github.com/mrtazz/checkmake)
-* Markdown
-  * [alex](https://github.com/wooorm/alex) :floppy_disk:
-  * [languagetool](https://languagetool.org/) :floppy_disk:
-  * [markdownlint](https://github.com/DavidAnson/markdownlint) :floppy_disk:
-  * [mdl](https://github.com/mivok/markdownlint)
-  * [prettier](https://github.com/prettier/prettier)
-  * [proselint](http://proselint.com/)
-  * [redpen](http://redpen.cc/)
-  * [remark-lint](https://github.com/wooorm/remark-lint)
-  * [textlint](https://textlint.github.io/)
-  * [vale](https://github.com/ValeLint/vale)
-  * [write-good](https://github.com/btford/write-good)
-* MATLAB
-  * [mlint](https://www.mathworks.com/help/matlab/ref/mlint.html)
-* Mercury
-  * [mmc](http://mercurylang.org) :floppy_disk:
-* NASM
-  * [nasm](https://www.nasm.us/) :floppy_disk:
-* Nim
-  * [nim check](https://nim-lang.org/docs/nimc.html) :floppy_disk:
-  * [nimlsp](https://github.com/PMunch/nimlsp)
-  * nimpretty
-* nix
-  * [nix-instantiate](http://nixos.org/nix/manual/#sec-nix-instantiate)
-  * [nixpkgs-fmt](https://github.com/nix-community/nixpkgs-fmt)
-* nroff
-  * [alex](https://github.com/wooorm/alex) :floppy_disk:
-  * [proselint](http://proselint.com/)
-  * [write-good](https://github.com/btford/write-good)
-* Objective-C
-  * [ccls](https://github.com/MaskRay/ccls)
-  * [clang](http://clang.llvm.org/)
-  * [clangd](https://clang.llvm.org/extra/clangd.html)
-  * [uncrustify](https://github.com/uncrustify/uncrustify)
-* Objective-C++
-  * [clang](http://clang.llvm.org/)
-  * [clangd](https://clang.llvm.org/extra/clangd.html)
-  * [uncrustify](https://github.com/uncrustify/uncrustify)
-* OCaml
-  * [merlin](https://github.com/the-lambda-church/merlin) see `:help ale-ocaml-merlin` for configuration instructions
-  * [ocamlformat](https://github.com/ocaml-ppx/ocamlformat)
-  * [ocp-indent](https://github.com/OCamlPro/ocp-indent)
-  * [ols](https://github.com/freebroccolo/ocaml-language-server)
-* Pawn
-  * [uncrustify](https://github.com/uncrustify/uncrustify)
-* Perl
-  * [perl -c](https://perl.org/) :warning:
-  * [perl-critic](https://metacpan.org/pod/Perl::Critic)
-  * [perltidy](https://metacpan.org/pod/distribution/Perl-Tidy/bin/perltidy)
-* Perl6
-  * [perl6 -c](https://perl6.org) :warning:
-* PHP
-  * [langserver](https://github.com/felixfbecker/php-language-server)
-  * [phan](https://github.com/phan/phan) see `:help ale-php-phan` to instructions
-  * [phpcbf](https://github.com/squizlabs/PHP_CodeSniffer)
-  * [phpcs](https://github.com/squizlabs/PHP_CodeSniffer)
-  * [php-cs-fixer](http://cs.sensiolabs.org/)
-  * [php -l](https://secure.php.net/)
-  * [phpmd](https://phpmd.org)
-  * [phpstan](https://github.com/phpstan/phpstan)
-  * [psalm](https://getpsalm.org) :floppy_disk:
-* PO
-  * [alex](https://github.com/wooorm/alex) :floppy_disk:
-  * [msgfmt](https://www.gnu.org/software/gettext/manual/html_node/msgfmt-Invocation.html)
-  * [proselint](http://proselint.com/)
-  * [write-good](https://github.com/btford/write-good)
-* Pod
-  * [alex](https://github.com/wooorm/alex) :floppy_disk:
-  * [proselint](http://proselint.com/)
-  * [write-good](https://github.com/btford/write-good)
-* Pony
-  * [ponyc](https://github.com/ponylang/ponyc)
-* PowerShell
-  * [powershell](https://github.com/PowerShell/PowerShell) :floppy_disk:
-  * [psscriptanalyzer](https://github.com/PowerShell/PSScriptAnalyzer) :floppy_disk:
-* Prolog
-  * [swipl](https://github.com/SWI-Prolog/swipl-devel)
-* proto
-  * [protoc-gen-lint](https://github.com/ckaznocha/protoc-gen-lint)
-* Pug
-  * [pug-lint](https://github.com/pugjs/pug-lint)
-* Puppet
-  * [languageserver](https://github.com/lingua-pupuli/puppet-editor-services)
-  * [puppet](https://puppet.com)
-  * [puppet-lint](https://puppet-lint.com)
-* PureScript
-  * [purescript-language-server](https://github.com/nwolverson/purescript-language-server)
-  * [purty](https://gitlab.com/joneshf/purty)
-* Python
-  * [autopep8](https://github.com/hhatto/autopep8)
-  * [bandit](https://github.com/PyCQA/bandit) :warning:
-  * [black](https://github.com/ambv/black)
-  * [flake8](http://flake8.pycqa.org/en/latest/)
-  * [isort](https://github.com/timothycrosley/isort)
-  * [mypy](http://mypy-lang.org/)
-  * [prospector](https://github.com/PyCQA/prospector) :warning:
-  * [pycodestyle](https://github.com/PyCQA/pycodestyle) :warning:
-  * [pydocstyle](https://www.pydocstyle.org/) :warning:
-  * [pyflakes](https://github.com/PyCQA/pyflakes)
-  * [pylama](https://github.com/klen/pylama) :floppy_disk:
-  * [pylint](https://www.pylint.org/) :floppy_disk:
-  * [pyls](https://github.com/palantir/python-language-server) :warning:
-  * [pyre](https://github.com/facebook/pyre-check) :warning:
-  * [reorder-python-imports](https://github.com/asottile/reorder_python_imports)
-  * [vulture](https://github.com/jendrikseipp/vulture) :warning: :floppy_disk:
-  * [yapf](https://github.com/google/yapf)
-* QML
-  * [qmlfmt](https://github.com/jesperhh/qmlfmt)
-  * [qmllint](https://github.com/qt/qtdeclarative/tree/5.11/tools/qmllint)
-* R
-  * [lintr](https://github.com/jimhester/lintr)
-  * [styler](https://github.com/r-lib/styler)
-* Racket
-  * [raco](https://docs.racket-lang.org/raco/)
-* ReasonML
-  * [merlin](https://github.com/the-lambda-church/merlin) see `:help ale-reasonml-ols` for configuration instructions
-  * [ols](https://github.com/freebroccolo/ocaml-language-server)
-  * [reason-language-server](https://github.com/jaredly/reason-language-server)
-  * [refmt](https://github.com/reasonml/reason-cli)
-* reStructuredText
-  * [alex](https://github.com/wooorm/alex) :floppy_disk:
-  * [proselint](http://proselint.com/)
-  * [redpen](http://redpen.cc/)
-  * [rstcheck](https://github.com/myint/rstcheck)
-  * [textlint](https://textlint.github.io/)
-  * [vale](https://github.com/ValeLint/vale)
-  * [write-good](https://github.com/btford/write-good)
-* Re:VIEW
-  * [redpen](http://redpen.cc/)
-* RPM spec
-  * [rpmlint](https://github.com/rpm-software-management/rpmlint) :warning: (see `:help ale-integration-spec`)
-* Ruby
-  * [brakeman](http://brakemanscanner.org/) :floppy_disk:
-  * [debride](https://github.com/seattlerb/debride) :floppy_disk:
-  * [rails_best_practices](https://github.com/flyerhzm/rails_best_practices) :floppy_disk:
-  * [reek](https://github.com/troessner/reek)
-  * [rubocop](https://github.com/bbatsov/rubocop)
-  * [ruby](https://www.ruby-lang.org)
-  * [rufo](https://github.com/ruby-formatter/rufo)
-  * [solargraph](https://solargraph.org)
-  * [sorbet](https://github.com/sorbet/sorbet)
-  * [standardrb](https://github.com/testdouble/standard)
-* Rust
-  * [cargo](https://github.com/rust-lang/cargo) :floppy_disk: (see `:help ale-integration-rust` for configuration instructions)
-  * [rls](https://github.com/rust-lang-nursery/rls) :warning:
-  * [rust-analyzer](https://github.com/rust-analyzer/rust-analyzer) :warning:
-  * [rustc](https://www.rust-lang.org/) :warning:
-  * [rustfmt](https://github.com/rust-lang-nursery/rustfmt)
-* Sass
-  * [sass-lint](https://www.npmjs.com/package/sass-lint)
-  * [stylelint](https://github.com/stylelint/stylelint)
-* Scala
-  * [fsc](https://www.scala-lang.org/old/sites/default/files/linuxsoft_archives/docu/files/tools/fsc.html)
-  * [metals](https://scalameta.org/metals/)
-  * [sbtserver](https://www.scala-sbt.org/1.x/docs/sbt-server.html)
-  * [scalac](http://scala-lang.org)
-  * [scalafmt](https://scalameta.org/scalafmt/)
-  * [scalastyle](http://www.scalastyle.org)
-* SCSS
-  * [prettier](https://github.com/prettier/prettier)
-  * [sass-lint](https://www.npmjs.com/package/sass-lint)
-  * [scss-lint](https://github.com/brigade/scss-lint)
-  * [stylelint](https://github.com/stylelint/stylelint)
-* Slim
-  * [slim-lint](https://github.com/sds/slim-lint)
-* SML
-  * [smlnj](http://www.smlnj.org/)
-* Solidity
-  * [solc](https://solidity.readthedocs.io/)
-  * [solhint](https://github.com/protofire/solhint)
-  * [solium](https://github.com/duaraghav8/Solium)
-* SQL
-  * [pgformatter](https://github.com/darold/pgFormatter)
-  * [sqlfmt](https://github.com/jackc/sqlfmt)
-  * [sqlformat](https://github.com/andialbrecht/sqlparse)
-  * [sqlint](https://github.com/purcell/sqlint)
-* Stylus
-  * [stylelint](https://github.com/stylelint/stylelint)
-* SugarSS
-  * [stylelint](https://github.com/stylelint/stylelint)
-* Swift
-  * [sourcekit-lsp](https://github.com/apple/sourcekit-lsp)
-  * [swiftformat](https://github.com/nicklockwood/SwiftFormat)
-  * [swiftlint](https://github.com/realm/SwiftLint)
-* Tcl
-  * [nagelfar](http://nagelfar.sourceforge.net) :floppy_disk:
-* Terraform
-  * [fmt](https://github.com/hashicorp/terraform)
-  * [tflint](https://github.com/wata727/tflint)
-* Texinfo
-  * [alex](https://github.com/wooorm/alex) :floppy_disk:
-  * [proselint](http://proselint.com/)
-  * [write-good](https://github.com/btford/write-good)
-* Text
-  * [alex](https://github.com/wooorm/alex) :warning: :floppy_disk:
-  * [languagetool](https://languagetool.org/) :floppy_disk:
-  * [proselint](http://proselint.com/) :warning:
-  * [redpen](http://redpen.cc/) :warning:
-  * [textlint](https://textlint.github.io/) :warning:
-  * [vale](https://github.com/ValeLint/vale) :warning:
-  * [write-good](https://github.com/btford/write-good) :warning:
-* Thrift
-  * [thrift](http://thrift.apache.org/)
-* TypeScript
-  * [eslint](http://eslint.org/)
-  * [fecs](http://fecs.baidu.com/)
-  * [prettier](https://github.com/prettier/prettier)
-  * [standard](http://standardjs.com/)
-  * [tslint](https://github.com/palantir/tslint)
-  * [tsserver](https://github.com/Microsoft/TypeScript/wiki/Standalone-Server-%28tsserver%29)
-  * typecheck
-* VALA
-  * [uncrustify](https://github.com/uncrustify/uncrustify)
-* Verilog
-  * [iverilog](https://github.com/steveicarus/iverilog)
-  * [verilator](http://www.veripool.org/projects/verilator/wiki/Intro)
-  * [vlog](https://www.mentor.com/products/fv/questa/)
-  * [xvlog](https://www.xilinx.com/products/design-tools/vivado.html)
-* VHDL
-  * [ghdl](https://github.com/ghdl/ghdl)
-  * [vcom](https://www.mentor.com/products/fv/questa/)
-  * [xvhdl](https://www.xilinx.com/products/design-tools/vivado.html)
-* Vim
-  * [vimls](https://github.com/iamcco/vim-language-server)
-  * [vint](https://github.com/Kuniwak/vint)
-* Vim help
-  * [alex](https://github.com/wooorm/alex) :warning: :floppy_disk:
-  * [proselint](http://proselint.com/) :warning:
-  * [write-good](https://github.com/btford/write-good) :warning:
-* Vue
-  * [prettier](https://github.com/prettier/prettier)
-  * [vls](https://github.com/vuejs/vetur/tree/master/server)
-* XHTML
-  * [alex](https://github.com/wooorm/alex) :floppy_disk:
-  * [proselint](http://proselint.com/)
-  * [write-good](https://github.com/btford/write-good)
-* XML
-  * [xmllint](http://xmlsoft.org/xmllint.html)
-* YAML
-  * [prettier](https://github.com/prettier/prettier)
-  * [swaglint](https://github.com/byCedric/swaglint)
-  * [yamllint](https://yamllint.readthedocs.io/)
-* YANG
-  * [yang-lsp](https://github.com/theia-ide/yang-lsp)
diff --git a/sources_non_forked/ale/syntax/ale-fix-suggest.vim b/sources_non_forked/ale/syntax/ale-fix-suggest.vim
deleted file mode 100644
index b112f5b..0000000
--- a/sources_non_forked/ale/syntax/ale-fix-suggest.vim
+++ /dev/null
@@ -1,13 +0,0 @@
-if exists('b:current_syntax')
-    finish
-endif
-
-syn match aleFixerComment /^.*$/
-syn match aleFixerName /\(^\|, \)'[^']*'/
-syn match aleFixerHelp /^See :help ale-fix-configuration/
-
-hi def link aleFixerComment Comment
-hi def link aleFixerName String
-hi def link aleFixerHelp Statement
-
-let b:current_syntax = 'ale-fix-suggest'
diff --git a/sources_non_forked/ale/syntax/ale-preview-selection.vim b/sources_non_forked/ale/syntax/ale-preview-selection.vim
deleted file mode 100644
index 879ba09..0000000
--- a/sources_non_forked/ale/syntax/ale-preview-selection.vim
+++ /dev/null
@@ -1,11 +0,0 @@
-if exists('b:current_syntax')
-    finish
-endif
-
-syn match alePreviewSelectionFilename /\v^([a-zA-Z]?:?[^:]+)/
-syn match alPreviewNumber /\v:\d+:\d+$/
-
-hi def link alePreviewSelectionFilename String
-hi def link alePreviewNumber Number
-
-let b:current_syntax = 'ale-preview-selection'
diff --git a/sources_non_forked/auto-pairs/.gitignore b/sources_non_forked/auto-pairs/.gitignore
deleted file mode 100644
index 926ccaa..0000000
--- a/sources_non_forked/auto-pairs/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-doc/tags
diff --git a/sources_non_forked/auto-pairs/README.md b/sources_non_forked/auto-pairs/README.md
deleted file mode 100644
index 8d079ba..0000000
--- a/sources_non_forked/auto-pairs/README.md
+++ /dev/null
@@ -1,411 +0,0 @@
-Auto Pairs
-==========
-Insert or delete brackets, parens, quotes in pair.
-
-Installation
-------------
-
-* Manual
-  * Copy `plugin/auto-pairs.vim` to `~/.vim/plugin`
-* [Pathogen](https://github.com/tpope/vim-pathogen)
-  * `git clone git://github.com/jiangmiao/auto-pairs.git ~/.vim/bundle/auto-pairs`
-* [Vundle](https://github.com/VundleVim/Vundle.vim)
-  * `Plugin 'jiangmiao/auto-pairs'`
-
-Features
---------
-*   Insert in pair
-
-        input: [
-        output: [|]
-
-*   Delete in pair
-
-        input: foo[<BS>]
-        output: foo
-
-*   Insert new indented line after Return
-
-        input: {|} (press <CR> at |)
-        output: {
-            |
-        }          (press } to close the pair)
-        output: {
-        }|         (the inserted blank line will be deleted)
-
-
-*   Insert spaces before closing characters, only for [], (), {}
-
-        input: {|} (press <SPACE> at |)
-        output: { | }
-
-        input: {|} (press <SPACE>foo} at |)
-        output: { foo }|
-
-        input: '|' (press <SPACE> at |)
-        output: ' |'
-
-*   Skip ' when inside a word
-
-        input: foo| (press ' at |)
-        output: foo'
-
-*   Skip closed bracket.
-
-        input: []
-        output: []
-
-*   Ignore auto pair when previous character is \
-
-        input: "\'
-        output: "\'"
-
-*   Fast Wrap
-
-        input: |[foo, bar()] (press (<M-e> at |)
-        output: ([foo, bar()])
-
-*   Quick move char to closed pair
-
-        input: (|){["foo"]} (press <M-}> at |)
-        output: ({["foo"]}|)
-
-        input: |[foo, bar()] (press (<M-]> at |)
-        output: ([foo, bar()]|)
-
-*   Quick jump to closed pair.
-
-        input:
-        {
-            something;|
-        }
-
-        (press } at |)
-
-        output:
-        {
-
-        }|
-
-*  Fly Mode
-
-        input: if(a[3)
-        output: if(a[3])| (In Fly Mode)
-        output: if(a[3)]) (Without Fly Mode)
-
-        input:
-        {
-            hello();|
-            world();
-        }
-
-        (press } at |)
-
-        output:
-        {
-            hello();
-            world();
-        }|
-
-        (then press <M-b> at | to do backinsert)
-        output:
-        {
-            hello();}|
-            world();
-        }
-
-        See Fly Mode section for details
-
-*  Multibyte Pairs
-        
-        Support any multibyte pairs such as <!-- -->, <% %>, """ """
-        See multibyte pairs section for details
-
-Fly Mode
---------
-Fly Mode will always force closed-pair jumping instead of inserting. only for ")", "}", "]"
-
-If jumps in mistake, could use AutoPairsBackInsert(Default Key: `<M-b>`) to jump back and insert closed pair.
-
-the most situation maybe want to insert single closed pair in the string, eg ")"
-
-Fly Mode is DISABLED by default.
-
-add **let g:AutoPairsFlyMode = 1** .vimrc to turn it on
-
-Default Options:
-
-    let g:AutoPairsFlyMode = 0
-    let g:AutoPairsShortcutBackInsert = '<M-b>'
-
-Shortcuts
----------
-
-    System Shortcuts:
-        <CR>  : Insert new indented line after return if cursor in blank brackets or quotes.
-        <BS>  : Delete brackets in pair
-        <M-p> : Toggle Autopairs (g:AutoPairsShortcutToggle)
-        <M-e> : Fast Wrap (g:AutoPairsShortcutFastWrap)
-        <M-n> : Jump to next closed pair (g:AutoPairsShortcutJump)
-        <M-b> : BackInsert (g:AutoPairsShortcutBackInsert)
-
-    If <M-p> <M-e> or <M-n> conflict with another keys or want to bind to another keys, add
-
-        let g:AutoPairsShortcutToggle = '<another key>'
-
-    to .vimrc, if the key is empty string '', then the shortcut will be disabled.
-
-Options
--------
-*   g:AutoPairs
-
-        Default: {'(':')', '[':']', '{':'}',"'":"'",'"':'"', "`":"`", '```':'```', '"""':'"""', "'''":"'''"}
-
-*   b:AutoPairs
-
-        Default: g:AutoPairs
-
-        Buffer level pairs set.
-
-*   g:AutoPairsShortcutToggle
-
-        Default: '<M-p>'
-
-        The shortcut to toggle autopairs.
-
-*   g:AutoPairsShortcutFastWrap
-
-        Default: '<M-e>'
-
-        Fast wrap the word. all pairs will be consider as a block (include <>).
-        (|)'hello' after fast wrap at |, the word will be ('hello')
-        (|)<hello> after fast wrap at |, the word will be (<hello>)
-
-*   g:AutoPairsShortcutJump
-
-        Default: '<M-n>'
-
-        Jump to the next closed pair
-
-*   g:AutoPairsMapBS
-
-        Default : 1
-
-        Map <BS> to delete brackets, quotes in pair
-        execute 'inoremap <buffer> <silent> <BS> <C-R>=AutoPairsDelete()<CR>'
-
-*   g:AutoPairsMapCh
-
-        Default : 1
-
-        Map <C-h> to delete brackets, quotes in pair
-
-*   g:AutoPairsMapCR
-
-        Default : 1
-
-        Map <CR> to insert a new indented line if cursor in (|), {|} [|], '|', "|"
-        execute 'inoremap <buffer> <silent> <CR> <C-R>=AutoPairsReturn()<CR>'
-
-*   g:AutoPairsCenterLine
-
-        Default : 1
-
-        When g:AutoPairsMapCR is on, center current line after return if the line is at the bottom 1/3 of the window.
-
-*   g:AutoPairsMapSpace
-
-        Default : 1
-
-        Map <space> to insert a space after the opening character and before the closing one.
-        execute 'inoremap <buffer> <silent> <CR> <C-R>=AutoPairsSpace()<CR>'
-
-*   g:AutoPairsFlyMode
-
-        Default : 0
-
-        set it to 1 to enable FlyMode.
-        see FlyMode section for details.
-
-*   g:AutoPairsMultilineClose
-
-        Default : 1
-
-        When you press the key for the closing pair (e.g. `)`) it jumps past it.
-        If set to 1, then it'll jump to the next line, if there is only whitespace.
-        If set to 0, then it'll only jump to a closing pair on the same line.
-
-*   g:AutoPairsShortcutBackInsert
-
-        Default : <M-b>
-
-        Work with FlyMode, insert the key at the Fly Mode jumped postion
-
-*   g:AutoPairsMoveCharacter
-
-        Default: "()[]{}\"'"
-
-        Map <M-(> <M-)> <M-[> <M-]> <M-{> <M-}> <M-"> <M-'> to
-        move character under the cursor to the pair.
-
-Buffer Level Pairs Setting
---------------------------
-
-Set b:AutoPairs before BufEnter
-
-eg:
-
-    " When the filetype is FILETYPE then make AutoPairs only match for parenthesis
-    au Filetype FILETYPE let b:AutoPairs = {"(": ")"}
-    au FileType php      let b:AutoPairs = AutoPairsDefine({'<?' : '?>', '<?php': '?>'})
-
-Multibyte Pairs
----------------
-
-    The default pairs is {'(':')', '[':']', '{':'}',"'":"'",'"':'"', '`':'`'}
-    You could also define multibyte pairs such as <!-- -->, <% %> and so on
-
-* Function AutoPairsDefine(addPairs:dict[, removeOpenPairList:list])
-
-        add or delete pairs base on g:AutoPairs
-
-        eg:
-            au FileType html let b:AutoPairs = AutoPairsDefine({'<!--' : '-->'}, ['{'])
-            add <!-- --> pair and remove '{' for html file
-
-        the pair implict start with \V, so if want to match start of line ^ should be write in \^ vim comment {'\^"': ''}
-
-* General usage
-
-        au FileType php      let b:AutoPairs = AutoPairsDefine({'<?' : '?>', '<?php': '?>'})
-
-        the first key of closed pair ? will be mapped
-
-        pairs: '<?' : '?>', '<?php': '?>'
-        input: <?
-        output: <?|?>
-
-        input: <?php
-        output: <?php|?>
-
-        input: he<?php|?> (press <BS> at|)
-        output: he|
-
-        input: <?php|?> (press ? at|)
-        output: <?php?>|
-
-        pair: '[[':']]'
-        input: [[|]] (press <BS>)
-        output: | ([[ and ]] will be deleted the [['s priority is higher than [ for it's longer)
-
-* Modifier
-
-        The text after //  in close pair is modifiers
-
-        n - do not map the first charactor of closed pair to close key
-        m - close key jumps through multi line
-        s - close key jumps only in the same line
-        k[KEY] - map the close key to [KEY]
-
-            by default if open key equals close key the multi line is turn off
-
-            "<?": "?>"      ? jumps only in the same line
-            "<?": "?>//m"   force ? jumping through multi line
-            "<?php":"?>"    ? will jump through multi line
-            "<?php":"?>//s" force ? only jumping in the same line
-            "<?": "?>//n"   do not jump totally
-            "<?": "?>//k]"  use key ] to jump through ?>
-
-        for 'begin' 'end' pair, e is a charactor, if map e to jump will be annoy, so use modifier 'n' to skip key map
-
-        au FileType ruby     let b:AutoPairs = AutoPairsDefine({'begin': 'end//n]'})
-
-
-        input: begin
-        output: begin|end
-
-        input: begin|end (press <BS> on |)
-        output: |
-
-        input: begin|end (press e on |)
-        output: begineend (will not jump for e is not mapped)
-
-* Advanced usage
-
-        au FileType rust     let b:AutoPairs = AutoPairsDefine({'\w\zs<': '>'})
-
-        if press < after a word will generate the pair
-
-        when use regexp MUST use \zs to prevent catching
-        if use '\w<' without \zs,  for text hello<|> press <BS> on | will output 'hell', the 'o' has been deleted
-
-        pair: '\w\zs<': '>'
-        input: h <
-        output: h <
-
-        input: h<
-        output: h<|>
-
-        input: h<|> press <BS>
-        output: h|
-
-        pair: '\w<': '>' (WRONG pair which missed \zs)
-        input: h<|> press <BS>
-        output: | (charactor 'h' is deleted)
-
-
-        the 'begin' 'end' pair write in
-
-        au FileType ruby     let b:AutoPairs = AutoPairsDefine({'\v(^|\W)\zsbegin': 'end//n'})
-
-        will be better, only auto pair when at start of line or follow non-word text
-
-TroubleShooting
----------------
-    The script will remap keys ([{'"}]) <BS>,
-    If auto pairs cannot work, use :imap ( to check if the map is corrected.
-    The correct map should be <C-R>=AutoPairsInsert("\(")<CR>
-    Or the plugin conflict with some other plugins.
-    use command :call AutoPairsInit() to remap the keys.
-
-
-* How to insert parens purely
-
-    There are 3 ways
-
-    1. use Ctrl-V ) to insert paren without trigger the plugin.
-
-    2. use Alt-P to turn off the plugin.
-
-    3. use DEL or <C-O>x to delete the character insert by plugin.
-
-* Swedish Character Conflict
-
-    Because AutoPairs uses Meta(Alt) key as shortcut, it is conflict with some Swedish character such as .
-    To fix the issue, you need remap or disable the related shortcut.
-
-Known Issues
-------------
-Breaks '.' - [issue #3](https://github.com/jiangmiao/auto-pairs/issues/3)
-
-    Description: After entering insert mode and inputing `[hello` then leave insert
-                 mode by `<ESC>`. press '.' will insert 'hello' instead of '[hello]'.
-    Reason: `[` actually equals `[]\<LEFT>` and \<LEFT> will break '.'.
-            After version 7.4.849, Vim implements new keyword <C-G>U to avoid the break
-    Solution: Update Vim to 7.4.849+
-
-Contributors
-------------
-* [camthompson](https://github.com/camthompson)
-
-
-License
--------
-
-Copyright (C) 2011-2013 Miao Jiang
-
-Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
diff --git a/sources_non_forked/auto-pairs/doc/AutoPairs.txt b/sources_non_forked/auto-pairs/doc/AutoPairs.txt
deleted file mode 100644
index afe589e..0000000
--- a/sources_non_forked/auto-pairs/doc/AutoPairs.txt
+++ /dev/null
@@ -1,356 +0,0 @@
-*AutoPairs.txt*  Insert or delete brackets, parens, quotes in pair
-
-Author:  jiangmiao
-License: MIT
-URL: https://github.com/jiangmiao/auto-pairs
-
-==============================================================================
-CONTENTS                                                    *autopairs-contents*
-
-    1. Installation ............................. |autopairs-installation|
-    2. Features ..................................... |autopairs-features|
-    3. Fly Mode ..................................... |autopairs-fly-mode|
-    4. Shortcuts ................................... |autopairs-shortcuts|
-    5. Options ....................................... |autopairs-options|
-    6. Troubleshooting ......................  |autopairs-troubleshooting|
-
-==============================================================================
-1. Introduction                                         *autopairs-installation*
-
-Copy `plugin/auto-pairs.vim` to `~/.vim/plugin`.
-
-Or if you are using `pathogen`: >
-
-    git clone git://github.com/jiangmiao/auto-pairs.git ~/.vim/bundle/auto-pairs
-
-==============================================================================
-2. Features                                                 *autopairs-features*
-
-Insert in pair: >
-
-        input: [
-        output: [|]
-
-Delete in pair: >
-
-        input: foo[<BS>]
-        output: foo
-
-Insert new indented line after Return: >
-
-        input: {|} (press <CR> at |)
-        output: {
-            |
-        }
-
-Insert spaces before closing characters, only for [], (), {}: >
-
-        input: {|} (press <SPACE> at |)
-        output: { | }
-
-        input: {|} (press <SPACE>foo} at |)
-        output: { foo }|
-
-        input: '|' (press <SPACE> at |)
-        output: ' |'
-
-Skip ' when inside a word: >
-
-        input: foo| (press ' at |)
-        output: foo'
-
-Skip closed bracket: >
-
-        input: []
-        output: []
-
-Ignore auto pair when previous character is '\': >
-
-        input: "\'
-        output: "\'"
-
-Fast Wrap: >
-
-        input: |'hello' (press (<M-e> at |)
-        output: ('hello')
-
-    Wrap string, only support c style string.
-        input: |'h\\el\'lo' (press (<M-e> at |)
-        output ('h\\ello\'')
-
-        input: |[foo, bar()] (press (<M-e> at |)
-        output: ([foo, bar()])
-
-Quick jump to closed pair: >
-
-        input:
-        {
-            something;|
-        }
-
-        (press } at |)
-
-        output:
-        {
-
-        }|
-
-Support ```, ''' and """: >
-
-        input:
-            '''
-
-        output:
-            '''|'''
-
-Delete Repeated Pairs in one time: >
-
-        input: """|""" (press <BS> at |)
-        output: |
-
-        input: {{|}} (press <BS> at |)
-        output: |
-
-        input: [[[[[[|]]]]]] (press <BS> at |)
-        output: |
-
-Fly Mode (|autopairs-flymode|): >
-
-        input: if(a[3)
-        output: if(a[3])| (In Fly Mode)
-        output: if(a[3)]) (Without Fly Mode)
-
-        input:
-        {
-            hello();|
-            world();
-        }
-
-        (press } at |)
-
-        output:
-        {
-            hello();
-            world();
-        }|
-
-        (then press <M-b> at | to do backinsert)
-        output:
-        {
-            hello();}|
-            world();
-        }
-
-        See |Fly Mode| section for details
-
-==============================================================================
-3. Fly Mode                                                  *autopairs-flymode*
-
-Fly Mode will always force closed-pair jumping instead of inserting. Only for
-")", "}", "]". If jumps in mistake, you can use |g:AutoPairsBackInsert| (default
-Key: <M-b>) to jump back and insert closed pair.
-
-The most situation maybe you want to insert single closed pair in the string,
-eg: >
-
-    ")"
-
-Fly Mode is DISABLED by default. To enable Fly Mode add following to your
-'.vimrc': >
-
-    let g:AutoPairsFlyMode = 1
-
-Default Options: >
-
-    let g:AutoPairsFlyMode = 0
-    let g:AutoPairsShortcutBackInsert = '<M-b>'
-
-==============================================================================
-4. Shortcuts                                             *autopairs-shortcuts*
-
-System Shortcuts:
-    <CR> : Insert new indented line after return if cursor in blank brackets
-           or quotes.
-    <BS> : Delete brackets in pair
-    <M-p>: Toggle Autopairs (|g:AutoPairsShortcutToggle|)
-    <M-e>: Fast Wrap (|g:AutoPairsShortcutFastWrap|)
-    <M-n>: Jump to next closed pair (|g:AutoPairsShortcutJump|)
-    <M-b>: BackInsert (|g:AutoPairsShortcutBackInsert|)
-
-
-    To rebind keys <M-p>, <M-e> or <M-n> or in case of conflicts with
-    another keys:
-
-        let g:AutoPairsShortcutToggle = '<another key>'
-
-    If the key is empty string '', then the shortcut will be disabled.
-
-==============================================================================
-5. Options                                                 *autopairs-options*
-
-                                                                 *g:AutoPairs*
-|g:AutoPairs|                                                             dict
-
-Default: >
-    {'(':')', '[':']', '{':'}',"'":"'",'"':'"', '`':'`'}
-
-Specifies which symbols should be automatically paired.
-
-To append new pairs without overwriting defaults, add values in your `.vimrc`.:
-
-    let g:AutoPairs['<']='>'
-
-This example will enable matching of `<` with `>`.
-
-
-                                                                  *b:AutoPairs*
-|b:AutoPairs|                                                              dict
-
-Default: |g:AutoPairs|
-
-Buffer level pairs set.
-
-You can set |b:AutoPairs| before |BufEnter|: >
-
-    au Filetype FILETYPE let b:AutoPairs = {"(": ")"}
-
-This sets |AutoPairs| to only match for parenthesis for 'FILETYPE'.
-
-
-
-                                                    *g:AutoPairsShortcutToggle*
-|g:AutoPairsShortcutToggle|                                              string
-
-Default: <M-p>
-
-The shortcut to toggle autopairs.
-
-
-
-                                                  *g:AutoPairsShortcutFastWrap*
-|g:AutoPairsShortcutFastWrap|                                            string
-
-Default: <M-e>
-
-Fast wrap the word. All pairs will be considered as a block (including <>).
-
-        (|)'hello' after fast wrap at |, the word will be ('hello')
-        (|)<hello> after fast wrap at |, the word will be (<hello>)
-
-
-
-                                                      *g:AutoPairsShortcutJump*
-|g:AutoPairsShortcutJump|                                                string
-
-Default: <M-n>
-
-Jump to the next closed pair.
-
-
-                                                *g:AutoPairsShortcutBackInsert*
-|g:AutoPairsShortcutBackInsert|                                          string
-
-Default: <M-b>
-
-Work with |autopairs-flymode|, insert the key at the Fly Mode jumped position.
-
-
-
-                                                             *g:AutoPairsMapBS*
-|g:AutoPairsMapBS|                                                          int
-
-Default: 1
-
-Map <BS> to delete brackets and quotes in pair, executes:
-
-    inoremap <buffer> <silent> <BS> <C-R>=AutoPairsDelete()<CR>
-
-
-                                                             *g:AutoPairsMapCh*
-|g:AutoPairsMapCh|                                                          int
-
-Default: 1
-
-Map <C-h> to delete brackets and quotes in pair.
-
-
-                                                             *g:AutoPairsMapCR*
-|g:AutoPairsMapCR|                                                          int
-
-Default: 1
-
-Map <CR> to insert a new indented line if cursor in (|), {|} [|], '|', "|".
-Executes:
-
-    inoremap <buffer> <silent> <CR> <C-R>=AutoPairsReturn()<CR>
-
-
-                                                        *g:AutoPairsCenterLine*
-|g:AutoPairsCenterLine|                                                     int
-
-Default: 1
-
-When |g:AutoPairsMapCR| is on, center current line after return if the line
-is at the bottom 1/3 of the window.
-
-
-                                                          *g:AutoPairsMapSpace*
-|g:AutoPairsMapSpace|                                                       int
-
-Default: 1
-
-Map <space> to insert a space after the opening character and before the
-closing one.
-
-Executes:
-
-    inoremap <buffer> <silent> <CR> <C-R>=AutoPairsSpace()<CR>
-
-
-                                                           *g:AutoPairsFlyMode*
-|g:AutoPairsFlyMode|                                                        int
-
-Default: 0
-
-Set it to 1 to enable |autopairs-flymode|.
-
-
-                                                    *g:AutoPairsMultilineClose*
-|g:AutoPairsMultilineClose|                                                 int
-
-Default: 1
-
-When you press the key for the closing pair (e.g. `)`) it jumps past it.
-If set to 1, then it'll jump to the next line, if there is only 'whitespace'.
-If set to 0, then it'll only jump to a closing pair on the same line.
-
-==============================================================================
-6. Troubleshooting                                 *autopairs-troubleshooting*
-
-This plugin remaps keys `([{'"}]) <BS>`
-
-If auto pairs cannot work, use |:imap| to check if the map is corrected.
-
-The correct map should be: >
-
-    <C-R>=AutoPairsInsert("\(")<CR>
-
-Or the plugin conflicts with some other plugins. Use command: >
-
-    :call AutoPairsInit() to remap the keys.
-
---- How to insert parens purely? ---
-
-There are 3 ways:
-
-    1. Use Ctrl-V ) to insert paren without trigger the plugin.
-
-    2. Use Alt-P to turn off the plugin.
-
-    3. Use DEL or <C-O>x to delete the character insert by plugin.
-
---- Swedish Character Conflict ---
-
-Because AutoPairs uses Meta(Alt) key as a shortcut, it conflicts with some
-Swedish character such as . To fix the issue, you need remap or disable the
-related shortcut.
diff --git a/sources_non_forked/auto-pairs/plugin/auto-pairs.vim b/sources_non_forked/auto-pairs/plugin/auto-pairs.vim
deleted file mode 100644
index af5eb32..0000000
--- a/sources_non_forked/auto-pairs/plugin/auto-pairs.vim
+++ /dev/null
@@ -1,673 +0,0 @@
-" Insert or delete brackets, parens, quotes in pairs.
-" Maintainer:	JiangMiao <jiangfriend@gmail.com>
-" Contributor: camthompson
-" Last Change:  2019-02-02
-" Version: 2.0.0
-" Homepage: http://www.vim.org/scripts/script.php?script_id=3599
-" Repository: https://github.com/jiangmiao/auto-pairs
-" License: MIT
-
-if exists('g:AutoPairsLoaded') || &cp
-  finish
-end
-let g:AutoPairsLoaded = 1
-
-if !exists('g:AutoPairs')
-  let g:AutoPairs = {'(':')', '[':']', '{':'}',"'":"'",'"':'"', '```':'```', '"""':'"""', "'''":"'''", "`":"`"}
-end
-
-" default pairs base on filetype
-func! AutoPairsDefaultPairs()
-  if exists('b:autopairs_defaultpairs')
-    return b:autopairs_defaultpairs
-  end
-  let r = copy(g:AutoPairs)
-  let allPairs = {
-        \ 'vim': {'\v^\s*\zs"': ''},
-        \ 'rust': {'\w\zs<': '>', '&\zs''': ''},
-        \ 'php': {'<?': '?>//k]', '<?php': '?>//k]'}
-        \ }
-  for [filetype, pairs] in items(allPairs)
-    if &filetype == filetype
-      for [open, close] in items(pairs)
-        let r[open] = close
-      endfor
-    end
-  endfor
-  let b:autopairs_defaultpairs = r
-  return r
-endf
-
-if !exists('g:AutoPairsMapBS')
-  let g:AutoPairsMapBS = 1
-end
-
-" Map <C-h> as the same BS
-if !exists('g:AutoPairsMapCh')
-  let g:AutoPairsMapCh = 1
-end
-
-if !exists('g:AutoPairsMapCR')
-  let g:AutoPairsMapCR = 1
-end
-
-if !exists('g:AutoPairsWildClosedPair')
-  let g:AutoPairsWildClosedPair = ''
-end
-
-if !exists('g:AutoPairsMapSpace')
-  let g:AutoPairsMapSpace = 1
-end
-
-if !exists('g:AutoPairsCenterLine')
-  let g:AutoPairsCenterLine = 1
-end
-
-if !exists('g:AutoPairsShortcutToggle')
-  let g:AutoPairsShortcutToggle = '<M-p>'
-end
-
-if !exists('g:AutoPairsShortcutFastWrap')
-  let g:AutoPairsShortcutFastWrap = '<M-e>'
-end
-
-if !exists('g:AutoPairsMoveCharacter')
-  let g:AutoPairsMoveCharacter = "()[]{}\"'"
-end
-
-if !exists('g:AutoPairsShortcutJump')
-  let g:AutoPairsShortcutJump = '<M-n>'
-endif
-
-" Fly mode will for closed pair to jump to closed pair instead of insert.
-" also support AutoPairsBackInsert to insert pairs where jumped.
-if !exists('g:AutoPairsFlyMode')
-  let g:AutoPairsFlyMode = 0
-endif
-
-" When skipping the closed pair, look at the current and
-" next line as well.
-if !exists('g:AutoPairsMultilineClose')
-  let g:AutoPairsMultilineClose = 1
-endif
-
-" Work with Fly Mode, insert pair where jumped
-if !exists('g:AutoPairsShortcutBackInsert')
-  let g:AutoPairsShortcutBackInsert = '<M-b>'
-endif
-
-if !exists('g:AutoPairsSmartQuotes')
-  let g:AutoPairsSmartQuotes = 1
-endif
-
-" 7.4.849 support <C-G>U to avoid breaking '.'
-" Issue talk: https://github.com/jiangmiao/auto-pairs/issues/3
-" Vim note: https://github.com/vim/vim/releases/tag/v7.4.849
-if v:version > 704 || v:version == 704 && has("patch849")
-  let s:Go = "\<C-G>U"
-else
-  let s:Go = ""
-endif
-
-let s:Left = s:Go."\<LEFT>"
-let s:Right = s:Go."\<RIGHT>"
-
-
-
-
-" unicode len
-func! s:ulen(s)
-  return len(split(a:s, '\zs'))
-endf
-
-func! s:left(s)
-  return repeat(s:Left, s:ulen(a:s))
-endf
-
-func! s:right(s)
-  return repeat(s:Right, s:ulen(a:s))
-endf
-
-func! s:delete(s)
-  return repeat("\<DEL>", s:ulen(a:s))
-endf
-
-func! s:backspace(s)
-  return repeat("\<BS>", s:ulen(a:s))
-endf
-
-func! s:getline()
-  let line = getline('.')
-  let pos = col('.') - 1
-  let before = strpart(line, 0, pos)
-  let after = strpart(line, pos)
-  let afterline = after
-  if g:AutoPairsMultilineClose
-    let n = line('$')
-    let i = line('.')+1
-    while i <= n
-      let line = getline(i)
-      let after = after.' '.line
-      if !(line =~ '\v^\s*$')
-        break
-      end
-      let i = i+1
-    endwhile
-  end
-  return [before, after, afterline]
-endf
-
-" split text to two part
-" returns [orig, text_before_open, open]
-func! s:matchend(text, open)
-    let m = matchstr(a:text, '\V'.a:open.'\v$')
-    if m == ""
-      return []
-    end
-    return [a:text, strpart(a:text, 0, len(a:text)-len(m)), m]
-endf
-
-" returns [orig, close, text_after_close]
-func! s:matchbegin(text, close)
-    let m = matchstr(a:text, '^\V'.a:close)
-    if m == ""
-      return []
-    end
-    return [a:text, m, strpart(a:text, len(m), len(a:text)-len(m))]
-endf
-
-" add or delete pairs base on g:AutoPairs
-" AutoPairsDefine(addPairs:dict[, removeOpenPairList:list])
-"
-" eg:
-"   au FileType html let b:AutoPairs = AutoPairsDefine({'<!--' : '-->'}, ['{'])
-"   add <!-- --> pair and remove '{' for html file
-func! AutoPairsDefine(pairs, ...)
-  let r = AutoPairsDefaultPairs()
-  if a:0 > 0
-    for open in a:1
-      unlet r[open]
-    endfor
-  end
-  for [open, close] in items(a:pairs)
-    let r[open] = close
-  endfor
-  return r
-endf
-
-func! AutoPairsInsert(key)
-  if !b:autopairs_enabled
-    return a:key
-  end
-
-  let b:autopairs_saved_pair = [a:key, getpos('.')]
-
-  let [before, after, afterline] = s:getline()
-
-  " Ignore auto close if prev character is \
-  if before[-1:-1] == '\'
-    return a:key
-  end
-
-  " check open pairs
-  for [open, close, opt] in b:AutoPairsList
-    let ms = s:matchend(before.a:key, open)
-    let m = matchstr(afterline, '^\v\s*\zs\V'.close)
-    if len(ms) > 0
-      " process the open pair
-      
-      " remove inserted pair
-      " eg: if the pairs include < > and  <!-- --> 
-      " when <!-- is detected the inserted pair < > should be clean up 
-      let target = ms[1]
-      let openPair = ms[2]
-      if len(openPair) == 1 && m == openPair
-        break
-      end
-      let bs = ''
-      let del = ''
-      while len(before) > len(target)
-        let found = 0
-        " delete pair
-        for [o, c, opt] in b:AutoPairsList
-          let os = s:matchend(before, o)
-          if len(os) && len(os[1]) < len(target)
-            " any text before openPair should not be deleted
-            continue
-          end
-          let cs = s:matchbegin(afterline, c)
-          if len(os) && len(cs)
-            let found = 1
-            let before = os[1]
-            let afterline = cs[2]
-            let bs = bs.s:backspace(os[2])
-            let del = del.s:delete(cs[1])
-            break
-          end
-        endfor
-        if !found
-          " delete charactor
-          let ms = s:matchend(before, '\v.')
-          if len(ms)
-            let before = ms[1]
-            let bs = bs.s:backspace(ms[2])
-          end
-        end
-      endwhile
-      return bs.del.openPair.close.s:left(close)
-    end
-  endfor
-
-  " check close pairs
-  for [open, close, opt] in b:AutoPairsList
-    if close == ''
-      continue
-    end
-    if a:key == g:AutoPairsWildClosedPair || opt['mapclose'] && opt['key'] == a:key
-      " the close pair is in the same line
-      let m = matchstr(afterline, '^\v\s*\V'.close)
-      if m != ''
-        if before =~ '\V'.open.'\v\s*$' && m[0] =~ '\v\s'
-          " remove the space we inserted if the text in pairs is blank
-          return "\<DEL>".s:right(m[1:])
-        else
-          return s:right(m)
-        end
-      end
-      let m = matchstr(after, '^\v\s*\zs\V'.close)
-      if m != ''
-        if a:key == g:AutoPairsWildClosedPair || opt['multiline']
-          if b:autopairs_return_pos == line('.') && getline('.') =~ '\v^\s*$'
-            normal! ddk$
-          end
-          call search(m, 'We')
-          return "\<Right>"
-        else
-          break
-        end
-      end
-    end
-  endfor
-
-
-  " Fly Mode, and the key is closed-pairs, search closed-pair and jump
-  if g:AutoPairsFlyMode &&  a:key =~ '\v[\}\]\)]'
-    if search(a:key, 'We')
-      return "\<Right>"
-    endif
-  endif
-
-  return a:key
-endf
-
-func! AutoPairsDelete()
-  if !b:autopairs_enabled
-    return "\<BS>"
-  end
-
-  let [before, after, ig] = s:getline()
-  for [open, close, opt] in b:AutoPairsList
-    let b = matchstr(before, '\V'.open.'\v\s?$')
-    let a = matchstr(after, '^\v\s*\V'.close)
-    if b != '' && a != ''
-      if b[-1:-1] == ' '
-        if a[0] == ' '
-          return "\<BS>\<DELETE>"
-        else
-          return "\<BS>"
-        end
-      end
-      return s:backspace(b).s:delete(a)
-    end
-  endfor
-
-  return "\<BS>"
-  " delete the pair foo[]| <BS> to foo
-  for [open, close, opt] in b:AutoPairsList
-    let m = s:matchend(before, '\V'.open.'\v\s*'.'\V'.close.'\v$')
-    if len(m) > 0
-      return s:backspace(m[2])
-    end
-  endfor
-  return "\<BS>"
-endf
-
-
-" Fast wrap the word in brackets
-func! AutoPairsFastWrap()
-  let c = @"
-  normal! x
-  let [before, after, ig] = s:getline()
-  if after[0] =~ '\v[\{\[\(\<]'
-    normal! %
-    normal! p
-  else
-    for [open, close, opt] in b:AutoPairsList
-      if close == ''
-        continue
-      end
-      if after =~ '^\s*\V'.open
-        call search(close, 'We')
-        normal! p
-        let @" = c
-        return ""
-      end
-    endfor
-    if after[1:1] =~ '\v\w'
-      normal! e
-      normal! p
-    else
-      normal! p
-    end
-  end
-  let @" = c
-  return ""
-endf
-
-func! AutoPairsJump()
-  call search('["\]'')}]','W')
-endf
-
-func! AutoPairsMoveCharacter(key)
-  let c = getline(".")[col(".")-1]
-  let escaped_key = substitute(a:key, "'", "''", 'g')
-  return "\<DEL>\<ESC>:call search("."'".escaped_key."'".")\<CR>a".c."\<LEFT>"
-endf
-
-func! AutoPairsBackInsert()
-  let pair = b:autopairs_saved_pair[0]
-  let pos  = b:autopairs_saved_pair[1]
-  call setpos('.', pos)
-  return pair
-endf
-
-func! AutoPairsReturn()
-  if b:autopairs_enabled == 0
-    return ''
-  end
-  let b:autopairs_return_pos = 0
-  let before = getline(line('.')-1)
-  let [ig, ig, afterline] = s:getline()
-  let cmd = ''
-  for [open, close, opt] in b:AutoPairsList
-    if close == ''
-      continue
-    end
-
-    if before =~ '\V'.open.'\v\s*$' && afterline =~ '^\s*\V'.close
-      let b:autopairs_return_pos = line('.')
-      if g:AutoPairsCenterLine && winline() * 3 >= winheight(0) * 2
-        " Recenter before adding new line to avoid replacing line content
-        let cmd = "zz"
-      end
-
-      " If equalprg has been set, then avoid call =
-      " https://github.com/jiangmiao/auto-pairs/issues/24
-      if &equalprg != ''
-        return "\<ESC>".cmd."O"
-      endif
-
-      " conflict with javascript and coffee
-      " javascript   need   indent new line
-      " coffeescript forbid indent new line
-      if &filetype == 'coffeescript' || &filetype == 'coffee'
-        return "\<ESC>".cmd."k==o"
-      else
-        return "\<ESC>".cmd."=ko"
-      endif
-    end
-  endfor
-  return ''
-endf
-
-func! AutoPairsSpace()
-  if !b:autopairs_enabled
-    return "\<SPACE>"
-  end
-
-  let [before, after, ig] = s:getline()
-
-  for [open, close, opt] in b:AutoPairsList
-    if close == ''
-      continue
-    end
-    if before =~ '\V'.open.'\v$' && after =~ '^\V'.close
-      if close =~ '\v^[''"`]$'
-        return "\<SPACE>"
-      else
-        return "\<SPACE>\<SPACE>".s:Left
-      end
-    end
-  endfor
-  return "\<SPACE>"
-endf
-
-func! AutoPairsMap(key)
-  " | is special key which separate map command from text
-  let key = a:key
-  if key == '|'
-    let key = '<BAR>'
-  end
-  let escaped_key = substitute(key, "'", "''", 'g')
-  " use expr will cause search() doesn't work
-  execute 'inoremap <buffer> <silent> '.key." <C-R>=AutoPairsInsert('".escaped_key."')<CR>"
-endf
-
-func! AutoPairsToggle()
-  if b:autopairs_enabled
-    let b:autopairs_enabled = 0
-    echo 'AutoPairs Disabled.'
-  else
-    let b:autopairs_enabled = 1
-    echo 'AutoPairs Enabled.'
-  end
-  return ''
-endf
-
-func! s:sortByLength(i1, i2)
-  return len(a:i2[0])-len(a:i1[0])
-endf
-
-func! AutoPairsInit()
-  let b:autopairs_loaded  = 1
-  if !exists('b:autopairs_enabled')
-    let b:autopairs_enabled = 1
-  end
-
-  if !exists('b:AutoPairs')
-    let b:AutoPairs = AutoPairsDefaultPairs()
-  end
-
-  if !exists('b:AutoPairsMoveCharacter')
-    let b:AutoPairsMoveCharacter = g:AutoPairsMoveCharacter
-  end
-
-  let b:autopairs_return_pos = 0
-  let b:autopairs_saved_pair = [0, 0]
-  let b:AutoPairsList = []
-
-  " buffer level map pairs keys
-  " n - do not map the first charactor of closed pair to close key
-  " m - close key jumps through multi line
-  " s - close key jumps only in the same line
-  for [open, close] in items(b:AutoPairs)
-    let o = open[-1:-1]
-    let c = close[0]
-    let opt = {'mapclose': 1, 'multiline':1}
-    let opt['key'] = c
-    if o == c
-      let opt['multiline'] = 0
-    end
-    let m = matchlist(close, '\v(.*)//(.*)$')
-    if len(m) > 0 
-      if m[2] =~ 'n'
-        let opt['mapclose'] = 0
-      end
-      if m[2] =~ 'm'
-        let opt['multiline'] = 1
-      end
-      if m[2] =~ 's'
-        let opt['multiline'] = 0
-      end
-      let ks = matchlist(m[2], '\vk(.)')
-      if len(ks) > 0
-        let opt['key'] = ks[1]
-        let c = opt['key']
-      end
-      let close = m[1]
-    end
-    call AutoPairsMap(o)
-    if o != c && c != '' && opt['mapclose']
-      call AutoPairsMap(c)
-    end
-    let b:AutoPairsList += [[open, close, opt]]
-  endfor
-
-  " sort pairs by length, longer pair should have higher priority
-  let b:AutoPairsList = sort(b:AutoPairsList, "s:sortByLength")
-
-  for item in b:AutoPairsList
-    let [open, close, opt] = item
-    if open == "'" && open == close
-      let item[0] = '\v(^|\W)\zs'''
-    end
-  endfor
-
-
-  for key in split(b:AutoPairsMoveCharacter, '\s*')
-    let escaped_key = substitute(key, "'", "''", 'g')
-    execute 'inoremap <silent> <buffer> <M-'.key."> <C-R>=AutoPairsMoveCharacter('".escaped_key."')<CR>"
-  endfor
-
-  " Still use <buffer> level mapping for <BS> <SPACE>
-  if g:AutoPairsMapBS
-    " Use <C-R> instead of <expr> for issue #14 sometimes press BS output strange words
-    execute 'inoremap <buffer> <silent> <BS> <C-R>=AutoPairsDelete()<CR>'
-  end
-
-  if g:AutoPairsMapCh
-    execute 'inoremap <buffer> <silent> <C-h> <C-R>=AutoPairsDelete()<CR>'
-  endif
-
-  if g:AutoPairsMapSpace
-    " Try to respect abbreviations on a <SPACE>
-    let do_abbrev = ""
-    if v:version == 703 && has("patch489") || v:version > 703
-      let do_abbrev = "<C-]>"
-    endif
-    execute 'inoremap <buffer> <silent> <SPACE> '.do_abbrev.'<C-R>=AutoPairsSpace()<CR>'
-  end
-
-  if g:AutoPairsShortcutFastWrap != ''
-    execute 'inoremap <buffer> <silent> '.g:AutoPairsShortcutFastWrap.' <C-R>=AutoPairsFastWrap()<CR>'
-  end
-
-  if g:AutoPairsShortcutBackInsert != ''
-    execute 'inoremap <buffer> <silent> '.g:AutoPairsShortcutBackInsert.' <C-R>=AutoPairsBackInsert()<CR>'
-  end
-
-  if g:AutoPairsShortcutToggle != ''
-    " use <expr> to ensure showing the status when toggle
-    execute 'inoremap <buffer> <silent> <expr> '.g:AutoPairsShortcutToggle.' AutoPairsToggle()'
-    execute 'noremap <buffer> <silent> '.g:AutoPairsShortcutToggle.' :call AutoPairsToggle()<CR>'
-  end
-
-  if g:AutoPairsShortcutJump != ''
-    execute 'inoremap <buffer> <silent> ' . g:AutoPairsShortcutJump. ' <ESC>:call AutoPairsJump()<CR>a'
-    execute 'noremap <buffer> <silent> ' . g:AutoPairsShortcutJump. ' :call AutoPairsJump()<CR>'
-  end
-
-  if &keymap != ''
-    let l:imsearch = &imsearch
-    let l:iminsert = &iminsert
-    let l:imdisable = &imdisable
-    execute 'setlocal keymap=' . &keymap
-    execute 'setlocal imsearch=' . l:imsearch
-    execute 'setlocal iminsert=' . l:iminsert
-    if l:imdisable
-      execute 'setlocal imdisable'
-    else
-      execute 'setlocal noimdisable'
-    end
-  end
-
-endf
-
-func! s:ExpandMap(map)
-  let map = a:map
-  let map = substitute(map, '\(<Plug>\w\+\)', '\=maparg(submatch(1), "i")', 'g')
-  let map = substitute(map, '\(<Plug>([^)]*)\)', '\=maparg(submatch(1), "i")', 'g')
-  return map
-endf
-
-func! AutoPairsTryInit()
-  if exists('b:autopairs_loaded')
-    return
-  end
-
-  " for auto-pairs starts with 'a', so the priority is higher than supertab and vim-endwise
-  "
-  " vim-endwise doesn't support <Plug>AutoPairsReturn
-  " when use <Plug>AutoPairsReturn will cause <Plug> isn't expanded
-  "
-  " supertab doesn't support <SID>AutoPairsReturn
-  " when use <SID>AutoPairsReturn  will cause Duplicated <CR>
-  "
-  " and when load after vim-endwise will cause unexpected endwise inserted.
-  " so always load AutoPairs at last
-
-  " Buffer level keys mapping
-  " comptible with other plugin
-  if g:AutoPairsMapCR
-    if v:version == 703 && has('patch32') || v:version > 703
-      " VIM 7.3 supports advancer maparg which could get <expr> info
-      " then auto-pairs could remap <CR> in any case.
-      let info = maparg('<CR>', 'i', 0, 1)
-      if empty(info)
-        let old_cr = '<CR>'
-        let is_expr = 0
-      else
-        let old_cr = info['rhs']
-        let old_cr = s:ExpandMap(old_cr)
-        let old_cr = substitute(old_cr, '<SID>', '<SNR>' . info['sid'] . '_', 'g')
-        let is_expr = info['expr']
-        let wrapper_name = '<SID>AutoPairsOldCRWrapper73'
-      endif
-    else
-      " VIM version less than 7.3
-      " the mapping's <expr> info is lost, so guess it is expr or not, it's
-      " not accurate.
-      let old_cr = maparg('<CR>', 'i')
-      if old_cr == ''
-        let old_cr = '<CR>'
-        let is_expr = 0
-      else
-        let old_cr = s:ExpandMap(old_cr)
-        " old_cr contain (, I guess the old cr is in expr mode
-        let is_expr = old_cr =~ '\V(' && toupper(old_cr) !~ '\V<C-R>'
-
-        " The old_cr start with " it must be in expr mode
-        let is_expr = is_expr || old_cr =~ '\v^"'
-        let wrapper_name = '<SID>AutoPairsOldCRWrapper'
-      end
-    end
-
-    if old_cr !~ 'AutoPairsReturn'
-      if is_expr
-        " remap <expr> to `name` to avoid mix expr and non-expr mode
-        execute 'inoremap <buffer> <expr> <script> '. wrapper_name . ' ' . old_cr
-        let old_cr = wrapper_name
-      end
-      " Always silent mapping
-      execute 'inoremap <script> <buffer> <silent> <CR> '.old_cr.'<SID>AutoPairsReturn'
-    end
-  endif
-  call AutoPairsInit()
-endf
-
-" Always silent the command
-inoremap <silent> <SID>AutoPairsReturn <C-R>=AutoPairsReturn()<CR>
-imap <script> <Plug>AutoPairsReturn <SID>AutoPairsReturn
-
-
-au BufEnter * :call AutoPairsTryInit()
diff --git a/sources_non_forked/bufexplorer/.gitignore b/sources_non_forked/bufexplorer/.gitignore
deleted file mode 100644
index 42d5d59..0000000
--- a/sources_non_forked/bufexplorer/.gitignore
+++ /dev/null
@@ -1,6 +0,0 @@
-# Ignore generated tags
-/doc/tags
-dist.bat
-*.zip
-tags
-*.sw[a-p]
diff --git a/sources_non_forked/bufexplorer/LICENSE b/sources_non_forked/bufexplorer/LICENSE
deleted file mode 100644
index 28d7bc4..0000000
--- a/sources_non_forked/bufexplorer/LICENSE
+++ /dev/null
@@ -1,27 +0,0 @@
-Copyright (c) 2001-2013, Jeff Lanzarotta
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-* Redistributions of source code must retain the above copyright notice, this
-  list of conditions and the following disclaimer.
-
-* Redistributions in binary form must reproduce the above copyright notice, this
-  list of conditions and the following disclaimer in the documentation and/or
-  other materials provided with the distribution.
-
-* Neither the name of the {organization} nor the names of its
-  contributors may be used to endorse or promote products derived from
-  this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff --git a/sources_non_forked/bufexplorer/README.md b/sources_non_forked/bufexplorer/README.md
deleted file mode 100644
index 2987bdd..0000000
--- a/sources_non_forked/bufexplorer/README.md
+++ /dev/null
@@ -1,99 +0,0 @@
-bufexplorer
-===========
-
-BufExplorer Plugin for Vim
-
-With bufexplorer, you can quickly and easily switch between buffers by using the one of the default public interfaces:
-
-`\<Leader\>be` normal open
-
-`\<Leader\>bt` toggle open / close
-
-`\<Leader\>bs` force horizontal split open
-
-`\<Leader\>bv` force vertical split open
-
-
-Once the bufexplorer window is open you can use the normal movement keys (hjkl) to move around and then use <Enter> or <Left-Mouse-Click> to select the buffer you would like to open. If you would like to have the selected buffer opened in a new tab, simply press either <Shift-Enter> or 't'. Please note that when opening a buffer in a tab, that if the buffer is already in another tab, bufexplorer can switch to that tab automatically for you if you would like. More about that in the supplied VIM help.
-
-Bufexplorer also offers various options including:
-- Display the list of buffers in various sort orders including:
-    - Most Recently Used (MRU) which is the default
-    - Buffer number
-    - File name
-    - File extension
-    - Full file path name
-- Delete buffer from list
-
-For more about options, sort orders, configuration options, etc. please see the supplied VIM help.
-
-## vim.org
-This plugin can also be found at http://www.vim.org/scripts/script.php?script_id=42.
-
-## Installation
-### Manually
-1.  If you do not want to use one of the the bundle handlers, you can take the
-    zip file from vim.org and unzip it and copy the plugin to your vimfiles\plugin
-    directory and the txt file to your vimfiles\doc directory.  If you do that,
-    make sure you generate the help by executing
-
-    `:helptag <your runtime directory>/doc`
-
-    Once help tags have been generated, you can view the manual with
-    `:help bufexplorer`.
-
-### Vundle (https://github.com/gmarik/Vundle.vim)
-1. Add the following configuration to your `.vimrc`.
-
-        Plugin 'jlanzarotta/bufexplorer'
-
-2. Install with `:BundleInstall`.
-
-### NeoBundle (https://github.com/Shougo/neobundle.vim)
-1. Add the following configuration to your `.vimrc`.
-
-        NeoBundle 'jlanzarotta/bufexplorer'
-
-2. Install with `:NeoBundleInstall`.
-
-### Plug (https://github.com/junegunn/vim-plug)
-1. Add the following configuration to your `.vimrc`.
-
-        Plug 'jlanzarotta/bufexplorer'
-
-2. Install with `:PlugInstall`.
-
-### Pathogen
-1. Install with the following command.
-
-        git clone https://github.com/jlanzarotta/bufexplorer.git ~/.vim/bundle/bufexplorer.vim
-
-## License
-Copyright (c) 2001-2020, Jeff Lanzarotta
-
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-* Redistributions of source code must retain the above copyright notice, this
-  list of conditions and the following disclaimer.
-
-* Redistributions in binary form must reproduce the above copyright notice, this
-  list of conditions and the following disclaimer in the documentation and/or
-  other materials provided with the distribution.
-
-* Neither the name of the {organization} nor the names of its
-  contributors may be used to endorse or promote products derived from
-  this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff --git a/sources_non_forked/bufexplorer/doc/bufexplorer.txt b/sources_non_forked/bufexplorer/doc/bufexplorer.txt
deleted file mode 100644
index fd52fb5..0000000
--- a/sources_non_forked/bufexplorer/doc/bufexplorer.txt
+++ /dev/null
@@ -1,806 +0,0 @@
-*bufexplorer.txt*              Buffer Explorer       Last Change: 08 Dec 2018
-
-Buffer Explorer                                *buffer-explorer* *bufexplorer*
-                                Version 7.4.21
-
-Plugin for easily exploring (or browsing) Vim|:buffers|.
-
-|bufexplorer-installation|   Installation
-|bufexplorer-usage|          Usage
-|bufexplorer-windowlayout|   Window Layout
-|bufexplorer-customization|  Customization
-|bufexplorer-changelog|      Change Log
-|bufexplorer-todo|           Todo
-|bufexplorer-credits|        Credits
-|bufexplorer-copyright|      Copyright
-
-For Vim version 7.0 and above.
-This plugin is only available if 'compatible' is not set.
-
-{Vi does not have any of this}
-
-==============================================================================
-INSTALLATION                                        *bufexplorer-installation*
-
-To install:
-  - Download the bufexplorer.zip from one of the following places:
-    https://github.com/jlanzarotta/bufexplorer
-    http://www.vim.org/scripts/script.php?script_id=42
-    or use a package manager like Vundle.
-  - Extract the zip archive into your runtime directory.
-    The archive contains plugin/bufexplorer.vim, and doc/bufexplorer.txt.
-  - Start Vim or goto an existing instance of Vim.
-  - Execute the following command:
->
-      :helptag <your runtime directory>/doc
-<
-    This will generate all the help tags for any file located in the doc
-    directory.
-
-==============================================================================
-USAGE                                                      *bufexplorer-usage*
-
-To start exploring in the current window, use: >
- <Leader>be   or   :BufExplorer   or   Your custom key mapping
-To toggle bufexplorer on or off in the current window, use: >
- <Leader>bt   or   :ToggleBufExplorer   or   Your custom key mapping
-To start exploring in a newly split horizontal window, use: >
- <Leader>bs   or   :BufExplorerHorizontalSplit   or   Your custom key mapping
-To start exploring in a newly split vertical window, use: >
- <Leader>bv   or   :BufExplorerVerticalSplit   or   Your custom key mapping
-
-If you would like to use something other than the default leader key - '\' -
-you may simply change the leader (see |mapleader|).
-
-When <Leader>bs or <Leader>bv is issued, bufexplorer opens in either a
-horizontally or vertically split window.  By issuing either of these commands,
-the user is telling bufexplorer that they want to split the window and have
-bufexplorer show the buffer they are about to select (from the bufexplorer
-windows) in the newly split window.  When <Leader>be is issued, bufexplorer
-opens the bufexplorer contents in the current window and the buffer the user
-selects is opened in the current window.
-
-Note: If the current buffer is modified when bufexplorer started, the current
-      window is always split and the new bufexplorer is displayed in that new
-      window.
-
-Commands to use once exploring:
-
- <F1>          Toggle help information.
- <enter>       Opens the buffer that is under the cursor into the current
-               window.
- <leftmouse>   Opens the buffer that is under the cursor into the current
-               window.
- <shift-enter> Opens the buffer that is under the cursor in another tab.
- a             Toggles whether you are taken to the active window when
-               selecting a buffer or not.
- b             Fast buffer switching with b<any bufnum>.
- B             Works in association with the |ShowTabBuffer| option.  If
-               |ShowTabBuffer| is set to 1, this toggles if BufExplorer is to
-               only store the most recent tab for this buffer or not.
- d             |:delete| the buffer under the cursor from the list.  The
-               buffer's 'buflisted' is cleared. This allows for the buffer to
-               be displayed again using the 'show unlisted' command.
- D             |:wipeout| the buffer under the cursor from the list.  When a
-               buffer is wiped, it will not be shown when unlisted buffers are
-               displayed.
- F             Open selected buffer in another window above the current.
- f             Open selected buffer in another window below the current.
- o             Opens the buffer that is under the cursor into the current
-               window.
- p             Toggles the showing of a split filename/pathname.
- q             Exit/Close bufexplorer.
- r             Reverses the order the buffers are listed in.
- R             Toggles relative path/absolute path.
- s             Cycle thru how the buffers are listed. Either by buffer
-               number, file name, file extension, most recently used (MRU), or
-               full path.
- S             Cycle thru how the buffers are listed, in reverse order.
-               Either by buffer number, file name, file extension, most
-               recently used (MRU), or full path.
- t             Opens the buffer that is under the cursor in another tab.
- T             Toggles to show only buffers for this tab or not.
- u             Toggles the showing of "unlisted" buffers.
- V             Open the selected buffer in another window on the left of the current.
- v             Open the selected buffer in another window on the right of the current.
-
-Once invoked, Buffer Explorer displays a sorted list (MRU is the default
-sort method) of all the buffers that are currently opened. You are then
-able to move the cursor to the line containing the buffer's name you are
-wanting to act upon. Once you have selected the buffer you would like,
-you can then either open it, close it (delete), resort the list, reverse
-the sort, quit exploring and so on...
-
-===============================================================================
-WINDOW LAYOUT                                       *bufexplorer-windowlayout*
-
--------------------------------------------------------------------------------
-" Press <F1> for Help
-" Sorted by mru | Locate buffer | Absolute Split path
-"=
-  1 %a    bufexplorer.txt      C:\Vim\vimfiles\doc       line 87
-  2 #     bufexplorer.vim      c:\Vim\vimfiles\plugin    line 1
--------------------------------------------------------------------------------
-  | |     |                    |                         |
-  | |     |                    |                         +-- Current Line #.
-  | |     |                    +-- Relative/Full Path
-  | |     +-- Buffer Name.
-  | +-- Buffer Attributes. See |:buffers| for more information.
-  +-- Buffer Number. See |:buffers| for more information.
-
-===============================================================================
-CUSTOMIZATION                                       *bufexplorer-customization*
-
-If you do not like the default key mappings of <Leader>be, <Leader>bs, and
-<Leader>bv, you can override bufexplorer's default mappings by setting up
-something like the following in your vimrc file:
-
-  nnoremap <silent> <F11> :BufExplorer<CR>
-  nnoremap <silent> <s-F11> :ToggleBufExplorer<CR>
-  nnoremap <silent> <m-F11> :BufExplorerHorizontalSplit<CR>
-  nnoremap <silent> <c-F11> :BufExplorerVerticalSplit<CR>
-
-                                                          *g:bufExplorerChgWin*
-If set, bufexplorer will bring up the selected buffer in the window specified
-by g:bufExplorerChgWin.
-
-                                                     *g:bufExplorerDefaultHelp*
-To control whether the default help is displayed or not, use: >
-  let g:bufExplorerDefaultHelp=0       " Do not show default help.
-  let g:bufExplorerDefaultHelp=1       " Show default help.
-The default is to show the default help.
-
-                                        *g:bufExplorerDisableDefaultKeyMapping*
-To control whether the default key mappings are enabled or not, use: >
-  let g:bufExplorerDisableDefaultKeyMapping=0    " Do not disable mapping.
-  let g:bufExplorerDisableDefaultKeyMapping=1    " Disable mapping.
-The default is NOT to disable the default key mapping.
-
-                                                    *g:bufExplorerDetailedHelp*
-To control whether detailed help is display by, use: >
-  let g:bufExplorerDetailedHelp=0      " Do not show detailed help.
-  let g:bufExplorerDetailedHelp=1      " Show detailed help.
-The default is NOT to show detailed help.
-
-                                                      *g:bufExplorerFindActive*
-To control whether you are taken to the active window when selecting a buffer,
-use: >
-  let g:bufExplorerFindActive=0        " Do not go to active window.
-  let g:bufExplorerFindActive=1        " Go to active window.
-The default is to be taken to the active window.
-
-                                                         *g:bufExplorerFuncRef*
-When a buffer is selected, the functions specified either singly or as a list
-will be called.
-
-                                                     *g:bufExplorerReverseSort*
-To control whether to sort the buffer in reverse order or not, use: >
-  let g:bufExplorerReverseSort=0       " Do not sort in reverse order.
-  let g:bufExplorerReverseSort=1       " Sort in reverse order.
-The default is NOT to sort in reverse order.
-
-                                                 *g:bufExplorerShowDirectories*
-Directories usually show up in the list from using a command like ":e .".
-To control whether to show directories in the buffer list or not, use: >
-  let g:bufExplorerShowDirectories=0   " Do not show directories.
-  let g:bufExplorerShowDirectories=1   " Show directories.
-The default is to show directories.
-
-                                                      *g:bufExplorerShowNoName*
-To control whether to show "No Name" buffers or not, use: >
-  let g:bufExplorerShowNoName=0        " Do not "No Name" buffers.
-  let g:bufExplorerShowNoName=1        " Show "No Name" buffers.
-The default is to NOT show "No Name buffers.
-
-                                                *g:bufExplorerShowRelativePath*
-To control whether to show absolute paths or relative to the current
-directory, use: >
-  let g:bufExplorerShowRelativePath=0  " Show absolute paths.
-  let g:bufExplorerShowRelativePath=1  " Show relative paths.
-The default is to show absolute paths.
-
-                                                   *g:bufExplorerShowTabBuffer*
-To control whether or not to show buffers on for the specific tab or not, use: >
-  let g:bufExplorerShowTabBuffer=0        " No.
-  let g:bufExplorerShowTabBuffer=1        " Yes.
-The default is not to show.
-
-                                                    *g:bufExplorerShowUnlisted*
-To control whether to show unlisted buffers or not, use: >
-  let g:bufExplorerShowUnlisted=0      " Do not show unlisted buffers.
-  let g:bufExplorerShowUnlisted=1      " Show unlisted buffers.
-The default is to NOT show unlisted buffers.
-
-                                                          *g:bufExplorerSortBy*
-To control what field the buffers are sorted by, use: >
-  let g:bufExplorerSortBy='extension'  " Sort by file extension.
-  let g:bufExplorerSortBy='fullpath'   " Sort by full file path name.
-  let g:bufExplorerSortBy='mru'        " Sort by most recently used.
-  let g:bufExplorerSortBy='name'       " Sort by the buffer's name.
-  let g:bufExplorerSortBy='number'     " Sort by the buffer's number.
-The default is to sort by mru.
-
-                                                      *g:bufExplorerSplitBelow*
-To control where the new split window will be placed above or below the
-current window, use: >
-  let g:bufExplorerSplitBelow=1        " Split new window below current.
-  let g:bufExplorerSplitBelow=0        " Split new window above current.
-The default is to use whatever is set by the global &splitbelow
-variable.
-
-                                                   *g:bufExplorerSplitHorzSize*
-To control the size of the new horizontal split window. use: >
-  let g:bufExplorerSplitHorzSize=n     " New split window is n rows high.
-  let g:bufExplorerSplitHorzSize=0     " New split window size set by Vim.
-The default is 0, so that the size is set by Vim.
-
-                                                *g:bufExplorerSplitOutPathName*
-To control whether to split out the path and file name or not, use: >
-  let g:bufExplorerSplitOutPathName=1  " Split the path and file name.
-  let g:bufExplorerSplitOutPathName=0  " Don't split the path and file
-                                       " name.
-The default is to split the path and file name.
-
-                                                      *g:bufExplorerSplitRight*
-To control where the new vsplit window will be placed to the left or right of
-current window, use: >
-  let g:bufExplorerSplitRight=0        " Split left.
-  let g:bufExplorerSplitRight=1        " Split right.
-The default is to use the global &splitright.
-
-                                                   *g:bufExplorerSplitVertSize*
-To control the size of the new vertical split window, use: >
-  let g:bufExplorerSplitVertSize=n          " New split window is n columns wide.
-  let g:bufExplorerSplitVertSize=0          " New split windows size set by Vim.
-The default is 0, so that the size is set by Vim.
-
-                                                   *g:bufExplorerVersionWarn*
-To control whether to warning about Vim version or not, use: >
-  let g:bufExplorerVersionWarn=1       " Warn if version conflict.
-  let g:bufExplorerVersionWarn=0       " Do not warn if version conflict.
-The default is 1.
-
-===============================================================================
-CHANGE LOG                                              *bufexplorer-changelog*
-
-7.4.21   December 8, 2018
-    - Merged in changes from adelarsq that introduced ryanoasis/vim-devicons
-      support.  If the global g:loaded_webdevicons has been set, bufexplorer
-      will now load the associated dev icons for each buffer.
-7.4.20   January 18, 2017
-    - Thanks to jpflouret for supplying code that can remove the warning
-      messages if you using this plugin on an older version of Vim.  The
-      global variable is g:bufExplorerVersionWarn.
-7.4.19   September 18, 2017
-    - Merged all changes from github back into this version and tried to sync
-      to the correct version number.
-7.4.18 - Github.
-7.4.17 - Github.
-7.4.16   August 14, 2017
-    - Thanks to Yubo Su for the patch that adds 'f, F, V, and v' commands.
-      With this change, the original 'f' command was remapped to 'a'.
-
-      The set of commands that can be used during exploring are:
-      F - Open selected buffer in another window above the current.
-      f - Open selected buffer in another window below the current.
-      V - Open the selected buffer in another window on the left of the
-          current.
-      v - Open the selected buffer in another window on the right of the
-          current.
-7.4.15   May 01, 2017
-    - Finally applied the patch submitted by justfalter.  This patch is a
-      backward-compatible fix for the "invalid tab range" bug.
-7.4.14   April 10, 2017
-    - As suggested by adelarsq way back on January 5th, 2016, a filetype has
-      been added.  There is now 'filetype=bufexplorer'.
-7.4.13   March 08, 2017
-    - Thanks to devakivamsi for pointing out that even though bufexplorer
-      turns off line numbers by default within its own window, this did not
-      work correctly when using WinManager.  This has now been corrected.
-7.4.12   September 30, 2016
-    - Thanks again to Martin Vuille for several more fixes related to making
-      bufexplorer more tab-friendly.
-7.4.11   September, 20, 2016
-    - Thanks to Martin Vuille for reworking the per-tab buffer listing code.
-      Fix for g:bufExplorerShowTabBuffer is not working correctly and other
-      "gliches" when the ShotTabBuffer option is enabled.  For example old
-      code would not correctly handle adding/deleting a tab that wasn't the
-      highest-numbered tab.
-7.4.10   August 26, 2016
-    - Thanks to buddylindsey for fixing a misspelling in the docs.
-7.4.9    April 01, 2016
-    - Thanks to ivegotasthma for supplying a patch to fix a major issue with
-      plugin performance when lots of buffers are open.
-    - Thanks to ershov for the patch to fix grouping of files in ambiguous
-      sort modes.
-    - Thanks to PhilRunninger for changing documentation to use <Leader>, in
-      place of '\'.
-7.4.8    January 27, 2015
-    - Thanks to Marius Gedminas for fixing up the documentation and correcting
-      various typos.
-7.4.7    January 20, 2015
-    - Thanks goes out to Phil Runninger for added the ability to toggle the
-      bufexplorer list on and off using the :ToggleBufExplorer command, the
-      map <Leader>bt, and the function ToggleBufExplorer().
-7.4.6    November 03, 2014
-    - Not sure how, but the file format was converted to Dos instead of Unix.
-      I converted the file back to Unix.
-7.4.5    October 24, 2014
-    - Dr Michael Henry suggested to change all noremap commands to nnoremap.
-      Using noremap is unnecessarily broad and can cause problems, especially
-      for select mode.
-7.4.4    August 19, 2014
-    - Revert change where bufexplorer windows was closed even if the target
-      buffer has not been loaded yet.
-7.4.3    August 13, 2014
-    - Ivan Ukhov fixed issue with deleting the last window.  This update also
-      fixes as well as another.  If you have say, NERDtree open on the left
-      side and bufexplorer on the right, that bufexplorer would close NERDtree
-      erroneously thinking that it is closing itself.
-    - Radoslaw Burny fixed a few bugs that surfaced when bufexplorer is used
-      within winmanager.
-7.4.2    October 22, 2013
-    - Added global option g:bufExplorerDisableDefaultKeyMapping.  This option
-      controls weather the default key mappings (\be, \bs, and \bv) are
-      enabled or not.  See documentation for more information.
-7.4.1    October 11, 2013
-    - First update related to Vim 7.4.
-    - Changed license text.
-    - Fixed issue with 'hidden'.  If 'hidden' is set, make sure that
-      g:bufExplorerFindActive is set to 0.  Otherwise, when using \bs or \bv,
-      and selecting a buffer, the original buffer will be switched to instead
-      of being opened in the newly created windows.
-    - Added new 'b' mapping when the bufExplorer window is opened.  When 'b'
-      is pressed, the user is prompted for the buffer number to switch to, and
-      is is then switched to when <CR> is pressed.  This allows for somewhat
-      faster buffer switching instead of using the j and k keys or the mouse
-      to select the buffer to switch to.
-    - Removed 'set nolist' from the Initialize() function as well as the
-      restore of the 'list' setting in the CleanUp() function.  These were
-      causing issues when multiple new files were opened from the command
-      line.  Furthermore, there was really no reason, that I can remember, to
-      why the 'list' setting was saved, modified, and restored anyways.
-    - Fixed issue with WinManager integration code not working correctly
-      anymore.
-    - Brought back the xnoremap setup for the 'd' and 'D' keys.  These were
-      removed for some reason after version 7.2.8.
-    - Thanks to all the contributors and testers.
-7.3.6    May 06, 2013
-    - Removed the 'drop' window command that was causing issue with the
-      argument-list being modified after the BufExplorer windows was
-      displayed.
-7.3.5    February 08, 2013
-    - Michael Henry added the ability to view "No Name" buffers.  This
-      functionality was lost since version 7.3.0.  He also did some removal of
-      "dead" code and cleaned up the code to handle filenames with embedded
-      '"'.
-7.3.4    January 28, 2013
-    - Thanks go out to John Szakmeister for finding and fixing a bug in the
-      RebuildBufferList method.  The keepjumps line that clears the list could
-      potentially reference a backwards range.
-7.3.3    January 14, 2013
-    - Major cleanup and reorganization of the change log.
-    - We welcome the return of g:bufExplorerSplitHorzSize and
-      g:bufExplorerSplitVertSize.  When setting these values, anything less
-      than or equal to 0 causes the split windows size to be determined by
-      Vim.  If for example you want your new horizontal split window 10 rows
-      high, set g:bufExplorerSplitHorzSize = 10 in your .vimrc.  Similar would
-      be done if wanting a vertical split except you would use the
-      g:bufExplorerSplitVertSize variable instead.
-7.3.2    December 24, 2012
-    - Thanks go out to Michael Henry for pointing out that I completely
-      missed yet another function, ReverseSortSelect(), during the
-      refactoring.  This function has now returned.
-7.3.1    December 06, 2012
-    - Thanks go out to Brett Rasmussen for pointing out that the feature
-      added way back in version 7.2.3 by Yuriy Ershov to automatically
-      reposition the cursor to the line containing the active buffer, was
-      no longer in the plugin.  That bit of code has been re-added and
-      all is well.
-7.3.0    October 09, 2012
-    - It has been quite a while since I published a new version and this
-      is the first version since Vim 7.3 was released.  I have put some
-      time into reworking and cleaning up the code as well as various bug
-      fixes.  Overall, I am hopeful that I not forgotten or lost a feature.
-    - Thanks to Tim Johnson for testing out this new version.
-    - I have hopefully allowed for better mapping of the main public
-      methods as is explained in the |bufexplorer-customization| section
-      of the documentation.
-    - Add new 'B', 'o', and 'S' key mappings.
-7.2.8    November 08, 2010
-    - Thanks to Charles Campbell for integrating bufexplorer with GDBMGR.
-      http://mysite.verizon.net/astronaut/vim/index.html#GDBMGR
-7.2.7    April 26, 2010
-    - My 1st attempt to fix the "cache" issue where buffers information
-      has changed but the cache/display does not reflect those changes.
-      More work still needs to be done.
-7.2.6    February 12, 2010
-    - Thanks to Michael Henry for pointing out that I totally forgot to
-      update the inline help to reflect the previous change to the 'd'
-      and 'D' keys. Opps!
-7.2.5    February 10, 2010
-    - Philip Morant suggested switching the command (bwipe) associated
-      with the 'd' key with the command (bdelete) associated with the 'D'
-      key. This made sense since the 'd' key is more likely to be used
-      compared to the 'D' key.
-7.2.4    January 14, 2010
-    - I did not implement the patch provided by Godefroid Chapelle
-      correctly. I missed one line which happened to be the most important
-      one :)
-7.2.3    December 15, 2009
-    - Hopefully I have not left anyone or anything out :)
-    - Thanks to David Fishburn for helping me out with a much needed
-      code overhaul as well as some awesome performance enhancements.
-    - David also reworked the handling of tabs.
-    - Thanks to Vladimir Dobriakov for making the suggestions on
-      enhancing the documentation to include a better explaination of
-      what is contained in the main bufexplorer window.
-    - Thanks to Yuriy Ershov for added code that when the bufexplorer
-      window is opened, the cursor is now positioned at the line with the
-      active buffer (useful in non-MRU sort modes).
-    - Yuriy also added the abiltiy to cycle through the sort fields in
-      reverse order.
-    - Thanks to Michael Henry for supplying a patch that allows
-      bufexplorer to be opened even when there is one buffer or less.
-    - Thanks to Godefroid Chapelle for supplying a patch that fixed
-      MRU sort order after loading a session.
-7.2.2    November 19, 2008
-    - Thanks to David L. Dight for spotting and fixing an issue when using
-      ctrl^. bufexplorer would incorrectly handle the previous buffer so
-      that when ctrl^ was pressed the incorrect file was opened.
-7.2.1    September 03, 2008
-    - Thanks to Dimitar for spotting and fixing a feature that was
-      inadvertently left out of the previous version. The feature was when
-      bufexplorer was used together with WinManager, you could use the tab
-      key to open a buffer in a split window.
-7.2.0    August 15, 2008
-    - For all those missing the \bs and \bv commands, these have now
-      returned. Thanks to Phil O'Connell for asking for the return of
-      these missing features and helping test out this version.
-    - Fixed problem with the bufExplorerFindActive code not working
-      correctly.
-    - Fixed an incompatibility between bufexplorer and netrw that caused
-      buffers to be incorrectly removed from the MRU list.
-7.1.7    December 21, 2007
-    - TaCahiroy fixed several issues related to opening a buffer in a tab.
-7.1.6    December 01, 2007
-    - Removed ff=unix from modeline in bufexplorer.txt. Found by Bill
-      McCarthy.
-7.1.5    November 30, 2007
-    - Could not open unnamed buffers. Fixed by TaCahiroy.
-7.1.4    November 16, 2007
-    - Sometimes when a file's path has 'white space' in it, extra buffers
-      would be created containing each piece of the path. i.e:
-      opening c:\document and settings\test.txt would create a buffer
-      named "and" and a buffer named "Documents". This was reported and
-      fixed by TaCa Yoss.
-7.1.3    November 15, 2007
-    - Added code to allow only one instance of the plugin to run at a time.
-      Thanks Dennis Hostetler.
-7.1.2    November 07, 2007
-    - Dave Larson added handling of tabs.
-    - Dave Larson removed \bs and \bv commands because these are easier for
-      the used to create horizontal and vertical windows.
-    - Fixed a jumplist issue spotted by JiangJun. I overlooked the
-      'jumplist' and with a couple calls to 'keepjumps', everything is fine
-      again.
-    - Went back to using just a plugin file, instead of both an autoload
-      and plugin file. The splitting of the file caused issues with other
-      plugins.  So if you have a prior version of bufexplorer that has an
-      autoload file, please remove autoload\bufexplorer and
-      plugin\bufexplorer before installing this new version.
-    - Fixed E493 error spotted by Thomas Arendsen Hein.
-    - Minor cosmetic changes.
-    - Minor help file changes.
-7.1.1    August 02, 2007
-    - A problem spotted by Thomas Arendsen Hein.  When running Vim
-      (7.1.94), error E493 was being thrown.
-    * Added 'D' for 'delete' buffer as the 'd' command was a 'wipe' buffer.
-7.1.0    August 01, 2007
-    - Another 'major' update, some by Dave Larson, some by me.
-    - Making use of 'autoload' now to make the plugin load quicker.
-    - Removed '\bs' and '\bv'. These are now controlled by the user. The
-      user can issue a ':sp' or ':vs' to create a horizontal or vertical
-      split window and then issue a '\be'
-    - Added handling of tabs.
-7.0.17   July 24, 2007
-    - Fixed issue with 'drop' command.
-    - Various enhancements and improvements.
-7.0.16   May 15, 2007
-    - Fixed issue reported by Liu Jiaping on non Windows systems, which was
-      ...
-      Open file1, open file2, modify file1, open bufexplorer, you get the
-      following error:
-
-      --------8<--------
-      Error detected while processing function
-      <SNR>14_StartBufExplorer..<SNR>14_SplitOpen:
-      line    4:
-      E37: No write since last change (add ! to override)
-
-      But the worse thing is, when I want to save the current buffer and
-      type ':w', I get another error message:
-      E382: Cannot write, 'buftype' option is set
-      --------8<--------
-
-7.0.15   April 27, 2007
-    - Thanks to Mark Smithfield for suggesting bufexplorer needed to handle
-      the ':args' command.
-7.0.14   March 23, 2007
-    - Thanks to Randall Hansen for removing the requirement of terminal
-      versions to be recompiled with 'gui' support so the 'drop' command
-      would work. The 'drop' command is really not needed in terminal
-      versions.
-7.0.13   February 23, 2007
-    - Fixed integration with WinManager.
-    - Thanks to Dave Eggum for another update.
-      * Fix: The detailed help didn't display the mapping for toggling
-        the split type, even though the split type is displayed.
-      * Fixed incorrect description in the detailed help for toggling
-        relative or full paths.
-      * Deprecated s:ExtractBufferNbr(). Vim's str2nr() does the same
-        thing.
-      * Created a s:Set() function that sets a variable only if it hasn't
-        already been defined. It's useful for initializing all those
-        default settings.
-      * Removed checks for repetitive command definitions. They were
-        unnecessary.
-      * Made the help highlighting a little more fancy.
-      * Minor reverse compatibility issue: Changed ambiguous setting
-        names to be more descriptive of what they do (also makes the code
-        easier to follow):
-            Changed bufExplorerSortDirection to bufExplorerReverseSort
-            Changed bufExplorerSplitType to bufExplorerSplitVertical
-            Changed bufExplorerOpenMode to bufExplorerUseCurrentWindow
-      * When the BufExplorer window closes, all the file-local marks are
-        now deleted. This may have the benefit of cleaning up some of the
-        jumplist.
-      * Changed the name of the parameter for StartBufExplorer from
-        "split" to "open". The parameter is a string which specifies how
-        the buffer will be open, not if it is split or not.
-      * Deprecated DoAnyMoreBuffersExist() - it is a one line function
-        only used in one spot.
-      * Created four functions (SplitOpen(), RebuildBufferList(),
-        UpdateHelpStatus() and ReSortListing()) all with one purpose - to
-        reduce repeated code.
-      * Changed the name of AddHeader() to CreateHelp() to be more
-        descriptive of what it does. It now returns an array instead of
-        updating the window directly. This has the benefit of making the
-        code more efficient since the text the function returns is used a
-        little differently in the two places the function is called.
-      * Other minor simplifications.
-7.0.12   November 30, 2006
-    - MAJOR Update.  This version will ONLY run with Vim version 7.0 or
-      greater.
-    - Dave Eggum has made some 'significant' updates to this latest
-      version:
-      * Added BufExplorerGetAltBuf() global function to be used in the
-        user's rulerformat.
-      * Added g:bufExplorerSplitRight option.
-      * Added g:bufExplorerShowRelativePath option with mapping.
-      * Added current line highlighting.
-      * The split type can now be changed whether bufexplorer is opened
-        in split mode or not.
-      * Various major and minor bug fixes and speed improvements.
-      * Sort by extension.
-    - Other improvements/changes:
-      * Changed the help key from '?' to <F1> to be more 'standard'.
-      * Fixed splitting of vertical bufexplorer window.
-    - Hopefully I have not forgot something :)
-7.0.11   March 10, 2006
-    - Fixed a couple of highlighting bugs, reported by David Eggum.
-    - Dave Eggum also changed passive voice to active on a couple of
-      warning messages.
-7.0.10   March 02, 2006
-    - Fixed bug report by Xiangjiang Ma. If the 'ssl' option is set,
-      the slash character used when displaying the path was incorrect.
-7.0.9    February 28, 2006
-    - Martin Grenfell found and eliminated an annoying bug in the
-      bufexplorer/winmanager integration. The bug was were an
-      annoying message would be displayed when a window was split or
-      a new file was opened in a new window. Thanks Martin!
-7.0.8    January 18, 2006
-    - Thanks to Mike Li for catching a bug in the WinManager integration.
-      The bug was related to the incorrect displaying of the buffer
-      explorer's window title.
-7.0.7    December 19, 2005
-    - Thanks to Jeremy Cowgar for adding a new enhancement. This
-      enhancement allows the user to press 'S', that is capital S, which
-      will open the buffer under the cursor in a newly created split
-      window.
-7.0.6    November 18, 2005
-    - Thanks to Larry Zhang for finding a bug in the "split" buffer code.
-      If you force set g:bufExplorerSplitType='v' in your vimrc, and if you
-      tried to do a \bs to split the bufexplorer window, it would always
-      split horizontal, not vertical.
-    - Larry Zhang also found that I had a typeo in that the variable
-      g:bufExplorerSplitVertSize was all lower case in the documentation
-      which was incorrect.
-7.0.5    October 18, 2005
-    - Thanks to Mun Johl for pointing out a bug that if a buffer was
-      modified, the '+' was not showing up correctly.
-7.0.4    October 03, 2005
-    - Fixed a problem discovered first by Xiangjiang Ma. Well since I've
-      been using vim 7.0 and not 6.3, I started using a function (getftype)
-      that is not in 6.3. So for backward compatibility, I conditionaly use
-      this function now.  Thus, the g:bufExplorerShowDirectories feature is
-      only available when using vim 7.0 and above.
-7.0.3    September 30, 2005
-    - Thanks to Erwin Waterlander for finding a problem when the last
-      buffer was deleted. This issue got me to rewrite the buffer display
-      logic (which I've wanted to do for sometime now).
-    - Also great thanks to Dave Eggum for coming up with idea for
-      g:bufExplorerShowDirectories. Read the above information about this
-      feature.
-7.0.2    March 25, 2005
-    - Thanks to Thomas Arendsen Hein for finding a problem when a user
-      has the default help turned off and then brought up the explorer. An
-      E493 would be displayed.
-7.0.1    March 10, 2005
-    - Thanks to Erwin Waterlander for finding a couple problems.
-      The first problem allowed a modified buffer to be deleted.  Opps! The
-      second problem occurred when several files were opened, BufExplorer
-      was started, the current buffer was deleted using the 'd' option, and
-      then BufExplorer was exited. The deleted buffer was still visible
-      while it is not in the buffers list. Opps again!
-7.0.0    March 10, 205
-    - Thanks to Shankar R. for suggesting to add the ability to set
-      the fixed width (g:bufExplorerSplitVertSize) of a new window
-      when opening bufexplorer vertically and fixed height
-      (g:bufExplorerSplitHorzSize) of a new window when opening
-      bufexplorer horizontally. By default, the windows are normally
-      split to use half the existing width or height.
-6.3.0    July 23, 2004
-    - Added keepjumps so that the jumps list would not get cluttered with
-      bufexplorer related stuff.
-6.2.3    April 15, 2004
-    - Thanks to Jay Logan for finding a bug in the vertical split position
-      of the code. When selecting that the window was to be split
-      vertically by doing a '\bv', from then on, all splits, i.e. '\bs',
-      were split vertically, even though g:bufExplorerSplitType was not set
-      to 'v'.
-6.2.2    January 09, 2004
-    - Thanks to Patrik Modesto for adding a small improvement. For some
-      reason his bufexplorer window was always showing up folded. He added
-      'setlocal nofoldenable' and it was fixed.
-6.2.1    October 09, 2003
-    - Thanks goes out to Takashi Matsuo for added the 'fullPath' sorting
-      logic and option.
-6.2.0    June 13, 2003
-    - Thanks goes out to Simon Johann-Ganter for spotting and fixing a
-      problem in that the last search pattern is overridden by the search
-      pattern for blank lines.
-6.1.6    May 05, 2003
-    - Thanks to Artem Chuprina for finding a pesky bug that has been around
-      for sometime now. The <esc> key mapping was causing the buffer
-      explored to close prematurely when vim was run in an xterm. The <esc>
-      key mapping is now removed.
-6.1.5    April 28, 2003
-    - Thanks to Khorev Sergey. Added option to show default help or not.
-6.1.4    March 18, 2003
-    - Thanks goes out to Valery Kondakoff for suggesting the addition of
-      setlocal nonumber and foldcolumn=0. This allows for line numbering
-      and folding to be turned off temporarily while in the explorer.
-6.1.3    March 11, 2003
-    - Added folding.
-    - Did some code cleanup.
-    - Added the ability to force the newly split window to be temporarily
-      vertical, which was suggested by Thomas Glanzmann.
-6.1.2    November 05, 2002
-    - Now pressing the <esc> key will quit, just like 'q'.
-    - Added folds to hide winmanager configuration.
-    - If anyone had the 'C' option in their cpoptions they would receive
-      a E10 error on startup of BufExplorer. cpo is now saved, updated and
-      restored. Thanks to Charles E Campbell, Jr.
-    - Attempted to make sure there can only be one BufExplorer window open
-      at a time.
-6.1.1    March 28, 2002
-    - Thanks to Brian D. Goodwin for adding toupper to FileNameCmp. This
-      way buffers sorted by name will be in the correct order regardless of
-      case.
-6.0.16   March 14, 2002
-    - Thanks to Andre Pang for the original patch/idea to get bufexplorer
-      to work in insertmode/modeless mode (evim).
-    - Added Initialize and Cleanup autocommands to handle commands that
-      need to be performed when starting or leaving bufexplorer.
-6.0.15   February 20, 2002
-    - Srinath Avadhanulax added a patch for winmanager.vim.
-6.0.14   February 19, 2002
-    - Fix a few more bug that I thought I already had fixed.
-    - Thanks to Eric Bloodworth for adding 'Open Mode/Edit in Place'.
-    - Added vertical splitting.
-6.0.13   February 05, 2002
-    - Thanks to Charles E Campbell, Jr. for pointing out some embarrassing
-      typos that I had in the documentation. I guess I need to run the
-      spell checker more :o)
-6.0.12   February 04, 2002
-    - Thanks to Madoka Machitani, for the tip on adding the augroup command
-      around the MRUList autocommands.
-6.0.11   January 26, 2002
-    - Fixed bug report by Xiangjiang Ma. '"=' was being added to the search
-      history which messed up hlsearch.
-6.0.10   January 14, 2002
-    - Added the necessary hooks so that the Srinath Avadhanula's
-      winmanager.vim script could more easily integrate with this script.
-    - Tried to improve performance.
-6.0.9    December 17, 2001
-    - Added MRU (Most Recently Used) sort ordering.
-6.0.8    December 03, 2001
-    - Was not resetting the showcmd command correctly.
-    - Added nifty help file.
-6.0.7    November 19, 2001
-    - Thanks to Brett Carlane for some great enhancements. Some are added,
-      some are not, yet. Added highlighting of current and alternate
-      filenames. Added splitting of path/filename toggle. Reworked
-      ShowBuffers().
-    - Changed my email address.
-6.0.6    September 05, 2001
-    - Copyright notice added. Needed this so that it could be distributed
-      with Debian Linux.
-    - Fixed problem with the SortListing() function failing when there was
-      only one buffer to display.
-6.0.5    August 10, 2001
-    - Fixed problems reported by David Pascoe, in that you where unable to
-      hit 'd' on a buffer that belonged to a files that no longer existed
-      and that the 'yank' buffer was being overridden by the help text when
-      the bufexplorer was opened.
-6.0.4    July, 31, 2001
-    - Thanks to Charles Campbell, Jr. for making this plugin more plugin
-      *compliant*, adding default keymappings of <Leader>be and <Leader>bs
-      as well as fixing the 'w:sortDirLabel not being defined' bug.
-6.0.3    July 30, 2001
-    - Added sorting capabilities. Sort taken from explorer.vim.
-6.0.2    July 25, 2001
-    - Can't remember.
-6.0.1    Sometime before July 25, 2001
-    - Initial release.
-
-===============================================================================
-TODO                                                         *bufexplorer-todo*
-
-- Add ability to open a buffer in a horizontal or vertical split after the
-  initial bufexplorer window is opened.
-
-===============================================================================
-CREDITS                                                   *bufexplorer-credits*
-
-Author: Jeff Lanzarotta <delux256-vim at outlook dot com>
-
-Credit must go out to Bram Moolenaar and all the Vim developers for
-making the world's best editor (IMHO). I also want to thank everyone who
-helped and gave me suggestions. I wouldn't want to leave anyone out so I
-won't list names.
-
-===============================================================================
-COPYRIGHT                                               *bufexplorer-copyright*
-
-Copyright (c) 2001-2017, Jeff Lanzarotta
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-* Redistributions of source code must retain the above copyright notice, this
-  list of conditions and the following disclaimer.
-
-* Redistributions in binary form must reproduce the above copyright notice,
-  this list of conditions and the following disclaimer in the documentation
-  and/or other materials provided with the distribution.
-
-* Neither the name of the {organization} nor the names of its contributors may
-  be used to endorse or promote products derived from this software without
-  specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
-DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
-OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-===============================================================================
-vim:tw=78:noet:wrap:ts=4:ft=help:norl:
diff --git a/sources_non_forked/bufexplorer/plugin/bufexplorer.vim b/sources_non_forked/bufexplorer/plugin/bufexplorer.vim
deleted file mode 100644
index 6a7ef4f..0000000
--- a/sources_non_forked/bufexplorer/plugin/bufexplorer.vim
+++ /dev/null
@@ -1,1366 +0,0 @@
-"============================================================================
-"    Copyright: Copyright (c) 2001-2018, Jeff Lanzarotta
-"               All rights reserved.
-"
-"               Redistribution and use in source and binary forms, with or
-"               without modification, are permitted provided that the
-"               following conditions are met:
-"
-"               * Redistributions of source code must retain the above
-"                 copyright notice, this list of conditions and the following
-"                 disclaimer.
-"
-"               * Redistributions in binary form must reproduce the above
-"                 copyright notice, this list of conditions and the following
-"                 disclaimer in the documentation and/or other materials
-"                 provided with the distribution.
-"
-"               * Neither the name of the {organization} nor the names of its
-"                 contributors may be used to endorse or promote products
-"                 derived from this software without specific prior written
-"                 permission.
-"
-"               THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
-"               CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
-"               INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
-"               MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-"               DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-"               CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-"               SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-"               NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-"               LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
-"               HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-"               CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
-"               OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
-"               EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-" Name Of File: bufexplorer.vim
-"  Description: Buffer Explorer Vim Plugin
-"   Maintainer: Jeff Lanzarotta (delux256-vim at outlook dot com)
-" Last Changed: Saturday, 08 December 2018
-"      Version: See g:bufexplorer_version for version number.
-"        Usage: This file should reside in the plugin directory and be
-"               automatically sourced.
-"
-"               You may use the default keymappings of
-"
-"                 <Leader>be  - Opens BufExplorer
-"                 <Leader>bt  - Toggles BufExplorer open or closed
-"                 <Leader>bs  - Opens horizontally split window BufExplorer
-"                 <Leader>bv  - Opens vertically split window BufExplorer
-"
-"               Or you can override the defaults and define your own mapping
-"               in your vimrc file, for example:
-"
-"                   nnoremap <silent> <F11> :BufExplorer<CR>
-"                   nnoremap <silent> <s-F11> :ToggleBufExplorer<CR>
-"                   nnoremap <silent> <m-F11> :BufExplorerHorizontalSplit<CR>
-"                   nnoremap <silent> <c-F11> :BufExplorerVerticalSplit<CR>
-"
-"               Or you can use
-"
-"                 ":BufExplorer"                - Opens BufExplorer
-"                 ":ToggleBufExplorer"          - Opens/Closes BufExplorer
-"                 ":BufExplorerHorizontalSplit" - Opens horizontally window BufExplorer
-"                 ":BufExplorerVerticalSplit"   - Opens vertically split window BufExplorer
-"
-"               For more help see supplied documentation.
-"      History: See supplied documentation.
-"=============================================================================
-
-" Exit quickly if already running or when 'compatible' is set. {{{1
-if exists("g:bufexplorer_version") || &cp
-    finish
-endif
-"1}}}
-
-" Version number
-let g:bufexplorer_version = "7.4.21"
-
-" Plugin Code {{{1
-" Check for Vim version {{{2
-if !exists("g:bufExplorerVersionWarn")
-    let g:bufExplorerVersionWarn = 1
-endif
-
-if v:version < 700
-    if g:bufExplorerVersionWarn
-        echohl WarningMsg
-        echo "Sorry, bufexplorer ".g:bufexplorer_version." required Vim 7.0 or greater."
-        echohl None
-    endif
-    finish
-endif
-" Check to see if the version of Vim has the correct patch applied, if not, do
-" not used <nowait>.
-if v:version > 703 || v:version == 703 && has('patch1261') && has('patch1264')
-    " We are good to go.
-else
-    if g:bufExplorerVersionWarn
-        echohl WarningMsg
-        echo "Sorry, bufexplorer ".g:bufexplorer_version." required Vim 7.3 or greater with patch1261 and patch1264."
-        echohl None
-    endif
-    finish
-endif
-
-" Create commands {{{2
-command! BufExplorer :call BufExplorer()
-command! ToggleBufExplorer :call ToggleBufExplorer()
-command! BufExplorerHorizontalSplit :call BufExplorerHorizontalSplit()
-command! BufExplorerVerticalSplit :call BufExplorerVerticalSplit()
-
-" Set {{{2
-function! s:Set(var, default)
-    if !exists(a:var)
-        if type(a:default)
-            execute "let" a:var "=" string(a:default)
-        else
-            execute "let" a:var "=" a:default
-        endif
-
-        return 1
-    endif
-
-    return 0
-endfunction
-
-" Script variables {{{2
-let s:MRU_Exclude_List = ["[BufExplorer]","__MRU_Files__","[Buf\ List]"]
-let s:MRUList = []
-let s:name = '[BufExplorer]'
-let s:originBuffer = 0
-let s:running = 0
-let s:sort_by = ["number", "name", "fullpath", "mru", "extension"]
-let s:splitMode = ""
-let s:types = {"fullname": ':p', "path": ':p:h', "relativename": ':~:.', "relativepath": ':~:.:h', "shortname": ':t'}
-
-" Setup the autocommands that handle the MRUList and other stuff. {{{2
-autocmd VimEnter * call s:Setup()
-
-" Setup {{{2
-function! s:Setup()
-    call s:Reset()
-
-    " Now that the MRUList is created, add the other autocmds.
-    augroup BufExplorer
-        autocmd!
-        autocmd BufEnter,BufNew * call s:ActivateBuffer()
-        autocmd BufWipeOut * call s:DeactivateBuffer(1)
-        autocmd BufDelete * call s:DeactivateBuffer(0)
-        autocmd BufWinEnter \[BufExplorer\] call s:Initialize()
-        autocmd BufWinLeave \[BufExplorer\] call s:Cleanup()
-    augroup END
-endfunction
-
-" Reset {{{2
-function! s:Reset()
-    " Build initial MRUList. This makes sure all the files specified on the
-    " command line are picked up correctly.
-    let s:MRUList = range(1, bufnr('$'))
-
-    " Initialize the association of buffers to tabs for any buffers
-    " that have been created prior to now, e.g., files specified as
-    " vim command line arguments
-    call s:CatalogBuffers()
-endfunction
-
-" CatalogBuffers {{{2
-" Create tab associations for any existing buffers
-function! s:CatalogBuffers()
-    let ct = tabpagenr()
-
-    for tab in range(1, tabpagenr('$'))
-        silent execute 'normal! ' . tab . 'gt'
-        for buf in tabpagebuflist()
-            call s:UpdateTabBufData(buf)
-        endfor
-    endfor
-
-    silent execute 'normal! ' . ct . 'gt'
-endfunction
-
-" AssociatedTab {{{2
-" Return the number of the tab associated with the specified buffer.
-" If the buffer is associated with more than one tab, the first one
-" found is returned. If the buffer is not associated with any tabs,
-" -1 is returned.
-function! s:AssociatedTab(bufnr)
-    for tab in range(1, tabpagenr('$'))
-        let list = gettabvar(tab, 'bufexp_buf_list', [])
-        let idx = index(list, a:bufnr)
-        if idx != -1
-            return tab
-        endif
-    endfor
-
-    return -1
-endfunction
-
-" RemoveBufFromOtherTabs {{{2
-" Remove the specified buffer from the buffer lists of all tabs
-" except the current tab.
-function! s:RemoveBufFromOtherTabs(bufnr)
-    for tab in range(1, tabpagenr('$'))
-        if tab == tabpagenr()
-            continue
-        endif
-
-        let list = gettabvar(tab, 'bufexp_buf_list', [])
-        let idx = index(list, a:bufnr)
-        if idx == -1
-            continue
-        endif
-
-        call remove(list, idx)
-        call settabvar(tab, 'bufexp_buf_list', list)
-    endfor
-endfunction
-
-" AddBufToCurrentTab {{{2
-" Add the specified buffer to the list of buffers associated
-" with the current tab
-function! s:AddBufToCurrentTab(bufnr)
-    if index(t:bufexp_buf_list, a:bufnr) == -1
-        call add(t:bufexp_buf_list, a:bufnr)
-    endif
-endfunction
-
-" IsInCurrentTab {{{2
-" Returns whether the specified buffer is associated
-" with the current tab
-function! s:IsInCurrentTab(bufnr)
-    " It shouldn't happen that the list of buffers is
-    " not defined but if it does, play it safe and
-    " include the buffer
-    if !exists('t:bufexp_buf_list')
-        return 1
-    endif
-
-    return (index(t:bufexp_buf_list, a:bufnr) != -1)
-endfunction
-
-" UpdateTabBufData {{{2
-" Update the tab buffer data for the specified buffer
-"
-" The current tab's list is updated. If a buffer is only
-" allowed to be associated with one tab, it is removed
-" from the lists of any other tabs with which it may have
-" been associated.
-"
-" The associations between tabs and buffers are maintained
-" in separate lists for each tab, which are stored in tab-
-" specific variables 't:bufexp_buf_list'.
-function! s:UpdateTabBufData(bufnr)
-    " The first time we add a tab, Vim uses the current buffer
-    " as its starting page even though we are about to edit a
-    " new page, and another BufEnter for the new page is triggered
-    " later. Use this first BufEnter to initialize the list of
-    " buffers, but don't add the buffer number to the list if
-    " it is already associated with another tab
-    "
-    " Unfortunately, this doesn't work right when the first
-    " buffer opened in the tab should be associated with it,
-    " such as when 'tab split +buffer N' is used
-    if !exists("t:bufexp_buf_list")
-        let t:bufexp_buf_list = []
-
-        if s:AssociatedTab(a:bufnr) != -1
-            return
-        endif
-    endif
-
-    call s:AddBufToCurrentTab(a:bufnr)
-
-    if g:bufExplorerOnlyOneTab
-        call s:RemoveBufFromOtherTabs(a:bufnr)
-    endif
-endfunction
-
-" ActivateBuffer {{{2
-function! s:ActivateBuffer()
-    let _bufnr = bufnr("%")
-    call s:UpdateTabBufData(_bufnr)
-    call s:MRUPush(_bufnr)
-endfunction
-
-" DeactivateBuffer {{{2
-function! s:DeactivateBuffer(remove)
-    let _bufnr = str2nr(expand("<abuf>"))
-    call s:MRUPop(_bufnr)
-endfunction
-
-" MRUPop {{{2
-function! s:MRUPop(bufnr)
-    call filter(s:MRUList, 'v:val != '.a:bufnr)
-endfunction
-
-" MRUPush {{{2
-function! s:MRUPush(buf)
-    " Skip temporary buffer with buftype set. Don't add the BufExplorer window
-    " to the list.
-    if s:ShouldIgnore(a:buf) == 1
-        return
-    endif
-
-    " Remove the buffer number from the list if it already exists.
-    call s:MRUPop(a:buf)
-
-    " Add the buffer number to the head of the list.
-    call insert(s:MRUList, a:buf)
-endfunction
-
-" ShouldIgnore {{{2
-function! s:ShouldIgnore(buf)
-    " Ignore temporary buffers with buftype set.
-    if empty(getbufvar(a:buf, "&buftype") == 0)
-        return 1
-    endif
-
-    " Ignore buffers with no name.
-    if empty(bufname(a:buf)) == 1
-        return 1
-    endif
-
-    " Ignore the BufExplorer buffer.
-    if fnamemodify(bufname(a:buf), ":t") == s:name
-        return 1
-    endif
-
-    " Ignore any buffers in the exclude list.
-    if index(s:MRU_Exclude_List, bufname(a:buf)) >= 0
-        return 1
-    endif
-
-    " Else return 0 to indicate that the buffer was not ignored.
-    return 0
-endfunction
-
-" Initialize {{{2
-function! s:Initialize()
-    call s:SetLocalSettings()
-    let s:running = 1
-endfunction
-
-" Cleanup {{{2
-function! s:Cleanup()
-    if exists("s:_insertmode")
-        let &insertmode = s:_insertmode
-    endif
-
-    if exists("s:_showcmd")
-        let &showcmd = s:_showcmd
-    endif
-
-    if exists("s:_cpo")
-        let &cpo = s:_cpo
-    endif
-
-    if exists("s:_report")
-        let &report = s:_report
-    endif
-
-    let s:running = 0
-    let s:splitMode = ""
-
-    delmarks!
-endfunction
-
-" SetLocalSettings {{{2
-function! s:SetLocalSettings()
-    let s:_insertmode = &insertmode
-    set noinsertmode
-
-    let s:_showcmd = &showcmd
-    set noshowcmd
-
-    let s:_cpo = &cpo
-    set cpo&vim
-
-    let s:_report = &report
-    let &report = 10000
-
-    setlocal nonumber
-    setlocal foldcolumn=0
-    setlocal nofoldenable
-    setlocal cursorline
-    setlocal nospell
-    setlocal nobuflisted
-    setlocal filetype=bufexplorer
-endfunction
-
-" BufExplorerHorizontalSplit {{{2
-function! BufExplorerHorizontalSplit()
-    let s:splitMode = "sp"
-    execute "BufExplorer"
-endfunction
-
-" BufExplorerVerticalSplit {{{2
-function! BufExplorerVerticalSplit()
-    let s:splitMode = "vsp"
-    execute "BufExplorer"
-endfunction
-
-" ToggleBufExplorer {{{2
-function! ToggleBufExplorer()
-    if exists("s:running") && s:running == 1 && bufname(winbufnr(0)) == s:name
-        call s:Close()
-    else
-        call BufExplorer()
-    endif
-endfunction
-
-" BufExplorer {{{2
-function! BufExplorer()
-    let name = s:name
-
-    if !has("win32")
-        " On non-Windows boxes, escape the name so that is shows up correctly.
-        let name = escape(name, "[]")
-    endif
-
-    " Make sure there is only one explorer open at a time.
-    if s:running == 1
-        " Go to the open buffer.
-        if has("gui")
-            execute "drop" name
-        endif
-
-        return
-    endif
-
-    " Add zero to ensure the variable is treated as a number.
-    let s:originBuffer = bufnr("%") + 0
-
-    silent let s:raw_buffer_listing = s:GetBufferInfo(0)
-
-    " We may have to split the current window.
-    if s:splitMode != ""
-        " Save off the original settings.
-        let [_splitbelow, _splitright] = [&splitbelow, &splitright]
-
-        " Set the setting to ours.
-        let [&splitbelow, &splitright] = [g:bufExplorerSplitBelow, g:bufExplorerSplitRight]
-        let _size = (s:splitMode == "sp") ? g:bufExplorerSplitHorzSize : g:bufExplorerSplitVertSize
-
-        " Split the window either horizontally or vertically.
-        if _size <= 0
-            execute 'keepalt ' . s:splitMode
-        else
-            execute 'keepalt ' . _size . s:splitMode
-        endif
-
-        " Restore the original settings.
-        let [&splitbelow, &splitright] = [_splitbelow, _splitright]
-    endif
-
-    if !exists("b:displayMode") || b:displayMode != "winmanager"
-        " Do not use keepalt when opening bufexplorer to allow the buffer that
-        " we are leaving to become the new alternate buffer
-        execute "silent keepjumps hide edit".name
-    endif
-
-    call s:DisplayBufferList()
-
-    " Position the cursor in the newly displayed list on the line representing
-    " the active buffer.  The active buffer is the line with the '%' character
-    " in it.
-    execute search("%")
-endfunction
-
-" DisplayBufferList {{{2
-function! s:DisplayBufferList()
-    " Do not set bufhidden since it wipes out the data if we switch away from
-    " the buffer using CTRL-^.
-    setlocal buftype=nofile
-    setlocal modifiable
-    setlocal noswapfile
-    setlocal nowrap
-
-    call s:SetupSyntax()
-    call s:MapKeys()
-
-    " Wipe out any existing lines in case BufExplorer buffer exists and the
-    " user had changed any global settings that might reduce the number of
-    " lines needed in the buffer.
-    silent keepjumps 1,$d _
-
-    call setline(1, s:CreateHelp())
-    call s:BuildBufferList()
-    call cursor(s:firstBufferLine, 1)
-
-    if !g:bufExplorerResize
-        normal! zz
-    endif
-
-    setlocal nomodifiable
-endfunction
-
-" MapKeys {{{2
-function! s:MapKeys()
-    if exists("b:displayMode") && b:displayMode == "winmanager"
-        nnoremap <buffer> <silent> <tab> :call <SID>SelectBuffer()<CR>
-    endif
-
-    nnoremap <script> <silent> <nowait> <buffer> <2-leftmouse> :call <SID>SelectBuffer()<CR>
-    nnoremap <script> <silent> <nowait> <buffer> <CR>          :call <SID>SelectBuffer()<CR>
-    nnoremap <script> <silent> <nowait> <buffer> <F1>          :call <SID>ToggleHelp()<CR>
-    nnoremap <script> <silent> <nowait> <buffer> <s-cr>        :call <SID>SelectBuffer("tab")<CR>
-    nnoremap <script> <silent> <nowait> <buffer> a             :call <SID>ToggleFindActive()<CR>
-    nnoremap <script> <silent> <nowait> <buffer> b             :call <SID>SelectBuffer("ask")<CR>
-    nnoremap <script> <silent> <nowait> <buffer> d             :call <SID>RemoveBuffer("delete")<CR>
-    xnoremap <script> <silent> <nowait> <buffer> d             :call <SID>RemoveBuffer("delete")<CR>
-    nnoremap <script> <silent> <nowait> <buffer> D             :call <SID>RemoveBuffer("wipe")<CR>
-    xnoremap <script> <silent> <nowait> <buffer> D             :call <SID>RemoveBuffer("wipe")<CR>
-    nnoremap <script> <silent> <nowait> <buffer> f             :call <SID>SelectBuffer("split", "sb")<CR>
-    nnoremap <script> <silent> <nowait> <buffer> F             :call <SID>SelectBuffer("split", "st")<CR>
-    nnoremap <script> <silent> <nowait> <buffer> m             :call <SID>MRUListShow()<CR>
-    nnoremap <script> <silent> <nowait> <buffer> o             :call <SID>SelectBuffer()<CR>
-    nnoremap <script> <silent> <nowait> <buffer> p             :call <SID>ToggleSplitOutPathName()<CR>
-    nnoremap <script> <silent> <nowait> <buffer> q             :call <SID>Close()<CR>
-    nnoremap <script> <silent> <nowait> <buffer> r             :call <SID>SortReverse()<CR>
-    nnoremap <script> <silent> <nowait> <buffer> R             :call <SID>ToggleShowRelativePath()<CR>
-    nnoremap <script> <silent> <nowait> <buffer> s             :call <SID>SortSelect()<CR>
-    nnoremap <script> <silent> <nowait> <buffer> S             :call <SID>ReverseSortSelect()<CR>
-    nnoremap <script> <silent> <nowait> <buffer> t             :call <SID>SelectBuffer("tab")<CR>
-    nnoremap <script> <silent> <nowait> <buffer> T             :call <SID>ToggleShowTabBuffer()<CR>
-    nnoremap <script> <silent> <nowait> <buffer> u             :call <SID>ToggleShowUnlisted()<CR>
-    nnoremap <script> <silent> <nowait> <buffer> v             :call <SID>SelectBuffer("split", "vr")<CR>
-    nnoremap <script> <silent> <nowait> <buffer> V             :call <SID>SelectBuffer("split", "vl")<CR>
-
-    for k in ["G", "n", "N", "L", "M", "H"]
-        execute "nnoremap <buffer> <silent>" k ":keepjumps normal!" k."<CR>"
-    endfor
-endfunction
-
-" SetupSyntax {{{2
-function! s:SetupSyntax()
-    if has("syntax")
-        syn match bufExplorerHelp     "^\".*" contains=bufExplorerSortBy,bufExplorerMapping,bufExplorerTitle,bufExplorerSortType,bufExplorerToggleSplit,bufExplorerToggleOpen
-        syn match bufExplorerOpenIn   "Open in \w\+ window" contained
-        syn match bufExplorerSplit    "\w\+ split" contained
-        syn match bufExplorerSortBy   "Sorted by .*" contained contains=bufExplorerOpenIn,bufExplorerSplit
-        syn match bufExplorerMapping  "\" \zs.\+\ze :" contained
-        syn match bufExplorerTitle    "Buffer Explorer.*" contained
-        syn match bufExplorerSortType "'\w\{-}'" contained
-        syn match bufExplorerBufNbr   /^\s*\d\+/
-        syn match bufExplorerToggleSplit  "toggle split type" contained
-        syn match bufExplorerToggleOpen   "toggle open mode" contained
-
-        syn match bufExplorerModBuf    /^\s*\d\+.\{4}+.*/
-        syn match bufExplorerLockedBuf /^\s*\d\+.\{3}[\-=].*/
-        syn match bufExplorerHidBuf    /^\s*\d\+.\{2}h.*/
-        syn match bufExplorerActBuf    /^\s*\d\+.\{2}a.*/
-        syn match bufExplorerCurBuf    /^\s*\d\+.%.*/
-        syn match bufExplorerAltBuf    /^\s*\d\+.#.*/
-        syn match bufExplorerUnlBuf    /^\s*\d\+u.*/
-        syn match bufExplorerInactBuf  /^\s*\d\+ \{7}.*/
-
-        hi def link bufExplorerBufNbr Number
-        hi def link bufExplorerMapping NonText
-        hi def link bufExplorerHelp Special
-        hi def link bufExplorerOpenIn Identifier
-        hi def link bufExplorerSortBy String
-        hi def link bufExplorerSplit NonText
-        hi def link bufExplorerTitle NonText
-        hi def link bufExplorerSortType bufExplorerSortBy
-        hi def link bufExplorerToggleSplit bufExplorerSplit
-        hi def link bufExplorerToggleOpen bufExplorerOpenIn
-
-        hi def link bufExplorerActBuf Identifier
-        hi def link bufExplorerAltBuf String
-        hi def link bufExplorerCurBuf Type
-        hi def link bufExplorerHidBuf Constant
-        hi def link bufExplorerLockedBuf Special
-        hi def link bufExplorerModBuf Exception
-        hi def link bufExplorerUnlBuf Comment
-        hi def link bufExplorerInactBuf Comment
-    endif
-endfunction
-
-" ToggleHelp {{{2
-function! s:ToggleHelp()
-    let g:bufExplorerDetailedHelp = !g:bufExplorerDetailedHelp
-
-    setlocal modifiable
-
-    " Save position.
-    normal! ma
-
-    " Remove old header.
-    if s:firstBufferLine > 1
-        execute "keepjumps 1,".(s:firstBufferLine - 1) "d _"
-    endif
-
-    call append(0, s:CreateHelp())
-
-    silent! normal! g`a
-    delmarks a
-
-    setlocal nomodifiable
-
-    if exists("b:displayMode") && b:displayMode == "winmanager"
-        call WinManagerForceReSize("BufExplorer")
-    endif
-endfunction
-
-" GetHelpStatus {{{2
-function! s:GetHelpStatus()
-    let ret = '" Sorted by '.((g:bufExplorerReverseSort == 1) ? "reverse " : "").g:bufExplorerSortBy
-    let ret .= ' | '.((g:bufExplorerFindActive == 0) ? "Don't " : "")."Locate buffer"
-    let ret .= ((g:bufExplorerShowUnlisted == 0) ? "" : " | Show unlisted")
-    let ret .= ((g:bufExplorerShowTabBuffer == 0) ? "" : " | Show buffers/tab")
-    let ret .= ((g:bufExplorerOnlyOneTab == 0) ? "" : " | One tab/buffer")
-    let ret .= ' | '.((g:bufExplorerShowRelativePath == 0) ? "Absolute" : "Relative")
-    let ret .= ' '.((g:bufExplorerSplitOutPathName == 0) ? "Full" : "Split")." path"
-
-    return ret
-endfunction
-
-" CreateHelp {{{2
-function! s:CreateHelp()
-    if g:bufExplorerDefaultHelp == 0 && g:bufExplorerDetailedHelp == 0
-        let s:firstBufferLine = 1
-        return []
-    endif
-
-    let header = []
-
-    if g:bufExplorerDetailedHelp == 1
-        call add(header, '" Buffer Explorer ('.g:bufexplorer_version.')')
-        call add(header, '" --------------------------')
-        call add(header, '" <F1> : toggle this help')
-        call add(header, '" <enter> or o or Mouse-Double-Click : open buffer under cursor')
-        call add(header, '" <shift-enter> or t : open buffer in another tab')
-        call add(header, '" a : toggle find active buffer')
-        call add(header, '" b : Fast buffer switching with b<any bufnum>')
-        call add(header, '" B : toggle if to save/use recent tab or not')
-        call add(header, '" d : delete buffer')
-        call add(header, '" D : wipe buffer')
-        call add(header, '" F : open buffer in another window above the current')
-        call add(header, '" f : open buffer in another window below the current')
-        call add(header, '" p : toggle splitting of file and path name')
-        call add(header, '" q : quit')
-        call add(header, '" r : reverse sort')
-        call add(header, '" R : toggle showing relative or full paths')
-        call add(header, '" s : cycle thru "sort by" fields '.string(s:sort_by).'')
-        call add(header, '" S : reverse cycle thru "sort by" fields')
-        call add(header, '" T : toggle if to show only buffers for this tab or not')
-        call add(header, '" u : toggle showing unlisted buffers')
-        call add(header, '" V : open buffer in another window on the left of the current')
-        call add(header, '" v : open buffer in another window on the right of the current')
-    else
-        call add(header, '" Press <F1> for Help')
-    endif
-
-    if (!exists("b:displayMode") || b:displayMode != "winmanager") || (b:displayMode == "winmanager" && g:bufExplorerDetailedHelp == 1)
-        call add(header, s:GetHelpStatus())
-        call add(header, '"=')
-    endif
-
-    let s:firstBufferLine = len(header) + 1
-
-    return header
-endfunction
-
-" GetBufferInfo {{{2
-function! s:GetBufferInfo(bufnr)
-    redir => bufoutput
-
-    " Show all buffers including the unlisted ones. [!] tells Vim to show the
-    " unlisted ones.
-    buffers!
-    redir END
-
-    if a:bufnr > 0
-        " Since we are only interested in this specified buffer
-        " remove the other buffers listed
-        let bufoutput = substitute(bufoutput."\n", '^.*\n\(\s*'.a:bufnr.'\>.\{-}\)\n.*', '\1', '')
-    endif
-
-    let [all, allwidths, listedwidths] = [[], {}, {}]
-
-    for n in keys(s:types)
-        let allwidths[n] = []
-        let listedwidths[n] = []
-    endfor
-
-    " Loop over each line in the buffer.
-    for buf in split(bufoutput, '\n')
-        let bits = split(buf, '"')
-
-        " Use first and last components after the split on '"', in case a
-        " filename with an embedded '"' is present.
-        let b = {"attributes": bits[0], "line": substitute(bits[-1], '\s*', '', '')}
-
-        let name = bufname(str2nr(b.attributes))
-        let b["hasNoName"] = empty(name)
-        if b.hasNoName
-            let name = "[No Name]"
-        endif
-
-        for [key, val] in items(s:types)
-            let b[key] = fnamemodify(name, val)
-        endfor
-
-        if getftype(b.fullname) == "dir" && g:bufExplorerShowDirectories == 1
-            let b.shortname = "<DIRECTORY>"
-        endif
-
-        call add(all, b)
-
-        for n in keys(s:types)
-            call add(allwidths[n], s:StringWidth(b[n]))
-
-            if b.attributes !~ "u"
-                call add(listedwidths[n], s:StringWidth(b[n]))
-            endif
-        endfor
-    endfor
-
-    let [s:allpads, s:listedpads] = [{}, {}]
-
-    for n in keys(s:types)
-        let s:allpads[n] = repeat(' ', max(allwidths[n]))
-        let s:listedpads[n] = repeat(' ', max(listedwidths[n]))
-    endfor
-
-    return all
-endfunction
-
-" BuildBufferList {{{2
-function! s:BuildBufferList()
-    let lines = []
-
-    " Loop through every buffer.
-    for buf in s:raw_buffer_listing
-        " Skip unlisted buffers if we are not to show them.
-        if !g:bufExplorerShowUnlisted && buf.attributes =~ "u"
-            " Skip unlisted buffers if we are not to show them.
-            continue
-        endif
-
-        " Skip "No Name" buffers if we are not to show them.
-        if g:bufExplorerShowNoName == 0 && buf.hasNoName
-            continue
-        endif
-
-        " Are we to show only buffer(s) for this tab?
-        if g:bufExplorerShowTabBuffer && (!s:IsInCurrentTab(str2nr(buf.attributes)))
-            continue
-        endif
-
-        let line = buf.attributes." "
-
-        if exists("g:loaded_webdevicons")
-            let line .= WebDevIconsGetFileTypeSymbol(buf.shortname)
-            let line .= " "
-        endif
-
-        " Are we to split the path and file name?
-        if g:bufExplorerSplitOutPathName
-            let type = (g:bufExplorerShowRelativePath) ? "relativepath" : "path"
-            let path = buf[type]
-            let pad  = (g:bufExplorerShowUnlisted) ? s:allpads.shortname : s:listedpads.shortname
-            let line .= buf.shortname." ".strpart(pad.path, s:StringWidth(buf.shortname))
-        else
-            let type = (g:bufExplorerShowRelativePath) ? "relativename" : "fullname"
-            let path = buf[type]
-            let line .= path
-        endif
-
-        let pads = (g:bufExplorerShowUnlisted) ? s:allpads : s:listedpads
-
-        if !empty(pads[type])
-            let line .= strpart(pads[type], s:StringWidth(path))." "
-        endif
-
-        let line .= buf.line
-
-        call add(lines, line)
-    endfor
-
-    call setline(s:firstBufferLine, lines)
-    call s:SortListing()
-endfunction
-
-" SelectBuffer {{{2
-function! s:SelectBuffer(...)
-    " Sometimes messages are not cleared when we get here so it looks like an
-    " error has occurred when it really has not.
-    "echo ""
-
-    let _bufNbr = -1
-
-    if (a:0 == 1) && (a:1 == "ask")
-        " Ask the user for input.
-        call inputsave()
-        let cmd = input("Enter buffer number to switch to: ")
-        call inputrestore()
-
-        " Clear the message area from the previous prompt.
-        redraw | echo
-
-        if strlen(cmd) > 0
-            let _bufNbr = str2nr(cmd)
-        else
-            call s:Error("Invalid buffer number, try again.")
-            return
-        endif
-    else
-        " Are we on a line with a file name?
-        if line('.') < s:firstBufferLine
-            execute "normal! \<CR>"
-            return
-        endif
-
-        let _bufNbr = str2nr(getline('.'))
-
-        " Check and see if we are running BufferExplorer via WinManager.
-        if exists("b:displayMode") && b:displayMode == "winmanager"
-            let _bufName = expand("#"._bufNbr.":p")
-
-            if (a:0 == 1) && (a:1 == "tab")
-                call WinManagerFileEdit(_bufName, 1)
-            else
-                call WinManagerFileEdit(_bufName, 0)
-            endif
-
-            return
-        endif
-    endif
-
-    if bufexists(_bufNbr)
-        if bufnr("#") == _bufNbr && !exists("g:bufExplorerChgWin")
-            return s:Close()
-        endif
-
-        " Get the tab number where this bufer is located in.
-        let tabNbr = s:GetTabNbr(_bufNbr)
-        " Are we supposed to open the selected buffer in a tab?
-        if (a:0 == 1) && (a:1 == "tab")
-
-            " Restore [BufExplorer] buffer.
-            execute "silent buffer!".s:originBuffer
-
-            " Was the tab found?
-            if tabNbr == 0
-                " _bufNbr is not opened in any tabs. Open a new tab with the
-                " selected buffer in it.
-                if v:version > 704 || ( v:version == 704 && has('patch2237') )
-                    " new syntax for last tab as of 7.4.2237
-                    execute "$tab split +buffer" . _bufNbr
-                else
-                    execute "999tab split +buffer" . _bufNbr
-                endif
-
-                " Workaround for the issue mentioned in UpdateTabBufData.
-                call s:UpdateTabBufData(_bufNbr)
-            else
-                " The _bufNbr is already opened in a tab, go to that tab.
-                execute tabNbr . "tabnext"
-
-                " Focus window.
-                execute s:GetWinNbr(tabNbr, _bufNbr) . "wincmd w"
-            endif
-            " Are we supposed to open the selected buffer in a split?
-        elseif (a:0 == 2) && (a:1 == "split")
-            if g:bufExplorerFindActive
-                call s:Close()
-            endif
-            " Was the tab found?
-            if tabNbr != 0
-                " Yes, the buffer is located in a tab. Go to that tab instead of
-                " opening split
-                execute tabNbr . "tabnext"
-            else
-                "Nope, the buffer is not in a tab, open it accordingly
-                let _bufName = expand("#"._bufNbr.":p")
-                if (a:2 == "vl")
-                    execute _bufName ?
-                                \ "vert topleft sb ".escape(_bufName, " ") :
-                                \ "vert topleft sb "._bufNbr
-                elseif (a:2 == "vr")
-                    execute _bufName ?
-                                \ "vert belowright sb ".escape(_bufName, " ") :
-                                \ "vert belowright sb "._bufNbr
-                elseif (a:2 == "st")
-                    execute _bufName ?
-                                \ "topleft sb ".escape(_bufName, " ") :
-                                \ "topleft sb "._bufNbr
-                else " = sb
-                    execute _bufName ?
-                                \ "belowright sb ".escape(_bufName, " ") :
-                                \ "belowright sb "._bufNbr
-                endif
-            endif
-
-            " Switch to selected buffer
-            execute "keepalt silent b!" _bufNbr
-            " Default, open in current window
-        else
-            " Are we suppose to move to the tab where the active buffer is?
-            if exists("g:bufExplorerChgWin")
-                execute g:bufExplorerChgWin."wincmd w"
-            elseif bufloaded(_bufNbr) && g:bufExplorerFindActive
-                if g:bufExplorerFindActive
-                    call s:Close()
-                endif
-
-                " Was the tab found?
-                if tabNbr != 0
-                    " Yes, the buffer is located in a tab. Go to that tab number.
-                    execute tabNbr . "tabnext"
-                else
-                    "Nope, the buffer is not in a tab. Simply switch to that
-                    "buffer.
-                    let _bufName = expand("#"._bufNbr.":p")
-                    execute _bufName ? "drop ".escape(_bufName, " ") : "buffer "._bufNbr
-                endif
-            endif
-
-            " Switch to the selected buffer.
-            execute "keepjumps keepalt silent b!" _bufNbr
-        endif
-
-        " Make the buffer 'listed' again.
-        call setbufvar(_bufNbr, "&buflisted", "1")
-
-        " Call any associated function references. g:bufExplorerFuncRef may be
-        " an individual function reference or it may be a list containing
-        " function references. It will ignore anything that's not a function
-        " reference.
-        "
-        " See  :help FuncRef  for more on function references.
-        if exists("g:BufExplorerFuncRef")
-            if type(g:BufExplorerFuncRef) == 2
-                keepj call g:BufExplorerFuncRef()
-            elseif type(g:BufExplorerFuncRef) == 3
-                for FncRef in g:BufExplorerFuncRef
-                    if type(FncRef) == 2
-                        keepj call FncRef()
-                    endif
-                endfor
-            endif
-        endif
-    else
-        call s:Error("Sorry, that buffer no longer exists, please select another")
-        call s:DeleteBuffer(_bufNbr, "wipe")
-    endif
-endfunction
-
-" RemoveBuffer {{{2
-function! s:RemoveBuffer(mode)
-    " Are we on a line with a file name?
-    if line('.') < s:firstBufferLine
-        return
-    endif
-
-    let mode = a:mode
-
-    " These commands are to temporarily suspend the activity of winmanager.
-    if exists("b:displayMode") && b:displayMode == "winmanager"
-        call WinManagerSuspendAUs()
-    end
-
-    let _bufNbr = str2nr(getline('.'))
-
-    if getbufvar(_bufNbr, '&modified') == 1
-        " Calling confirm() requires Vim built with dialog option
-        if !has("dialog_con") && !has("dialog_gui")
-            call s:Error("Sorry, no write since last change for buffer "._bufNbr.", unable to delete")
-            return
-        endif
-
-        let answer = confirm('No write since last change for buffer '._bufNbr.'. Delete anyway?', "&Yes\n&No", 2)
-
-        if a:mode == "delete" && answer == 1
-            let mode = "force_delete"
-        elseif a:mode == "wipe" && answer == 1
-            let mode = "force_wipe"
-        else
-            return
-        endif
-
-    endif
-
-    " Okay, everything is good, delete or wipe the buffer.
-    call s:DeleteBuffer(_bufNbr, mode)
-
-    " Reactivate winmanager autocommand activity.
-    if exists("b:displayMode") && b:displayMode == "winmanager"
-        call WinManagerForceReSize("BufExplorer")
-        call WinManagerResumeAUs()
-    end
-endfunction
-
-" DeleteBuffer {{{2
-function! s:DeleteBuffer(buf, mode)
-    " This routine assumes that the buffer to be removed is on the current line.
-    try
-        " Wipe/Delete buffer from Vim.
-        if a:mode == "wipe"
-            execute "silent bwipe" a:buf
-        elseif a:mode == "force_wipe"
-            execute "silent bwipe!" a:buf
-        elseif a:mode == "force_delete"
-            execute "silent bdelete!" a:buf
-        else
-            execute "silent bdelete" a:buf
-        endif
-
-        " Delete the buffer from the list on screen.
-        setlocal modifiable
-        normal! "_dd
-        setlocal nomodifiable
-
-        " Delete the buffer from the raw buffer list.
-        call filter(s:raw_buffer_listing, 'v:val.attributes !~ " '.a:buf.' "')
-    catch
-        call s:Error(v:exception)
-    endtry
-endfunction
-
-" ListedAndCurrentTab {{{2
-" Returns whether the specified buffer is both listed and associated
-" with the current tab
-function! s:ListedAndCurrentTab(buf)
-    return buflisted(a:buf) && s:IsInCurrentTab(a:buf)
-endfunction
-
-" Close {{{2
-function! s:Close()
-    " Get only the listed buffers associated with the current tab
-    let listed = filter(copy(s:MRUList), "s:ListedAndCurrentTab(v:val)")
-    if len(listed) == 0
-        let listed = filter(range(1, bufnr('$')), "s:ListedAndCurrentTab(v:val)")
-    endif
-
-    " If we needed to split the main window, close the split one.
-    if s:splitMode != "" && bufwinnr(s:originBuffer) != -1
-        execute "wincmd c"
-    endif
-
-    " Check to see if there are anymore buffers listed.
-    if len(listed) == 0
-        " Since there are no buffers left to switch to, open a new empty
-        " buffers.
-        execute "enew"
-    else
-        " Since there are buffers left to switch to, switch to the previous and
-        " then the current.
-        for b in reverse(listed[0:1])
-            execute "keepjumps silent b ".b
-        endfor
-    endif
-
-    " Clear any messages.
-    echo
-endfunction
-
-" ToggleSplitOutPathName {{{2
-function! s:ToggleSplitOutPathName()
-    let g:bufExplorerSplitOutPathName = !g:bufExplorerSplitOutPathName
-    call s:RebuildBufferList()
-    call s:UpdateHelpStatus()
-endfunction
-
-" ToggleShowRelativePath {{{2
-function! s:ToggleShowRelativePath()
-    let g:bufExplorerShowRelativePath = !g:bufExplorerShowRelativePath
-    call s:RebuildBufferList()
-    call s:UpdateHelpStatus()
-endfunction
-
-" ToggleShowTabBuffer {{{2
-function! s:ToggleShowTabBuffer()
-    let g:bufExplorerShowTabBuffer = !g:bufExplorerShowTabBuffer
-    call s:RebuildBufferList(g:bufExplorerShowTabBuffer)
-    call s:UpdateHelpStatus()
-endfunction
-
-" ToggleOnlyOneTab {{{2
-function! s:ToggleOnlyOneTab()
-    let g:bufExplorerOnlyOneTab = !g:bufExplorerOnlyOneTab
-    call s:RebuildBufferList()
-    call s:UpdateHelpStatus()
-endfunction
-
-" ToggleShowUnlisted {{{2
-function! s:ToggleShowUnlisted()
-    let g:bufExplorerShowUnlisted = !g:bufExplorerShowUnlisted
-    let num_bufs = s:RebuildBufferList(g:bufExplorerShowUnlisted == 0)
-    call s:UpdateHelpStatus()
-endfunction
-
-" ToggleFindActive {{{2
-function! s:ToggleFindActive()
-    let g:bufExplorerFindActive = !g:bufExplorerFindActive
-    call s:UpdateHelpStatus()
-endfunction
-
-" RebuildBufferList {{{2
-function! s:RebuildBufferList(...)
-    setlocal modifiable
-
-    let curPos = getpos('.')
-
-    if a:0 && a:000[0] && (line('$') >= s:firstBufferLine)
-        " Clear the list first.
-        execute "silent keepjumps ".s:firstBufferLine.',$d _'
-    endif
-
-    let num_bufs = s:BuildBufferList()
-
-    call setpos('.', curPos)
-
-    setlocal nomodifiable
-
-    return num_bufs
-endfunction
-
-" UpdateHelpStatus {{{2
-function! s:UpdateHelpStatus()
-    setlocal modifiable
-
-    let text = s:GetHelpStatus()
-    call setline(s:firstBufferLine - 2, text)
-
-    setlocal nomodifiable
-endfunction
-
-" MRUCmp {{{2
-function! s:MRUCmp(line1, line2)
-    return index(s:MRUList, str2nr(a:line1)) - index(s:MRUList, str2nr(a:line2))
-endfunction
-
-" SortReverse {{{2
-function! s:SortReverse()
-    let g:bufExplorerReverseSort = !g:bufExplorerReverseSort
-    call s:ReSortListing()
-endfunction
-
-" SortSelect {{{2
-function! s:SortSelect()
-    let g:bufExplorerSortBy = get(s:sort_by, index(s:sort_by, g:bufExplorerSortBy) + 1, s:sort_by[0])
-    call s:ReSortListing()
-endfunction
-
-" ReverseSortSelect {{{2
-function! s:ReverseSortSelect()
-    let g:bufExplorerSortBy = get(s:sort_by, index(s:sort_by, g:bufExplorerSortBy) - 1, s:sort_by[-1])
-    call s:ReSortListing()
-endfunction
-
-" ReSortListing {{{2
-function! s:ReSortListing()
-    setlocal modifiable
-
-    let curPos = getpos('.')
-
-    call s:SortListing()
-    call s:UpdateHelpStatus()
-
-    call setpos('.', curPos)
-
-    setlocal nomodifiable
-endfunction
-
-" SortListing {{{2
-function! s:SortListing()
-    let sort = s:firstBufferLine.",$sort".((g:bufExplorerReverseSort == 1) ? "!": "")
-
-    if g:bufExplorerSortBy == "number"
-        " Easiest case.
-        execute sort 'n'
-    elseif g:bufExplorerSortBy == "name"
-        " Sort by full path first
-        execute sort 'ir /\zs\f\+\ze\s\+line/'
-
-        if g:bufExplorerSplitOutPathName
-            execute sort 'ir /\d.\{7}\zs\f\+\ze/'
-        else
-            execute sort 'ir /\zs[^\/\\]\+\ze\s*line/'
-        endif
-    elseif g:bufExplorerSortBy == "fullpath"
-        if g:bufExplorerSplitOutPathName
-            " Sort twice - first on the file name then on the path.
-            execute sort 'ir /\d.\{7}\zs\f\+\ze/'
-        endif
-
-        execute sort 'ir /\zs\f\+\ze\s\+line/'
-    elseif g:bufExplorerSortBy == "extension"
-        " Sort by full path...
-        execute sort 'ir /\zs\f\+\ze\s\+line/'
-
-        " Sort by name...
-        if g:bufExplorerSplitOutPathName
-            " Sort twice - first on the file name then on the path.
-            execute sort 'ir /\d.\{7}\zs\f\+\ze/'
-        endif
-
-        " Sort by extension.
-        execute sort 'ir /\.\zs\w\+\ze\s/'
-    elseif g:bufExplorerSortBy == "mru"
-        let l = getline(s:firstBufferLine, "$")
-
-        call sort(l, "<SID>MRUCmp")
-
-        if g:bufExplorerReverseSort
-            call reverse(l)
-        endif
-
-        call setline(s:firstBufferLine, l)
-    endif
-endfunction
-
-" MRUListShow {{{2
-function! s:MRUListShow()
-    echomsg "MRUList=".string(s:MRUList)
-endfunction
-
-" Error {{{2
-" Display a message using ErrorMsg highlight group.
-function! s:Error(msg)
-    echohl ErrorMsg
-    echomsg a:msg
-    echohl None
-endfunction
-
-" Warning {{{2
-" Display a message using WarningMsg highlight group.
-function! s:Warning(msg)
-    echohl WarningMsg
-    echomsg a:msg
-    echohl None
-endfunction
-
-" GetTabNbr {{{2
-function! s:GetTabNbr(bufNbr)
-    " Searching buffer bufno, in tabs.
-    for i in range(tabpagenr("$"))
-        if index(tabpagebuflist(i + 1), a:bufNbr) != -1
-            return i + 1
-        endif
-    endfor
-
-    return 0
-endfunction
-
-" GetWinNbr" {{{2
-function! s:GetWinNbr(tabNbr, bufNbr)
-    " window number in tabpage.
-    let tablist = tabpagebuflist(a:tabNbr)
-    " Number:     0
-    " String:     1
-    " Funcref:    2
-    " List:       3
-    " Dictionary: 4
-    " Float:      5
-    if type(tablist) == 3
-        return index(tabpagebuflist(a:tabNbr), a:bufNbr) + 1
-    else
-        return 1
-    endif
-endfunction
-
-" StringWidth" {{{2
-if exists('*strwidth')
-    function s:StringWidth(s)
-        return strwidth(a:s)
-    endfunction
-else
-    function s:StringWidth(s)
-        return len(a:s)
-    endfunction
-endif
-
-" Winmanager Integration {{{2
-let g:BufExplorer_title = "\[Buf\ List\]"
-call s:Set("g:bufExplorerResize", 1)
-call s:Set("g:bufExplorerMaxHeight", 25) " Handles dynamic resizing of the window.
-
-" function! to start display. Set the mode to 'winmanager' for this buffer.
-" This is to figure out how this plugin was called. In a standalone fashion
-" or by winmanager.
-function! BufExplorer_Start()
-    let b:displayMode = "winmanager"
-    call s:SetLocalSettings()
-    call BufExplorer()
-endfunction
-
-" Returns whether the display is okay or not.
-function! BufExplorer_IsValid()
-    return 0
-endfunction
-
-" Handles dynamic refreshing of the window.
-function! BufExplorer_Refresh()
-    let b:displayMode = "winmanager"
-    call s:SetLocalSettings()
-    call BufExplorer()
-endfunction
-
-function! BufExplorer_ReSize()
-    if !g:bufExplorerResize
-        return
-    end
-
-    let nlines = min([line("$"), g:bufExplorerMaxHeight])
-
-    execute nlines." wincmd _"
-
-    " The following lines restore the layout so that the last file line is also
-    " the last window line. Sometimes, when a line is deleted, although the
-    " window size is exactly equal to the number of lines in the file, some of
-    " the lines are pushed up and we see some lagging '~'s.
-    let pres = getpos(".")
-
-    normal! $
-
-    let _scr = &scrolloff
-    let &scrolloff = 0
-
-    normal! z-
-
-    let &scrolloff = _scr
-
-    call setpos(".", pres)
-endfunction
-
-" Default values {{{2
-call s:Set("g:bufExplorerDisableDefaultKeyMapping", 0)  " Do not disable default key mappings.
-call s:Set("g:bufExplorerDefaultHelp", 1)               " Show default help?
-call s:Set("g:bufExplorerDetailedHelp", 0)              " Show detailed help?
-call s:Set("g:bufExplorerFindActive", 1)                " When selecting an active buffer, take you to the window where it is active?
-call s:Set("g:bufExplorerOnlyOneTab", 1)                " If ShowTabBuffer = 1, only store the most recent tab for this buffer.
-call s:Set("g:bufExplorerReverseSort", 0)               " Sort in reverse order by default?
-call s:Set("g:bufExplorerShowDirectories", 1)           " (Dir's are added by commands like ':e .')
-call s:Set("g:bufExplorerShowRelativePath", 0)          " Show listings with relative or absolute paths?
-call s:Set("g:bufExplorerShowTabBuffer", 0)             " Show only buffer(s) for this tab?
-call s:Set("g:bufExplorerShowUnlisted", 0)              " Show unlisted buffers?
-call s:Set("g:bufExplorerShowNoName", 0)                " Show 'No Name' buffers?
-call s:Set("g:bufExplorerSortBy", "mru")                " Sorting methods are in s:sort_by:
-call s:Set("g:bufExplorerSplitBelow", &splitbelow)      " Should horizontal splits be below or above current window?
-call s:Set("g:bufExplorerSplitOutPathName", 1)          " Split out path and file name?
-call s:Set("g:bufExplorerSplitRight", &splitright)      " Should vertical splits be on the right or left of current window?
-call s:Set("g:bufExplorerSplitVertSize", 0)             " Height for a vertical split. If <=0, default Vim size is used.
-call s:Set("g:bufExplorerSplitHorzSize", 0)             " Height for a horizontal split. If <=0, default Vim size is used.
-
-" Default key mapping {{{2
-if !hasmapto('BufExplorer') && g:bufExplorerDisableDefaultKeyMapping == 0
-    nnoremap <script> <silent> <unique> <Leader>be :BufExplorer<CR>
-endif
-
-if !hasmapto('ToggleBufExplorer') && g:bufExplorerDisableDefaultKeyMapping == 0
-    nnoremap <script> <silent> <unique> <Leader>bt :ToggleBufExplorer<CR>
-endif
-
-if !hasmapto('BufExplorerHorizontalSplit') && g:bufExplorerDisableDefaultKeyMapping == 0
-    nnoremap <script> <silent> <unique> <Leader>bs :BufExplorerHorizontalSplit<CR>
-endif
-
-if !hasmapto('BufExplorerVerticalSplit') && g:bufExplorerDisableDefaultKeyMapping == 0
-    nnoremap <script> <silent> <unique> <Leader>bv :BufExplorerVerticalSplit<CR>
-endif
-
-" vim:ft=vim foldmethod=marker sw=4
diff --git a/sources_non_forked/ctrlp.vim/.gitignore b/sources_non_forked/ctrlp.vim/.gitignore
deleted file mode 100644
index 3dc7cfe..0000000
--- a/sources_non_forked/ctrlp.vim/.gitignore
+++ /dev/null
@@ -1,7 +0,0 @@
-*.markdown
-*.zip
-note.txt
-tags
-tags-cn
-.hg*
-tmp/*
diff --git a/sources_non_forked/ctrlp.vim/LICENSE b/sources_non_forked/ctrlp.vim/LICENSE
deleted file mode 100644
index 84aaf41..0000000
--- a/sources_non_forked/ctrlp.vim/LICENSE
+++ /dev/null
@@ -1,30 +0,0 @@
-VIM LICENSE
-
-I) There are no restrictions on distributing unmodified copies of Vim except that they must include this license text. You can also distribute unmodified parts of Vim, likewise unrestricted except that they must include this license text. You are also allowed to include executables that you made from the unmodified Vim sources, plus your own usage examples and Vim scripts.
-
-II) It is allowed to distribute a modified (or extended) version of Vim, including executables and/or source code, when the following four conditions are met:
-
-     1) This license text must be included unmodified.
-
-     2) The modified Vim must be distributed in one of the following five ways:
-
-          a) If you make changes to Vim yourself, you must clearly describe in the distribution how to contact you. When the maintainer asks you (in any way) for a copy of the modified Vim you distributed, you must make your changes, including source code, available to the maintainer without fee. The maintainer reserves the right to include your changes in the official version of Vim. What the maintainer will do with your changes and under what license they will be distributed is negotiable. If there has been no negotiation then this license, or a later version, also applies to your changes. The current maintainer is Bram Moolenaar <Bram@vim.org>. If this changes it will be announced in appropriate places (most likely vim.sf.net, www.vim.org and/or comp.editors). When it is completely impossible to contact the maintainer, the obligation to send him your changes ceases. Once the maintainer has confirmed that he has received your changes they will not have to be sent again.
-
-          b) If you have received a modified Vim that was distributed as mentioned under a) you are allowed to further distribute it unmodified, as mentioned at I). If you make additional changes the text under a) applies to those changes.
-
-          c) Provide all the changes, including source code, with every copy of the modified Vim you distribute. This may be done in the form of a context diff. You can choose what license to use for new code you add. The changes and their license must not restrict others from making their own changes to the official version of Vim.
-
-          d) When you have a modified Vim which includes changes as mentioned under c), you can distribute it without the source code for the changes if the following three conditions are met:
-          - The license that applies to the changes permits you to distribute the changes to the Vim maintainer without fee or restriction, and permits the Vim maintainer to include the changes in the official version of Vim without fee or restriction.
-          - You keep the changes for at least three years after last distributing the corresponding modified Vim. When the maintainer or someone who you distributed the modified Vim to asks you (in any way) for the changes within this period, you must make them available to him.
-          - You clearly describe in the distribution how to contact you. This contact information must remain valid for at least three years after last distributing the corresponding modified Vim, or as long as possible.
-
-          e) When the GNU General Public License (GPL) applies to the changes, you can distribute the modified Vim under the GNU GPL version 2 or any later version.
-
-     3) A message must be added, at least in the output of the ":version" command and in the intro screen, such that the user of the modified Vim is able to see that it was modified. When distributing as mentioned under 2)e) adding the message is only required for as far as this does not conflict with the license used for the changes.
-
-     4) The contact information as required under 2)a) and 2)d) must not be removed or changed, except that the person himself can make corrections.
-
-III) If you distribute a modified version of Vim, you are encouraged to use the Vim license for your changes and make them available to the maintainer, including the source code. The preferred way to do this is by e-mail or by uploading the files to a server and e-mailing the URL. If the number of changes is small (e.g., a modified Makefile) e-mailing a context diff will do. The e-mail address to be used is <maintainer@vim.org>
-
-IV) It is not allowed to remove this license from the distribution of the Vim sources, parts of it or from a modified version. You may use this license for previous Vim releases instead of the license that they came with, at your option.
diff --git a/sources_non_forked/ctrlp.vim/autoload/ctrlp.vim b/sources_non_forked/ctrlp.vim/autoload/ctrlp.vim
deleted file mode 100644
index 828a8c8..0000000
--- a/sources_non_forked/ctrlp.vim/autoload/ctrlp.vim
+++ /dev/null
@@ -1,2784 +0,0 @@
-" =============================================================================
-" File:          autoload/ctrlp.vim
-" Description:   Fuzzy file, buffer, mru, tag, etc finder.
-" Author:        CtrlP Dev Team
-" Original:      Kien Nguyen <github.com/kien>
-" Version:       1.80
-" =============================================================================
-
-" ** Static variables {{{1
-" s:ignore() {{{2
-fu! s:ignore()
-	let igdirs = [
-		\ '\.git',
-		\ '\.hg',
-		\ '\.svn',
-		\ '_darcs',
-		\ '\.bzr',
-		\ '\.cdv',
-		\ '\~\.dep',
-		\ '\~\.dot',
-		\ '\~\.nib',
-		\ '\~\.plst',
-		\ '\.pc',
-		\ '_MTN',
-		\ 'blib',
-		\ 'CVS',
-		\ 'RCS',
-		\ 'SCCS',
-		\ '_sgbak',
-		\ 'autom4te\.cache',
-		\ 'cover_db',
-		\ '_build',
-		\ ]
-	let igfiles = [
-		\ '\~$',
-		\ '#.+#$',
-		\ '[._].*\.swp$',
-		\ 'core\.\d+$',
-		\ '\.exe$',
-		\ '\.so$',
-		\ '\.bak$',
-		\ '\.png$',
-		\ '\.jpg$',
-		\ '\.gif$',
-		\ '\.zip$',
-		\ '\.rar$',
-		\ '\.tar\.gz$',
-		\ ]
-	retu {
-		\ 'dir': '\v[\/]('.join(igdirs, '|').')$',
-		\ 'file': '\v'.join(igfiles, '|'),
-		\ }
-endf
-" Script local vars {{{2
-let [s:pref, s:bpref, s:opts, s:new_opts, s:lc_opts] =
-	\ ['g:ctrlp_', 'b:ctrlp_', {
-	\ 'abbrev':                ['s:abbrev', {}],
-	\ 'arg_map':               ['s:argmap', 0],
-	\ 'buffer_func':           ['s:buffunc', {}],
-	\ 'by_filename':           ['s:byfname', 0],
-	\ 'custom_ignore':         ['s:usrign', s:ignore()],
-	\ 'default_input':         ['s:deftxt', 0],
-	\ 'dont_split':            ['s:nosplit', 'netrw'],
-	\ 'dotfiles':              ['s:showhidden', 0],
-	\ 'extensions':            ['s:extensions', []],
-	\ 'follow_symlinks':       ['s:folsym', 0],
-	\ 'highlight_match':       ['s:mathi', [1, 'CtrlPMatch']],
-	\ 'jump_to_buffer':        ['s:jmptobuf', 'Et'],
-	\ 'key_loop':              ['s:keyloop', 0],
-	\ 'lazy_update':           ['s:lazy', 0],
-	\ 'match_func':            ['s:matcher', {}],
-	\ 'match_window':          ['s:mw', ''],
-	\ 'match_window_bottom':   ['s:mwbottom', 1],
-	\ 'match_window_reversed': ['s:mwreverse', 1],
-	\ 'max_depth':             ['s:maxdepth', 40],
-	\ 'max_files':             ['s:maxfiles', 10000],
-	\ 'max_height':            ['s:mxheight', 10],
-	\ 'max_history':           ['s:maxhst', exists('+hi') ? &hi : 20],
-	\ 'mruf_default_order':    ['s:mrudef', 0],
-	\ 'open_func':             ['s:openfunc', {}],
-	\ 'open_multi':            ['s:opmul', '1v'],
-	\ 'open_new_file':         ['s:newfop', 'v'],
-	\ 'prompt_mappings':       ['s:urprtmaps', 0],
-	\ 'regexp_search':         ['s:regexp', 0],
-	\ 'root_markers':          ['s:rmarkers', []],
-	\ 'split_window':          ['s:splitwin', 0],
-	\ 'status_func':           ['s:status', {}],
-	\ 'tabpage_position':      ['s:tabpage', 'ac'],
-	\ 'use_caching':           ['s:caching', 1],
-	\ 'user_command':          ['s:usrcmd', ''],
-	\ 'validate':              ['s:validate', ''],
-	\ 'working_path_mode':     ['s:pathmode', 'ra'],
-	\ 'line_prefix':           ['s:lineprefix', '> '],
-	\ 'open_single_match':     ['s:opensingle', []],
-	\ 'brief_prompt':          ['s:brfprt', 0],
-	\ 'match_current_file':    ['s:matchcrfile', 0],
-	\ 'match_natural_name':    ['s:matchnatural', 0],
-	\ 'compare_lim':           ['s:compare_lim', 3000],
-	\ 'bufname_mod':           ['s:bufname_mod', ':t'],
-	\ 'bufpath_mod':           ['s:bufpath_mod', ':~:.:h'],
-	\ 'formatline_func':       ['s:flfunc', 's:formatline(v:val)'],
-	\ 'user_command_async':    ['s:usrcmdasync', 0],
-	\ }, {
-	\ 'open_multiple_files':   's:opmul',
-	\ 'regexp':                's:regexp',
-	\ 'reuse_window':          's:nosplit',
-	\ 'show_hidden':           's:showhidden',
-	\ 'switch_buffer':         's:jmptobuf',
-	\ }, {
-	\ 'root_markers':          's:rmarkers',
-	\ 'user_command':          's:usrcmd',
-	\ 'working_path_mode':     's:pathmode',
-	\ }]
-
-" Global options
-let s:glbs = { 'magic': 1, 'to': 1, 'tm': 0, 'sb': 1, 'hls': 0, 'im': 0,
-	\ 'report': 9999, 'sc': 0, 'ss': 0, 'siso': 0, 'mfd': 200, 'ttimeout': 0,
-	\ 'gcr': 'a:blinkon0', 'ic': 1, 'lmap': '', 'mousef': 0, 'imd': 1 }
-
-" Keymaps
-let [s:lcmap, s:prtmaps] = ['nn <buffer> <silent>', {
-	\ 'PrtBS()':              ['<bs>', '<c-]>'],
-	\ 'PrtDelete()':          ['<del>'],
-	\ 'PrtDeleteWord()':      ['<c-w>'],
-	\ 'PrtClear()':           ['<c-u>'],
-	\ 'PrtSelectMove("j")':   ['<c-j>', '<down>'],
-	\ 'PrtSelectMove("k")':   ['<c-k>', '<up>'],
-	\ 'PrtSelectMove("t")':   ['<Home>', '<kHome>'],
-	\ 'PrtSelectMove("b")':   ['<End>', '<kEnd>'],
-	\ 'PrtSelectMove("u")':   ['<PageUp>', '<kPageUp>'],
-	\ 'PrtSelectMove("d")':   ['<PageDown>', '<kPageDown>'],
-	\ 'PrtHistory(-1)':       ['<c-n>'],
-	\ 'PrtHistory(1)':        ['<c-p>'],
-	\ 'AcceptSelection("e")': ['<cr>', '<2-LeftMouse>'],
-	\ 'AcceptSelection("h")': ['<c-x>', '<c-cr>', '<c-s>'],
-	\ 'AcceptSelection("t")': ['<c-t>'],
-	\ 'AcceptSelection("v")': ['<c-v>', '<RightMouse>'],
-	\ 'ToggleFocus()':        ['<s-tab>'],
-	\ 'ToggleRegex()':        ['<c-r>'],
-	\ 'ToggleByFname()':      ['<c-d>'],
-	\ 'ToggleType(1)':        ['<c-f>', '<c-up>'],
-	\ 'ToggleType(-1)':       ['<c-b>', '<c-down>'],
-	\ 'PrtExpandDir()':       ['<tab>'],
-	\ 'PrtInsert("c")':       ['<MiddleMouse>', '<insert>'],
-	\ 'PrtInsert()':          ['<c-\>'],
-	\ 'PrtCurStart()':        ['<c-a>'],
-	\ 'PrtCurEnd()':          ['<c-e>'],
-	\ 'PrtCurLeft()':         ['<c-h>', '<left>', '<c-^>'],
-	\ 'PrtCurRight()':        ['<c-l>', '<right>'],
-	\ 'PrtClearCache()':      ['<F5>'],
-	\ 'PrtDeleteEnt()':       ['<F7>'],
-	\ 'CreateNewFile()':      ['<c-y>'],
-	\ 'MarkToOpen()':         ['<c-z>'],
-	\ 'OpenMulti()':          ['<c-o>'],
-	\ 'YankLine()':           [],
-	\ 'PrtExit()':            ['<esc>', '<c-c>', '<c-g>'],
-	\ }]
-
-if !has('gui_running')
-	cal add(s:prtmaps['PrtBS()'], remove(s:prtmaps['PrtCurLeft()'], 0))
-en
-
-let s:ficounts = {}
-
-let s:ccex = s:pref.'clear_cache_on_exit'
-
-" Regexp
-let s:fpats = {
-	\ '^\(\\|\)\|\(\\|\)$': '\\|',
-	\ '^\\\(zs\|ze\|<\|>\)': '^\\\(zs\|ze\|<\|>\)',
-	\ '^\S\*$': '\*',
-	\ '^\S\\?$': '\\?',
-	\ }
-
-let s:has_conceal = has('conceal')
-let s:bufnr_width = 3
-
-" Keypad
-let s:kprange = {
-	\ 'Plus': '+',
-	\ 'Minus': '-',
-	\ 'Divide': '/',
-	\ 'Multiply': '*',
-	\ 'Point': '.',
-	\ }
-
-" Highlight groups
-let s:hlgrps = {
-	\ 'NoEntries': 'Error',
-	\ 'Mode1': 'Character',
-	\ 'Mode2': 'LineNr',
-	\ 'Stats': 'Function',
-	\ 'Match': 'Identifier',
-	\ 'PrtBase': 'Comment',
-	\ 'PrtText': 'Normal',
-	\ 'PrtCursor': 'Constant',
-	\ 'BufferNr':      'Constant',
-	\ 'BufferInd':     'Normal',
-	\ 'BufferHid':     'Comment',
-	\ 'BufferHidMod':  'String',
-	\ 'BufferVis':     'Normal',
-	\ 'BufferVisMod':  'Identifier',
-	\ 'BufferCur':     'Question',
-	\ 'BufferCurMod':  'WarningMsg',
-	\ 'BufferPath':    'Comment',
-	\ }
-
-" lname, sname of the basic(non-extension) modes
-let s:types = ['fil', 'buf', 'mru']
-if !exists('g:ctrlp_types')
-	let g:ctrlp_types = s:types
-el
-	call filter(g:ctrlp_types, "index(['fil', 'buf', 'mru'], v:val)!=-1")
-en
-let g:ctrlp_builtins = len(g:ctrlp_types)-1
-
-let s:coretype_names = {
-	\ 'fil' : 'files',
-	\ 'buf' : 'buffers',
-	\ 'mru' : 'mru files',
-	\ }
-
-let s:coretypes = map(copy(g:ctrlp_types), '[s:coretype_names[v:val], v:val]')
-
-" Get the options {{{2
-fu! s:opts(...)
-	unl! s:usrign s:usrcmd s:urprtmaps
-	for each in ['byfname', 'regexp', 'extensions'] | if exists('s:'.each)
-		let {each} = s:{each}
-	en | endfo
-	for [ke, va] in items(s:opts)
-		let {va[0]} = exists(s:pref.ke) ? {s:pref.ke} : va[1]
-	endfo
-	unl va
-	for [ke, va] in items(s:new_opts)
-		let {va} = {exists(s:pref.ke) ? s:pref.ke : va}
-	endfo
-	unl va
-	for [ke, va] in items(s:lc_opts)
-		if exists(s:bpref.ke)
-			unl {va}
-			let {va} = {s:bpref.ke}
-		en
-	endfo
-	" Match window options
-	cal s:match_window_opts()
-	" One-time values
-	if a:0 && a:1 != {}
-		unl va
-		for [ke, va] in items(a:1)
-			let opke = substitute(ke, '\(\w:\)\?ctrlp_', '', '')
-			if has_key(s:lc_opts, opke)
-				let sva = s:lc_opts[opke]
-				unl {sva}
-				let {sva} = va
-			en
-		endfo
-	en
-	for each in ['byfname', 'regexp'] | if exists(each)
-		let s:{each} = {each}
-	en | endfo
-	if !exists('g:ctrlp_tilde_homedir') | let g:ctrlp_tilde_homedir = 0 | en
-	if !exists('g:ctrlp_newcache') | let g:ctrlp_newcache = 0 | en
-	let s:maxdepth = min([s:maxdepth, 100])
-	let s:glob = s:showhidden ? '.*\|*' : '*'
-	let s:igntype = empty(s:usrign) ? -1 : type(s:usrign)
-	let s:lash = ctrlp#utils#lash()
-	if s:keyloop
-		let [s:lazy, s:glbs['imd']] = [0, 0]
-	en
-	if s:lazy
-		cal extend(s:glbs, { 'ut': ( s:lazy > 1 ? s:lazy : 250 ) })
-	en
-	" Extensions
-	if !( exists('extensions') && extensions == s:extensions )
-		for each in s:extensions
-			exe 'ru autoload/ctrlp/'.each.'.vim'
-		endfo
-	en
-	" Keymaps
-	if type(s:urprtmaps) == 4
-		cal extend(s:prtmaps, s:urprtmaps)
-	en
-endf
-
-fu! s:match_window_opts()
-	let s:mw_pos =
-		\ s:mw =~ 'top\|bottom' ? matchstr(s:mw, 'top\|bottom') :
-		\ exists('g:ctrlp_match_window_bottom') ? ( s:mwbottom ? 'bottom' : 'top' )
-		\ : 'bottom'
-	let s:mw_order =
-		\ s:mw =~ 'order:[^,]\+' ? matchstr(s:mw, 'order:\zs[^,]\+') :
-		\ exists('g:ctrlp_match_window_reversed') ? ( s:mwreverse ? 'btt' : 'ttb' )
-		\ : 'btt'
-	let s:mw_max =
-		\ s:mw =~ 'max:[^,]\+' ? str2nr(matchstr(s:mw, 'max:\zs\d\+')) :
-		\ exists('g:ctrlp_max_height') ? s:mxheight
-		\ : 10
-	let s:mw_min =
-		\ s:mw =~ 'min:[^,]\+' ? str2nr(matchstr(s:mw, 'min:\zs\d\+')) : 1
-	let [s:mw_max, s:mw_min] = [max([s:mw_max, 1]), max([s:mw_min, 1])]
-	let s:mw_min = min([s:mw_min, s:mw_max])
-	let s:mw_res =
-		\ s:mw =~ 'results:[^,]\+' ? str2nr(matchstr(s:mw, 'results:\zs\d\+'))
-		\ : min([s:mw_max, &lines])
-endf
-"}}}1
-" * Open & Close {{{1
-fu! s:Open()
-	cal s:log(1)
-	cal s:getenv()
-	cal s:execextvar('enter')
-	sil! exe 'keepa' ( s:mw_pos == 'top' ? 'to' : 'bo' ) '1new ControlP'
-	cal s:buffunc(1)
-	let [s:bufnr, s:winw] = [bufnr('%'), winwidth(0)]
-	let [s:focus, s:prompt] = [1, ['', '', '']]
-	abc <buffer>
-	if !exists('s:hstry')
-		let hst = filereadable(s:gethistloc()[1]) ? s:gethistdata() : ['']
-		let s:hstry = empty(hst) || !s:maxhst ? [''] : hst
-	en
-	for [ke, va] in items(s:glbs) | if exists('+'.ke)
-		sil! exe 'let s:glb_'.ke.' = &'.ke.' | let &'.ke.' = '.string(va)
-	en | endfo
-	if s:opmul != '0' && has('signs')
-		sign define ctrlpmark text=+> texthl=CtrlPMark
-		hi def link CtrlPMark Search
-	en
-	cal s:setupblank()
-endf
-
-fu! s:Close()
-	cal s:async_glob_abort()
-	cal s:buffunc(0)
-	if winnr('$') == 1
-		bw!
-	el
-		try | bun!
-		cat | clo! | endt
-		cal s:unmarksigns()
-	en
-	for key in keys(s:glbs) | if exists('+'.key)
-		sil! exe 'let &'.key.' = s:glb_'.key
-	en | endfo
-	if exists('s:glb_acd') | let &acd = s:glb_acd | en
-	let g:ctrlp_lines = []
-	if s:winres[1] >= &lines && s:winres[2] == winnr('$')
-		exe s:winres[0].s:winres[0]
-	en
-	unl! s:focus s:hisidx s:hstgot s:marked s:statypes s:init s:savestr
-		\ s:mrbs s:did_exp
-	cal ctrlp#recordhist()
-	cal s:execextvar('exit')
-	cal s:log(0)
-	let v:errmsg = s:ermsg
-	ec
-endf
-" * Clear caches {{{1
-fu! ctrlp#clr(...)
-	let [s:matches, g:ctrlp_new{ a:0 ? a:1 : 'cache' }] = [1, 1]
-endf
-
-fu! ctrlp#clra()
-	let cadir = ctrlp#utils#cachedir()
-	if isdirectory(cadir)
-		let cafiles = split(s:glbpath(s:fnesc(cadir, 'g', ','), '**', 1), "\n")
-		let eval = '!isdirectory(v:val) && v:val !~ ''\v[\/]cache[.a-z]+$|\.log$'''
-		sil! cal map(s:ifilter(cafiles, eval), 'delete(v:val)')
-	en
-	cal ctrlp#clr()
-endf
-
-fu! s:Reset(args)
-	let opts = has_key(a:args, 'opts') ? [a:args['opts']] : []
-	cal call('s:opts', opts)
-	cal s:autocmds()
-	cal ctrlp#utils#opts()
-	cal s:execextvar('opts')
-endf
-" * Files {{{1
-fu! ctrlp#files()
-	let cafile = ctrlp#utils#cachefile()
-	if g:ctrlp_newcache || !filereadable(cafile) || s:nocache(cafile)
-		let [lscmd, s:initcwd, g:ctrlp_allfiles] = [s:lsCmd(), s:dyncwd, []]
-		" Get the list of files
-		if empty(lscmd)
-			if !ctrlp#igncwd(s:dyncwd)
-				cal s:InitCustomFuncs()
-				cal s:GlobPath(s:fnesc(s:dyncwd, 'g', ','), 0)
-				cal s:CloseCustomFuncs()
-			en
-		el
-			sil! cal ctrlp#progress('Indexing...')
-			try | cal s:UserCmd(lscmd)
-			cat | retu [] | endt
-		en
-		" Remove base directory
-		cal ctrlp#rmbasedir(g:ctrlp_allfiles)
-		if len(g:ctrlp_allfiles) <= s:compare_lim
-			cal sort(g:ctrlp_allfiles, 'ctrlp#complen')
-		en
-		cal s:writecache(cafile)
-		let catime = getftime(cafile)
-	el
-		let catime = getftime(cafile)
-		if !( exists('s:initcwd') && s:initcwd == s:dyncwd )
-			\ || get(s:ficounts, s:dyncwd, [0, catime])[1] != catime
-			let s:initcwd = s:dyncwd
-			let g:ctrlp_allfiles = ctrlp#utils#readfile(cafile)
-		en
-	en
-	cal extend(s:ficounts, { s:dyncwd : [len(g:ctrlp_allfiles), catime] })
-	retu g:ctrlp_allfiles
-endf
-
-fu! s:InitCustomFuncs()
-	if s:igntype == 4 && has_key(s:usrign, 'func-init') && s:usrign['func-init'] != ''
-		exe call(s:usrign['func-init'], [])
-	en
-endf
-
-fu! s:CloseCustomFuncs()
-	if s:igntype == 4 && has_key(s:usrign, 'func-close') && s:usrign['func-close'] != ''
-		exe call(s:usrign['func-close'], [])
-	en
-endf
-
-fu! s:GlobPath(dirs, depth)
-	let entries = split(globpath(a:dirs, s:glob), "\n")
-	let [dnf, depth] = [ctrlp#dirnfile(entries), a:depth + 1]
-	cal extend(g:ctrlp_allfiles, dnf[1])
-	if !empty(dnf[0]) && !s:maxf(len(g:ctrlp_allfiles)) && depth <= s:maxdepth
-		sil! cal ctrlp#progress(len(g:ctrlp_allfiles), 1)
-		cal s:GlobPath(join(map(dnf[0], 's:fnesc(v:val, "g", ",")'), ','), depth)
-	en
-endf
-
-fu! s:async_glob_update_progress(timer)
-	let s:must_wait = 0
-	if exists('s:focus') && get(s:, 'setlines_post_ended', 0)
-		cal s:ForceUpdate()
-	en
-	if exists('s:timer')
-		sil! cal ctrlp#statusline()
-	endif
-
-	if !exists('s:job')
-		call s:stop_timer_if_exists()
-	endif
-endf
-
-fu! s:async_glob_on_stdout(job, data, ...)
-	if type(a:data) ==# type([])
-		call extend(g:ctrlp_allfiles, filter(a:data, 'v:val !=# ""'))
-	else
-		call add(g:ctrlp_allfiles, a:data)
-	endif
-endf
-
-fu! s:async_glob_on_exit(...)
-	let s:must_wait = 0
-	if exists('s:job')
-		unlet s:job
-	endif
-	cal s:stop_timer_if_exists()
-	if exists('s:focus') && get(s:, 'setlines_post_ended', 0)
-		sil! cal ctrlp#statusline()
-		cal s:ForceUpdate()
-	en
-endf
-
-fu! s:async_glob_abort()
-	cal s:stop_job_if_exists()
-	cal s:stop_timer_if_exists()
-	cal s:ForceUpdate()
-endf
-
-fu! s:stop_timer_if_exists()
-	if exists('s:timer')
-		call timer_stop(s:timer)
-		unlet s:timer
-	en
-endf
-
-fu! s:stop_job_if_exists()
-	if exists('s:job')
-		if !has('nvim')
-			cal job_stop(s:job)
-		else
-			cal jobstop(s:job)
-		endif
-		unlet s:job
-	en
-endf
-
-fu! s:safe_printf(format, ...)
-	try
-		retu call('printf', [a:format] + a:000)
-	cat
-		retu a:format
-	endt
-endf
-
-fu! s:UserCmd(lscmd)
-	let [path, lscmd] = [s:dyncwd, a:lscmd]
-	let do_ign =
-		\ type(s:usrcmd) == 4 && has_key(s:usrcmd, 'ignore') && s:usrcmd['ignore']
-	if do_ign && ctrlp#igncwd(s:cwd) | retu | en
-	if exists('+ssl') && &ssl && &shell !~ 'sh'
-		let [ssl, &ssl, path] = [&ssl, 0, tr(path, '/', '\')]
-	en
-	if (has('win32') || has('win64')) && match(&shellcmdflag, "/") != -1
-		let lscmd = substitute(lscmd, '\v(^|\&\&\s*)\zscd (/d)@!', 'cd /d ', '')
-	en
-	let path = exists('*shellescape') ? shellescape(path) : path
-	if (has('win32') || has('win64')) && match(&shell, 'sh') != -1
-		let path = tr(path, '\', '/')
-	en
-	if s:usrcmdasync && (v:version >= 800 || has('nvim')) && (exists('*job_start') || exists('*jobstart'))
-		cal s:stop_job_if_exists()
-		let g:ctrlp_allfiles = []
-		let s:must_wait = 1
-		let argv = [&shell, &shellcmdflag, printf(lscmd, path)]
-		if !has('nvim')
-			let s:job = job_start(argv, {
-						\ 'out_cb': function('s:async_glob_on_stdout'), 
-						\ 'exit_cb': function('s:async_glob_on_exit')
-						\ })
-		else
-			let s:job = jobstart(argv, {
-						\ 'on_stdout': function('s:async_glob_on_stdout'),
-						\ 'on_exit': function('s:async_glob_on_exit')
-						\ })
-		endif
-		let s:timer = timer_start(250, function('s:async_glob_update_progress'), {'repeat': -1})
-		while s:must_wait
-			sleep 50m
-		endwhile
-	elsei has('patch-7.4-597') && !(has('win32') || has('win64'))
-		let g:ctrlp_allfiles = systemlist(s:safe_printf(lscmd, path))
-	el
-		let g:ctrlp_allfiles = split(system(s:safe_printf(lscmd, path)), "\n")
-	en
-	if exists('+ssl') && exists('ssl')
-		let &ssl = ssl
-		cal map(g:ctrlp_allfiles, 'tr(v:val, "\\", "/")')
-	en
-	if exists('s:vcscmd') && s:vcscmd
-		cal map(g:ctrlp_allfiles, 'tr(v:val, "/", "\\")')
-	en
-	if do_ign
-		if !empty(s:usrign)
-			let g:ctrlp_allfiles = ctrlp#dirnfile(g:ctrlp_allfiles)[1]
-		en
-		if &wig != ''
-			cal filter(g:ctrlp_allfiles, 'glob(v:val) != ""')
-		en
-	en
-endf
-
-fu! s:lsCmd()
-	let cmd = s:usrcmd
-	if type(cmd) == 1
-		retu cmd
-	elsei type(cmd) == 3 && len(cmd) >= 2 && cmd[:1] != ['', '']
-		if s:findroot(s:dyncwd, cmd[0], 0, 1) == []
-			retu len(cmd) == 3 ? cmd[2] : ''
-		en
-		let s:vcscmd = s:lash == '\'
-		retu cmd[1]
-	elsei type(cmd) == 4 && ( has_key(cmd, 'types') || has_key(cmd, 'fallback') )
-		let fndroot = []
-		if has_key(cmd, 'types') && cmd['types'] != {}
-			let [markrs, cmdtypes] = [[], values(cmd['types'])]
-			for pair in cmdtypes
-				cal add(markrs, pair[0])
-			endfo
-			let fndroot = s:findroot(s:dyncwd, markrs, 0, 1)
-		en
-		if fndroot == []
-			retu has_key(cmd, 'fallback') ? cmd['fallback'] : ''
-		en
-		for pair in cmdtypes
-			if pair[0] == fndroot[0] | brea | en
-		endfo
-		let s:vcscmd = s:lash == '\'
-		retu pair[1]
-	en
-endf
-" - Buffers {{{1
-fu! s:bufparts(bufnr)
-	let idc  = (a:bufnr == bufnr('#')      ? '#' : '')  " alternative
-	let idc .= (getbufvar(a:bufnr, '&mod') ? '+' : '')  " modified
-	let idc .= (getbufvar(a:bufnr, '&ma')  ? '' : '-')  " nomodifiable
-	let idc .= (getbufvar(a:bufnr, '&ro')  ? '=' : '')  " readonly
-
-	" flags for highlighting
-	let hiflags  = (bufwinnr(a:bufnr) != -1    ? '*' : '')  " visible
-	let hiflags .= (getbufvar(a:bufnr, '&mod') ? '+' : '')  " modified
-	let hiflags .= (a:bufnr == s:crbufnr       ? '!' : '')  " current
-
-	let bname = bufname(a:bufnr)
-	let bname = (bname == '' ? '[No Name]' : fnamemodify(bname, s:bufname_mod))
-
-	let bpath = empty(s:bufpath_mod) ? '' : fnamemodify(bufname(a:bufnr), s:bufpath_mod).s:lash()
-
-	retu [idc, hiflags, bname, bpath]
-endf
-fu! ctrlp#buffers(...)
-	let ids = sort(filter(range(1, bufnr('$')), '(empty(getbufvar(v:val, "&bt"))'
-		\ .' || s:isterminal(v:val)) && getbufvar(v:val, "&bl")'), 's:compmreb')
-	if a:0 && a:1 == 'id'
-		retu ids
-	el
-		let bufs = [[], []]
-		for id in ids
-			let bname = bufname(id)
-			let ebname = bname == ''
-			let fname = fnamemodify(ebname ? '['.id.'*No Name]' : bname, ':.')
-			cal add(bufs[ebname], fname)
-		endfo
-		retu bufs[0] + bufs[1]
-	en
-endf
-" * MatchedItems() {{{1
-fu! s:MatchIt(items, pat, limit, exc)
-	let [lines, id] = [[], 0]
-	let pat =
-		\ s:byfname() ? map(split(a:pat, '^[^;]\+\\\@<!\zs;', 1), 's:martcs.v:val')
-		\ : s:martcs.a:pat
-	for item in a:items
-		let id += 1
-		try
-			if (s:matchcrfile || !( s:ispath && item ==# a:exc )) &&
-						\call(s:mfunc, [item, pat]) >= 0
-				cal add(lines, item)
-			en
-		cat | brea | endt
-		if a:limit > 0 && len(lines) >= a:limit | brea | en
-	endfo
-	let s:mdata = [s:dyncwd, s:itemtype, s:regexp, s:sublist(a:items, id, -1)]
-	retu lines
-endf
-
-fu! s:MatchedItems(items, pat, limit)
-	let exc = exists('s:crfilerel') ? s:crfilerel : ''
-	let items = s:narrowable() ? s:matched + s:mdata[3] : a:items
-	let matcher = s:getextvar('matcher')
-	if empty(matcher) || type(matcher) != 4 || !has_key(matcher, 'match')
-		unlet matcher
-		let matcher = s:matcher
-	en
-	if matcher != {}
-		let argms =
-			\ has_key(matcher, 'arg_type') && matcher['arg_type'] == 'dict' ? [{
-			\ 'items':  items,
-			\ 'str':    a:pat,
-			\ 'limit':  a:limit,
-			\ 'mmode':  s:mmode(),
-			\ 'ispath': s:ispath,
-			\ 'crfile': exc,
-			\ 'regex':  s:regexp,
-			\ }] : [items, a:pat, a:limit, s:mmode(), s:ispath, exc, s:regexp]
-		let lines = call(matcher['match'], argms, matcher)
-	el
-		let lines = s:MatchIt(items, a:pat, a:limit, exc)
-	en
-	let s:matches = len(lines)
-	unl! s:did_exp
-	retu lines
-endf
-
-fu! s:SplitPattern(str)
-	let str = a:str
-	let s:savestr = str
-	if s:regexp
-		let pat = s:regexfilter(str)
-	el
-		let lst = split(str, '\zs')
-		if exists('+ssl') && !&ssl
-			cal map(lst, 'escape(v:val, ''\'')')
-		en
-		for each in ['^', '$', '.']
-			cal map(lst, 'escape(v:val, each)')
-		endfo
-	en
-	if exists('lst')
-		let pat = ''
-		if !empty(lst)
-			if s:byfname() && index(lst, ';') > 0
-				let fbar = index(lst, ';')
-				let lst_1 = s:sublist(lst, 0, fbar - 1)
-				let lst_2 = len(lst) - 1 > fbar ? s:sublist(lst, fbar + 1, -1) : ['']
-				let pat = s:buildpat(lst_1).';'.s:buildpat(lst_2)
-			el
-				let pat = s:buildpat(lst)
-			en
-		en
-	en
-	retu escape(pat, '~')
-endf
-" * BuildPrompt() {{{1
-fu! s:Render(lines, pat)
-	let [&ma, lines, s:res_count] = [1, a:lines, len(a:lines)]
-	let height = min([max([s:mw_min, s:res_count]), s:winmaxh])
-	let pat = s:byfname() ? split(a:pat, '^[^;]\+\\\@<!\zs;', 1)[0] : a:pat
-	let cur_cmd = 'keepj norm! '.( s:mw_order == 'btt' ? 'G' : 'gg' ).'1|'
-
-	" Setup the match window
-	sil! exe '%d _ | res' height
-	" Print the new items
-	if empty(lines)
-		let [s:matched, s:lines] = [[], []]
-		let lines = [' == NO ENTRIES ==']
-		cal setline(1, s:offset(lines, height - 1))
-		setl noma nocul
-		exe cur_cmd
-		cal s:unmarksigns()
-		if s:dohighlight() | cal clearmatches() | en
-		retu
-	en
-	let s:matched = copy(lines)
-	" Sorting
-	if !s:nosort()
-		let s:compat = s:martcs.pat
-		cal sort(lines, 's:mixedsort')
-		unl s:compat
-	en
-	if s:mw_order == 'btt' | cal reverse(lines) | en
-	let s:lines = copy(lines)
-	cal map(lines, s:flfunc)
-	cal setline(1, s:offset(lines, height))
-	cal s:unmarksigns()
-	cal s:remarksigns()
-	" Highlighting
-	if s:dohighlight()
-		cal s:highlight(pat, s:mathi[1])
-	en
-	setl noma cul
-	exe cur_cmd
-endf
-
-fu! s:Update(str)
-	" Get the previous string if existed
-	let oldstr = exists('s:savestr') ? s:savestr : ''
-	" Get the new string sans tail
-	let str = s:sanstail(a:str)
-	" Stop if the string's unchanged
-	if str == oldstr && !empty(str) && !exists('s:force') | retu | en
-	" Optionally send the string to a custom validate function
-	if s:validate != '' | let str = call(s:validate, [str]) | en
-	let s:martcs = &scs && str =~ '\u' ? '\C' : ''
-	let pat = s:matcher == {} ? s:SplitPattern(str) : str
-	let lines = s:nolim == 1 && empty(str) ? copy(g:ctrlp_lines)
-		\ : s:MatchedItems(g:ctrlp_lines, pat, s:mw_res)
-	if empty(str) | cal clearmatches() | en
-	cal s:Render(lines, pat)
-	return lines
-endf
-
-fu! s:ForceUpdate()
-	let pos = exists('*getcurpos') ? getcurpos() : getpos('.')
-	sil! cal s:Update(escape(s:getinput(), '\'))
-	cal setpos('.', pos)
-endf
-
-fu! s:BuildPrompt(upd)
-	let base = ( s:regexp ? 'r' : '>' ).( s:byfname() ? 'd' : '>' ).'> '
-	let str = escape(s:getinput(), '\')
-	let lazy = str == '' || exists('s:force') || !has('autocmd') ? 0 : s:lazy
-	if a:upd && !lazy && ( s:matches || s:regexp || exists('s:did_exp')
-		\ || str =~ '\(\\\(<\|>\)\|[*|]\)\|\(\\\:\([^:]\|\\:\)*$\)' )
-		sil! cal s:Update(str)
-	en
-	sil! cal ctrlp#statusline()
-	" Toggling
-	let [hiactive, hicursor, base] = s:focus
-		\ ? ['CtrlPPrtText', 'CtrlPPrtCursor', base]
-		\ : ['CtrlPPrtBase', 'CtrlPPrtBase', tr(base, '>', '-')]
-	let hibase = 'CtrlPPrtBase'
-	" Build it
-	redr
-	let prt = copy(s:prompt)
-	cal map(prt, 'escape(v:val, ''"\'')')
-	exe 'echoh' hibase '| echon "'.base.'"
-		\ | echoh' hiactive '| echon "'.prt[0].'"
-		\ | echoh' hicursor '| echon "'.prt[1].'"
-		\ | echoh' hiactive '| echon "'.prt[2].'" | echoh None'
-	" Append the cursor at the end
-	if empty(prt[1]) && s:focus
-		exe 'echoh' hibase '| echon "_" | echoh None'
-	en
-	if a:upd
-		cal s:NotifySearch()
-	en
-endf
-" - SetDefTxt() {{{1
-fu! s:SetDefTxt()
-	if s:deftxt == '0' || ( s:deftxt == 1 && !s:ispath ) | retu | en
-	let txt = s:deftxt
-	if !type(txt)
-		let path = s:crfpath.s:lash(s:crfpath)
-		let txt = txt && !stridx(path, s:dyncwd) ? ctrlp#rmbasedir([path])[0] : ''
-	en
-	let s:prompt[0] = txt
-endf
-" ** Prt Actions {{{1
-" Editing {{{2
-fu! s:PrtClear()
-	if !s:focus | retu | en
-	unl! s:hstgot
-	let [s:prompt, s:matches] = [['', '', ''], 1]
-	cal s:BuildPrompt(1)
-endf
-
-fu! s:PrtAdd(char)
-	unl! s:hstgot
-	let s:act_add = 1
-	let s:prompt[0] .= a:char
-	cal s:BuildPrompt(1)
-	unl s:act_add
-endf
-
-fu! s:PrtBS()
-	if !s:focus | retu | en
-	if empty(s:prompt[0]) && s:brfprt != 0
-		cal s:PrtExit()
-		retu
-	en
-	unl! s:hstgot
-	let [s:prompt[0], s:matches] = [substitute(s:prompt[0], '.$', '', ''), 1]
-	cal s:BuildPrompt(1)
-endf
-
-fu! s:PrtDelete()
-	if !s:focus | retu | en
-	unl! s:hstgot
-	let [prt, s:matches] = [s:prompt, 1]
-	let prt[1] = matchstr(prt[2], '^.')
-	let prt[2] = substitute(prt[2], '^.', '', '')
-	cal s:BuildPrompt(1)
-endf
-
-fu! s:PrtDeleteWord()
-	if !s:focus | retu | en
-	unl! s:hstgot
-	let [str, s:matches] = [s:prompt[0], 1]
-	let str = str =~ '\W\w\+$' ? matchstr(str, '^.\+\W\ze\w\+$')
-		\ : str =~ '\w\W\+$' ? matchstr(str, '^.\+\w\ze\W\+$')
-		\ : str =~ '\s\+$' ? matchstr(str, '^.*\S\ze\s\+$')
-		\ : str =~ '\v^(\S+|\s+)$' ? '' : str
-	let s:prompt[0] = str
-	cal s:BuildPrompt(1)
-endf
-
-fu! s:PrtInsert(...)
-	if !s:focus | retu | en
-	let type = !a:0 ? '' : a:1
-	if !a:0
-		let type = s:insertstr()
-		if type == 'cancel' | retu | en
-	en
-	if type ==# 'r'
-		let regcont = s:getregs()
-		if regcont < 0 | retu | en
-	en
-	unl! s:hstgot
-	let s:act_add = 1
-	let s:prompt[0] .= type ==# 'w' ? s:crword
-		\ : type ==# 'f' ? s:crgfile
-		\ : type ==# 's' ? s:regisfilter('/')
-		\ : type ==# 'v' ? s:crvisual
-		\ : type ==# 'c' ? s:regisfilter('+')
-		\ : type ==# 'r' ? regcont : ''
-	cal s:BuildPrompt(1)
-	unl s:act_add
-endf
-
-fu! s:PrtExpandDir()
-	if !s:focus | retu | en
-	let str = s:getinput('c')
-	if str =~ '\v^\@(cd|lc[hd]?|chd)\s.+' && s:spi
-		let hasat = split(str, '\v^\@(cd|lc[hd]?|chd)\s*\zs')
-		let str = get(hasat, 1, '')
-		if str =~# '\v^[~$]\i{-}[\/]?|^#(\<?\d+)?:(p|h|8|\~|\.|g?s+)'
-			let str = expand(s:fnesc(str, 'g'))
-		elsei str =~# '\v^(\%|\<c\h{4}\>):(p|h|8|\~|\.|g?s+)'
-			let spc = str =~# '^%' ? s:crfile
-				\ : str =~# '^<cfile>' ? s:crgfile
-				\ : str =~# '^<cword>' ? s:crword
-				\ : str =~# '^<cWORD>' ? s:crnbword : ''
-			let pat = '(:(p|h|8|\~|\.|g?s(.)[^\3]*\3[^\3]*\3))+'
-			let mdr = matchstr(str, '\v^[^:]+\zs'.pat)
-			let nmd = matchstr(str, '\v^[^:]+'.pat.'\zs.{-}$')
-			let str = fnamemodify(s:fnesc(spc, 'g'), mdr).nmd
-		en
-	en
-	if str == '' | retu | en
-	unl! s:hstgot
-	let s:act_add = 1
-	let [base, seed] = s:headntail(str)
-	if str =~# '^[\/]'
-		let base = expand('/').base
-	en
-	let dirs = s:dircompl(base, seed)
-	if len(dirs) == 1
-		let str = dirs[0]
-	elsei len(dirs) > 1
-		let str .= s:findcommon(dirs, str)
-	en
-	let s:prompt[0] = exists('hasat') ? hasat[0].str : str
-	cal s:BuildPrompt(1)
-	unl s:act_add
-endf
-" Movement {{{2
-fu! s:PrtCurLeft()
-	if !s:focus | retu | en
-	let prt = s:prompt
-	if !empty(prt[0])
-		let s:prompt = [substitute(prt[0], '.$', '', ''), matchstr(prt[0], '.$'),
-			\ prt[1] . prt[2]]
-	en
-	cal s:BuildPrompt(0)
-endf
-
-fu! s:PrtCurRight()
-	if !s:focus | retu | en
-	let prt = s:prompt
-	let s:prompt = [prt[0] . prt[1], matchstr(prt[2], '^.'),
-		\ substitute(prt[2], '^.', '', '')]
-	cal s:BuildPrompt(0)
-endf
-
-fu! s:PrtCurStart()
-	if !s:focus | retu | en
-	let str = join(s:prompt, '')
-	let s:prompt = ['', matchstr(str, '^.'), substitute(str, '^.', '', '')]
-	cal s:BuildPrompt(0)
-endf
-
-fu! s:PrtCurEnd()
-	if !s:focus | retu | en
-	let s:prompt = [join(s:prompt, ''), '', '']
-	cal s:BuildPrompt(0)
-endf
-
-fu! s:PrtSelectMove(dir)
-	let wht = winheight(0)
-	let dirs = {'t': 'gg','b': 'G','j': 'j','k': 'k','u': wht.'k','d': wht.'j'}
-	exe 'keepj norm!' dirs[a:dir]
-	let pos = exists('*getcurpos') ? getcurpos() : getpos('.')
-	cal s:BuildPrompt(0)
-	cal setpos('.', pos)
-endf
-
-fu! s:PrtSelectJump(char)
-	let lines = copy(s:lines)
-	if s:byfname()
-		cal map(lines, 'split(v:val, ''[\/]\ze[^\/]\+$'')[-1]')
-	en
-	" Cycle through matches, use s:jmpchr to store last jump
-	let chr = escape(matchstr(a:char, '^.'), '.~')
-	let smartcs = &scs && chr =~ '\u' ? '\C' : ''
-	if match(lines, smartcs.'^'.chr) >= 0
-		" If not exists or does but not for the same char
-		let pos = match(lines, smartcs.'^'.chr)
-		if !exists('s:jmpchr') || ( exists('s:jmpchr') && s:jmpchr[0] != chr )
-			let [jmpln, s:jmpchr] = [pos, [chr, pos]]
-		elsei exists('s:jmpchr') && s:jmpchr[0] == chr
-			" Start of lines
-			if s:jmpchr[1] == -1 | let s:jmpchr[1] = pos | en
-			let npos = match(lines, smartcs.'^'.chr, s:jmpchr[1] + 1)
-			let [jmpln, s:jmpchr] = [npos == -1 ? pos : npos, [chr, npos]]
-		en
-		exe 'keepj norm!' ( jmpln + 1 ).'G'
-		let pos = exists('*getcurpos') ? getcurpos() : getpos('.')
-		cal s:BuildPrompt(0)
-		cal setpos('.', pos)
-	en
-endf
-" Misc {{{2
-fu! s:PrtFocusMap(char)
-	cal call(( s:focus ? 's:PrtAdd' : 's:PrtSelectJump' ), [a:char])
-endf
-
-fu! s:PrtClearCache()
-	let ct = s:curtype()
-	if ct == 'fil'
-		cal ctrlp#clr()
-	elsei s:itemtype >= len(s:coretypes)
-		cal ctrlp#clr(s:statypes[s:itemtype][1])
-	en
-	if ct == 'mru'
-		let g:ctrlp_lines = ctrlp#mrufiles#refresh()
-	el
-		cal ctrlp#setlines()
-	en
-	let s:force = 1
-	cal s:BuildPrompt(1)
-	unl s:force
-endf
-
-fu! s:PrtDeleteEnt()
-	let ct = s:curtype()
-	if ct == 'mru'
-		cal s:PrtDeleteMRU()
-	elsei ct == 'buf'
-		cal s:delbuf()
-	elsei type(s:getextvar('wipe')) == 1
-		cal s:delent(s:getextvar('wipe'))
-	en
-endf
-
-fu! s:PrtDeleteMRU()
-	if s:curtype() == 'mru'
-		cal s:delent('ctrlp#mrufiles#remove')
-	en
-endf
-
-fu! s:PrtExit()
-	let bw = bufwinnr('%')
-	exe bufwinnr(s:bufnr).'winc w'
-	if bufnr('%') == s:bufnr && bufname('%') == 'ControlP'
-		noa cal s:Close()
-		noa winc p
-	els
-		exe bw.'winc w'
-	en
-endf
-
-fu! s:PrtHistory(...)
-	if !s:focus || !s:maxhst | retu | en
-	let [str, hst, s:matches] = [join(s:prompt, ''), s:hstry, 1]
-	" Save to history if not saved before
-	let [hst[0], hslen] = [exists('s:hstgot') ? hst[0] : str, len(hst)]
-	let idx = exists('s:hisidx') ? s:hisidx + a:1 : a:1
-	" Limit idx within 0 and hslen
-	let idx = idx < 0 ? 0 : idx >= hslen ? hslen > 1 ? hslen - 1 : 0 : idx
-	let s:prompt = [hst[idx], '', '']
-	let [s:hisidx, s:hstgot, s:force] = [idx, 1, 1]
-	cal s:BuildPrompt(1)
-	unl s:force
-endf
-"}}}1
-" * Mappings {{{1
-fu! s:MapNorms()
-	if exists('s:nmapped') && s:nmapped == s:bufnr | retu | en
-	let pcmd = "nn \<buffer> \<silent> \<k%s> :\<c-u>cal \<SID>%s(\"%s\")\<cr>"
-	let cmd = substitute(pcmd, 'k%s', 'char-%d', '')
-	let pfunc = 'PrtFocusMap'
-	let ranges = [32, 33, 125, 126] + range(35, 91) + range(93, 123)
-	for each in [34, 92, 124]
-		exe printf(cmd, each, pfunc, escape(nr2char(each), '"|\'))
-	endfo
-	for each in ranges
-		exe printf(cmd, each, pfunc, nr2char(each))
-	endfo
-	for each in range(0, 9)
-		exe printf(pcmd, each, pfunc, each)
-	endfo
-	for [ke, va] in items(s:kprange)
-		exe printf(pcmd, ke, pfunc, va)
-	endfo
-	let s:nmapped = s:bufnr
-endf
-
-fu! s:MapSpecs()
-	if !( exists('s:smapped') && s:smapped == s:bufnr )
-		" Correct arrow keys in terminal
-		if ( has('termresponse') && v:termresponse =~ "\<ESC>" )
-			\ || &term =~? '\vxterm|<k?vt|gnome|screen|linux|ansi|tmux|st(-[-a-z0-9]*)?(\:tc)?$'
-			for each in ['\A <up>','\B <down>','\C <right>','\D <left>']
-				exe s:lcmap.' <esc>['.each
-			endfo
-		en
-	en
-	for [ke, va] in items(s:prtmaps) | for kp in va
-		exe s:lcmap kp ':<c-u>cal <SID>'.ke.'<cr>'
-	endfo | endfo
-	let s:smapped = s:bufnr
-endf
-
-fu! s:KeyLoop()
-	let [t_ve, guicursor] = [&t_ve, &guicursor]
-	wh exists('s:init') && s:keyloop
-		try
-			set t_ve=
-			if guicursor != ''
-				set guicursor=a:NONE
-			en
-			let nr = getchar()
-		fina
-			let &t_ve = t_ve
-			let &guicursor = guicursor
-		endt
-		let chr = !type(nr) ? nr2char(nr) : nr
-		if nr >=# 0x20
-			cal s:PrtFocusMap(chr)
-		el
-			let cmd = matchstr(maparg(chr), ':<C-U>\zs.\+\ze<CR>$')
-			try
-				exe ( cmd != '' ? cmd : 'norm '.chr )
-			cat
-			endt
-		en
-	endw
-endf
-" * Toggling {{{1
-fu! s:ToggleFocus()
-	let s:focus = !s:focus
-	cal s:BuildPrompt(0)
-endf
-
-fu! s:ToggleRegex()
-	let s:regexp = !s:regexp
-	cal s:PrtSwitcher()
-endf
-
-fu! s:ToggleByFname()
-	if s:ispath
-		let s:byfname = !s:byfname
-		let s:mfunc = s:mfunc()
-		cal s:PrtSwitcher()
-	en
-endf
-
-fu! s:ToggleType(dir)
-	cal s:async_glob_abort()
-	let max = len(g:ctrlp_ext_vars) + len(s:coretypes) - 1
-	let next = s:walker(max, s:itemtype, a:dir)
-	cal ctrlp#setlines(next)
-	cal ctrlp#syntax()
-	cal s:PrtSwitcher()
-endf
-
-fu! s:ToggleKeyLoop()
-	let s:keyloop = !s:keyloop
-	if exists('+imd')
-		let &imd = !s:keyloop
-	en
-	if s:keyloop
-		let [&ut, s:lazy] = [0, 0]
-		cal s:KeyLoop()
-	elsei has_key(s:glbs, 'ut')
-		let [&ut, s:lazy] = [s:glbs['ut'], 1]
-	en
-endf
-
-fu! s:ToggleMRURelative()
-	cal ctrlp#mrufiles#tgrel()
-	cal s:PrtClearCache()
-endf
-
-fu! s:PrtSwitcher()
-	let [s:force, s:matches] = [1, 1]
-	cal s:BuildPrompt(1)
-	unl s:force
-endf
-" - SetWD() {{{1
-fu! s:SetWD(args)
-	if has_key(a:args, 'args') && stridx(a:args['args'], '--dir') >= 0
-		\ && exists('s:dyncwd')
-		cal ctrlp#setdir(s:dyncwd) | retu
-	en
-	if has_key(a:args, 'dir') && a:args['dir'] != ''
-		cal ctrlp#setdir(a:args['dir']) | retu
-	en
-	let pmodes = has_key(a:args, 'mode') ? a:args['mode'] : s:pathmode
-	let [s:crfilerel, s:dyncwd] = [fnamemodify(s:crfile, ':.'), getcwd()]
-	if (!type(pmodes))
-		let pmodes =
-			\ pmodes == 0 ? '' :
-			\ pmodes == 1 ? 'a' :
-			\ pmodes == 2 ? 'r' :
-			\ 'c'
-	en
-	let spath = pmodes =~ 'd' ? s:dyncwd : pmodes =~ 'w' ? s:cwd : s:crfpath
-	for pmode in split(pmodes, '\zs')
-		if ctrlp#setpathmode(pmode, spath) | retu | en
-	endfo
-endf
-" * AcceptSelection() {{{1
-fu! ctrlp#acceptfile(...)
-	let useb = 0
-	if a:0 == 1 && type(a:1) == 4
-		let [md, line] = [a:1['action'], a:1['line']]
-		let atl = has_key(a:1, 'tail') ? a:1['tail'] : ''
-	el
-		let [md, line] = [a:1, a:2]
-		let atl = a:0 > 2 ? a:3 : ''
-	en
-	if !type(line)
-		let [filpath, bufnr, useb] = [line, line, 1]
-	el
-		let [bufnr, filpath] = s:bufnrfilpath(line)
-		if bufnr == filpath
-			let useb = 1
-		en
-	en
-	cal s:PrtExit()
-	let tail = s:tail()
-	let j2l = atl != '' ? atl : matchstr(tail, '^ +\zs\d\+$')
-	let openmyself = bufnr == bufnr('%')
-	if bufnr > 0 && ( !empty(s:jmptobuf) && s:jmptobuf =~ md )
-		\ && !( md == 'e' && openmyself )
-		let [jmpb, bufwinnr] = [1, bufwinnr(bufnr)]
-		let buftab = ( s:jmptobuf =~# '[tTVH]' || s:jmptobuf > 1 )
-			\ ? s:buftab(bufnr, md) : [0, 0]
-	en
-	" Switch to existing buffer or open new one
-	if exists('jmpb') && bufwinnr > 0
-		\ && !( md == 't' && ( s:jmptobuf !~# toupper(md) || buftab[0] ) )
-		exe bufwinnr.'winc w'
-		if j2l | cal ctrlp#j2l(j2l) | en
-	elsei exists('jmpb') && buftab[0]
-		\ && !( md =~ '[evh]' && s:jmptobuf !~# toupper(md) )
-		exe 'tabn' buftab[0]
-		exe buftab[1].'winc w'
-		if j2l | cal ctrlp#j2l(j2l) | en
-	el
-		" Determine the command to use
-		let useb = bufnr > 0 && ( buflisted(bufnr) || openmyself ) && ( empty(tail) || useb )
-		let cmd =
-			\ md == 't' || s:splitwin == 1 ? ( useb ? 'tab sb' : 'tabe' ) :
-			\ md == 'h' || s:splitwin == 2 ? ( useb ? 'sb' : 'new' ) :
-			\ md == 'v' || s:splitwin == 3 ? ( useb ? 'vert sb' : 'vne' ) :
-			\ &bt == 'help' && openmyself ? 'b' :
-			\ call('ctrlp#normcmd', useb ? ['b', 'bo vert sb'] : ['e'])
-		" Reset &switchbuf option
-		let [swb, &swb] = [&swb, '']
-		" Open new window/buffer
-		let [fid, tail] = [( useb ? bufnr : filpath ), ( atl != '' ? ' +'.atl : tail )]
-		let args = [cmd, fid, tail, 1, [useb, j2l]]
-		cal call('s:openfile', args)
-		let &swb = swb
-	en
-endf
-
-fu! s:SpecInputs(str)
-	if a:str =~ '\v^(\.\.([\/]\.\.)*[\/]?[.\/]*)$' && s:spi
-		let cwd = s:dyncwd
-		cal ctrlp#setdir(a:str =~ '^\.\.\.*$' ?
-			\ '../'.repeat('../', strlen(a:str) - 2) : a:str)
-		if cwd != s:dyncwd | cal ctrlp#setlines() | en
-		cal s:PrtClear()
-		retu 1
-	elsei a:str == s:lash && s:spi
-		cal s:SetWD({ 'mode': 'rd' })
-		cal ctrlp#setlines()
-		cal s:PrtClear()
-		retu 1
-	elsei a:str =~ '^@.\+' && s:spi
-		retu s:at(a:str)
-	elsei a:str == '?'
-		cal s:PrtExit()
-		let hlpwin = &columns > 159 ? '| vert res 80' : ''
-		sil! exe 'bo vert h ctrlp-mappings' hlpwin '| norm! 0'
-		retu 1
-	en
-	retu 0
-endf
-
-fu! s:AcceptSelection(action)
-	let [md, icr] = [a:action[0], match(a:action, 'r') >= 0]
-	let subm = icr || ( !icr && md == 'e' )
-	if !subm && s:OpenMulti(md) != -1 | retu | en
-	let str = s:getinput()
-	if subm | if s:SpecInputs(str) | retu | en | en
-	" Get the selected line
-	let line = ctrlp#getcline()
-	if !subm && s:curtype() != 'fil' && line == '' && line('.') > s:offset
-		\ && str !~ '\v^(\.\.([\/]\.\.)*[\/]?[.\/]*|/|\\|\?|\@.+)$'
-		cal s:CreateNewFile(md) | retu
-	en
-	if empty(line) | retu | en
-	" Do something with it
-	if s:openfunc != {} && has_key(s:openfunc, s:ctype)
-		let actfunc = s:openfunc[s:ctype]
-		let type = has_key(s:openfunc, 'arg_type') ? s:openfunc['arg_type'] : 'list'
-	el
-		if s:itemtype < len(s:coretypes)
-			let [actfunc, type] = ['ctrlp#acceptfile', 'dict']
-		el
-			let [actfunc, exttype] = [s:getextvar('accept'), s:getextvar('act_farg')]
-			let type = exttype == 'dict' ? exttype : 'list'
-		en
-	en
-	let actargs = type == 'dict' ? [{ 'action': md, 'line': line, 'icr': icr, 'input': str}]
-		\ : [md, line]
-	cal call(actfunc, actargs)
-endf
-" - CreateNewFile() {{{1
-fu! s:CreateNewFile(...)
-	let [md, str] = ['', s:getinput('n')]
-	if empty(str) | retu | en
-	if s:argmap && !a:0
-		" Get the extra argument
-		let md = s:argmaps(md, 1)
-		if md == 'cancel' | retu | en
-	en
-	let str = s:sanstail(str)
-	let [base, fname] = s:headntail(str)
-	if fname =~ '^[\/]$' | retu | en
-	if exists('s:marked') && len(s:marked)
-		" Use the first marked file's path
-		let path = fnamemodify(values(s:marked)[0], ':p:h')
-		let base = path.s:lash(path).base
-		let str = fnamemodify(base.s:lash.fname, ':.')
-	en
-	if base != '' | if isdirectory(ctrlp#utils#mkdir(base))
-		let optyp = str | en | el | let optyp = fname
-	en
-	if !exists('optyp') | retu | en
-	let [filpath, tail] = [fnamemodify(optyp, ':p'), s:tail()]
-	if !stridx(filpath, s:dyncwd) | cal s:insertcache(str) | en
-	cal s:PrtExit()
-	let cmd = md == 'r' ? ctrlp#normcmd('e') :
-		\ s:newfop =~ '1\|t' || ( a:0 && a:1 == 't' ) || md == 't' ? 'tabe' :
-		\ s:newfop =~ '2\|h' || ( a:0 && a:1 == 'h' ) || md == 'h' ? 'new' :
-		\ s:newfop =~ '3\|v' || ( a:0 && a:1 == 'v' ) || md == 'v' ? 'vne' :
-		\ ctrlp#normcmd('e')
-	cal s:openfile(cmd, filpath, tail, 1)
-endf
-" * OpenMulti() {{{1
-fu! s:MarkToOpen()
-	let ct = s:curtype()
-	if s:bufnr <= 0 || s:opmul == '0'
-		\ || ( s:itemtype >= len(s:coretypes) && s:getextvar('opmul') != 1 )
-		retu
-	en
-	let line = ctrlp#getcline()
-
-	" Do not allow to mark modified or current buffer
-	let bufnr = s:bufnrfilpath(line)[0]
-	if (ct == 'buf' && s:delbufcond(bufnr))
-		retu
-	en
-
-	if empty(line) | retu | en
-	let filpath = s:ispath ? fnamemodify(line, ':p') : line
-	if exists('s:marked') && s:dictindex(s:marked, filpath) > 0
-		" Unmark and remove the file from s:marked
-		let key = s:dictindex(s:marked, filpath)
-		cal remove(s:marked, key)
-		if empty(s:marked) | unl s:marked | en
-		if has('signs')
-			exe 'sign unplace' key 'buffer='.s:bufnr
-		en
-	el
-		" Add to s:marked and place a new sign
-		if exists('s:marked')
-			let vac = s:vacantdict(s:marked)
-			let key = empty(vac) ? len(s:marked) + 1 : vac[0]
-			let s:marked = extend(s:marked, { key : filpath })
-		el
-			let [key, s:marked] = [1, { 1 : filpath }]
-		en
-		if has('signs')
-			exe 'sign place' key 'line='.line('.').' name=ctrlpmark buffer='.s:bufnr
-		en
-	en
-	sil! cal ctrlp#statusline()
-endf
-
-fu! s:OpenMulti(...)
-	let has_marked = exists('s:marked')
-	if ( !has_marked && a:0 ) || s:opmul == '0' || !s:ispath
-		\ || ( s:itemtype >= len(s:coretypes) && s:getextvar('opmul') != 1 )
-		retu -1
-	en
-	" Get the options
-	let [nr, md] = [matchstr(s:opmul, '\d\+'), matchstr(s:opmul, '[thvi]')]
-	let [ur, jf] = [s:opmul =~ 'r', s:opmul =~ 'j']
-	let md = a:0 ? a:1 : ( md == '' ? 'v' : md )
-	let nopt = exists('g:ctrlp_open_multiple_files')
-	if !has_marked
-		let line = ctrlp#getcline()
-		if line == '' | retu | en
-		let marked = { 1 : fnamemodify(line, ':p') }
-		let [nr, ur, jf, nopt] = ['1', 0, 0, 1]
-	en
-	if ( s:argmap || !has_marked ) && !a:0
-		let md = s:argmaps(md, !has_marked ? 2 : 0)
-		if md == 'c'
-			cal s:unmarksigns()
-			unl! s:marked
-			cal s:BuildPrompt(0)
-		elsei !has_marked && md =~ '[axd]'
-			retu s:OpenNoMarks(md, line)
-		en
-		if md =~ '\v^c(ancel)?$' | retu | en
-		let nr = nr == '0' ? ( nopt ? '' : '1' ) : nr
-		let ur = !has_marked && md == 'r' ? 1 : ur
-	en
-	let mkd = values(has_marked ? s:marked : marked)
-	cal s:sanstail(join(s:prompt, ''))
-	cal s:PrtExit()
-	if nr == '0' || md == 'i'
-		retu map(mkd, "s:openfile('bad', v:val, '', 0)")
-	en
-	let tail = s:tail()
-	let [emptytail, bufnr] = [empty(tail), bufnr('^'.mkd[0].'$')]
-	let useb = bufnr > 0 && buflisted(bufnr) && emptytail
-	" Move to a replaceable window
-	let ncmd = ( useb ? ['b', 'bo vert sb'] : ['e', 'bo vne'] )
-		\ + ( ur ? [] : ['ignruw'] )
-	let fst = call('ctrlp#normcmd', ncmd)
-	" Check if the current window has a replaceable buffer
-	let repabl = !( md == 't' && !ur ) && empty(bufname('%')) && empty(&l:ft)
-	" Commands for the rest of the files
-	let [ic, cmds] = [1, { 'v': ['vert sb', 'vne'], 'h': ['sb', 'new'],
-		\ 't': ['tab sb', 'tabe'] }]
-	let [swb, &swb] = [&swb, '']
-	if md == 't' && ctrlp#tabcount() < tabpagenr()
-		let s:tabct = ctrlp#tabcount()
-	en
-	" Open the files
-	for va in mkd
-		let bufnr = bufnr('^'.va.'$')
-		if bufnr < 0 && getftype(va) == '' | con | en
-		let useb = bufnr > 0 && buflisted(bufnr) && emptytail
-		let snd = md != '' && has_key(cmds, md) ?
-			\ ( useb ? cmds[md][0] : cmds[md][1] ) : ( useb ? 'vert sb' : 'vne' )
-		let cmd = ic == 1 && ( !( !ur && fst =~ '^[eb]$' ) || repabl ) ? fst : snd
-		let conds = [( nr != '' && nr > 1 && nr < ic ) || ( nr == '' && ic > 1 ),
-			\ nr != '' && nr < ic]
-		if conds[nopt]
-			if !buflisted(bufnr) | cal s:openfile('bad', va, '', 0) | en
-		el
-			cal s:openfile(cmd, useb ? bufnr : va, tail, ic == 1)
-			if jf | if ic == 1
-				let crpos = [tabpagenr(), winnr()]
-			el
-				let crpos[0] += tabpagenr() <= crpos[0]
-				let crpos[1] += winnr() <= crpos[1]
-			en | en
-			let ic += 1
-		en
-	endfo
-	if jf && exists('crpos') && ic > 2
-		exe ( md == 't' ? 'tabn '.crpos[0] : crpos[1].'winc w' )
-	en
-	let &swb = swb
-	unl! s:tabct
-endf
-
-fu! s:YankLine(...)
-	let @" = s:getinput()
-	let has_marked = exists('s:marked')
-	if !has_marked
-		let line = ctrlp#getcline()
-		if line == '' | retu | en
-		let marked = { 1 : fnamemodify(line, ':p') }
-	en
-	let @" = join(values(has_marked ? s:marked : marked), "\n")
-	cal s:PrtExit()
-endf
-
-fu! s:OpenNoMarks(md, line)
-	if a:md == 'a'
-		let [s:marked, key] = [{}, 1]
-		for line in s:lines
-			let s:marked = extend(s:marked, { key : fnamemodify(line, ':p') })
-			let key += 1
-		endfo
-		cal s:remarksigns()
-		cal s:BuildPrompt(0)
-	elsei a:md == 'x'
-		let type = has_key(s:openfunc, 'arg_type') ? s:openfunc['arg_type'] : 'dict'
-		let argms = type == 'dict' ? [{ 'action': a:md, 'line': a:line }]
-			\ : [a:md, a:line]
-		cal call(s:openfunc[s:ctype], argms, s:openfunc)
-	elsei a:md == 'd'
-		let dir = fnamemodify(a:line, ':h')
-		if isdirectory(dir)
-			cal ctrlp#setdir(dir)
-			cal ctrlp#switchtype(0)
-			cal ctrlp#recordhist()
-			cal s:PrtClear()
-		en
-	en
-endf
-" ** Helper functions {{{1
-" Sorting {{{2
-fu! ctrlp#complen(...)
-	" By length
-	let [len1, len2] = [strlen(a:1), strlen(a:2)]
-	retu len1 == len2 ? 0 : len1 > len2 ? 1 : -1
-endf
-
-fu! s:compmatlen(...)
-	" By match length
-	let mln1 = s:shortest(s:matchlens(a:1, s:compat))
-	let mln2 = s:shortest(s:matchlens(a:2, s:compat))
-	retu mln1 == mln2 ? 0 : mln1 > mln2 ? 1 : -1
-endf
-
-fu! s:comptime(...)
-	" By last modified time
-	let [time1, time2] = [getftime(a:1), getftime(a:2)]
-	retu time1 == time2 ? 0 : time1 < time2 ? 1 : -1
-endf
-
-fu! s:compmreb(...)
-	" By last entered time (bufnr)
-	let [id1, id2] = [index(s:mrbs, a:1), index(s:mrbs, a:2)]
-	if id1 == id2
-		return 0
-	endif
-	if id1 < 0
-		return 1
-	endif
-	if id2 < 0
-		return -1
-	endif
-	return id1 > id2 ? 1 : -1
-endf
-
-fu! s:compmref(...)
-	" By last entered time (MRU)
-	let [id1, id2] = [index(g:ctrlp_lines, a:1), index(g:ctrlp_lines, a:2)]
-	retu id1 == id2 ? 0 : id1 > id2 ? 1 : -1
-endf
-
-fu! s:comparent(...)
-	" By same parent dir
-	if !stridx(s:crfpath, s:dyncwd)
-		let [as1, as2] = [s:dyncwd.s:lash().a:1, s:dyncwd.s:lash().a:2]
-		let [loc1, loc2] = [s:getparent(as1), s:getparent(as2)]
-		if loc1 == s:crfpath && loc2 != s:crfpath | retu -1 | en
-		if loc2 == s:crfpath && loc1 != s:crfpath | retu 1  | en
-		retu 0
-	en
-	retu 0
-endf
-
-fu! s:compfnlen(...)
-	" By filename length
-	let len1 = strlen(split(a:1, s:lash)[-1])
-	let len2 = strlen(split(a:2, s:lash)[-1])
-	retu len1 == len2 ? 0 : len1 > len2 ? 1 : -1
-endf
-
-fu! s:matchlens(str, pat, ...)
-	if empty(a:pat) || index(['^', '$'], a:pat) >= 0 | retu {} | en
-	let st   = a:0 ? a:1 : 0
-	let lens = a:0 >= 2 ? a:2 : {}
-	let nr   = a:0 >= 3 ? a:3 : 0
-	if nr > 20 | retu {} | en
-	if match(a:str, a:pat, st) >= 0
-		let [mst, mnd] = [matchstr(a:str, a:pat, st), matchend(a:str, a:pat, st)]
-		let lens = extend(lens, { nr : [strlen(mst), mst] })
-		let lens = s:matchlens(a:str, a:pat, mnd, lens, nr + 1)
-	en
-	retu lens
-endf
-
-fu! s:shortest(lens)
-	retu min(map(values(a:lens), 'v:val[0]'))
-endf
-
-fu! s:mixedsort(...)
-	let ct = s:curtype()
-	if ct == 'buf'
-		let pat = '[\/]\?\[\d\+\*No Name\]$'
-		if a:1 =~# pat && a:2 =~# pat | retu 0
-		elsei a:1 =~# pat | retu 1
-		elsei a:2 =~# pat | retu -1 | en
-	en
-	let [cln, cml] = [ctrlp#complen(a:1, a:2), s:compmatlen(a:1, a:2)]
-	if s:ispath
-		let ms = []
-		if s:res_count < 21
-			let ms += [s:compfnlen(a:1, a:2)]
-			if ct !~ '^\(buf\|mru\)$' | let ms += [s:comptime(a:1, a:2)] | en
-			if !s:itemtype | let ms += [s:comparent(a:1, a:2)] | en
-		en
-		if ct =~ '^\(buf\|mru\)$'
-			let ms += [s:compmref(a:1, a:2)]
-			let cln = cml ? cln : 0
-		en
-		let ms += [cml, 0, 0, 0]
-		let mp = call('s:multipliers', ms[:3])
-		retu cln + ms[0] * mp[0] + ms[1] * mp[1] + ms[2] * mp[2] + ms[3] * mp[3]
-	en
-	retu cln + cml * 2
-endf
-
-fu! s:multipliers(...)
-	let mp0 = !a:1 ? 0 : 2
-	let mp1 = !a:2 ? 0 : 1 + ( !mp0 ? 1 : mp0 )
-	let mp2 = !a:3 ? 0 : 1 + ( !( mp0 + mp1 ) ? 1 : ( mp0 + mp1 ) )
-	let mp3 = !a:4 ? 0 : 1 + ( !( mp0 + mp1 + mp2 ) ? 1 : ( mp0 + mp1 + mp2 ) )
-	retu [mp0, mp1, mp2, mp3]
-endf
-
-fu! s:compval(...)
-	retu a:1 - a:2
-endf
-" Statusline {{{2
-fu! ctrlp#statusline()
-	if !exists('s:statypes')
-		let s:statypes = copy(s:coretypes)
-		if !empty(g:ctrlp_ext_vars)
-			cal map(copy(g:ctrlp_ext_vars),
-				\ 'add(s:statypes, [ v:val["lname"], v:val["sname"] ])')
-		en
-	en
-	let tps = s:statypes
-	let max = len(tps) - 1
-	let nxt = tps[s:walker(max, s:itemtype,  1)][1]
-	let prv = tps[s:walker(max, s:itemtype, -1)][1]
-	let s:ctype = tps[s:itemtype][0]
-	let focus   = s:focus ? 'prt'  : 'win'
-	let byfname = s:ispath ? s:byfname ? 'file' : 'path' : 'line'
-	let marked  = s:opmul != '0' ?
-		\ exists('s:marked') ? ' <'.s:dismrk().'>' : ' <->' : ''
-	if s:status != {}
-		let argms =
-			\ has_key(s:status, 'arg_type') && s:status['arg_type'] == 'dict' ? [{
-			\ 'focus':   focus,
-			\ 'byfname': byfname,
-			\ 'regex':   s:regexp,
-			\ 'prev':    prv,
-			\ 'item':    s:ctype,
-			\ 'next':    nxt,
-			\ 'marked':  marked,
-			\ }] : [focus, byfname, s:regexp, prv, s:ctype, nxt, marked]
-		let &l:stl = call(s:status['main'], argms, s:status)
-	el
-		let item    = '%#CtrlPMode1# '.s:ctype.' %*'
-		let focus   = '%#CtrlPMode2# '.focus.' %*'
-		let byfname = '%#CtrlPMode1# '.byfname.' %*'
-		let regex   = s:regexp  ? '%#CtrlPMode2# regex %*' : ''
-		let slider  = ' <'.prv.'>={'.item.'}=<'.nxt.'>'
-		let dir     = ' %=%<%#CtrlPMode2# %{getcwd()} %*'
-		let &l:stl  = focus.byfname.regex.slider.marked.dir
-		if exists('s:timer')
-			let &l:stl = '%#CtrlPStats# '.len(g:ctrlp_allfiles).' '.&l:stl
-		en
-	en
-endf
-
-fu! s:dismrk()
-	retu has('signs') ? len(s:marked) :
-		\ '%<'.join(values(map(copy(s:marked), 'split(v:val, "[\\/]")[-1]')), ', ')
-endf
-
-fu! ctrlp#progress(enum, ...)
-	if has('macunix') || has('mac') | sl 1m | en
-	let txt = a:0 ? '(press ctrl-c to abort)' : ''
-	if s:status != {}
-		let argms = has_key(s:status, 'arg_type') && s:status['arg_type'] == 'dict'
-			\ ? [{ 'str': a:enum }] : [a:enum]
-		let &l:stl = call(s:status['prog'], argms, s:status)
-	el
-		let &l:stl = '%#CtrlPStats# '.a:enum.' %* '.txt.'%=%<%#CtrlPMode2# %{getcwd()} %*'
-	en
-	redraws
-endf
-" *** Paths {{{2
-" Line formatting {{{3
-fu! s:formatline(str)
-	let str = a:str
-	let ct = s:curtype()
-	if ct == 'buf'
-		let bufnr = s:bufnrfilpath(str)[0]
-		let parts = s:bufparts(bufnr)
-		let str = printf('%'.s:bufnr_width.'s', bufnr)
-		if s:has_conceal && has('syntax_items')
-			let str .= printf(' %-13s %s%-36s',
-				\ '<bi>'.parts[0].'</bi>',
-				\ '<bn>'.parts[1], '{'.parts[2].'}</bn>')
-			if (!empty(s:bufpath_mod))
-				let str .= printf('  %s', '<bp>'.parts[3].'</bp>')
-			en
-		el
-			let str .= printf(' %-5s %-30s',
-				\ parts[0],
-				\ parts[2])
-			if (!empty(s:bufpath_mod))
-				let str .= printf('  %s', parts[3])
-			en
-		en
-	en
-	let cond = ct != 'buf' &&s:ispath && ( s:winw - 4 ) < s:strwidth(str)
-	retu s:lineprefix.( cond ? s:pathshorten(str) : str )
-endf
-
-fu! s:pathshorten(str)
-	retu matchstr(a:str, '^.\{9}').'...'
-		\ .matchstr(a:str, '.\{'.( s:winw - 16 ).'}$')
-endf
-
-fu! s:offset(lines, height)
-	let s:offset = s:mw_order == 'btt' ? ( a:height - s:res_count ) : 0
-	retu s:offset > 0 ? ( repeat([''], s:offset) + a:lines ) : a:lines
-endf
-" Directory completion {{{3
-fu! s:dircompl(be, sd)
-	if a:sd == '' | retu [] | en
-	if a:be == ''
-		let [be, sd] = [s:dyncwd, a:sd]
-	el
-		let be = a:be.s:lash(a:be)
-		let sd = be.a:sd
-	en
-	let dirs = split(globpath(s:fnesc(be, 'g', ','), a:sd.'*/'), "\n")
-	if a:be == ''
-		let dirs = ctrlp#rmbasedir(dirs)
-	en
-	cal filter(dirs, '!match(v:val, escape(sd, ''~$.\''))'
-		\ . ' && v:val !~ ''\v(^|[\/])\.{1,2}[\/]$''')
-	retu dirs
-endf
-
-fu! s:findcommon(items, seed)
-	let [items, id, cmn, ic] = [copy(a:items), strlen(a:seed), '', 0]
-	cal map(items, 'strpart(v:val, id)')
-	for char in split(items[0], '\zs')
-		for item in items[1:]
-			if item[ic] != char | let brk = 1 | brea | en
-		endfo
-		if exists('brk') | brea | en
-		let cmn .= char
-		let ic += 1
-	endfo
-	retu cmn
-endf
-" Misc {{{3
-fu! s:headntail(str)
-	let parts = split(a:str, '[\/]\ze[^\/]\+[\/:]\?$')
-	retu len(parts) == 1 ? ['', parts[0]] : len(parts) == 2 ? parts : []
-endf
-
-fu! s:lash(...)
-	retu ( a:0 ? a:1 : s:dyncwd ) !~ '[\/]$' ? s:lash : ''
-endf
-
-fu! s:ispathitem()
-	retu s:itemtype < len(s:coretypes) || s:getextvar('type') == 'path'
-endf
-
-fu! ctrlp#igncwd(cwd)
-	retu ctrlp#utils#glob(a:cwd, 0) == '' ||
-		\ ( s:igntype >= 0 && s:usrign(a:cwd, getftype(a:cwd)) )
-endf
-
-fu! ctrlp#dirnfile(entries)
-	let [items, cwd] = [[[], []], s:dyncwd.s:lash()]
-	for each in a:entries
-		let etype = getftype(each)
-		if s:igntype >= 0 && s:usrign(each, etype) | con | en
-		if etype == 'dir'
-			if s:showhidden | if each !~ '[\/]\.\{1,2}$'
-				cal add(items[0], each)
-			en | el
-				cal add(items[0], each)
-			en
-		elsei etype == 'link'
-			if s:folsym
-				let isfile = !isdirectory(each)
-				if s:folsym == 2 || !s:samerootsyml(each, isfile, cwd)
-					cal add(items[isfile], each)
-				en
-			en
-		elsei etype == 'file'
-			cal add(items[1], each)
-		en
-	endfo
-	retu items
-endf
-
-fu! s:usrign(item, type)
-	if s:igntype == 1 | retu a:item =~ s:usrign | en
-	if s:igntype == 2
-		if call(s:usrign, [a:item, a:type])
-			retu 1
-		en
-	elsei s:igntype == 4
-		if has_key(s:usrign, a:type) && s:usrign[a:type] != ''
-					\ && a:item =~ s:usrign[a:type]
-			retu 1
-		elsei has_key(s:usrign, 'func') && s:usrign['func'] != ''
-					\ && call(s:usrign['func'], [a:item, a:type])
-			retu 1
-		en
-	en
-	retu 0
-endf
-
-fu! s:samerootsyml(each, isfile, cwd)
-	let resolve = fnamemodify(resolve(a:each), ':p:h')
-	let resolve .= s:lash(resolve)
-	retu !( stridx(resolve, a:cwd) && ( stridx(a:cwd, resolve) || a:isfile ) )
-endf
-
-fu! ctrlp#rmbasedir(items)
-	if a:items == []
-		retu a:items
-	en
-	let cwd = s:dyncwd.s:lash()
-	let first = a:items[0]
-	if has('win32') || has('win64')
-		let cwd = tr(cwd, '\', '/')
-		let first = tr(first, '\', '/')
-	en
-	if !stridx(first, cwd)
-		let idx = strlen(cwd)
-		retu map(a:items, 'strpart(v:val, idx)')
-	en
-	retu a:items
-endf
-" Working directory {{{3
-fu! s:getparent(item)
-	let parent = substitute(a:item, '[\/][^\/]\+[\/:]\?$', '', '')
-	if parent == '' || parent !~ '[\/]'
-		let parent .= s:lash
-	en
-	retu parent
-endf
-
-fu! s:findroot(curr, mark, depth, type)
-	let [depth, fnd] = [a:depth + 1, 0]
-	if type(a:mark) == 1
-		let fnd = s:glbpath(s:fnesc(a:curr, 'g', ','), a:mark, 1) != ''
-	elsei type(a:mark) == 3
-		for markr in a:mark
-			if s:glbpath(s:fnesc(a:curr, 'g', ','), markr, 1) != ''
-				let fnd = 1
-				brea
-			en
-		endfo
-	en
-	if fnd
-		if !a:type | cal ctrlp#setdir(a:curr) | en
-		retu [exists('markr') ? markr : a:mark, a:curr]
-	elsei depth > s:maxdepth
-		cal ctrlp#setdir(s:cwd)
-	el
-		let parent = s:getparent(a:curr)
-		if parent != a:curr
-			retu s:findroot(parent, a:mark, depth, a:type)
-		en
-	en
-	retu []
-endf
-
-fu! ctrlp#setpathmode(pmode, ...)
-	if a:pmode == 'c' || ( a:pmode == 'a' && stridx(s:crfpath, s:cwd) < 0 )
-		if exists('+acd') | let [s:glb_acd, &acd] = [&acd, 0] | en
-		cal ctrlp#setdir(s:crfpath)
-		retu 1
-	elsei a:pmode == 'r'
-		let spath = a:0 ? a:1 : s:crfpath
-		let markers = ['.git', '.hg', '.svn', '.bzr', '_darcs']
-		if type(s:rmarkers) == 3 && !empty(s:rmarkers)
-			if s:findroot(spath, s:rmarkers, 0, 0) != [] | retu 1 | en
-			cal filter(markers, 'index(s:rmarkers, v:val) < 0')
-			let markers = s:rmarkers + markers
-		en
-		if s:findroot(spath, markers, 0, 0) != [] | retu 1 | en
-	en
-	retu 0
-endf
-
-fu! ctrlp#setdir(path, ...)
-	let cmd = a:0 ? a:1 : 'lc!'
-	sil! exe cmd s:fnesc(a:path, 'c')
-	let [s:crfilerel, s:dyncwd] = [fnamemodify(s:crfile, ':.'), getcwd()]
-endf
-" Fallbacks {{{3
-fu! s:glbpath(...)
-	retu call('ctrlp#utils#globpath', a:000)
-endf
-
-fu! s:fnesc(...)
-	retu call('ctrlp#utils#fnesc', a:000)
-endf
-
-fu! ctrlp#setlcdir()
-	if exists('*haslocaldir')
-		cal ctrlp#setdir(getcwd(), haslocaldir() ? 'lc!' : 'cd!')
-	en
-endf
-" Highlighting {{{2
-fu! ctrlp#syntax()
-	if ctrlp#nosy() | retu | en
-	for [ke, va] in items(s:hlgrps) | cal ctrlp#hicheck('CtrlP'.ke, va) | endfo
-	let bgColor=synIDattr(synIDtrans(hlID('Normal')), 'bg')
-	if bgColor !~ '^-1$\|^$'
-		sil! exe 'hi CtrlPLinePre guifg='.bgColor.' ctermfg='.bgColor
-	en
-	sy match CtrlPNoEntries '^ == NO ENTRIES ==$'
-	if hlexists('CtrlPLinePre')
-		exe "sy match CtrlPLinePre '^".escape(get(g:, 'ctrlp_line_prefix', '>'),'^$.*~\')."'"
-	en
-
-	if s:curtype() == 'buf' && s:has_conceal
-		sy region CtrlPBufferNr     matchgroup=CtrlPLinePre start='^>\s\+' end='\s'
-		sy region CtrlPBufferInd    concealends matchgroup=Ignore start='<bi>' end='</bi>'
-		sy region CtrlPBufferRegion concealends matchgroup=Ignore start='<bn>' end='</bn>'
-			\ contains=CtrlPBufferHid,CtrlPBufferHidMod,CtrlPBufferVis,CtrlPBufferVisMod,CtrlPBufferCur,CtrlPBufferCurMod
-		sy region CtrlPBufferHid    concealends matchgroup=Ignore     start='\s*{' end='}' contained
-		sy region CtrlPBufferHidMod concealends matchgroup=Ignore    start='+\s*{' end='}' contained
-		sy region CtrlPBufferVis    concealends matchgroup=Ignore   start='\*\s*{' end='}' contained
-		sy region CtrlPBufferVisMod concealends matchgroup=Ignore  start='\*+\s*{' end='}' contained
-		sy region CtrlPBufferCur    concealends matchgroup=Ignore  start='\*!\s*{' end='}' contained
-		sy region CtrlPBufferCurMod concealends matchgroup=Ignore start='\*+!\s*{' end='}' contained
-		sy region CtrlPBufferPath   concealends matchgroup=Ignore start='<bp>' end='</bp>'
-	en
-endf
-
-fu! s:highlight(pat, grp)
-	if s:matcher != {} | retu | en
-	cal clearmatches()
-	if !empty(a:pat) && s:ispath
-		if s:regexp
-			let pat = substitute(a:pat, '\\\@<!\^', '^> \\zs', 'g')
-			cal matchadd(a:grp, ( s:martcs == '' ? '\c' : '\C' ).pat)
-		el
-			let pat = a:pat
-
-			" get original characters so we can rebuild pat
-			let chars = split(pat, '\[\^\\\?.\]\\{-}')
-
-			" Build a pattern like /a.*b.*c/ from abc (but with .\{-} non-greedy
-			" matchers instead)
-			let pat = join(chars, '.\{-}')
-			" Ensure we match the last version of our pattern
-			let ending = '\(.*'.pat.'\)\@!'
-			" Case sensitive?
-			let beginning = ( s:martcs == '' ? '\c' : '\C' ).'^.*'
-			if s:byfname()
-				" Make sure there are no slashes in our match
-				let beginning = beginning.'\([^\/]*$\)\@='
-			en
-
-			for i in range(len(chars))
-				" Surround our current target letter with \zs and \ze so it only
-				" actually matches that one letter, but has all preceding and trailing
-				" letters as well.
-				" \zsa.*b.*c
-				" a\(\zsb\|.*\zsb)\ze.*c
-				let charcopy = copy(chars)
-				if i == 0
-					let charcopy[i] = '\zs'.charcopy[i].'\ze'
-					let middle = join(charcopy, '.\{-}')
-				el
-					let before = join(charcopy[0:i-1], '.\{-}')
-					let after = join(charcopy[i+1:-1], '.\{-}')
-					let c = charcopy[i]
-					" for abc, match either ab.\{-}c or a.*b.\{-}c in that order
-					let cpat = '\(\zs'.c.'\|'.'.*\zs'.c.'\)\ze.*'
-					let middle = before.cpat.after
-				en
-
-				" Now we matchadd for each letter, the basic form being:
-				" ^.*\zsx\ze.*$, but with our pattern we built above for the letter,
-				" and a negative lookahead ensuring that we only highlight the last
-				" occurrence of our letters. We also ensure that our matcher is case
-				" insensitive or sensitive depending.
-				cal matchadd(a:grp, beginning.middle.ending)
-			endfo
-		en
-
-		cal matchadd('CtrlPLinePre', '^>')
-	elseif !empty(a:pat) && s:regexp &&
-				\ exists('g:ctrlp_regex_always_higlight') &&
-				\ g:ctrlp_regex_always_higlight
-		let pat = substitute(a:pat, '\\\@<!\^', '^> \\zs', 'g')
-		cal matchadd(a:grp, ( s:martcs == '' ? '\c' : '\C').pat)
-	en
-endf
-
-fu! s:dohighlight()
-	retu s:mathi[0] && exists('*clearmatches') && !ctrlp#nosy()
-endf
-" Prompt history {{{2
-fu! s:gethistloc()
-	let utilcadir = ctrlp#utils#cachedir()
-	let cache_dir = utilcadir.s:lash(utilcadir).'hist'
-	retu [cache_dir, cache_dir.s:lash(cache_dir).'cache.txt']
-endf
-
-fu! s:gethistdata()
-	retu ctrlp#utils#readfile(s:gethistloc()[1])
-endf
-
-fu! ctrlp#recordhist()
-	let str = join(s:prompt, '')
-	if empty(str) || !s:maxhst | retu | en
-	let hst = s:hstry
-	if len(hst) > 1 && hst[1] == str | retu | en
-	cal extend(hst, [str], 1)
-	if len(hst) > s:maxhst | cal remove(hst, s:maxhst, -1) | en
-	cal ctrlp#utils#writecache(hst, s:gethistloc()[0], s:gethistloc()[1])
-endf
-" Signs {{{2
-fu! s:unmarksigns()
-	if !s:dosigns() | retu | en
-	for key in keys(s:marked)
-		exe 'sign unplace' key 'buffer='.s:bufnr
-	endfo
-endf
-
-fu! s:remarksigns()
-	if !s:dosigns() | retu | en
-	for ic in range(1, len(s:lines))
-		let line = s:ispath ? fnamemodify(s:lines[ic - 1], ':p') : s:lines[ic - 1]
-		let key = s:dictindex(s:marked, line)
-		if key > 0
-			exe 'sign place' key 'line='.ic.' name=ctrlpmark buffer='.s:bufnr
-		en
-	endfo
-endf
-
-fu! s:dosigns()
-	retu exists('s:marked') && s:bufnr > 0 && s:opmul != '0' && has('signs')
-endf
-" Lists & Dictionaries {{{2
-fu! s:ifilter(list, str)
-	let [rlist, estr] = [[], substitute(a:str, 'v:val', 'each', 'g')]
-	for each in a:list
-		try
-			if eval(estr)
-				cal add(rlist, each)
-			en
-		cat | con | endt
-	endfo
-	retu rlist
-endf
-
-fu! s:dictindex(dict, expr)
-	for key in keys(a:dict)
-		if a:dict[key] ==# a:expr | retu key | en
-	endfo
-	retu -1
-endf
-
-fu! s:vacantdict(dict)
-	retu filter(range(1, max(keys(a:dict))), '!has_key(a:dict, v:val)')
-endf
-
-fu! s:sublist(l, s, e)
-	retu v:version > 701 ? a:l[(a:s):(a:e)] : s:sublist7071(a:l, a:s, a:e)
-endf
-
-fu! s:sublist7071(l, s, e)
-	let [newlist, id, ae] = [[], a:s, a:e == -1 ? len(a:l) - 1 : a:e]
-	wh id <= ae
-		cal add(newlist, get(a:l, id))
-		let id += 1
-	endw
-	retu newlist
-endf
-" Buffers {{{2
-fu! s:buftab(bufnr, md)
-	for tabnr in range(1, tabpagenr('$'))
-		if tabpagenr() == tabnr && a:md == 't' | con | en
-		let buflist = tabpagebuflist(tabnr)
-		if index(buflist, a:bufnr) >= 0
-			for winnr in range(1, tabpagewinnr(tabnr, '$'))
-				if buflist[winnr - 1] == a:bufnr | retu [tabnr, winnr] | en
-			endfo
-		en
-	endfo
-	retu [0, 0]
-endf
-
-fu! s:bufwins(bufnr)
-	let winns = 0
-	for tabnr in range(1, tabpagenr('$'))
-		let winns += count(tabpagebuflist(tabnr), a:bufnr)
-	endfo
-	retu winns
-endf
-
-fu! s:isabs(path)
-	if (has('win32') || has('win64'))
-		return a:path =~ '^\([a-zA-Z]:\)\{-}[/\\]'
-	el
-		return a:path =~ '^[/\\]'
-	en
-endf
-
-fu! s:bufnrfilpath(line)
-  if s:isabs(a:line) || a:line =~ '^\~[/\\]' || a:line =~ '^\w\+:\/\/'
-		let filpath = a:line
-	el
-		let filpath = s:dyncwd.s:lash().a:line
-	en
-	let filpath = fnamemodify(filpath, ':p')
-	let bufnr = bufnr('^'.fnameescape(filpath).'$')
-	if (!filereadable(filpath) && bufnr < 1)
-		if (a:line =~ '[\/]\?\[\d\+\*No Name\]$')
-			let bufnr = str2nr(matchstr(a:line, '[\/]\?\[\zs\d\+\ze\*No Name\]$'))
-			let filpath = bufnr
-		els
-			let bufnr = bufnr(a:line)
-			retu [bufnr, a:line]
-		en
-	en
-	retu [bufnr, filpath]
-endf
-
-fu! ctrlp#normcmd(cmd, ...)
-	let buftypes = [ 'quickfix', 'help', 'nofile' ]
-	if a:0 < 2 && s:nosplit() | retu a:cmd | en
-	let norwins = filter(range(1, winnr('$')),
-		\ 'index(buftypes, getbufvar(winbufnr(v:val), "&bt")) == -1 || s:isterminal(winbufnr(v:val))')
-	for each in norwins
-		let bufnr = winbufnr(each)
-		if empty(bufname(bufnr)) && empty(getbufvar(bufnr, '&ft'))
-			let fstemp = each | brea
-		en
-	endfo
-	let norwin = empty(norwins) ? 0 : norwins[0]
-	if norwin
-		if index(norwins, winnr()) < 0
-			exe ( exists('fstemp') ? fstemp : norwin ).'winc w'
-		en
-		retu a:cmd
-	en
-	retu a:0 ? a:1 : 'bo vne'
-endf
-
-fu! ctrlp#modfilecond(w)
-	retu &mod && !&hid && &bh != 'hide' && s:bufwins(bufnr('%')) == 1 && !&cf &&
-		\ ( ( !&awa && a:w ) || filewritable(fnamemodify(bufname('%'), ':p')) != 1 )
-endf
-
-fu! s:nosplit()
-	retu !empty(s:nosplit) && match([bufname('%'), &l:ft, &l:bt], s:nosplit) >= 0
-endf
-
-fu! s:setupblank()
-	setl noswf nonu nobl nowrap nolist nospell nocuc wfh
-	setl fdc=0 fdl=99 tw=0 bt=nofile bh=unload
-	if v:version > 702
-		setl nornu noudf cc=0
-	en
-	if s:has_conceal
-		setl cole=2 cocu=nc
-	en
-endf
-
-fu! s:leavepre()
-	if exists('s:bufnr') && s:bufnr == bufnr('%') | bw! | en
-	if !( exists(s:ccex) && !{s:ccex} )
-		\ && !( has('clientserver') && len(split(serverlist(), "\n")) > 1 )
-		cal ctrlp#clra()
-	en
-endf
-
-fu! s:checkbuf()
-	if !exists('s:init') && exists('s:bufnr') && s:bufnr > 0
-		exe s:bufnr.'bw!'
-	en
-endf
-
-fu! s:iscmdwin()
-	let [ermsg, v:errmsg] = [v:errmsg, '']
-	sil! noa winc p
-	sil! noa winc p
-	let [v:errmsg, ermsg] = [ermsg, v:errmsg]
-	retu ermsg =~ '^E11:'
-endf
-" Arguments {{{2
-fu! s:at(str)
-	if a:str =~ '\v^\@(cd|lc[hd]?|chd).*'
-		let str = substitute(a:str, '\v^\@(cd|lc[hd]?|chd)\s*', '', '')
-		if str == '' | retu 1 | en
-		let str = str =~ '^%:.\+' ? fnamemodify(s:crfile, str[1:]) : str
-		let path = fnamemodify(expand(str, 1), ':p')
-		if isdirectory(path)
-			if path != s:dyncwd
-				cal ctrlp#setdir(path)
-				cal ctrlp#setlines()
-			en
-			cal ctrlp#recordhist()
-			cal s:PrtClear()
-		en
-		retu 1
-	en
-	retu 0
-endf
-
-fu! s:tail()
-	if exists('s:optail') && !empty('s:optail')
-		let tailpref = s:optail !~ '^\s*+' ? ' +' : ' '
-		retu tailpref.s:optail
-	en
-	retu ''
-endf
-
-fu! s:sanstail(str)
-	let str = s:spi ?
-		\ substitute(a:str, '^\(@.*$\|\\\\\ze@\|\.\.\zs[.\/]\+$\)', '', 'g') : a:str
-	let [str, pat] = [substitute(str, '\\\\', '\', 'g'), '\([^:]\|\\:\)*$']
-	unl! s:optail
-	if str =~ '\\\@<!:'.pat
-		let s:optail = matchstr(str, '\\\@<!:\zs'.pat)
-		let str = substitute(str, '\\\@<!:'.pat, '', '')
-	en
-	retu substitute(str, '\\\ze:', '', 'g')
-endf
-
-fu! s:argmaps(md, i)
-	let roh = [
-		\ ['Open Multiple Files', '/h[i]dden/[c]lear', ['i', 'c']],
-		\ ['Create a New File', '/[r]eplace', ['r']],
-		\ ['Open Selected', '/[r]eplace', ['r', 'd', 'a']],
-		\ ]
-	if a:i == 2
-		if !buflisted(bufnr('^'.fnamemodify(ctrlp#getcline(), ':p').'$'))
-			let roh[2][1] .= '/h[i]dden'
-			let roh[2][2] += ['i']
-		en
-		if s:openfunc != {} && has_key(s:openfunc, s:ctype)
-			let roh[2][1] .= '/e[x]ternal'
-			let roh[2][2] += ['x']
-		en
-	en
-	let str = roh[a:i][0].': [t]ab/[v]ertical/[h]orizontal'.roh[a:i][1].'? '
-	retu s:choices(str, ['t', 'v', 'h'] + roh[a:i][2], 's:argmaps', [a:md, a:i])
-endf
-
-fu! s:insertstr()
-	let str = 'Insert: c[w]ord/c[f]ile/[s]earch/[v]isual/[c]lipboard/[r]egister? '
-	retu s:choices(str, ['w', 'f', 's', 'v', 'c', 'r'], 's:insertstr', [])
-endf
-
-fu! s:textdialog(str)
-	redr | echoh MoreMsg | echon a:str | echoh None
-	retu nr2char(getchar())
-endf
-
-fu! s:choices(str, choices, func, args)
-	let char = s:textdialog(a:str)
-	if index(a:choices, char) >= 0
-		retu char
-	elsei char =~# "\\v\<Esc>|\<C-c>|\<C-g>|\<C-u>|\<C-w>|\<C-[>"
-		cal s:BuildPrompt(0)
-		retu 'cancel'
-	elsei char =~# "\<CR>" && a:args != []
-		retu a:args[0]
-	en
-	retu call(a:func, a:args)
-endf
-
-fu! s:getregs()
-	let char = s:textdialog('Insert from register: ')
-	if char =~# "\\v\<Esc>|\<C-c>|\<C-g>|\<C-u>|\<C-w>|\<C-[>"
-		cal s:BuildPrompt(0)
-		retu -1
-	elsei char =~# "\<CR>"
-		retu s:getregs()
-	en
-	retu s:regisfilter(char)
-endf
-
-fu! s:regisfilter(reg)
-	retu substitute(getreg(a:reg), "[\t\n]", ' ', 'g')
-endf
-" Misc {{{2
-fu! s:modevar()
-	let s:matchtype = s:mtype()
-	let s:ispath = s:ispathitem()
-	let s:mfunc = s:mfunc()
-	let s:nolim = s:getextvar('nolim')
-	let s:dosort = s:getextvar('sort')
-	let s:spi = !s:itemtype || s:getextvar('specinput') > 0
-endf
-
-fu! s:nosort()
-	let ct = s:curtype()
-	retu s:matcher != {} || s:nolim == 1 || ( ct == 'mru' && s:mrudef )
-		\ || ( ct =~ '^\(buf\|mru\)$' && s:prompt == ['', '', ''] ) || !s:dosort
-endf
-
-fu! s:byfname()
-	retu s:curtype() != 'buf' && s:ispath && s:byfname
-endf
-
-fu! s:narrowable()
-	retu exists('s:act_add') && exists('s:matched') && s:matched != []
-		\ && exists('s:mdata') && s:mdata[:2] == [s:dyncwd, s:itemtype, s:regexp]
-		\ && s:matcher == {} && !exists('s:did_exp')
-endf
-
-fu! s:getinput(...)
-	let [prt, spi] = [s:prompt, ( a:0 ? a:1 : '' )]
-	if s:abbrev != {}
-		let gmd = has_key(s:abbrev, 'gmode') ? s:abbrev['gmode'] : ''
-		let str = ( gmd =~ 't' && !a:0 ) || spi == 'c' ? prt[0] : join(prt, '')
-		if gmd =~ 't' && gmd =~ 'k' && !a:0 && matchstr(str, '.$') =~ '\k'
-			retu join(prt, '')
-		en
-		let [pf, rz] = [( s:byfname() ? 'f' : 'p' ), ( s:regexp ? 'r' : 'z' )]
-		for dict in s:abbrev['abbrevs']
-			let dmd = has_key(dict, 'mode') ? dict['mode'] : ''
-			let pat = escape(dict['pattern'], '~')
-			if ( dmd == '' || ( dmd =~ pf && dmd =~ rz && !a:0 )
-				\ || dmd =~ '['.spi.']' ) && str =~ pat
-				let [str, s:did_exp] = [join(split(str, pat, 1), dict['expanded']), 1]
-			en
-		endfo
-		if gmd =~ 't' && !a:0
-			let prt[0] = str
-		el
-			retu str
-		en
-	en
-	retu spi == 'c' ? prt[0] : join(prt, '')
-endf
-
-fu! s:strwidth(str)
-	retu exists('*strdisplaywidth') ? strdisplaywidth(a:str) : strlen(a:str)
-endf
-
-fu! ctrlp#j2l(nr)
-	exe 'norm!' a:nr.'G'
-	sil! norm! zvzz
-endf
-
-fu! s:maxf(len)
-	retu s:maxfiles && a:len > s:maxfiles
-endf
-
-fu! s:regexfilter(str)
-	let str = a:str
-	for key in keys(s:fpats) | if str =~ key
-		let str = substitute(str, s:fpats[key], '', 'g')
-	en | endfo
-	retu str
-endf
-
-fu! s:walker(m, p, d)
-	retu a:d >= 0 ? a:p < a:m ? a:p + a:d : 0 : a:p > 0 ? a:p + a:d : a:m
-endf
-
-fu! s:delent(rfunc)
-	if a:rfunc == '' | retu | en
-	let [s:force, tbrem] = [1, []]
-	if exists('s:marked')
-		let tbrem = values(s:marked)
-		cal s:unmarksigns()
-		unl s:marked
-	en
-	if tbrem == [] && ( has('dialog_gui') || has('dialog_con') ) &&
-		\ confirm("Wipe all entries?", "&OK\n&Cancel") != 1
-		unl s:force
-		cal s:BuildPrompt(0)
-		retu
-	en
-	let g:ctrlp_lines = call(a:rfunc, [tbrem])
-	cal s:BuildPrompt(1)
-	unl s:force
-endf
-
-fu! s:delbufcond(bufnr)
-	retu getbufvar(a:bufnr, "&mod") || a:bufnr == s:crbufnr
-endf
-
-fu! s:delbuf()
-	let lines = []
-	if exists('s:marked')
-		let lines = values(s:marked)
-		cal s:unmarksigns()
-		unl s:marked
-	el
-		let lines += [ctrlp#getcline()]
-	en
-	for line in lines
-		let bufnr = s:bufnrfilpath(line)[0]
-		if (s:delbufcond(bufnr))
-			con
-		en
-		exe 'bd '. bufnr
-	endfo
-	cal s:PrtClearCache()
-endf
-
-fu! s:isterminal(buf)
-	retu getbufvar(a:buf, "&bt") == "terminal"
-endf
-" Entering & Exiting {{{2
-fu! s:getenv()
-	let [s:cwd, s:winres] = [getcwd(), [winrestcmd(), &lines, winnr('$')]]
-	let [s:crword, s:crnbword] = [expand('<cword>', 1), expand('<cWORD>', 1)]
-	let [s:crgfile, s:crline] = [expand('<cfile>', 1), getline('.')]
-	let [s:winmaxh, s:crcursor] = [min([s:mw_max, &lines]), getpos('.')]
-	let [s:crbufnr, s:crvisual] = [bufnr('%'), s:lastvisual()]
-	let s:crfile = bufname('%') == ''
-		\ ? '['.s:crbufnr.'*No Name]' : expand('%:p', 1)
-	let s:crfpath = expand('%:p:h', 1)
-	let s:mrbs = ctrlp#mrufiles#bufs()
-endf
-
-fu! s:lastvisual()
-	let cview = winsaveview()
-	let [ovreg, ovtype] = [getreg('v'), getregtype('v')]
-	let [oureg, outype] = [getreg('"'), getregtype('"')]
-	sil! norm! gV"vy
-	let selected = s:regisfilter('v')
-	cal setreg('v', ovreg, ovtype)
-	cal setreg('"', oureg, outype)
-	cal winrestview(cview)
-	retu selected
-endf
-
-fu! s:log(m)
-	if exists('g:ctrlp_log') && g:ctrlp_log | if a:m
-		let cadir = ctrlp#utils#cachedir()
-		let apd = g:ctrlp_log > 1 ? '>' : ''
-		sil! exe 'redi! >'.apd cadir.s:lash(cadir).'ctrlp.log'
-	el
-		sil! redi END
-	en | en
-endf
-
-fu! s:buffunc(e)
-	if a:e && has_key(s:buffunc, 'enter')
-		cal call(s:buffunc['enter'], [], s:buffunc)
-	elsei !a:e && has_key(s:buffunc, 'exit')
-		cal call(s:buffunc['exit'], [], s:buffunc)
-	en
-endf
-
-fu! s:openfile(cmd, fid, tail, chkmod, ...)
-	let cmd = a:cmd
-	if a:chkmod && cmd =~ '^[eb]$' && ctrlp#modfilecond(!( cmd == 'b' && &aw ))
-		let cmd = cmd == 'b' ? 'sb' : 'sp'
-	en
-	let cmd = cmd =~ '^tab' ? ctrlp#tabcount().cmd : cmd
-	let j2l = a:0 && a:1[0] ? a:1[1] : 0
-	exe cmd.( a:0 && a:1[0] ? '' : a:tail ) s:fnesc(a:fid, 'f')
-	if j2l
-		cal ctrlp#j2l(j2l)
-	en
-	if !empty(a:tail)
-		sil! norm! zvzz
-	en
-	if cmd != 'bad'
-		cal ctrlp#setlcdir()
-	en
-endf
-
-fu! ctrlp#tabcount()
-	if exists('s:tabct')
-		let tabct = s:tabct
-		let s:tabct += 1
-	elsei !type(s:tabpage)
-		let tabct = s:tabpage
-	elsei type(s:tabpage) == 1
-		let tabpos =
-			\ s:tabpage =~ 'c' ? tabpagenr() :
-			\ s:tabpage =~ 'f' ? 1 :
-			\ s:tabpage =~ 'l' ? tabpagenr('$') :
-			\ tabpagenr()
-		let tabct =
-			\ s:tabpage =~ 'a' ? tabpos :
-			\ s:tabpage =~ 'b' ? tabpos - 1 :
-			\ tabpos
-	en
-	retu tabct < 0 ? 0 : tabct
-endf
-
-fu! s:settype(type)
-	retu a:type < 0 ? exists('s:itemtype') ? s:itemtype : 0 : a:type
-endf
-" Matching {{{2
-fu! s:matchfname(item, pat)
-	let parts = split(a:item, '[\/]\ze[^\/]\+$')
-	let mfn = match(parts[-1], a:pat[0])
-	retu len(a:pat) == 1 ? mfn : len(a:pat) == 2 ?
-		\ ( mfn >= 0 && ( len(parts) == 2 ? match(parts[0], a:pat[1]) : -1 ) >= 0
-		\ ? 0 : -1 ) : -1
-endf
-
-fu! s:matchbuf(item, pat)
-	let bufnr = s:bufnrfilpath(a:item)[0]
-	let parts = s:bufparts(bufnr)
-	let item = s:byfname ? parts[2] : bufnr.parts[0].parts[2].s:lash().parts[3]
-	retu match(item, a:pat)
-endf
-
-fu! s:matchtabs(item, pat)
-	retu match(split(a:item, '\t\+')[0], a:pat)
-endf
-
-fu! s:matchtabe(item, pat)
-	retu match(split(a:item, '\t\+[^\t]\+$')[0], a:pat)
-endf
-
-fu! s:buildpat(lst)
-	let pat = a:lst[0]
-	if s:matchnatural == 1
-		for item in range(1, len(a:lst) - 1)
-			let c = a:lst[item - 1]
-			let pat .= (c == '/' ? '[^/]\{-}' : '[^'.c.'/]\{-}').a:lst[item]
-		endfo
-	els
-		for item in range(1, len(a:lst) - 1)
-			let pat .= '[^'.a:lst[item - 1].']\{-}'.a:lst[item]
-		endfo
-	en
-	retu pat
-endf
-
-fu! s:curtype()
-	return s:CurTypeName()[1]
-endf
-
-fu! s:mfunc()
-	let mfunc = 'match'
-	if s:byfname()
-		let mfunc = 's:matchfname'
-	elsei s:curtype() == 'buf'
-		let mfunc = 's:matchbuf'
-	elsei s:itemtype >= len(s:coretypes)
-		let matchtypes = { 'tabs': 's:matchtabs', 'tabe': 's:matchtabe' }
-		if has_key(matchtypes, s:matchtype)
-			let mfunc = matchtypes[s:matchtype]
-		en
-	en
-	retu mfunc
-endf
-
-fu! s:mmode()
-	let matchmodes = {
-		\ 'match': 'full-line',
-		\ 's:matchfname': 'filename-only',
-		\ 's:matchbuf': 'full-line',
-		\ 's:matchtabs': 'first-non-tab',
-		\ 's:matchtabe': 'until-last-tab',
-		\ }
-	retu matchmodes[s:mfunc]
-endf
-" Cache {{{2
-fu! s:writecache(cafile)
-	if ( g:ctrlp_newcache || !filereadable(a:cafile) ) && !s:nocache()
-		cal ctrlp#utils#writecache(g:ctrlp_allfiles)
-		let g:ctrlp_newcache = 0
-	en
-endf
-
-fu! s:nocache(...)
-	if !s:caching
-		retu 1
-	elsei s:caching > 1
-		if !( exists(s:ccex) && !{s:ccex} ) || has_key(s:ficounts, s:dyncwd)
-			retu get(s:ficounts, s:dyncwd, [0, 0])[0] < s:caching
-		elsei a:0 && filereadable(a:1)
-			retu len(ctrlp#utils#readfile(a:1)) < s:caching
-		en
-		retu 1
-	en
-	retu 0
-endf
-
-fu! s:insertcache(str)
-	let [data, g:ctrlp_newcache, str] = [g:ctrlp_allfiles, 1, a:str]
-	if data == [] || strlen(str) <= strlen(data[0])
-		let pos = 0
-	elsei strlen(str) >= strlen(data[-1])
-		let pos = len(data) - 1
-	el
-		let pos = 0
-		for each in data
-			if strlen(each) > strlen(str) | brea | en
-			let pos += 1
-		endfo
-	en
-	cal insert(data, str, pos)
-	cal s:writecache(ctrlp#utils#cachefile())
-endf
-" Extensions {{{2
-fu! s:mtype()
-	retu s:itemtype >= len(s:coretypes) ? s:getextvar('type') : 'path'
-endf
-
-fu! s:execextvar(key)
-	if !empty(g:ctrlp_ext_vars)
-		cal map(filter(copy(g:ctrlp_ext_vars),
-			\ 'has_key(v:val, a:key)'), 'eval(v:val[a:key])')
-	en
-endf
-
-fu! s:getextvar(key)
-	if s:itemtype >= len(s:coretypes) && len(g:ctrlp_ext_vars) > 0
-		let vars = g:ctrlp_ext_vars[s:itemtype - len(s:coretypes)]
-		if has_key(vars, a:key)
-			retu vars[a:key]
-		en
-	en
-	retu get(g:, 'ctrlp_' . s:matchtype . '_' . a:key, -1)
-endf
-
-fu! ctrlp#getcline()
-	let [linenr, offset] = [line('.'), ( s:offset > 0 ? s:offset : 0 )]
-	retu !empty(s:lines) && !( offset && linenr <= offset )
-		\ ? s:lines[linenr - 1 - offset] : ''
-endf
-
-fu! ctrlp#getmarkedlist()
-	retu exists('s:marked') ? values(s:marked) : []
-endf
-
-fu! ctrlp#clearmarkedlist()
-	let s:marked = {}
-endf
-
-fu! ctrlp#input()
-	retu s:getinput()
-endf
-
-fu! ctrlp#exit()
-	cal s:PrtExit()
-endf
-
-fu! ctrlp#prtclear()
-	cal s:PrtClear()
-endf
-
-fu! ctrlp#switchtype(id)
-	cal s:ToggleType(a:id - s:itemtype)
-endf
-
-fu! ctrlp#nosy()
-	retu !( has('syntax') && exists('g:syntax_on') )
-endf
-
-fu! ctrlp#hicheck(grp, defgrp)
-	if !hlexists(a:grp)
-		exe 'hi link' a:grp a:defgrp
-	en
-endf
-
-fu! ctrlp#call(func, ...)
-	retu call(a:func, a:000)
-endf
-
-fu! ctrlp#getvar(var)
-	retu {a:var}
-endf
-"}}}1
-" * Initialization {{{1
-fu! s:setlines_pre(...)
-	if a:0 | let s:itemtype = a:1 | en
-	cal s:modevar()
-	let s:setlines_post_ended = 0
-	let g:ctrlp_lines = []
-endf
-
-fu! s:setlines_post()
-	let inits = {'fil': 'ctrlp#files()', 'buf': 'ctrlp#buffers()', 'mru': 'ctrlp#mrufiles#list()'}
-	let types = map(copy(g:ctrlp_types), 'inits[v:val]')
-	if !empty(g:ctrlp_ext_vars)
-		cal map(copy(g:ctrlp_ext_vars), 'add(types, v:val["init"])')
-	en
-	let g:ctrlp_lines = eval(types[s:itemtype])
-	let s:setlines_post_ended = 1
-endf
-
-fu! ctrlp#setlines(...)
-	cal call('s:setlines_pre', a:000)
-	cal s:setlines_post()
-endf
-
-" Returns [lname, sname]
-fu! s:CurTypeName()
-	if s:itemtype < len(s:coretypes)
-		return filter(copy(s:coretypes), 'v:val[1]==g:ctrlp_types[s:itemtype]')[0]
-	el
-		return [s:getextvar("lname"), s:getextvar('sname')]
-	en
-endfu
-
-fu! s:ExitIfSingleCandidate()
-	if len(s:Update(s:prompt[0])) == 1
-		call s:AcceptSelection('e')
-		call ctrlp#exit()
-		return 1
-	en
-	return 0
-endfu
-
-fu! s:IsBuiltin()
-	let builtins = ['tag', 'dir', 'bft', 'rts', 'bkd', 'lns', 'chs', 'mix', 'udo', 'qfx']
-	let curtype = s:getextvar('sname')
-	return s:itemtype < len(s:coretypes) || index(builtins, curtype) > -1
-endfu
-
-fu! s:DetectFileType(type, ft)
-	if s:IsBuiltin() || empty(a:ft) || a:ft ==# 'ctrlp'
-		retu 'ctrlp'
-	el
-		retu 'ctrlp.' . a:ft
-	en
-endfu
-
-fu! ctrlp#init(type, ...)
-	if exists('s:init') || s:iscmdwin() | retu | en
-	let [s:ermsg, v:errmsg] = [v:errmsg, '']
-	let [s:matches, s:init] = [1, 1]
-	cal s:Reset(a:0 ? a:1 : {})
-	noa cal s:Open()
-	cal s:SetWD(a:0 ? a:1 : {})
-	cal s:MapNorms()
-	cal s:MapSpecs()
-	if empty(g:ctrlp_types) && empty(g:ctrlp_ext_vars)
-		call ctrlp#exit()
-		retu
-	en
-	if type(a:type) == 0
-		let type = a:type
-	el
-		let type = index(g:ctrlp_types, a:type)
-		if type == -1
-			call ctrlp#exit()
-			retu
-		en
-	en
-	" Fixed issue ctrlpvim/ctrlp.vim#463 : Opening 'ctrlp' in certain modes
-	" (':CtrlPBufTag', ':CtrlPLine') seems to trigger a partially deffective
-	" intialisation (for example, syntax highlighting not working as expected).
-	" Fix: ctrlp#setlines() split in two, as the second part (now in
-	" s:setlines_post()) seems to need '&filetype', and s:DetectFileType() seems
-	" to need the first part of the old ctrlp#setlines() (now in
-	" s:setlines_pre()).
-	cal s:setlines_pre(s:settype(type))
-	let &filetype = s:DetectFileType(type, &filetype)
-	cal s:setlines_post()
-	cal ctrlp#syntax()
-	cal s:SetDefTxt()
-	let curName = s:CurTypeName()
-	let shouldExitSingle = index(s:opensingle, curName[0])>=0 || index(s:opensingle, curName[1])>=0
-	if shouldExitSingle && s:ExitIfSingleCandidate()
-		return 0
-	en
-	cal s:BuildPrompt(1)
-	if s:keyloop | cal s:KeyLoop() | en
-	retu 1
-endf
-
-" - Events {{{1
-fu! s:NotifySearch()
-	let l:cb = s:getextvar('search')
-	if l:cb != -1
-		cal eval(l:cb)
-	en
-endf
-
-fu! ctrlp#update()
-	cal s:ForceUpdate()
-endf
-
-" - Autocmds {{{1
-if has('autocmd')
-	aug CtrlPAug
-		au!
-		au BufEnter ControlP cal s:checkbuf()
-		au BufLeave ControlP noa cal s:Close()
-		au VimLeavePre * cal s:leavepre()
-	aug END
-en
-
-fu! s:autocmds()
-	if !has('autocmd') | retu | en
-	if exists('#CtrlPLazy')
-		au! CtrlPLazy
-	en
-	if s:lazy
-		aug CtrlPLazy
-			au!
-			au CursorHold ControlP cal s:ForceUpdate()
-		aug END
-	en
-endf
-"}}}
-
-" vim:fen:fdm=marker:fmr={{{,}}}:fdl=0:fdc=1:ts=2:sw=2:sts=2
diff --git a/sources_non_forked/ctrlp.vim/autoload/ctrlp/autoignore.vim b/sources_non_forked/ctrlp.vim/autoload/ctrlp/autoignore.vim
deleted file mode 100644
index ec2329e..0000000
--- a/sources_non_forked/ctrlp.vim/autoload/ctrlp/autoignore.vim
+++ /dev/null
@@ -1,173 +0,0 @@
-" =============================================================================
-" File:          autoload/ctrlp/autoignore.vim
-" Description:   Auto-ignore Extension
-" Author:        Ludovic Chabant <github.com/ludovicchabant>
-" =============================================================================
-
-
-" Global Settings {{{
-
-if exists('g:ctrlp_autoignore_loaded') && g:ctrlp_autoignore_loaded
-		\ && !g:ctrlp_autoignore_debug
-	finish
-endif
-let g:ctrlp_autoignore_loaded = 1
-
-if !exists('g:ctrlp_autoignore_debug')
-	let g:ctrlp_autoignore_debug = 0
-endif
-
-if !exists('g:ctrlp_autoignore_trace')
-	let g:ctrlp_autoignore_trace = 0
-endif
-
-" }}}
-
-" Initialization {{{
-
-if !exists('g:ctrlp_custom_ignore')
-	let g:ctrlp_custom_ignore = {}
-endif
-let g:ctrlp_custom_ignore['func'] = 'ctrlp#autoignore#ignore'
-let g:ctrlp_custom_ignore['func-init'] = 'ctrlp#autoignore#ignore_init'
-let g:ctrlp_custom_ignore['func-close'] = 'ctrlp#autoignore#ignore_close'
-
-if !exists('g:ctrlp_root_markers')
-	let g:ctrlp_root_markers = []
-endif
-call add(g:ctrlp_root_markers, '.ctrlpignore')
-
-" }}}
-
-" Internals {{{
-
-function! s:trace(message) abort
-    if g:ctrlp_autoignore_trace
-        echom "ctrlp_autoignore: " . a:message
-    endif
-endfunction
-
-let s:proj_cache = {}
-let s:active_cwd = ''
-let s:active_cwd_len = 0
-let s:active_patterns = []
-let s:changed_wildignore = 0
-let s:prev_wildignore = ''
-
-function! s:load_project_patterns(root_dir) abort
-	let l:ign_path = a:root_dir . '/.ctrlpignore'
-	if !filereadable(l:ign_path)
-		call s:trace("No pattern file at: " . l:ign_path)
-		return []
-	endif
-	let l:cursyntax = 'regexp'
-	let l:knownsyntaxes = ['regexp', 'wildignore']
-	let l:patterns = []
-	let l:lines = readfile(l:ign_path)
-	for line in l:lines
-		" Comment line?
-		if match(line, '\v^\s*$') >= 0 || match(line, '\v^\s*#') >= 0
-			continue
-		endif
-		" Syntax change?
-		let l:matches = matchlist(line, '\v^syntax:\s?(\w+)\s*$')
-		if len(l:matches) > 0
-			let l:cursyntax = l:matches[1]
-			if index(l:knownsyntaxes, l:cursyntax) < 0
-				echoerr "ctrlp_autoignore: Unknown syntax '".l:cursyntax."' in: ".l:ign_path
-			endif
-			continue
-		endif
-		" Patterns!
-		let l:matches = matchlist(line, '\v^((dir|file|link)\:)?(.*)')
-		let l:mtype = l:matches[2]
-		let l:mpat = l:matches[3]
-		call add(l:patterns, {'syn': l:cursyntax, 'type': l:mtype, 'pat': l:mpat})
-	endfor
-	call s:trace("Loaded " . len(l:patterns) . " patterns from: " . l:ign_path)
-	return l:patterns
-endfunction
-
-function! s:get_project_patterns(root_dir) abort
-	let l:ign_path = a:root_dir . '/.ctrlpignore'
-	let l:ign_mtime = getftime(l:ign_path)
-	let l:patterns = get(s:proj_cache, a:root_dir)
-	if type(l:patterns) == type({})
-		" Check that these patterns are still valid.
-		if l:ign_mtime < 0
-			" File got deleted! :(
-			let l:patterns['pats'] = []
-			return l:patterns['pats']
-		elseif l:ign_mtime <= l:patterns['mtime']
-			" File hasn't changed! :)
-			return l:patterns['pats']
-		endif
-	endif
-
-	call s:trace("Loading patterns for project: " . a:root_dir)
-	let l:loaded = s:load_project_patterns(a:root_dir)
-	let s:proj_cache[a:root_dir] = {
-	\'mtime': localtime(),
-	\'pats': l:loaded}
-	return l:loaded
-endfunction
-
-" The custom ignore function that CtrlP will be using in addition to
-" normal pattern-based matching.
-function! ctrlp#autoignore#ignore(item, type) abort
-	let l:cnv_item = tr(strpart(a:item, s:active_cwd_len), "\\", "/")
-	for pat in s:active_patterns
-		if pat['syn'] != 'regexp'
-			continue
-		endif
-		if pat['type'] == '' || pat['type'] == a:type
-			if match(l:cnv_item, pat['pat']) >= 0
-				call s:trace("Ignoring ".l:cnv_item." because of ".pat['pat'])
-				return 1
-			endif
-		endif
-	endfor
-	return 0
-endfunction
-
-function! ctrlp#autoignore#ignore_init() abort
-	let l:root = getcwd()
-	let s:active_cwd = l:root
-	" len+1 is for including the next separator after the root.
-	let s:active_cwd_len = len(l:root) + 1
-	let s:active_patterns = s:get_project_patterns(l:root)
-	call s:trace("Got ".len(s:active_patterns)." patterns for ".l:root)
-
-	let s:changed_wildignore = 0
-	let s:prev_wildignore = &wildignore
-	for pat in s:active_patterns
-		if pat['syn'] == 'wildignore'
-			execute 'set wildignore+='.pat['pat']
-			let s:changed_wildignore = 1
-		endif
-	endfor
-	if s:changed_wildignore
-		call s:trace("Set wildignore to ".&wildignore)
-	endif
-endfunction
-
-function! ctrlp#autoignore#ignore_close() abort
-	if s:changed_wildignore
-		execute 'set wildignore='.s:prev_wildignore
-		let s:prev_wildignore = ''
-		call s:trace("Set wildignore back to ".&wildignore)
-	endif
-endfunction
-
-" List patterns for a given project's root.
-function! ctrlp#autoignore#get_patterns(root_dir) abort
-	let l:patterns = s:get_project_patterns(a:root_dir)
-	for pat in l:patterns
-		let l:prefix = pat['type'] == '' ? '(all)' : pat['type']
-		echom l:prefix . ':' . pat['pat']
-	endfor
-endfunction
-
-" }}}
-
-" vim:fen:fdm=marker:fmr={{{,}}}:fdl=0:fdc=1:ts=2:sw=2:sts=2
diff --git a/sources_non_forked/ctrlp.vim/autoload/ctrlp/bookmarkdir.vim b/sources_non_forked/ctrlp.vim/autoload/ctrlp/bookmarkdir.vim
deleted file mode 100644
index f7fc14d..0000000
--- a/sources_non_forked/ctrlp.vim/autoload/ctrlp/bookmarkdir.vim
+++ /dev/null
@@ -1,147 +0,0 @@
-" =============================================================================
-" File:          autoload/ctrlp/bookmarkdir.vim
-" Description:   Bookmarked directories extension
-" Author:        Kien Nguyen <github.com/kien>
-" =============================================================================
-
-" Init {{{1
-if exists('g:loaded_ctrlp_bookmarkdir') && g:loaded_ctrlp_bookmarkdir
-	fini
-en
-let g:loaded_ctrlp_bookmarkdir = 1
-
-cal add(g:ctrlp_ext_vars, {
-	\ 'init': 'ctrlp#bookmarkdir#init()',
-	\ 'accept': 'ctrlp#bookmarkdir#accept',
-	\ 'lname': 'bookmarked dirs',
-	\ 'sname': 'bkd',
-	\ 'type': 'tabs',
-	\ 'opmul': 1,
-	\ 'nolim': 1,
-	\ 'wipe': 'ctrlp#bookmarkdir#remove',
-	\ })
-
-let s:id = g:ctrlp_builtins + len(g:ctrlp_ext_vars)
-" Utilities {{{1
-fu! s:getinput(str, ...)
-	echoh Identifier
-	cal inputsave()
-	let input = call('input', a:0 ? [a:str] + a:000 : [a:str])
-	cal inputrestore()
-	echoh None
-	retu input
-endf
-
-fu! s:cachefile()
-	if !exists('s:cadir') || !exists('s:cafile')
-		let s:cadir = ctrlp#utils#cachedir().ctrlp#utils#lash().'bkd'
-		let s:cafile = s:cadir.ctrlp#utils#lash().'cache.txt'
-	en
-	retu s:cafile
-endf
-
-fu! s:writecache(lines)
-	cal ctrlp#utils#writecache(a:lines, s:cadir, s:cafile)
-endf
-
-fu! s:getbookmarks()
-	retu ctrlp#utils#readfile(s:cachefile())
-endf
-
-fu! s:savebookmark(name, cwd)
-	let cwds = exists('+ssl') ? [tr(a:cwd, '\', '/'), tr(a:cwd, '/', '\')] : [a:cwd]
-	let entries = filter(s:getbookmarks(), 'index(cwds, s:parts(v:val)[1]) < 0')
-	cal s:writecache(insert(entries, a:name.'	'.a:cwd))
-endf
-
-fu! s:setentries()
-	let time = getftime(s:cachefile())
-	if !( exists('s:bookmarks') && time == s:bookmarks[0] )
-		let s:bookmarks = [time, s:getbookmarks()]
-	en
-endf
-
-fu! s:parts(str)
-	let mlist = matchlist(a:str, '\v([^\t]+)\t(.*)$')
-	retu mlist != [] ? mlist[1:2] : ['', '']
-endf
-
-fu! s:process(entries, type)
-	retu map(a:entries, 's:modify(v:val, a:type)')
-endf
-
-fu! s:modify(entry, type)
-	let [name, dir] = s:parts(a:entry)
-	let dir = fnamemodify(dir, a:type)
-	retu name.'	'.( dir == '' ? '.' : dir )
-endf
-
-fu! s:msg(name, cwd)
-	redr
-	echoh Identifier | echon 'Bookmarked ' | echoh Constant
-	echon a:name.' ' | echoh Directory | echon a:cwd
-	echoh None
-endf
-
-fu! s:syntax()
-	if !ctrlp#nosy()
-		cal ctrlp#hicheck('CtrlPBookmark', 'Identifier')
-		cal ctrlp#hicheck('CtrlPTabExtra', 'Comment')
-		sy match CtrlPBookmark '^> [^\t]\+' contains=CtrlPLinePre
-		sy match CtrlPTabExtra '\zs\t.*\ze$'
-	en
-endf
-" Public {{{1
-fu! ctrlp#bookmarkdir#init()
-	cal s:setentries()
-	cal s:syntax()
-	retu s:process(copy(s:bookmarks[1]), ':.')
-endf
-
-fu! ctrlp#bookmarkdir#accept(mode, str)
-	let parts = s:parts(s:modify(a:str, ':p'))
-	cal call('s:savebookmark', parts)
-	if a:mode =~ 't\|v\|h'
-		cal ctrlp#exit()
-	en
-	cal ctrlp#setdir(parts[1], a:mode =~ 't\|h' ? 'chd!' : 'lc!')
-	if a:mode == 'e'
-		cal ctrlp#switchtype(0)
-		cal ctrlp#recordhist()
-		cal ctrlp#prtclear()
-	en
-endf
-
-fu! ctrlp#bookmarkdir#add(bang, dir, ...)
-	let ctrlp_tilde_homedir = get(g:, 'ctrlp_tilde_homedir', 0)
-	let cwd = fnamemodify(getcwd(), ctrlp_tilde_homedir ? ':p:~' : ':p')
-	let dir = fnamemodify(a:dir, ctrlp_tilde_homedir ? ':p:~' : ':p')
-	if a:bang == '!'
-		let cwd = dir != '' ? dir : cwd
-		let name = a:0 && a:1 != '' ? a:1 : cwd
-	el
-		let str = 'Directory to bookmark: '
-		let cwd = dir != '' ? dir : s:getinput(str, cwd, 'dir')
-		if cwd == '' | retu | en
-		let name = a:0 && a:1 != '' ? a:1 : s:getinput('Bookmark as: ', cwd)
-		if name == '' | retu | en
-	en
-	let name = tr(name, '	', ' ')
-	cal s:savebookmark(name, cwd)
-	cal s:msg(name, cwd)
-endf
-
-fu! ctrlp#bookmarkdir#remove(entries)
-	cal s:process(a:entries, ':p')
-	cal s:writecache(a:entries == [] ? [] :
-		\ filter(s:getbookmarks(), 'index(a:entries, v:val) < 0'))
-	cal s:setentries()
-	retu s:process(copy(s:bookmarks[1]), ':.')
-endf
-
-fu! ctrlp#bookmarkdir#id()
-	retu s:id
-endf
-"}}}
-
-" vim:fen:fdm=marker:fmr={{{,}}}:fdl=0:fdc=1:ts=2:sw=2:sts=2
diff --git a/sources_non_forked/ctrlp.vim/autoload/ctrlp/buffertag.vim b/sources_non_forked/ctrlp.vim/autoload/ctrlp/buffertag.vim
deleted file mode 100644
index f36a5cf..0000000
--- a/sources_non_forked/ctrlp.vim/autoload/ctrlp/buffertag.vim
+++ /dev/null
@@ -1,277 +0,0 @@
-" =============================================================================
-" File:          autoload/ctrlp/buffertag.vim
-" Description:   Buffer Tag extension
-" Maintainer:    Kien Nguyen <github.com/kien>
-" Credits:       Much of the code was taken from tagbar.vim by Jan Larres, plus
-"                a few lines from taglist.vim by Yegappan Lakshmanan and from
-"                buffertag.vim by Takeshi Nishida.
-" =============================================================================
-
-" Init {{{1
-if exists('g:loaded_ctrlp_buftag') && g:loaded_ctrlp_buftag
-	fini
-en
-let g:loaded_ctrlp_buftag = 1
-
-cal add(g:ctrlp_ext_vars, {
-	\ 'init': 'ctrlp#buffertag#init(s:crfile)',
-	\ 'accept': 'ctrlp#buffertag#accept',
-	\ 'lname': 'buffer tags',
-	\ 'sname': 'bft',
-	\ 'exit': 'ctrlp#buffertag#exit()',
-	\ 'type': 'tabs',
-	\ 'opts': 'ctrlp#buffertag#opts()',
-	\ })
-
-let s:id = g:ctrlp_builtins + len(g:ctrlp_ext_vars)
-
-let [s:pref, s:opts] = ['g:ctrlp_buftag_', {
-	\ 'systemenc': ['s:enc', &enc],
-	\ 'ctags_bin': ['s:bin', ''],
-	\ 'types': ['s:usr_types', {}],
-	\ }]
-
-let s:bins = [
-	\ 'ctags-exuberant',
-	\ 'exuberant-ctags',
-	\ 'exctags',
-	\ '/usr/local/bin/ctags',
-	\ '/opt/local/bin/ctags',
-	\ 'ctags',
-	\ 'ctags.exe',
-	\ 'tags',
-	\ ]
-
-let s:types = {
-	\ 'ant'    : '%sant%sant%spt',
-	\ 'asm'    : '%sasm%sasm%sdlmt',
-	\ 'aspperl': '%sasp%sasp%sfsv',
-	\ 'aspvbs' : '%sasp%sasp%sfsv',
-	\ 'awk'    : '%sawk%sawk%sf',
-	\ 'beta'   : '%sbeta%sbeta%sfsv',
-	\ 'c'      : '%sc%sc%sdgsutvf',
-	\ 'cpp'    : '%sc++%sc++%snvdtcgsuf',
-	\ 'cs'     : '%sc#%sc#%sdtncEgsipm',
-	\ 'cobol'  : '%scobol%scobol%sdfgpPs',
-	\ 'delphi' : '%spascal%spascal%sfp',
-	\ 'dosbatch': '%sdosbatch%sdosbatch%slv',
-	\ 'eiffel' : '%seiffel%seiffel%scf',
-	\ 'erlang' : '%serlang%serlang%sdrmf',
-	\ 'expect' : '%stcl%stcl%scfp',
-	\ 'fortran': '%sfortran%sfortran%spbceiklmntvfs',
-	\ 'go'     : '%sgo%sgo%sfctv',
-	\ 'html'   : '%shtml%shtml%saf',
-	\ 'java'   : '%sjava%sjava%spcifm',
-	\ 'javascript': '%sjavascript%sjavascript%sf',
-	\ 'lisp'   : '%slisp%slisp%sf',
-	\ 'lua'    : '%slua%slua%sf',
-	\ 'make'   : '%smake%smake%sm',
-	\ 'matlab' : '%smatlab%smatlab%sf',
-	\ 'ocaml'  : '%socaml%socaml%scmMvtfCre',
-	\ 'pascal' : '%spascal%spascal%sfp',
-	\ 'perl'   : '%sperl%sperl%sclps',
-	\ 'php'    : '%sphp%sphp%scdvf',
-	\ 'python' : '%spython%spython%scmf',
-	\ 'rexx'   : '%srexx%srexx%ss',
-	\ 'ruby'   : '%sruby%sruby%scfFm',
-	\ 'rust'   : '%srust%srust%sfTgsmctid',
-	\ 'scheme' : '%sscheme%sscheme%ssf',
-	\ 'sh'     : '%ssh%ssh%sf',
-	\ 'csh'    : '%ssh%ssh%sf',
-	\ 'zsh'    : '%ssh%ssh%sf',
-	\ 'scala'  : '%sscala%sscala%sctTmlp',
-	\ 'slang'  : '%sslang%sslang%snf',
-	\ 'sml'    : '%ssml%ssml%secsrtvf',
-	\ 'sql'    : '%ssql%ssql%scFPrstTvfp',
-	\ 'tex'    : '%stex%stex%sipcsubPGl',
-	\ 'tcl'    : '%stcl%stcl%scfmp',
-	\ 'vera'   : '%svera%svera%scdefgmpPtTvx',
-	\ 'verilog': '%sverilog%sverilog%smcPertwpvf',
-	\ 'vhdl'   : '%svhdl%svhdl%sPctTrefp',
-	\ 'vim'    : '%svim%svim%savf',
-	\ 'yacc'   : '%syacc%syacc%sl',
-	\ }
-
-cal map(s:types, 'printf(v:val, "--language-force=", " --", "-types=")')
-
-if executable('jsctags')
-	cal extend(s:types, { 'javascript': { 'args': '-f -', 'bin': 'jsctags' } })
-en
-
-fu! ctrlp#buffertag#opts()
-	for [ke, va] in items(s:opts)
-		let {va[0]} = exists(s:pref.ke) ? {s:pref.ke} : va[1]
-	endfo
-	" Ctags bin
-	if empty(s:bin)
-		for bin in s:bins | if executable(bin)
-			let s:bin = bin
-			brea
-		en | endfo
-	el
-		let s:bin = expand(s:bin, 1)
-	en
-	" Types
-	cal extend(s:types, s:usr_types)
-endf
-" Utilities {{{1
-fu! s:validfile(fname, ftype)
-	if ( !empty(a:fname) || !empty(a:ftype) ) && filereadable(a:fname)
-		\ && index(keys(s:types), a:ftype) >= 0 | retu 1 | en
-	retu 0
-endf
-
-fu! s:exectags(cmd)
-	if exists('+ssl')
-		let [ssl, &ssl] = [&ssl, 0]
-	en
-	if &sh =~ 'cmd\.exe'
-		let [sxq, &sxq, shcf, &shcf] = [&sxq, '"', &shcf, '/s /c']
-	en
-	let output = system(a:cmd)
-	if &sh =~ 'cmd\.exe'
-		let [&sxq, &shcf] = [sxq, shcf]
-	en
-	if exists('+ssl')
-		let &ssl = ssl
-	en
-	retu output
-endf
-
-fu! s:exectagsonfile(fname, ftype)
-	let [ags, ft] = ['-f - --sort=no --excmd=pattern --fields=nKs --extra= --file-scope=yes ', a:ftype]
-	if type(s:types[ft]) == 1
-		let ags .= s:types[ft]
-		let bin = s:bin
-	elsei type(s:types[ft]) == 4
-		let ags = s:types[ft]['args']
-		let bin = expand(s:types[ft]['bin'], 1)
-	en
-	if empty(bin) | retu '' | en
-	let cmd = s:esctagscmd(bin, ags, a:fname)
-	if empty(cmd) | retu '' | en
-	let output = s:exectags(cmd)
-	if v:shell_error || output =~ 'Warning: cannot open' | retu '' | en
-	retu output
-endf
-
-fu! s:esctagscmd(bin, args, ...)
-	if exists('+ssl')
-		let [ssl, &ssl] = [&ssl, 0]
-	en
-	let fname = a:0 ? shellescape(a:1) : ''
-	if  (has('win32') || has('win64'))
-		let cmd = a:bin.' '.a:args.' '.fname
-	else
-		let cmd = shellescape(a:bin).' '.a:args.' '.fname
-	endif
-	if &sh =~ 'cmd\.exe'
-		let cmd = substitute(cmd, '[&()@^<>|]', '^\0', 'g')
-	en
-	if exists('+ssl')
-		let &ssl = ssl
-	en
-	if has('iconv')
-		let last = s:enc != &enc ? s:enc : !empty( $LANG ) ? $LANG : &enc
-		let cmd = iconv(cmd, &enc, last)
-	en
-	retu cmd
-endf
-
-fu! s:process(fname, ftype)
-	if !s:validfile(a:fname, a:ftype) | retu [] | endif
-	let ftime = getftime(a:fname)
-	if has_key(g:ctrlp_buftags, a:fname)
-		\ && g:ctrlp_buftags[a:fname]['time'] >= ftime
-		let lines = g:ctrlp_buftags[a:fname]['lines']
-	el
-		let data = s:exectagsonfile(a:fname, a:ftype)
-		let [raw, lines] = [split(data, '\n\+'), []]
-		for line in raw
-			if line !~# '^!_TAG_' && len(split(line, ';"')) == 2
-				let parsed_line = s:parseline(line)
-				if parsed_line != ''
-					cal add(lines, parsed_line)
-				en
-			en
-		endfo
-		let cache = { a:fname : { 'time': ftime, 'lines': lines } }
-		cal extend(g:ctrlp_buftags, cache)
-	en
-	retu lines
-endf
-
-fu! s:parseline(line)
-	let vals = matchlist(a:line,
-		\ '\v^([^\t]+)\t(.+)\t[?/]\^?(.{-1,})\$?[?/]\;\"\t(.+)\tline(no)?\:(\d+)')
-	if vals == [] | retu '' | en
-	let [bufnr, bufname] = [bufnr('^'.vals[2].'$'), fnamemodify(vals[2], ':p:t')]
-	retu vals[1].'	'.vals[4].'|'.bufnr.':'.bufname.'|'.vals[6].'| '.vals[3]
-endf
-
-fu! s:syntax()
-	if !ctrlp#nosy()
-		cal ctrlp#hicheck('CtrlPTagKind', 'Title')
-		cal ctrlp#hicheck('CtrlPBufName', 'Directory')
-		cal ctrlp#hicheck('CtrlPTabExtra', 'Comment')
-		sy match CtrlPTagKind '\zs[^\t|]\+\ze|\d\+:[^|]\+|\d\+|'
-		sy match CtrlPBufName '|\d\+:\zs[^|]\+\ze|\d\+|'
-		sy match CtrlPTabExtra '\zs\t.*\ze$' contains=CtrlPBufName,CtrlPTagKind
-	en
-endf
-
-fu! s:chknearby(pat)
-	if match(getline('.'), a:pat) < 0
-		let [int, forw, maxl] = [1, 1, line('$')]
-		wh !search(a:pat, 'W'.( forw ? '' : 'b' ))
-			if !forw
-				if int > maxl | brea | en
-				let int += int
-			en
-			let forw = !forw
-		endw
-	en
-endf
-" Public {{{1
-fu! ctrlp#buffertag#init(fname)
-	let bufs = exists('s:btmode') && s:btmode
-		\ ? filter(ctrlp#buffers(), 'filereadable(v:val)')
-		\ : [exists('s:bufname') ? s:bufname : a:fname]
-	let lines = []
-	for each in bufs
-		let bname = fnamemodify(each, ':p')
-		let tftype = get(split(getbufvar('^'.bname.'$', '&ft'), '\.'), 0, '')
-		cal extend(lines, s:process(bname, tftype))
-	endfo
-	cal s:syntax()
-	retu lines
-endf
-
-fu! ctrlp#buffertag#accept(mode, str)
-	let vals = matchlist(a:str,
-		\ '\v^[^\t]+\t+[^\t|]+\|(\d+)\:[^\t|]+\|(\d+)\|\s(.+)$')
-	let bufnr = str2nr(get(vals, 1))
-	if bufnr
-		cal ctrlp#acceptfile(a:mode, bufnr)
-		exe 'norm!' str2nr(get(vals, 2, line('.'))).'G'
-		cal s:chknearby('\V\C'.get(vals, 3, ''))
-		sil! norm! zvzz
-	en
-endf
-
-fu! ctrlp#buffertag#cmd(mode, ...)
-	let s:btmode = a:mode
-	if a:0 && !empty(a:1)
-		let s:btmode = 0
-		let bname = a:1 =~# '^%$\|^#\d*$' ? expand(a:1) : a:1
-		let s:bufname = fnamemodify(bname, ':p')
-	en
-	retu s:id
-endf
-
-fu! ctrlp#buffertag#exit()
-	unl! s:btmode s:bufname
-endf
-"}}}
-
-" vim:fen:fdm=marker:fmr={{{,}}}:fdl=0:fdc=1:ts=2:sw=2:sts=2
diff --git a/sources_non_forked/ctrlp.vim/autoload/ctrlp/changes.vim b/sources_non_forked/ctrlp.vim/autoload/ctrlp/changes.vim
deleted file mode 100644
index 313d8c2..0000000
--- a/sources_non_forked/ctrlp.vim/autoload/ctrlp/changes.vim
+++ /dev/null
@@ -1,98 +0,0 @@
-" =============================================================================
-" File:          autoload/ctrlp/changes.vim
-" Description:   Change list extension
-" Author:        Kien Nguyen <github.com/kien>
-" =============================================================================
-
-" Init {{{1
-if exists('g:loaded_ctrlp_changes') && g:loaded_ctrlp_changes
-	fini
-en
-let g:loaded_ctrlp_changes = 1
-
-cal add(g:ctrlp_ext_vars, {
-	\ 'init': 'ctrlp#changes#init(s:bufnr, s:crbufnr)',
-	\ 'accept': 'ctrlp#changes#accept',
-	\ 'lname': 'changes',
-	\ 'sname': 'chs',
-	\ 'exit': 'ctrlp#changes#exit()',
-	\ 'type': 'tabe',
-	\ 'sort': 0,
-	\ 'nolim': 1,
-	\ })
-
-let s:id = g:ctrlp_builtins + len(g:ctrlp_ext_vars)
-" Utilities {{{1
-fu! s:changelist(bufnr)
-	sil! exe 'noa hid b' a:bufnr
-	redi => result
-	sil! changes
-	redi END
-	retu map(split(result, "\n")[1:], 'tr(v:val, "	", " ")')
-endf
-
-fu! s:process(clines, ...)
-	let [clines, evas] = [[], []]
-	for each in a:clines
-		let parts = matchlist(each, '\v^.\s*\d+\s+(\d+)\s+(\d+)\s(.*)$')
-		if !empty(parts)
-			if parts[3] == '' | let parts[3] = ' ' | en
-			cal add(clines, parts[3].'	|'.a:1.':'.a:2.'|'.parts[1].':'.parts[2].'|')
-		en
-	endfo
-	retu reverse(filter(clines, 'count(clines, v:val) == 1'))
-endf
-
-fu! s:syntax()
-	if !ctrlp#nosy()
-		cal ctrlp#hicheck('CtrlPBufName', 'Directory')
-		cal ctrlp#hicheck('CtrlPTabExtra', 'Comment')
-		sy match CtrlPBufName '\t|\d\+:\zs[^|]\+\ze|\d\+:\d\+|$'
-		sy match CtrlPTabExtra '\zs\t.*\ze$' contains=CtrlPBufName
-	en
-endf
-" Public {{{1
-fu! ctrlp#changes#init(original_bufnr, bufnr)
-	let bufnr = exists('s:bufnr') ? s:bufnr : a:bufnr
-	let bufs = exists('s:clmode') && s:clmode ? ctrlp#buffers('id') : [bufnr]
-	cal filter(bufs, 'v:val > 0')
-	let [swb, &swb] = [&swb, '']
-	let lines = []
-	for each in bufs
-		let bname = bufname(each)
-		let fnamet = fnamemodify(bname == '' ? '[No Name]' : bname, ':t')
-		cal extend(lines, s:process(s:changelist(each), each, fnamet))
-	endfo
-	sil! exe 'noa hid b' a:original_bufnr
-	let &swb = swb
-	cal ctrlp#syntax()
-	cal s:syntax()
-	retu lines
-endf
-
-fu! ctrlp#changes#accept(mode, str)
-	let info = matchlist(a:str, '\t|\(\d\+\):[^|]\+|\(\d\+\):\(\d\+\)|$')
-	let bufnr = str2nr(get(info, 1))
-	if bufnr
-		cal ctrlp#acceptfile(a:mode, bufnr)
-		cal cursor(get(info, 2), get(info, 3))
-		sil! norm! zvzz
-	en
-endf
-
-fu! ctrlp#changes#cmd(mode, ...)
-	let s:clmode = a:mode
-	if a:0 && !empty(a:1)
-		let s:clmode = 0
-		let bname = a:1 =~# '^%$\|^#\d*$' ? expand(a:1) : a:1
-		let s:bufnr = bufnr('^'.fnamemodify(bname, ':p').'$')
-	en
-	retu s:id
-endf
-
-fu! ctrlp#changes#exit()
-	unl! s:clmode s:bufnr
-endf
-"}}}
-
-" vim:fen:fdm=marker:fmr={{{,}}}:fdl=0:fdc=1:ts=2:sw=2:sts=2
diff --git a/sources_non_forked/ctrlp.vim/autoload/ctrlp/dir.vim b/sources_non_forked/ctrlp.vim/autoload/ctrlp/dir.vim
deleted file mode 100644
index 4e6d4ad..0000000
--- a/sources_non_forked/ctrlp.vim/autoload/ctrlp/dir.vim
+++ /dev/null
@@ -1,95 +0,0 @@
-" =============================================================================
-" File:          autoload/ctrlp/dir.vim
-" Description:   Directory extension
-" Author:        Kien Nguyen <github.com/kien>
-" =============================================================================
-
-" Init {{{1
-if exists('g:loaded_ctrlp_dir') && g:loaded_ctrlp_dir
-	fini
-en
-let [g:loaded_ctrlp_dir, g:ctrlp_newdir] = [1, 0]
-
-let s:ars = ['s:maxdepth', 's:maxfiles', 's:compare_lim', 's:glob', 's:caching']
-
-cal add(g:ctrlp_ext_vars, {
-	\ 'init': 'ctrlp#dir#init('.join(s:ars, ', ').')',
-	\ 'accept': 'ctrlp#dir#accept',
-	\ 'lname': 'dirs',
-	\ 'sname': 'dir',
-	\ 'type': 'path',
-	\ 'specinput': 1,
-	\ })
-
-let s:id = g:ctrlp_builtins + len(g:ctrlp_ext_vars)
-
-let s:dircounts = {}
-" Utilities {{{1
-fu! s:globdirs(dirs, depth)
-	let entries = split(globpath(a:dirs, s:glob), "\n")
-	let [dirs, depth] = [ctrlp#dirnfile(entries)[0], a:depth + 1]
-	cal extend(g:ctrlp_alldirs, dirs)
-	let nr = len(g:ctrlp_alldirs)
-	if !empty(dirs) && !s:max(nr, s:maxfiles) && depth <= s:maxdepth
-		sil! cal ctrlp#progress(nr)
-		cal map(dirs, 'ctrlp#utils#fnesc(v:val, "g", ",")')
-		cal s:globdirs(join(dirs, ','), depth)
-	en
-endf
-
-fu! s:max(len, max)
-	retu a:max && a:len > a:max
-endf
-
-fu! s:nocache()
-	retu !s:caching || ( s:caching > 1 && get(s:dircounts, s:cwd) < s:caching )
-endf
-" Public {{{1
-fu! ctrlp#dir#init(...)
-	let s:cwd = getcwd()
-	for each in range(len(s:ars))
-		let {s:ars[each]} = a:{each + 1}
-	endfo
-	let cadir = ctrlp#utils#cachedir().ctrlp#utils#lash().'dir'
-	let cafile = cadir.ctrlp#utils#lash().ctrlp#utils#cachefile('dir')
-	if g:ctrlp_newdir || s:nocache() || !filereadable(cafile)
-		let [s:initcwd, g:ctrlp_alldirs] = [s:cwd, []]
-		if !ctrlp#igncwd(s:cwd)
-			cal s:globdirs(ctrlp#utils#fnesc(s:cwd, 'g', ','), 0)
-		en
-		cal ctrlp#rmbasedir(g:ctrlp_alldirs)
-		if len(g:ctrlp_alldirs) <= s:compare_lim
-			cal sort(g:ctrlp_alldirs, 'ctrlp#complen')
-		en
-		cal ctrlp#utils#writecache(g:ctrlp_alldirs, cadir, cafile)
-		let g:ctrlp_newdir = 0
-	el
-		if !( exists('s:initcwd') && s:initcwd == s:cwd )
-			let s:initcwd = s:cwd
-			let g:ctrlp_alldirs = ctrlp#utils#readfile(cafile)
-		en
-	en
-	cal extend(s:dircounts, { s:cwd : len(g:ctrlp_alldirs) })
-	retu g:ctrlp_alldirs
-endf
-
-fu! ctrlp#dir#accept(mode, str)
-	let path = a:mode == 'h' ? getcwd() : s:cwd.ctrlp#call('s:lash', s:cwd).a:str
-	if a:mode =~ 't\|v\|h'
-		cal ctrlp#exit()
-	en
-	cal ctrlp#setdir(path, a:mode =~ 't\|h' ? 'chd!' : 'lc!')
-	if a:mode == 'e'
-		sil! cal ctrlp#statusline()
-		cal ctrlp#setlines(s:id)
-		cal ctrlp#recordhist()
-		cal ctrlp#prtclear()
-	en
-endf
-
-fu! ctrlp#dir#id()
-	retu s:id
-endf
-"}}}
-
-" vim:fen:fdm=marker:fmr={{{,}}}:fdl=0:fdc=1:ts=2:sw=2:sts=2
diff --git a/sources_non_forked/ctrlp.vim/autoload/ctrlp/line.vim b/sources_non_forked/ctrlp.vim/autoload/ctrlp/line.vim
deleted file mode 100644
index f5ab83e..0000000
--- a/sources_non_forked/ctrlp.vim/autoload/ctrlp/line.vim
+++ /dev/null
@@ -1,81 +0,0 @@
-" =============================================================================
-" File:          autoload/ctrlp/line.vim
-" Description:   Line extension
-" Author:        Kien Nguyen <github.com/kien>
-" =============================================================================
-
-" Init {{{1
-if exists('g:loaded_ctrlp_line') && g:loaded_ctrlp_line
-	fini
-en
-let g:loaded_ctrlp_line = 1
-
-cal add(g:ctrlp_ext_vars, {
-	\ 'init': 'ctrlp#line#init(s:crbufnr)',
-	\ 'accept': 'ctrlp#line#accept',
-	\ 'act_farg' : 'dict',
-	\ 'lname': 'lines',
-	\ 'sname': 'lns',
-	\ 'type': 'tabe',
-	\ })
-
-let s:id = g:ctrlp_builtins + len(g:ctrlp_ext_vars)
-" Utilities {{{1
-fu! s:syntax()
-	if !ctrlp#nosy()
-		cal ctrlp#hicheck('CtrlPBufName', 'Directory')
-		cal ctrlp#hicheck('CtrlPTabExtra', 'Comment')
-		sy match CtrlPBufName '\t|\zs[^|]\+\ze|\d\+:\d\+|$'
-		sy match CtrlPTabExtra '\zs\t.*\ze$' contains=CtrlPBufName
-	en
-endf
-" Public {{{1
-fu! ctrlp#line#init(bufnr)
-	let [lines, bufnr] = [[], exists('s:bufnr') ? s:bufnr : a:bufnr]
-	let bufs = exists('s:lnmode') && !empty(s:lnmode) ? ctrlp#buffers('id') : [bufnr]
-	for bufnr in bufs
-		let [lfb, bufn] = [getbufline(bufnr, 1, '$'), bufname(bufnr)]
-		if lfb == [] && bufn != ''
-			let lfb = ctrlp#utils#readfile(fnamemodify(bufn, ':p'))
-		en
-		cal map(lfb, 'tr(v:val, ''	'', '' '')')
-		let [linenr, len_lfb] = [1, len(lfb)]
-		let buft = bufn == '' ? '[No Name]' : fnamemodify(bufn, ':t')
-		wh linenr <= len_lfb
-			let lfb[linenr - 1] .= '	|'.buft.'|'.bufnr.':'.linenr.'|'
-			let linenr += 1
-		endw
-		cal extend(lines, filter(lfb, 'v:val !~ ''^\s*\t|[^|]\+|\d\+:\d\+|$'''))
-	endfo
-	cal s:syntax()
-	retu lines
-endf
-
-fu! ctrlp#line#accept(dict)
-	let mode = a:dict['action']
-	let str = a:dict['line']
-	let input = a:dict['input']
-	let info = matchlist(str, '\t|[^|]\+|\(\d\+\):\(\d\+\)|$')
-	let bufnr = str2nr(get(info, 1))
-	if bufnr
-		cal ctrlp#acceptfile(mode, bufnr, get(info, 2))
-		if !empty(input)
-			let @/ = input
-			call search(input, 'c')
-			call histadd("search", input)
-		en
-	en
-endf
-
-fu! ctrlp#line#cmd(mode, ...)
-	let s:lnmode = a:mode
-	if a:0 && !empty(a:1)
-		let s:lnmode = 0
-		let bname = a:1 =~# '^%$\|^#\d*$' ? expand(a:1) : a:1
-		let s:bufnr = bufnr('^'.fnamemodify(bname, ':p').'$')
-	en
-	retu s:id
-endf
-"}}}
-
-" vim:fen:fdm=marker:fmr={{{,}}}:fdl=0:fdc=1:ts=2:sw=2:sts=2
diff --git a/sources_non_forked/ctrlp.vim/autoload/ctrlp/mixed.vim b/sources_non_forked/ctrlp.vim/autoload/ctrlp/mixed.vim
deleted file mode 100644
index 74d904d..0000000
--- a/sources_non_forked/ctrlp.vim/autoload/ctrlp/mixed.vim
+++ /dev/null
@@ -1,88 +0,0 @@
-" =============================================================================
-" File:          autoload/ctrlp/mixed.vim
-" Description:   Mixing Files + MRU + Buffers
-" Author:        Kien Nguyen <github.com/kien>
-" =============================================================================
-
-" Init {{{1
-if exists('g:loaded_ctrlp_mixed') && g:loaded_ctrlp_mixed
-	fini
-en
-let [g:loaded_ctrlp_mixed, g:ctrlp_newmix] = [1, 0]
-
-cal add(g:ctrlp_ext_vars, {
-	\ 'init': 'ctrlp#mixed#init(s:compare_lim)',
-	\ 'accept': 'ctrlp#acceptfile',
-	\ 'lname': 'fil + mru + buf',
-	\ 'sname': 'mix',
-	\ 'type': 'path',
-	\ 'opmul': 1,
-	\ 'specinput': 1,
-	\ })
-
-let s:id = g:ctrlp_builtins + len(g:ctrlp_ext_vars)
-" Utilities {{{1
-fu! s:newcache(cwd)
-	if g:ctrlp_newmix || !has_key(g:ctrlp_allmixes, 'data') | retu 1 | en
-	retu g:ctrlp_allmixes['cwd'] != a:cwd
-		\ || g:ctrlp_allmixes['filtime'] < getftime(ctrlp#utils#cachefile())
-		\ || g:ctrlp_allmixes['mrutime'] < getftime(ctrlp#mrufiles#cachefile())
-		\ || g:ctrlp_allmixes['bufs'] < len(ctrlp#mrufiles#bufs())
-endf
-
-fu! s:getnewmix(cwd, clim)
-	if g:ctrlp_newmix
-		cal ctrlp#mrufiles#refresh('raw')
-		let g:ctrlp_newcache = 1
-	en
-	let g:ctrlp_lines = copy(ctrlp#files())
-	cal ctrlp#progress('Mixing...')
-	let mrufs = copy(ctrlp#mrufiles#list('raw'))
-	if exists('+ssl') && &ssl
-		cal map(mrufs, 'tr(v:val, "\\", "/")')
-	en
-	let allbufs = map(ctrlp#buffers(), 'fnamemodify(v:val, ":p")')
-	let [bufs, ubufs] = [[], []]
-	for each in allbufs
-		cal add(filereadable(each) ? bufs : ubufs, each)
-	endfo
-	let mrufs = bufs + filter(mrufs, 'index(bufs, v:val) < 0')
-	if len(mrufs) > len(g:ctrlp_lines)
-		cal filter(mrufs, 'stridx(v:val, a:cwd)')
-	el
-		let cwd_mrufs = filter(copy(mrufs), '!stridx(v:val, a:cwd)')
-		let cwd_mrufs = ctrlp#rmbasedir(cwd_mrufs)
-		for each in cwd_mrufs
-			let id = index(g:ctrlp_lines, each)
-			if id >= 0 | cal remove(g:ctrlp_lines, id) | en
-		endfo
-	en
-	let mrufs += ubufs
-	cal map(mrufs, 'fnamemodify(v:val, ":.")')
-	let g:ctrlp_lines = len(mrufs) > len(g:ctrlp_lines)
-		\ ? g:ctrlp_lines + mrufs : mrufs + g:ctrlp_lines
-	if len(g:ctrlp_lines) <= a:clim
-		cal sort(g:ctrlp_lines, 'ctrlp#complen')
-	en
-	let g:ctrlp_allmixes = { 'filtime': getftime(ctrlp#utils#cachefile()),
-		\ 'mrutime': getftime(ctrlp#mrufiles#cachefile()), 'cwd': a:cwd,
-		\ 'bufs': len(ctrlp#mrufiles#bufs()), 'data': g:ctrlp_lines }
-endf
-" Public {{{1
-fu! ctrlp#mixed#init(clim)
-	let cwd = getcwd()
-	if s:newcache(cwd)
-		cal s:getnewmix(cwd, a:clim)
-	el
-		let g:ctrlp_lines = g:ctrlp_allmixes['data']
-	en
-	let g:ctrlp_newmix = 0
-	retu g:ctrlp_lines
-endf
-
-fu! ctrlp#mixed#id()
-	retu s:id
-endf
-"}}}
-
-" vim:fen:fdm=marker:fmr={{{,}}}:fdl=0:fdc=1:ts=2:sw=2:sts=2
diff --git a/sources_non_forked/ctrlp.vim/autoload/ctrlp/mrufiles.vim b/sources_non_forked/ctrlp.vim/autoload/ctrlp/mrufiles.vim
deleted file mode 100644
index 32473da..0000000
--- a/sources_non_forked/ctrlp.vim/autoload/ctrlp/mrufiles.vim
+++ /dev/null
@@ -1,158 +0,0 @@
-" =============================================================================
-" File:          autoload/ctrlp/mrufiles.vim
-" Description:   Most Recently Used Files extension
-" Author:        Kien Nguyen <github.com/kien>
-" =============================================================================
-
-" Static variables {{{1
-let [s:mrbs, s:mrufs] = [[], []]
-let s:mruf_map_string = '!stridx(v:val, cwd) ? strpart(v:val, idx) : v:val'
-
-fu! ctrlp#mrufiles#opts()
-	let [pref, opts] = ['g:ctrlp_mruf_', {
-		\ 'max': ['s:max', 250],
-		\ 'include': ['s:in', ''],
-		\ 'exclude': ['s:ex', ''],
-		\ 'case_sensitive': ['s:cseno', 1],
-		\ 'relative': ['s:re', 0],
-		\ 'save_on_update': ['s:soup', 1],
-		\ 'map_string': ['g:ctrlp_mruf_map_string', s:mruf_map_string],
-		\ }]
-	for [ke, va] in items(opts)
-		let [{va[0]}, {pref.ke}] = [pref.ke, exists(pref.ke) ? {pref.ke} : va[1]]
-	endfo
-endf
-cal ctrlp#mrufiles#opts()
-" Utilities {{{1
-fu! s:excl(fn)
-	retu !empty({s:ex}) && a:fn =~# {s:ex}
-endf
-
-fu! s:mergelists()
-	let diskmrufs = ctrlp#utils#readfile(ctrlp#mrufiles#cachefile())
-	cal filter(diskmrufs, 'index(s:mrufs, v:val) < 0')
-	let mrufs = s:mrufs + diskmrufs
-	retu s:chop(mrufs)
-endf
-
-fu! s:chop(mrufs)
-	if len(a:mrufs) > {s:max} | cal remove(a:mrufs, {s:max}, -1) | en
-	retu a:mrufs
-endf
-
-fu! s:reformat(mrufs, ...)
-	let cwd = getcwd()
-	let cwd .= cwd !~ '[\/]$' ? ctrlp#utils#lash() : ''
-	if {s:re}
-		let cwd = exists('+ssl') ? tr(cwd, '/', '\') : cwd
-		cal filter(a:mrufs, '!stridx(v:val, cwd)')
-	en
-	if a:0 && a:1 == 'raw' | retu a:mrufs | en
-	let idx = strlen(cwd)
-	if exists('+ssl') && &ssl
-		let cwd = tr(cwd, '\', '/')
-		cal map(a:mrufs, 'tr(v:val, "\\", "/")')
-	en
-	retu map(a:mrufs, g:ctrlp_mruf_map_string)
-endf
-
-fu! s:record(bufnr)
-	if s:locked | retu | en
-	let bufnr = a:bufnr + 0
-	let bufname = bufname(bufnr)
-	if bufnr > 0 && !empty(bufname)
-		cal filter(s:mrbs, 'v:val != bufnr')
-		cal insert(s:mrbs, bufnr)
-		cal s:addtomrufs(bufname)
-	en
-endf
-
-fu! s:addtomrufs(fname)
-	let fn = fnamemodify(a:fname, get(g:, 'ctrlp_tilde_homedir', 0) ? ':p:~' : ':p')
-	let fn = exists('+ssl') ? tr(fn, '/', '\') : fn
-	let abs_fn = fnamemodify(fn,':p')
-	if ( !empty({s:in}) && fn !~# {s:in} ) || ( !empty({s:ex}) && fn =~# {s:ex} )
-		\ || !empty(getbufvar('^' . abs_fn . '$', '&bt')) || !filereadable(abs_fn)
-		retu
-	en
-	let idx = index(s:mrufs, fn, 0, !{s:cseno})
-	if idx
-		cal filter(s:mrufs, 'v:val !='.( {s:cseno} ? '#' : '?' ).' fn')
-		cal insert(s:mrufs, fn)
-		if {s:soup} && idx < 0
-			cal s:savetofile(s:mergelists())
-		en
-	en
-endf
-
-fu! s:savetofile(mrufs)
-	cal ctrlp#utils#writecache(a:mrufs, s:cadir, s:cafile)
-endf
-" Public {{{1
-fu! ctrlp#mrufiles#refresh(...)
-	let mrufs = s:mergelists()
-	cal filter(mrufs, '!empty(ctrlp#utils#glob(v:val, 1)) && !s:excl(v:val)')
-	if exists('+ssl')
-		cal map(mrufs, 'tr(v:val, "/", "\\")')
-		cal map(s:mrufs, 'tr(v:val, "/", "\\")')
-		let cond = 'count(mrufs, v:val, !{s:cseno}) == 1'
-		cal filter(mrufs, cond)
-		cal filter(s:mrufs, cond)
-	en
-	cal s:savetofile(mrufs)
-	retu a:0 && a:1 == 'raw' ? [] : s:reformat(mrufs)
-endf
-
-fu! ctrlp#mrufiles#remove(files)
-	let mrufs = []
-	if a:files != []
-		let mrufs = s:mergelists()
-		let cond = 'index(a:files, v:val, 0, !{s:cseno}) < 0'
-		cal filter(mrufs, cond)
-		cal filter(s:mrufs, cond)
-	en
-	cal s:savetofile(mrufs)
-	retu s:reformat(mrufs)
-endf
-
-fu! ctrlp#mrufiles#add(fn)
-	if !empty(a:fn)
-		cal s:addtomrufs(a:fn)
-	en
-endf
-
-fu! ctrlp#mrufiles#list(...)
-	retu a:0 ? a:1 == 'raw' ? s:reformat(s:mergelists(), a:1) : 0
-		\ : s:reformat(s:mergelists())
-endf
-
-fu! ctrlp#mrufiles#bufs()
-	retu s:mrbs
-endf
-
-fu! ctrlp#mrufiles#tgrel()
-	let {s:re} = !{s:re}
-endf
-
-fu! ctrlp#mrufiles#cachefile()
-	if !exists('s:cadir') || !exists('s:cafile')
-		let s:cadir = ctrlp#utils#cachedir().ctrlp#utils#lash().'mru'
-		let s:cafile = s:cadir.ctrlp#utils#lash().'cache.txt'
-	en
-	retu s:cafile
-endf
-
-fu! ctrlp#mrufiles#init()
-	if !has('autocmd') | retu | en
-	let s:locked = 0
-	aug CtrlPMRUF
-		au!
-		au BufWinEnter,BufWinLeave,BufWritePost * cal s:record(expand('<abuf>', 1))
-		au QuickFixCmdPre  *vimgrep* let s:locked = 1
-		au QuickFixCmdPost *vimgrep* let s:locked = 0
-		au VimLeavePre * cal s:savetofile(s:mergelists())
-	aug END
-endf
-"}}}
-
-" vim:fen:fdm=marker:fmr={{{,}}}:fdl=0:fdc=1:ts=2:sw=2:sts=2
diff --git a/sources_non_forked/ctrlp.vim/autoload/ctrlp/quickfix.vim b/sources_non_forked/ctrlp.vim/autoload/ctrlp/quickfix.vim
deleted file mode 100644
index 03ab921..0000000
--- a/sources_non_forked/ctrlp.vim/autoload/ctrlp/quickfix.vim
+++ /dev/null
@@ -1,59 +0,0 @@
-" =============================================================================
-" File:          autoload/ctrlp/quickfix.vim
-" Description:   Quickfix extension
-" Author:        Kien Nguyen <github.com/kien>
-" =============================================================================
-
-" Init {{{1
-if exists('g:loaded_ctrlp_quickfix') && g:loaded_ctrlp_quickfix
-	fini
-en
-let g:loaded_ctrlp_quickfix = 1
-
-cal add(g:ctrlp_ext_vars, {
-	\ 'init': 'ctrlp#quickfix#init()',
-	\ 'accept': 'ctrlp#quickfix#accept',
-	\ 'lname': 'quickfix',
-	\ 'sname': 'qfx',
-	\ 'type': 'line',
-	\ 'sort': 0,
-	\ 'nolim': 1,
-	\ })
-
-let s:id = g:ctrlp_builtins + len(g:ctrlp_ext_vars)
-
-fu! s:lineout(dict)
-	retu printf('%s|%d:%d| %s', bufname(a:dict['bufnr']), a:dict['lnum'],
-		\ a:dict['col'], matchstr(a:dict['text'], '\s*\zs.*\S'))
-endf
-" Utilities {{{1
-fu! s:syntax()
-	if !ctrlp#nosy()
-		cal ctrlp#hicheck('CtrlPqfLineCol', 'Search')
-		sy match CtrlPqfLineCol '|\zs\d\+:\d\+\ze|'
-	en
-endf
-" Public {{{1
-fu! ctrlp#quickfix#init()
-	cal s:syntax()
-	retu map(getqflist(), 's:lineout(v:val)')
-endf
-
-fu! ctrlp#quickfix#accept(mode, str)
-	let vals = matchlist(a:str, '^\([^|]\+\ze\)|\(\d\+\):\(\d\+\)|')
-	if vals == [] || vals[1] == '' | retu | en
-	cal ctrlp#acceptfile(a:mode, vals[1])
-	let cur_pos = getpos('.')[1:2]
-	if cur_pos != [1, 1] && cur_pos != map(vals[2:3], 'str2nr(v:val)')
-		mark '
-	en
-	cal cursor(vals[2], vals[3])
-	sil! norm! zvzz
-endf
-
-fu! ctrlp#quickfix#id()
-	retu s:id
-endf
-"}}}
-
-" vim:fen:fdm=marker:fmr={{{,}}}:fdl=0:fdc=1:ts=2:sw=2:sts=2
diff --git a/sources_non_forked/ctrlp.vim/autoload/ctrlp/rtscript.vim b/sources_non_forked/ctrlp.vim/autoload/ctrlp/rtscript.vim
deleted file mode 100644
index eed21c6..0000000
--- a/sources_non_forked/ctrlp.vim/autoload/ctrlp/rtscript.vim
+++ /dev/null
@@ -1,59 +0,0 @@
-" =============================================================================
-" File:          autoload/ctrlp/rtscript.vim
-" Description:   Runtime scripts extension
-" Author:        Kien Nguyen <github.com/kien>
-" =============================================================================
-
-" Init {{{1
-if exists('g:loaded_ctrlp_rtscript') && g:loaded_ctrlp_rtscript
-	fini
-en
-let [g:loaded_ctrlp_rtscript, g:ctrlp_newrts] = [1, 0]
-
-cal add(g:ctrlp_ext_vars, {
-	\ 'init': 'ctrlp#rtscript#init(s:caching)',
-	\ 'accept': 'ctrlp#acceptfile',
-	\ 'lname': 'runtime scripts',
-	\ 'sname': 'rts',
-	\ 'type': 'path',
-	\ 'opmul': 1,
-	\ })
-
-let s:id = g:ctrlp_builtins + len(g:ctrlp_ext_vars)
-
-let s:filecounts = {}
-" Utilities {{{1
-fu! s:nocache()
-	retu g:ctrlp_newrts ||
-		\ !s:caching || ( s:caching > 1 && get(s:filecounts, s:cwd) < s:caching )
-endf
-" Public {{{1
-fu! ctrlp#rtscript#init(caching)
-	let [s:caching, s:cwd] = [a:caching, getcwd()]
-	if s:nocache() ||
-		\ !( exists('g:ctrlp_rtscache') && g:ctrlp_rtscache[0] == &rtp )
-		sil! cal ctrlp#progress('Indexing...')
-		let entries = split(globpath(ctrlp#utils#fnesc(&rtp, 'g'), '**/*.*'), "\n")
-		cal filter(entries, 'count(entries, v:val) == 1')
-		let [entries, echoed] = [ctrlp#dirnfile(entries)[1], 1]
-	el
-		let [entries, results] = g:ctrlp_rtscache[2:3]
-	en
-	if s:nocache() ||
-		\ !( exists('g:ctrlp_rtscache') && g:ctrlp_rtscache[:1] == [&rtp, s:cwd] )
-		if !exists('echoed')
-			sil! cal ctrlp#progress('Processing...')
-		en
-		let results = map(copy(entries), 'fnamemodify(v:val, '':.'')')
-	en
-	let [g:ctrlp_rtscache, g:ctrlp_newrts] = [[&rtp, s:cwd, entries, results], 0]
-	cal extend(s:filecounts, { s:cwd : len(results) })
-	retu results
-endf
-
-fu! ctrlp#rtscript#id()
-	retu s:id
-endf
-"}}}
-
-" vim:fen:fdm=marker:fmr={{{,}}}:fdl=0:fdc=1:ts=2:sw=2:sts=2
diff --git a/sources_non_forked/ctrlp.vim/autoload/ctrlp/tag.vim b/sources_non_forked/ctrlp.vim/autoload/ctrlp/tag.vim
deleted file mode 100644
index c229480..0000000
--- a/sources_non_forked/ctrlp.vim/autoload/ctrlp/tag.vim
+++ /dev/null
@@ -1,146 +0,0 @@
-" =============================================================================
-" File:          autoload/ctrlp/tag.vim
-" Description:   Tag file extension
-" Author:        Kien Nguyen <github.com/kien>
-" =============================================================================
-
-" Init {{{1
-if exists('g:loaded_ctrlp_tag') && g:loaded_ctrlp_tag
-	fini
-en
-let g:loaded_ctrlp_tag = 1
-
-cal add(g:ctrlp_ext_vars, {
-	\ 'init': 'ctrlp#tag#init()',
-	\ 'accept': 'ctrlp#tag#accept',
-	\ 'lname': 'tags',
-	\ 'sname': 'tag',
-	\ 'enter': 'ctrlp#tag#enter()',
-	\ 'type': 'tabs',
-	\ })
-
-let s:id = g:ctrlp_builtins + len(g:ctrlp_ext_vars)
-" Utilities {{{1
-fu! s:findcount(str, tgaddr)
-	let [tg, ofname] = split(a:str, '\t\+\ze[^\t]\+$')
-	let tgs = taglist('^'.tg.'$')
-	if len(tgs) < 2
-		retu [0, 0, 0, 0]
-	en
-	let bname = fnamemodify(bufname('%'), ':p')
-	let fname = expand(fnamemodify(simplify(ofname), ':s?^[.\/]\+??:p:.'), 1)
-	let [fnd, cnt, pos, ctgs, otgs] = [0, 0, 0, [], []]
-	for tgi in tgs
-		let lst = bname == fnamemodify(tgi["filename"], ':p') ? 'ctgs' : 'otgs'
-		cal call('add', [{lst}, tgi])
-	endfo
-	let ntgs = ctgs + otgs
-	for tgi in ntgs
-		let cnt += 1
-		let fulname = fnamemodify(tgi["filename"], ':p')
-		if stridx(fulname, fname) >= 0
-			\ && strlen(fname) + stridx(fulname, fname) == strlen(fulname)
-			let fnd += 1
-			let pos = cnt
-		en
-	endfo
-	let cnt = 0
-	for tgi in ntgs
-		let cnt += 1
-		if tgi["filename"] == ofname
-			if a:tgaddr != ""
-				if a:tgaddr == tgi["cmd"]
-					let [fnd, pos] = [0, cnt]
-				en
-			else
-				let [fnd, pos] = [0, cnt]
-			en
-		en
-	endfo
-	retu [1, fnd, pos, len(ctgs)]
-endf
-
-fu! s:filter(tags)
-	let nr = 0
-	wh 0 < 1
-		if a:tags == [] | brea | en
-		if a:tags[nr] =~ '^!' && a:tags[nr] !~# '^!_TAG_'
-			let nr += 1
-			con
-		en
-		if a:tags[nr] =~# '^!_TAG_' && len(a:tags) > nr
-			cal remove(a:tags, nr)
-		el
-			brea
-		en
-	endw
-	retu a:tags
-endf
-
-fu! s:syntax()
-	if !ctrlp#nosy()
-		cal ctrlp#hicheck('CtrlPTabExtra', 'Comment')
-		sy match CtrlPTabExtra '\zs\t.*\ze$'
-	en
-endf
-" Public {{{1
-fu! ctrlp#tag#init()
-	if empty(s:tagfiles) | retu [] | en
-	let g:ctrlp_alltags = []
-	let tagfiles = sort(filter(s:tagfiles, 'count(s:tagfiles, v:val) == 1'))
-	for each in tagfiles
-		let alltags = s:filter(ctrlp#utils#readfile(each))
-		cal extend(g:ctrlp_alltags, alltags)
-	endfo
-	cal s:syntax()
-	retu g:ctrlp_alltags
-endf
-
-fu! ctrlp#tag#accept(mode, str)
-	cal ctrlp#exit()
-	let tgaddr = matchstr(a:str, '^[^\t]\+\t\+[^\t]\+\t\zs[^\t]\{-1,}\ze\%(;"\)\?\t')
-	let str = matchstr(a:str, '^[^\t]\+\t\+[^\t]\+\ze\t')
-	let [tg, fdcnt] = [split(str, '^[^\t]\+\zs\t')[0], s:findcount(str, tgaddr)]
-	let cmds = {
-		\ 't': ['tab sp', 'tab stj'],
-		\ 'h': ['sp', 'stj'],
-		\ 'v': ['vs', 'vert stj'],
-		\ 'e': ['', 'tj'],
-		\ }
-	let utg = fdcnt[3] < 2 && fdcnt[0] == 1 && fdcnt[1] == 1
-	let cmd = !fdcnt[0] || utg ? cmds[a:mode][0] : cmds[a:mode][1]
-	let cmd = a:mode == 'e' && ctrlp#modfilecond(!&aw)
-		\ ? ( cmd == 'tj' ? 'stj' : 'sp' ) : cmd
-	let cmd = a:mode == 't' ? ctrlp#tabcount().cmd : cmd
-	if !fdcnt[0] || utg
-		if cmd != ''
-			exe cmd
-		en
-		let save_cst = &cst
-		set cst&
-		cal feedkeys(":".( utg ? fdcnt[2] : "" )."ta ".tg."\r", 'nt')
-		let &cst = save_cst
-	el
-		let ext = ""
-		if fdcnt[1] < 2 && fdcnt[2]
-			let [sav_more, &more] = [&more, 0]
-			let ext = fdcnt[2]."\r".":let &more = ".sav_more."\r"
-		en
-		cal feedkeys(":".cmd." ".tg."\r".ext, 'nt')
-	en
-	cal feedkeys('zvzz', 'nt')
-	cal ctrlp#setlcdir()
-endf
-
-fu! ctrlp#tag#id()
-	retu s:id
-endf
-
-fu! ctrlp#tag#enter()
-	let tfs = get(g:, 'ctrlp_custom_tag_files', tagfiles())
-	let s:tagfiles = type(tfs) == 3 && tfs != [] ? filter(map(tfs, 'fnamemodify(v:val, ":p")'),
-		\ 'filereadable(v:val)') : []
-endf
-"}}}
-
-" vim:fen:fdm=marker:fmr={{{,}}}:fdl=0:fdc=1:ts=2:sw=2:sts=2
diff --git a/sources_non_forked/ctrlp.vim/autoload/ctrlp/undo.vim b/sources_non_forked/ctrlp.vim/autoload/ctrlp/undo.vim
deleted file mode 100644
index dee705e..0000000
--- a/sources_non_forked/ctrlp.vim/autoload/ctrlp/undo.vim
+++ /dev/null
@@ -1,154 +0,0 @@
-" =============================================================================
-" File:          autoload/ctrlp/undo.vim
-" Description:   Undo extension
-" Author:        Kien Nguyen <github.com/kien>
-" =============================================================================
-
-" Init {{{1
-if ( exists('g:loaded_ctrlp_undo') && g:loaded_ctrlp_undo )
-	fini
-en
-let g:loaded_ctrlp_undo = 1
-
-cal add(g:ctrlp_ext_vars, {
-	\ 'init': 'ctrlp#undo#init()',
-	\ 'accept': 'ctrlp#undo#accept',
-	\ 'lname': 'undo',
-	\ 'sname': 'udo',
-	\ 'enter': 'ctrlp#undo#enter()',
-	\ 'exit': 'ctrlp#undo#exit()',
-	\ 'type': 'line',
-	\ 'sort': 0,
-	\ 'nolim': 1,
-	\ })
-
-let s:id = g:ctrlp_builtins + len(g:ctrlp_ext_vars)
-
-let s:text = map(['second', 'seconds', 'minutes', 'hours', 'days', 'weeks',
-	\ 'months', 'years'], '" ".v:val." ago"')
-" Utilities {{{1
-fu! s:getundo()
-	if exists('*undotree')
-		\ && ( v:version > 703 || ( v:version == 703 && has('patch005') ) )
-		retu [1, undotree()]
-	el
-		redi => result
-		sil! undol
-		redi END
-		retu [0, split(result, "\n")[1:]]
-	en
-endf
-
-fu! s:flatten(tree, cur)
-	let flatdict = {}
-	for each in a:tree
-		let saved = has_key(each, 'save') ? 'saved' : ''
-		let current = each['seq'] == a:cur ? 'current' : ''
-		cal extend(flatdict, { each['seq'] : [each['time'], saved, current] })
-		if has_key(each, 'alt')
-			cal extend(flatdict, s:flatten(each['alt'], a:cur))
-		en
-	endfo
-	retu flatdict
-endf
-
-fu! s:elapsed(nr)
-	let [text, time] = [s:text, localtime() - a:nr]
-	let mins = time / 60
-	let hrs  = time / 3600
-	let days = time / 86400
-	let wks  = time / 604800
-	let mons = time / 2592000
-	let yrs  = time / 31536000
-	if yrs > 1
-		retu yrs.text[7]
-	elsei mons > 1
-		retu mons.text[6]
-	elsei wks > 1
-		retu wks.text[5]
-	elsei days > 1
-		retu days.text[4]
-	elsei hrs > 1
-		retu hrs.text[3]
-	elsei mins > 1
-		retu mins.text[2]
-	elsei time == 1
-		retu time.text[0]
-	elsei time < 120
-		retu time.text[1]
-	en
-endf
-
-fu! s:syntax()
-	if ctrlp#nosy() | retu | en
-	for [ke, va] in items({'T': 'Directory', 'Br': 'Comment', 'Nr': 'String',
-		\ 'Sv': 'Comment', 'Po': 'Title'})
-		cal ctrlp#hicheck('CtrlPUndo'.ke, va)
-	endfo
-	sy match CtrlPUndoT '\v\d+ \zs[^ ]+\ze|\d+:\d+:\d+'
-	sy match CtrlPUndoBr '\[\|\]'
-	sy match CtrlPUndoNr '\[\d\+\]' contains=CtrlPUndoBr
-	sy match CtrlPUndoSv 'saved'
-	sy match CtrlPUndoPo 'current'
-endf
-
-fu! s:dict2list(dict)
-	for ke in keys(a:dict)
-		let a:dict[ke][0] = s:elapsed(a:dict[ke][0])
-	endfo
-	retu map(keys(a:dict), 'eval(''[v:val, a:dict[v:val]]'')')
-endf
-
-fu! s:compval(...)
-	retu a:2[0] - a:1[0]
-endf
-
-fu! s:format(...)
-	let saved = !empty(a:1[1][1]) ? ' '.a:1[1][1] : ''
-	let current = !empty(a:1[1][2]) ? ' '.a:1[1][2] : ''
-	retu a:1[1][0].' ['.a:1[0].']'.saved.current
-endf
-
-fu! s:formatul(...)
-	let parts = matchlist(a:1,
-		\ '\v^\s+(\d+)\s+\d+\s+([^ ]+\s?[^ ]+|\d+\s\w+\s\w+)(\s*\d*)$')
-	retu parts == [] ? '----'
-		\ : parts[2].' ['.parts[1].']'.( parts[3] != '' ? ' saved' : '' )
-endf
-" Public {{{1
-fu! ctrlp#undo#init()
-	let entries = s:undos[0] ? s:undos[1]['entries'] : s:undos[1]
-	if empty(entries) | retu [] | en
-	if !exists('s:lines')
-		if s:undos[0]
-			let entries = s:dict2list(s:flatten(entries, s:undos[1]['seq_cur']))
-			let s:lines = map(sort(entries, 's:compval'), 's:format(v:val)')
-		el
-			let s:lines = map(reverse(entries), 's:formatul(v:val)')
-		en
-	en
-	cal s:syntax()
-	retu s:lines
-endf
-
-fu! ctrlp#undo#accept(mode, str)
-	let undon = matchstr(a:str, '\[\zs\d\+\ze\]')
-	if empty(undon) | retu | en
-	cal ctrlp#exit()
-	exe 'u' undon
-endf
-
-fu! ctrlp#undo#id()
-	retu s:id
-endf
-
-fu! ctrlp#undo#enter()
-	let s:undos = s:getundo()
-endf
-
-fu! ctrlp#undo#exit()
-	unl! s:lines
-endf
-"}}}
-
-" vim:fen:fdm=marker:fmr={{{,}}}:fdl=0:fdc=1:ts=2:sw=2:sts=2
diff --git a/sources_non_forked/ctrlp.vim/autoload/ctrlp/utils.vim b/sources_non_forked/ctrlp.vim/autoload/ctrlp/utils.vim
deleted file mode 100644
index 91b9f24..0000000
--- a/sources_non_forked/ctrlp.vim/autoload/ctrlp/utils.vim
+++ /dev/null
@@ -1,110 +0,0 @@
-" =============================================================================
-" File:          autoload/ctrlp/utils.vim
-" Description:   Utilities
-" Author:        Kien Nguyen <github.com/kien>
-" =============================================================================
-
-" Static variables {{{1
-fu! ctrlp#utils#lash()
-	retu &ssl || !exists('+ssl') ? '/' : '\'
-endf
-
-fu! s:lash(...)
-	retu ( a:0 ? a:1 : getcwd() ) !~ '[\/]$' ? s:lash : ''
-endf
-
-fu! ctrlp#utils#opts()
-	let s:lash = ctrlp#utils#lash()
-	let usrhome = $HOME . s:lash( $HOME )
-	let cahome = exists('$XDG_CACHE_HOME') ? $XDG_CACHE_HOME : usrhome.'.cache'
-	let cadir = isdirectory(usrhome.'.ctrlp_cache')
-		\ ? usrhome.'.ctrlp_cache' : cahome.s:lash(cahome).'ctrlp'
-	if exists('g:ctrlp_cache_dir')
-		let cadir = expand(g:ctrlp_cache_dir, 1)
-		if isdirectory(cadir.s:lash(cadir).'.ctrlp_cache')
-			let cadir = cadir.s:lash(cadir).'.ctrlp_cache'
-		en
-	en
-	let s:cache_dir = cadir
-endf
-cal ctrlp#utils#opts()
-
-let s:wig_cond = v:version > 702 || ( v:version == 702 && has('patch051') )
-" Files and Directories {{{1
-fu! ctrlp#utils#cachedir()
-	retu s:cache_dir
-endf
-
-fu! ctrlp#utils#cachefile(...)
-	let [tail, dir] = [a:0 == 1 ? '.'.a:1 : '', a:0 == 2 ? a:1 : getcwd()]
-	let cache_file = substitute(dir, '\([\/]\|^\a\zs:\)', '%', 'g').tail.'.txt'
-	retu a:0 == 1 ? cache_file : s:cache_dir.s:lash(s:cache_dir).cache_file
-endf
-
-fu! ctrlp#utils#readfile(file)
-	if filereadable(a:file)
-		let data = readfile(a:file)
-		if empty(data) || type(data) != 3
-			unl data
-			let data = []
-		en
-		retu data
-	en
-	retu []
-endf
-
-fu! ctrlp#utils#mkdir(dir)
-	if exists('*mkdir') && !isdirectory(a:dir)
-		sil! cal mkdir(a:dir, 'p')
-	en
-	retu a:dir
-endf
-
-fu! ctrlp#utils#writecache(lines, ...)
-	if isdirectory(ctrlp#utils#mkdir(a:0 ? a:1 : s:cache_dir))
-		sil! cal writefile(a:lines, a:0 >= 2 ? a:2 : ctrlp#utils#cachefile())
-	en
-endf
-
-fu! ctrlp#utils#glob(...)
-	let path = ctrlp#utils#fnesc(a:1, 'g')
-	retu s:wig_cond ? glob(path, a:2) : glob(path)
-endf
-
-fu! ctrlp#utils#globpath(...)
-	retu call('globpath', s:wig_cond ? a:000 : a:000[:1])
-endf
-
-fu! ctrlp#utils#fnesc(path, type, ...)
-	if exists('*fnameescape')
-		if exists('+ssl')
-			if a:type == 'c'
-				let path = escape(a:path, '%#')
-			elsei a:type == 'f'
-				let path = fnameescape(a:path)
-			elsei a:type == 'g'
-				let path = escape(a:path, '?*')
-			en
-			let path = substitute(path, '[', '[[]', 'g')
-		el
-			let path = fnameescape(a:path)
-		en
-	el
-		if exists('+ssl')
-			if a:type == 'c'
-				let path = escape(a:path, '%#')
-			elsei a:type == 'f'
-				let path = escape(a:path, " \t\n%#*?|<\"")
-			elsei a:type == 'g'
-				let path = escape(a:path, '?*')
-			en
-			let path = substitute(path, '[', '[[]', 'g')
-		el
-			let path = escape(a:path, " \t\n*?[{`$\\%#'\"|!<")
-		en
-	en
-	retu a:0 ? escape(path, a:1) : path
-endf
-"}}}
-
-" vim:fen:fdm=marker:fmr={{{,}}}:fdl=0:fdc=1:ts=2:sw=2:sts=2
diff --git a/sources_non_forked/ctrlp.vim/doc/ctrlp.cnx b/sources_non_forked/ctrlp.vim/doc/ctrlp.cnx
deleted file mode 100644
index 32da378..0000000
--- a/sources_non_forked/ctrlp.vim/doc/ctrlp.cnx
+++ /dev/null
@@ -1,1616 +0,0 @@
-*ctrlp.txt*        , , , , ... . v1.80
-*CtrlP* *ControlP* *'ctrlp'* *'ctrl-p'*
-===============================================================================
-#                                                                             #
-#          :::::::: ::::::::::: :::::::::  :::             :::::::::          #
-#         :+:    :+:    :+:     :+:    :+: :+:             :+:    :+:         #
-#         +:+           +:+     +:+    +:+ +:+             +:+    +:+         #
-#         +#+           +#+     +#++:++#:  +#+             +#++:++#+          #
-#         +#+           +#+     +#+    +#+ +#+             +#+                #
-#         #+#    #+#    #+#     #+#    #+# #+#             #+#                #
-#          ########     ###     ###    ### ##########      ###                #
-#                                                                             #
-===============================================================================
-
-
-  buffer:                    mapping:
-     mru:               prompt:
-     tag:                          tab:
-     tab:
-
-===============================================================================
-                                                            *ctrlp-content*
-
-    1. .............................................|ctrlp-intro|
-    2. .............................................|ctrlp-options|
-    3. .............................................|ctrlp-commands|
-    4. .........................................|ctrlp-mappings|
-    5. .........................................|ctrlp-input-formats|
-    6. .............................................|ctrlp-extensions|
-
-===============================================================================
-                                                              *ctrlp-intro*
-
-, , , , ... 
-VimscriptMacVimgVim7.0Vim
-Vim |regexp| 
-
-
-rtscript... |ctrlp-extensions| 
-
-===============================================================================
-OPTIONS                                                         *ctrlp-options*
-
-:~
-
-  |loaded_ctrlp|................
-  |ctrlp_map|...................
-  |ctrlp_cmd|...................
-  |ctrlp_by_filename|...........
-  |ctrlp_regexp|................
-  |ctrlp_match_window|..........
-  |ctrlp_switch_buffer|.........
-  |ctrlp_reuse_window|.......... |quickfix| 
-  |ctrlp_tabpage_position|......
-  |ctrlp_working_path_mode|.....CtrlP
-  |ctrlp_root_markers|..........
-  |ctrlp_use_caching|...........
-  |ctrlp_clear_cache_on_exit|...Vim
-  |ctrlp_cache_dir|.............
-  |ctrlp_show_hidden|...........
-  |ctrlp_custom_ignore|......... |globpath()| 
-  |ctrlp_max_files|.............
-  |ctrlp_max_depth|.............
-  |ctrlp_user_command|..........
-  |ctrlp_max_history|...........
-  |ctrlp_open_new_file|.........<c-y>
-  |ctrlp_open_multiple_files|...<c-z>
-  |ctrlp_arg_map|...............<c-y>  <c-o> 
-  |ctrlp_follow_symlinks|.......
-  |ctrlp_lazy_update|...........
-  |ctrlp_default_input|.........
-  |ctrlp_abbrev|................
-  |ctrlp_key_loop|..............
-  |ctrlp_prompt_mappings|.......
-  |ctrlp_line_prefix|...........ctrlp 
-  |ctrlp_open_single_match|.....
-  |ctrlp_brief_prompt|..........<bs> CtrlP
-  |ctrlp_match_current_file|....
-  |ctrlp_types|.................
-
-  :
-  |ctrlp_mruf_max|..............
-  |ctrlp_mruf_exclude|..........
-  |ctrlp_mruf_include|..........
-  |ctrlp_mruf_relative|.........
-  |ctrlp_tilde_homedir|......... home  MRU  ~/
-  |ctrlp_mruf_default_order|....
-  |ctrlp_mruf_case_sensitive|...
-  |ctrlp_mruf_save_on_update|...
-
-  :
-  |ctrlp_bufname_mod|...........
-  |ctrlp_bufpath_mod|...........
-
-  : ( |ctrlp-extensions| )
-  |g:ctrlp_buftag_ctags_bin|....ctags
-  |g:ctrlp_buftag_systemenc|....ctags
-  |g:ctrlp_buftag_types|........
-
-  :
-  |ctrlp_open_func|.............
-  |ctrlp_status_func|...........CtrlP
-  |ctrlp_buffer_func|...........CtrlP
-  |ctrlp_match_func|............
-
--------------------------------------------------------------------------------
-:~
-
-                                                                *'g:ctrlp_map'*
- |Normal| CtrlP: >
-  let g:ctrlp_map = '<c-p>'
-<
-
-                                                                *'g:ctrlp_cmd'*
-
-: >
-  let g:ctrlp_cmd = 'CtrlP'
-<
-
-                                                             *'g:loaded_ctrlp'*
-: >
-  let g:loaded_ctrlp = 1
-<
-
-                                                        *'g:ctrlp_by_filename'*
-1: >
-  let g:ctrlp_by_filename = 0
-<
- <c-d> 
-
-                                                             *'g:ctrlp_regexp'*
-1: >
-  let g:ctrlp_regexp = 0
-<
- <c-r> 
-
-                                                       *'g:ctrlp_match_window'*
-: >
-  let g:ctrlp_match_window = ''
-<
-: >
-  let g:ctrlp_match_window = 'bottom,order:btt,min:1,max:10,results:10'
-<
-: (:)
-  top - 
-  bottom - 
-
-: (: btt)
-  order:ttb - 
-  order:btt - 
-
-:
-  min:{n} -  {n}  (: 1).
-  max:{n} -  {n}  (: 10).
-
-:
-  results:{n} -  {n}  (: ).
-                0
-
-: 
-
-                                                      *'g:ctrlp_switch_buffer'*
-CtrlP
-: >
-  let g:ctrlp_switch_buffer = 'Et'
-<
-  e -  <cr> 
-  t -  <c-t> , 
-  v -  "e",  <c-v> 
-  h -  "e",  <c-x> 
-  E, T, V, H -  "e", "t", "v", and "h", 
-  0  <empty> - 
-
-                                                       *'g:ctrlp_reuse_window'*
- <cr> CtrlP
-: >
-  let g:ctrlp_reuse_window = 'netrw'
-<
-
-
-: >
-  let g:ctrlp_reuse_window = 'netrw\|help\|quickfix'
-<
-
-                                                   *'g:ctrlp_tabpage_position'*
-: >
-  let g:ctrlp_tabpage_position = 'ac'
-<
-  a - 
-  b - 
-  c - 
-  l - 
-  f - 
-
-                                                  *'g:ctrlp_working_path_mode'*
-CtrlP: >
-  let g:ctrlp_working_path_mode = 'ra'
-<
-  c - 
-  a - 
-  r - :
-      .git .hg .svn .bzr _darcs
-  w - r
-  0  <empty> - 
-
- #1:  "a"  "c"  "r" "a"  
-"c" 
-
- #2:  |b:var| 
-
-                                                       *'g:ctrlp_root_markers'*
-(.hg, .svn, .bzr, and _darcs)
-: >
-  let g:ctrlp_root_markers = ['']
-<
-:  |b:var| 
-
-                                                        *'g:ctrlp_use_caching'*
-/: >
-  let g:ctrlp_use_caching = 1
-<
-  0 - 
-  1 - 
-  n - 1
-
-: CtrlP <F5> 
-
-                                                *'g:ctrlp_clear_cache_on_exit'*
-0Vim: >
-  let g:ctrlp_clear_cache_on_exit = 1
-<
-
-                                                          *'g:ctrlp_cache_dir'*
-: >
-  let g:ctrlp_cache_dir = $HOME.'/.cache/ctrlp'
-<
-
-                                                        *'g:ctrlp_show_hidden'*
-CtrlP1: >
-  let g:ctrlp_show_hidden = 0
-<
-:  |g:ctrlp_user_command| 
-
-                                                           *'ctrlp-wildignore'*
-Vim |'wildignore'| 
-: >
-  " 
-  set wildignore+=*/.git/*,*/.hg/*,*/.svn/*        " Linux/MacOSX
-  set wildignore+=*\\.git\\*,*\\.hg\\*,*\\.svn\\*  " Windows ('noshellslash')
-<
- #1:  `*/` 
-
- #2: |wildignore|  |expand()|  |globpath()|  |glob()| 
-.git/.hg/
-Windows*.exe |wildignore| 
-
-
-                                                      *'g:ctrlp_custom_ignore'*
- |'wildignore'|  |g:ctrlp_show_hidden| CtrlP
-: >
-  let g:ctrlp_custom_ignore = ''
-<
-: >
-  let g:ctrlp_custom_ignore = '\v[\/]\.(git|hg|svn)$'
-  let g:ctrlp_custom_ignore = {
-    \ 'dir':  '\v[\/]\.(git|hg|svn)$',
-    \ 'file': '\v\.(exe|so|dll)$',
-    \ 'link': 'SOME_BAD_SYMBOLIC_LINKS',
-    \ }
-  let g:ctrlp_custom_ignore = {
-    \ 'file': '\v(\.cpp|\.h|\.hh|\.cxx)@<!$'
-    \ }
-  let g:ctrlp_custom_ignore = {
-    \ 'func': 'some#custom#match_function'
-    \ }
-<
- #1:  |wildignore|  |g:ctrlp_custom_ignore|  |globpath()| 
- |g:ctrlp_user_command| 
-
-
- #2:  |:unlet| Vim
-"E706: Variable type mismatch" 
-
- #3: CtrlP
-
-10
-
-                                                          *'g:ctrlp_max_files'*
-0: >
-  let g:ctrlp_max_files = 10000
-<
-:  |g:ctrlp_user_command| 
-
-                                                          *'g:ctrlp_max_depth'*
-: >
-  let g:ctrlp_max_depth = 40
-<
-:  |g:ctrlp_user_command| 
-
-                                                       *'g:ctrlp_user_command'*
-Vim |globpath()|  %s : >
-  let g:ctrlp_user_command = ''
-<
-: >
-  let g:ctrlp_user_command = 'find %s -type f'       " MacOSX/Linux
-  let g:ctrlp_user_command = 'dir %s /-n /b /s /a-d' " Windows
-<
- 'grep', 'findstr' 
-: >
-  let g:ctrlp_user_command =
-    \ 'find %s -type f | grep -v -P "\.jpg$|/tmp/"'          " MacOSX/Linux
-  let g:ctrlp_user_command =
-    \ 'dir %s /-n /b /s /a-d | findstr /v /l ".jpg \\tmp\\"' " Windows
-<
-: >
-  let g:ctrlp_user_command = [root_marker, listing_command, fallback_command]
-  let g:ctrlp_user_command = {
-    \ 'types': {
-      \ 1: [root_marker_1, listing_command_1],
-      \ n: [root_marker_n, listing_command_n],
-      \ },
-    \ 'fallback': fallback_command,
-    \ 'ignore': 0 or 1
-    \ }
-<
-: >
-  " :
-  let g:ctrlp_user_command = ['.git', 'cd %s && git ls-files']
-  let g:ctrlp_user_command = ['.hg', 'hg --cwd %s locate -I .']
-
-  " :
-  let g:ctrlp_user_command = {
-    \ 'types': {
-      \ 1: ['.git', 'cd %s && git ls-files'],
-      \ 2: ['.hg', 'hg --cwd %s locate -I .'],
-      \ },
-    \ 'fallback': 'find %s -type f'
-    \ }
-
-  " :
-  let g:ctrlp_user_command =
-    \ ['.git', 'cd %s && git ls-files -co --exclude-standard']
-
-  let g:ctrlp_user_command =
-    \ ['.hg', 'hg --cwd %s status -numac -I . $(hg root)'] " MacOSX/Linux
-
-  let g:ctrlp_user_command = ['.hg', 'for /f "tokens=1" %%a in (''hg root'') '
-    \ . 'do hg --cwd %s status -numac -I . %%a']           " Windows
-<
- #1:  |Dictionary| , 'fallback'  'ignore'  |List| 
-
-
- #2:  'fallback' 
-|globpath()| 
-
- #3:  |Dictionary|  'ignore' 1
- |wildignore|  |g:ctrlp_custom_ignore| 
-'ignore' 0
-
- #4:  |:unlet| Vim
-"E706: Variable type mismatch" 
-
- #5:  |b:var| 
-
-                                                        *'g:ctrlp_max_history'*
-CtrlPVim |'history'| : >
-  let g:ctrlp_max_history = &history
-<
-0 <c-n>  <c-p> 
-
-                                                      *'g:ctrlp_open_new_file'*
- <c-y> : >
-  let g:ctrlp_open_new_file = 'v'
-<
-  t - 
-  h - 
-  v - 
-  r - 
-
-                                                *'g:ctrlp_open_multiple_files'*
-0  <c-z>  <c-o> : >
-  let g:ctrlp_open_multiple_files = 'v'
-<
-: >
-  let g:ctrlp_open_multiple_files = '2vjr'
-<
-:
-  - 
-    
-  - <c-o> 
-
-:
-  t - 
-  h - 
-  v - 
-  i - 
-  j - 
-  r - "h""v""t"
-      
-
-                                                            *'g:ctrlp_arg_map'*
-1 <c-o>  <c-y> : >
-  let g:ctrlp_arg_map = 0
-<
- <c-o>  <c-y> :
-  t - 
-  h - 
-  v - 
-  i -  <c-o> 
-  c -  <c-o> 
-  r -  <c-y> 
-  <esc>, <c-c>, <c-u> - 
-  <cr> -  |g:ctrlp_open_new_file|  |g:ctrlp_open_multiple_files| 
-         
-
-
-                                                    *'g:ctrlp_follow_symlinks'*
-0CtrlP: >
-  let g:ctrlp_follow_symlinks = 0
-<
-  0 - 
-  1 - 
-  2 - 
-
-:  |g:ctrlp_user_command| 
-
-                                                        *'g:ctrlp_lazy_update'*
-1: >
-  let g:ctrlp_lazy_update = 0
-<
-12501
-
-                                                      *'g:ctrlp_default_input'*
-1: >
-  let g:ctrlp_default_input = 0
-<
-10: >
-  let g:ctrlp_default_input = 'anystring'
-<
- |g:ctrlp_open_single_match| 
-
-
-                                                 *'g:ctrlp_match_current_file'*
-: >
-  let g:ctrlp_match_current_file = 1
-
-
-
-:  |g:ctrlp_match_func| 
-
-                                                              *'g:ctrlp_types'*
-: >
-  let g:ctrlp_types = ['mru', 'fil']
-
-: >
-  let g:ctrlp_types = ['fil', 'buf', 'mru'].
-
-                                                             *'g:ctrlp_abbrev'*
-: >
-  let g:ctrlp_abbrev = {}
-<
-: >
-  let g:ctrlp_abbrev = {
-    \ 'gmode': 'i',
-    \ 'abbrevs': [
-      \ {
-        \ 'pattern': '^cd b',
-        \ 'expanded': '@cd ~/.vim/bundle',
-        \ 'mode': 'pfrz',
-      \ },
-      \ {
-        \ 'pattern': '\(^@.\+\|\\\@<!:.\+\)\@<! ',
-        \ 'expanded': '.\{-}',
-        \ 'mode': 'pfr',
-      \ },
-      \ {
-        \ 'pattern': '\\\@<!:.\+\zs\\\@<! ',
-        \ 'expanded': '\ ',
-        \ 'mode': 'pfz',
-      \ },
-      \ ]
-    \ }
-<
- 'pattern' 
-
-
- 'gmode' :
-  i - 
-  t - 
-  k - "t"
-
- 'mode' :
-  f - 
-  p - 
-  r - 
-  z - 
-  n -  <c-y> 
-  c -  <tab> 
-  <empty>  - 
-
-:  'gmode' "t"
-
-
-                                                           *'g:ctrlp_key_loop'*
-1: >
-  let g:ctrlp_key_loop = 0
-<
- #1:  |g:ctrlp_lazy_update| 
-
- #2: : >
-  let g:ctrlp_prompt_mappings = { 'ToggleKeyLoop()': ['<F3>'] }
-<
-
-                                                    *'g:ctrlp_prompt_mappings'*
-CtrlP
-[]: >
-  let g:ctrlp_prompt_mappings = {
-    \ 'PrtBS()':              ['<bs>', '<c-]>'],
-    \ 'PrtDelete()':          ['<del>'],
-    \ 'PrtDeleteWord()':      ['<c-w>'],
-    \ 'PrtClear()':           ['<c-u>'],
-    \ 'PrtSelectMove("j")':   ['<c-j>', '<down>'],
-    \ 'PrtSelectMove("k")':   ['<c-k>', '<up>'],
-    \ 'PrtSelectMove("t")':   ['<Home>', '<kHome>'],
-    \ 'PrtSelectMove("b")':   ['<End>', '<kEnd>'],
-    \ 'PrtSelectMove("u")':   ['<PageUp>', '<kPageUp>'],
-    \ 'PrtSelectMove("d")':   ['<PageDown>', '<kPageDown>'],
-    \ 'PrtHistory(-1)':       ['<c-n>'],
-    \ 'PrtHistory(1)':        ['<c-p>'],
-    \ 'AcceptSelection("e")': ['<cr>', '<2-LeftMouse>'],
-    \ 'AcceptSelection("h")': ['<c-x>', '<c-cr>', '<c-s>'],
-    \ 'AcceptSelection("t")': ['<c-t>'],
-    \ 'AcceptSelection("v")': ['<c-v>', '<RightMouse>'],
-    \ 'ToggleFocus()':        ['<s-tab>'],
-    \ 'ToggleRegex()':        ['<c-r>'],
-    \ 'ToggleByFname()':      ['<c-d>'],
-    \ 'ToggleType(1)':        ['<c-f>', '<c-up>'],
-    \ 'ToggleType(-1)':       ['<c-b>', '<c-down>'],
-    \ 'PrtExpandDir()':       ['<tab>'],
-    \ 'PrtInsert("c")':       ['<MiddleMouse>', '<insert>'],
-    \ 'PrtInsert()':          ['<c-\>'],
-    \ 'PrtCurStart()':        ['<c-a>'],
-    \ 'PrtCurEnd()':          ['<c-e>'],
-    \ 'PrtCurLeft()':         ['<c-h>', '<left>', '<c-^>'],
-    \ 'PrtCurRight()':        ['<c-l>', '<right>'],
-    \ 'PrtClearCache()':      ['<F5>'],
-    \ 'PrtDeleteEnt()':       ['<F7>'],
-    \ 'CreateNewFile()':      ['<c-y>'],
-    \ 'MarkToOpen()':         ['<c-z>'],
-    \ 'OpenMulti()':          ['<c-o>'],
-    \ 'PrtExit()':            ['<esc>', '<c-c>', '<c-g>'],
-    \ }
-<
-:  <bs> .vimrc
- <c-h> : >
-  let g:ctrlp_prompt_mappings = { 'PrtCurLeft()': ['<left>', '<c-^>'] }
-<
-
-                                                    *'g:ctrlp_line_prefix'*
-ctrlp
-: >
-  let g:ctrlp_line_prefix = '> '
-<
-
-                                                    *'g:ctrlp_open_single_match'*
-CtrlPCtrlP
-: >
-  let g:ctrlp_open_single_match = ['buffer tags', 'buffer']
-<
- |g:ctrlp_default_input| 
- >
-  fu! <SID>tagsUnderCursor()
-    try
-      let default_input_save = get(g:, 'ctrlp_default_input', '')
-      let g:ctrlp_default_input = expand('<cword>')
-      CtrlPBufTagAll
-    finally
-      if exists('default_input_save')
-        let g:ctrlp_default_input = default_input_save
-      endif
-    endtry
-  endfu
->
-<
-----------------------------------------
-MRU mode options:~
-
-                                                           *'g:ctrlp_mruf_max'*
-CtrlP: >
-  let g:ctrlp_mruf_max = 250
-<
-
-                                                       *'g:ctrlp_mruf_exclude'*
-CtrlP: >
-  let g:ctrlp_mruf_exclude = ''
-<
-: >
-  let g:ctrlp_mruf_exclude = '/tmp/.*\|/temp/.*' " MacOSX/Linux
-  let g:ctrlp_mruf_exclude = '^C:\\dev\\tmp\\.*' " Windows
-<
-
-                                                       *'g:ctrlp_mruf_include'*
-CtrlP: >
-  let g:ctrlp_mruf_include = ''
-<
-: >
-  let g:ctrlp_mruf_include = '\.py$\|\.rb$'
-<
-                                                       *'g:ctrlp_tilde_homedir'*
-1 MRU  $HOME  $HOME/$filepath 
- ~/$filepath  $HOME/$filepath : >
-  let g:ctrlp_tilde_homedir = 0
-<
-:  :CtrlPBookmarkDirAdd! 
-
-                                                      *'g:ctrlp_mruf_relative'*
-1: >
-  let g:ctrlp_mruf_relative = 0
-<
-: : >
-  let g:ctrlp_prompt_mappings = { 'ToggleMRURelative()': ['<F2>'] }
-<
-
-                                                 *'g:ctrlp_mruf_default_order'*
-1: >
-  let g:ctrlp_mruf_default_order = 0
-<
-
-                                                *'g:ctrlp_mruf_case_sensitive'*
-: >
-  let g:ctrlp_mruf_case_sensitive = 1
-<
-
-                                                *'g:ctrlp_mruf_save_on_update'*
- 0  CtrlP 
-Vim: >
-  let g:ctrlp_mruf_save_on_update = 1
-<
-                                                *'g:ctrlp_bufname_mod'*
- |filename-modifiers|  >
-  let g:ctrlp_bufname_mod = ':t'
-<
-                                                *'g:ctrlp_bufpath_mod'*
- |filename-modifiers|  >
-  let g:ctrlp_bufpath_mod = ':~:.:h'
-<
-----------------------------------------
-:~
-
-                                                          *'g:ctrlp_open_func'*
-: >
-  let g:ctrlp_open_func = {}
-<
-: >
-  let g:ctrlp_open_func = {
-    \ 'files'     : 'Function_Name_1',
-    \ 'buffers'   : 'Function_Name_2',
-    \ 'mru files' : 'Function_Name_3',
-    \ }
-<
-: >
-  function! Function_Name(action, line)
-    " :
-    " |
-    " +- a:action : :
-    " |             + 'e' :  <cr>  ()
-    " |             + 'h' :  <c-x> ()
-    " |             + 'v' :  <c-v> ()
-    " |             + 't' :  <c-t> ()
-    " |             + 'x' :  <c-o>  () "e[x]ternal"
-    " |
-    " +- a:line   : 
-
-  endfunction
-<
-: <c-z>  <c-o>
-
-:  <c-t> HTMLVim >
-  function! HTMLOpenFunc(action, line)
-    if a:action =~ '^[tx]$' && fnamemodify(a:line, ':e') =~? '^html\?$'
-
-      " 
-      let filename = fnameescape(fnamemodify(a:line, ':p'))
-
-      " CtrlP
-      call ctrlp#exit()
-
-      " 
-      silent! execute '!xdg-open' filename
-
-    elseif a:action == 'x' && fnamemodify(a:line, ':e') !~? '^html\?$'
-
-      " HTML <c-o> 
-      call feedkeys("\<c-o>")
-
-    else
-
-      " CtrlP
-      call call('ctrlp#acceptfile', [a:action, a:line])
-
-    endif
-  endfunction
-
-  let g:ctrlp_open_func = { 'files': 'HTMLOpenFunc' }
-<
-
-                                                        *'g:ctrlp_status_func'*
-CtrlP: >
-  let g:ctrlp_status_func = {}
-<
-: >
-  let g:ctrlp_status_func = {
-    \ 'main': 'Function_Name_1',
-    \ 'prog': 'Function_Name_2',
-    \ }
-<
-: >
-  " 
-  function! Function_Name_1(focus, byfname, regex, prev, item, next, marked)
-    " :
-    " |
-    " +- a:focus   : : "prt"  "win"
-    " |
-    " +- a:byfname : : "file"  "path"
-    " |
-    " +- a:regex   : : 1 or 0
-    " |
-    " +- a:prev    : 
-    " |
-    " +- a:item    : 
-    " |
-    " +- a:next    : 
-    " |
-    " +- a:marked  : 
-
-    return full_statusline
-  endfunction
-
-  " 
-  function! Function_Name_2(str)
-    " a:str : 
-
-    return full_statusline
-  endfunction
-<
- https://gist.github.com/1610859 
-
-                                                        *'g:ctrlp_buffer_func'*
-CtrlP: >
-  let g:ctrlp_buffer_func = {}
-<
-: >
-  let g:ctrlp_buffer_func = {
-    \ 'enter': 'Function_Name_1',
-    \ 'exit':  'Function_Name_2',
-    \ }
-<
-
-                                                         *'g:ctrlp_match_func'*
-CtrlP: >
-  let g:ctrlp_match_func = {}
-<
-: >
-  let g:ctrlp_match_func = { 'match': 'Function_Name' }
-<
-: >
-  function! Function_Name(items, str, limit, mmode, ispath, crfile, regex)
-    " :
-    " |
-    " +- a:items  : 
-    " |
-    " +- a:str    : 
-    " |
-    " +- a:limit  : 
-    " |
-    " +- a:mmode  : :
-    " |             + "full-line": 
-    " |             + "filename-only": 
-    " |             + "first-non-tab": 
-    " |             + "until-last-tab": 
-    " |
-    " +- a:ispath : rtscript.
-    " |             10
-    " |
-    " +- a:crfile : a:ispath1
-    " |
-    " +- a:regex  : : 1 or 0.
-
-    return list_of_matched_items
-  endfunction
-<
-
-:  { 'arg_type': 'dict' } 
-
-
-: >
-  let g:ctrlp_status_func = {
-    \ 'arg_type' : 'dict',
-    \ 'enter': 'Function_Name_1',
-    \ 'exit':  'Function_Name_2',
-    \ }
-
-  function! Function_Name_1(dict)
-    " where dict == {
-    " \ 'focus':   value,
-    " \ 'byfname': value,
-    " \ 'regex':   value,
-    " \ ...
-    " }
-  endfunction
-<
-                                                       *'g:ctrlp_brief_prompt'*
- 1 ,  <bs>  CtrlP 
-
-                                                          *ctrlp-default-value*
-
-: >
-  let g:ctrlp_path_nolim = 1
-
-
-===============================================================================
-                                                           *ctrlp-commands*
-
-                                                                       *:CtrlP*
-:CtrlP []
-   CtrlP
-
-   |g:ctrlp_working_path_mode| 
-     |:CtrlPCurFile|  |:CtrlPCurWD| 
-
-    <tab> []
-
-                                                                 *:CtrlPBuffer*
-:CtrlPBuffer
-   CtrlP
-
-                                                                *:CtrlPCurFile*
-:CtrlPCurFile
-     |g:ctrlp_working_path_mode| = ''  |:CtrlP| 
-    
-
-                                                                  *:CtrlPCurWD*
-:CtrlPCurWD
-     |g:ctrlp_working_path_mode| = ''  |:CtrlP| 
-    
-
-                                                                    *:CtrlPMRU*
-:CtrlPMRU
-   CtrlP
-
-                                                               *:CtrlPLastMode*
-:CtrlPLastMode [--dir]
-   CtrlP"--dir"
-
-                                                                   *:CtrlPRoot*
-:CtrlPRoot
-     |g:ctrlp_working_path_mode| = 'r' 
-    |:CtrlP| 
-
-                                                             *:CtrlPClearCache*
-:CtrlPClearCache
-   CtrlP <F5> 
-    |g:ctrlp_use_caching| 
-
-                                                         *:CtrlPClearAllCaches*
-:CtrlPClearAllCaches
-    |g:ctrlp_cache_dir| 
-
--------------------------------------------------------------------------------
- |ctrlp-extensions| 
-
-===============================================================================
-                                                        *ctrlp-mappings*
-
-                                                                *'ctrlp-<c-p>'*
-<c-p>
-    |Normal| CtrlP
-
-----------------------------------------
-:~
-
-  <c-d>
-    
-    : '>d>''>>>'
-
-  <c-r>                                                    *'ctrlp-fullregexp'*
-    
-    : 'r>>''>>>'
-
-    : |input-formats|  |g:ctrlp_regexp_search| 
-
-  <c-f>, 'forward' 
-  <c-up>
-     'next' 
-
-  <c-b>, 'backward' 
-  <c-down>
-     'previous' 
-
-  <tab>                                                *'ctrlp-autocompletion'*
-    
-
-  <s-tab>
-    
-
-  <esc>,
-  <c-c>,
-  <c-g>
-    CtrlP
-
-:~
-
-  <c-j>,
-  <down>
-    
-
-  <c-k>,
-  <up>
-    
-
-  <c-a>
-     'start' 
-
-  <c-e>
-     'end' 
-
-  <c-h>,
-  <left>,
-  <c-^>
-     'left' 
-
-  <c-l>,
-  <right>
-     'right' 
-
-:~
-
-  <c-]>,
-  <bs>
-    
-
-  <del>
-    
-
-  <c-w>
-    
-
-  <c-u>
-    
-
-:~
-
-  <c-n>
-    
-
-  <c-p>
-    
-
-/:~
-
-  <cr>
-     'current' 
-
-  <c-t>
-     'tab' 
-    Open the selected file in a new 'tab'.
-
-  <c-v>
-     'vertical' 
-
-  <c-x>,
-  <c-cr>,
-  <c-s>
-     'horizontal' 
-
-  <c-y>
-    
-
-:~
-
-  <c-z>
-    - / <c-o> 
-    - / <c-y> 
-
-  <c-o>
-    -  <c-z> 
-    -  <c-z> :
-
-      :
-        t - 
-        v - 
-        h - 
-        r - 
-        i - 
-        x -  |g:ctrlp_open_func| 
-
-       :
-        a - 
-        d - CtrlP
-
-:~
-
-  <F5>
-    - 
-    - 
-
-  <F7>
-    
-    - 
-    -  <c-z> 
-    
-    -  <c-z> 
-
-:~
-
-  <Insert>,                                                   *'ctrlp-pasting'*
-  <MiddleMouse>
-    
-
-  <c-\>
-     <cword> <cfile>
-    
-
- |g:ctrlp_prompt_mappings| 
-
-----------------------------------------
- <s-tab> :~
-
-  a-z
-  0-9
-  ~^-=;`',.+!@#$%&_(){}[]
-    
-
-===============================================================================
-                                                  *ctrlp-input-formats*
-
-:~
-
-a)  
-
-    : 'abc'  'a[^a]\{-}b[^b]\{-}c'
-
-b)  Vim |pattern| 
-    
-
-    : 'abc\d*efg'  'abc\d*efg'
-
-     |ctrlp-fullregexp|  
-    |g:ctrlp_regexp_search| 
-
-c)  ':'Vim
-    ':''\:'
-    
-
-    : ':45'45
-
-          ':/any\:string''any:string'
-
-          ':+setf\ myfiletype|50' 'myfiletype'
-          50
-
-          ':diffthis' |:diffthis| 
-
-    : Vim |++opt|  |+cmd|.
-
-d)   '..' 
-    :
->
-                  
-         ..           ../
-         ...          ../../
-         ....         ../../../
-<
-    : 
-
-    '@cd path/'CtrlPpath/'@cd %:h'
-    
-
-e)  '/''\'
-
-    
-     |g:ctrlp_user_command| )
-
-    : d)  e) 
-
-f)   <c-y>  <c-z> 
-    
-
-    :  'newdir/newfile.txt' 'newdir'
-          'newfile.txt'
-
-          'some/old/dirs/oldfile.txt' <c-z>  'newdir'
-          'newfile.txt''some/old/dirs'
-          'some/old/dirs/newdir/newfile.txt'.
-
-    : Windows '\'  '/'  |'shellslash'| 
-
-g)   <c-d> 
-    ab
-
-h)  ?
-
-===============================================================================
-                                                         *ctrlp-extensions*
-
-g:ctrlp_extensions: >
-  let g:ctrlp_extensions = ['tag', 'buffertag', 'quickfix', 'dir', 'rtscript',
-                          \ 'undo', 'line', 'changes', 'mixed', 'bookmarkdir']
-<
- <c-f> <c-b> 
-
-
-:~
-
-                                                                    *:CtrlPTag*
-  * :~
-    - : 'tag'
-    - : ":CtrlPTag"
-    - Vim |'tags'| 
-      
-      : set tags+=doc/tags
-
-                                                                 *:CtrlPBufTag*
-                                                              *:CtrlPBufTagAll*
-  * :~
-    - : 'buffertag'
-    - : ":CtrlPBufTag []"
-                ":CtrlPBufTagAll"
-    - 
-      |exuberant_ctags| 
-
-                                                               *:CtrlPQuickfix*
-  * :~
-    - : 'quickfix'
-    - : ":CtrlPQuickfix"
-    - 
-
-                                                                    *:CtrlPDir*
-  * :~
-    - : 'dir'
-    - : ":CtrlPDir [muu]"
-    - 
-    - :
-      + <cr> CtrlP
-      + <c-t> 
-      + <c-v> 
-      + <c-x> CtrlP
-
-                                                                    *:CtrlPRTS*
-  * :~
-    - : 'rtscript'
-    - : ":CtrlPRTS"
-    - vimscripts, docs, snippets...
-
-                                                                   *:CtrlPUndo*
-  * :~
-    - : 'undo'
-    - : ":CtrlPUndo"
-    - 
-
-                                                                   *:CtrlPLine*
-  * :~
-    - : 'line'
-    - : ":CtrlPLine []"
-    -  [buffer] 
-
-                                                                 *:CtrlPChange*
-                                                              *:CtrlPChangeAll*
-  * :~
-    - : 'changes'
-    - : ":CtrlPChange []",
-            ":CtrlPChangeAll".
-    - 
-
-                                                                  *:CtrlPMixed*
-  * :~
-    - : 'mixed'
-    - : ":CtrlPMixed"
-    - 
-
-                                                            *:CtrlPBookmarkDir*
-                                                         *:CtrlPBookmarkDirAdd*
-  * :~
-    - : 'bookmarkdir'
-    - : ":CtrlPBookmarkDir",
-            ":CtrlPBookmarkDirAdd [] []".
-            ":CtrlPBookmarkDirAdd! [] []".
-    - 
-    - [][] CtrlPBookmarkDir []
-      []
-    - [][] CtrlPBookmarkDir 
-      ( [CWD] )[] 
-
-       CtrlPBookmarkDir 
-      
-      >
-      augroup CtrlPDirMRU
-        autocmd!
-        autocmd FileType * if &modifiable | execute 'silent CtrlPBookmarkDirAdd! %:p:h' | endif
-      augroup END
-<
-
-    - :
-      + <cr> CtrlP
-      + <c-x> 
-      + <c-v> 
-      + <F7>
-        - 
-        -  <c-z> 
-
-                                                 *ctrlp-autoignore-extension*
-  * :~
-    - : 'autoignore'
-
-    -  `.ctrlpignore` 
-       ( |ctrlp_custom_ignore|)
-       CtrlP  `.gitignore`  `.hgignore`
-
-      :  |g:ctrlp_user_command| 
-
-      : `.ctrlpignore` ( |g:ctrlp_root_markers|).
-
-    - :
-       `#` 
-
-        *string-match* 
-       CtrlP 
-
-      :
-
-        \.tmp$
-        ^generated/
-        local\.cfg
-
-      :  Windows 
-
-       glob 
-
-        syntax:wildignore
-        *.tar.gz
-        *.tmp
-
-       |'wildignore'|
-      
-
-      
-
-        syntax:regexp
-
-      ...
-
-        dir:build
-        file:foo\.txt
-
-       "build"  "foo.txt" 
-       "build" 
-
-      :  "build"  "build" 
-       ^build$
-
-    - :
-      :  CtrlP  `.gitignore` or `.hgignore` ?
-
-      :  CtrlP 
-       CtrlP 
-      
-      
-      /
-       :)
-
-      :  |ctrlp-autoignore-extension|  `.ctrlpignore`
-      
-
-      : CtrlP 
-      <F5>  `.ctrlpignore` 
-
-----------------------------------------
-:~
-
-                                                   *'g:ctrlp_buftag_ctags_bin'*
-ctagsctags
-/opt/local/bin  /usr/local/bin: >
-  let g:ctrlp_buftag_ctags_bin = ''
-<
-
-                                                   *'g:ctrlp_buftag_systemenc'*
-VimVim
-|'encoding'| : >
-  let g:ctrlp_buftag_systemenc = &encoding
-<
-
-                                                       *'g:ctrlp_buftag_types'*
-ctags, jsctags...: >
-  let g:ctrlp_buftag_types = ''
-<
-: >
-  let g:ctrlp_buftag_types = {
-    \ 'erlang'     : '--language-force=erlang --erlang-types=drmf',
-    \ 'javascript' : {
-      \ 'bin': 'jsctags',
-      \ 'args': '-f -',
-      \ },
-    \ }
-<
-
-===============================================================================
-                                                    *ctrlp-customization*
-
-:~
-  * CtrlP:
-    CtrlPNoEntries : 
-    CtrlPMatch     : 
-    CtrlPLinePre   : '>'
-    CtrlPPrtBase   : 
-    CtrlPPrtText   :  |hl-Normal|
-    CtrlPPrtCursor : 
-
-  * :
-    CtrlPBufferNr     : 
-    CtrlPBufferInd    : '+', '-', '='  '#'  ( |:buffers|)
-    CtrlPBufferHid    : 
-    CtrlPBufferHidMod : 
-    CtrlPBufferVis    : 
-    CtrlPBufferVisMod : 
-    CtrlPBufferCur    : 
-    CtrlPBufferCurMod : 
-    CtrlPBufferPath   : 
-
-  * :
-    CtrlPTabExtra  : 
-    CtrlPBufName   : |hl-Directory|
-    CtrlPTagKind   : |hl-Title|
-    CtrlPqfLineCol : 
-    CtrlPUndoT     : |hl-Directory|
-    CtrlPUndoBr    : 
-    CtrlPUndoNr    : 
-    CtrlPUndoSv    : 
-    CtrlPUndoPo    : |hl-Title|
-    CtrlPBookmark  : 
-
-:~
-  * :
-    CtrlPMode1 : 'file'  'path'  'line'
-    CtrlPMode2 : 'prt'  'win' 'regex' |hl-LineNr| 
-    CtrlPStats : 
-
-   |g:ctrlp_status_func| 
-
-===============================================================================
-                                          *ctrlp-miscellaneous-configs*
-
-*  |g:ctrlp_user_command|  |wildignore| :
->
-  function! s:wig2cmd()
-    " wildignore|
-    " : .aux .out .toc .jpg .bmp .gif
-    "   .aux$\|.out$\|.toc$\|.jpg$\|.bmp$\|.gif$
-    let pats = ['[*\/]*\([?_.0-9A-Za-z]\+\)\([*\/]*\)\(\\\@<!,\|$\)','\\\@<!,']
-    let subs = has('win32') || has('win64') ? ['\1\3', ' '] : ['\1\2\3', '\\|']
-    let expr = substitute(&wig, pats[0], subs[0], 'g')
-    let expr = substitute(expr, pats[1], subs[1], 'g')
-    let expr = substitute(expr, '\\,', ',', 'g')
-
-    " 
-    let g:ctrlp_user_command = has('win32') || has('win64')
-      \ ? 'dir %s /-n /b /s /a-d | findstr /V /l "'.expr.'"'
-      \ : 'find %s -type f | grep -v "'.expr .'"'
-  endfunction
-
-  call s:wig2cmd()
-<
- Rich Alesi <github.com/ralesi> 
-
-* 
-* 
->
-  function! s:setcwd()
-    let cph = expand('%:p:h', 1)
-    if cph =~ '^.\+://' | retu | en
-    for mkr in ['.git/', '.hg/', '.svn/', '.bzr/', '_darcs/', '.vimprojects']
-      let wd = call('find'.(mkr =~ '/$' ? 'dir' : 'file'), [mkr, cph.';'])
-      if wd != '' | let &acd = 0 | brea | en
-    endfo
-    exe 'lc!' fnameescape(wd == '' ? cph : substitute(wd, mkr.'$', '.', ''))
-  endfunction
-
-  autocmd BufEnter * call s:setcwd()
-<
-( Vim 7.1.299+)
-
-*  |count| :
->
-  let g:ctrlp_cmd = 'exe "CtrlP".get(["", "Buffer", "MRU"], v:count)'
-<
-
-===============================================================================
-                                                        *ctrlp-credits*
-
- Kien Nguyen <github.com/kien> Github  ctrlpvim 
-(https://github.com/orgs/ctrlpvim/people) Vim |license| 
-
-:   http://ctrlpvim.github.com/ctrlp.vim
-Git :   https://github.com/ctrlpvim/ctrlp.vim
-
--------------------------------------------------------------------------------
-githubbitbucketbugdebugging
-
-:~
-
-    * Woojong Koh <github.com/wjkoh>
-    * Simon Ruderich
-    * Yasuhiro Matsumoto <github.com/mattn>
-    * Ken Earley <github.com/kenearley>
-    * Kyo Nagashima <github.com/hail2u>
-    * Zak Johnson <github.com/zakj>
-    * Diego Viola <github.com/diegoviola>
-    * Piet Delport <github.com/pjdelport>
-    * Thibault Duplessis <github.com/ornicar>
-    * Kent Sibilev <github.com/datanoise>
-    * Tacahiroy <github.com/tacahiroy>
-    * Luca Pette <github.com/lucapette>
-    * Seth Fowler <github.com/sfowler>
-    * Lowe Thiderman <github.com/thiderman>
-    * Christopher Fredn <github.com/icetan>
-    * Zahary Karadjov <github.com/zah>
-    * Jo De Boeck <github.com/grimpy>
-    * Rudi Grinberg <github.com/rgrinberg>
-    * Timothy Mellor <github.com/mellort>
-    * Sergey Vlasov <github.com/noscript>
-
-===============================================================================
-                                                      *ctrlp-changelog*
-
-    *  |g:ctrlp_custom_tag_files| 
-    *  g:ctrlp_match_window 0
-
-Before 2016/11/28~
-
-    + : |YankLine()| 
-    + : |g:ctrlp_types| 
-    + :  |g:ctrlp_user_command|  
-              |g:ctrlp_user_command_async|  1
-    +  delphi, rust  golangbuffertag
-    + : |g:ctrlp_brief_prompt|,
-              |g:match_current_file|,
-              |g:ctrlp_compare_lim|.
-    + : 
-    +  ant, tex, dosbatch, matlab  vhdlbuffertag
-    +  |g:ctrlp_line_prefix| 
-    +  |g:open_single_match|  matches 
-    +  <plug>(ctrlp) 
-    +  bang for CtrlPBookmarkDirAdd 
-    +  "g:ctrlp_TYPE_MODE" 
-                   : let g:ctrlp_path_sort
-    + : |g:ctrlp_custom_ancestors|
-
-2014/08/08~
-
-    +  ( |+conceal|)
-    + : |g:ctrlp_bufname_mod|,
-              |g:ctrlp_bufpath_mod|
-    +  *g:ctrlp_match_window_bottom* *g:ctrlp_match_window_reversed* 
-      *g:ctrlp_max_height*  |g:ctrlp_match_window| 
-    + : |g:ctrlp_match_window| 
-
-2012/11/30~
-
-    + : |g:ctrlp_abbrev|
-              |g:ctrlp_key_loop|
-              |g:ctrlp_open_func|
-              |g:ctrlp_tabpage_position|
-              |g:ctrlp_mruf_save_on_update|
-    + :
-        *g:ctrlp_dotfiles* -> |g:ctrlp_show_hidden| 
-    +  |g:ctrlp_switch_buffer|  |g:ctrlp_working_path_mode|
-      
-    +  |g:ctrlp_user_command| : 'ignore'
-
-2012/06/15~
-
-    + |g:ctrlp_follow_symlinks| : 2
-    + |g:ctrlp_open_multiple_files| : 'j'
-    +  <c-t>, <c-x>, <c-v>  <c-z> 
-    +  '..' (|ctrlp-input-formats| (d))
-    + : '@cd' (|ctrlp-input-formats| (d))
-
-2012/04/30~
-
-    + : |g:ctrlp_mruf_default_order|
-    + : 
-    + : |:CtrlPBookmarkDir|
-              |:CtrlPBookmarkDirAdd|
-
-2012/04/15~
-
-    + : |g:ctrlp_buffer_func|CtrlP
-    +   : g:ctrlp_mruf_last_entered
-    + : |:CtrlPLastMode|CtrlP
-              |:CtrlPMixed|
-
-2012/03/31~
-
-    + : |g:ctrlp_default_input| CtrlP
-              |g:ctrlp_match_func|
-    + :
-        *ClearCtrlPCache* -> |CtrlPClearCache|
-        *ClearAllCtrlPCaches* -> |CtrlPClearAllCaches|
-        *ResetCtrlP* -> |CtrlPReload|
-
-2012/03/02~
-
-    + :
-        *g:ctrlp_regexp_search* -> |g:ctrlp_regexp|
-        *g:ctrlp_dont_split* -> |g:ctrlp_reuse_window|
-        *g:ctrlp_jump_to_buffer* -> |g:ctrlp_switch_buffer|
-    + :
-        *g:ctrlp_open_multi* -> |g:ctrlp_open_multiple_files|
-    +  *g:ctrlp_highlight_match*
-    +  |g:ctrlp_user_command| 
-    + : |g:ctrlp_mruf_last_entered| 
-
-2012/01/15~
-
-    + :  <tab>  <s-tab>. <tab> 
-                  
-    + : |g:ctrlp_arg_map|  <c-y> <c-o> 
-              |g:ctrlp_status_func| 
-              |g:ctrlp_mruf_relative| 
-    +  g:ctrlp_open_multi  tr hr vr
-    +  |g:ctrlp_custom_ignore| 
-
-2012/01/05~
-
-    + : 
-    + : |:CtrlPBufTag|, |:CtrlPBufTagAll|
-    + : |g:ctrlp_cmd|
-              |g:ctrlp_custom_ignore|
-
-2011/11/30~
-
-    + : 
-    + : |:CtrlPTag|, |:CtrlPQuickfix|, |:CtrlPDir|
-    + : |g:ctrlp_use_migemo|
-              |g:ctrlp_lazy_update|
-              |g:ctrlp_follow_symlinks|
-
-2011/11/13~
-
-    + : '/'  '\'  (|ctrlp-input-formats| (e))
-    +  ctrlp#SetWorkingPath()
-    +  *g:ctrlp_mru_files* 
-    +  g:ctrlp_open_multi
-    + : g:ctrlp_dont_split
-              |g:ctrlp_mruf_case_sensitive|
-
-2011/10/30~
-
-    + : 
-              <F5> 
-    + : g:ctrlp_jump_to_buffer
-
-2011/10/12~
-
-    + : 
-              Vim |++opt|  |+cmd| 
-              (|ctrlp-input-formats| (c))
-               |:CtrlP| []
-    + : <c-z> / <c-o> 
-                  <c-o> 
-    + : g:ctrlp_open_multi
-    +  *g:ctrlp_persistent_input* *g:ctrlp_live_update* and <c-^>
-
-2011/09/29~
-
-    + : <c-n>, <c-p> /
-                  <c-y> 
-    + : |g:ctrlp_open_new_file|
-                   |g:ctrlp_max_history|
-    + <c-x>
-
-2011/09/19~
-
-    + : ResetCtrlP
-    + : |g:ctrlp_max_files|
-              |g:ctrlp_max_depth|
-              g:ctrlp_live_update
-    + : <c-^>
-
-2011/09/12~
-
-    + 
-    +  g:ctrlp_persistent_input
-    +  |:CtrlP| 
-    + : |g:ctrlp_dotfiles|
-              |g:ctrlp_clear_cache_on_exit|
-              g:ctrlp_highlight_match
-              |g:ctrlp_user_command|
-    + : '..' (|ctrlp-input-formats| (d))
-    + : <F5>
-    + : |:CtrlPCurWD|
-              |:CtrlPCurFile|
-              |:CtrlPRoot|
-
-    + : 
-    + : <c-b>
-    +  <c-f> 
-    + : g:ctrlp_mru_files
-              |g:ctrlp_mruf_max|
-              |g:ctrlp_mruf_exclude|
-              |g:ctrlp_mruf_include|
-    + : |:CtrlPMRU|
-
-: 2011/09/06~
-
-===============================================================================
-vim:ft=help:et:ts=2:sw=2:sts=2:norl
diff --git a/sources_non_forked/ctrlp.vim/doc/ctrlp.txt b/sources_non_forked/ctrlp.vim/doc/ctrlp.txt
deleted file mode 100644
index 56e3e5d..0000000
--- a/sources_non_forked/ctrlp.vim/doc/ctrlp.txt
+++ /dev/null
@@ -1,1682 +0,0 @@
-*ctrlp.txt*       Fuzzy file, buffer, mru, tag, ... finder. v1.80
-*CtrlP* *ControlP* *'ctrlp'* *'ctrl-p'*
-===============================================================================
-#                                                                             #
-#          :::::::: ::::::::::: :::::::::  :::             :::::::::          #
-#         :+:    :+:    :+:     :+:    :+: :+:             :+:    :+:         #
-#         +:+           +:+     +:+    +:+ +:+             +:+    +:+         #
-#         +#+           +#+     +#++:++#:  +#+             +#++:++#+          #
-#         +#+           +#+     +#+    +#+ +#+             +#+                #
-#         #+#    #+#    #+#     #+#    #+# #+#             #+#                #
-#          ########     ###     ###    ### ##########      ###                #
-#                                                                             #
-===============================================================================
-CONTENTS                                                       *ctrlp-contents*
-
-    1. Intro........................................|ctrlp-intro|
-    2. Options......................................|ctrlp-options|
-    3. Commands.....................................|ctrlp-commands|
-    4. Mappings.....................................|ctrlp-mappings|
-    5. Input Formats................................|ctrlp-input-formats|
-    6. Extensions...................................|ctrlp-extensions|
-
-===============================================================================
-INTRO                                                             *ctrlp-intro*
-
-Full path fuzzy file, buffer, mru, tag, ... finder with an intuitive interface.
-Written in pure Vimscript for MacVim, gVim and Vim version 7.0+. Has full
-support for Vim's |regexp| as search pattern, built-in MRU files monitoring,
-project's root finder, and more.
-
-To enable optional extensions (tag, dir, rtscript...), see |ctrlp-extensions|.
-
-===============================================================================
-OPTIONS                                                         *ctrlp-options*
-
-Overview:~
-
-  |loaded_ctrlp|................Disable the plugin.
-  |ctrlp_map|...................Default mapping.
-  |ctrlp_cmd|...................Default command used for the default mapping.
-  |ctrlp_by_filename|...........Default to filename mode or not.
-  |ctrlp_regexp|................Default to regexp mode or not.
-  |ctrlp_match_window|..........Order, height and position of the match window.
-  |ctrlp_switch_buffer|.........Jump to an open buffer if already opened.
-  |ctrlp_reuse_window|..........Reuse special windows (help, quickfix, etc).
-  |ctrlp_tabpage_position|......Where to put the new tab page.
-  |ctrlp_working_path_mode|.....How to set CtrlP's local working directory.
-  |ctrlp_root_markers|..........Additional, high priority root markers.
-  |ctrlp_use_caching|...........Use per-session caching or not.
-  |ctrlp_clear_cache_on_exit|...Keep cache after exiting Vim or not.
-  |ctrlp_cache_dir|.............Location of the cache directory.
-  |ctrlp_show_hidden|...........Ignore dotfiles and dotdirs or not.
-  |ctrlp_custom_ignore|.........Hide stuff when using |globpath()|.
-  |ctrlp_max_files|.............Number of files to scan initially.
-  |ctrlp_max_depth|.............Directory depth to recurse into when scanning.
-  |ctrlp_user_command|..........Use an external scanner.
-  |ctrlp_max_history|...........Number of entries saved in the prompt history.
-  |ctrlp_open_new_file|.........How to open a file created by <c-y>.
-  |ctrlp_open_multiple_files|...How to open files selected by <c-z>.
-  |ctrlp_arg_map|...............Intercept <c-y> and <c-o> or not.
-  |ctrlp_follow_symlinks|.......Follow symbolic links or not.
-  |ctrlp_lazy_update|...........Only update when typing has stopped.
-  |ctrlp_default_input|.........Seed the prompt with an initial string.
-  |ctrlp_abbrev|................Input abbreviations.
-  |ctrlp_key_loop|..............Use input looping for multi-byte input.
-  |ctrlp_prompt_mappings|.......Change the mappings inside the prompt.
-  |ctrlp_line_prefix|...........Prefix for each line in ctrlp window.
-  |ctrlp_open_single_match|.....Automatically accept when only one candidate.
-  |ctrlp_brief_prompt|..........Exit CtrlP on empty prompt by <bs>.
-  |ctrlp_match_current_file|....Include current file in match entries.
-  |ctrlp_types|.................Names of builtin types.
-
-  MRU mode:
-  |ctrlp_mruf_max|..............Max MRU entries to remember.
-  |ctrlp_mruf_exclude|..........Files that shouldn't be remembered.
-  |ctrlp_mruf_include|..........Files to be remembered.
-  |ctrlp_mruf_relative|.........Show only MRU files in the working directory.
-  |ctrlp_tilde_homedir|....Save MRU file paths in home dir as ~/.
-  |ctrlp_mruf_default_order|....Disable sorting.
-  |ctrlp_mruf_case_sensitive|...MRU files are case sensitive or not.
-  |ctrlp_mruf_save_on_update|...Save to disk whenever a new entry is added.
-
-  Buffer mode:
-  |ctrlp_bufname_mod|...........File name section modificator.
-  |ctrlp_bufpath_mod|...........File path section modificator.
-
-  BufferTag mode: (to enable, see |ctrlp-extensions|)
-  |g:ctrlp_buftag_ctags_bin|....The location of the ctags-compatible binary.
-  |g:ctrlp_buftag_systemenc|....The encoding used for the ctags command.
-  |g:ctrlp_buftag_types|........Add new filetypes and set the cmd arguments.
-
-  Advanced options:
-  |ctrlp_open_func|.............Use custom file opening functions.
-  |ctrlp_status_func|...........Change CtrlP's two statuslines.
-  |ctrlp_buffer_func|...........Call custom functions in the CtrlP buffer.
-  |ctrlp_match_func|............Replace the built-in matching algorithm.
-
--------------------------------------------------------------------------------
-Detailed descriptions and default values:~
-
-                                                                *'g:ctrlp_map'*
-Use this option to change the mapping to invoke CtrlP in |Normal| mode: >
-  let g:ctrlp_map = '<c-p>'
-<
-
-                                                                *'g:ctrlp_cmd'*
-Set the default opening command to use when pressing the above mapping: >
-  let g:ctrlp_cmd = 'CtrlP'
-<
-
-                                                             *'g:loaded_ctrlp'*
-Use this to disable the plugin completely: >
-  let g:loaded_ctrlp = 1
-<
-
-                                                        *'g:ctrlp_by_filename'*
-Set this to 1 to set searching by filename (as opposed to full path) as the
-default: >
-  let g:ctrlp_by_filename = 0
-<
-Can be toggled on/off by pressing <c-d> inside the prompt.
-
-                                                             *'g:ctrlp_regexp'*
-Set this to 1 to set regexp search as the default: >
-  let g:ctrlp_regexp = 0
-<
-Can be toggled on/off by pressing <c-r> inside the prompt.
-
-                                                       *'g:ctrlp_match_window'*
-Change the position, the listing order of results, the minimum and the maximum
-heights of the match window: >
-  let g:ctrlp_match_window = ''
-<
-Example: >
-  let g:ctrlp_match_window = 'bottom,order:btt,min:1,max:10,results:10'
-<
-The position: (default: bottom)
-  top - show the match window at the top of the screen.
-  bottom - show the match window at the bottom of the screen.
-
-The listing order of results: (default: btt)
-  order:ttb - from top to bottom.
-  order:btt - from bottom to top.
-
-The minimum and maximum heights:
-  min:{n} - show minimum {n} lines (default: 1).
-  max:{n} - show maximum {n} lines (default: 10).
-
-The maximum number of results:
-  results:{n} - list maximum {n} results (default: sync with max height).
-                0 mean no-limit.
-
-Note: When a setting isn't set, its default value will be used.
-
-                                                      *'g:ctrlp_switch_buffer'*
-When opening a file, if it's already open in a window somewhere, CtrlP will try
-to jump to it instead of opening a new instance: >
-  let g:ctrlp_switch_buffer = 'Et'
-<
-  e - jump when <cr> is pressed, but only to windows in the current tab.
-  t - jump when <c-t> is pressed, but only to windows in another tab.
-  v - like "e", but jump when <c-v> is pressed.
-  h - like "e", but jump when <c-x> is pressed.
-  E, T, V, H - like "e", "t", "v", and "h", but jump to windows anywhere.
-  0 or <empty> - disable this feature.
-
-                                                       *'g:ctrlp_reuse_window'*
-When opening a file with <cr>, CtrlP avoids opening it in windows created by
-plugins, help and quickfix. Use this to setup some exceptions: >
-  let g:ctrlp_reuse_window = 'netrw'
-<
-Acceptable values are partial name, filetype or buftype of the special buffers.
-Use regexp to specify the pattern.
-Example: >
-  let g:ctrlp_reuse_window = 'netrw\|help\|quickfix'
-<
-
-                                                   *'g:ctrlp_tabpage_position'*
-Where to put the new tab page when opening one: >
-  let g:ctrlp_tabpage_position = 'ac'
-<
-  a - after.
-  b - before.
-  c - the current tab page.
-  l - the last tab page.
-  f - the first tab page.
-
-                                                  *'g:ctrlp_working_path_mode'*
-When starting up, CtrlP sets its local working directory according to this
-variable: >
-  let g:ctrlp_working_path_mode = 'ra'
-<
-  c - the directory of the current file.
-  a - the directory of the current file, unless it is a subdirectory of the cwd
-  r - the nearest ancestor of the current file that contains one of these
-      directories or files:
-      .git .hg .svn .bzr _darcs
-  w - modifier to "r": start search from the cwd instead of the current file's
-      directory
-  0 or <empty> - disable this feature.
-
-Note #1: if "a" or "c" is included with "r", use the behavior of "a" or "c" (as
-a fallback) when a root can't be found.
-
-Note #2: you can use a |b:var| to set this option on a per buffer basis.
-
-                                                       *'g:ctrlp_root_markers'*
-Use this to set your own root markers in addition to the default ones (.git,
-.hg, .svn, .bzr, and _darcs). Your markers will take precedence: >
-  let g:ctrlp_root_markers = ['']
-<
-Note: you can use a |b:var| to set this option on a per buffer basis.
-
-                                                        *'g:ctrlp_use_caching'*
-Enable/Disable per-session caching: >
-  let g:ctrlp_use_caching = 1
-<
-  0 - Disable caching.
-  1 - Enable caching.
-  n - When bigger than 1, disable caching and use the number as the limit to
-      enable caching again.
-
-Note: you can quickly purge the cache by pressing <F5> while inside CtrlP.
-
-                                                *'g:ctrlp_clear_cache_on_exit'*
-Set this to 0 to enable cross-session caching by not deleting the cache files
-upon exiting Vim: >
-  let g:ctrlp_clear_cache_on_exit = 1
-<
-
-                                                          *'g:ctrlp_cache_dir'*
-Set the directory to store the cache files: >
-  let g:ctrlp_cache_dir = $HOME.'/.cache/ctrlp'
-<
-
-                                                        *'g:ctrlp_show_hidden'*
-Set this to 1 if you want CtrlP to scan for dotfiles and dotdirs: >
-  let g:ctrlp_show_hidden = 0
-<
-Note: does not apply when a command defined with |g:ctrlp_user_command| is
-being used.
-
-                                                           *'ctrlp-wildignore'*
-You can use Vim's |'wildignore'| to exclude files and directories from the
-results.
-Examples: >
-  " Excluding version control directories
-  set wildignore+=*/.git/*,*/.hg/*,*/.svn/*        " Linux/MacOSX
-  set wildignore+=*\\.git\\*,*\\.hg\\*,*\\.svn\\*  " Windows ('noshellslash')
-<
-Note #1: the `*/` in front of each directory glob is required.
-
-Note #2: |wildignore| influences the result of |expand()|, |globpath()| and
-|glob()| which many plugins use to find stuff on the system (e.g. VCS related
-plugins look for .git/, .hg/,... some other plugins look for external *.exe
-tools on Windows). So be a little mindful of what you put in your |wildignore|.
-
-                                                      *'g:ctrlp_custom_ignore'*
-In addition to |'wildignore'| and |g:ctrlp_show_hidden|, use this for files
-and directories you want only CtrlP to not show. Use regexp to specify the
-patterns: >
-  let g:ctrlp_custom_ignore = ''
-<
-Examples: >
-  let g:ctrlp_custom_ignore = '\v[\/]\.(git|hg|svn)$'
-  let g:ctrlp_custom_ignore = {
-    \ 'dir':  '\v[\/]\.(git|hg|svn)$',
-    \ 'file': '\v\.(exe|so|dll)$',
-    \ 'link': 'SOME_BAD_SYMBOLIC_LINKS',
-    \ }
-  let g:ctrlp_custom_ignore = {
-    \ 'file': '\v(\.cpp|\.h|\.hh|\.cxx)@<!$'
-    \ }
-  let g:ctrlp_custom_ignore = {
-    \ 'func': 'some#custom#match_function'
-    \ }
-<
-Note #1: by default, |wildignore| and |g:ctrlp_custom_ignore| only apply when
-|globpath()| is used to scan for files, thus these options do not apply when a
-command defined with |g:ctrlp_user_command| is being used.
-
-Note #2: when changing the option's variable type, remember to |:unlet| it
-first or restart Vim to avoid the "E706: Variable type mismatch" error.
-
-Note #3: when using the "func" ignore type, you must provide the full name of
-a function that can be called from CtrlP. An |autoload| function name is
-recommended here. The function must take 2 parameters, the item to match and
-its type. The type will be "dir", "file", or "link". The function must return
-1 if the item should be ignored, 0 otherwise.
-
-                                                          *'g:ctrlp_max_files'*
-The maximum number of files to scan, set to 0 for no limit: >
-  let g:ctrlp_max_files = 10000
-<
-Note: does not apply when a command defined with |g:ctrlp_user_command| is
-being used.
-
-                                                          *'g:ctrlp_max_depth'*
-The maximum depth of a directory tree to recurse into: >
-  let g:ctrlp_max_depth = 40
-<
-Note: does not apply when a command defined with |g:ctrlp_user_command| is
-being used.
-
-                                                       *'g:ctrlp_user_command'*
-Specify an external tool to use for listing files instead of using Vim's
-|globpath()|. Use %s in place of the target directory: >
-  let g:ctrlp_user_command = ''
-<
-Examples: >
-  let g:ctrlp_user_command = 'find %s -type f'       " MacOSX/Linux
-  let g:ctrlp_user_command = 'dir %s /-n /b /s /a-d' " Windows
-<
-You can also use 'grep', 'findstr' or something else to filter the results.
-Examples: >
-  let g:ctrlp_user_command =
-    \ 'find %s -type f | grep -v -P "\.jpg$|/tmp/"'          " MacOSX/Linux
-  let g:ctrlp_user_command =
-    \ 'dir %s /-n /b /s /a-d | findstr /v /l ".jpg \\tmp\\"' " Windows
-<
-Use a version control listing command when inside a repository, this is faster
-when scanning large projects: >
-  let g:ctrlp_user_command = [root_marker, listing_command, fallback_command]
-  let g:ctrlp_user_command = {
-    \ 'types': {
-      \ 1: [root_marker_1, listing_command_1],
-      \ n: [root_marker_n, listing_command_n],
-      \ },
-    \ 'fallback': fallback_command,
-    \ 'ignore': 0 or 1
-    \ }
-<
-Some examples: >
-  " Single VCS, listing command does not list untracked files:
-  let g:ctrlp_user_command = ['.git', 'cd %s && git ls-files']
-  let g:ctrlp_user_command = ['.hg', 'hg --cwd %s locate -I .']
-
-  " Multiple VCS's:
-  let g:ctrlp_user_command = {
-    \ 'types': {
-      \ 1: ['.git', 'cd %s && git ls-files'],
-      \ 2: ['.hg', 'hg --cwd %s locate -I .'],
-      \ },
-    \ 'fallback': 'find %s -type f'
-    \ }
-
-  " Single VCS, listing command lists untracked files (slower):
-  let g:ctrlp_user_command =
-    \ ['.git', 'cd %s && git ls-files -co --exclude-standard']
-
-  let g:ctrlp_user_command =
-    \ ['.hg', 'hg --cwd %s status -numac -I . $(hg root)'] " MacOSX/Linux
-
-  let g:ctrlp_user_command = ['.hg', 'for /f "tokens=1" %%a in (''hg root'') '
-    \ . 'do hg --cwd %s status -numac -I . %%a']           " Windows
-<
-Note #1: in the |Dictionary| format, 'fallback' and 'ignore' are optional. In
-the |List| format, fallback_command is optional.
-
-Note #2: if the fallback_command is empty or the 'fallback' key is not defined,
-|globpath()| will then be used when scanning outside of a repository.
-
-Note #3: unless the |Dictionary| format is used and 'ignore' is defined and set
-to 1, the |wildignore| and |g:ctrlp_custom_ignore| options do not apply when
-these custom commands are being used. When not present, 'ignore' is set to 0 by
-default to retain the performance advantage of using external commands.
-
-Note #4: when changing the option's variable type, remember to |:unlet| it
-first or restart Vim to avoid the "E706: Variable type mismatch" error.
-
-Note #5: you can use a |b:var| to set this option on a per buffer basis.
-
-                                                        *'g:ctrlp_max_history'*
-The maximum number of input strings you want CtrlP to remember. The default
-value mirrors Vim's global |'history'| option: >
-  let g:ctrlp_max_history = &history
-<
-Set to 0 to disable prompt's history. Browse the history with <c-n> and <c-p>.
-
-                                                      *'g:ctrlp_open_new_file'*
-Use this option to specify how the newly created file is to be opened when
-pressing <c-y>: >
-  let g:ctrlp_open_new_file = 'v'
-<
-  t - in a new tab.
-  h - in a new horizontal split.
-  v - in a new vertical split.
-  r - in the current window.
-
-                                                *'g:ctrlp_open_multiple_files'*
-If non-zero, this will enable opening multiple files with <c-z> and <c-o>: >
-  let g:ctrlp_open_multiple_files = 'v'
-<
-Example: >
-  let g:ctrlp_open_multiple_files = '2vjr'
-<
-For the number:
-  - If given, it'll be used as the maximum number of windows or tabs to create
-    when opening the files (the rest will be opened as hidden buffers).
-  - If not given, <c-o> will open all files, each in a new window or new tab.
-
-For the letters:
-  t - each file in a new tab.
-  h - each file in a new horizontal split.
-  v - each file in a new vertical split.
-  i - all files as hidden buffers.
-  j - after opening, jump to the first opened tab or window.
-  r - open the first file in the current window, then the remaining files in
-      new splits or new tabs depending on which of "h", "v" and "t" is also
-      present.
-
-                                                            *'g:ctrlp_arg_map'*
-When this is set to 1, the <c-o> and <c-y> mappings will accept one extra key
-as an argument to override their default behavior: >
-  let g:ctrlp_arg_map = 0
-<
-Pressing <c-o> or <c-y> will then prompt for a keypress. The key can be:
-  t - open in tab(s)
-  h - open in horizontal split(s)
-  v - open in vertical split(s)
-  i - open as hidden buffers (for <c-o> only)
-  c - clear the marked files (for <c-o> only)
-  r - open in the current window (for <c-y> only)
-  <esc>, <c-c>, <c-u> - cancel and go back to the prompt.
-  <cr> - use the default behavior specified with |g:ctrlp_open_new_file| and
-  |g:ctrlp_open_multiple_files|.
-
-                                                    *'g:ctrlp_follow_symlinks'*
-If non-zero, CtrlP will follow symbolic links when listing files: >
-  let g:ctrlp_follow_symlinks = 0
-<
-  0 - don't follow symbolic links.
-  1 - follow but ignore looped internal symlinks to avoid duplicates.
-  2 - follow all symlinks indiscriminately.
-
-Note: does not apply when a command defined with |g:ctrlp_user_command| is
-being used.
-
-                                                        *'g:ctrlp_lazy_update'*
-Set this to 1 to enable the lazy-update feature: only update the match window
-after typing's been stopped for a certain amount of time: >
-  let g:ctrlp_lazy_update = 0
-<
-If is 1, update after 250ms. If bigger than 1, the number will be used as the
-delay time in milliseconds.
-
-                                                      *'g:ctrlp_default_input'*
-Set this to 1 to enable seeding the prompt with the current file's relative
-path: >
-  let g:ctrlp_default_input = 0
-<
-Instead of 1 or 0, if the value of the option is a string, it'll be used as-is
-as the default input: >
-  let g:ctrlp_default_input = 'anystring'
-<
-This option works well together with |g:ctrlp_open_single_match|
-
-
-                                                 *'g:ctrlp_match_current_file'*
-Includes the current file in the match entries: >
-  let g:ctrlp_match_current_file = 1
-
-By default, the current file is excluded from the list.
-
-Note: does not apply when |g:ctrlp_match_func| is used. 
-
-                                                              *'g:ctrlp_types'*
-Set this to list of names to customize core types: >
-  let g:ctrlp_types = ['mru', 'fil']
-
-By default, the types are: >
-  let g:ctrlp_types = ['fil', 'buf', 'mru'].
-
-                                                             *'g:ctrlp_abbrev'*
-Define input abbreviations that can be expanded (either internally or visibly)
-in the prompt: >
-  let g:ctrlp_abbrev = {}
-<
-Examples: >
-  let g:ctrlp_abbrev = {
-    \ 'gmode': 'i',
-    \ 'abbrevs': [
-      \ {
-        \ 'pattern': '^cd b',
-        \ 'expanded': '@cd ~/.vim/bundle',
-        \ 'mode': 'pfrz',
-      \ },
-      \ {
-        \ 'pattern': '\(^@.\+\|\\\@<!:.\+\)\@<! ',
-        \ 'expanded': '.\{-}',
-        \ 'mode': 'pfr',
-      \ },
-      \ {
-        \ 'pattern': '\\\@<!:.\+\zs\\\@<! ',
-        \ 'expanded': '\ ',
-        \ 'mode': 'pfz',
-      \ },
-      \ ]
-    \ }
-<
-The 'pattern' string is regexp matched against the entered input. The expansion
-is as if the 'expanded' string was typed into the prompt.
-
-For 'gmode' (optional):
-  i - expand internally (default).
-  t - insert the expanded results into the prompt as you type.
-  k - insert the expanded results when a non-keyword character is typed. Only
-      applies when "t" is also present.
-
-For 'mode' (of each entry; optional):
-  f - only in filename mode.
-  p - only in full path mode.
-  r - only in regexp mode.
-  z - only in fuzzy mode.
-  n - only when creating a new file with <c-y> (use the expanded string in the
-      new filename).
-  c - only when auto-completing directory names with <tab> (expand the pattern
-      immediately before doing the auto-completion).
-  <empty> or not defined - always enable.
-
-Note: the abbrev entries are evaluated in sequence, so a later entry can be
-evaluated against the expanded result of a previous entry; this includes itself
-when 'gmode' is "t".
-
-                                                           *'g:ctrlp_key_loop'*
-An experimental feature. Set this to 1 to enable input looping for the typing
-of multi-byte characters: >
-  let g:ctrlp_key_loop = 0
-<
-Note #1: when set, this option resets the |g:ctrlp_lazy_update| option.
-
-Note #2: you can toggle this feature inside the prompt with a custom mapping: >
-  let g:ctrlp_prompt_mappings = { 'ToggleKeyLoop()': ['<F3>'] }
-<
-
-                                                    *'g:ctrlp_prompt_mappings'*
-Use this to customize the mappings inside CtrlP's prompt to your liking. You
-only need to keep the lines that you've changed the values (inside []): >
-  let g:ctrlp_prompt_mappings = {
-    \ 'PrtBS()':              ['<bs>', '<c-]>'],
-    \ 'PrtDelete()':          ['<del>'],
-    \ 'PrtDeleteWord()':      ['<c-w>'],
-    \ 'PrtClear()':           ['<c-u>'],
-    \ 'PrtSelectMove("j")':   ['<c-j>', '<down>'],
-    \ 'PrtSelectMove("k")':   ['<c-k>', '<up>'],
-    \ 'PrtSelectMove("t")':   ['<Home>', '<kHome>'],
-    \ 'PrtSelectMove("b")':   ['<End>', '<kEnd>'],
-    \ 'PrtSelectMove("u")':   ['<PageUp>', '<kPageUp>'],
-    \ 'PrtSelectMove("d")':   ['<PageDown>', '<kPageDown>'],
-    \ 'PrtHistory(-1)':       ['<c-n>'],
-    \ 'PrtHistory(1)':        ['<c-p>'],
-    \ 'AcceptSelection("e")': ['<cr>', '<2-LeftMouse>'],
-    \ 'AcceptSelection("h")': ['<c-x>', '<c-cr>', '<c-s>'],
-    \ 'AcceptSelection("t")': ['<c-t>'],
-    \ 'AcceptSelection("v")': ['<c-v>', '<RightMouse>'],
-    \ 'ToggleFocus()':        ['<s-tab>'],
-    \ 'ToggleRegex()':        ['<c-r>'],
-    \ 'ToggleByFname()':      ['<c-d>'],
-    \ 'ToggleType(1)':        ['<c-f>', '<c-up>'],
-    \ 'ToggleType(-1)':       ['<c-b>', '<c-down>'],
-    \ 'PrtExpandDir()':       ['<tab>'],
-    \ 'PrtInsert("c")':       ['<MiddleMouse>', '<insert>'],
-    \ 'PrtInsert()':          ['<c-\>'],
-    \ 'PrtCurStart()':        ['<c-a>'],
-    \ 'PrtCurEnd()':          ['<c-e>'],
-    \ 'PrtCurLeft()':         ['<c-h>', '<left>', '<c-^>'],
-    \ 'PrtCurRight()':        ['<c-l>', '<right>'],
-    \ 'PrtClearCache()':      ['<F5>'],
-    \ 'PrtDeleteEnt()':       ['<F7>'],
-    \ 'CreateNewFile()':      ['<c-y>'],
-    \ 'MarkToOpen()':         ['<c-z>'],
-    \ 'OpenMulti()':          ['<c-o>'],
-    \ 'PrtExit()':            ['<esc>', '<c-c>', '<c-g>'],
-    \ }
-<
-Note: if pressing <bs> moves the cursor one character to the left instead of
-deleting a character for you, add this to your |.vimrc| to disable the plugin's
-default <c-h> mapping: >
-  let g:ctrlp_prompt_mappings = { 'PrtCurLeft()': ['<left>', '<c-^>'] }
-<
-
-                                                    *'g:ctrlp_line_prefix'*
-This prefix will be prepended to each line in ctrlp's item listing.
-default: >
-  let g:ctrlp_line_prefix = '> '
-<
-
-                                                    *'g:ctrlp_open_single_match'*
-List of CtrlP modes for which CtrlP should accept an entry directly, if only
-one candidate exists.
-Example: >
-  let g:ctrlp_open_single_match = ['buffer tags', 'buffer']
-<
-This is currently only really useful together with |g:ctrlp_default_input|
-set before launching, and cleared afterwards, with a function such as
-following: >
-  fu! <SID>tagsUnderCursor()
-    try
-      let default_input_save = get(g:, 'ctrlp_default_input', '')
-      let g:ctrlp_default_input = expand('<cword>')
-      CtrlPBufTagAll
-    finally
-      if exists('default_input_save')
-        let g:ctrlp_default_input = default_input_save
-      endif
-    endtry
-  endfu
->
-<
-----------------------------------------
-MRU mode options:~
-
-                                                           *'g:ctrlp_mruf_max'*
-Specify the number of recently opened files you want CtrlP to remember: >
-  let g:ctrlp_mruf_max = 250
-<
-
-                                                       *'g:ctrlp_mruf_exclude'*
-Files you don't want CtrlP to remember. Use regexp to specify the patterns: >
-  let g:ctrlp_mruf_exclude = ''
-<
-Examples: >
-  let g:ctrlp_mruf_exclude = '/tmp/.*\|/temp/.*' " MacOSX/Linux
-  let g:ctrlp_mruf_exclude = '^C:\\dev\\tmp\\.*' " Windows
-<
-
-                                                       *'g:ctrlp_mruf_include'*
-And if you want CtrlP to only remember some files, specify them here: >
-  let g:ctrlp_mruf_include = ''
-<
-Example: >
-  let g:ctrlp_mruf_include = '\.py$\|\.rb$'
-<
-
-                                                 *'g:ctrlp_tilde_homedir'*
-Set this to 1 to save every MRU file path $HOME/$filepath in the $HOME dir
-  as ~/$filepath instead of $HOME/$filepath : >
-  let g:ctrlp_tilde_homedir = 0
-<
-Note: This applies also to all dir paths stored by :CtrlPBookmarkDirAdd!
-
-                                                      *'g:ctrlp_mruf_relative'*
-Set this to 1 to show only MRU files in the current working directory: >
-  let g:ctrlp_mruf_relative = 0
-<
-Note: you can use a custom mapping to toggle this option inside the prompt: >
-  let g:ctrlp_prompt_mappings = { 'ToggleMRURelative()': ['<F2>'] }
-<
-                                                 *'g:ctrlp_mruf_default_order'*
-Set this to 1 to disable sorting when searching in MRU mode: >
-  let g:ctrlp_mruf_default_order = 0
-<
-
-                                                *'g:ctrlp_mruf_case_sensitive'*
-Match this with your file system case-sensitivity setting to avoid duplicate
-MRU entries: >
-  let g:ctrlp_mruf_case_sensitive = 1
-<
-
-                                                *'g:ctrlp_mruf_save_on_update'*
-Set this to 0 to disable saving of the MRU list to hard drive whenever a new
-entry is added, saving will then only occur when exiting Vim: >
-  let g:ctrlp_mruf_save_on_update = 1
-<
-                                                *'g:ctrlp_bufname_mod'*
-Modify file name section according to modificator string. See |filename-modifiers|. >
-  let g:ctrlp_bufname_mod = ':t'
-<
-                                                *'g:ctrlp_bufpath_mod'*
-Modify file path section according to modificator string. See |filename-modifiers|. >
-  let g:ctrlp_bufpath_mod = ':~:.:h'
-<
-----------------------------------------
-Advanced options:~
-
-                                                          *'g:ctrlp_open_func'*
-Define a custom function to open the selected file: >
-  let g:ctrlp_open_func = {}
-<
-Example: >
-  let g:ctrlp_open_func = {
-    \ 'files'     : 'Function_Name_1',
-    \ 'buffers'   : 'Function_Name_2',
-    \ 'mru files' : 'Function_Name_3',
-    \ }
-<
-Structure of the functions: >
-  function! Function_Name(action, line)
-    " Arguments:
-    " |
-    " +- a:action : The opening action:
-    " |             + 'e' : user pressed <cr>  (default)
-    " |             + 'h' : user pressed <c-x> (default)
-    " |             + 'v' : user pressed <c-v> (default)
-    " |             + 't' : user pressed <c-t> (default)
-    " |             + 'x' : user used the <c-o> console dialog (default) and
-    " |                     chose "e[x]ternal".
-    " |
-    " +- a:line   : The selected line.
-
-  endfunction
-<
-Note: does not apply when opening multiple files with <c-z> and <c-o>.
-
-Example: open HTML files in the default web browser when <c-t> is pressed and
-in Vim otherwise >
-  function! HTMLOpenFunc(action, line)
-    if a:action =~ '^[tx]$' && fnamemodify(a:line, ':e') =~? '^html\?$'
-
-      " Get the filename
-      let filename = fnameescape(fnamemodify(a:line, ':p'))
-
-      " Close CtrlP
-      call ctrlp#exit()
-
-      " Open the file
-      silent! execute '!xdg-open' filename
-
-    elseif a:action == 'x' && fnamemodify(a:line, ':e') !~? '^html\?$'
-
-      " Not a HTML file, simulate pressing <c-o> again and wait for new input
-      call feedkeys("\<c-o>")
-
-    else
-
-      " Use CtrlP's default file opening function
-      call call('ctrlp#acceptfile', [a:action, a:line])
-
-    endif
-  endfunction
-
-  let g:ctrlp_open_func = { 'files': 'HTMLOpenFunc' }
-<
-
-                                                        *'g:ctrlp_status_func'*
-Use this to customize the statuslines for the CtrlP window: >
-  let g:ctrlp_status_func = {}
-<
-Example: >
-  let g:ctrlp_status_func = {
-    \ 'main': 'Function_Name_1',
-    \ 'prog': 'Function_Name_2',
-    \ }
-<
-Structure of the functions: >
-  " Main statusline
-  function! Function_Name_1(focus, byfname, regex, prev, item, next, marked)
-    " Arguments:
-    " |
-    " +- a:focus   : The focus of the prompt: "prt" or "win".
-    " |
-    " +- a:byfname : In filename mode or in full path mode: "file" or "path".
-    " |
-    " +- a:regex   : In regex mode: 1 or 0.
-    " |
-    " +- a:prev    : The previous search mode.
-    " |
-    " +- a:item    : The current search mode.
-    " |
-    " +- a:next    : The next search mode.
-    " |
-    " +- a:marked  : The number of marked files, or a comma separated list of
-    "                the marked filenames.
-
-    return full_statusline
-  endfunction
-
-  " Progress statusline
-  function! Function_Name_2(str)
-    " a:str : Either the number of files scanned so far, or a string indicating
-    "         the current directory is being scanned with a user_command.
-
-    return full_statusline
-  endfunction
-<
-See https://gist.github.com/1610859 for a working example.
-
-                                                        *'g:ctrlp_buffer_func'*
-Specify the functions that will be called after entering and before exiting the
-CtrlP buffer: >
-  let g:ctrlp_buffer_func = {}
-<
-Example: >
-  let g:ctrlp_buffer_func = {
-    \ 'enter': 'Function_Name_1',
-    \ 'exit':  'Function_Name_2',
-    \ }
-<
-
-                                                         *'g:ctrlp_match_func'*
-Set an external fuzzy matching function for CtrlP to use: >
-  let g:ctrlp_match_func = {}
-<
-Example: >
-  let g:ctrlp_match_func = { 'match': 'Function_Name' }
-<
-Structure of the function: >
-  function! Function_Name(items, str, limit, mmode, ispath, crfile, regex)
-    " Arguments:
-    " |
-    " +- a:items  : The full list of items to search in.
-    " |
-    " +- a:str    : The string entered by the user.
-    " |
-    " +- a:limit  : The max height of the match window. Can be used to limit
-    " |             the number of items to return.
-    " |
-    " +- a:mmode  : The match mode. Can be one of these strings:
-    " |             + "full-line": match the entire line.
-    " |             + "filename-only": match only the filename.
-    " |             + "first-non-tab": match until the first tab char.
-    " |             + "until-last-tab": match until the last tab char.
-    " |
-    " +- a:ispath : Is 1 when searching in file, buffer, mru, mixed, dir, and
-    " |             rtscript modes. Is 0 otherwise.
-    " |
-    " +- a:crfile : The file in the current window. Should be excluded from the
-    " |             results when a:ispath == 1.
-    " |
-    " +- a:regex  : In regex mode: 1 or 0.
-
-    return list_of_matched_items
-  endfunction
-<
-
-Note: you can extend any of the above options with { 'arg_type': 'dict' } to
-enable passing all the function arguments in a single Dictionary argument. Use
-the existing argument names as keys in this Dictionary.
-
-Example: >
-  let g:ctrlp_status_func = {
-    \ 'arg_type' : 'dict',
-    \ 'enter': 'Function_Name_1',
-    \ 'exit':  'Function_Name_2',
-    \ }
-
-  function! Function_Name_1(dict)
-    " where dict == {
-    " \ 'focus':   value,
-    " \ 'byfname': value,
-    " \ 'regex':   value,
-    " \ ...
-    " }
-  endfunction
-<
-                                                       *'g:ctrlp_brief_prompt'*
-When this is set to 1, the <bs> on empty prompt exit CtrlP.
-
-                                                          *ctrlp-default-value*
-Otherwise, you can use below to change default value.
-Example: >
-  let g:ctrlp_path_nolim = 1
-
-This is possible to change no-limit mode for match type "path".
-
-===============================================================================
-COMMANDS                                                       *ctrlp-commands*
-
-                                                                       *:CtrlP*
-:CtrlP [starting-directory]
-   Open CtrlP in find file mode.
-
-   If no argument is given, the value of |g:ctrlp_working_path_mode| will be
-   used to determine the starting directory.  See |:CtrlPCurFile| and
-   |:CtrlPCurWD| to temporarily override the setting.
-
-   You can use <tab> to auto-complete the [starting-directory] when typing it.
-
-                                                                 *:CtrlPBuffer*
-:CtrlPBuffer
-   Open CtrlP in find buffer mode.
-
-                                                                *:CtrlPCurFile*
-:CtrlPCurFile
-    This acts like |:CtrlP| with |g:ctrlp_working_path_mode| = 'c' and ignores
-    the variable's current value.
-
-                                                                  *:CtrlPCurWD*
-:CtrlPCurWD
-    This acts like |:CtrlP| with |g:ctrlp_working_path_mode| = 'd' and ignores
-    the variable's current value.
-
-                                                                    *:CtrlPMRU*
-:CtrlPMRU
-   Open CtrlP in find Most-Recently-Used file mode.
-
-                                                               *:CtrlPLastMode*
-:CtrlPLastMode [--dir]
-   Open CtrlP in the last mode used. When having the "--dir" argument, also
-   reuse the last working directory.
-
-                                                                   *:CtrlPRoot*
-:CtrlPRoot
-    This acts like |:CtrlP| with |g:ctrlp_working_path_mode| = 'r' and ignores
-    the variable's current value.
-
-                                                             *:CtrlPClearCache*
-:CtrlPClearCache
-   Flush the cache for the current working directory. The same as pressing <F5>
-   inside CtrlP.
-   To enable or disable caching, use the |g:ctrlp_use_caching| option.
-
-                                                         *:CtrlPClearAllCaches*
-:CtrlPClearAllCaches
-   Delete all the cache files saved in |g:ctrlp_cache_dir| location.
-
--------------------------------------------------------------------------------
-For commands provided by bundled extensions, see |ctrlp-extensions|.
-
-===============================================================================
-MAPPINGS                                                       *ctrlp-mappings*
-
-                                                                *'ctrlp-<c-p>'*
-<c-p>
-   Default |Normal| mode mapping to open the CtrlP prompt in find file mode.
-
-----------------------------------------
-Once inside the prompt:~
-
-  <c-d>
-    Toggle between full-path search and filename only search.
-    Note: in filename mode, the prompt's base is '>d>' instead of '>>>'
-
-  <c-r>                                                    *'ctrlp-fullregexp'*
-    Toggle between the string mode and full regexp mode.
-    Note: in full regexp mode, the prompt's base is 'r>>' instead of '>>>'
-
-    See also: |input-formats| (guide) and |g:ctrlp_regexp_search| (option).
-
-  <c-f>, 'forward'
-  <c-up>
-    Scroll to the 'next' search mode in the sequence.
-
-  <c-b>, 'backward'
-  <c-down>
-    Scroll to the 'previous' search mode in the sequence.
-
-  <tab>                                                *'ctrlp-autocompletion'*
-    Auto-complete directory names under the current working directory inside
-    the prompt.
-
-  <s-tab>
-    Toggle the focus between the match window and the prompt.
-
-  <esc>,
-  <c-c>,
-  <c-g>
-    Exit CtrlP.
-
-Moving:~
-
-  <c-j>,
-  <down>
-    Move selection down.
-
-  <c-k>,
-  <up>
-    Move selection up.
-
-  <c-a>
-    Move the cursor to the 'start' of the prompt.
-
-  <c-e>
-    Move the cursor to the 'end' of the prompt.
-
-  <c-h>,
-  <left>,
-  <c-^>
-    Move the cursor one character to the 'left'.
-
-  <c-l>,
-  <right>
-    Move the cursor one character to the 'right'.
-
-Editing:~
-
-  <c-]>,
-  <bs>
-    Delete the preceding character.
-
-  <del>
-    Delete the current character.
-
-  <c-w>
-    Delete a preceding inner word.
-
-  <c-u>
-    Clear the input field.
-
-Browsing input history:~
-
-  <c-n>
-    Next string in the prompt's history.
-
-  <c-p>
-    Previous string in the prompt's history.
-
-Opening/Creating a file:~
-
-  <cr>
-    Open the selected file in the 'current' window if possible.
-
-  <c-t>
-    Open the selected file in a new 'tab'.
-
-  <c-v>
-    Open the selected file in a 'vertical' split.
-
-  <c-x>,
-  <c-cr>,
-  <c-s>
-    Open the selected file in a 'horizontal' split.
-
-  <c-y>
-    Create a new file and its parent directories.
-
-Opening multiple files:~
-
-  <c-z>
-    - Mark/unmark a file to be opened with <c-o>.
-    - Mark/unmark a file to create a new file in its directory using <c-y>.
-
-  <c-o>
-    - Open files marked by <c-z>.
-    - When no file has been marked by <c-z>, open a console dialog with the
-      following options:
-
-      Open the selected file:
-        t - in a tab page.
-        v - in a vertical split.
-        h - in a horizontal split.
-        r - in the current window.
-        i - as a hidden buffer.
-        x - (optional) with the function defined in |g:ctrlp_open_func|.
-
-      Other options (not shown):
-        a - mark all files in the match window.
-        d - change CtrlP's local working directory to the selected file's
-            directory and switch to find file mode.
-
-Function keys:~
-
-  <F5>
-    - Refresh the match window and purge the cache for the current directory.
-    - Remove deleted files from the MRU list.
-
-  <F7>
-    MRU mode:
-    - Wipe the list.
-    - Delete entries marked by <c-z>.
-    Buffer mode:
-    - Delete entry under the cursor or delete multiple entries marked by <c-z>.
-
-
-Pasting:~
-
-  <Insert>,                                                   *'ctrlp-pasting'*
-  <MiddleMouse>
-    Paste the clipboard content into the prompt.
-
-  <c-\>
-    Open a console dialog to paste <cword>, <cfile>, the content of the search
-    register, the last visual selection, the clipboard or any register into the
-    prompt.
-
-Choose your own mappings with |g:ctrlp_prompt_mappings|.
-
-----------------------------------------
-When inside the match window (press <s-tab> to switch):~
-
-  a-z
-  0-9
-  ~^-=;`',.+!@#$%&_(){}[]
-    Cycle through the lines which have the matching first character.
-
-===============================================================================
-INPUT FORMATS                                             *ctrlp-input-formats*
-
-Formats for inputting in the prompt:~
-
-a)  Simple string.
-
-    E.g. 'abc' is understood internally as 'a[^a]\{-}b[^b]\{-}c'
-
-b)  When in regexp mode, the input string's treated as a Vim's regexp |pattern|
-    without any modification.
-
-    E.g. 'abc\d*efg' will be read as 'abc\d*efg'.
-
-    See |ctrlp-fullregexp| (keymap) and |g:ctrlp_regexp_search| (option) for
-    how to enable regexp mode.
-
-c)  End the string with a colon ':' followed by a Vim command to execute that
-    command after opening the file. If you need to use ':' literally, escape it
-    with a backslash: '\:'. When opening multiple files, the command will be
-    executed on each opening file.
-
-    E.g. Use ':45' to jump to line 45.
-
-         Use ':/any\:string' to jump to the first instance of 'any:string'.
-
-         Use ':+setf\ myfiletype|50' to set the filetype to 'myfiletype', then
-         jump to line 50.
-
-         Use ':diffthis' when opening multiple files to run |:diffthis| on the
-         first 4 files.
-
-    See also: Vim's |++opt| and |+cmd|.
-
-d)  Input two dots '..' and then hit the <Enter> key to go upward the directory tree by 1 level. To go up
-    multiple levels, use one extra dot for each extra level:
->
-         Raw input    Interpreted as
-         ..<Cr>           ../
-         ...<Cr>          ../../
-         ....<Cr>         ../../../
-<
-    Note: if the parent directories are large and uncached, this can be slow.
-
-    You can also use '@cd path/' to change CtrlP's local working directory.
-    Use '@cd %:h' to change to the directory of the current file.
-
-e)  Similarly, submit '/' or '\' to find and go to the project's root.
-
-    If the project is large, using a VCS listing command to look for files
-    might help speeding up the initial scan (see |g:ctrlp_user_command| for more
-    details).
-
-    Note: d) and e) only work in file, directory and mixed modes.
-
-f)  Type the name of a non-existent file and press <c-y> to create it. Mark a
-    file with <c-z> to create the new file in the same directory as the marked
-    file.
-
-    E.g. Using 'newdir/newfile.txt' will create a directory named 'newdir' as
-         well as a file named 'newfile.txt'.
-
-         If an entry 'some/old/dirs/oldfile.txt' is marked with <c-z>, then
-         'newdir' and 'newfile.txt' will be created under 'some/old/dirs'. The
-         final path will then be 'some/old/dirs/newdir/newfile.txt'.
-
-    Note: use '\' in place of '/' on Windows (if |'shellslash'| is not set).
-
-g)  In filename mode (toggle with <c-d>), you can use one primary pattern and
-    one refining pattern separated by a semicolon. Both patterns work like (a),
-    or (b) when in regexp mode.
-
-h)  Submit ? to open this help file.
-
-===============================================================================
-EXTENSIONS                                                   *ctrlp-extensions*
-
-Extensions are optional. To enable an extension, add its name to the variable
-g:ctrlp_extensions: >
-  let g:ctrlp_extensions = ['tag', 'buffertag', 'quickfix', 'dir', 'rtscript',
-                          \ 'undo', 'line', 'changes', 'mixed', 'bookmarkdir']
-<
-The order of the items will be the order they appear on the statusline and when
-using <c-f>, <c-b>.
-
-Available extensions:~
-
-                                                                    *:CtrlPTag*
-  * Tag mode:~
-    - Name: 'tag'
-    - Command: ":CtrlPTag"
-    - Search for a tag within a generated central tags file, and jump to the
-      definition. Use the Vim's option |'tags'| to specify the names and the
-      locations of the tags file(s).
-      E.g. set tags+=doc/tags
-
-                                                                 *:CtrlPBufTag*
-                                                              *:CtrlPBufTagAll*
-  * Buffer Tag mode:~
-    - Name: 'buffertag'
-    - Commands: ":CtrlPBufTag [buffer]",
-                ":CtrlPBufTagAll".
-    - Search for a tag within the current buffer or all listed buffers and jump
-      to the definition. Requires |exuberant_ctags| or compatible programs.
-
-                                                               *:CtrlPQuickfix*
-  * Quickfix mode:~
-    - Name: 'quickfix'
-    - Command: ":CtrlPQuickfix"
-    - Search for an entry in the current quickfix errors and jump to it.
-
-                                                                    *:CtrlPDir*
-  * Directory mode:~
-    - Name: 'dir'
-    - Command: ":CtrlPDir [starting-directory]"
-    - Search for a directory and change the working directory to it.
-    - Mappings:
-      + <cr> change the local working directory for CtrlP and keep it open.
-      + <c-t> change the global working directory (exit).
-      + <c-v> change the local working directory for the current window (exit).
-      + <c-x> change the global working directory to CtrlP's current local
-        working directory (exit).
-
-                                                                    *:CtrlPRTS*
-  * Runtime script mode:~
-    - Name: 'rtscript'
-    - Command: ":CtrlPRTS"
-    - Search for files (vimscripts, docs, snippets...) in runtimepath.
-
-                                                                   *:CtrlPUndo*
-  * Undo mode:~
-    - Name: 'undo'
-    - Command: ":CtrlPUndo"
-    - Browse undo history.
-
-                                                                   *:CtrlPLine*
-  * Line mode:~
-    - Name: 'line'
-    - Command: ":CtrlPLine [buffer]"
-    - Search for a line in all listed buffers or in the specified [buffer].
-
-                                                                 *:CtrlPChange*
-                                                              *:CtrlPChangeAll*
-  * Change list mode:~
-    - Name: 'changes'
-    - Commands: ":CtrlPChange [buffer]",
-                ":CtrlPChangeAll".
-    - Search for and jump to a recent change in the current buffer or in all
-      listed buffers.
-
-                                                                  *:CtrlPMixed*
-  * Mixed mode:~
-    - Name: 'mixed'
-    - Command: ":CtrlPMixed"
-    - Search in files, buffers and MRU files at the same time.
-
-                                                            *:CtrlPBookmarkDir*
-                                                         *:CtrlPBookmarkDirAdd*
-  * BookmarkDir mode:~
-    - Name: 'bookmarkdir'
-    - Commands: ":CtrlPBookmarkDir",
-                ":CtrlPBookmarkDirAdd  [directory] [TITLE]".
-                ":CtrlPBookmarkDirAdd! [directory] [TITLE]".
-
-    - Search for a bookmarked directory and change the working directory to it.
-    - Add either the dir [directory], if supplied, or otherwise ask for it,
-      under the title given by either [TITLE], if supplied, or otherwise ask for
-      it, to the CtrlPBookmarkDir list.
-    - Add either the dir [directory], if supplied, or otherwise the current
-      work dir ( [CWD] ) under the title given by either [TITLE], if supplied,
-      or otherwise [CWD] to the CtrlPBookmarkDir list.
-
-    The last command can be used to add all recently used work dirs to the
-    CtrlPBookmarkDir list by an autocommand like
-
-    >
-    augroup CtrlPDirMRU
-      autocmd!
-      autocmd FileType * if &modifiable | execute 'silent CtrlPBookmarkDirAdd! %:p:h' | endif
-    augroup END
-<
-
-    - Mappings:
-      + <cr> change the local working directory for CtrlP, keep it open and
-        switch to find file mode.
-      + <c-x> change the global working directory (exit).
-      + <c-v> change the local working directory for the current window (exit).
-      + <F7>
-        - Wipe bookmark list.
-        - Delete entries marked by <c-z>.
-
-                                                 *ctrlp-autoignore-extension*
-  * Autoignore mode:~
-    - Name: 'autoignore'
-
-    - This extension doesn't add new commands. It adds support for per-project
-      ignore patterns (as per |ctrlp_custom_ignore|) via a `.ctrlpignore` file
-      at the root of the project. It's basically like a `.gitignore` or
-      `.hgignore` for CtrlP.
-
-      Note: auto-ignore won't work when |g:ctrlp_user_command| is used.
-
-      Note: `.ctrlpignore` will be added to the root markers (see
-      |g:ctrlp_root_markers|).
-
-    - Ignore file syntax:
-      Empty lines, and lines starting with `#` (comments) are ignored.
-
-      Other lines are treated like regular expression patterns. See *string-match*
-      for how patterns are used. Anything that matches any of the patterns will be
-      ignored from CtrlP's search results.
-
-      Example:
-
-        \.tmp$
-        ^generated/
-        local\.cfg
-
-      Note: patterns should use forward slashes, even on Windows.
-
-      You can also switch to a glob-like syntax like this:
-
-        syntax:wildignore
-        *.tar.gz
-        *.tmp
-
-      This will temporarily add each pattern to |'wildignore'| for the
-      duration of the file scan, and remove them at the end.
-
-      You can switch back to the default regular-expression-based patterns by
-      writing:
-
-        syntax:regexp
-
-      You can also specify a match on only a given type of item:
-
-        dir:build
-        file:foo\.txt
-
-      This will only ignore directories with "build" in them, and files with
-      "foo.txt" in them. Not files with "build" in them or vice-versa.
-
-      Note: to ignore a root directory "build", and not _any_ directory with
-      "build" in it, you can root the regex: ^build$
-
-    - FAQ:
-      Q: Why can't CtrlP support `.gitignore` or `.hgignore` natively?
-
-      A: Those files look at first like they may contain all the patterns
-      you'd want to exclude from CtrlP already. However, more often than not,
-      there are some differences. Those files list patterns that should not be
-      included in source-control. This includes things you want to ignore, but
-      also things you may not want to: local settings, external packages and
-      dependencies, etc. The author felt the trouble of supporting various
-      syntaxes was too much compared to just copy/pasting a few lines. Feel
-      free to contribute a patch if you disagree :)
-
-      Q: I enabled |ctrlp-autoignore-extension|, or edited `.ctrlpignore`, but
-      none of the new patterns are working. What did I do wrong?
-
-      A: Probably nothing! CtrlP can cache search results for faster response
-      times. You can hit <F5> to force it to refresh. This will use the newer
-      ignore patterns if the `.ctrlpignore` file has changed, too.
-
-
-----------------------------------------
-Buffer Tag mode options:~
-
-                                                   *'g:ctrlp_buftag_ctags_bin'*
-If ctags isn't in your $PATH, or a ctags binary exists in either
-/opt/local/bin or /usr/local/bin, use this to set its location: >
-  let g:ctrlp_buftag_ctags_bin = ''
-<
-
-                                                   *'g:ctrlp_buftag_systemenc'*
-Match this with your OS's encoding (not Vim's). The default value mirrors Vim's
-global |'encoding'| option: >
-  let g:ctrlp_buftag_systemenc = &encoding
-<
-
-                                                       *'g:ctrlp_buftag_types'*
-Use this to set the arguments for ctags, jsctags... for a given filetype: >
-  let g:ctrlp_buftag_types = ''
-<
-Examples: >
-  let g:ctrlp_buftag_types = {
-    \ 'erlang'     : '--language-force=erlang --erlang-types=drmf',
-    \ 'javascript' : {
-      \ 'bin': 'jsctags',
-      \ 'args': '-f -',
-      \ },
-    \ }
-<
-
-===============================================================================
-CUSTOMIZATION                                             *ctrlp-customization*
-
-Highlighting:~
-  * For the CtrlP buffer:
-    CtrlPNoEntries : the message when no match is found (Error)
-    CtrlPMatch     : the matched pattern (Identifier)
-    CtrlPLinePre   : the line prefix '>' in the match window
-    CtrlPPrtBase   : the prompt's base (Comment)
-    CtrlPPrtText   : the prompt's text (|hl-Normal|)
-    CtrlPPrtCursor : the prompt's cursor when moving over the text (Constant)
-
-  * Buffer explorer mode:
-    CtrlPBufferNr     : buffer number
-    CtrlPBufferInd    : '+', '-', '=' and '#' indicators (see |:buffers|)
-    CtrlPBufferHid    : hidden buffer
-    CtrlPBufferHidMod : hidden and modified buffer
-    CtrlPBufferVis    : visible buffer
-    CtrlPBufferVisMod : visible and modified buffer
-    CtrlPBufferCur    : current buffer
-    CtrlPBufferCurMod : current and modified buffer
-    CtrlPBufferPath   : buffer path
-
-  * In extensions:
-    CtrlPTabExtra  : the part of each line that's not matched against (Comment)
-    CtrlPBufName   : the buffer name an entry belongs to (|hl-Directory|)
-    CtrlPTagKind   : the kind of the tag in buffer-tag mode (|hl-Title|)
-    CtrlPqfLineCol : the line and column numbers in quickfix mode (Comment)
-    CtrlPUndoT     : the elapsed time in undo mode (|hl-Directory|)
-    CtrlPUndoBr    : the square brackets [] in undo mode (Comment)
-    CtrlPUndoNr    : the undo number inside [] in undo mode (String)
-    CtrlPUndoSv    : the point where the file was saved (Comment)
-    CtrlPUndoPo    : the current position in the undo tree (|hl-Title|)
-    CtrlPBookmark  : the name of the bookmark (Identifier)
-
-Statuslines:~
-  * Highlight groups:
-    CtrlPMode1 : 'file' or 'path' or 'line', and the current mode (Character)
-    CtrlPMode2 : 'prt' or 'win', 'regex', the working directory (|hl-LineNr|)
-    CtrlPStats : the scanning status (Function)
-
-  For rebuilding the statuslines, see |g:ctrlp_status_func|.
-
-===============================================================================
-MISCELLANEOUS CONFIGS                             *ctrlp-miscellaneous-configs*
-
-* Using |wildignore| for |g:ctrlp_user_command|:
->
-  function! s:wig2cmd()
-    " Change wildignore into space or | separated groups
-    " e.g. .aux .out .toc .jpg .bmp .gif
-    " or   .aux$\|.out$\|.toc$\|.jpg$\|.bmp$\|.gif$
-    let pats = ['[*\/]*\([?_.0-9A-Za-z]\+\)\([*\/]*\)\(\\\@<!,\|$\)','\\\@<!,']
-    let subs = has('win32') || has('win64') ? ['\1\3', ' '] : ['\1\2\3', '\\|']
-    let expr = substitute(&wig, pats[0], subs[0], 'g')
-    let expr = substitute(expr, pats[1], subs[1], 'g')
-    let expr = substitute(expr, '\\,', ',', 'g')
-
-    " Set the user_command option
-    let g:ctrlp_user_command = has('win32') || has('win64')
-      \ ? 'dir %s /-n /b /s /a-d | findstr /V /l "'.expr.'"'
-      \ : 'find %s -type f | grep -v "'.expr .'"'
-  endfunction
-
-  call s:wig2cmd()
-<
-(submitted by Rich Alesi <github.com/ralesi>)
-
-* A standalone function to set the working directory to the project's root, or
-  to the parent directory of the current file if a root can't be found:
->
-  function! s:setcwd()
-    let cph = expand('%:p:h', 1)
-    if cph =~ '^.\+://' | retu | en
-    for mkr in ['.git/', '.hg/', '.svn/', '.bzr/', '_darcs/', '.vimprojects']
-      let wd = call('find'.(mkr =~ '/$' ? 'dir' : 'file'), [mkr, cph.';'])
-      if wd != '' | let &acd = 0 | brea | en
-    endfo
-    exe 'lc!' fnameescape(wd == '' ? cph : substitute(wd, mkr.'$', '.', ''))
-  endfunction
-
-  autocmd BufEnter * call s:setcwd()
-<
-(requires Vim 7.1.299+)
-
-* Using a |count| to invoke different commands using the same mapping:
->
-  let g:ctrlp_cmd = 'exe "CtrlP".get(["", "Buffer", "MRU"], v:count)'
-<
-
-===============================================================================
-CREDITS                                                         *ctrlp-credits*
-
-Originally developed by Kien Nguyen <github.com/kien>.  Now maintained by the
-members of the ctrlpvim Github organisation
-(https://github.com/orgs/ctrlpvim/people).  Distributed under Vim's |license|.
-
-Project's homepage:   http://ctrlpvim.github.com/ctrlp.vim
-Git repository:       https://github.com/ctrlpvim/ctrlp.vim
-
--------------------------------------------------------------------------------
-Thanks to everyone that has submitted ideas, bug reports or helped debugging on
-gibhub, bitbucket, and through email.
-
-Special thanks:~
-
-    * Woojong Koh <github.com/wjkoh>
-    * Simon Ruderich
-    * Yasuhiro Matsumoto <github.com/mattn>
-    * Ken Earley <github.com/kenearley>
-    * Kyo Nagashima <github.com/hail2u>
-    * Zak Johnson <github.com/zakj>
-    * Diego Viola <github.com/diegoviola>
-    * Piet Delport <github.com/pjdelport>
-    * Thibault Duplessis <github.com/ornicar>
-    * Kent Sibilev <github.com/datanoise>
-    * Tacahiroy <github.com/tacahiroy>
-    * Luca Pette <github.com/lucapette>
-    * Seth Fowler <github.com/sfowler>
-    * Lowe Thiderman <github.com/thiderman>
-    * Christopher Fredn <github.com/icetan>
-    * Zahary Karadjov <github.com/zah>
-    * Jo De Boeck <github.com/grimpy>
-    * Rudi Grinberg <github.com/rgrinberg>
-    * Timothy Mellor <github.com/mellort>
-    * Sergey Vlasov <github.com/noscript>
-
-===============================================================================
-CHANGELOG                                                     *ctrlp-changelog*
-
-    * New option |g:ctrlp_custom_tag_files| to specify custom tag files.
-    * Accept 0 for g:ctrlp_match_window no-limited window size.
-
-Before 2016/11/28~
-
-    + New command: |YankLine()| to yank current line.
-    + New option: |g:ctrlp_types| to select builtin modes.
-    + New feature: asynchronized spawn of |g:ctrlp_user_command|. This enable
-                  with set |g:ctrlp_user_command_async| to 1.
-    + Support buffertag for delphi, rust and golang.
-    + New option: |g:ctrlp_brief_prompt|,
-                  |g:match_current_file|,
-                  |g:ctrlp_compare_lim|.
-    + New feature: Auto-ignore extension.
-    + Support buffertag for ant, tex, dosbatch, matlab and vhdl.
-    + New option |g:ctrlp_line_prefix| for integrating third party plugins.
-    + New option |g:open_single_match| to open single file in matches.
-    + Add <plug>(ctrlp) for launch CtrlP.
-    + Accept bang for CtrlPBookmarkDirAdd to avoid confirm.
-    + Handle variable like "g:ctrlp_TYPE_MODE".
-                   ex: let g:ctrlp_path_sort
-    + New option: |g:ctrlp_custom_ancestors|
-
-Before 2014/08/08~
-
-    + New buffer explorer mode with highlighting (|+conceal| recommended)
-    + New options: |g:ctrlp_bufname_mod|,
-                   |g:ctrlp_bufpath_mod|
-    + Combine *g:ctrlp_match_window_bottom* *g:ctrlp_match_window_reversed* and
-      *g:ctrlp_max_height* into |g:ctrlp_match_window|.
-    + New option: |g:ctrlp_match_window|.
-
-Before 2012/11/30~
-
-    + New options: |g:ctrlp_abbrev|,
-                   |g:ctrlp_key_loop|,
-                   |g:ctrlp_open_func|,
-                   |g:ctrlp_tabpage_position|,
-                   |g:ctrlp_mruf_save_on_update|
-    + Rename:
-        *g:ctrlp_dotfiles* -> |g:ctrlp_show_hidden|.
-    + Change |g:ctrlp_switch_buffer|'s and |g:ctrlp_working_path_mode|'s type
-      (old values still work).
-    + New key for |g:ctrlp_user_command| when it's a Dictionary: 'ignore'.
-
-Before 2012/06/15~
-
-    + New value for |g:ctrlp_follow_symlinks|: 2.
-    + New value for |g:ctrlp_open_multiple_files|: 'j'.
-    + Allow using <c-t>, <c-x>, <c-v> to open files marked by <c-z>.
-    + Extend '..' (|ctrlp-input-formats| (d))
-    + New input format: '@cd' (|ctrlp-input-formats| (d))
-
-Before 2012/04/30~
-
-    + New option: |g:ctrlp_mruf_default_order|
-    + New feature: Bookmarked directories extension.
-    + New commands: |:CtrlPBookmarkDir|
-                    |:CtrlPBookmarkDirAdd|
-
-Before 2012/04/15~
-
-    + New option: |g:ctrlp_buffer_func|, callback functions for CtrlP buffer.
-    + Remove: g:ctrlp_mruf_last_entered, make it a default for MRU mode.
-    + New commands: |:CtrlPLastMode|, open CtrlP in the last mode used.
-                    |:CtrlPMixed|, search in files, buffers and MRU files.
-
-Before 2012/03/31~
-
-    + New options: |g:ctrlp_default_input|, default input when entering CtrlP.
-                   |g:ctrlp_match_func|, allow using a custom fuzzy matcher.
-    + Rename:
-        *ClearCtrlPCache* -> |CtrlPClearCache|
-        *ClearAllCtrlPCaches* -> |CtrlPClearAllCaches|
-        *ResetCtrlP* -> |CtrlPReload|
-
-Before 2012/03/02~
-
-    + Rename:
-        *g:ctrlp_regexp_search* -> |g:ctrlp_regexp|,
-        *g:ctrlp_dont_split* -> |g:ctrlp_reuse_window|,
-        *g:ctrlp_jump_to_buffer* -> |g:ctrlp_switch_buffer|.
-    + Rename and tweak:
-        *g:ctrlp_open_multi* -> |g:ctrlp_open_multiple_files|.
-    + Deprecate *g:ctrlp_highlight_match*
-    + Extend |g:ctrlp_user_command| to support multiple commands.
-    + New option: |g:ctrlp_mruf_last_entered| change MRU to Recently-Entered.
-
-Before 2012/01/15~
-
-    + New mapping: Switch <tab> and <s-tab>. <tab> is now used for completion
-                   of directory names under the current working directory.
-    + New options: |g:ctrlp_arg_map| for <c-y>, <c-o> to accept an argument.
-                   |g:ctrlp_status_func| custom statusline.
-                   |g:ctrlp_mruf_relative| show only MRU files inside cwd.
-    + Extend g:ctrlp_open_multi with new optional values: tr, hr, vr.
-    + Extend |g:ctrlp_custom_ignore| to specifically filter dir, file and link.
-
-Before 2012/01/05~
-
-    + New feature: Buffer Tag extension.
-    + New commands: |:CtrlPBufTag|, |:CtrlPBufTagAll|.
-    + New options: |g:ctrlp_cmd|,
-                   |g:ctrlp_custom_ignore|
-
-Before 2011/11/30~
-
-    + New features: Tag, Quickfix and Directory extensions.
-    + New commands: |:CtrlPTag|, |:CtrlPQuickfix|, |:CtrlPDir|.
-    + New options: |g:ctrlp_use_migemo|,
-                   |g:ctrlp_lazy_update|,
-                   |g:ctrlp_follow_symlinks|
-
-Before 2011/11/13~
-
-    + New special input: '/' and '\' find root (|ctrlp-input-formats| (e))
-    + Remove ctrlp#SetWorkingPath().
-    + Remove *g:ctrlp_mru_files* and make MRU mode permanent.
-    + Extend g:ctrlp_open_multi, add new ways to open files.
-    + New option: g:ctrlp_dont_split,
-                  |g:ctrlp_mruf_case_sensitive|
-
-Before 2011/10/30~
-
-    + New feature: Support for custom extensions.
-                   <F5> also removes non-existent files from MRU list.
-    + New option: g:ctrlp_jump_to_buffer
-
-Before 2011/10/12~
-
-    + New features: Open multiple files.
-                    Pass Vim's |++opt| and |+cmd| to the opening file
-                    (|ctrlp-input-formats| (c))
-                    Auto-complete each dir for |:CtrlP| [starting-directory]
-    + New mappings: <c-z> mark/unmark a file to be opened with <c-o>.
-                    <c-o> open all marked files.
-    + New option: g:ctrlp_open_multi
-    + Remove *g:ctrlp_persistent_input* *g:ctrlp_live_update* and <c-^>.
-
-Before 2011/09/29~
-
-    + New mappings: <c-n>, <c-p> next/prev string in the input history.
-                    <c-y> create a new file and its parent dirs.
-    + New options: |g:ctrlp_open_new_file|,
-                   |g:ctrlp_max_history|
-    + Added a new open-in-horizontal-split mapping: <c-x>
-
-Before 2011/09/19~
-
-    + New command: ResetCtrlP
-    + New options: |g:ctrlp_max_files|,
-                   |g:ctrlp_max_depth|,
-                   g:ctrlp_live_update
-    + New mapping: <c-^>
-
-Before 2011/09/12~
-
-    + Ability to cycle through matched lines in the match window.
-    + Extend the behavior of g:ctrlp_persistent_input
-    + Extend the behavior of |:CtrlP|
-    + New options: |g:ctrlp_dotfiles|,
-                   |g:ctrlp_clear_cache_on_exit|,
-                   g:ctrlp_highlight_match,
-                   |g:ctrlp_user_command|
-    + New special input: '..' (|ctrlp-input-formats| (d))
-    + New mapping: <F5>.
-    + New commands: |:CtrlPCurWD|,
-                    |:CtrlPCurFile|,
-                    |:CtrlPRoot|
-
-    + New feature: Search in most recently used (MRU) files
-    + New mapping: <c-b>.
-    + Extended the behavior of <c-f>.
-    + New options: g:ctrlp_mru_files,
-                   |g:ctrlp_mruf_max|,
-                   |g:ctrlp_mruf_exclude|,
-                   |g:ctrlp_mruf_include|
-    + New command: |:CtrlPMRU|
-
-First public release: 2011/09/06~
-
-===============================================================================
-vim:ft=help:et:ts=2:sw=2:sts=2:norl
diff --git a/sources_non_forked/ctrlp.vim/plugin/ctrlp.vim b/sources_non_forked/ctrlp.vim/plugin/ctrlp.vim
deleted file mode 100644
index 1e56eca..0000000
--- a/sources_non_forked/ctrlp.vim/plugin/ctrlp.vim
+++ /dev/null
@@ -1,72 +0,0 @@
-" =============================================================================
-" File:          plugin/ctrlp.vim
-" Description:   Fuzzy file, buffer, mru, tag, etc finder.
-" Author:        Kien Nguyen <github.com/kien>
-" =============================================================================
-" GetLatestVimScripts: 3736 1 :AutoInstall: ctrlp.zip
-
-if ( exists('g:loaded_ctrlp') && g:loaded_ctrlp ) || v:version < 700 || &cp
-	fini
-en
-let g:loaded_ctrlp = 1
-
-let [g:ctrlp_lines, g:ctrlp_allfiles, g:ctrlp_alltags, g:ctrlp_alldirs,
-	\ g:ctrlp_allmixes, g:ctrlp_buftags, g:ctrlp_ext_vars, g:ctrlp_builtins]
-	\ = [[], [], [], [], {}, {}, [], 2]
-
-if !exists('g:ctrlp_map') | let g:ctrlp_map = '<c-p>' | en
-if !exists('g:ctrlp_cmd') | let g:ctrlp_cmd = 'CtrlP' | en
-
-com! -n=? -com=dir CtrlP         cal ctrlp#init(0, { 'dir': <q-args> })
-com! -n=? -com=dir CtrlPMRUFiles cal ctrlp#init('mru', { 'dir': <q-args> })
-
-com! -bar CtrlPBuffer   cal ctrlp#init('buf')
-com! -n=? CtrlPLastMode cal ctrlp#init(-1, { 'args': <q-args> })
-
-com! -bar CtrlPClearCache     cal ctrlp#clr()
-com! -bar CtrlPClearAllCaches cal ctrlp#clra()
-
-com! -bar ClearCtrlPCache     cal ctrlp#clr()
-com! -bar ClearAllCtrlPCaches cal ctrlp#clra()
-
-com! -bar CtrlPCurWD   cal ctrlp#init('fil', { 'mode': '' })
-com! -bar CtrlPCurFile cal ctrlp#init('fil', { 'mode': 'c' })
-com! -bar CtrlPRoot    cal ctrlp#init('fil', { 'mode': 'r' })
-
-exe 'nn <silent> <plug>(ctrlp) :<c-u>'.g:ctrlp_cmd.'<cr>'
-
-if g:ctrlp_map != '' && !hasmapto('<plug>(ctrlp)')
-	exe 'map' g:ctrlp_map '<plug>(ctrlp)'
-en
-
-if !exists('g:ctrlp_types') || index(g:ctrlp_types, 'mru') >= 0
-	cal ctrlp#mrufiles#init()
-en
-
-com! -bar CtrlPTag      cal ctrlp#init(ctrlp#tag#id())
-com! -bar CtrlPQuickfix cal ctrlp#init(ctrlp#quickfix#id())
-
-com! -n=? -com=dir CtrlPDir
-	\ cal ctrlp#init(ctrlp#dir#id(), { 'dir': <q-args> })
-
-com! -n=? -com=buffer CtrlPBufTag
-	\ cal ctrlp#init(ctrlp#buffertag#cmd(0, <q-args>))
-
-com! -bar CtrlPBufTagAll cal ctrlp#init(ctrlp#buffertag#cmd(1))
-com! -bar CtrlPRTS       cal ctrlp#init(ctrlp#rtscript#id())
-com! -bar CtrlPUndo      cal ctrlp#init(ctrlp#undo#id())
-
-com! -n=? -com=buffer CtrlPLine
-	\ cal ctrlp#init(ctrlp#line#cmd('buf', <q-args>))
-
-com! -n=? -com=buffer CtrlPChange
-	\ cal ctrlp#init(ctrlp#changes#cmd('fil', <q-args>))
-
-com! -bar CtrlPChangeAll   cal ctrlp#init(ctrlp#changes#cmd(1))
-com! -bar CtrlPMixed       cal ctrlp#init(ctrlp#mixed#id())
-com! -bar CtrlPBookmarkDir cal ctrlp#init(ctrlp#bookmarkdir#id())
-
-com! -n=? -com=dir -bang CtrlPBookmarkDirAdd
-	\ cal ctrlp#call('ctrlp#bookmarkdir#add', '<bang>', <q-args>)
-
-" vim:ts=2:sw=2:sts=2
diff --git a/sources_non_forked/ctrlp.vim/readme.md b/sources_non_forked/ctrlp.vim/readme.md
deleted file mode 100644
index 2f4c6ae..0000000
--- a/sources_non_forked/ctrlp.vim/readme.md
+++ /dev/null
@@ -1,109 +0,0 @@
-# ctrlp.vim
-Full path fuzzy __file__, __buffer__, __mru__, __tag__, __...__ finder for Vim.
-
-* Written in pure Vimscript for MacVim, gVim and Vim 7.0+.
-* Full support for Vim's regexp as search patterns.
-* Built-in Most Recently Used (MRU) files monitoring.
-* Built-in project's root finder.
-* Open multiple files at once.
-* Create new files and directories.
-* [Extensible][2].
-
-![ctrlp][1]
-
-## Basic Usage
-* Run `:CtrlP` or `:CtrlP [starting-directory]` to invoke CtrlP in find file mode.
-* Run `:CtrlPBuffer` or `:CtrlPMRU` to invoke CtrlP in find buffer or find MRU file mode.
-* Run `:CtrlPMixed` to search in Files, Buffers and MRU files at the same time.
-
-Check `:help ctrlp-commands` and `:help ctrlp-extensions` for other commands.
-
-##### Once CtrlP is open:
-* Press `<F5>` to purge the cache for the current directory to get new files, remove deleted files and apply new ignore options.
-* Press `<c-f>` and `<c-b>` to cycle between modes.
-* Press `<c-d>` to switch to filename only search instead of full path.
-* Press `<c-r>` to switch to regexp mode.
-* Use `<c-j>`, `<c-k>` or the arrow keys to navigate the result list.
-* Use `<c-t>` or `<c-v>`, `<c-x>` to open the selected entry in a new tab or in a new split.
-* Use `<c-n>`, `<c-p>` to select the next/previous string in the prompt's history.
-* Use `<c-y>` to create a new file and its parent directories.
-* Use `<c-z>` to mark/unmark multiple files and `<c-o>` to open them.
-
-Run `:help ctrlp-mappings` or submit `?` in CtrlP for more mapping help.
-
-* Submit two or more dots `..` to go up the directory tree by one or multiple levels.
-* End the input string with a colon `:` followed by a command to execute it on the opening file(s):
-Use `:25` to jump to line 25.
-Use `:diffthis` when opening multiple files to run `:diffthis` on the first 4 files.
-
-## Basic Options
-* Change the default mapping and the default command to invoke CtrlP:
-
-    ```vim
-    let g:ctrlp_map = '<c-p>'
-    let g:ctrlp_cmd = 'CtrlP'
-    ```
-
-* When invoked without an explicit starting directory, CtrlP will set its local working directory according to this variable:
-
-    ```vim
-    let g:ctrlp_working_path_mode = 'ra'
-    ```
-
-    `'c'` - the directory of the current file.  
-    `'a'` - the directory of the current file, unless it is a subdirectory of the cwd  
-    `'r'` - the nearest ancestor of the current file that contains one of these directories or files: `.git` `.hg` `.svn` `.bzr` `_darcs`  
-    `'w'` - modifier to "r": start search from the cwd instead of the current file's directory  
-    `0` or `''` (empty string) - disable this feature.
-
-    If none of the default markers (`.git` `.hg` `.svn` `.bzr` `_darcs`) are present in a project, you can define additional ones with `g:ctrlp_root_markers`:
-
-    ```vim
-    let g:ctrlp_root_markers = ['pom.xml', '.p4ignore']
-    ```
-
-    If more than one mode is specified, they will be tried in order until a directory is located.
-
-* If a file is already open, open it again in a new pane instead of switching to the existing pane
-
-    `let g:ctrlp_switch_buffer = 'et'`
-
-* Exclude files and directories using Vim's `wildignore` and CtrlP's own `g:ctrlp_custom_ignore`. If a custom listing command is being used, exclusions are ignored:
-
-    ```vim
-    set wildignore+=*/tmp/*,*.so,*.swp,*.zip     " MacOSX/Linux
-    set wildignore+=*\\tmp\\*,*.swp,*.zip,*.exe  " Windows
-
-    let g:ctrlp_custom_ignore = '\v[\/]\.(git|hg|svn)$'
-    let g:ctrlp_custom_ignore = {
-      \ 'dir':  '\v[\/]\.(git|hg|svn)$',
-      \ 'file': '\v\.(exe|so|dll)$',
-      \ 'link': 'some_bad_symbolic_links',
-      \ }
-    ```
-
-* Use a custom file listing command:
-
-    ```vim
-    let g:ctrlp_user_command = 'find %s -type f'        " MacOSX/Linux
-    let g:ctrlp_user_command = 'dir %s /-n /b /s /a-d'  " Windows
-    ```
-
-* Ignore files in `.gitignore`
-    
-    ```vim
-      let g:ctrlp_user_command = ['.git', 'cd %s && git ls-files -co --exclude-standard']
-    ```
-
-Check `:help ctrlp-options` for other options.
-
-## Installation
-Use your favorite method or check the homepage for a [quick installation guide][3].
-
-## License
-CtrlP is distributed under Vim's [license][4].
-
-[1]: http://i.imgur.com/aOcwHwt.png
-[2]: https://github.com/ctrlpvim/ctrlp.vim/tree/extensions
-[3]: http://ctrlpvim.github.com/ctrlp.vim#installation
-[4]: http://vimdoc.sourceforge.net/htmldoc/uganda.html
diff --git a/sources_non_forked/gist-vim/.github/FUNDING.yml b/sources_non_forked/gist-vim/.github/FUNDING.yml
deleted file mode 100644
index 351ae11..0000000
--- a/sources_non_forked/gist-vim/.github/FUNDING.yml
+++ /dev/null
@@ -1,12 +0,0 @@
-# These are supported funding model platforms
-
-github: # Replace with up to 4 GitHub Sponsors-enabled usernames e.g., [user1, user2]
-patreon: mattn # Replace with a single Patreon username
-open_collective: # Replace with a single Open Collective username
-ko_fi: # Replace with a single Ko-fi username
-tidelift: # Replace with a single Tidelift platform-name/package-name e.g., npm/babel
-community_bridge: # Replace with a single Community Bridge project-name e.g., cloud-foundry
-liberapay: # Replace with a single Liberapay username
-issuehunt: # Replace with a single IssueHunt username
-otechie: # Replace with a single Otechie username
-custom: # Replace with up to 4 custom sponsorship URLs e.g., ['link1', 'link2']
diff --git a/sources_non_forked/gist-vim/Makefile b/sources_non_forked/gist-vim/Makefile
deleted file mode 100644
index 81370a8..0000000
--- a/sources_non_forked/gist-vim/Makefile
+++ /dev/null
@@ -1,11 +0,0 @@
-all : gist-vim.zip
-
-remove-zip:
-	-rm -f doc/tags
-	-rm -f gist-vim.zip
-
-gist-vim.zip: remove-zip
-	zip -r gist-vim.zip autoload plugin doc README.mkd
-
-release: gist-vim.zip
-	vimup update-script gist.vim
diff --git a/sources_non_forked/gist-vim/README.md b/sources_non_forked/gist-vim/README.md
deleted file mode 100644
index e91463f..0000000
--- a/sources_non_forked/gist-vim/README.md
+++ /dev/null
@@ -1,281 +0,0 @@
-# Gist.vim
-
-This is a vimscript for creating gists (http://gist.github.com).
-
-For the latest version please see https://github.com/mattn/gist-vim.
-
-## Usage:
-
-- Post current buffer to gist, using default privacy option.
-
-        :Gist
-
-- Post selected text to gist, using default privacy option.
-  This applies to all permutations listed below (except multi).
-
-        :'<,'>Gist
-
-- Create a private gist.
-
-        :Gist -p
-
-- Create a public gist.
-  (Only relevant if you've set gists to be private by default.)
-
-        :Gist -P
-
->  This is only relevant if you've set gists to be private by default;
-> if you get an empty gist list, try ":Gist --abandon".
-
-- Create a gist anonymously.
-
-        :Gist -a
-
-- Create a gist with all open buffers.
-
-        :Gist -m
-
-- Edit the gist (you need to have opened the gist buffer first).
-  You can update the gist with the ":w" command within the gist buffer.
-
-        :Gist -e
-
-- Edit the gist with name 'foo.js' (you need to have opened the gist buffer
-  first).
-
-        :Gist -e foo.js
-
-- Post/Edit with the description " (you need to have opened the gist buffer
-  first). >
-
-        :Gist -s something
-        :Gist -e -s something
-
-- Delete the gist (you need to have opened the gist buffer first).
-  Password authentication is needed.
-
-        :Gist -d
-
-- Fork the gist (you need to have opened the gist buffer first).
-  Password authentication is needed.
-
-        :Gist -f
-
-- Star the gist (you need to have opened the gist buffer first).
-  Password authentication is needed.
-
-        :Gist +1
-
-- Unstar the gist (you need to have opened the gist buffer first).
-  Password authentication is needed.
-
-        :Gist -1
-
-- Get gist XXXXX.
-
-        :Gist XXXXX
-
-- Get gist XXXXX and add to clipboard.
-
-        :Gist -c XXXXX
-
-- List your public gists.
-
-        :Gist -l
-
-- List gists from user "mattn".
-
-        :Gist -l mattn
-
-- List everyone's gists.
-
-        :Gist -la
-
-- List gists from your starred gists.
-
-        :Gist -ls
-
-- Open the gist on browser after you post or update it.
-
-        :Gist -b
-
-## List Feature
-
-- Useful mappings on the gist-listing buffer:
-    - Both `o` or `Enter` open the gist file in a new buffer, and close the
-      gist-vim listing one.
-    - `b` opens the gist file in a browser; this is necessary because
-      `Shift-Enter` (as was originally) only works for GUI vim.
-    - `y` copies the contents of the selected gist to the clipboard, and
-      closes the gist-vim buffer.
-    - `p` pastes the contents of the selected gist to the buffer from where
-      gist-vim was called, and closes the gist-vim buffer.
-    - Hitting `Escape` or `Tab` at the gist-vim buffer closes it.
-
-- Gist listing has fixed-length columns now, more amenable to eye inspection.
-  Every line on the gist-listing buffer contains the gist id, name and
-  description, in that order. Columns are now padded and truncated to offer a
-  faster browsing, in the following way:
-  - The gist id string is fixed at 32 characters.
-  - The length (in characters) of the name of the gist is fixed and
-    can be set by the user using, for example:
-
-    `let g:gistvim_namelength = 20`
-
-    The default value for `gistvim_namelength` is 30. If the gist (file)name
-    exceeds that length, it is truncated to the specified length.
-  - Finally, the gist description is truncated in length to fit the remaining
-    of the line, avoiding wrapped lines that mess up the table layout.
-  - Note that the gist listing buffer now does not show the field 'code'
-    (not sure what that did in the first place).
-
-## Tips:
-
-If you set g:gist_clip_command, gist.vim will copy the gist code with option
-'-c'.
-
-- Mac:
-
-        let g:gist_clip_command = 'pbcopy'
-
-- Linux:
-
-        let g:gist_clip_command = 'xclip -selection clipboard'
-
-- Others (cygwin?):
-
-        let g:gist_clip_command = 'putclip'
-
-If you want to detect filetype from the filename:
-
-    let g:gist_detect_filetype = 1
-
-If you want to open browser after the post:
-
-    let g:gist_open_browser_after_post = 1
-
-If you want to change the browser:
-
-    let g:gist_browser_command = 'w3m %URL%'
-
-or:
-
-    let g:gist_browser_command = 'opera %URL% &'
-
-On windows, this should work with your user settings.
-
-If you want to show your private gists with ":Gist -l":
-
-    let g:gist_show_privates = 1
-
-If you want your gist to be private by default:
-
-    let g:gist_post_private = 1
-
-If you want your gist to be anonymous by default:
-
-    let g:gist_post_anonymous = 1
-
-If you want to manipulate multiple files in a gist:
-
-    let g:gist_get_multiplefile = 1
-
-If you want to use on GitHub Enterprise:
-
-    let g:gist_api_url = 'http://your-github-enterprise-domain/api/v3'
-
-You need to either set global git config:
-
-	$ git config --global github.user Username
-
-## License:
-
-    Copyright 2010 by Yasuhiro Matsumoto
-    modification, are permitted provided that the following conditions are met:
-
-    1. Redistributions of source code must retain the above copyright notice,
-       this list of conditions and the following disclaimer.
-    2. Redistributions in binary form must reproduce the above copyright notice,
-       this list of conditions and the following disclaimer in the documentation
-       and/or other materials provided with the distribution.
-
-    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-    ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-    FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
-    REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
-    INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
-    HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
-    STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
-    OF THE POSSIBILITY OF SUCH DAMAGE.
-
-
-## Install:
-
-Copy it to your plugin directory.
-gist.vim will create a curl cookie-jar file in your runtimepath.
-
-- rtp:
-  - autoload/gist.vim
-  - plugin/gist.vim
-
-If you want to uninstall gist.vim, remember to also remove `~/.gist-vim`.
-
-You need to install webapi-vim also:
-
-  http://www.vim.org/scripts/script.php?script_id=4019
-
-If you want to use latest one:
-
-  https://github.com/mattn/webapi-vim
-
-### Install with [Vundle](https://github.com/gmarik/vundle)
-
-Add the following lines to your `.vimrc`.
-
-    Bundle 'mattn/webapi-vim'
-    Bundle 'mattn/gist-vim'
-
-Now restart Vim and run `:BundleInstall`.
-
-### Install with [NeoBundle](https://github.com/Shougo/neobundle.vim)
-
-Add the following line to your `.vimrc`.
-
-    NeoBundle 'mattn/gist-vim', {'depends': 'mattn/webapi-vim'}
-
-## Requirements:
-
-- curl command (http://curl.haxx.se/)
-- webapi-vim (https://github.com/mattn/webapi-vim)
-- and if you want to use your git profile, the git command-line client.
-
-## Setup:
-
-This plugin supports both basic and two-factor authentication using GitHub
-API v3. The plugin stores its credentials in `~/.gist-vim`.
-
-First, you need to set your GitHub username in git's global configuration:
-
-    $ git config --global github.user <username>
-
-Then gist-vim will ask for your password in order to create an access
-token. If you have two-factor authentication enabled, gist-vim will also
-prompt you to enter the two-factor key you receive.
-
-NOTE:
-If you want you can set it directly to `g:github_user` and `g:gist_token`.
-
-Whichever type of authentication you use, your GitHub password will not be
-stored, only a OAuth access token produced specifically for gist-vim. The
-token is stored in `~/.gist-vim`. If you stop using the plugin, you can
-easily remove this file. To revoke the associated  GitHub token, go to the
-list of ["Authorized applications" on GitHub's "Account Settings"
-page][uas].
-
-[uas]: https://github.com/settings/applications
-
-**Note:** the username is optional if you only send anonymous gists.
diff --git a/sources_non_forked/gist-vim/autoload/gist.vim b/sources_non_forked/gist-vim/autoload/gist.vim
deleted file mode 100644
index afe797e..0000000
--- a/sources_non_forked/gist-vim/autoload/gist.vim
+++ /dev/null
@@ -1,1165 +0,0 @@
-"=============================================================================
-" File: gist.vim
-" Author: Yasuhiro Matsumoto <mattn.jp@gmail.com>
-" Last Change: 10-Oct-2016.
-" Version: 7.3
-" WebPage: http://github.com/mattn/gist-vim
-" License: BSD
-
-let s:save_cpo = &cpoptions
-set cpoptions&vim
-
-if exists('g:gist_disabled') && g:gist_disabled == 1
-  function! gist#Gist(...) abort
-  endfunction
-  finish
-endif
-
-if !exists('g:github_user') && !executable('git')
-  echohl ErrorMsg | echomsg 'Gist: require ''git'' command' | echohl None
-  finish
-endif
-
-if !executable('curl')
-  echohl ErrorMsg | echomsg 'Gist: require ''curl'' command' | echohl None
-  finish
-endif
-
-if globpath(&rtp, 'autoload/webapi/http.vim') ==# ''
-  echohl ErrorMsg | echomsg 'Gist: require ''webapi'', install https://github.com/mattn/webapi-vim' | echohl None
-  finish
-else
-  call webapi#json#true()
-endif
-
-let s:gist_token_file = expand(get(g:, 'gist_token_file', '~/.gist-vim'))
-let s:system = function(get(g:, 'webapi#system_function', 'system'))
-
-if !exists('g:github_user')
-  let g:github_user = substitute(s:system('git config --get github.user'), "\n", '', '')
-  if strlen(g:github_user) == 0
-    let g:github_user = $GITHUB_USER
-  end
-endif
-
-if !exists('g:gist_api_url')
-  let g:gist_api_url = substitute(s:system('git config --get github.apiurl'), "\n", '', '')
-  if strlen(g:gist_api_url) == 0
-    let g:gist_api_url = 'https://api.github.com/'
-  end
-  if exists('g:github_api_url') && !exists('g:gist_shutup_issue154')
-    if matchstr(g:gist_api_url, 'https\?://\zs[^/]\+\ze') != matchstr(g:github_api_url, 'https\?://\zs[^/]\+\ze')
-      echohl WarningMsg
-      echo '--- Warning ---'
-      echo 'It seems that you set different URIs for github_api_url/gist_api_url.'
-      echo 'If you want to remove this message: let g:gist_shutup_issue154 = 1'
-      echohl None
-      if confirm('Continue?', '&Yes\n&No') != 1
-        let g:gist_disabled = 1
-        finish
-      endif
-      redraw!
-    endif
-  endif
-endif
-if g:gist_api_url !~# '/$'
-  let g:gist_api_url .= '/'
-endif
-
-if !exists('g:gist_update_on_write')
-  let g:gist_update_on_write = 1
-endif
-
-function! s:get_browser_command() abort
-  let gist_browser_command = get(g:, 'gist_browser_command', '')
-  if gist_browser_command ==# ''
-    if has('win32') || has('win64')
-      let gist_browser_command = '!start rundll32 url.dll,FileProtocolHandler %URL%'
-    elseif has('mac') || has('macunix') || has('gui_macvim') || system('uname') =~? '^darwin'
-      let gist_browser_command = 'open %URL%'
-    elseif executable('xdg-open')
-      let gist_browser_command = 'xdg-open %URL%'
-    elseif executable('firefox')
-      let gist_browser_command = 'firefox %URL% &'
-    else
-      let gist_browser_command = ''
-    endif
-  endif
-  return gist_browser_command
-endfunction
-
-function! s:open_browser(url) abort
-  let cmd = s:get_browser_command()
-  if len(cmd) == 0
-    redraw
-    echohl WarningMsg
-    echo 'It seems that you don''t have general web browser. Open URL below.'
-    echohl None
-    echo a:url
-    return
-  endif
-  let quote = &shellxquote == '"' ?  "'" : '"'
-  if cmd =~# '^!'
-    let cmd = substitute(cmd, '%URL%', '\=quote.a:url.quote', 'g')
-    silent! exec cmd
-  elseif cmd =~# '^:[A-Z]'
-    let cmd = substitute(cmd, '%URL%', '\=a:url', 'g')
-    exec cmd
-  else
-    let cmd = substitute(cmd, '%URL%', '\=quote.a:url.quote', 'g')
-    call system(cmd)
-  endif
-endfunction
-
-function! s:shellwords(str) abort
-  let words = split(a:str, '\%(\([^ \t\''"]\+\)\|''\([^\'']*\)''\|"\(\%([^\"\\]\|\\.\)*\)"\)\zs\s*\ze')
-  let words = map(words, 'substitute(v:val, ''\\\([\\ ]\)'', ''\1'', "g")')
-  let words = map(words, 'matchstr(v:val, ''^\%\("\zs\(.*\)\ze"\|''''\zs\(.*\)\ze''''\|.*\)$'')')
-  return words
-endfunction
-
-function! s:truncate(str, num)
-  let mx_first = '^\(.\)\(.*\)$'
-  let str = a:str
-  let ret = ''
-  let width = 0
-  while 1
-    let char = substitute(str, mx_first, '\1', '')
-    let cells = strdisplaywidth(char)
-    if cells == 0 || width + cells > a:num
-      break
-    endif
-    let width = width + cells
-    let ret .= char
-    let str = substitute(str, mx_first, '\2', '')
-  endwhile
-  while width + 1 <= a:num
-    let ret .= " "
-    let width = width + 1
-  endwhile
-  return ret
-endfunction
-
-function! s:format_gist(gist) abort
-  let files = sort(keys(a:gist.files))
-  if empty(files)
-    return ''
-  endif
-  let file = a:gist.files[files[0]]
-  let name = file.filename
-  if has_key(file, 'content')
-    let code = file.content
-    let code = "\n".join(map(split(code, "\n"), '"  ".v:val'), "\n")
-  else
-    let code = ''
-  endif
-  let desc = type(a:gist.description)==0 || a:gist.description ==# '' ? '' : a:gist.description
-  let name = substitute(name, '[\r\n\t]', ' ', 'g')
-  let name = substitute(name, '  ', ' ', 'g')
-  let desc = substitute(desc, '[\r\n\t]', ' ', 'g')
-  let desc = substitute(desc, '  ', ' ', 'g')
-  " Display a nice formatted (and truncated if needed) table of gists on screen
-  " Calculate field lengths for gist-listing formatting on screen
-  redir =>a |exe "sil sign place buffer=".bufnr('')|redir end
-  let signlist = split(a, '\n')
-  let width = winwidth(0) - ((&number||&relativenumber) ? &numberwidth : 0) - &foldcolumn - (len(signlist) > 2 ? 2 : 0)
-  let idlen = 33
-  let namelen = get(g:, 'gist_namelength', 30)
-  let desclen = width - (idlen + namelen + 10)
-  return printf('gist: %s %s %s', s:truncate(a:gist.id, idlen), s:truncate(name, namelen), s:truncate(desc, desclen))
-endfunction
-
-" Note: A colon in the file name has side effects on Windows due to NTFS Alternate Data Streams; avoid it.
-let s:bufprefix = 'gist' . (has('unix') ? ':' : '_')
-function! s:GistList(gistls, page) abort
-  if a:gistls ==# '-all'
-    let url = g:gist_api_url.'gists/public'
-  elseif get(g:, 'gist_show_privates', 0) && a:gistls ==# 'starred'
-    let url = g:gist_api_url.'gists/starred'
-  elseif get(g:, 'gist_show_privates') && a:gistls ==# 'mine'
-    let url = g:gist_api_url.'gists'
-  else
-    let url = g:gist_api_url.'users/'.a:gistls.'/gists'
-  endif
-  let winnum = bufwinnr(bufnr(s:bufprefix.a:gistls))
-  if winnum != -1
-    if winnum != bufwinnr('%')
-      exe winnum 'wincmd w'
-    endif
-    setlocal modifiable
-  else
-    if get(g:, 'gist_list_vsplit', 0)
-      exec 'silent noautocmd vsplit +set\ winfixwidth ' s:bufprefix.a:gistls
-    elseif get(g:, 'gist_list_rightbelow', 0)
-      exec 'silent noautocmd rightbelow 5 split +set\ winfixheight ' s:bufprefix.a:gistls
-    else
-      exec 'silent noautocmd split' s:bufprefix.a:gistls
-    endif
-  endif
-  if a:page > 1
-    let oldlines = getline(0, line('$'))
-    let url = url . '?page=' . a:page
-  endif
-
-  setlocal modifiable
-  let old_undolevels = &undolevels
-  let oldlines = []
-  silent %d _
-
-  redraw | echon 'Listing gists... '
-  let auth = s:GistGetAuthHeader()
-  if len(auth) == 0
-    bw!
-    redraw
-    echohl ErrorMsg | echomsg v:errmsg | echohl None
-    return
-  endif
-  let res = webapi#http#get(url, '', { "Authorization": auth })
-  if v:shell_error != 0
-    bw!
-    redraw
-    echohl ErrorMsg | echomsg 'Gists not found' | echohl None
-    return
-  endif
-  let content = webapi#json#decode(res.content)
-  if type(content) == 4 && has_key(content, 'message') && len(content.message)
-    bw!
-    redraw
-    echohl ErrorMsg | echomsg content.message | echohl None
-    if content.message ==# 'Bad credentials'
-      call delete(s:gist_token_file)
-    endif
-    return
-  endif
-
-  let lines = map(filter(content, '!empty(v:val.files)'), 's:format_gist(v:val)')
-  call setline(1, split(join(lines, "\n"), "\n"))
-
-  $put='more...'
-
-  let b:gistls = a:gistls
-  let b:page = a:page
-  setlocal buftype=nofile bufhidden=hide noswapfile
-  setlocal cursorline
-  setlocal nomodified
-  setlocal nomodifiable
-  syntax match SpecialKey /^gist:/he=e-1
-  syntax match Title /^gist: \S\+/hs=s+5 contains=ALL
-  nnoremap <silent> <buffer> <cr> :call <SID>GistListAction(0)<cr>
-  nnoremap <silent> <buffer> o :call <SID>GistListAction(0)<cr>
-  nnoremap <silent> <buffer> b :call <SID>GistListAction(1)<cr>
-  nnoremap <silent> <buffer> y :call <SID>GistListAction(2)<cr>
-  nnoremap <silent> <buffer> p :call <SID>GistListAction(3)<cr>
-  nnoremap <silent> <buffer> <esc> :bw<cr>
-  nnoremap <silent> <buffer> <s-cr> :call <SID>GistListAction(1)<cr>
-
-  cal cursor(1+len(oldlines),1)
-  nohlsearch
-  redraw | echo ''
-endfunction
-
-function! gist#list_recursively(user, ...) abort
-  let use_cache = get(a:000, 0, 1)
-  let limit = get(a:000, 1, -1)
-  let verbose = get(a:000, 2, 1)
-  if a:user ==# 'mine'
-    let url = g:gist_api_url . 'gists'
-  elseif a:user ==# 'starred'
-    let url = g:gist_api_url . 'gists/starred'
-  else
-    let url = g:gist_api_url.'users/'.a:user.'/gists'
-  endif
-
-  let auth = s:GistGetAuthHeader()
-  if len(auth) == 0
-    " anonymous user cannot get gists to prevent infinite recursive loading
-    return []
-  endif
-
-  if use_cache && exists('g:gist_list_recursively_cache')
-    if has_key(g:gist_list_recursively_cache, a:user)
-      return webapi#json#decode(g:gist_list_recursively_cache[a:user])
-    endif
-  endif
-
-  let page = 1
-  let gists = []
-  let lastpage = -1
-
-  function! s:get_lastpage(res) abort
-    let links = split(a:res.header[match(a:res.header, 'Link')], ',')
-    let link = links[match(links, 'rel=[''"]last[''"]')]
-    let page = str2nr(matchlist(link, '\%(page=\)\(\d\+\)')[1])
-    return page
-  endfunction
-
-  if verbose > 0
-    redraw | echon 'Loading gists...'
-  endif
-
-  while limit == -1 || page <= limit
-    let res = webapi#http#get(url.'?page='.page, '', {'Authorization': auth})
-    if limit == -1
-      " update limit to the last page
-      let limit = s:get_lastpage(res)
-    endif
-    if verbose > 0
-      redraw | echon 'Loading gists... ' . page . '/' . limit . ' pages has loaded.'
-    endif
-    let gists = gists + webapi#json#decode(res.content)
-    let page = page + 1
-  endwhile
-  let g:gist_list_recursively_cache = get(g:, 'gist_list_recursively_cache', {})
-  let g:gist_list_recursively_cache[a:user] = webapi#json#encode(gists)
-  return gists
-endfunction
-
-function! gist#list(user, ...) abort
-  let page = get(a:000, 0, 0)
-  if a:user ==# '-all'
-    let url = g:gist_api_url.'gists/public'
-  elseif get(g:, 'gist_show_privates', 0) && a:user ==# 'starred'
-    let url = g:gist_api_url.'gists/starred'
-  elseif get(g:, 'gist_show_privates') && a:user ==# 'mine'
-    let url = g:gist_api_url.'gists'
-  else
-    let url = g:gist_api_url.'users/'.a:user.'/gists'
-  endif
-
-  let auth = s:GistGetAuthHeader()
-  if len(auth) == 0
-    return []
-  endif
-  let res = webapi#http#get(url, '', { "Authorization": auth })
-  return webapi#json#decode(res.content)
-endfunction
-
-function! s:GistGetFileName(gistid) abort
-  let auth = s:GistGetAuthHeader()
-  if len(auth) == 0
-    return ''
-  endif
-  let res = webapi#http#get(g:gist_api_url.'gists/'.a:gistid, '', { "Authorization": auth })
-  let gist = webapi#json#decode(res.content)
-  if has_key(gist, 'files')
-    return sort(keys(gist.files))[0]
-  endif
-  return ''
-endfunction
-
-function! s:GistDetectFiletype(gistid) abort
-  let auth = s:GistGetAuthHeader()
-  if len(auth) == 0
-    return ''
-  endif
-  let res = webapi#http#get(g:gist_api_url.'gists/'.a:gistid, '', { "Authorization": auth })
-  let gist = webapi#json#decode(res.content)
-  let filename = sort(keys(gist.files))[0]
-  let ext = fnamemodify(filename, ':e')
-  if has_key(s:extmap, ext)
-    let type = s:extmap[ext]
-  else
-    let type = get(gist.files[filename], 'type', 'text')
-  endif
-  silent! exec 'setlocal ft='.tolower(type)
-endfunction
-
-function! s:GistWrite(fname) abort
-  if substitute(a:fname, '\\', '/', 'g') == expand("%:p:gs@\\@/@")
-    if g:gist_update_on_write != 2 || v:cmdbang
-      Gist -e
-    else
-      echohl ErrorMsg | echomsg 'Please type ":w!" to update a gist.' | echohl None
-    endif
-  else
-    exe 'w'.(v:cmdbang ? '!' : '') fnameescape(v:cmdarg) fnameescape(a:fname)
-    silent! exe 'file' fnameescape(a:fname)
-    silent! au! BufWriteCmd <buffer>
-  endif
-endfunction
-
-function! s:GistGet(gistid, clipboard) abort
-  redraw | echon 'Getting gist... '
-  let res = webapi#http#get(g:gist_api_url.'gists/'.a:gistid, '', { "Authorization": s:GistGetAuthHeader() })
-  if res.status =~# '^2'
-    try
-      let gist = webapi#json#decode(res.content)
-    catch
-      redraw
-      echohl ErrorMsg | echomsg 'Gist seems to be broken' | echohl None
-      return
-    endtry
-    if get(g:, 'gist_get_multiplefile', 0) != 0
-      let num_file = len(keys(gist.files))
-    else
-      let num_file = 1
-    endif
-    redraw
-    if num_file > len(keys(gist.files))
-      echohl ErrorMsg | echomsg 'Gist not found' | echohl None
-      return
-    endif
-    augroup GistWrite
-      au!
-    augroup END
-    for n in range(num_file)
-      try
-        let old_undolevels = &undolevels
-        let filename = sort(keys(gist.files))[n]
-
-        let winnum = bufwinnr(bufnr(s:bufprefix.a:gistid.'/'.filename))
-        if winnum != -1
-          if winnum != bufwinnr('%')
-            exe winnum 'wincmd w'
-          endif
-          setlocal modifiable
-        else
-          if num_file == 1
-            if get(g:, 'gist_edit_with_buffers', 0)
-              let found = -1
-              for wnr in range(1, winnr('$'))
-                let bnr = winbufnr(wnr)
-                if bnr != -1 && !empty(getbufvar(bnr, 'gist'))
-                  let found = wnr
-                  break
-                endif
-              endfor
-              if found != -1
-                exe found 'wincmd w'
-                setlocal modifiable
-              else
-                if get(g:, 'gist_list_vsplit', 0)
-                  exec 'silent noautocmd rightbelow vnew'
-                else
-                  exec 'silent noautocmd rightbelow new'
-                endif
-              endif
-            else
-              silent only!
-              if get(g:, 'gist_list_vsplit', 0)
-                exec 'silent noautocmd rightbelow vnew'
-              else
-                exec 'silent noautocmd rightbelow new'
-              endif
-            endif
-          else
-            if get(g:, 'gist_list_vsplit', 0)
-              exec 'silent noautocmd rightbelow vnew'
-            else
-              exec 'silent noautocmd rightbelow new'
-            endif
-          endif
-          setlocal noswapfile
-          silent exec 'noautocmd file' s:bufprefix.a:gistid.'/'.fnameescape(filename)
-        endif
-        set undolevels=-1
-        filetype detect
-        silent %d _
-
-        let content = gist.files[filename].content
-        call setline(1, split(content, "\n"))
-        let b:gist = {
-        \ "filename": filename,
-        \ "id": gist.id,
-        \ "description": gist.description,
-        \ "private": gist.public =~ 'true',
-        \}
-      catch
-        let &undolevels = old_undolevels
-        bw!
-        redraw
-        echohl ErrorMsg | echomsg 'Gist contains binary' | echohl None
-        return
-      endtry
-      let &undolevels = old_undolevels
-      setlocal buftype=acwrite bufhidden=hide noswapfile
-      setlocal nomodified
-      doau StdinReadPost,BufRead,BufReadPost
-      let gist_detect_filetype = get(g:, 'gist_detect_filetype', 0)
-      if (&ft ==# '' && gist_detect_filetype == 1) || gist_detect_filetype == 2
-        call s:GistDetectFiletype(a:gistid)
-      endif
-      if a:clipboard
-        if exists('g:gist_clip_command')
-          exec 'silent w !'.g:gist_clip_command
-        elseif has('clipboard')
-          silent! %yank +
-        else
-          %yank
-        endif
-      endif
-      1
-      augroup GistWrite
-        au! BufWriteCmd <buffer> call s:GistWrite(expand("<amatch>"))
-      augroup END
-    endfor
-  else
-    bw!
-    redraw
-    echohl ErrorMsg | echomsg 'Gist not found' | echohl None
-    return
-  endif
-endfunction
-
-function! s:GistListAction(mode) abort
-  let line = getline('.')
-  let mx = '^gist:\s*\zs\(\w\+\)\ze.*'
-  if line =~# mx
-    let gistid = matchstr(line, mx)
-    if a:mode == 1
-      call s:open_browser('https://gist.github.com/' . gistid)
-    elseif a:mode == 0
-      call s:GistGet(gistid, 0)
-      wincmd w
-      bw
-    elseif a:mode == 2
-      call s:GistGet(gistid, 1)
-      " TODO close with buffe rname
-      bdelete
-      bdelete
-    elseif a:mode == 3
-      call s:GistGet(gistid, 1)
-      " TODO close with buffe rname
-      bdelete
-      bdelete
-      normal! "+p
-    endif
-    return
-  endif
-  if line =~# '^more\.\.\.$'
-    call s:GistList(b:gistls, b:page+1)
-    return
-  endif
-endfunction
-
-function! s:GistUpdate(content, gistid, gistnm, desc) abort
-  let gist = { "id": a:gistid, "files" : {}, "description": "","public": function('webapi#json#true') }
-  if exists('b:gist')
-    if has_key(b:gist, 'filename') && len(a:gistnm) > 0
-      let gist.files[b:gist.filename] = { "content": '', "filename": b:gist.filename }
-      let b:gist.filename = a:gistnm
-    endif
-    if has_key(b:gist, 'private') && b:gist.private | let gist['public'] = function('webapi#json#false') | endif
-    if has_key(b:gist, 'description') | let gist['description'] = b:gist.description | endif
-    if has_key(b:gist, 'filename') | let filename = b:gist.filename | endif
-  else
-    let filename = a:gistnm
-    if len(filename) == 0 | let filename = s:GistGetFileName(a:gistid) | endif
-    if len(filename) == 0 | let filename = s:get_current_filename(1) | endif
-  endif
-
-  let auth = s:GistGetAuthHeader()
-  if len(auth) == 0
-    redraw
-    echohl ErrorMsg | echomsg v:errmsg | echohl None
-    return
-  endif
-
-  " Update description
-  " If no new description specified, keep the old description
-  if a:desc !=# ' '
-    let gist['description'] = a:desc
-  else
-    let res = webapi#http#get(g:gist_api_url.'gists/'.a:gistid, '', { "Authorization": auth })
-    if res.status =~# '^2'
-      let old_gist = webapi#json#decode(res.content)
-      let gist['description'] = old_gist.description
-    endif
-  endif
-
-  let gist.files[filename] = { "content": a:content, "filename": filename }
-
-  redraw | echon 'Updating gist... '
-  let res = webapi#http#post(g:gist_api_url.'gists/' . a:gistid,
-  \ webapi#json#encode(gist), {
-  \   "Authorization": auth,
-  \   "Content-Type": "application/json",
-  \})
-  if res.status =~# '^2'
-    let obj = webapi#json#decode(res.content)
-    let loc = obj['html_url']
-    let b:gist = {"id": a:gistid, "filename": filename}
-    setlocal nomodified
-    redraw | echomsg 'Done: '.loc
-  else
-    let loc = ''
-    echohl ErrorMsg | echomsg 'Post failed: ' . res.message | echohl None
-  endif
-  return loc
-endfunction
-
-function! s:GistDelete(gistid) abort
-  let auth = s:GistGetAuthHeader()
-  if len(auth) == 0
-    redraw
-    echohl ErrorMsg | echomsg v:errmsg | echohl None
-    return
-  endif
-
-  redraw | echon 'Deleting gist... '
-  let res = webapi#http#post(g:gist_api_url.'gists/'.a:gistid, '', {
-  \   "Authorization": auth,
-  \   "Content-Type": "application/json",
-  \}, 'DELETE')
-  if res.status =~# '^2'
-    if exists('b:gist')
-      unlet b:gist
-    endif
-    redraw | echomsg 'Done: '
-  else
-    echohl ErrorMsg | echomsg 'Delete failed: ' . res.message | echohl None
-  endif
-endfunction
-
-function! s:get_current_filename(no) abort
-  let filename = expand('%:t')
-  if len(filename) == 0 && &ft !=# ''
-    let pair = filter(items(s:extmap), 'v:val[1] == &ft')
-    if len(pair) > 0
-      let filename = printf('gistfile%d%s', a:no, pair[0][0])
-    endif
-  endif
-  if filename ==# ''
-    let filename = printf('gistfile%d.txt', a:no)
-  endif
-  return filename
-endfunction
-
-function! s:update_GistID(id) abort
-  let view = winsaveview()
-  normal! gg
-  let ret = 0
-  if search('\<GistID\>:\s*$')
-    let line = getline('.')
-    let line = substitute(line, '\s\+$', '', 'g')
-    call setline('.', line . ' ' . a:id)
-    let ret = 1
-  endif
-  call winrestview(view)
-  return ret
-endfunction
-
-" GistPost function:
-"   Post new gist to github
-"
-"   if there is an embedded gist url or gist id in your file,
-"   it will just update it.
-"                                                   -- by c9s
-"
-"   embedded gist id format:
-"
-"       GistID: 123123
-"
-function! s:GistPost(content, private, desc, anonymous) abort
-  let gist = { "files" : {}, "description": "","public": function('webapi#json#true') }
-  if a:desc !=# ' ' | let gist['description'] = a:desc | endif
-  if a:private | let gist['public'] = function('webapi#json#false') | endif
-  let filename = s:get_current_filename(1)
-  let gist.files[filename] = { "content": a:content, "filename": filename }
-
-  let header = {"Content-Type": "application/json"}
-  if !a:anonymous
-    let auth = s:GistGetAuthHeader()
-    if len(auth) == 0
-      redraw
-      echohl ErrorMsg | echomsg v:errmsg | echohl None
-      return
-    endif
-    let header['Authorization'] = auth
-  endif
-
-  redraw | echon 'Posting it to gist... '
-  let res = webapi#http#post(g:gist_api_url.'gists', webapi#json#encode(gist), header)
-  if res.status =~# '^2'
-    let obj = webapi#json#decode(res.content)
-    let loc = obj['html_url']
-    let b:gist = {
-    \ "filename": filename,
-    \ "id": matchstr(loc, '[^/]\+$'),
-    \ "description": gist['description'],
-    \ "private": a:private,
-    \}
-    if s:update_GistID(b:gist['id'])
-      Gist -e
-    endif
-    redraw | echomsg 'Done: '.loc
-  else
-    let loc = ''
-    echohl ErrorMsg | echomsg 'Post failed: '. res.message | echohl None
-  endif
-  return loc
-endfunction
-
-function! s:GistPostBuffers(private, desc, anonymous) abort
-  let bufnrs = range(1, bufnr('$'))
-  let bn = bufnr('%')
-  let query = []
-
-  let gist = { "files" : {}, "description": "","public": function('webapi#json#true') }
-  if a:desc !=# ' ' | let gist['description'] = a:desc | endif
-  if a:private | let gist['public'] = function('webapi#json#false') | endif
-
-  let index = 1
-  for bufnr in bufnrs
-    if !bufexists(bufnr) || buflisted(bufnr) == 0
-      continue
-    endif
-    echo 'Creating gist content'.index.'... '
-    silent! exec 'buffer!' bufnr
-    let content = join(getline(1, line('$')), "\n")
-    let filename = s:get_current_filename(index)
-    let gist.files[filename] = { "content": content, "filename": filename }
-    let index = index + 1
-  endfor
-  silent! exec 'buffer!' bn
-
-  let header = {"Content-Type": "application/json"}
-  if !a:anonymous
-    let auth = s:GistGetAuthHeader()
-    if len(auth) == 0
-      redraw
-      echohl ErrorMsg | echomsg v:errmsg | echohl None
-      return
-    endif
-    let header['Authorization'] = auth
-  endif
-
-  redraw | echon 'Posting it to gist... '
-  let res = webapi#http#post(g:gist_api_url.'gists', webapi#json#encode(gist), header)
-  if res.status =~# '^2'
-    let obj = webapi#json#decode(res.content)
-    let loc = obj['html_url']
-    let b:gist = {
-    \ "filename": filename,
-    \ "id": matchstr(loc, '[^/]\+$'),
-    \ "description": gist['description'],
-    \ "private": a:private,
-    \}
-    if s:update_GistID(b:gist['id'])
-      Gist -e
-    endif
-    redraw | echomsg 'Done: '.loc
-  else
-    let loc = ''
-    echohl ErrorMsg | echomsg 'Post failed: ' . res.message | echohl None
-  endif
-  return loc
-endfunction
-
-function! gist#Gist(count, bang, line1, line2, ...) abort
-  redraw
-  let bufname = bufname('%')
-  " find GistID: in content , then we should just update
-  let gistid = ''
-  let gistls = ''
-  let gistnm = ''
-  let gistdesc = ' '
-  let private = get(g:, 'gist_post_private', 0)
-  let multibuffer = 0
-  let clipboard = 0
-  let deletepost = 0
-  let editpost = 0
-  let anonymous = get(g:, 'gist_post_anonymous', 0)
-  let openbrowser = 0
-  let listmx = '^\%(-l\|--list\)\s*\([^\s]\+\)\?$'
-  let bufnamemx = '^' . s:bufprefix .'\(\zs[0-9a-f]\+\ze\|\zs[0-9a-f]\+\ze[/\\].*\)$'
-  if strlen(g:github_user) == 0 && anonymous == 0
-    echohl ErrorMsg | echomsg 'You have not configured a Github account. Read '':help gist-vim-setup''.' | echohl None
-    return
-  endif
-  if a:bang == '!'
-    let gistidbuf = ''
-  elseif bufname =~# bufnamemx
-    let gistidbuf = matchstr(bufname, bufnamemx)
-  elseif exists('b:gist') && has_key(b:gist, 'id')
-    let gistidbuf = b:gist['id']
-  else
-    let gistidbuf = matchstr(join(getline(a:line1, a:line2), "\n"), 'GistID:\s*\zs\w\+')
-  endif
-
-  let args = (a:0 > 0) ? s:shellwords(a:1) : []
-  for arg in args
-    if arg =~# '^\(-h\|--help\)$\C'
-      help :Gist
-      return
-    elseif arg =~# '^\(-g\|--git\)$\C' && gistidbuf !=# '' && g:gist_api_url ==# 'https://api.github.com/' && has_key(b:, 'gist') && has_key(b:gist, 'id')
-      echo printf('git clone git@github.com:%s', b:gist['id'])
-      return
-    elseif arg =~# '^\(-G\|--gitclone\)$\C' && gistidbuf !=# '' && g:gist_api_url ==# 'https://api.github.com/' && has_key(b:, 'gist') && has_key(b:gist, 'id')
-      exe '!' printf('git clone git@github.com:%s', b:gist['id'])
-      return
-    elseif arg =~# '^\(-la\|--listall\)$\C'
-      let gistls = '-all'
-    elseif arg =~# '^\(-ls\|--liststar\)$\C'
-      let gistls = 'starred'
-    elseif arg =~# '^\(-l\|--list\)$\C'
-      if get(g:, 'gist_show_privates')
-        let gistls = 'mine'
-      else
-        let gistls = g:github_user
-      endif
-    elseif arg =~# '^\(-m\|--multibuffer\)$\C'
-      let multibuffer = 1
-    elseif arg =~# '^\(-p\|--private\)$\C'
-      let private = 1
-    elseif arg =~# '^\(-P\|--public\)$\C'
-      let private = 0
-    elseif arg =~# '^\(-a\|--anonymous\)$\C'
-      let anonymous = 1
-    elseif arg =~# '^\(-s\|--description\)$\C'
-      let gistdesc = ''
-    elseif arg =~# '^\(-c\|--clipboard\)$\C'
-      let clipboard = 1
-    elseif arg =~# '^--rawurl$\C' && gistidbuf !=# '' && g:gist_api_url ==# 'https://api.github.com/'
-      let gistid = gistidbuf
-      echo 'https://gist.github.com/raw/'.gistid
-      return
-    elseif arg =~# '^\(-d\|--delete\)$\C' && gistidbuf !=# ''
-      let gistid = gistidbuf
-      let deletepost = 1
-    elseif arg =~# '^\(-e\|--edit\)$\C'
-      if gistidbuf !=# ''
-        let gistid = gistidbuf
-      endif
-      let editpost = 1
-    elseif arg =~# '^\(+1\|--star\)$\C' && gistidbuf !=# ''
-      let auth = s:GistGetAuthHeader()
-      if len(auth) == 0
-        echohl ErrorMsg | echomsg v:errmsg | echohl None
-      else
-        let gistid = gistidbuf
-        let res = webapi#http#post(g:gist_api_url.'gists/'.gistid.'/star', '', { "Authorization": auth }, 'PUT')
-        if res.status =~# '^2'
-          echomsg 'Starred' gistid
-        else
-          echohl ErrorMsg | echomsg 'Star failed' | echohl None
-        endif
-      endif
-      return
-    elseif arg =~# '^\(-1\|--unstar\)$\C' && gistidbuf !=# ''
-      let auth = s:GistGetAuthHeader()
-      if len(auth) == 0
-        echohl ErrorMsg | echomsg v:errmsg | echohl None
-      else
-        let gistid = gistidbuf
-        let res = webapi#http#post(g:gist_api_url.'gists/'.gistid.'/star', '', { "Authorization": auth }, 'DELETE')
-        if res.status =~# '^2'
-          echomsg 'Unstarred' gistid
-        else
-          echohl ErrorMsg | echomsg 'Unstar failed' | echohl None
-        endif
-      endif
-      return
-    elseif arg =~# '^\(-f\|--fork\)$\C' && gistidbuf !=# ''
-      let auth = s:GistGetAuthHeader()
-      if len(auth) == 0
-        echohl ErrorMsg | echomsg v:errmsg | echohl None
-        return
-      else
-        let gistid = gistidbuf
-        let res = webapi#http#post(g:gist_api_url.'gists/'.gistid.'/fork', '', { "Authorization": auth })
-        if res.status =~# '^2'
-          let obj = webapi#json#decode(res.content)
-          let gistid = obj['id']
-        else
-          echohl ErrorMsg | echomsg 'Fork failed' | echohl None
-          return
-        endif
-      endif
-    elseif arg =~# '^\(-b\|--browser\)$\C'
-      let openbrowser = 1
-    elseif arg !~# '^-' && len(gistnm) == 0
-      if gistdesc !=# ' '
-        let gistdesc = matchstr(arg, '^\s*\zs.*\ze\s*$')
-      elseif editpost == 1 || deletepost == 1
-        let gistnm = arg
-      elseif len(gistls) > 0 && arg !=# '^\w\+$\C'
-        let gistls = arg
-      elseif arg =~# '^[0-9a-z]\+$\C'
-        let gistid = arg
-      else
-        echohl ErrorMsg | echomsg 'Invalid arguments: '.arg | echohl None
-        unlet args
-        return 0
-      endif
-    elseif len(arg) > 0
-      echohl ErrorMsg | echomsg 'Invalid arguments: '.arg | echohl None
-      unlet args
-      return 0
-    endif
-  endfor
-  unlet args
-  "echom "gistid=".gistid
-  "echom "gistls=".gistls
-  "echom "gistnm=".gistnm
-  "echom "gistdesc=".gistdesc
-  "echom "private=".private
-  "echom "clipboard=".clipboard
-  "echom "editpost=".editpost
-  "echom "deletepost=".deletepost
-
-  if gistidbuf !=# '' && gistid ==# '' && editpost == 0 && deletepost == 0 && anonymous == 0
-    let editpost = 1
-    let gistid = gistidbuf
-  endif
-
-  if len(gistls) > 0
-    call s:GistList(gistls, 1)
-  elseif len(gistid) > 0 && editpost == 0 && deletepost == 0
-    call s:GistGet(gistid, clipboard)
-  else
-    let url = ''
-    if multibuffer == 1
-      let url = s:GistPostBuffers(private, gistdesc, anonymous)
-    else
-      if a:count < 1
-        let content = join(getline(a:line1, a:line2), "\n")
-      else
-        let save_regcont = @"
-        let save_regtype = getregtype('"')
-        silent! normal! gvy
-        let content = @"
-        call setreg('"', save_regcont, save_regtype)
-      endif
-      if editpost == 1
-        let url = s:GistUpdate(content, gistid, gistnm, gistdesc)
-      elseif deletepost == 1
-        call s:GistDelete(gistid)
-      else
-        let url = s:GistPost(content, private, gistdesc, anonymous)
-      endif
-      if a:count >= 1 && get(g:, 'gist_keep_selection', 0) == 1
-        silent! normal! gv
-      endif
-    endif
-    if type(url) == 1 && len(url) > 0
-      if get(g:, 'gist_open_browser_after_post', 0) == 1 || openbrowser
-        call s:open_browser(url)
-      endif
-      let gist_put_url_to_clipboard_after_post = get(g:, 'gist_put_url_to_clipboard_after_post', 1)
-      if gist_put_url_to_clipboard_after_post > 0 || clipboard
-        if gist_put_url_to_clipboard_after_post == 2
-          let url = url . "\n"
-        endif
-        if exists('g:gist_clip_command')
-          call system(g:gist_clip_command, url)
-        elseif has('clipboard')
-          let @+ = url
-        else
-          let @" = url
-        endif
-      endif
-    endif
-  endif
-  return 1
-endfunction
-
-function! s:GistGetAuthHeader() abort
-  if get(g:, 'gist_use_password_in_gitconfig', 0) != 0
-    let password = substitute(system('git config --get github.password'), "\n", '', '')
-    if password =~# '^!' | let password = system(password[1:]) | endif
-    return printf('basic %s', webapi#base64#b64encode(g:github_user.':'.password))
-  endif
-  let auth = ''
-  if !empty(get(g:, 'gist_token', $GITHUB_TOKEN))
-    let auth = 'token ' . get(g:, 'gist_token', $GITHUB_TOKEN)
-  elseif filereadable(s:gist_token_file)
-    let str = join(readfile(s:gist_token_file), '')
-    if type(str) == 1
-      let auth = str
-    endif
-  endif
-  if len(auth) > 0
-    return auth
-  endif
-
-  redraw
-  echohl WarningMsg
-  echo 'Gist.vim requires authorization to use the GitHub API. These settings are stored in "~/.gist-vim". If you want to revoke, do "rm ~/.gist-vim".'
-  echohl None
-  let password = inputsecret('GitHub Password for '.g:github_user.':')
-  if len(password) == 0
-    let v:errmsg = 'Canceled'
-    return ''
-  endif
-  let note = 'Gist.vim on '.hostname().' '.strftime('%Y/%m/%d-%H:%M:%S')
-  let note_url = 'http://www.vim.org/scripts/script.php?script_id=2423'
-  let insecureSecret = printf('basic %s', webapi#base64#b64encode(g:github_user.':'.password))
-  let res = webapi#http#post(g:gist_api_url.'authorizations', webapi#json#encode({
-              \  "scopes"   : ["gist"],
-              \  "note"     : note,
-              \  "note_url" : note_url,
-              \}), {
-              \  "Content-Type"  : "application/json",
-              \  "Authorization" : insecureSecret,
-              \})
-  let h = filter(res.header, 'stridx(v:val, "X-GitHub-OTP:") == 0')
-  if len(h)
-    let otp = inputsecret('OTP:')
-    if len(otp) == 0
-      let v:errmsg = 'Canceled'
-      return ''
-    endif
-    let res = webapi#http#post(g:gist_api_url.'authorizations', webapi#json#encode({
-                \  "scopes"   : ["gist"],
-                \  "note"     : note,
-                \  "note_url" : note_url,
-                \}), {
-                \  "Content-Type"  : "application/json",
-                \  "Authorization" : insecureSecret,
-                \  "X-GitHub-OTP"  : otp,
-                \})
-  endif
-  let authorization = webapi#json#decode(res.content)
-  if has_key(authorization, 'token')
-    let secret = printf('token %s', authorization.token)
-    call writefile([secret], s:gist_token_file)
-    if !(has('win32') || has('win64'))
-      call system('chmod go= '.s:gist_token_file)
-    endif
-  elseif has_key(authorization, 'message')
-    let secret = ''
-    let v:errmsg = authorization.message
-  endif
-  return secret
-endfunction
-
-let s:extmap = extend({
-\".adb": "ada",
-\".ahk": "ahk",
-\".arc": "arc",
-\".as": "actionscript",
-\".asm": "asm",
-\".asp": "asp",
-\".aw": "php",
-\".b": "b",
-\".bat": "bat",
-\".befunge": "befunge",
-\".bmx": "bmx",
-\".boo": "boo",
-\".c-objdump": "c-objdump",
-\".c": "c",
-\".cfg": "cfg",
-\".cfm": "cfm",
-\".ck": "ck",
-\".cl": "cl",
-\".clj": "clj",
-\".cmake": "cmake",
-\".coffee": "coffee",
-\".cpp": "cpp",
-\".cppobjdump": "cppobjdump",
-\".cs": "csharp",
-\".css": "css",
-\".cw": "cw",
-\".d-objdump": "d-objdump",
-\".d": "d",
-\".darcspatch": "darcspatch",
-\".diff": "diff",
-\".duby": "duby",
-\".dylan": "dylan",
-\".e": "e",
-\".ebuild": "ebuild",
-\".eclass": "eclass",
-\".el": "lisp",
-\".erb": "erb",
-\".erl": "erlang",
-\".f90": "f90",
-\".factor": "factor",
-\".feature": "feature",
-\".fs": "fs",
-\".fy": "fy",
-\".go": "go",
-\".groovy": "groovy",
-\".gs": "gs",
-\".gsp": "gsp",
-\".haml": "haml",
-\".hs": "haskell",
-\".html": "html",
-\".hx": "hx",
-\".ik": "ik",
-\".ino": "ino",
-\".io": "io",
-\".j": "j",
-\".java": "java",
-\".js": "javascript",
-\".json": "json",
-\".jsp": "jsp",
-\".kid": "kid",
-\".lhs": "lhs",
-\".lisp": "lisp",
-\".ll": "ll",
-\".lua": "lua",
-\".ly": "ly",
-\".m": "objc",
-\".mak": "mak",
-\".man": "man",
-\".mao": "mao",
-\".matlab": "matlab",
-\".md": "markdown",
-\".minid": "minid",
-\".ml": "ml",
-\".moo": "moo",
-\".mu": "mu",
-\".mustache": "mustache",
-\".mxt": "mxt",
-\".myt": "myt",
-\".n": "n",
-\".nim": "nim",
-\".nu": "nu",
-\".numpy": "numpy",
-\".objdump": "objdump",
-\".ooc": "ooc",
-\".parrot": "parrot",
-\".pas": "pas",
-\".pasm": "pasm",
-\".pd": "pd",
-\".phtml": "phtml",
-\".pir": "pir",
-\".pl": "perl",
-\".po": "po",
-\".py": "python",
-\".pytb": "pytb",
-\".pyx": "pyx",
-\".r": "r",
-\".raw": "raw",
-\".rb": "ruby",
-\".rhtml": "rhtml",
-\".rkt": "rkt",
-\".rs": "rs",
-\".rst": "rst",
-\".s": "s",
-\".sass": "sass",
-\".sc": "sc",
-\".scala": "scala",
-\".scm": "scheme",
-\".scpt": "scpt",
-\".scss": "scss",
-\".self": "self",
-\".sh": "sh",
-\".sml": "sml",
-\".sql": "sql",
-\".st": "smalltalk",
-\".swift": "swift",
-\".tcl": "tcl",
-\".tcsh": "tcsh",
-\".tex": "tex",
-\".textile": "textile",
-\".tpl": "smarty",
-\".twig": "twig",
-\".txt" : "text",
-\".v": "verilog",
-\".vala": "vala",
-\".vb": "vbnet",
-\".vhd": "vhdl",
-\".vim": "vim",
-\".weechatlog": "weechatlog",
-\".xml": "xml",
-\".xq": "xquery",
-\".xs": "xs",
-\".yml": "yaml",
-\}, get(g:, 'gist_extmap', {}))
-
-let &cpo = s:save_cpo
-unlet s:save_cpo
-
-" vim:set et:
diff --git a/sources_non_forked/gist-vim/doc/gist-vim.txt b/sources_non_forked/gist-vim/doc/gist-vim.txt
deleted file mode 100644
index c7005a7..0000000
--- a/sources_non_forked/gist-vim/doc/gist-vim.txt
+++ /dev/null
@@ -1,358 +0,0 @@
-*Gist.vim* Vimscript for creating gists (http://gist.github.com)
-
-Usage                                          |gist-vim-usage|
-Tips                                           |gist-vim-tips|
-License                                        |gist-vim-license|
-Install                                        |gist-vim-install|
-Requirements                                   |gist-vim-requirements|
-Setup                                          |gist-vim-setup|
-FAQ                                            |gist-vim-faq|
-
-This is a vimscript for creating gists (http://gist.github.com)
-
-For the latest version please see https://github.com/mattn/gist-vim.
-
-==============================================================================
-USAGE                                                 *:Gist* *gist-vim-usage*
-
-- Post current buffer to gist, using default privacy option. >
-
-    :Gist
-<
-- Post selected text to gist, using default privacy option.
-  This applies to all permutations listed below (except multi). >
-
-    :'<,'>Gist
-<
-- Create a private gist. >
-
-    :Gist -p
-    :Gist --private
-<
-- Create a public gist.
-  (Only relevant if you've set gists to be private by default.) >
-
-    :Gist -P
-    :Gist --public
-<
-- Post whole text to gist as public.
-  This is only relevant if you've set gists to be private by default.
->
-    :Gist -P
-<
-- Create a gist anonymously. >
-
-    :Gist -a
-    :Gist --anonymous
-<
-- Create a gist with all open buffers. >
-
-    :Gist -m
-    :Gist --multibuffer
-<
-- Edit the gist (you need to have opened the gist buffer first).
-  You can update the gist with the {:w} command within the gist buffer. >
-
-    :Gist -e
-    :Gist --edit
-<
-- Edit the gist with name "foo.js" (you need to have opened the gist buffer
-  first). >
-
-    :Gist -e foo.js
-<
-- Post/Edit with the description " (you need to have opened the gist buffer
-  first). >
-
-    :Gist -s something
-    :Gist --description something
-    :Gist -e -s something
-<
-- Delete the gist (you need to have opened the gist buffer first).
-  Password authentication is needed. >
-
-    :Gist -d
-    :Gist --delete
-<
-- Fork the gist (you need to have opened the gist buffer first).
-  Password authentication is needed. >
-
-    :Gist -f
-    :Gist --fork
-<
-- Star the gist (you need to have opened the gist buffer first).
-  Password authentication is needed.
->
-    :Gist +1
-<
-- Unstar the gist (you need to have opened the gist buffer first).
-  Password authentication is needed.
->
-    :Gist -1
-<
-- Get gist XXXXX. >
-
-    :Gist XXXXX
-<
-- Get gist XXXXX and add to clipboard. >
-
-    :Gist -c XXXXX
-<
-- List your public gists. >
-
-    :Gist -l
-    :Gist --list
-<
-- List gists from user "mattn". >
-
-    :Gist -l mattn
-<
-- List everyone's gists. >
-
-    :Gist -la
-    :Gist --listall
-<
-- List gists from your starred gists.
->
-    :Gist -ls
-    :Gist --liststar
-
-- While the gist list is visible, the following mappings apply:
-
-  - 'o' or 'Enter' will open the selected gist file in a new buffer
-    and close the gist-vim listing split.
-  - 'b' will open the selected gist file in a browser. If you are in
-    GUI vim you can also achieve this by pressing 'Shift-Enter'.
-  - 'y' will copy the contents of the selected gist to the clipboard,
-    and close the gist-vim listing split.
-  - 'p' will (copy and) paste the contents of the selected gist to the
-    buffer from which gist-vim was called, and close the gist-vim
-    listing split.
-  - 'Esc' will close the gist-vim listing split without performing any
-    further action.
-
-- Open the gist on browser after you post or update it.
->
-    :Gist -b
-    :Gist --browser
-<
-- Post as new gist after editing on the buffer.
->
-    :Gist!
-<
-==============================================================================
-TIPS                                                           *gist-vim-tips*
-
-If you set "g:gist_clip_command", gist.vim will copy the gist code with option
-"-c".
-
-  - Mac: >
-    let g:gist_clip_command = 'pbcopy'
-<
-  - Linux: >
-    let g:gist_clip_command = 'xclip -selection clipboard'
-<
-  - Others (cygwin?): >
-    let g:gist_clip_command = 'putclip'
-<
-If you want to detect filetype from the filename: >
-
-    let g:gist_detect_filetype = 1
-<
-If you want to open the browser after the post: >
-
-    let g:gist_open_browser_after_post = 1
-<
-If you want to change the browser: >
-
-    let g:gist_browser_command = 'w3m %URL%'
-<
-or: >
-
-    let g:gist_browser_command = 'opera %URL% &'
-<
-On windows, this should work with your user settings.
-
-If you want to show your private gists with ":Gist -l": >
-
-    let g:gist_show_privates = 1
-<
-If you want your gist to be private by default: >
-
-    let g:gist_post_private = 1
-<
-If you want your gist to be anonymous by default: >
-
-    let g:gist_post_anonymous = 1
-<
-If you want to edit all files for gists containing more than one: >
-
-    let g:gist_get_multiplefile = 1
-<
-If you want to use on GitHub Enterprise: >
-
-    let g:gist_api_url = 'http://your-github-enterprise-domain/api/v3'
-<
-If you want to open gist with current editing buffers: >
-
-    let g:gist_edit_with_buffers = 1
-
-If you want to open gist list/buffer as vertical split: >
-
-    let g:gist_list_vsplit = 1
-
-If you want to modify filetype for the file on github, or add mapping of
-filetype/file-extension: >
-
-    let g:gist_extmap = { ".swift": "swift" }
-<
-    key is file-extension, value is filetype.
-
-If you want to update a gist, embed >
-
-    GistID: xxxxx
->
-in your local file, then call >
-
-    :Gist
-
-The gist-vim listing split lists gists ids, names (filenames) as well as
-their description. This is done following a table layout, with fixed space
-for each column. For offering quick browsing, gist-vim will truncate all
-output exceeding the available horizontal space, assuring that every gist
-listed only takes one line on the table. Although the gist id field width is
-fixed internally, the user can define the length of the (file)name field on
-the gist-vim listing. This can be done by the following declaration:
-
-    let g:gist_namelength = 20
-
-Note that the default value for gist_namelength is 30. Again, if the gist
-(file)name exceeds the specified number of characters, it will be truncated.
-
-If you want to update a gist when only |:w!|: >
-
-    " :w and :w! update a gist.
-    let g:gist_update_on_write = 1
-
-    " Only :w! updates a gist.
-    let g:gist_update_on_write = 2
->
-All other values are treated as 1.
-This variable's value is 1 by default.
-
-==============================================================================
-LICENSE                                                     *gist-vim-license*
-
-
-  Copyright 2010 by Yasuhiro Matsumoto
-  modification, are permitted provided that the following conditions are met:
-
-  1. Redistributions of source code must retain the above copyright notice,
-     this list of conditions and the following disclaimer.
-  2. Redistributions in binary form must reproduce the above copyright notice,
-     this list of conditions and the following disclaimer in the documentation
-     and/or other materials provided with the distribution.
-
-  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-  ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
-  REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
-  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
-  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
-  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
-  OF THE POSSIBILITY OF SUCH DAMAGE.
-
-==============================================================================
-INSTALL                                                     *gist-vim-install*
-
-Copy following files into your plugin directory.
-
-rtp:
-  - autoload/gist.vim
-  - plugin/gist.vim
-
-If you want to uninstall gist.vim, remember to also remove `~/.gist-vim`.
-
-You need to install webapi-vim also:
-
-  http://www.vim.org/scripts/script.php?script_id=4019
-
-If you want to use latest one:
-
-  https://github.com/mattn/webapi-vim
-
-==============================================================================
-REQUIREMENTS                                           *gist-vim-requirements*
-
-  - curl command (http://curl.haxx.se/)
-  - webapi-vim (https://github.com/mattn/webapi-vim)
-  - and, if you want to use your git profile, the git command-line client.
-
-==============================================================================
-SETUP                                                       *gist-vim-setup*
-
-This plugin uses GitHub API v3. The authentication value is stored in `~/.gist-vim`.
-gist-vim provides two ways to authenticate against the GitHub APIs.
-
-First, you need to set your GitHub username in global git config:
->
-    $ git config --global github.user Username
-<
-Then, gist.vim will ask for your password to create an authorization when you
-first use it.  The password is not stored and only the OAuth access token will
-be kept for later use.  You can revoke the token at any time from the list of
-"Authorized applications" on GitHub's "Account Settings" page.
-(https://github.com/settings/applications)
-
-If you have two-factor authentication enabled on GitHub, you'll see the message
-"Must specify two-factor authentication OTP code." In this case, you need to
-create a "Personal Access Token" on GitHub's "Account Settings" page
-(https://github.com/settings/applications) and place it in a file
-named ~/.gist-vim like this:
->
-    token xxxxx
-<
-If you happen to have your password already written in ~/.gitconfig like
-below:
->
-    [github]
-        password = xxxxx
-<
-Then, add following into your ~/.vimrc
->
-    let g:gist_use_password_in_gitconfig = 1
-<
-This is not secure at all, so strongly discouraged.
-
-NOTE: the username is optional if you only send anonymous gists.
-
-==============================================================================
-FAQ                                                           *gist-vim-faq*
-
-Q. :Gist returns a Forbidden error
-A. Try deleting ~/.gist-vim and authenticating again.
-
-==============================================================================
-THANKS                                                     *gist-vim-thanks*
-
-  AD7six
-  Bruno Bigras
-  c9s
-  Daniel Bretoi
-  Jeremy Michael Cantrell
-  Kien N
-  kongo2002
-  MATSUU Takuto
-  Matthew Weier O'Phinney
-  ornicar
-  Roland Schilter
-  steve
-  tyru
-  Will Gray
-  netj
-
- vim:tw=78:ts=8:ft=help:norl:
diff --git a/sources_non_forked/gist-vim/gist.vim.vimup b/sources_non_forked/gist-vim/gist.vim.vimup
deleted file mode 100644
index fa85320..0000000
--- a/sources_non_forked/gist-vim/gist.vim.vimup
+++ /dev/null
@@ -1,303 +0,0 @@
-script_name: Gist.vim
-script_id: '2423'
-script_type: utility
-script_package: gist-vim.zip
-script_version: '7.3'
-required_vim_version: '7.0'
-summary: vimscript for gist
-
-detailed_description: |
-  This is vimscript for gist (http://gist.github.com)
-
-  Usage:
-
-    :Gist
-      post whole text to gist.
-
-    :'<,'>Gist
-      post selected text to gist.
-
-    :Gist -p
-      post whole text to gist with private.
-      if you got empty gist list, try :Gist --abandon
-
-    :Gist -a
-      post whole text to gist with anonymous.
-
-    :Gist -m
-      post multi buffer to gist.
-
-    :Gist -e
-      edit the gist. (should be work on gist buffer)
-      you can update the gist with :w command on gist buffer.
-
-    :Gist -e foo.js
-      edit the gist with name 'foo.js'. (should be work on gist buffer)
-
-    :Gist -d
-      delete the gist. (should be work on gist buffer)
-      authentication required.
-
-    :Gist -f
-      fork the gist. (should be work on gist buffer)
-      authentication required.
-
-    :Gist XXXXX
-      get gist XXXXX.
-
-    :Gist -c XXXXX.
-      get gist XXXXX and put to clipboard.
-
-    :Gist -l
-      list gists from mine.
-
-    :Gist -la
-      list gists from all.
-
-  Tips:
-    if set g:gist_clip_command, gist.vim will copy the gist code
-      with option '-c'.
-
-      # mac
-      let g:gist_clip_command = 'pbcopy'
-
-      # linux
-      let g:gist_clip_command = 'xclip -selection clipboard'
-
-      # others(cygwin?)
-      let g:gist_clip_command = 'putclip'
-
-    if you want to detect filetype from filename...
-
-      let g:gist_detect_filetype = 1
-
-    if you want to open browser after the post...
-
-      let g:gist_open_browser_after_post = 1
-
-    if you want to change the browser...
-
-      let g:gist_browser_command = 'w3m %URL%'
-
-        or
-
-      let g:gist_browser_command = 'opera %URL% &'
-
-      on windows, should work with original setting.
-
-  Require:
-    curl command (http://curl.haxx.se/)
-    and if you want to use profile of git, it require git command.
-
-install_details: |
-  copy it to your plugin directory.
-
-  gist.vim leave cookie-jar file into runtimepath.
-
-  rtp:
-    plugin/gist.vim
-    cookies/github
-
-  See also: https://github.com/mattn/gist-vim/blob/master/README.mkd
-
-versions:
-- '7.3': |
-   This is an upgrade for Gist.vim: fixed many bugs. Added few list actions: yank, paste, open in browser.
-
-- '7.2': |
-   This is an upgrade for Gist.vim: fixed many bugs.
-
-- '7.1': |
-   This is an upgrade for Gist.vim: updated installation notes.
-
-- '7.0': |
-   This is an upgrade for Gist.vim: fixed few bugs.
-
-- '6.9': |
-   This is an upgrade for Gist.vim: fixed few bugs.
-
-- '6.8': |
-   This is an upgrade for Gist.vim: changed authentication. removed password authentication. if you want to keep using password authentication, let gist_use_password_in_gitconfig to 1.
-
-- '6.7': |
-   This is an upgrade for Gist.vim: fix behavior of g:gist_browser_command = ':OpenBrowser %URL%'.
-
-- '6.6': |
-   This is an upgrade for Gist.vim: fixed detecting filetype.
-
-- '6.5': |
-   This is an upgrade for Gist.vim: use webapi namespace. NOTE: please upgrade webapi-vim also.
-
-- '6.4': |
-   This is an upgrade for Gist.vim: fixed updating with description.
-
-- '6.3': |
-   This is an upgrade for Gist.vim: fixed typos.
-
-- '6.2': |
-   This is an upgrade for Gist.vim: fixed some bugs.
-
-- '6.1': |
-   This is an upgrade for Gist.vim: fixed opening browser.
-
-- '6.0': |
-   This is an upgrade for Gist.vim: changed to use github APIs. Note to remove cookies directory if you used.
-
-- '5.9': |
-   This is an upgrade for Gist.vim: add support anonymous post. fixed many bugs.
-
-- '5.8': |
-   This is an upgrade for Gist.vim: add support for description. you can post description using -s option.
-
-- '5.7': |
-   This is an upgrade for Gist.vim: post with filetype more cleverly.
-
-- '5.6': |
-   This is an upgrade for Gist.vim: fix '--abandon'.
-
-- '5.5': |
-   This is an upgrade for Gist.vim: fix: forgot to upload autoload/gist.vim.
-
-- '5.4': |
-   This is an upgrade for Gist.vim: fix: does not work correctly with blockwize selection.
-
-- '5.3': |
-   This is an upgrade for Gist.vim: upd: support autoload.
-
-- '5.2': |
-   This is an upgrade for Gist.vim: add: support block-wise selection.
-
-- '5.1': |
-   This is an upgrade for Gist.vim: fix: can't update privates.
-
-- '5.0': |
-   This is an upgrade for Gist.vim: follow update of gist.github.com
-
-- '4.9': |
-    fix: don't add new line after "Done: xxx".
-    fix: show WHY FAILED' when failed to post.
-    add: support for :OpenBrowser.
-    add: new option 'gist_curl_options'.
-
-- '4.8': |
-   This is an upgrade for Gist.vim: fix: can't open private gist with ":Gist XXXXX".
-
-- '4.7': |
-   This is an upgrade for Gist.vim: fix: filetype detection.
-
-- '4.6': |
-   This is an upgrade for Gist.vim: fix: strange cookies folder.
-
-- '4.5': |
-   This is an upgrade for Gist.vim: fix: use gist_clip_command for copying URL to clipboard. this fix strange behavior on Mac OSX.
-
-- '4.4': |
-   This is an upgrade for Gist.vim: fix: gist is now only using https.
-
-- '4.3': |
-   This is an upgrade for Gist.vim: add new option '-f' for fork.
-
-- '4.2': |
-   This is an upgrade for Gist.vim: fixed code for login.
-
-- '4.1': |
-   This is an upgrade for Gist.vim: fixed code cleanup.
-
-- '4.0': |
-   This is an upgrade for Gist.vim: fixed deleting gist, listing privates.
-
-- '3.9': |
-   This is an upgrade for Gist.vim: fixed :w handler in gist buffer.
-
-- '3.8': |
-   This is an upgrade for Gist.vim: 'more...' on gist list.
-
-- '3.7': |
-   This is an upgrade for Gist.vim: fix problem that break "gist list" window at twice.
-
-- '3.6': |
-   This is an upgrade for Gist.vim: fix filetype detection for 'vimscript'.
-
-- '3.5': |
-   This is an upgrade for Gist.vim: fix filetype detection.
-
-- '3.4': |
-   This is an upgrade for Gist.vim: use '+' register on unix only if built with 'xterm_clipboard'. and some bug fixes.
-
-- '3.3': |
-   This is an upgrade for Gist.vim: fix problem that append empty line when getting gist.
-
-- '3.2': |
-   This is an upgrade for Gist.vim: added Gist header to recognize the gist. added script type header for Vimana.
-
-- '3.1': |
-   This is an upgrade for Gist.vim: fix checking redirect url.
-
-- '3.0': |
-   This is an upgrade for Gist.vim: fix for official changes(private button name was changed).
-
-- '2.9': |
-   This is an upgrade for Gist.vim: fix for official changes(private button name was changed).
-
-- '2.8': |
-   This is an upgrade for Gist.vim: be able to post multi buffer. currently updating or showing not supported. and ':Gist -d' delete the gist.
-
-- '2.7': |
-   This is an upgrade for Gist.vim: be able to write the gist to local file with ':w foo.txt'.
-
-- '2.6': |
-   This is an upgrade for Gist.vim: fixed problem that does not work 'Gist XXXX'.
-
-- '2.5': |
-   This is an upgrade for Gist.vim: use existing buffer when open the list or gist.
-
-- '2.4': |
-   This is an upgrade for Gist.vim: show error message when no any github settings.
-
-- '2.3': |
-   This is an upgrade for Gist.vim: added :w BufWriteCmd for GistUpdate.
-
-- '2.2': |
-   This is an upgrade for Gist.vim: fixed a bug for anonymous post. and new option '-a' for anonymous post.
-
-- '2.1': |
-   This is an upgrade for Gist.vim: support changing gist filename.
-
-- '2.0': |
-   This is an upgrade for Gist.vim: bugfix for listing gists in specified user.
-
-- '1.9': |
-   This is an upgrade for Gist.vim: added support editing the gist. and bits bug fix.
-
-- '1.8': |
-   This is an upgrade for Gist.vim: added new option g:gist_open_browser_after_post/g:gist_browser_command to open posted gist.
-
-- '1.7': |
-   This is an upgrade for Gist.vim: now changed argument for putting clipboard as ':Gist -c XXXXX'.
-
-- '1.6': |
-   This is an upgrade for Gist.vim: add gist's author in gist list.
-
-- '1.5': |
-   This is an upgrade for Gist.vim: oops. bugfix for auto-detection.
-
-- '1.4': |
-   This is an upgrade for Gist.vim: bugfix for auto-detection.
-
-- '1.3': |
-   This is an upgrade for Gist.vim: more auto-detection for filetype.
-
-- '1.2': |
-   This is an upgrade for Gist.vim: added new option for detect filetype from filename.
-
-- '1.1': |
-   This is an upgrade for Gist.vim: calling StdinReadPost.
-
-- '1.0': |
-   This is an upgrade for Gist.vim: treat literal "-" as part of username.
-
-- '0.9': |
-   This is an upgrade for Gist.vim: added new option 'g:gist_clip_command' that copy the gist code.
-
-# __END__
-# vim: filetype=yaml
diff --git a/sources_non_forked/gist-vim/plugin/gist.vim b/sources_non_forked/gist-vim/plugin/gist.vim
deleted file mode 100644
index 4aa674d..0000000
--- a/sources_non_forked/gist-vim/plugin/gist.vim
+++ /dev/null
@@ -1,23 +0,0 @@
-"=============================================================================
-" File: gist.vim
-" Author: Yasuhiro Matsumoto <mattn.jp@gmail.com>
-" WebPage: http://github.com/mattn/gist-vim
-" License: BSD
-" GetLatestVimScripts: 2423 1 :AutoInstall: gist.vim
-" script type: plugin
-
-if &compatible || (exists('g:loaded_gist_vim') && g:loaded_gist_vim)
-  finish
-endif
-let g:loaded_gist_vim = 1
-
-function! s:CompleteArgs(arg_lead,cmdline,cursor_pos)
-    return filter(copy(["-p", "-P", "-a", "-m", "-e", "-s", "-d", "+1", "-1", "-f", "-c", "-l", "-la", "-ls", "-b",
-                \ "--listall", "--liststar", "--list", "--multibuffer", "--private", "--public", "--anonymous", "--description", "--clipboard",
-                \ "--rawurl", "--delete", "--edit", "--star", "--unstar", "--fork", "--browser"
-                \ ]), 'stridx(v:val, a:arg_lead)==0')
-endfunction
-
-command! -nargs=? -range=% -bang -complete=customlist,s:CompleteArgs Gist :call gist#Gist(<count>, "<bang>", <line1>, <line2>, <f-args>)
-
-" vim:set et:
diff --git a/sources_non_forked/goyo.vim/autoload/goyo.vim b/sources_non_forked/goyo.vim/autoload/goyo.vim
deleted file mode 100644
index 0593f78..0000000
--- a/sources_non_forked/goyo.vim/autoload/goyo.vim
+++ /dev/null
@@ -1,447 +0,0 @@
-" Copyright (c) 2015 Junegunn Choi
-"
-" MIT License
-"
-" Permission is hereby granted, free of charge, to any person obtaining
-" a copy of this software and associated documentation files (the
-" "Software"), to deal in the Software without restriction, including
-" without limitation the rights to use, copy, modify, merge, publish,
-" distribute, sublicense, and/or sell copies of the Software, and to
-" permit persons to whom the Software is furnished to do so, subject to
-" the following conditions:
-"
-" The above copyright notice and this permission notice shall be
-" included in all copies or substantial portions of the Software.
-"
-" THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-" EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-" MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
-" NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
-" LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
-" OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
-" WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-
-let s:cpo_save = &cpo
-set cpo&vim
-
-function! s:const(val, min, max)
-  return min([max([a:val, a:min]), a:max])
-endfunction
-
-function! s:get_color(group, attr)
-  return synIDattr(synIDtrans(hlID(a:group)), a:attr)
-endfunction
-
-function! s:set_color(group, attr, color)
-  let gui = has('gui_running') || has('termguicolors') && &termguicolors
-  execute printf('hi %s %s%s=%s', a:group, gui ? 'gui' : 'cterm', a:attr, a:color)
-endfunction
-
-function! s:blank(repel)
-  if bufwinnr(t:goyo_pads.r) <= bufwinnr(t:goyo_pads.l) + 1
-    \ || bufwinnr(t:goyo_pads.b) <= bufwinnr(t:goyo_pads.t) + 3
-    call s:goyo_off()
-  endif
-  execute 'wincmd' a:repel
-endfunction
-
-function! s:init_pad(command)
-  execute a:command
-
-  setlocal buftype=nofile bufhidden=wipe nomodifiable nobuflisted noswapfile
-      \ nonu nocursorline nocursorcolumn winfixwidth winfixheight statusline=\ 
-  if exists('&rnu')
-    setlocal nornu
-  endif
-  if exists('&colorcolumn')
-    setlocal colorcolumn=
-  endif
-  let bufnr = winbufnr(0)
-
-  execute winnr('#') . 'wincmd w'
-  return bufnr
-endfunction
-
-function! s:setup_pad(bufnr, vert, size, repel)
-  let win = bufwinnr(a:bufnr)
-  execute win . 'wincmd w'
-  execute (a:vert ? 'vertical ' : '') . 'resize ' . max([0, a:size])
-  augroup goyop
-    execute 'autocmd WinEnter,CursorMoved <buffer> nested call s:blank("'.a:repel.'")'
-    autocmd WinLeave <buffer> call s:hide_statusline()
-  augroup END
-
-  " To hide scrollbars of pad windows in GVim
-  let diff = winheight(0) - line('$') - (has('gui_running') ? 2 : 0)
-  if diff > 0
-    setlocal modifiable
-    call append(0, map(range(1, diff), '""'))
-    normal! gg
-    setlocal nomodifiable
-  endif
-  execute winnr('#') . 'wincmd w'
-endfunction
-
-function! s:resize_pads()
-  augroup goyop
-    autocmd!
-  augroup END
-
-  let t:goyo_dim.width = s:const(t:goyo_dim.width, 2, &columns)
-  let t:goyo_dim.height = s:const(t:goyo_dim.height, 2, &lines)
-
-  let vmargin = max([0, (&lines - t:goyo_dim.height) / 2 - 1])
-  let yoff = s:const(t:goyo_dim.yoff, - vmargin, vmargin)
-  let top = vmargin + yoff
-  let bot = vmargin - yoff - 1
-  call s:setup_pad(t:goyo_pads.t, 0, top, 'j')
-  call s:setup_pad(t:goyo_pads.b, 0, bot, 'k')
-
-  let nwidth  = max([len(string(line('$'))) + 1, &numberwidth])
-  let width   = t:goyo_dim.width + (&number ? nwidth : 0)
-  let hmargin = max([0, (&columns - width) / 2 - 1])
-  let xoff    = s:const(t:goyo_dim.xoff, - hmargin, hmargin)
-  call s:setup_pad(t:goyo_pads.l, 1, hmargin + xoff, 'l')
-  call s:setup_pad(t:goyo_pads.r, 1, hmargin - xoff, 'h')
-endfunction
-
-function! s:tranquilize()
-  let bg = s:get_color('Normal', 'bg#')
-  for grp in ['NonText', 'FoldColumn', 'ColorColumn', 'VertSplit',
-            \ 'StatusLine', 'StatusLineNC', 'SignColumn']
-    " -1 on Vim / '' on GVim
-    if bg == -1 || empty(bg)
-      call s:set_color(grp, 'fg', get(g:, 'goyo_bg', 'black'))
-      call s:set_color(grp, 'bg', 'NONE')
-    else
-      call s:set_color(grp, 'fg', bg)
-      call s:set_color(grp, 'bg', bg)
-    endif
-    call s:set_color(grp, '', 'NONE')
-  endfor
-endfunction
-
-function! s:hide_statusline()
-  setlocal statusline=\ 
-endfunction
-
-function! s:hide_linenr()
-  if !get(g:, 'goyo_linenr', 0)
-    setlocal nonu
-    if exists('&rnu')
-      setlocal nornu
-    endif
-  endif
-  if exists('&colorcolumn')
-    setlocal colorcolumn=
-  endif
-endfunction
-
-function! s:maps_nop()
-  let mapped = filter(['R', 'H', 'J', 'K', 'L', '|', '_'],
-                    \ "empty(maparg(\"\<c-w>\".v:val, 'n'))")
-  for c in mapped
-    execute 'nnoremap <c-w>'.escape(c, '|').' <nop>'
-  endfor
-  return mapped
-endfunction
-
-function! s:maps_resize()
-  let commands = {
-  \ '=': ':<c-u>let t:goyo_dim = <sid>parse_arg(t:goyo_dim_expr) <bar> call <sid>resize_pads()<cr>',
-  \ '>': ':<c-u>let t:goyo_dim.width = winwidth(0) + 2 * v:count1 <bar> call <sid>resize_pads()<cr>',
-  \ '<': ':<c-u>let t:goyo_dim.width = winwidth(0) - 2 * v:count1 <bar> call <sid>resize_pads()<cr>',
-  \ '+': ':<c-u>let t:goyo_dim.height += 2 * v:count1 <bar> call <sid>resize_pads()<cr>',
-  \ '-': ':<c-u>let t:goyo_dim.height -= 2 * v:count1 <bar> call <sid>resize_pads()<cr>'
-  \ }
-  let mapped = filter(keys(commands), "empty(maparg(\"\<c-w>\".v:val, 'n'))")
-  for c in mapped
-    execute 'nnoremap <silent> <c-w>'.c.' '.commands[c]
-  endfor
-  return mapped
-endfunction
-
-nnoremap <silent> <plug>(goyo-resize) :<c-u>call <sid>resize_pads()<cr>
-
-function! s:goyo_on(dim)
-  let dim = s:parse_arg(a:dim)
-  if empty(dim)
-    return
-  endif
-
-  let s:orig_tab = tabpagenr()
-  let settings =
-    \ { 'laststatus':    &laststatus,
-    \   'showtabline':   &showtabline,
-    \   'fillchars':     &fillchars,
-    \   'winminwidth':   &winminwidth,
-    \   'winwidth':      &winwidth,
-    \   'winminheight':  &winminheight,
-    \   'winheight':     &winheight,
-    \   'ruler':         &ruler,
-    \   'sidescroll':    &sidescroll,
-    \   'sidescrolloff': &sidescrolloff
-    \ }
-
-  " New tab
-  tab split
-
-  let t:goyo_master = winbufnr(0)
-  let t:goyo_dim = dim
-  let t:goyo_dim_expr = a:dim
-  let t:goyo_pads = {}
-  let t:goyo_revert = settings
-  let t:goyo_maps = extend(s:maps_nop(), s:maps_resize())
-  if has('gui_running')
-    let t:goyo_revert.guioptions = &guioptions
-  endif
-
-  " vim-gitgutter
-  let t:goyo_disabled_gitgutter = get(g:, 'gitgutter_enabled', 0)
-  if t:goyo_disabled_gitgutter
-    silent! GitGutterDisable
-  endif
-
-  " vim-signify
-  let t:goyo_disabled_signify = !empty(getbufvar(bufnr(''), 'sy'))
-  if t:goyo_disabled_signify
-    SignifyToggle
-  endif
-
-  " vim-airline
-  let t:goyo_disabled_airline = exists('#airline')
-  if t:goyo_disabled_airline
-    AirlineToggle
-  endif
-
-  " vim-powerline
-  let t:goyo_disabled_powerline = exists('#PowerlineMain')
-  if t:goyo_disabled_powerline
-    augroup PowerlineMain
-      autocmd!
-    augroup END
-    augroup! PowerlineMain
-  endif
-
-  " lightline.vim
-  let t:goyo_disabled_lightline = exists('#lightline')
-  if t:goyo_disabled_lightline
-    silent! call lightline#disable()
-  endif
-
-  call s:hide_linenr()
-  " Global options
-  let &winheight = max([&winminheight, 1])
-  set winminheight=1
-  set winheight=1
-  set winminwidth=1 winwidth=1
-  set laststatus=0
-  set showtabline=0
-  set noruler
-  set fillchars+=vert:\ 
-  set fillchars+=stl:\ 
-  set fillchars+=stlnc:\ 
-  set sidescroll=1
-  set sidescrolloff=0
-
-  " Hide left-hand scrollbars
-  if has('gui_running')
-    set guioptions-=l
-    set guioptions-=L
-  endif
-
-  let t:goyo_pads.l = s:init_pad('vertical topleft new')
-  let t:goyo_pads.r = s:init_pad('vertical botright new')
-  let t:goyo_pads.t = s:init_pad('topleft new')
-  let t:goyo_pads.b = s:init_pad('botright new')
-
-  call s:resize_pads()
-  call s:tranquilize()
-
-  augroup goyo
-    autocmd!
-    autocmd TabLeave    * nested call s:goyo_off()
-    autocmd VimResized  *        call s:resize_pads()
-    autocmd ColorScheme *        call s:tranquilize()
-    autocmd BufWinEnter *        call s:hide_linenr() | call s:hide_statusline()
-    autocmd WinEnter,WinLeave *  call s:hide_statusline()
-    if has('nvim')
-      autocmd TermClose * call feedkeys("\<plug>(goyo-resize)")
-    endif
-  augroup END
-
-  call s:hide_statusline()
-  if exists('g:goyo_callbacks[0]')
-    call g:goyo_callbacks[0]()
-  endif
-  if exists('#User#GoyoEnter')
-    doautocmd User GoyoEnter
-  endif
-endfunction
-
-function! s:goyo_off()
-  if !exists('#goyo')
-    return
-  endif
-
-  " Oops, not this tab
-  if !exists('t:goyo_revert')
-    return
-  endif
-
-  " Clear auto commands
-  augroup goyo
-    autocmd!
-  augroup END
-  augroup! goyo
-  augroup goyop
-    autocmd!
-  augroup END
-  augroup! goyop
-
-  for c in t:goyo_maps
-    execute 'nunmap <c-w>'.escape(c, '|')
-  endfor
-
-  let goyo_revert             = t:goyo_revert
-  let goyo_disabled_gitgutter = t:goyo_disabled_gitgutter
-  let goyo_disabled_signify   = t:goyo_disabled_signify
-  let goyo_disabled_airline   = t:goyo_disabled_airline
-  let goyo_disabled_powerline = t:goyo_disabled_powerline
-  let goyo_disabled_lightline = t:goyo_disabled_lightline
-  let goyo_orig_buffer        = t:goyo_master
-  let [line, col]             = [line('.'), col('.')]
-
-  if tabpagenr() == 1
-    tabnew
-    normal! gt
-    bd
-  endif
-  tabclose
-  execute 'normal! '.s:orig_tab.'gt'
-  if winbufnr(0) == goyo_orig_buffer
-    " Doesn't work if window closed with `q`
-    execute printf('normal! %dG%d|', line, col)
-  endif
-
-  let wmw = remove(goyo_revert, 'winminwidth')
-  let ww  = remove(goyo_revert, 'winwidth')
-  let &winwidth     = ww
-  let &winminwidth  = wmw
-  let wmh = remove(goyo_revert, 'winminheight')
-  let wh  = remove(goyo_revert, 'winheight')
-  let &winheight    = max([wmh, 1])
-  let &winminheight = wmh
-  let &winheight    = wh
-
-  for [k, v] in items(goyo_revert)
-    execute printf('let &%s = %s', k, string(v))
-  endfor
-  execute 'colo '. get(g:, 'colors_name', 'default')
-
-  if goyo_disabled_gitgutter
-    silent! GitGutterEnable
-  endif
-
-  if goyo_disabled_signify
-    silent! if !b:sy.active
-      SignifyToggle
-    endif
-  endif
-
-  if goyo_disabled_airline && !exists('#airline')
-    AirlineToggle
-    " For some reason, Airline requires two refreshes to avoid display
-    " artifacts
-    silent! AirlineRefresh
-    silent! AirlineRefresh
-  endif
-
-  if goyo_disabled_powerline && !exists('#PowerlineMain')
-    doautocmd PowerlineStartup VimEnter
-    silent! PowerlineReloadColorscheme
-  endif
-
-  if goyo_disabled_lightline
-    silent! call lightline#enable()
-  endif
-
-  if exists('#Powerline')
-    doautocmd Powerline ColorScheme
-  endif
-
-  if exists('g:goyo_callbacks[1]')
-    call g:goyo_callbacks[1]()
-  endif
-  if exists('#User#GoyoLeave')
-    doautocmd User GoyoLeave
-  endif
-endfunction
-
-function! s:relsz(expr, limit)
-  if a:expr !~ '%$'
-    return str2nr(a:expr)
-  endif
-  return a:limit * str2nr(a:expr[:-2]) / 100
-endfunction
-
-function! s:parse_arg(arg)
-  if exists('g:goyo_height') || !exists('g:goyo_margin_top') && !exists('g:goyo_margin_bottom')
-    let height = s:relsz(get(g:, 'goyo_height', '85%'), &lines)
-    let yoff = 0
-  else
-    let top = max([0, s:relsz(get(g:, 'goyo_margin_top', 4), &lines)])
-    let bot = max([0, s:relsz(get(g:, 'goyo_margin_bottom', 4), &lines)])
-    let height = &lines - top - bot
-    let yoff = top - bot
-  endif
-
-  let dim = { 'width':  s:relsz(get(g:, 'goyo_width', 80), &columns),
-            \ 'height': height,
-            \ 'xoff':   0,
-            \ 'yoff':   yoff }
-  if empty(a:arg)
-    return dim
-  endif
-  let parts = matchlist(a:arg, '^\s*\([0-9]\+%\?\)\?\([+-][0-9]\+%\?\)\?\%(x\([0-9]\+%\?\)\?\([+-][0-9]\+%\?\)\?\)\?\s*$')
-  if empty(parts)
-    echohl WarningMsg
-    echo 'Invalid dimension expression: '.a:arg
-    echohl None
-    return {}
-  endif
-  if !empty(parts[1]) | let dim.width  = s:relsz(parts[1], &columns) | endif
-  if !empty(parts[2]) | let dim.xoff   = s:relsz(parts[2], &columns) | endif
-  if !empty(parts[3]) | let dim.height = s:relsz(parts[3], &lines)   | endif
-  if !empty(parts[4]) | let dim.yoff   = s:relsz(parts[4], &lines)   | endif
-  return dim
-endfunction
-
-function! goyo#execute(bang, dim)
-  if a:bang
-    if exists('#goyo')
-      call s:goyo_off()
-    endif
-  else
-    if exists('#goyo') == 0
-      call s:goyo_on(a:dim)
-    elseif !empty(a:dim)
-      if winnr('$') < 5
-        call s:goyo_off()
-        return goyo#execute(a:bang, a:dim)
-      endif
-      let dim = s:parse_arg(a:dim)
-      if !empty(dim)
-        let t:goyo_dim = dim
-        let t:goyo_dim_expr = a:dim
-        call s:resize_pads()
-      endif
-    else
-      call s:goyo_off()
-    end
-  end
-endfunction
-
-let &cpo = s:cpo_save
-unlet s:cpo_save
-
diff --git a/sources_non_forked/goyo.vim/doc/goyo.txt b/sources_non_forked/goyo.vim/doc/goyo.txt
deleted file mode 100644
index b805022..0000000
--- a/sources_non_forked/goyo.vim/doc/goyo.txt
+++ /dev/null
@@ -1,170 +0,0 @@
-*goyo.txt*	goyo	Last change: April 2 2017
-GOYO - TABLE OF CONTENTS                                         *goyo* *goyo-toc*
-==============================================================================
-
-  goyo.vim ()
-    Installation
-    Usage
-      Dimension expression
-    Configuration
-      Callbacks
-    Inspiration
-    Pros.
-    License
-
-GOYO.VIM ()                                                         *goyo-vim*
-==============================================================================
-
-Distraction-free writing in Vim.
-
-https://raw.github.com/junegunn/i/master/goyo.png
-
-(Color scheme: {seoul256}{1})
-
-Best served with {limelight.vim}{2}.
-
-                                 {1} https://github.com/junegunn/seoul256.vim
-                                 {2} https://github.com/junegunn/limelight.vim
-
-
-INSTALLATION                                                 *goyo-installation*
-==============================================================================
-
-Use your favorite plugin manager.
-
-                                                                  *:PlugInstall*
-
- - {vim-plug}{3}
-   1. Add `Plug'junegunn/goyo.vim'` to .vimrc
-   2. Run `:PlugInstall`
-
-                                      {3} https://github.com/junegunn/vim-plug
-
-
-USAGE                                                               *goyo-usage*
-==============================================================================
-
-                                                                         *:Goyo*
-
- - `:Goyo`
-   - Toggle Goyo
- - `:Goyo[dimension]`
-   - Turn on or resize Goyo
- - `:Goyo!`
-   - Turn Goyo off
-
-The window can be resized with the usual [count]`CTRL-W` + `>`, `<`, `+`, `-` keys,
-and `CTRL-W` + `=` will resize it back to the initial size.
-
-
-< Dimension expression >______________________________________________________~
-                                                     *goyo-dimension-expression*
-
-The expected format of a dimension expression is
-`[WIDTH][XOFFSET][x[HEIGHT][YOFFSET]]`. `XOFFSET` and `YOFFSET` should be
-prefixed by `+` or `-`. Each component can be given in percentage.
->
-    " Width
-    Goyo 120
-
-    " Height
-    Goyo x30
-
-    " Both
-    Goyo 120x30
-
-    " In percentage
-    Goyo 120x50%
-
-    " With offsets
-    Goyo 50%+25%x50%-25%
-<
-
-CONFIGURATION                                               *goyo-configuration*
-==============================================================================
-
-                                      *g:goyo_width* *g:goyo_height* *g:goyo_linenr*
-
- - `g:goyo_width` (default: 80)
- - `g:goyo_height` (default: 85%)
- - `g:goyo_linenr` (default: 0)
-
-
-< Callbacks >_________________________________________________________________~
-                                                                *goyo-callbacks*
-
-By default, {vim-airline}{4}, {vim-powerline}{5}, {powerline}{6},
-{lightline.vim}{7}, {vim-signify}{8}, and {vim-gitgutter}{9} are temporarily
-disabled while in Goyo mode.
-
-If you have other plugins that you want to disable/enable, or if you want to
-change the default settings of Goyo window, you can set up custom routines to
-be triggered on `GoyoEnter` and `GoyoLeave` events.
->
-    function! s:goyo_enter()
-      silent !tmux set status off
-      silent !tmux list-panes -F '\#F' | grep -q Z || tmux resize-pane -Z
-      set noshowmode
-      set noshowcmd
-      set scrolloff=999
-      Limelight
-      " ...
-    endfunction
-
-    function! s:goyo_leave()
-      silent !tmux set status on
-      silent !tmux list-panes -F '\#F' | grep -q Z && tmux resize-pane -Z
-      set showmode
-      set showcmd
-      set scrolloff=5
-      Limelight!
-      " ...
-    endfunction
-
-    autocmd! User GoyoEnter nested call <SID>goyo_enter()
-    autocmd! User GoyoLeave nested call <SID>goyo_leave()
-<
-More examples can be found here: {Customization}{10}
-
-                  {4} https://github.com/bling/vim-airline
-                  {5} https://github.com/Lokaltog/vim-powerline
-                  {6} https://github.com/Lokaltog/powerline
-                  {7} https://github.com/itchyny/lightline.vim
-                  {8} https://github.com/mhinz/vim-signify
-                  {9} https://github.com/airblade/vim-gitgutter
-                  {10} https://github.com/junegunn/goyo.vim/wiki/Customization
-
-
-INSPIRATION                                                   *goyo-inspiration*
-==============================================================================
-
- - {LiteDFM}{11}
- - {VimRoom}{12}
-
-                                    {11} https://github.com/bilalq/lite-dfm
-                                    {12} http://projects.mikewest.org/vimroom/
-
-
-PROS.                                                                *goyo-pros*
-==============================================================================
-
- 1. Works well with splits. Doesn't mess up with the current window arrangement
- 2. Works well with popular statusline plugins
- 3. Prevents accessing the empty windows around the central buffer
- 4. Can be closed with any of `:q[uit]`, `:clo[se]`, `:tabc[lose]`, or `:Goyo`
- 5. Can dynamically change the width of the window
- 6. Adjusts its colors when color scheme is changed
- 7. Realigns the window when the terminal (or window) is resized or when the size
-    of the font is changed
- 8. Correctly hides colorcolumns and Emojis in statusline
- 9. Highly customizable with callbacks
-
-
-LICENSE                                                           *goyo-license*
-==============================================================================
-
-MIT
-
-
-==============================================================================
-vim:tw=78:sw=2:ts=2:ft=help:norl:nowrap:
diff --git a/sources_non_forked/goyo.vim/plugin/goyo.vim b/sources_non_forked/goyo.vim/plugin/goyo.vim
deleted file mode 100644
index af4793a..0000000
--- a/sources_non_forked/goyo.vim/plugin/goyo.vim
+++ /dev/null
@@ -1,24 +0,0 @@
-" Copyright (c) 2015 Junegunn Choi
-"
-" MIT License
-"
-" Permission is hereby granted, free of charge, to any person obtaining
-" a copy of this software and associated documentation files (the
-" "Software"), to deal in the Software without restriction, including
-" without limitation the rights to use, copy, modify, merge, publish,
-" distribute, sublicense, and/or sell copies of the Software, and to
-" permit persons to whom the Software is furnished to do so, subject to
-" the following conditions:
-"
-" The above copyright notice and this permission notice shall be
-" included in all copies or substantial portions of the Software.
-"
-" THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-" EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-" MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
-" NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
-" LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
-" OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
-" WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-
-command! -nargs=? -bar -bang Goyo call goyo#execute(<bang>0, <q-args>)
diff --git a/sources_non_forked/gruvbox/CHANGELOG.md b/sources_non_forked/gruvbox/CHANGELOG.md
deleted file mode 100644
index 90fd3a2..0000000
--- a/sources_non_forked/gruvbox/CHANGELOG.md
+++ /dev/null
@@ -1,117 +0,0 @@
-# Change Log
-
-## [Unreleased](https://github.com/morhetz/gruvbox/tree/HEAD)
-
-[Full Changelog](https://github.com/morhetz/gruvbox/compare/v1.3.5...HEAD)
-
-**Fixed bugs:**
-
-- Lighter background on terminal [\#8](https://github.com/morhetz/gruvbox/issues/8)
-
-**Closed issues:**
-
-- Installation issue. [\#54](https://github.com/morhetz/gruvbox/issues/54)
-
-- Italic font in terminal\(urxvt\) [\#49](https://github.com/morhetz/gruvbox/issues/49)
-
-- Unable to log in when sourcing the palette shellscript [\#48](https://github.com/morhetz/gruvbox/issues/48)
-
-- How can i modify multiple comment scheme [\#46](https://github.com/morhetz/gruvbox/issues/46)
-
-- Remove comment highlight in iterm [\#44](https://github.com/morhetz/gruvbox/issues/44)
-
-- Comments looking strange withing tmux [\#43](https://github.com/morhetz/gruvbox/issues/43)
-
-- comments are reverse-video in xterm [\#41](https://github.com/morhetz/gruvbox/issues/41)
-
-- What font are you using in the screenshots? [\#39](https://github.com/morhetz/gruvbox/issues/39)
-
-- vim-signature crashes when I use gruvbox [\#38](https://github.com/morhetz/gruvbox/issues/38)
-
-- Color of statusbar in inactive windows [\#37](https://github.com/morhetz/gruvbox/issues/37)
-
-- Go method and struct highlighting missing [\#36](https://github.com/morhetz/gruvbox/issues/36)
-
-- gruvbox\_256palette.sh doesn't work for Konsole [\#35](https://github.com/morhetz/gruvbox/issues/35)
-
-- Contrast in jekyll markdown files [\#33](https://github.com/morhetz/gruvbox/issues/33)
-
-- Pentadactyl Gruvbox Theme [\#32](https://github.com/morhetz/gruvbox/issues/32)
-
-- make vertsplit better [\#31](https://github.com/morhetz/gruvbox/issues/31)
-
-- Console support. [\#30](https://github.com/morhetz/gruvbox/issues/30)
-
-- How can I change the background color? [\#29](https://github.com/morhetz/gruvbox/issues/29)
-
-- Some words are not bold [\#28](https://github.com/morhetz/gruvbox/issues/28)
-
-- Terminal theme on base gruvbox [\#25](https://github.com/morhetz/gruvbox/issues/25)
-
-- Markdown has inverted colors when using \* [\#24](https://github.com/morhetz/gruvbox/issues/24)
-
-- how install it on mac osx [\#23](https://github.com/morhetz/gruvbox/issues/23)
-
-- Comments color for Terminal Vim [\#22](https://github.com/morhetz/gruvbox/issues/22)
-
-- Move palette files to gruvbox-generalized [\#20](https://github.com/morhetz/gruvbox/issues/20)
-
-- Maybe add Gruvbox Airline theme? [\#19](https://github.com/morhetz/gruvbox/issues/19)
-
-- For Sublime text [\#18](https://github.com/morhetz/gruvbox/issues/18)
-
-**Merged pull requests:**
-
-- Fix the 256 palette script failed login issue [\#53](https://github.com/morhetz/gruvbox/pull/53) ([jonasmalacofilho](https://github.com/jonasmalacofilho))
-
-- add minimal coloring for gitcommit highlighting [\#52](https://github.com/morhetz/gruvbox/pull/52) ([daniely](https://github.com/daniely))
-
-- For terminals, turn off italics by default. [\#47](https://github.com/morhetz/gruvbox/pull/47) ([ryanmjacobs](https://github.com/ryanmjacobs))
-
-- Change color of vertical/horizontal seperators between split windows [\#45](https://github.com/morhetz/gruvbox/pull/45) ([deshtop](https://github.com/deshtop))
-
-- Improve gruvbox with C code [\#34](https://github.com/morhetz/gruvbox/pull/34) ([gladiac](https://github.com/gladiac))
-
-- Fix for linux console [\#27](https://github.com/morhetz/gruvbox/pull/27) ([vyp](https://github.com/vyp))
-
-- Colors for plugin vimshell.vim [\#21](https://github.com/morhetz/gruvbox/pull/21) ([joelmo](https://github.com/joelmo))
-
-## [v1.3.5](https://github.com/morhetz/gruvbox/tree/v1.3.5) (2014-03-19)
-
-[Full Changelog](https://github.com/morhetz/gruvbox/compare/v0.0.8...v1.3.5)
-
-**Implemented enhancements:**
-
-- Better selection colors [\#15](https://github.com/morhetz/gruvbox/issues/15)
-
-- When hlsearch is on, the cursor inverts the search color and not visible [\#2](https://github.com/morhetz/gruvbox/issues/2)
-
-**Fixed bugs:**
-
-- Problem with changing between dark and light on 256 color terminal [\#7](https://github.com/morhetz/gruvbox/issues/7)
-
-- IndentGuides coloring doesn't show up [\#1](https://github.com/morhetz/gruvbox/issues/1)
-
-**Closed issues:**
-
-- Requesting rxvt-unicode theme [\#17](https://github.com/morhetz/gruvbox/issues/17)
-
-- gruvbox\_256palette.sh gets reset \(gnome-terminal on Ubuntu\) [\#13](https://github.com/morhetz/gruvbox/issues/13)
-
-- Powerline colors [\#12](https://github.com/morhetz/gruvbox/issues/12)
-
-- Info necessary for making a port of this colorscheme [\#10](https://github.com/morhetz/gruvbox/issues/10)
-
-**Merged pull requests:**
-
-- Fix GNU screen detection for \*-bce [\#16](https://github.com/morhetz/gruvbox/pull/16) ([blueyed](https://github.com/blueyed))
-
-- Added iTerm2 dark theme [\#11](https://github.com/morhetz/gruvbox/pull/11) ([Greduan](https://github.com/Greduan))
-
-- Fix typo in Readme [\#5](https://github.com/morhetz/gruvbox/pull/5) ([ViViDboarder](https://github.com/ViViDboarder))
-
-## [v0.0.8](https://github.com/morhetz/gruvbox/tree/v0.0.8) (2012-12-08)
-
-
-
-\* *This Change Log was automatically generated by [github_changelog_generator](https://github.com/skywinder/Github-Changelog-Generator)*
\ No newline at end of file
diff --git a/sources_non_forked/gruvbox/README.md b/sources_non_forked/gruvbox/README.md
deleted file mode 100644
index cd07e48..0000000
--- a/sources_non_forked/gruvbox/README.md
+++ /dev/null
@@ -1,113 +0,0 @@
-<p align="center"><img src="http://svgur.com/i/3Dp.svg"></p>
-
-gruvbox is heavily inspired by [badwolf][], [jellybeans][] and [solarized][].
-
-Designed as a bright theme with pastel 'retro groove' colors and light/dark mode switching in the way of [solarized][]. The main focus when developing gruvbox is to keep colors easily distinguishable, contrast enough and still pleasant for the eyes.
-
-   [badwolf]: https://github.com/sjl/badwolf
-   [jellybeans]: https://github.com/nanotech/jellybeans.vim
-   [solarized]: http://ethanschoonover.com/solarized
-
-Attention
----------
-
-1. [Read this first](https://github.com/morhetz/gruvbox/wiki/Terminal-specific)
-2. Typeface from gallery is [Fantasque Sans Mono](https://github.com/belluzj/fantasque-sans)
-3. Typeface from screenshots below is [Fira Mono](https://mozilla.github.io/Fira/)
-
-Screenshots
------------
-
-Refer [Gallery][] for more syntax-specific screenshots.
-
-   [Gallery]: https://github.com/morhetz/gruvbox/wiki/Gallery
-
-### Dark mode
-
-![Screenshot Dark](http://i.imgur.com/GkIl8Fn.png)
-
-### Light mode
-
-![Screenshot Light](http://i.imgur.com/X75niEa.png)
-
-### Airline theme
-
-![Screenshot Airline](http://i.imgur.com/wRQceUR.png)
-
-Palette
--------
-
-### Dark mode
-
-![Palette Dark](http://i.imgur.com/wa666xg.png)
-
-### Light mode
-
-![Palette Light](http://i.imgur.com/49qKyYW.png)
-
-Contrast options
-----------------
-
-Refer [wiki section][] for contrast configuration and other options.
-
-   [wiki section]: https://github.com/morhetz/gruvbox/wiki/Configuration#ggruvbox_contrast_dark
-
-![Contrast Options](http://i.imgur.com/5MSbe6T.png)
-
-Documentation
--------------
-
-Please check [wiki][] for installation details, terminal-specific setup, troubleshooting, configuration options and others.
-
-   [wiki]: https://github.com/morhetz/gruvbox/wiki
-
-Features
---------
-
-* Lots of style-customization options (contrast, color invertion, italics usage etc.)
-* Extended filetype highlighting: Html, Xml, Vim, Clojure, C, Python, JavaScript, TypeScript, PureScript, CoffeeScript, Ruby, Objective-C, Go, Lua, MoonScript, Java, Markdown, Haskell, Elixir
-* Supported plugins: [EasyMotion][], [vim-sneak][], [Indent Guides][], [indentLine][], [Rainbow Parentheses][], [Airline][], [Lightline][], [GitGutter][], [Signify][], [ShowMarks][], [Signature][], [Syntastic][], [Ale][], [CtrlP][], [Startify][], [NERDTree][], [Dirvish][]
-
-   [EasyMotion]: https://github.com/Lokaltog/vim-easymotion
-   [vim-sneak]: https://github.com/justinmk/vim-sneak
-   [Indent Guides]: https://github.com/nathanaelkane/vim-indent-guides
-   [indentLine]: https://github.com/Yggdroot/indentLine
-   [Rainbow Parentheses]: https://github.com/kien/rainbow_parentheses.vim
-   [Airline]: https://github.com/bling/vim-airline
-   [Lightline]: https://github.com/itchyny/lightline.vim
-   [GitGutter]: https://github.com/airblade/vim-gitgutter
-   [Signify]: https://github.com/mhinz/vim-signify
-   [ShowMarks]: http://www.vim.org/scripts/script.php?script_id=152
-   [Signature]: https://github.com/kshenoy/vim-signature
-   [Syntastic]: https://github.com/scrooloose/syntastic
-   [Ale]: https://github.com/w0rp/ale
-   [CtrlP]: https://github.com/kien/ctrlp.vim
-   [Startify]: https://github.com/mhinz/vim-startify
-   [NERDTree]: https://github.com/scrooloose/nerdtree
-   [Dirvish]: https://github.com/justinmk/vim-dirvish
-
-Contributions
--------------
-
-See [gruvbox-contrib][] repo for contributions, ports and extras.
-
-[gruvbox-contrib]: https://github.com/morhetz/gruvbox-contrib
-
-ToDo
-----
-
-* Filetype syntax highlighting (R, TeX, Swift, Erlang)
-* Plugin support (Tagbar, VimPlug)
-
-Self-Promotion
---------------
-
-If you like gruvbox follow the repository on
-[GitHub](https://github.com/morhetz/gruvbox) and vote for it on
-[vim.org](http://www.vim.org/scripts/script.php?script_id=4349).
-
-License
--------
-[MIT/X11][]
-
-   [MIT/X11]: https://en.wikipedia.org/wiki/MIT_License
diff --git a/sources_non_forked/gruvbox/autoload/airline/themes/gruvbox.vim b/sources_non_forked/gruvbox/autoload/airline/themes/gruvbox.vim
deleted file mode 100644
index 6862a81..0000000
--- a/sources_non_forked/gruvbox/autoload/airline/themes/gruvbox.vim
+++ /dev/null
@@ -1,79 +0,0 @@
-" -----------------------------------------------------------------------------
-" File: gruvbox.vim
-" Description: Retro groove color scheme for Airline
-" Author: morhetz <morhetz@gmail.com>
-" Source: https://github.com/morhetz/gruvbox
-" Last Modified: 12 Aug 2017
-" -----------------------------------------------------------------------------
-
-let g:airline#themes#gruvbox#palette = {}
-
-function! airline#themes#gruvbox#refresh()
-
-  let M0 = airline#themes#get_highlight('Identifier')
-  let accents_group = airline#themes#get_highlight('Special')
-  let modified_group = [M0[0], '', M0[2], '', '']
-  let warning_group = airline#themes#get_highlight2(['Normal', 'bg'], ['Question', 'fg'])
-  let error_group = airline#themes#get_highlight2(['Normal', 'bg'], ['WarningMsg', 'fg'])
-
-  let s:N1 = airline#themes#get_highlight2(['Normal', 'bg'], ['StatusLineNC', 'bg'])
-  let s:N2 = airline#themes#get_highlight2(['StatusLineNC', 'bg'], ['Pmenu', 'bg'])
-  let s:N3 = airline#themes#get_highlight2(['StatusLineNC', 'bg'], ['CursorLine', 'bg'])
-  let g:airline#themes#gruvbox#palette.normal = airline#themes#generate_color_map(s:N1, s:N2, s:N3)
-  let g:airline#themes#gruvbox#palette.normal_modified = { 'airline_c': modified_group }
-  let g:airline#themes#gruvbox#palette.normal.airline_warning = warning_group
-  let g:airline#themes#gruvbox#palette.normal_modified.airline_warning = warning_group
-  let g:airline#themes#gruvbox#palette.normal.airline_error = error_group
-  let g:airline#themes#gruvbox#palette.normal_modified.airline_error = error_group
-
-  let s:I1 = airline#themes#get_highlight2(['Normal', 'bg'], ['Identifier', 'fg'])
-  let s:I2 = s:N2
-  let s:I3 = airline#themes#get_highlight2(['Normal', 'fg'], ['Pmenu', 'bg'])
-  let g:airline#themes#gruvbox#palette.insert = airline#themes#generate_color_map(s:I1, s:I2, s:I3)
-  let g:airline#themes#gruvbox#palette.insert_modified = g:airline#themes#gruvbox#palette.normal_modified
-  let g:airline#themes#gruvbox#palette.insert.airline_warning = g:airline#themes#gruvbox#palette.normal.airline_warning
-  let g:airline#themes#gruvbox#palette.insert_modified.airline_warning = g:airline#themes#gruvbox#palette.normal_modified.airline_warning
-  let g:airline#themes#gruvbox#palette.insert.airline_error = g:airline#themes#gruvbox#palette.normal.airline_error
-  let g:airline#themes#gruvbox#palette.insert_modified.airline_error = g:airline#themes#gruvbox#palette.normal_modified.airline_error
-
-  let s:R1 = airline#themes#get_highlight2(['Normal', 'bg'], ['Structure', 'fg'])
-  let s:R2 = s:I2
-  let s:R3 = s:I3
-  let g:airline#themes#gruvbox#palette.replace = airline#themes#generate_color_map(s:R1, s:R2, s:R3)
-  let g:airline#themes#gruvbox#palette.replace_modified = g:airline#themes#gruvbox#palette.normal_modified
-  let g:airline#themes#gruvbox#palette.replace.airline_warning = g:airline#themes#gruvbox#palette.normal.airline_warning
-  let g:airline#themes#gruvbox#palette.replace_modified.airline_warning = g:airline#themes#gruvbox#palette.normal_modified.airline_warning
-  let g:airline#themes#gruvbox#palette.replace.airline_error = g:airline#themes#gruvbox#palette.normal.airline_error
-  let g:airline#themes#gruvbox#palette.replace_modified.airline_error = g:airline#themes#gruvbox#palette.normal_modified.airline_error
-
-  let s:V1 = airline#themes#get_highlight2(['Normal', 'bg'], ['Question', 'fg'])
-  let s:V2 = s:N2
-  let s:V3 = airline#themes#get_highlight2(['Normal', 'bg'], ['TabLine', 'fg'])
-  let g:airline#themes#gruvbox#palette.visual = airline#themes#generate_color_map(s:V1, s:V2, s:V3)
-  let g:airline#themes#gruvbox#palette.visual_modified = { 'airline_c': [ s:V3[0], '', s:V3[2], '', '' ] }
-  let g:airline#themes#gruvbox#palette.visual.airline_warning = g:airline#themes#gruvbox#palette.normal.airline_warning
-  let g:airline#themes#gruvbox#palette.visual_modified.airline_warning = g:airline#themes#gruvbox#palette.normal_modified.airline_warning
-  let g:airline#themes#gruvbox#palette.visual.airline_error = g:airline#themes#gruvbox#palette.normal.airline_error
-  let g:airline#themes#gruvbox#palette.visual_modified.airline_error = g:airline#themes#gruvbox#palette.normal_modified.airline_error
-
-  let s:IA = airline#themes#get_highlight2(['TabLine', 'fg'], ['CursorLine', 'bg'])
-  let g:airline#themes#gruvbox#palette.inactive = airline#themes#generate_color_map(s:IA, s:IA, s:IA)
-  let g:airline#themes#gruvbox#palette.inactive_modified = { 'airline_c': modified_group }
-
-  let g:airline#themes#gruvbox#palette.accents = { 'red': accents_group }
-
-  let s:TF = airline#themes#get_highlight2(['Normal', 'bg'], ['Normal', 'bg'])
-  let g:airline#themes#gruvbox#palette.tabline = {
-    \ 'airline_tab':  s:N2,
-    \ 'airline_tabsel':  s:N1,
-    \ 'airline_tabtype':  s:V1,
-    \ 'airline_tabfill':  s:TF,
-    \ 'airline_tabhid':  s:IA,
-    \ 'airline_tabmod':  s:I1
-    \ }
-
-endfunction
-
-call airline#themes#gruvbox#refresh()
-
-" vim: set sw=2 ts=2 sts=2 et tw=80 ft=vim fdm=marker:
diff --git a/sources_non_forked/gruvbox/autoload/gruvbox.vim b/sources_non_forked/gruvbox/autoload/gruvbox.vim
deleted file mode 100644
index 44bec6e..0000000
--- a/sources_non_forked/gruvbox/autoload/gruvbox.vim
+++ /dev/null
@@ -1,41 +0,0 @@
-" -----------------------------------------------------------------------------
-" File: gruvbox.vim
-" Description: Retro groove color scheme for Vim
-" Author: morhetz <morhetz@gmail.com>
-" Source: https://github.com/morhetz/gruvbox
-" Last Modified: 09 Apr 2014
-" -----------------------------------------------------------------------------
-
-function! gruvbox#invert_signs_toggle()
-  if g:gruvbox_invert_signs == 0
-    let g:gruvbox_invert_signs=1
-  else
-    let g:gruvbox_invert_signs=0
-  endif
-
-  colorscheme gruvbox
-endfunction
-
-" Search Highlighting {{{
-
-function! gruvbox#hls_show()
-  set hlsearch
-  call GruvboxHlsShowCursor()
-endfunction
-
-function! gruvbox#hls_hide()
-  set nohlsearch
-  call GruvboxHlsHideCursor()
-endfunction
-
-function! gruvbox#hls_toggle()
-  if &hlsearch
-    call gruvbox#hls_hide()
-  else
-    call gruvbox#hls_show()
-  endif
-endfunction
-
-" }}}
-
-" vim: set sw=2 ts=2 sts=2 et tw=80 ft=vim fdm=marker:
diff --git a/sources_non_forked/gruvbox/autoload/lightline/colorscheme/gruvbox.vim b/sources_non_forked/gruvbox/autoload/lightline/colorscheme/gruvbox.vim
deleted file mode 100644
index 4730c09..0000000
--- a/sources_non_forked/gruvbox/autoload/lightline/colorscheme/gruvbox.vim
+++ /dev/null
@@ -1,57 +0,0 @@
-" -----------------------------------------------------------------------------
-" File: gruvbox.vim
-" Description: Gruvbox colorscheme for Lightline (itchyny/lightline.vim)
-" Author: gmoe <me@griffinmoe.com>
-" Source: https://github.com/morhetz/gruvbox
-" Last Modified: 20 Sep 2017
-" -----------------------------------------------------------------------------
-
-function! s:getGruvColor(group)
-  let guiColor = synIDattr(hlID(a:group), "fg", "gui") 
-  let termColor = synIDattr(hlID(a:group), "fg", "cterm") 
-  return [ guiColor, termColor ]
-endfunction
-
-if exists('g:lightline')
-
-  let s:bg0  = s:getGruvColor('GruvboxBg0')
-  let s:bg1  = s:getGruvColor('GruvboxBg1')
-  let s:bg2  = s:getGruvColor('GruvboxBg2')
-  let s:bg4  = s:getGruvColor('GruvboxBg4')
-  let s:fg1  = s:getGruvColor('GruvboxFg1')
-  let s:fg4  = s:getGruvColor('GruvboxFg4')
-
-  let s:yellow = s:getGruvColor('GruvboxYellow')
-  let s:blue   = s:getGruvColor('GruvboxBlue')
-  let s:aqua   = s:getGruvColor('GruvboxAqua')
-  let s:orange = s:getGruvColor('GruvboxOrange')
-  let s:green = s:getGruvColor('GruvboxGreen')
-
-  let s:p = {'normal':{}, 'inactive':{}, 'insert':{}, 'replace':{}, 'visual':{}, 'tabline':{}, 'terminal':{}}
-  let s:p.normal.left = [ [ s:bg0, s:fg4, 'bold' ], [ s:fg4, s:bg2 ] ]
-  let s:p.normal.right = [ [ s:bg0, s:fg4 ], [ s:fg4, s:bg2 ] ]
-  let s:p.normal.middle = [ [ s:fg4, s:bg1 ] ]
-  let s:p.inactive.right = [ [ s:bg4, s:bg1 ], [ s:bg4, s:bg1 ] ]
-  let s:p.inactive.left =  [ [ s:bg4, s:bg1 ], [ s:bg4, s:bg1 ] ]
-  let s:p.inactive.middle = [ [ s:bg4, s:bg1 ] ]
-  let s:p.insert.left = [ [ s:bg0, s:blue, 'bold' ], [ s:fg1, s:bg2 ] ]
-  let s:p.insert.right = [ [ s:bg0, s:blue ], [ s:fg1, s:bg2 ] ]
-  let s:p.insert.middle = [ [ s:fg4, s:bg2 ] ]
-  let s:p.terminal.left = [ [ s:bg0, s:green, 'bold' ], [ s:fg1, s:bg2 ] ]
-  let s:p.terminal.right = [ [ s:bg0, s:green ], [ s:fg1, s:bg2 ] ]
-  let s:p.terminal.middle = [ [ s:fg4, s:bg2 ] ]
-  let s:p.replace.left = [ [ s:bg0, s:aqua, 'bold' ], [ s:fg1, s:bg2 ] ]
-  let s:p.replace.right = [ [ s:bg0, s:aqua ], [ s:fg1, s:bg2 ] ]
-  let s:p.replace.middle = [ [ s:fg4, s:bg2 ] ]
-  let s:p.visual.left = [ [ s:bg0, s:orange, 'bold' ], [ s:bg0, s:bg4 ] ]
-  let s:p.visual.right = [ [ s:bg0, s:orange ], [ s:bg0, s:bg4 ] ]
-  let s:p.visual.middle = [ [ s:fg4, s:bg1 ] ]
-  let s:p.tabline.left = [ [ s:fg4, s:bg2 ] ]
-  let s:p.tabline.tabsel = [ [ s:bg0, s:fg4 ] ]
-  let s:p.tabline.middle = [ [ s:bg0, s:bg0 ] ]
-  let s:p.tabline.right = [ [ s:bg0, s:orange ] ]
-  let s:p.normal.error = [ [ s:bg0, s:orange ] ]
-  let s:p.normal.warning = [ [ s:bg2, s:yellow ] ]
-
-  let g:lightline#colorscheme#gruvbox#palette = lightline#colorscheme#flatten(s:p)
-endif
diff --git a/sources_non_forked/gruvbox/colors/gruvbox.vim b/sources_non_forked/gruvbox/colors/gruvbox.vim
deleted file mode 100644
index 66246fb..0000000
--- a/sources_non_forked/gruvbox/colors/gruvbox.vim
+++ /dev/null
@@ -1,1418 +0,0 @@
-" -----------------------------------------------------------------------------
-" File: gruvbox.vim
-" Description: Retro groove color scheme for Vim
-" Author: morhetz <morhetz@gmail.com>
-" Source: https://github.com/morhetz/gruvbox
-" Last Modified: 12 Aug 2017
-" -----------------------------------------------------------------------------
-
-" Supporting code -------------------------------------------------------------
-" Initialisation: {{{
-
-if version > 580
-  hi clear
-  if exists("syntax_on")
-    syntax reset
-  endif
-endif
-
-let g:colors_name='gruvbox'
-
-if !(has('termguicolors') && &termguicolors) && !has('gui_running') && &t_Co != 256
-  finish
-endif
-
-" }}}
-" Global Settings: {{{
-
-if !exists('g:gruvbox_bold')
-  let g:gruvbox_bold=1
-endif
-if !exists('g:gruvbox_italic')
-  if has('gui_running') || $TERM_ITALICS == 'true'
-    let g:gruvbox_italic=1
-  else
-    let g:gruvbox_italic=0
-  endif
-endif
-if !exists('g:gruvbox_undercurl')
-  let g:gruvbox_undercurl=1
-endif
-if !exists('g:gruvbox_underline')
-  let g:gruvbox_underline=1
-endif
-if !exists('g:gruvbox_inverse')
-  let g:gruvbox_inverse=1
-endif
-
-if !exists('g:gruvbox_guisp_fallback') || index(['fg', 'bg'], g:gruvbox_guisp_fallback) == -1
-  let g:gruvbox_guisp_fallback='NONE'
-endif
-
-if !exists('g:gruvbox_improved_strings')
-  let g:gruvbox_improved_strings=0
-endif
-
-if !exists('g:gruvbox_improved_warnings')
-  let g:gruvbox_improved_warnings=0
-endif
-
-if !exists('g:gruvbox_termcolors')
-  let g:gruvbox_termcolors=256
-endif
-
-if !exists('g:gruvbox_invert_indent_guides')
-  let g:gruvbox_invert_indent_guides=0
-endif
-
-if exists('g:gruvbox_contrast')
-  echo 'g:gruvbox_contrast is deprecated; use g:gruvbox_contrast_light and g:gruvbox_contrast_dark instead'
-endif
-
-if !exists('g:gruvbox_contrast_dark')
-  let g:gruvbox_contrast_dark='medium'
-endif
-
-if !exists('g:gruvbox_contrast_light')
-  let g:gruvbox_contrast_light='medium'
-endif
-
-let s:is_dark=(&background == 'dark')
-
-" }}}
-" Palette: {{{
-
-" setup palette dictionary
-let s:gb = {}
-
-" fill it with absolute colors
-let s:gb.dark0_hard  = ['#1d2021', 234]     " 29-32-33
-let s:gb.dark0       = ['#282828', 235]     " 40-40-40
-let s:gb.dark0_soft  = ['#32302f', 236]     " 50-48-47
-let s:gb.dark1       = ['#3c3836', 237]     " 60-56-54
-let s:gb.dark2       = ['#504945', 239]     " 80-73-69
-let s:gb.dark3       = ['#665c54', 241]     " 102-92-84
-let s:gb.dark4       = ['#7c6f64', 243]     " 124-111-100
-let s:gb.dark4_256   = ['#7c6f64', 243]     " 124-111-100
-
-let s:gb.gray_245    = ['#928374', 245]     " 146-131-116
-let s:gb.gray_244    = ['#928374', 244]     " 146-131-116
-
-let s:gb.light0_hard = ['#f9f5d7', 230]     " 249-245-215
-let s:gb.light0      = ['#fbf1c7', 229]     " 253-244-193
-let s:gb.light0_soft = ['#f2e5bc', 228]     " 242-229-188
-let s:gb.light1      = ['#ebdbb2', 223]     " 235-219-178
-let s:gb.light2      = ['#d5c4a1', 250]     " 213-196-161
-let s:gb.light3      = ['#bdae93', 248]     " 189-174-147
-let s:gb.light4      = ['#a89984', 246]     " 168-153-132
-let s:gb.light4_256  = ['#a89984', 246]     " 168-153-132
-
-let s:gb.bright_red     = ['#fb4934', 167]     " 251-73-52
-let s:gb.bright_green   = ['#b8bb26', 142]     " 184-187-38
-let s:gb.bright_yellow  = ['#fabd2f', 214]     " 250-189-47
-let s:gb.bright_blue    = ['#83a598', 109]     " 131-165-152
-let s:gb.bright_purple  = ['#d3869b', 175]     " 211-134-155
-let s:gb.bright_aqua    = ['#8ec07c', 108]     " 142-192-124
-let s:gb.bright_orange  = ['#fe8019', 208]     " 254-128-25
-
-let s:gb.neutral_red    = ['#cc241d', 124]     " 204-36-29
-let s:gb.neutral_green  = ['#98971a', 106]     " 152-151-26
-let s:gb.neutral_yellow = ['#d79921', 172]     " 215-153-33
-let s:gb.neutral_blue   = ['#458588', 66]      " 69-133-136
-let s:gb.neutral_purple = ['#b16286', 132]     " 177-98-134
-let s:gb.neutral_aqua   = ['#689d6a', 72]      " 104-157-106
-let s:gb.neutral_orange = ['#d65d0e', 166]     " 214-93-14
-
-let s:gb.faded_red      = ['#9d0006', 88]      " 157-0-6
-let s:gb.faded_green    = ['#79740e', 100]     " 121-116-14
-let s:gb.faded_yellow   = ['#b57614', 136]     " 181-118-20
-let s:gb.faded_blue     = ['#076678', 24]      " 7-102-120
-let s:gb.faded_purple   = ['#8f3f71', 96]      " 143-63-113
-let s:gb.faded_aqua     = ['#427b58', 66]      " 66-123-88
-let s:gb.faded_orange   = ['#af3a03', 130]     " 175-58-3
-
-" }}}
-" Setup Emphasis: {{{
-
-let s:bold = 'bold,'
-if g:gruvbox_bold == 0
-  let s:bold = ''
-endif
-
-let s:italic = 'italic,'
-if g:gruvbox_italic == 0
-  let s:italic = ''
-endif
-
-let s:underline = 'underline,'
-if g:gruvbox_underline == 0
-  let s:underline = ''
-endif
-
-let s:undercurl = 'undercurl,'
-if g:gruvbox_undercurl == 0
-  let s:undercurl = ''
-endif
-
-let s:inverse = 'inverse,'
-if g:gruvbox_inverse == 0
-  let s:inverse = ''
-endif
-
-" }}}
-" Setup Colors: {{{
-
-let s:vim_bg = ['bg', 'bg']
-let s:vim_fg = ['fg', 'fg']
-let s:none = ['NONE', 'NONE']
-
-" determine relative colors
-if s:is_dark
-  let s:bg0  = s:gb.dark0
-  if g:gruvbox_contrast_dark == 'soft'
-    let s:bg0  = s:gb.dark0_soft
-  elseif g:gruvbox_contrast_dark == 'hard'
-    let s:bg0  = s:gb.dark0_hard
-  endif
-
-  let s:bg1  = s:gb.dark1
-  let s:bg2  = s:gb.dark2
-  let s:bg3  = s:gb.dark3
-  let s:bg4  = s:gb.dark4
-
-  let s:gray = s:gb.gray_245
-
-  let s:fg0 = s:gb.light0
-  let s:fg1 = s:gb.light1
-  let s:fg2 = s:gb.light2
-  let s:fg3 = s:gb.light3
-  let s:fg4 = s:gb.light4
-
-  let s:fg4_256 = s:gb.light4_256
-
-  let s:red    = s:gb.bright_red
-  let s:green  = s:gb.bright_green
-  let s:yellow = s:gb.bright_yellow
-  let s:blue   = s:gb.bright_blue
-  let s:purple = s:gb.bright_purple
-  let s:aqua   = s:gb.bright_aqua
-  let s:orange = s:gb.bright_orange
-else
-  let s:bg0  = s:gb.light0
-  if g:gruvbox_contrast_light == 'soft'
-    let s:bg0  = s:gb.light0_soft
-  elseif g:gruvbox_contrast_light == 'hard'
-    let s:bg0  = s:gb.light0_hard
-  endif
-
-  let s:bg1  = s:gb.light1
-  let s:bg2  = s:gb.light2
-  let s:bg3  = s:gb.light3
-  let s:bg4  = s:gb.light4
-
-  let s:gray = s:gb.gray_244
-
-  let s:fg0 = s:gb.dark0
-  let s:fg1 = s:gb.dark1
-  let s:fg2 = s:gb.dark2
-  let s:fg3 = s:gb.dark3
-  let s:fg4 = s:gb.dark4
-
-  let s:fg4_256 = s:gb.dark4_256
-
-  let s:red    = s:gb.faded_red
-  let s:green  = s:gb.faded_green
-  let s:yellow = s:gb.faded_yellow
-  let s:blue   = s:gb.faded_blue
-  let s:purple = s:gb.faded_purple
-  let s:aqua   = s:gb.faded_aqua
-  let s:orange = s:gb.faded_orange
-endif
-
-" reset to 16 colors fallback
-if g:gruvbox_termcolors == 16
-  let s:bg0[1]    = 0
-  let s:fg4[1]    = 7
-  let s:gray[1]   = 8
-  let s:red[1]    = 9
-  let s:green[1]  = 10
-  let s:yellow[1] = 11
-  let s:blue[1]   = 12
-  let s:purple[1] = 13
-  let s:aqua[1]   = 14
-  let s:fg1[1]    = 15
-endif
-
-" save current relative colors back to palette dictionary
-let s:gb.bg0 = s:bg0
-let s:gb.bg1 = s:bg1
-let s:gb.bg2 = s:bg2
-let s:gb.bg3 = s:bg3
-let s:gb.bg4 = s:bg4
-
-let s:gb.gray = s:gray
-
-let s:gb.fg0 = s:fg0
-let s:gb.fg1 = s:fg1
-let s:gb.fg2 = s:fg2
-let s:gb.fg3 = s:fg3
-let s:gb.fg4 = s:fg4
-
-let s:gb.fg4_256 = s:fg4_256
-
-let s:gb.red    = s:red
-let s:gb.green  = s:green
-let s:gb.yellow = s:yellow
-let s:gb.blue   = s:blue
-let s:gb.purple = s:purple
-let s:gb.aqua   = s:aqua
-let s:gb.orange = s:orange
-
-" }}}
-" Setup Terminal Colors For Neovim: {{{
-
-if has('nvim')
-  let g:terminal_color_0 = s:bg0[0]
-  let g:terminal_color_8 = s:gray[0]
-
-  let g:terminal_color_1 = s:gb.neutral_red[0]
-  let g:terminal_color_9 = s:red[0]
-
-  let g:terminal_color_2 = s:gb.neutral_green[0]
-  let g:terminal_color_10 = s:green[0]
-
-  let g:terminal_color_3 = s:gb.neutral_yellow[0]
-  let g:terminal_color_11 = s:yellow[0]
-
-  let g:terminal_color_4 = s:gb.neutral_blue[0]
-  let g:terminal_color_12 = s:blue[0]
-
-  let g:terminal_color_5 = s:gb.neutral_purple[0]
-  let g:terminal_color_13 = s:purple[0]
-
-  let g:terminal_color_6 = s:gb.neutral_aqua[0]
-  let g:terminal_color_14 = s:aqua[0]
-
-  let g:terminal_color_7 = s:fg4[0]
-  let g:terminal_color_15 = s:fg1[0]
-endif
-
-" }}}
-" Overload Setting: {{{
-
-let s:hls_cursor = s:orange
-if exists('g:gruvbox_hls_cursor')
-  let s:hls_cursor = get(s:gb, g:gruvbox_hls_cursor)
-endif
-
-let s:number_column = s:none
-if exists('g:gruvbox_number_column')
-  let s:number_column = get(s:gb, g:gruvbox_number_column)
-endif
-
-let s:sign_column = s:bg1
-
-if exists('g:gitgutter_override_sign_column_highlight') &&
-      \ g:gitgutter_override_sign_column_highlight == 1
-  let s:sign_column = s:number_column
-else
-  let g:gitgutter_override_sign_column_highlight = 0
-
-  if exists('g:gruvbox_sign_column')
-    let s:sign_column = get(s:gb, g:gruvbox_sign_column)
-  endif
-endif
-
-let s:color_column = s:bg1
-if exists('g:gruvbox_color_column')
-  let s:color_column = get(s:gb, g:gruvbox_color_column)
-endif
-
-let s:vert_split = s:bg0
-if exists('g:gruvbox_vert_split')
-  let s:vert_split = get(s:gb, g:gruvbox_vert_split)
-endif
-
-let s:invert_signs = ''
-if exists('g:gruvbox_invert_signs')
-  if g:gruvbox_invert_signs == 1
-    let s:invert_signs = s:inverse
-  endif
-endif
-
-let s:invert_selection = s:inverse
-if exists('g:gruvbox_invert_selection')
-  if g:gruvbox_invert_selection == 0
-    let s:invert_selection = ''
-  endif
-endif
-
-let s:invert_tabline = ''
-if exists('g:gruvbox_invert_tabline')
-  if g:gruvbox_invert_tabline == 1
-    let s:invert_tabline = s:inverse
-  endif
-endif
-
-let s:italicize_comments = s:italic
-if exists('g:gruvbox_italicize_comments')
-  if g:gruvbox_italicize_comments == 0
-    let s:italicize_comments = ''
-  endif
-endif
-
-let s:italicize_strings = ''
-if exists('g:gruvbox_italicize_strings')
-  if g:gruvbox_italicize_strings == 1
-    let s:italicize_strings = s:italic
-  endif
-endif
-
-" }}}
-" Highlighting Function: {{{
-
-function! s:HL(group, fg, ...)
-  " Arguments: group, guifg, guibg, gui, guisp
-
-  " foreground
-  let fg = a:fg
-
-  " background
-  if a:0 >= 1
-    let bg = a:1
-  else
-    let bg = s:none
-  endif
-
-  " emphasis
-  if a:0 >= 2 && strlen(a:2)
-    let emstr = a:2
-  else
-    let emstr = 'NONE,'
-  endif
-
-  " special fallback
-  if a:0 >= 3
-    if g:gruvbox_guisp_fallback != 'NONE'
-      let fg = a:3
-    endif
-
-    " bg fallback mode should invert higlighting
-    if g:gruvbox_guisp_fallback == 'bg'
-      let emstr .= 'inverse,'
-    endif
-  endif
-
-  let histring = [ 'hi', a:group,
-        \ 'guifg=' . fg[0], 'ctermfg=' . fg[1],
-        \ 'guibg=' . bg[0], 'ctermbg=' . bg[1],
-        \ 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2]
-        \ ]
-
-  " special
-  if a:0 >= 3
-    call add(histring, 'guisp=' . a:3[0])
-  endif
-
-  execute join(histring, ' ')
-endfunction
-
-" }}}
-" Gruvbox Hi Groups: {{{
-
-" memoize common hi groups
-call s:HL('GruvboxFg0', s:fg0)
-call s:HL('GruvboxFg1', s:fg1)
-call s:HL('GruvboxFg2', s:fg2)
-call s:HL('GruvboxFg3', s:fg3)
-call s:HL('GruvboxFg4', s:fg4)
-call s:HL('GruvboxGray', s:gray)
-call s:HL('GruvboxBg0', s:bg0)
-call s:HL('GruvboxBg1', s:bg1)
-call s:HL('GruvboxBg2', s:bg2)
-call s:HL('GruvboxBg3', s:bg3)
-call s:HL('GruvboxBg4', s:bg4)
-
-call s:HL('GruvboxRed', s:red)
-call s:HL('GruvboxRedBold', s:red, s:none, s:bold)
-call s:HL('GruvboxGreen', s:green)
-call s:HL('GruvboxGreenBold', s:green, s:none, s:bold)
-call s:HL('GruvboxYellow', s:yellow)
-call s:HL('GruvboxYellowBold', s:yellow, s:none, s:bold)
-call s:HL('GruvboxBlue', s:blue)
-call s:HL('GruvboxBlueBold', s:blue, s:none, s:bold)
-call s:HL('GruvboxPurple', s:purple)
-call s:HL('GruvboxPurpleBold', s:purple, s:none, s:bold)
-call s:HL('GruvboxAqua', s:aqua)
-call s:HL('GruvboxAquaBold', s:aqua, s:none, s:bold)
-call s:HL('GruvboxOrange', s:orange)
-call s:HL('GruvboxOrangeBold', s:orange, s:none, s:bold)
-
-call s:HL('GruvboxRedSign', s:red, s:sign_column, s:invert_signs)
-call s:HL('GruvboxGreenSign', s:green, s:sign_column, s:invert_signs)
-call s:HL('GruvboxYellowSign', s:yellow, s:sign_column, s:invert_signs)
-call s:HL('GruvboxBlueSign', s:blue, s:sign_column, s:invert_signs)
-call s:HL('GruvboxPurpleSign', s:purple, s:sign_column, s:invert_signs)
-call s:HL('GruvboxAquaSign', s:aqua, s:sign_column, s:invert_signs)
-call s:HL('GruvboxOrangeSign', s:orange, s:sign_column, s:invert_signs)
-
-" }}}
-
-" Vanilla colorscheme ---------------------------------------------------------
-" General UI: {{{
-
-" Normal text
-call s:HL('Normal', s:fg1, s:bg0)
-
-" Correct background (see issue #7):
-" --- Problem with changing between dark and light on 256 color terminal
-" --- https://github.com/morhetz/gruvbox/issues/7
-if s:is_dark
-  set background=dark
-else
-  set background=light
-endif
-
-if version >= 700
-  " Screen line that the cursor is
-  call s:HL('CursorLine',   s:none, s:bg1)
-  " Screen column that the cursor is
-  hi! link CursorColumn CursorLine
-
-  " Tab pages line filler
-  call s:HL('TabLineFill', s:bg4, s:bg1, s:invert_tabline)
-  " Active tab page label
-  call s:HL('TabLineSel', s:green, s:bg1, s:invert_tabline)
-  " Not active tab page label
-  hi! link TabLine TabLineFill
-
-  " Match paired bracket under the cursor
-  call s:HL('MatchParen', s:none, s:bg3, s:bold)
-endif
-
-if version >= 703
-  " Highlighted screen columns
-  call s:HL('ColorColumn',  s:none, s:color_column)
-
-  " Concealed element: \lambda  
-  call s:HL('Conceal', s:blue, s:none)
-
-  " Line number of CursorLine
-  call s:HL('CursorLineNr', s:yellow, s:bg1)
-endif
-
-hi! link NonText GruvboxBg2
-hi! link SpecialKey GruvboxBg2
-
-call s:HL('Visual',    s:none,  s:bg3, s:invert_selection)
-hi! link VisualNOS Visual
-
-call s:HL('Search',    s:yellow, s:bg0, s:inverse)
-call s:HL('IncSearch', s:hls_cursor, s:bg0, s:inverse)
-
-call s:HL('Underlined', s:blue, s:none, s:underline)
-
-call s:HL('StatusLine',   s:bg2, s:fg1, s:inverse)
-call s:HL('StatusLineNC', s:bg1, s:fg4, s:inverse)
-
-" The column separating vertically split windows
-call s:HL('VertSplit', s:bg3, s:vert_split)
-
-" Current match in wildmenu completion
-call s:HL('WildMenu', s:blue, s:bg2, s:bold)
-
-" Directory names, special names in listing
-hi! link Directory GruvboxGreenBold
-
-" Titles for output from :set all, :autocmd, etc.
-hi! link Title GruvboxGreenBold
-
-" Error messages on the command line
-call s:HL('ErrorMsg',   s:bg0, s:red, s:bold)
-" More prompt: -- More --
-hi! link MoreMsg GruvboxYellowBold
-" Current mode message: -- INSERT --
-hi! link ModeMsg GruvboxYellowBold
-" 'Press enter' prompt and yes/no questions
-hi! link Question GruvboxOrangeBold
-" Warning messages
-hi! link WarningMsg GruvboxRedBold
-
-" }}}
-" Gutter: {{{
-
-" Line number for :number and :# commands
-call s:HL('LineNr', s:bg4, s:number_column)
-
-" Column where signs are displayed
-call s:HL('SignColumn', s:none, s:sign_column)
-
-" Line used for closed folds
-call s:HL('Folded', s:gray, s:bg1, s:italic)
-" Column where folds are displayed
-call s:HL('FoldColumn', s:gray, s:bg1)
-
-" }}}
-" Cursor: {{{
-
-" Character under cursor
-call s:HL('Cursor', s:none, s:none, s:inverse)
-" Visual mode cursor, selection
-hi! link vCursor Cursor
-" Input moder cursor
-hi! link iCursor Cursor
-" Language mapping cursor
-hi! link lCursor Cursor
-
-" }}}
-" Syntax Highlighting: {{{
-
-if g:gruvbox_improved_strings == 0
-  hi! link Special GruvboxOrange
-else
-  call s:HL('Special', s:orange, s:bg1, s:italicize_strings)
-endif
-
-call s:HL('Comment', s:gray, s:none, s:italicize_comments)
-call s:HL('Todo', s:vim_fg, s:vim_bg, s:bold . s:italic)
-call s:HL('Error', s:red, s:vim_bg, s:bold . s:inverse)
-
-" Generic statement
-hi! link Statement GruvboxRed
-" if, then, else, endif, swicth, etc.
-hi! link Conditional GruvboxRed
-" for, do, while, etc.
-hi! link Repeat GruvboxRed
-" case, default, etc.
-hi! link Label GruvboxRed
-" try, catch, throw
-hi! link Exception GruvboxRed
-" sizeof, "+", "*", etc.
-hi! link Operator Normal
-" Any other keyword
-hi! link Keyword GruvboxRed
-
-" Variable name
-hi! link Identifier GruvboxBlue
-" Function name
-hi! link Function GruvboxGreenBold
-
-" Generic preprocessor
-hi! link PreProc GruvboxAqua
-" Preprocessor #include
-hi! link Include GruvboxAqua
-" Preprocessor #define
-hi! link Define GruvboxAqua
-" Same as Define
-hi! link Macro GruvboxAqua
-" Preprocessor #if, #else, #endif, etc.
-hi! link PreCondit GruvboxAqua
-
-" Generic constant
-hi! link Constant GruvboxPurple
-" Character constant: 'c', '/n'
-hi! link Character GruvboxPurple
-" String constant: "this is a string"
-if g:gruvbox_improved_strings == 0
-  call s:HL('String',  s:green, s:none, s:italicize_strings)
-else
-  call s:HL('String',  s:fg1, s:bg1, s:italicize_strings)
-endif
-" Boolean constant: TRUE, false
-hi! link Boolean GruvboxPurple
-" Number constant: 234, 0xff
-hi! link Number GruvboxPurple
-" Floating point constant: 2.3e10
-hi! link Float GruvboxPurple
-
-" Generic type
-hi! link Type GruvboxYellow
-" static, register, volatile, etc
-hi! link StorageClass GruvboxOrange
-" struct, union, enum, etc.
-hi! link Structure GruvboxAqua
-" typedef
-hi! link Typedef GruvboxYellow
-
-" }}}
-" Completion Menu: {{{
-
-if version >= 700
-  " Popup menu: normal item
-  call s:HL('Pmenu', s:fg1, s:bg2)
-  " Popup menu: selected item
-  call s:HL('PmenuSel', s:bg2, s:blue, s:bold)
-  " Popup menu: scrollbar
-  call s:HL('PmenuSbar', s:none, s:bg2)
-  " Popup menu: scrollbar thumb
-  call s:HL('PmenuThumb', s:none, s:bg4)
-endif
-
-" }}}
-" Diffs: {{{
-
-call s:HL('DiffDelete', s:red, s:bg0, s:inverse)
-call s:HL('DiffAdd',    s:green, s:bg0, s:inverse)
-"call s:HL('DiffChange', s:bg0, s:blue)
-"call s:HL('DiffText',   s:bg0, s:yellow)
-
-" Alternative setting
-call s:HL('DiffChange', s:aqua, s:bg0, s:inverse)
-call s:HL('DiffText',   s:yellow, s:bg0, s:inverse)
-
-" }}}
-" Spelling: {{{
-
-if has("spell")
-  " Not capitalised word, or compile warnings
-  if g:gruvbox_improved_warnings == 0
-    call s:HL('SpellCap',   s:none, s:none, s:undercurl, s:red)
-  else
-    call s:HL('SpellCap',   s:green, s:none, s:bold . s:italic)
-  endif
-  " Not recognized word
-  call s:HL('SpellBad',   s:none, s:none, s:undercurl, s:blue)
-  " Wrong spelling for selected region
-  call s:HL('SpellLocal', s:none, s:none, s:undercurl, s:aqua)
-  " Rare word
-  call s:HL('SpellRare',  s:none, s:none, s:undercurl, s:purple)
-endif
-
-" }}}
-
-" Plugin specific -------------------------------------------------------------
-" EasyMotion: {{{
-
-hi! link EasyMotionTarget Search
-hi! link EasyMotionShade Comment
-
-" }}}
-" Sneak: {{{
-
-hi! link Sneak Search
-hi! link SneakLabel Search
-
-" }}}
-" Indent Guides: {{{
-
-if !exists('g:indent_guides_auto_colors')
-  let g:indent_guides_auto_colors = 0
-endif
-
-if g:indent_guides_auto_colors == 0
-  if g:gruvbox_invert_indent_guides == 0
-    call s:HL('IndentGuidesOdd', s:vim_bg, s:bg2)
-    call s:HL('IndentGuidesEven', s:vim_bg, s:bg1)
-  else
-    call s:HL('IndentGuidesOdd', s:vim_bg, s:bg2, s:inverse)
-    call s:HL('IndentGuidesEven', s:vim_bg, s:bg3, s:inverse)
-  endif
-endif
-
-" }}}
-" IndentLine: {{{
-
-if !exists('g:indentLine_color_term')
-  let g:indentLine_color_term = s:bg2[1]
-endif
-if !exists('g:indentLine_color_gui')
-  let g:indentLine_color_gui = s:bg2[0]
-endif
-
-" }}}
-" Rainbow Parentheses: {{{
-
-if !exists('g:rbpt_colorpairs')
-  let g:rbpt_colorpairs =
-    \ [
-      \ ['blue', '#458588'], ['magenta', '#b16286'],
-      \ ['red',  '#cc241d'], ['166',     '#d65d0e']
-    \ ]
-endif
-
-let g:rainbow_guifgs = [ '#d65d0e', '#cc241d', '#b16286', '#458588' ]
-let g:rainbow_ctermfgs = [ '166', 'red', 'magenta', 'blue' ]
-
-if !exists('g:rainbow_conf')
-   let g:rainbow_conf = {}
-endif
-if !has_key(g:rainbow_conf, 'guifgs')
-   let g:rainbow_conf['guifgs'] = g:rainbow_guifgs
-endif
-if !has_key(g:rainbow_conf, 'ctermfgs')
-   let g:rainbow_conf['ctermfgs'] = g:rainbow_ctermfgs
-endif
-
-let g:niji_dark_colours = g:rbpt_colorpairs
-let g:niji_light_colours = g:rbpt_colorpairs
-
-"}}}
-" GitGutter: {{{
-
-hi! link GitGutterAdd GruvboxGreenSign
-hi! link GitGutterChange GruvboxAquaSign
-hi! link GitGutterDelete GruvboxRedSign
-hi! link GitGutterChangeDelete GruvboxAquaSign
-
-" }}}
-" GitCommit: "{{{
-
-hi! link gitcommitSelectedFile GruvboxGreen
-hi! link gitcommitDiscardedFile GruvboxRed
-
-" }}}
-" Signify: {{{
-
-hi! link SignifySignAdd GruvboxGreenSign
-hi! link SignifySignChange GruvboxAquaSign
-hi! link SignifySignDelete GruvboxRedSign
-
-" }}}
-" Syntastic: {{{
-
-call s:HL('SyntasticError', s:none, s:none, s:undercurl, s:red)
-call s:HL('SyntasticWarning', s:none, s:none, s:undercurl, s:yellow)
-
-hi! link SyntasticErrorSign GruvboxRedSign
-hi! link SyntasticWarningSign GruvboxYellowSign
-
-" }}}
-" Signature: {{{
-hi! link SignatureMarkText   GruvboxBlueSign
-hi! link SignatureMarkerText GruvboxPurpleSign
-
-" }}}
-" ShowMarks: {{{
-
-hi! link ShowMarksHLl GruvboxBlueSign
-hi! link ShowMarksHLu GruvboxBlueSign
-hi! link ShowMarksHLo GruvboxBlueSign
-hi! link ShowMarksHLm GruvboxBlueSign
-
-" }}}
-" CtrlP: {{{
-
-hi! link CtrlPMatch GruvboxYellow
-hi! link CtrlPNoEntries GruvboxRed
-hi! link CtrlPPrtBase GruvboxBg2
-hi! link CtrlPPrtCursor GruvboxBlue
-hi! link CtrlPLinePre GruvboxBg2
-
-call s:HL('CtrlPMode1', s:blue, s:bg2, s:bold)
-call s:HL('CtrlPMode2', s:bg0, s:blue, s:bold)
-call s:HL('CtrlPStats', s:fg4, s:bg2, s:bold)
-
-" }}}
-" Startify: {{{
-
-hi! link StartifyBracket GruvboxFg3
-hi! link StartifyFile GruvboxFg1
-hi! link StartifyNumber GruvboxBlue
-hi! link StartifyPath GruvboxGray
-hi! link StartifySlash GruvboxGray
-hi! link StartifySection GruvboxYellow
-hi! link StartifySpecial GruvboxBg2
-hi! link StartifyHeader GruvboxOrange
-hi! link StartifyFooter GruvboxBg2
-
-" }}}
-" Vimshell: {{{
-
-let g:vimshell_escape_colors = [
-  \ s:bg4[0], s:red[0], s:green[0], s:yellow[0],
-  \ s:blue[0], s:purple[0], s:aqua[0], s:fg4[0],
-  \ s:bg0[0], s:red[0], s:green[0], s:orange[0],
-  \ s:blue[0], s:purple[0], s:aqua[0], s:fg0[0]
-  \ ]
-
-" }}}
-" BufTabLine: {{{
-
-call s:HL('BufTabLineCurrent', s:bg0, s:fg4)
-call s:HL('BufTabLineActive', s:fg4, s:bg2)
-call s:HL('BufTabLineHidden', s:bg4, s:bg1)
-call s:HL('BufTabLineFill', s:bg0, s:bg0)
-
-" }}}
-" Asynchronous Lint Engine: {{{
-
-call s:HL('ALEError', s:none, s:none, s:undercurl, s:red)
-call s:HL('ALEWarning', s:none, s:none, s:undercurl, s:yellow)
-call s:HL('ALEInfo', s:none, s:none, s:undercurl, s:blue)
-
-hi! link ALEErrorSign GruvboxRedSign
-hi! link ALEWarningSign GruvboxYellowSign
-hi! link ALEInfoSign GruvboxBlueSign
-
-" }}}
-" Dirvish: {{{
-
-hi! link DirvishPathTail GruvboxAqua
-hi! link DirvishArg GruvboxYellow
-
-" }}}
-" Netrw: {{{
-
-hi! link netrwDir GruvboxAqua
-hi! link netrwClassify GruvboxAqua
-hi! link netrwLink GruvboxGray
-hi! link netrwSymLink GruvboxFg1
-hi! link netrwExe GruvboxYellow
-hi! link netrwComment GruvboxGray
-hi! link netrwList GruvboxBlue
-hi! link netrwHelpCmd GruvboxAqua
-hi! link netrwCmdSep GruvboxFg3
-hi! link netrwVersion GruvboxGreen
-
-" }}}
-" NERDTree: {{{
-
-hi! link NERDTreeDir GruvboxAqua
-hi! link NERDTreeDirSlash GruvboxAqua
-
-hi! link NERDTreeOpenable GruvboxOrange
-hi! link NERDTreeClosable GruvboxOrange
-
-hi! link NERDTreeFile GruvboxFg1
-hi! link NERDTreeExecFile GruvboxYellow
-
-hi! link NERDTreeUp GruvboxGray
-hi! link NERDTreeCWD GruvboxGreen
-hi! link NERDTreeHelp GruvboxFg1
-
-hi! link NERDTreeToggleOn GruvboxGreen
-hi! link NERDTreeToggleOff GruvboxRed
-
-" }}}
-" Vim Multiple Cursors: {{{
-
-call s:HL('multiple_cursors_cursor', s:none, s:none, s:inverse)
-call s:HL('multiple_cursors_visual', s:none, s:bg2)
-
-" }}}
-" coc.nvim: {{{
-
-hi! link CocErrorSign GruvboxRedSign
-hi! link CocWarningSign GruvboxOrangeSign
-hi! link CocInfoSign GruvboxYellowSign
-hi! link CocHintSign GruvboxBlueSign
-hi! link CocErrorFloat GruvboxRed
-hi! link CocWarningFloat GruvboxOrange
-hi! link CocInfoFloat GruvboxYellow
-hi! link CocHintFloat GruvboxBlue
-hi! link CocDiagnosticsError GruvboxRed
-hi! link CocDiagnosticsWarning GruvboxOrange
-hi! link CocDiagnosticsInfo GruvboxYellow
-hi! link CocDiagnosticsHint GruvboxBlue
-
-hi! link CocSelectedText GruvboxRed
-hi! link CocCodeLens GruvboxGray
-
-call s:HL('CocErrorHighlight', s:none, s:none, s:undercurl, s:red)
-call s:HL('CocWarningHighlight', s:none, s:none, s:undercurl, s:orange)
-call s:HL('CocInfoHighlight', s:none, s:none, s:undercurl, s:yellow)
-call s:HL('CocHintHighlight', s:none, s:none, s:undercurl, s:blue)
-
-" }}}
-
-" Filetype specific -----------------------------------------------------------
-" Diff: {{{
-
-hi! link diffAdded GruvboxGreen
-hi! link diffRemoved GruvboxRed
-hi! link diffChanged GruvboxAqua
-
-hi! link diffFile GruvboxOrange
-hi! link diffNewFile GruvboxYellow
-
-hi! link diffLine GruvboxBlue
-
-" }}}
-" Html: {{{
-
-hi! link htmlTag GruvboxBlue
-hi! link htmlEndTag GruvboxBlue
-
-hi! link htmlTagName GruvboxAquaBold
-hi! link htmlArg GruvboxAqua
-
-hi! link htmlScriptTag GruvboxPurple
-hi! link htmlTagN GruvboxFg1
-hi! link htmlSpecialTagName GruvboxAquaBold
-
-call s:HL('htmlLink', s:fg4, s:none, s:underline)
-
-hi! link htmlSpecialChar GruvboxOrange
-
-call s:HL('htmlBold', s:vim_fg, s:vim_bg, s:bold)
-call s:HL('htmlBoldUnderline', s:vim_fg, s:vim_bg, s:bold . s:underline)
-call s:HL('htmlBoldItalic', s:vim_fg, s:vim_bg, s:bold . s:italic)
-call s:HL('htmlBoldUnderlineItalic', s:vim_fg, s:vim_bg, s:bold . s:underline . s:italic)
-
-call s:HL('htmlUnderline', s:vim_fg, s:vim_bg, s:underline)
-call s:HL('htmlUnderlineItalic', s:vim_fg, s:vim_bg, s:underline . s:italic)
-call s:HL('htmlItalic', s:vim_fg, s:vim_bg, s:italic)
-
-" }}}
-" Xml: {{{
-
-hi! link xmlTag GruvboxBlue
-hi! link xmlEndTag GruvboxBlue
-hi! link xmlTagName GruvboxBlue
-hi! link xmlEqual GruvboxBlue
-hi! link docbkKeyword GruvboxAquaBold
-
-hi! link xmlDocTypeDecl GruvboxGray
-hi! link xmlDocTypeKeyword GruvboxPurple
-hi! link xmlCdataStart GruvboxGray
-hi! link xmlCdataCdata GruvboxPurple
-hi! link dtdFunction GruvboxGray
-hi! link dtdTagName GruvboxPurple
-
-hi! link xmlAttrib GruvboxAqua
-hi! link xmlProcessingDelim GruvboxGray
-hi! link dtdParamEntityPunct GruvboxGray
-hi! link dtdParamEntityDPunct GruvboxGray
-hi! link xmlAttribPunct GruvboxGray
-
-hi! link xmlEntity GruvboxOrange
-hi! link xmlEntityPunct GruvboxOrange
-" }}}
-" Vim: {{{
-
-call s:HL('vimCommentTitle', s:fg4_256, s:none, s:bold . s:italicize_comments)
-
-hi! link vimNotation GruvboxOrange
-hi! link vimBracket GruvboxOrange
-hi! link vimMapModKey GruvboxOrange
-hi! link vimFuncSID GruvboxFg3
-hi! link vimSetSep GruvboxFg3
-hi! link vimSep GruvboxFg3
-hi! link vimContinue GruvboxFg3
-
-" }}}
-" Clojure: {{{
-
-hi! link clojureKeyword GruvboxBlue
-hi! link clojureCond GruvboxOrange
-hi! link clojureSpecial GruvboxOrange
-hi! link clojureDefine GruvboxOrange
-
-hi! link clojureFunc GruvboxYellow
-hi! link clojureRepeat GruvboxYellow
-hi! link clojureCharacter GruvboxAqua
-hi! link clojureStringEscape GruvboxAqua
-hi! link clojureException GruvboxRed
-
-hi! link clojureRegexp GruvboxAqua
-hi! link clojureRegexpEscape GruvboxAqua
-call s:HL('clojureRegexpCharClass', s:fg3, s:none, s:bold)
-hi! link clojureRegexpMod clojureRegexpCharClass
-hi! link clojureRegexpQuantifier clojureRegexpCharClass
-
-hi! link clojureParen GruvboxFg3
-hi! link clojureAnonArg GruvboxYellow
-hi! link clojureVariable GruvboxBlue
-hi! link clojureMacro GruvboxOrange
-
-hi! link clojureMeta GruvboxYellow
-hi! link clojureDeref GruvboxYellow
-hi! link clojureQuote GruvboxYellow
-hi! link clojureUnquote GruvboxYellow
-
-" }}}
-" C: {{{
-
-hi! link cOperator GruvboxPurple
-hi! link cStructure GruvboxOrange
-
-" }}}
-" Python: {{{
-
-hi! link pythonBuiltin GruvboxOrange
-hi! link pythonBuiltinObj GruvboxOrange
-hi! link pythonBuiltinFunc GruvboxOrange
-hi! link pythonFunction GruvboxAqua
-hi! link pythonDecorator GruvboxRed
-hi! link pythonInclude GruvboxBlue
-hi! link pythonImport GruvboxBlue
-hi! link pythonRun GruvboxBlue
-hi! link pythonCoding GruvboxBlue
-hi! link pythonOperator GruvboxRed
-hi! link pythonException GruvboxRed
-hi! link pythonExceptions GruvboxPurple
-hi! link pythonBoolean GruvboxPurple
-hi! link pythonDot GruvboxFg3
-hi! link pythonConditional GruvboxRed
-hi! link pythonRepeat GruvboxRed
-hi! link pythonDottedName GruvboxGreenBold
-
-" }}}
-" CSS: {{{
-
-hi! link cssBraces GruvboxBlue
-hi! link cssFunctionName GruvboxYellow
-hi! link cssIdentifier GruvboxOrange
-hi! link cssClassName GruvboxGreen
-hi! link cssColor GruvboxBlue
-hi! link cssSelectorOp GruvboxBlue
-hi! link cssSelectorOp2 GruvboxBlue
-hi! link cssImportant GruvboxGreen
-hi! link cssVendor GruvboxFg1
-
-hi! link cssTextProp GruvboxAqua
-hi! link cssAnimationProp GruvboxAqua
-hi! link cssUIProp GruvboxYellow
-hi! link cssTransformProp GruvboxAqua
-hi! link cssTransitionProp GruvboxAqua
-hi! link cssPrintProp GruvboxAqua
-hi! link cssPositioningProp GruvboxYellow
-hi! link cssBoxProp GruvboxAqua
-hi! link cssFontDescriptorProp GruvboxAqua
-hi! link cssFlexibleBoxProp GruvboxAqua
-hi! link cssBorderOutlineProp GruvboxAqua
-hi! link cssBackgroundProp GruvboxAqua
-hi! link cssMarginProp GruvboxAqua
-hi! link cssListProp GruvboxAqua
-hi! link cssTableProp GruvboxAqua
-hi! link cssFontProp GruvboxAqua
-hi! link cssPaddingProp GruvboxAqua
-hi! link cssDimensionProp GruvboxAqua
-hi! link cssRenderProp GruvboxAqua
-hi! link cssColorProp GruvboxAqua
-hi! link cssGeneratedContentProp GruvboxAqua
-
-" }}}
-" JavaScript: {{{
-
-hi! link javaScriptBraces GruvboxFg1
-hi! link javaScriptFunction GruvboxAqua
-hi! link javaScriptIdentifier GruvboxRed
-hi! link javaScriptMember GruvboxBlue
-hi! link javaScriptNumber GruvboxPurple
-hi! link javaScriptNull GruvboxPurple
-hi! link javaScriptParens GruvboxFg3
-
-" }}}
-" YAJS: {{{
-
-hi! link javascriptImport GruvboxAqua
-hi! link javascriptExport GruvboxAqua
-hi! link javascriptClassKeyword GruvboxAqua
-hi! link javascriptClassExtends GruvboxAqua
-hi! link javascriptDefault GruvboxAqua
-
-hi! link javascriptClassName GruvboxYellow
-hi! link javascriptClassSuperName GruvboxYellow
-hi! link javascriptGlobal GruvboxYellow
-
-hi! link javascriptEndColons GruvboxFg1
-hi! link javascriptFuncArg GruvboxFg1
-hi! link javascriptGlobalMethod GruvboxFg1
-hi! link javascriptNodeGlobal GruvboxFg1
-hi! link javascriptBOMWindowProp GruvboxFg1
-hi! link javascriptArrayMethod GruvboxFg1
-hi! link javascriptArrayStaticMethod GruvboxFg1
-hi! link javascriptCacheMethod GruvboxFg1
-hi! link javascriptDateMethod GruvboxFg1
-hi! link javascriptMathStaticMethod GruvboxFg1
-
-" hi! link javascriptProp GruvboxFg1
-hi! link javascriptURLUtilsProp GruvboxFg1
-hi! link javascriptBOMNavigatorProp GruvboxFg1
-hi! link javascriptDOMDocMethod GruvboxFg1
-hi! link javascriptDOMDocProp GruvboxFg1
-hi! link javascriptBOMLocationMethod GruvboxFg1
-hi! link javascriptBOMWindowMethod GruvboxFg1
-hi! link javascriptStringMethod GruvboxFg1
-
-hi! link javascriptVariable GruvboxOrange
-" hi! link javascriptVariable GruvboxRed
-" hi! link javascriptIdentifier GruvboxOrange
-" hi! link javascriptClassSuper GruvboxOrange
-hi! link javascriptIdentifier GruvboxOrange
-hi! link javascriptClassSuper GruvboxOrange
-
-" hi! link javascriptFuncKeyword GruvboxOrange
-" hi! link javascriptAsyncFunc GruvboxOrange
-hi! link javascriptFuncKeyword GruvboxAqua
-hi! link javascriptAsyncFunc GruvboxAqua
-hi! link javascriptClassStatic GruvboxOrange
-
-hi! link javascriptOperator GruvboxRed
-hi! link javascriptForOperator GruvboxRed
-hi! link javascriptYield GruvboxRed
-hi! link javascriptExceptions GruvboxRed
-hi! link javascriptMessage GruvboxRed
-
-hi! link javascriptTemplateSB GruvboxAqua
-hi! link javascriptTemplateSubstitution GruvboxFg1
-
-" hi! link javascriptLabel GruvboxBlue
-" hi! link javascriptObjectLabel GruvboxBlue
-" hi! link javascriptPropertyName GruvboxBlue
-hi! link javascriptLabel GruvboxFg1
-hi! link javascriptObjectLabel GruvboxFg1
-hi! link javascriptPropertyName GruvboxFg1
-
-hi! link javascriptLogicSymbols GruvboxFg1
-hi! link javascriptArrowFunc GruvboxYellow
-
-hi! link javascriptDocParamName GruvboxFg4
-hi! link javascriptDocTags GruvboxFg4
-hi! link javascriptDocNotation GruvboxFg4
-hi! link javascriptDocParamType GruvboxFg4
-hi! link javascriptDocNamedParamType GruvboxFg4
-
-hi! link javascriptBrackets GruvboxFg1
-hi! link javascriptDOMElemAttrs GruvboxFg1
-hi! link javascriptDOMEventMethod GruvboxFg1
-hi! link javascriptDOMNodeMethod GruvboxFg1
-hi! link javascriptDOMStorageMethod GruvboxFg1
-hi! link javascriptHeadersMethod GruvboxFg1
-
-hi! link javascriptAsyncFuncKeyword GruvboxRed
-hi! link javascriptAwaitFuncKeyword GruvboxRed
-
-" }}}
-" PanglossJS: {{{
-
-hi! link jsClassKeyword GruvboxAqua
-hi! link jsExtendsKeyword GruvboxAqua
-hi! link jsExportDefault GruvboxAqua
-hi! link jsTemplateBraces GruvboxAqua
-hi! link jsGlobalNodeObjects GruvboxFg1
-hi! link jsGlobalObjects GruvboxFg1
-hi! link jsFunction GruvboxAqua
-hi! link jsFuncParens GruvboxFg3
-hi! link jsParens GruvboxFg3
-hi! link jsNull GruvboxPurple
-hi! link jsUndefined GruvboxPurple
-hi! link jsClassDefinition GruvboxYellow
-
-" }}}
-" TypeScript: {{{
-
-hi! link typeScriptReserved GruvboxAqua
-hi! link typeScriptLabel GruvboxAqua
-hi! link typeScriptFuncKeyword GruvboxAqua
-hi! link typeScriptIdentifier GruvboxOrange
-hi! link typeScriptBraces GruvboxFg1
-hi! link typeScriptEndColons GruvboxFg1
-hi! link typeScriptDOMObjects GruvboxFg1
-hi! link typeScriptAjaxMethods GruvboxFg1
-hi! link typeScriptLogicSymbols GruvboxFg1
-hi! link typeScriptDocSeeTag Comment
-hi! link typeScriptDocParam Comment
-hi! link typeScriptDocTags vimCommentTitle
-hi! link typeScriptGlobalObjects GruvboxFg1
-hi! link typeScriptParens GruvboxFg3
-hi! link typeScriptOpSymbols GruvboxFg3
-hi! link typeScriptHtmlElemProperties GruvboxFg1
-hi! link typeScriptNull GruvboxPurple
-hi! link typeScriptInterpolationDelimiter GruvboxAqua
-
-" }}}
-" PureScript: {{{
-
-hi! link purescriptModuleKeyword GruvboxAqua
-hi! link purescriptModuleName GruvboxFg1
-hi! link purescriptWhere GruvboxAqua
-hi! link purescriptDelimiter GruvboxFg4
-hi! link purescriptType GruvboxFg1
-hi! link purescriptImportKeyword GruvboxAqua
-hi! link purescriptHidingKeyword GruvboxAqua
-hi! link purescriptAsKeyword GruvboxAqua
-hi! link purescriptStructure GruvboxAqua
-hi! link purescriptOperator GruvboxBlue
-
-hi! link purescriptTypeVar GruvboxFg1
-hi! link purescriptConstructor GruvboxFg1
-hi! link purescriptFunction GruvboxFg1
-hi! link purescriptConditional GruvboxOrange
-hi! link purescriptBacktick GruvboxOrange
-
-" }}}
-" CoffeeScript: {{{
-
-hi! link coffeeExtendedOp GruvboxFg3
-hi! link coffeeSpecialOp GruvboxFg3
-hi! link coffeeCurly GruvboxOrange
-hi! link coffeeParen GruvboxFg3
-hi! link coffeeBracket GruvboxOrange
-
-" }}}
-" Ruby: {{{
-
-hi! link rubyStringDelimiter GruvboxGreen
-hi! link rubyInterpolationDelimiter GruvboxAqua
-
-" }}}
-" ObjectiveC: {{{
-
-hi! link objcTypeModifier GruvboxRed
-hi! link objcDirective GruvboxBlue
-
-" }}}
-" Go: {{{
-
-hi! link goDirective GruvboxAqua
-hi! link goConstants GruvboxPurple
-hi! link goDeclaration GruvboxRed
-hi! link goDeclType GruvboxBlue
-hi! link goBuiltins GruvboxOrange
-
-" }}}
-" Lua: {{{
-
-hi! link luaIn GruvboxRed
-hi! link luaFunction GruvboxAqua
-hi! link luaTable GruvboxOrange
-
-" }}}
-" MoonScript: {{{
-
-hi! link moonSpecialOp GruvboxFg3
-hi! link moonExtendedOp GruvboxFg3
-hi! link moonFunction GruvboxFg3
-hi! link moonObject GruvboxYellow
-
-" }}}
-" Java: {{{
-
-hi! link javaAnnotation GruvboxBlue
-hi! link javaDocTags GruvboxAqua
-hi! link javaCommentTitle vimCommentTitle
-hi! link javaParen GruvboxFg3
-hi! link javaParen1 GruvboxFg3
-hi! link javaParen2 GruvboxFg3
-hi! link javaParen3 GruvboxFg3
-hi! link javaParen4 GruvboxFg3
-hi! link javaParen5 GruvboxFg3
-hi! link javaOperator GruvboxOrange
-
-hi! link javaVarArg GruvboxGreen
-
-" }}}
-" Elixir: {{{
-
-hi! link elixirDocString Comment
-
-hi! link elixirStringDelimiter GruvboxGreen
-hi! link elixirInterpolationDelimiter GruvboxAqua
-
-hi! link elixirModuleDeclaration GruvboxYellow
-
-" }}}
-" Scala: {{{
-
-" NB: scala vim syntax file is kinda horrible
-hi! link scalaNameDefinition GruvboxFg1
-hi! link scalaCaseFollowing GruvboxFg1
-hi! link scalaCapitalWord GruvboxFg1
-hi! link scalaTypeExtension GruvboxFg1
-
-hi! link scalaKeyword GruvboxRed
-hi! link scalaKeywordModifier GruvboxRed
-
-hi! link scalaSpecial GruvboxAqua
-hi! link scalaOperator GruvboxFg1
-
-hi! link scalaTypeDeclaration GruvboxYellow
-hi! link scalaTypeTypePostDeclaration GruvboxYellow
-
-hi! link scalaInstanceDeclaration GruvboxFg1
-hi! link scalaInterpolation GruvboxAqua
-
-" }}}
-" Markdown: {{{
-
-call s:HL('markdownItalic', s:fg3, s:none, s:italic)
-
-hi! link markdownH1 GruvboxGreenBold
-hi! link markdownH2 GruvboxGreenBold
-hi! link markdownH3 GruvboxYellowBold
-hi! link markdownH4 GruvboxYellowBold
-hi! link markdownH5 GruvboxYellow
-hi! link markdownH6 GruvboxYellow
-
-hi! link markdownCode GruvboxAqua
-hi! link markdownCodeBlock GruvboxAqua
-hi! link markdownCodeDelimiter GruvboxAqua
-
-hi! link markdownBlockquote GruvboxGray
-hi! link markdownListMarker GruvboxGray
-hi! link markdownOrderedListMarker GruvboxGray
-hi! link markdownRule GruvboxGray
-hi! link markdownHeadingRule GruvboxGray
-
-hi! link markdownUrlDelimiter GruvboxFg3
-hi! link markdownLinkDelimiter GruvboxFg3
-hi! link markdownLinkTextDelimiter GruvboxFg3
-
-hi! link markdownHeadingDelimiter GruvboxOrange
-hi! link markdownUrl GruvboxPurple
-hi! link markdownUrlTitleDelimiter GruvboxGreen
-
-call s:HL('markdownLinkText', s:gray, s:none, s:underline)
-hi! link markdownIdDeclaration markdownLinkText
-
-" }}}
-" Haskell: {{{
-
-" hi! link haskellType GruvboxYellow
-" hi! link haskellOperators GruvboxOrange
-" hi! link haskellConditional GruvboxAqua
-" hi! link haskellLet GruvboxOrange
-"
-hi! link haskellType GruvboxFg1
-hi! link haskellIdentifier GruvboxFg1
-hi! link haskellSeparator GruvboxFg1
-hi! link haskellDelimiter GruvboxFg4
-hi! link haskellOperators GruvboxBlue
-"
-hi! link haskellBacktick GruvboxOrange
-hi! link haskellStatement GruvboxOrange
-hi! link haskellConditional GruvboxOrange
-
-hi! link haskellLet GruvboxAqua
-hi! link haskellDefault GruvboxAqua
-hi! link haskellWhere GruvboxAqua
-hi! link haskellBottom GruvboxAqua
-hi! link haskellBlockKeywords GruvboxAqua
-hi! link haskellImportKeywords GruvboxAqua
-hi! link haskellDeclKeyword GruvboxAqua
-hi! link haskellDeriving GruvboxAqua
-hi! link haskellAssocType GruvboxAqua
-
-hi! link haskellNumber GruvboxPurple
-hi! link haskellPragma GruvboxPurple
-
-hi! link haskellString GruvboxGreen
-hi! link haskellChar GruvboxGreen
-
-" }}}
-" Json: {{{
-
-hi! link jsonKeyword GruvboxGreen
-hi! link jsonQuote GruvboxGreen
-hi! link jsonBraces GruvboxFg1
-hi! link jsonString GruvboxFg1
-
-" }}}
-
-
-" Functions -------------------------------------------------------------------
-" Search Highlighting Cursor {{{
-
-function! GruvboxHlsShowCursor()
-  call s:HL('Cursor', s:bg0, s:hls_cursor)
-endfunction
-
-function! GruvboxHlsHideCursor()
-  call s:HL('Cursor', s:none, s:none, s:inverse)
-endfunction
-
-" }}}
-
-" vim: set sw=2 ts=2 sts=2 et tw=80 ft=vim fdm=marker:
diff --git a/sources_non_forked/gruvbox/gruvbox_256palette.sh b/sources_non_forked/gruvbox/gruvbox_256palette.sh
deleted file mode 100644
index c7fd190..0000000
--- a/sources_non_forked/gruvbox/gruvbox_256palette.sh
+++ /dev/null
@@ -1,118 +0,0 @@
-#!/bin/sh
-
-if [ "${TERM%%-*}" = "screen" ]; then
-  if [ -n "$TMUX" ]; then
-    printf "\033Ptmux;\033\033]4;236;rgb:32/30/2f\007\033\\"
-    printf "\033Ptmux;\033\033]4;234;rgb:1d/20/21\007\033\\"
-
-    printf "\033Ptmux;\033\033]4;235;rgb:28/28/28\007\033\\"
-    printf "\033Ptmux;\033\033]4;237;rgb:3c/38/36\007\033\\"
-    printf "\033Ptmux;\033\033]4;239;rgb:50/49/45\007\033\\"
-    printf "\033Ptmux;\033\033]4;241;rgb:66/5c/54\007\033\\"
-    printf "\033Ptmux;\033\033]4;243;rgb:7c/6f/64\007\033\\"
-
-    printf "\033Ptmux;\033\033]4;244;rgb:92/83/74\007\033\\"
-    printf "\033Ptmux;\033\033]4;245;rgb:92/83/74\007\033\\"
-
-    printf "\033Ptmux;\033\033]4;228;rgb:f2/e5/bc\007\033\\"
-    printf "\033Ptmux;\033\033]4;230;rgb:f9/f5/d7\007\033\\"
-
-    printf "\033Ptmux;\033\033]4;229;rgb:fb/f1/c7\007\033\\"
-    printf "\033Ptmux;\033\033]4;223;rgb:eb/db/b2\007\033\\"
-    printf "\033Ptmux;\033\033]4;250;rgb:d5/c4/a1\007\033\\"
-    printf "\033Ptmux;\033\033]4;248;rgb:bd/ae/93\007\033\\"
-    printf "\033Ptmux;\033\033]4;246;rgb:a8/99/84\007\033\\"
-
-    printf "\033Ptmux;\033\033]4;167;rgb:fb/49/34\007\033\\"
-    printf "\033Ptmux;\033\033]4;142;rgb:b8/bb/26\007\033\\"
-    printf "\033Ptmux;\033\033]4;214;rgb:fa/bd/2f\007\033\\"
-    printf "\033Ptmux;\033\033]4;109;rgb:83/a5/98\007\033\\"
-    printf "\033Ptmux;\033\033]4;175;rgb:d3/86/9b\007\033\\"
-    printf "\033Ptmux;\033\033]4;108;rgb:8e/c0/7c\007\033\\"
-    printf "\033Ptmux;\033\033]4;208;rgb:fe/80/19\007\033\\"
-
-    printf "\033Ptmux;\033\033]4;88;rgb:9d/00/06\007\033\\"
-    printf "\033Ptmux;\033\033]4;100;rgb:79/74/0e\007\033\\"
-    printf "\033Ptmux;\033\033]4;136;rgb:b5/76/14\007\033\\"
-    printf "\033Ptmux;\033\033]4;24;rgb:07/66/78\007\033\\"
-    printf "\033Ptmux;\033\033]4;96;rgb:8f/3f/71\007\033\\"
-    printf "\033Ptmux;\033\033]4;66;rgb:42/7b/58\007\033\\"
-    printf "\033Ptmux;\033\033]4;130;rgb:af/3a/03\007\033\\"
-  else
-    printf "\033P\033]4;236;rgb:32/30/2f\007\033\\"
-    printf "\033P\033]4;234;rgb:1d/20/21\007\033\\"
-
-    printf "\033P\033]4;235;rgb:28/28/28\007\033\\"
-    printf "\033P\033]4;237;rgb:3c/38/36\007\033\\"
-    printf "\033P\033]4;239;rgb:50/49/45\007\033\\"
-    printf "\033P\033]4;241;rgb:66/5c/54\007\033\\"
-    printf "\033P\033]4;243;rgb:7c/6f/64\007\033\\"
-
-    printf "\033P\033]4;244;rgb:92/83/74\007\033\\"
-    printf "\033P\033]4;245;rgb:92/83/74\007\033\\"
-
-    printf "\033P\033]4;228;rgb:f2/e5/bc\007\033\\"
-    printf "\033P\033]4;230;rgb:f9/f5/d7\007\033\\"
-
-    printf "\033P\033]4;229;rgb:fb/f1/c7\007\033\\"
-    printf "\033P\033]4;223;rgb:eb/db/b2\007\033\\"
-    printf "\033P\033]4;250;rgb:d5/c4/a1\007\033\\"
-    printf "\033P\033]4;248;rgb:bd/ae/93\007\033\\"
-    printf "\033P\033]4;246;rgb:a8/99/84\007\033\\"
-
-    printf "\033P\033]4;167;rgb:fb/49/34\007\033\\"
-    printf "\033P\033]4;142;rgb:b8/bb/26\007\033\\"
-    printf "\033P\033]4;214;rgb:fa/bd/2f\007\033\\"
-    printf "\033P\033]4;109;rgb:83/a5/98\007\033\\"
-    printf "\033P\033]4;175;rgb:d3/86/9b\007\033\\"
-    printf "\033P\033]4;108;rgb:8e/c0/7c\007\033\\"
-    printf "\033P\033]4;208;rgb:fe/80/19\007\033\\"
-
-    printf "\033P\033]4;88;rgb:9d/00/06\007\033\\"
-    printf "\033P\033]4;100;rgb:79/74/0e\007\033\\"
-    printf "\033P\033]4;136;rgb:b5/76/14\007\033\\"
-    printf "\033P\033]4;24;rgb:07/66/78\007\033\\"
-    printf "\033P\033]4;96;rgb:8f/3f/71\007\033\\"
-    printf "\033P\033]4;66;rgb:42/7b/58\007\033\\"
-    printf "\033P\033]4;130;rgb:af/3a/03\007\033\\"
-  fi
-
-elif [ "$TERM" != "linux" ] && [ "$TERM" != "vt100" ] && [ "$TERM" != "vt220" ]; then
-
-  printf "\033]4;236;rgb:32/30/2f\033\\"
-  printf "\033]4;234;rgb:1d/20/21\033\\"
-
-  printf "\033]4;235;rgb:28/28/28\033\\"
-  printf "\033]4;237;rgb:3c/38/36\033\\"
-  printf "\033]4;239;rgb:50/49/45\033\\"
-  printf "\033]4;241;rgb:66/5c/54\033\\"
-  printf "\033]4;243;rgb:7c/6f/64\033\\"
-
-  printf "\033]4;244;rgb:92/83/74\033\\"
-  printf "\033]4;245;rgb:92/83/74\033\\"
-
-  printf "\033]4;228;rgb:f2/e5/bc\033\\"
-  printf "\033]4;230;rgb:f9/f5/d7\033\\"
-
-  printf "\033]4;229;rgb:fb/f1/c7\033\\"
-  printf "\033]4;223;rgb:eb/db/b2\033\\"
-  printf "\033]4;250;rgb:d5/c4/a1\033\\"
-  printf "\033]4;248;rgb:bd/ae/93\033\\"
-  printf "\033]4;246;rgb:a8/99/84\033\\"
-
-  printf "\033]4;167;rgb:fb/49/34\033\\"
-  printf "\033]4;142;rgb:b8/bb/26\033\\"
-  printf "\033]4;214;rgb:fa/bd/2f\033\\"
-  printf "\033]4;109;rgb:83/a5/98\033\\"
-  printf "\033]4;175;rgb:d3/86/9b\033\\"
-  printf "\033]4;108;rgb:8e/c0/7c\033\\"
-  printf "\033]4;208;rgb:fe/80/19\033\\"
-
-  printf "\033]4;88;rgb:9d/00/06\033\\"
-  printf "\033]4;100;rgb:79/74/0e\033\\"
-  printf "\033]4;136;rgb:b5/76/14\033\\"
-  printf "\033]4;24;rgb:07/66/78\033\\"
-  printf "\033]4;96;rgb:8f/3f/71\033\\"
-  printf "\033]4;66;rgb:42/7b/58\033\\"
-  printf "\033]4;130;rgb:af/3a/03\033\\"
-fi
diff --git a/sources_non_forked/gruvbox/gruvbox_256palette_osx.sh b/sources_non_forked/gruvbox/gruvbox_256palette_osx.sh
deleted file mode 100644
index ad5111a..0000000
--- a/sources_non_forked/gruvbox/gruvbox_256palette_osx.sh
+++ /dev/null
@@ -1,116 +0,0 @@
-#!/bin/sh
-
-if [ "${TERM%%-*}" = "screen" ]; then
-  if [ -n "$TMUX" ]; then
-    printf "\033Ptmux;\033\033]4;236;rgb:26/24/23\007\033\\"
-    printf "\033Ptmux;\033\033]4;234;rgb:16/18/19\007\033\\"
-
-    printf "\033Ptmux;\033\033]4;235;rgb:1e/1e/1e\007\033\\"
-    printf "\033Ptmux;\033\033]4;237;rgb:2e/2a/29\007\033\\"
-    printf "\033Ptmux;\033\033]4;239;rgb:3f/39/35\007\033\\"
-    printf "\033Ptmux;\033\033]4;241;rgb:53/4a/42\007\033\\"
-    printf "\033Ptmux;\033\033]4;243;rgb:68/5c/51\007\033\\"
-
-    printf "\033Ptmux;\033\033]4;244;rgb:7f/70/61\007\033\\"
-    printf "\033Ptmux;\033\033]4;245;rgb:7f/70/61\007\033\\"
-
-    printf "\033Ptmux;\033\033]4;228;rgb:ef/df/ae\007\033\\"
-    printf "\033Ptmux;\033\033]4;230;rgb:f8/f4/cd\007\033\\"
-
-    printf "\033Ptmux;\033\033]4;229;rgb:fa/ee/bb\007\033\\"
-    printf "\033Ptmux;\033\033]4;223;rgb:e6/d4/a3\007\033\\"
-    printf "\033Ptmux;\033\033]4;250;rgb:cb/b8/90\007\033\\"
-    printf "\033Ptmux;\033\033]4;248;rgb:af/9f/81\007\033\\"
-    printf "\033Ptmux;\033\033]4;246;rgb:97/87/71\007\033\\"
-
-    printf "\033Ptmux;\033\033]4;167;rgb:f7/30/28\007\033\\"
-    printf "\033Ptmux;\033\033]4;142;rgb:aa/b0/1e\007\033\\"
-    printf "\033Ptmux;\033\033]4;214;rgb:f7/b1/25\007\033\\"
-    printf "\033Ptmux;\033\033]4;109;rgb:71/95/86\007\033\\"
-    printf "\033Ptmux;\033\033]4;175;rgb:c7/70/89\007\033\\"
-    printf "\033Ptmux;\033\033]4;108;rgb:7d/b6/69\007\033\\"
-    printf "\033Ptmux;\033\033]4;208;rgb:fb/6a/16\007\033\\"
-
-    printf "\033Ptmux;\033\033]4;88;rgb:89/00/09\007\033\\"
-    printf "\033Ptmux;\033\033]4;100;rgb:66/62/0d\007\033\\"
-    printf "\033Ptmux;\033\033]4;136;rgb:a5/63/11\007\033\\"
-    printf "\033Ptmux;\033\033]4;24;rgb:0e/53/65\007\033\\"
-    printf "\033Ptmux;\033\033]4;96;rgb:7b/2b/5e\007\033\\"
-    printf "\033Ptmux;\033\033]4;66;rgb:35/6a/46\007\033\\"
-    printf "\033Ptmux;\033\033]4;130;rgb:9d/28/07\007\033\\"
-  else
-    printf "\033P\033]4;236;rgb:26/24/23\007\033\\"
-    printf "\033P\033]4;234;rgb:16/18/19\007\033\\"
-
-    printf "\033P\033]4;235;rgb:1e/1e/1e\007\033\\"
-    printf "\033P\033]4;237;rgb:2e/2a/29\007\033\\"
-    printf "\033P\033]4;239;rgb:3f/39/35\007\033\\"
-    printf "\033P\033]4;241;rgb:53/4a/42\007\033\\"
-    printf "\033P\033]4;243;rgb:68/5c/51\007\033\\"
-
-    printf "\033P\033]4;244;rgb:7f/70/61\007\033\\"
-    printf "\033P\033]4;245;rgb:7f/70/61\007\033\\"
-
-    printf "\033P\033]4;228;rgb:ef/df/ae\007\033\\"
-    printf "\033P\033]4;230;rgb:f8/f4/cd\007\033\\"
-
-    printf "\033P\033]4;229;rgb:fa/ee/bb\007\033\\"
-    printf "\033P\033]4;223;rgb:e6/d4/a3\007\033\\"
-    printf "\033P\033]4;250;rgb:cb/b8/90\007\033\\"
-    printf "\033P\033]4;248;rgb:af/9f/81\007\033\\"
-    printf "\033P\033]4;246;rgb:97/87/71\007\033\\"
-
-    printf "\033P\033]4;167;rgb:f7/30/28\007\033\\"
-    printf "\033P\033]4;142;rgb:aa/b0/1e\007\033\\"
-    printf "\033P\033]4;214;rgb:f7/b1/25\007\033\\"
-    printf "\033P\033]4;109;rgb:71/95/86\007\033\\"
-    printf "\033P\033]4;175;rgb:c7/70/89\007\033\\"
-    printf "\033P\033]4;108;rgb:7d/b6/69\007\033\\"
-    printf "\033P\033]4;208;rgb:fb/6a/16\007\033\\"
-
-    printf "\033P\033]4;88;rgb:89/00/09\007\033\\"
-    printf "\033P\033]4;100;rgb:66/62/0d\007\033\\"
-    printf "\033P\033]4;136;rgb:a5/63/11\007\033\\"
-    printf "\033P\033]4;24;rgb:0e/53/65\007\033\\"
-    printf "\033P\033]4;96;rgb:7b/2b/5e\007\033\\"
-    printf "\033P\033]4;66;rgb:35/6a/46\007\033\\"
-    printf "\033P\033]4;130;rgb:9d/28/07\007\033\\"
-  fi
-else
-  printf "\033]4;236;rgb:26/24/23\033\\"
-  printf "\033]4;234;rgb:16/18/19\033\\"
-
-  printf "\033]4;235;rgb:1e/1e/1e\033\\"
-  printf "\033]4;237;rgb:2e/2a/29\033\\"
-  printf "\033]4;239;rgb:3f/39/35\033\\"
-  printf "\033]4;241;rgb:53/4a/42\033\\"
-  printf "\033]4;243;rgb:68/5c/51\033\\"
-
-  printf "\033]4;244;rgb:7f/70/61\033\\"
-  printf "\033]4;245;rgb:7f/70/61\033\\"
-
-  printf "\033]4;228;rgb:ef/df/ae\033\\"
-  printf "\033]4;230;rgb:f8/f4/cd\033\\"
-
-  printf "\033]4;229;rgb:fa/ee/bb\033\\"
-  printf "\033]4;223;rgb:e6/d4/a3\033\\"
-  printf "\033]4;250;rgb:cb/b8/90\033\\"
-  printf "\033]4;248;rgb:af/9f/81\033\\"
-  printf "\033]4;246;rgb:97/87/71\033\\"
-
-  printf "\033]4;167;rgb:f7/30/28\033\\"
-  printf "\033]4;142;rgb:aa/b0/1e\033\\"
-  printf "\033]4;214;rgb:f7/b1/25\033\\"
-  printf "\033]4;109;rgb:71/95/86\033\\"
-  printf "\033]4;175;rgb:c7/70/89\033\\"
-  printf "\033]4;108;rgb:7d/b6/69\033\\"
-  printf "\033]4;208;rgb:fb/6a/16\033\\"
-
-  printf "\033]4;88;rgb:89/00/09\033\\"
-  printf "\033]4;100;rgb:66/62/0d\033\\"
-  printf "\033]4;136;rgb:a5/63/11\033\\"
-  printf "\033]4;24;rgb:0e/53/65\033\\"
-  printf "\033]4;96;rgb:7b/2b/5e\033\\"
-  printf "\033]4;66;rgb:35/6a/46\033\\"
-  printf "\033]4;130;rgb:9d/28/07\033\\"
-fi
diff --git a/sources_non_forked/gruvbox/package.json b/sources_non_forked/gruvbox/package.json
deleted file mode 100644
index 355c180..0000000
--- a/sources_non_forked/gruvbox/package.json
+++ /dev/null
@@ -1,10 +0,0 @@
-{
-  "name": "gruvbox",
-  "version": "2.0.0",
-  "repository": "git@github.com:morhetz/gruvbox.git",
-  "author": "Pavel Pertsev <morhetz@gmail.com>",
-  "license": "MIT",
-  "vim": {
-    "opt": true
-  }
-}
diff --git a/sources_non_forked/lightline-ale/LICENSE b/sources_non_forked/lightline-ale/LICENSE
deleted file mode 100644
index a69d886..0000000
--- a/sources_non_forked/lightline-ale/LICENSE
+++ /dev/null
@@ -1,21 +0,0 @@
-MIT License
-
-Copyright (c) 2017 Maxim Baz
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in all
-copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-SOFTWARE.
diff --git a/sources_non_forked/lightline-ale/README.md b/sources_non_forked/lightline-ale/README.md
deleted file mode 100644
index ebfbc7e..0000000
--- a/sources_non_forked/lightline-ale/README.md
+++ /dev/null
@@ -1,111 +0,0 @@
-# lightline-ale
-
-This plugin provides [ALE](https://github.com/w0rp/ale) indicator for the [lightline](https://github.com/itchyny/lightline.vim) vim plugin.
-
-![screenshot](./screenshot.png)
-
-## Table Of Contents
-
-* [Installation](#installation)
-* [Integration](#integration)
-* [Configuration](#configuration)
-* [License](#license)
-
-## Installation
-
-Install using a plugin manager of your choice, for example:
-
-```viml
-call dein#add('w0rp/ale')                 " Dependency: linter
-call dein#add('itchyny/lightline.vim')    " Dependency: status line
-call dein#add('maximbaz/lightline-ale')
-```
-
-## Integration
-
-1. Register the components:
-
-```viml
-let g:lightline = {}
-
-let g:lightline.component_expand = {
-      \  'linter_checking': 'lightline#ale#checking',
-      \  'linter_infos': 'lightline#ale#infos',
-      \  'linter_warnings': 'lightline#ale#warnings',
-      \  'linter_errors': 'lightline#ale#errors',
-      \  'linter_ok': 'lightline#ale#ok',
-      \ }
-```
-
-2. Set color to the components:
-
-```viml
-let g:lightline.component_type = {
-      \     'linter_checking': 'right',
-      \     'linter_infos': 'right',
-      \     'linter_warnings': 'warning',
-      \     'linter_errors': 'error',
-      \     'linter_ok': 'right',
-      \ }
-```
-
-3. Add the components to the lightline, for example to the right side:
-
-```viml
-let g:lightline.active = { 'right': [[ 'linter_checking', 'linter_errors', 'linter_warnings', 'linter_infos', 'linter_ok' ]] }
-```
-
-## Configuration
-
-##### `g:lightline#ale#indicator_checking`
-
-The indicator to use when ALE is in progress. Default is `Linting...`.
-
-##### `g:lightline#ale#indicator_infos`
-
-The indicator to use when there are infos. Default is `I:`.
-
-##### `g:lightline#ale#indicator_warnings`
-
-The indicator to use when there are warnings. Default is `W:`.
-
-##### `g:lightline#ale#indicator_errors`
-
-The indicator to use when there are errors. Default is `E:`.
-
-##### `g:lightline#ale#indicator_ok`
-
-The indicator to use when there are no warnings or errors. Default is `OK`.
-
-### Using icons as indicators
-
-If you would like to replace the default indicators with symbols like on the screenshot, then you'll need to ensure you have some "iconic fonts" installed, such as [Font Awesome](https://fontawesome.com). A common alternative is to replace your primary font with one of the [Patched Nerd Fonts](https://github.com/ryanoasis/nerd-fonts), which saves you from having to install multiple fonts.
-
-The following icons from the Font Awesome font are used in the screenshot:
-
-* Checking: [f110](https://fontawesome.com/icons/spinner)
-* Infos: [f129](https://fontawesome.com/icons/info)
-* Warnings: [f071](https://fontawesome.com/icons/exclamation-triangle)
-* Errors: [f05e](https://fontawesome.com/icons/ban)
-* OK: [f00c](https://fontawesome.com/icons/check) (although I prefer to disable this component)
-
-To specify icons in the configuration, use their unicode codes as `"\uXXXX"` (make sure to wrap them in double quotes). Alternatively copy the icons from a font website, or type <kbd>\<C-v\>u\<4-digit-unicode\></kbd> or <kbd>\<C-v\>U\<8-digit-unicode\></kbd> to insert the literal characters.
-
-See the code points here:
-
-* Font Awesome: https://fontawesome.com/icons
-* Nerd Fonts: https://github.com/ryanoasis/nerd-fonts#glyph-sets
-
-Here's the configuration snippet used in the screenshot:
-
-```viml
-let g:lightline#ale#indicator_checking = "\uf110"
-let g:lightline#ale#indicator_infos = "\uf129"
-let g:lightline#ale#indicator_warnings = "\uf071"
-let g:lightline#ale#indicator_errors = "\uf05e"
-let g:lightline#ale#indicator_ok = "\uf00c"
-```
-
-## License
-
-Released under the [MIT License](LICENSE)
diff --git a/sources_non_forked/lightline-ale/autoload/lightline/ale.vim b/sources_non_forked/lightline-ale/autoload/lightline/ale.vim
deleted file mode 100644
index c04f5ab..0000000
--- a/sources_non_forked/lightline-ale/autoload/lightline/ale.vim
+++ /dev/null
@@ -1,58 +0,0 @@
-let s:indicator_infos = get(g:, 'lightline#ale#indicator_infos', 'I: ')
-let s:indicator_warnings = get(g:, 'lightline#ale#indicator_warnings', 'W: ')
-let s:indicator_errors = get(g:, 'lightline#ale#indicator_errors', 'E: ')
-let s:indicator_ok = get(g:, 'lightline#ale#indicator_ok', 'OK')
-let s:indicator_checking = get(g:, 'lightline#ale#indicator_checking', 'Linting...')
-
-
-""""""""""""""""""""""
-" Lightline components
-
-function! lightline#ale#infos() abort
-  if !lightline#ale#linted()
-    return ''
-  endif
-  let l:counts = ale#statusline#Count(bufnr(''))
-  return l:counts.info == 0 ? '' : printf(s:indicator_infos . '%d', l:counts.info)
-endfunction
-
-function! lightline#ale#warnings() abort
-  if !lightline#ale#linted()
-    return ''
-  endif
-  let l:counts = ale#statusline#Count(bufnr(''))
-  let l:all_warnings = l:counts.warning + l:counts.style_warning
-  return l:all_warnings == 0 ? '' : printf(s:indicator_warnings . '%d', all_warnings)
-endfunction
-
-function! lightline#ale#errors() abort
-  if !lightline#ale#linted()
-    return ''
-  endif
-  let l:counts = ale#statusline#Count(bufnr(''))
-  let l:all_errors = l:counts.error + l:counts.style_error
-  return l:all_errors == 0 ? '' : printf(s:indicator_errors . '%d', all_errors)
-endfunction
-
-function! lightline#ale#ok() abort
-  if !lightline#ale#linted()
-    return ''
-  endif
-  let l:counts = ale#statusline#Count(bufnr(''))
-  return l:counts.total == 0 ? s:indicator_ok : ''
-endfunction
-
-function! lightline#ale#checking() abort
-  return ale#engine#IsCheckingBuffer(bufnr('')) ? s:indicator_checking : ''
-endfunction
-
-
-""""""""""""""""""
-" Helper functions
-
-function! lightline#ale#linted() abort
-  return get(g:, 'ale_enabled', 0) == 1
-    \ && getbufvar(bufnr(''), 'ale_enabled', 1)
-    \ && getbufvar(bufnr(''), 'ale_linted', 0) > 0
-    \ && ale#engine#IsCheckingBuffer(bufnr('')) == 0
-endfunction
diff --git a/sources_non_forked/lightline-ale/plugin/lightline/ale.vim b/sources_non_forked/lightline-ale/plugin/lightline/ale.vim
deleted file mode 100644
index fe0237c..0000000
--- a/sources_non_forked/lightline-ale/plugin/lightline/ale.vim
+++ /dev/null
@@ -1,6 +0,0 @@
-augroup lightline#ale
-  autocmd!
-  autocmd User ALEJobStarted call lightline#update()
-  autocmd User ALELintPost call lightline#update()
-  autocmd User ALEFixPost call lightline#update()
-augroup END
diff --git a/sources_non_forked/lightline-ale/screenshot.png b/sources_non_forked/lightline-ale/screenshot.png
deleted file mode 100644
index 642caea..0000000
Binary files a/sources_non_forked/lightline-ale/screenshot.png and /dev/null differ
diff --git a/sources_non_forked/lightline.vim/.github/workflows/ci.yaml b/sources_non_forked/lightline.vim/.github/workflows/ci.yaml
deleted file mode 100644
index b5db7ce..0000000
--- a/sources_non_forked/lightline.vim/.github/workflows/ci.yaml
+++ /dev/null
@@ -1,38 +0,0 @@
-name: CI
-
-on:
-  push:
-    branches:
-    - master
-  pull_request:
-
-jobs:
-  test:
-    name: Test
-    runs-on: ubuntu-latest
-    strategy:
-      matrix:
-        vim:
-        - v8.2.1000
-        - v8.2.0000
-        - v8.1.0000
-        - v8.0.0000
-        - v7.4
-        - v7.3
-    steps:
-    - name: Checkout code
-      uses: actions/checkout@master
-    - name: Checkout vim-themis
-      uses: actions/checkout@master
-      with:
-        repository: thinca/vim-themis
-        path: vim-themis
-    - name: Setup Vim
-      uses: rhysd/action-setup-vim@v1
-      id: vim
-      with:
-        version: ${{ matrix.vim }}
-    - name: Test
-      env:
-        THEMIS_VIM: ${{ steps.vim.outputs.executable }}
-      run: ./vim-themis/bin/themis --reporter spec
diff --git a/sources_non_forked/lightline.vim/.gitignore b/sources_non_forked/lightline.vim/.gitignore
deleted file mode 100644
index 0a56e3f..0000000
--- a/sources_non_forked/lightline.vim/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-/doc/tags
diff --git a/sources_non_forked/lightline.vim/LICENSE b/sources_non_forked/lightline.vim/LICENSE
deleted file mode 100644
index ee9e0c8..0000000
--- a/sources_non_forked/lightline.vim/LICENSE
+++ /dev/null
@@ -1,21 +0,0 @@
-The MIT License (MIT)
-
-Copyright (c) 2013-2020 itchyny
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in all
-copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-SOFTWARE.
diff --git a/sources_non_forked/lightline.vim/README.md b/sources_non_forked/lightline.vim/README.md
deleted file mode 100644
index 583f02e..0000000
--- a/sources_non_forked/lightline.vim/README.md
+++ /dev/null
@@ -1,447 +0,0 @@
-# lightline.vim
-A light and configurable statusline/tabline plugin for Vim
-
-https://github.com/itchyny/lightline.vim
-
-### powerline (default)
-
-![lightline.vim - powerline](https://raw.githubusercontent.com/wiki/itchyny/lightline.vim/image/powerline.png)
-
-### wombat
-
-![lightline.vim - wombat](https://raw.githubusercontent.com/wiki/itchyny/lightline.vim/image/wombat.png)
-
-### jellybeans
-
-![lightline.vim - jellybeans](https://raw.githubusercontent.com/wiki/itchyny/lightline.vim/image/jellybeans.png)
-
-### solarized dark
-
-![lightline.vim - solarized dark](https://raw.githubusercontent.com/wiki/itchyny/lightline.vim/image/solarized_dark.png)
-
-### solarized light
-
-![lightline.vim - solarized light](https://raw.githubusercontent.com/wiki/itchyny/lightline.vim/image/solarized_light.png)
-
-### PaperColor dark
-
-![lightline.vim - PaperColor dark](https://raw.githubusercontent.com/wiki/itchyny/lightline.vim/image/PaperColor_dark.png)
-
-### PaperColor light
-
-![lightline.vim - PaperColor light](https://raw.githubusercontent.com/wiki/itchyny/lightline.vim/image/PaperColor_light.png)
-
-### seoul256
-
-![lightline.vim - seoul256](https://raw.githubusercontent.com/wiki/itchyny/lightline.vim/image/seoul256.png)
-
-### one dark
-
-![lightline.vim - one dark](https://raw.githubusercontent.com/wiki/itchyny/lightline.vim/image/one_dark.png)
-
-### one light
-
-![lightline.vim - one light](https://raw.githubusercontent.com/wiki/itchyny/lightline.vim/image/one_light.png)
-
-### landscape
-
-![lightline.vim - landscape](https://raw.githubusercontent.com/wiki/itchyny/lightline.vim/image/landscape.png)
-
-landscape is my colorscheme, which is a high-contrast cterm-supported colorscheme, available at https://github.com/itchyny/landscape.vim
-
-
-For screenshots of all available colorshemes, see [this file](colorscheme.md).
-
-## Why yet another clone of powerline?
-+ [vim-powerline](https://github.com/Lokaltog/vim-powerline) is a nice plugin, but deprecated.
-+ [powerline](https://github.com/powerline/powerline) is a nice plugin, but difficult to configure.
-+ [vim-airline](https://github.com/vim-airline/vim-airline) is a nice plugin, but it uses too many functions of other plugins, which should be done by users in `.vimrc`.
-
-## Spirit of this plugin
-+ Minimalism. The core script is very small to achieve enough functions as a statusline plugin.
-+ Configurability. You can create your own component and easily add to the statusline and the tabline.
-+ Orthogonality. The plugin does not rely on the implementation of other plugins. Such plugin crossing settings should be configured by users.
-
-## Installation
-### [Vim packages](http://vimhelp.appspot.com/repeat.txt.html#packages) (since Vim 7.4.1528)
-
-        git clone https://github.com/itchyny/lightline.vim ~/.vim/pack/plugins/start/lightline
-
-### [Pathogen](https://github.com/tpope/vim-pathogen)
-1. Install with the following command.
-
-        git clone https://github.com/itchyny/lightline.vim ~/.vim/bundle/lightline.vim
-
-2. Generate help tags with `:Helptags`.
-
-### [Vundle](https://github.com/VundleVim/Vundle.vim)
-1. Add the following configuration to your `.vimrc`.
-
-        Plugin 'itchyny/lightline.vim'
-
-2. Install with `:PluginInstall`.
-
-### [NeoBundle](https://github.com/Shougo/neobundle.vim)
-1. Add the following configuration to your `.vimrc`.
-
-        NeoBundle 'itchyny/lightline.vim'
-
-2. Install with `:NeoBundleInstall`.
-
-### [vim-plug](https://github.com/junegunn/vim-plug)
-1. Add the following configuration to your `.vimrc`.
-
-        Plug 'itchyny/lightline.vim'
-
-2. Install with `:PlugInstall`.
-
-### [dein.vim](https://github.com/Shougo/dein.vim)
-1. Add the following configuration to your `.vimrc`.
-
-        call dein#add('itchyny/lightline.vim')
-
-2. Install with `:call dein#install()`
-
-## Introduction
-After installing this plugin, you restart the editor and will get a cool statusline.
-![lightline.vim - tutorial](https://raw.githubusercontent.com/wiki/itchyny/lightline.vim/image/tutorial/1.png)
-
-The color of the statusline changes due to the mode of Vim. Try typing something, selecting in visual mode and replacing some texts.
-
-If the statusline looks like
-![lightline.vim - tutorial](https://raw.githubusercontent.com/wiki/itchyny/lightline.vim/image/tutorial/21.png)
-
-add the following configuration to your `.vimrc`.
-```vim
-set laststatus=2
-```
-
-If the statusline is not coloured like
-![lightline.vim - tutorial](https://raw.githubusercontent.com/wiki/itchyny/lightline.vim/image/tutorial/20.png)
-
-then modify `TERM` in your shell configuration (`.zshrc` for example)
-```sh
-export TERM=xterm-256color
-```
-and then add the following configuration to your `.vimrc`.
-```vim
-if !has('gui_running')
-  set t_Co=256
-endif
-```
-
-Your statusline appears to work correctly? If yes, great, thanks for choosing lightline.vim! If no, please file an issue report to the [issue tracker](https://github.com/itchyny/lightline.vim/issues).
-
-By the way, `-- INSERT --` is unnecessary anymore because the mode information is displayed in the statusline.
-![lightline.vim - tutorial](https://raw.githubusercontent.com/wiki/itchyny/lightline.vim/image/tutorial/13.png)
-If you want to get rid of it, configure as follows.
-```vim
-set noshowmode
-```
-
-## Colorscheme configuration
-The lightline.vim plugin provides multiple colorschemes to meet your editor colorscheme.
-Do not be confused, editor colorscheme rules how codes look like in buffers and lightline.vim has independent colorscheme feature, which rules how the statusline looks like.
-
-If you are using wombat colorscheme, add the following setting to your `.vimrc`,
-```vim
-let g:lightline = {
-      \ 'colorscheme': 'wombat',
-      \ }
-```
-restart Vim and the statusline looks like:
-
-![lightline.vim - tutorial](https://raw.githubusercontent.com/wiki/itchyny/lightline.vim/image/tutorial/2.png)
-
-If the colors of the statusline do not change, move the settings of `g:lightline` before setting the editor colorscheme.
-
-There are many lightline colorschemes available as screenshots shown above. See `:h g:lightline.colorscheme` for the complete list.
-
-## Advanced configuration
-The default appearance of lightline.vim is carefully designed that the tutorial is enough here for most people.
-So please read this section if you really want to configure and enjoy the configurability of lightline.vim.
-
-Sometimes people want to display information of other plugins.
-For example git branch information, syntax check errors and some statuses of plugins.
-
-The lightline.vim plugin does not provide any plugin integration by default.
-This plugin considers orthogonality to be one of the important ideas, which means that the plugin does not rely on implementation of other plugins.
-Once a plugin starts to integrate with some famous plugins, it should be kept updated to follow the changes of the plugins, and should accept integration requests with new plugins and it will suffer from performance regression due to plugin availability checks.
-
-Instead, lightline.vim provides a simple API that user can easily integrate with other plugins.
-Once you understand how to configure and how it will be displayed in the statusline, you can also tell how to integrate with your favorite plugins.
-
-Let's start to configure the appearance.
-The statusline is composed of multiple components.
-It shows the current mode, filename, modified status on the left, and file format, encoding, filetype and cursor positions on the right.
-So in order to add something in the statusline, you firstly create a new component and specify the place.
-
-This is the hello world of lightline.vim component.
-```vim
-let g:lightline = {
-      \ 'colorscheme': 'wombat',
-      \ 'active': {
-      \   'left': [ [ 'mode', 'paste' ],
-      \             [ 'readonly', 'filename', 'modified', 'helloworld' ] ]
-      \ },
-      \ 'component': {
-      \   'helloworld': 'Hello, world!'
-      \ },
-      \ }
-```
-The statusline will look like:
-![lightline.vim - tutorial](https://raw.githubusercontent.com/wiki/itchyny/lightline.vim/image/tutorial/3.png)
-
-You have succeeded in displaying `Hello, world!` in the statusline.
-The `helloworld` component is added to `g:lightline.active.left` and its content is configured in `g:lightline.component`.
-The component contents are simply added to `&statusline`.
-Try `:echo &statusline`, it might be a little bit complicated, but you will find `Hello, world!` somewhere.
-
-You can use `'statusline'` syntax for lightline.vim components.
-Consult `:h 'statusline'` to see what's available here.
-For example, if you want to print the value of character under the cursor in hexadecimal, configure as
-```vim
-let g:lightline = {
-      \ 'colorscheme': 'wombat',
-      \ 'active': {
-      \   'left': [ [ 'mode', 'paste' ],
-      \             [ 'readonly', 'filename', 'modified', 'charvaluehex' ] ]
-      \ },
-      \ 'component': {
-      \   'charvaluehex': '0x%B'
-      \ },
-      \ }
-```
-![lightline.vim - tutorial](https://raw.githubusercontent.com/wiki/itchyny/lightline.vim/image/tutorial/4.png)
-
-You want the character value information on the right hand side? OK, configure as
-```vim
-let g:lightline = {
-      \ 'colorscheme': 'wombat',
-      \ 'active': {
-      \   'right': [ [ 'lineinfo' ],
-      \              [ 'percent' ],
-      \              [ 'fileformat', 'fileencoding', 'filetype', 'charvaluehex' ] ]
-      \ },
-      \ 'component': {
-      \   'charvaluehex': '0x%B'
-      \ },
-      \ }
-```
-![lightline.vim - tutorial](https://raw.githubusercontent.com/wiki/itchyny/lightline.vim/image/tutorial/5.png)
-
-We have learned how to add a simple component.
-
-- See `:h 'statusline'` to check the statusline flags.
-- Add a new component to `g:lightline.component`.
-- Add the component name to `g:lightline.active.left` or `g:lightline.active.right`.
-
-You can also configure the statusline of inactive buffers by adding the component to `g:lightline.inactive.left` or `g:lightline.inactive.right`.
-
-
-Now let's add some integrations with other plugin.
-The name of the git branch is important these days.
-But lightline.vim does not provide this information by default because it is also one of plugin crossing configurations, and not all people want the integration.
-
-In order to show the branch name in the statusline, install some plugins which provide the branch information.
-The [vim-fugitive](https://github.com/tpope/vim-fugitive) plugin is a famous plugin so let's integrate lightline.vim with it.
-If you don't like to install full git integration but just want to display the branch name in the statusline, you can use the [vim-gitbranch](https://github.com/itchyny/vim-gitbranch) plugin which provides `gitbranch#name` function.
-```vim
-let g:lightline = {
-      \ 'colorscheme': 'wombat',
-      \ 'active': {
-      \   'left': [ [ 'mode', 'paste' ],
-      \             [ 'gitbranch', 'readonly', 'filename', 'modified' ] ]
-      \ },
-      \ 'component_function': {
-      \   'gitbranch': 'FugitiveHead'
-      \ },
-      \ }
-```
-![lightline.vim - tutorial](https://raw.githubusercontent.com/wiki/itchyny/lightline.vim/image/tutorial/6.png)
-
-Okay, now the statusline shows that we are coding at the master branch.
-What do we learn from this example?
-
-- Find out the function which is suitable to use in the statusline.
-- Create a function component. The previous `charvaluehex` component has `'statusline'` item configuration and registered in `g:lightline.component`. In the current example, we register the name of the function in `g:lightline.component_function`. It should return the string to be displayed in the statusline.
-- Add the component name `gitbranch` to `g:lightline.active.left` or `g:lightline.active.right`.
-
-
-Here we have leaned two kinds of components.
-
-- component: it has a `%`-prefixed item which you can find the meaning at `:h 'statusline'`. All the default components of lightline.vim are components in this style. See the default components at `:h g:lightline.component`.
-- function component: the name of functions are registered. The function is called again and again so be careful not to register a heavy function. See the help with `:h g:lightline.component_function`.
-
-
-The function component is an important design for the configurability of lightline.vim.
-By providing the configuration interface via functions, you can adjust the statusline information as you wish.
-For the proof, let's look into some configuration examples in Q&amp;A style.
-
-### Can I hide the readonly component in the help buffer?
-Yes, create a function component for `readonly`.
-The configuration of function component has priority over the default component.
-```vim
-let g:lightline = {
-      \ 'component_function': {
-      \   'readonly': 'LightlineReadonly',
-      \ },
-      \ }
-
-function! LightlineReadonly()
-  return &readonly && &filetype !=# 'help' ? 'RO' : ''
-endfunction
-```
-![lightline.vim - tutorial](https://raw.githubusercontent.com/wiki/itchyny/lightline.vim/image/tutorial/7.png)
-
-### Can I hide the readonly component in other plugins buffer?
-Yes, modify the `LightlineReadonly` function as you wish.
-```vim
-function! LightlineReadonly()
-  return &readonly && &filetype !~# '\v(help|vimfiler|unite)' ? 'RO' : ''
-endfunction
-
-let g:unite_force_overwrite_statusline = 0
-let g:vimfiler_force_overwrite_statusline = 0
-```
-![lightline.vim - tutorial](https://raw.githubusercontent.com/wiki/itchyny/lightline.vim/image/tutorial/8.png)
-
-### Can I display the plugin information at the filename component?
-Yes, overwrite the filename component.
-```vim
-let g:lightline = {
-      \ 'component_function': {
-      \   'filename': 'LightlineFilename',
-      \ },
-      \ }
-
-function! LightlineFilename()
-  return &filetype ==# 'vimfiler' ? vimfiler#get_status_string() :
-        \ &filetype ==# 'unite' ? unite#get_status_string() :
-        \ &filetype ==# 'vimshell' ? vimshell#get_status_string() :
-        \ expand('%:t') !=# '' ? expand('%:t') : '[No Name]'
-endfunction
-
-let g:unite_force_overwrite_statusline = 0
-let g:vimfiler_force_overwrite_statusline = 0
-let g:vimshell_force_overwrite_statusline = 0
-```
-![lightline.vim - tutorial](https://raw.githubusercontent.com/wiki/itchyny/lightline.vim/image/tutorial/9.png)
-
-### Can I display the plugin name at the mode component?
-Yes, overwrite the mode component.
-```vim
-let g:lightline = {
-      \ 'component_function': {
-      \   'mode': 'LightlineMode',
-      \ },
-      \ }
-
-function! LightlineMode()
-  return expand('%:t') =~# '^__Tagbar__' ? 'Tagbar':
-        \ expand('%:t') ==# 'ControlP' ? 'CtrlP' :
-        \ &filetype ==# 'unite' ? 'Unite' :
-        \ &filetype ==# 'vimfiler' ? 'VimFiler' :
-        \ &filetype ==# 'vimshell' ? 'VimShell' :
-        \ lightline#mode()
-endfunction
-```
-![lightline.vim - tutorial](https://raw.githubusercontent.com/wiki/itchyny/lightline.vim/image/tutorial/10.png)
-
-### Can I trim the file format and encoding information on narrow windows?
-Yes, check `winwidth(0)` and return empty string with some threshold.
-```vim
-let g:lightline = {
-      \ 'component_function': {
-      \   'fileformat': 'LightlineFileformat',
-      \   'filetype': 'LightlineFiletype',
-      \ },
-      \ }
-
-function! LightlineFileformat()
-  return winwidth(0) > 70 ? &fileformat : ''
-endfunction
-
-function! LightlineFiletype()
-  return winwidth(0) > 70 ? (&filetype !=# '' ? &filetype : 'no ft') : ''
-endfunction
-```
-![lightline.vim - tutorial](https://raw.githubusercontent.com/wiki/itchyny/lightline.vim/image/tutorial/11.png)
-
-### Can I trim the bar between the filename and modified sign?
-Yes, by joining the two components.
-```vim
-let g:lightline = {
-      \ 'active': {
-      \   'left': [ [ 'mode', 'paste' ],
-      \             [ 'readonly', 'filename' ] ],
-      \ },
-      \ 'component_function': {
-      \   'filename': 'LightlineFilename',
-      \ },
-      \ }
-
-function! LightlineFilename()
-  let filename = expand('%:t') !=# '' ? expand('%:t') : '[No Name]'
-  let modified = &modified ? ' +' : ''
-  return filename . modified
-endfunction
-```
-![lightline.vim - tutorial](https://raw.githubusercontent.com/wiki/itchyny/lightline.vim/image/tutorial/12.png)
-
-You can control the visibility and contents by writing simple functions.
-Now you notice how much function component is important for the configurability of lightline.vim.
-
-### more tips
-#### Mode names are too long. Can I use shorter mode names?
-Yes, configure `g:lightline.mode_map`.
-```vim
-let g:lightline = {
-      \ 'mode_map': {
-        \ 'n' : 'N',
-        \ 'i' : 'I',
-        \ 'R' : 'R',
-        \ 'v' : 'V',
-        \ 'V' : 'VL',
-        \ "\<C-v>": 'VB',
-        \ 'c' : 'C',
-        \ 's' : 'S',
-        \ 'S' : 'SL',
-        \ "\<C-s>": 'SB',
-        \ 't': 'T',
-        \ },
-      \ }
-```
-
-#### How can I truncate the components from the right in narrow windows?
-Please include `%<` to one of the right components.
-```vim
-let g:lightline = {
-      \ 'component': {
-      \   'lineinfo': '%3l:%-2v%<',
-      \ },
-      \ }
-```
-
-#### Where can I find the default components?
-See `:h g:lightline.component`.
-
-## Note for developers of other plugins
-Appearance consistency matters.
-
-The statusline is an important space for Vim users.
-Overwriting the statusline forcibly in your plugin is not a good idea.
-It is not hospitality, but just an annoying feature.
-If your plugin has such a feature, add an option to be modest.
-
-A good design is as follows.
-Firstly, give the users a clue to judge which buffer is the one your plugin creates.
-The filename is a manner and the filetype is another.
-Then, export a function which is useful to be shown in the statusline.
-Lastly, for advanced users, set important information in buffer variables so that the users can obtain the condition of the plugin easily.
-
-## Author
-itchyny (https://github.com/itchyny)
-
-## License
-This software is released under the MIT License, see LICENSE.
diff --git a/sources_non_forked/lightline.vim/autoload/lightline.vim b/sources_non_forked/lightline.vim/autoload/lightline.vim
deleted file mode 100644
index e85e589..0000000
--- a/sources_non_forked/lightline.vim/autoload/lightline.vim
+++ /dev/null
@@ -1,500 +0,0 @@
-" =============================================================================
-" Filename: autoload/lightline.vim
-" Author: itchyny
-" License: MIT License
-" Last Change: 2020/06/19 11:08:46.
-" =============================================================================
-
-let s:save_cpo = &cpo
-set cpo&vim
-
-let s:_ = 1 " 1: uninitialized, 2: disabled
-
-function! lightline#update() abort
-  if s:skip() | return | endif
-  if s:_
-    if s:_ == 2 | return | endif
-    call lightline#init()
-    call lightline#colorscheme()
-  endif
-  if s:lightline.enable.statusline
-    let w = winnr()
-    let s = winnr('$') == 1 && w > 0 ? [lightline#statusline(0)] : [lightline#statusline(0), lightline#statusline(1)]
-    for n in range(1, winnr('$'))
-      call setwinvar(n, '&statusline', s[n!=w])
-    endfor
-  endif
-endfunction
-
-if exists('*win_gettype')
-  function! s:skip() abort " Vim 8.2.0257 (00f3b4e007), 8.2.0991 (0fe937fd86), 8.2.0996 (40a019f157)
-    return win_gettype() ==# 'popup' || win_gettype() ==# 'autocmd'
-  endfunction
-else
-  function! s:skip() abort
-    return &buftype ==# 'popup'
-  endfunction
-endif
-
-function! lightline#update_disable() abort
-  if s:lightline.enable.statusline
-    call setwinvar(0, '&statusline', '')
-  endif
-endfunction
-
-function! lightline#enable() abort
-  let s:_ = 1
-  call lightline#update()
-  augroup lightline
-    autocmd!
-    autocmd WinEnter,BufEnter,BufDelete,SessionLoadPost,FileChangedShellPost * call lightline#update()
-    if !has('patch-8.1.1715')
-      autocmd FileType qf call lightline#update()
-    endif
-    autocmd SessionLoadPost * call lightline#highlight()
-    autocmd ColorScheme * if !has('vim_starting') || expand('<amatch>') !=# 'macvim'
-          \ | call lightline#update() | call lightline#highlight() | endif
-  augroup END
-  augroup lightline-disable
-    autocmd!
-  augroup END
-  augroup! lightline-disable
-endfunction
-
-function! lightline#disable() abort
-  let [&statusline, &tabline] = [get(s:, '_statusline', ''), get(s:, '_tabline', '')]
-  for t in range(1, tabpagenr('$'))
-    for n in range(1, tabpagewinnr(t, '$'))
-      call settabwinvar(t, n, '&statusline', '')
-    endfor
-  endfor
-  augroup lightline
-    autocmd!
-  augroup END
-  augroup! lightline
-  augroup lightline-disable
-    autocmd!
-    autocmd WinEnter * call lightline#update_disable()
-  augroup END
-  let s:_ = 2
-endfunction
-
-function! lightline#toggle() abort
-  if exists('#lightline')
-    call lightline#disable()
-  else
-    call lightline#enable()
-  endif
-endfunction
-
-let s:_lightline = {
-      \   'active': {
-      \     'left': [['mode', 'paste'], ['readonly', 'filename', 'modified']],
-      \     'right': [['lineinfo'], ['percent'], ['fileformat', 'fileencoding', 'filetype']]
-      \   },
-      \   'inactive': {
-      \     'left': [['filename']],
-      \     'right': [['lineinfo'], ['percent']]
-      \   },
-      \   'tabline': {
-      \     'left': [['tabs']],
-      \     'right': [['close']]
-      \   },
-      \   'tab': {
-      \     'active': ['tabnum', 'filename', 'modified'],
-      \     'inactive': ['tabnum', 'filename', 'modified']
-      \   },
-      \   'component': {
-      \     'mode': '%{lightline#mode()}',
-      \     'absolutepath': '%F', 'relativepath': '%f', 'filename': '%t', 'modified': '%M', 'bufnum': '%n',
-      \     'paste': '%{&paste?"PASTE":""}', 'readonly': '%R', 'charvalue': '%b', 'charvaluehex': '%B',
-      \     'spell': '%{&spell?&spelllang:""}', 'fileencoding': '%{&fenc!=#""?&fenc:&enc}', 'fileformat': '%{&ff}',
-      \     'filetype': '%{&ft!=#""?&ft:"no ft"}', 'percent': '%3p%%', 'percentwin': '%P',
-      \     'lineinfo': '%3l:%-2v', 'line': '%l', 'column': '%c', 'close': '%999X X ', 'winnr': '%{winnr()}'
-      \   },
-      \   'component_visible_condition': {
-      \     'modified': '&modified||!&modifiable', 'readonly': '&readonly', 'paste': '&paste', 'spell': '&spell'
-      \   },
-      \   'component_function': {},
-      \   'component_function_visible_condition': {},
-      \   'component_expand': {
-      \     'tabs': 'lightline#tabs'
-      \   },
-      \   'component_type': {
-      \     'tabs': 'tabsel', 'close': 'raw'
-      \   },
-      \   'component_raw': {},
-      \   'tab_component': {},
-      \   'tab_component_function': {
-      \     'filename': 'lightline#tab#filename', 'modified': 'lightline#tab#modified',
-      \     'readonly': 'lightline#tab#readonly', 'tabnum': 'lightline#tab#tabnum'
-      \   },
-      \   'colorscheme': 'default',
-      \   'mode_map': {
-      \     'n': 'NORMAL', 'i': 'INSERT', 'R': 'REPLACE', 'v': 'VISUAL', 'V': 'V-LINE', "\<C-v>": 'V-BLOCK',
-      \     'c': 'COMMAND', 's': 'SELECT', 'S': 'S-LINE', "\<C-s>": 'S-BLOCK', 't': 'TERMINAL'
-      \   },
-      \   'separator': { 'left': '', 'right': '' },
-      \   'subseparator': { 'left': '|', 'right': '|' },
-      \   'tabline_separator': {},
-      \   'tabline_subseparator': {},
-      \   'enable': { 'statusline': 1, 'tabline': 1 },
-      \   '_mode_': {
-      \     'n': 'normal', 'i': 'insert', 'R': 'replace', 'v': 'visual', 'V': 'visual', "\<C-v>": 'visual',
-      \     'c': 'command', 's': 'select', 'S': 'select', "\<C-s>": 'select', 't': 'terminal'
-      \   },
-      \   'mode_fallback': { 'replace': 'insert', 'terminal': 'insert', 'select': 'visual' },
-      \   'palette': {},
-      \   'winwidth': winwidth(0),
-      \ }
-function! lightline#init() abort
-  let s:lightline = deepcopy(get(g:, 'lightline', {}))
-  for [key, value] in items(s:_lightline)
-    if type(value) == 4
-      if !has_key(s:lightline, key)
-        let s:lightline[key] = {}
-      endif
-      call extend(s:lightline[key], value, 'keep')
-    elseif !has_key(s:lightline, key)
-      let s:lightline[key] = value
-    endif
-    unlet value
-  endfor
-  call extend(s:lightline.tabline_separator, s:lightline.separator, 'keep')
-  call extend(s:lightline.tabline_subseparator, s:lightline.subseparator, 'keep')
-  let s:lightline.tabline_configured = has_key(get(get(g:, 'lightline', {}), 'component_expand', {}), 'tabs')
-  for components in deepcopy(s:lightline.tabline.left + s:lightline.tabline.right)
-    if len(filter(components, 'v:val !=# "tabs" && v:val !=# "close"')) > 0
-      let s:lightline.tabline_configured = 1
-      break
-    endif
-  endfor
-  if !exists('s:_statusline')
-    let s:_statusline = &statusline
-  endif
-  if !exists('s:_tabline')
-    let s:_tabline = &tabline
-  endif
-  if s:lightline.enable.tabline
-    set tabline=%!lightline#tabline()
-  else
-    let &tabline = get(s:, '_tabline', '')
-  endif
-  for f in values(s:lightline.component_function)
-    silent! call call(f, [])
-  endfor
-  for f in values(s:lightline.tab_component_function)
-    silent! call call(f, [1])
-  endfor
-  let s:mode = ''
-endfunction
-
-function! lightline#colorscheme() abort
-  try
-    let s:lightline.palette = g:lightline#colorscheme#{s:lightline.colorscheme}#palette
-  catch
-    call lightline#error('Could not load colorscheme ' . s:lightline.colorscheme . '.')
-    let s:lightline.colorscheme = 'default'
-    let s:lightline.palette = g:lightline#colorscheme#{s:lightline.colorscheme}#palette
-  finally
-    if has('win32') && !has('gui_running') && &t_Co < 256
-      call lightline#colortable#gui2cui_palette(s:lightline.palette)
-    endif
-    let s:highlight = {}
-    call lightline#highlight('normal')
-    call lightline#link()
-    let s:_ = 0
-  endtry
-endfunction
-
-function! lightline#palette() abort
-  return s:lightline.palette
-endfunction
-
-function! lightline#mode() abort
-  return get(s:lightline.mode_map, mode(), '')
-endfunction
-
-let s:mode = ''
-function! lightline#link(...) abort
-  let mode = get(s:lightline._mode_, a:0 ? a:1 : mode(), 'normal')
-  if s:mode ==# mode
-    return ''
-  endif
-  let s:mode = mode
-  if !has_key(s:highlight, mode)
-    call lightline#highlight(mode)
-  endif
-  let types = map(s:uniq(sort(filter(values(s:lightline.component_type), 'v:val !=# "raw"'))), '[v:val, 1]')
-  for [p, l] in [['Left', len(s:lightline.active.left)], ['Right', len(s:lightline.active.right)]]
-    for [i, t] in map(range(0, l), '[v:val, 0]') + types
-      if i != l
-        exec printf('hi link Lightline%s_active_%s Lightline%s_%s_%s', p, i, p, mode, i)
-      endif
-      for [j, s] in map(range(0, l), '[v:val, 0]') + types
-        if i + 1 == j || t || s && i != l
-          exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
-        endif
-      endfor
-    endfor
-  endfor
-  exec printf('hi link LightlineMiddle_active LightlineMiddle_%s', mode)
-  return ''
-endfunction
-
-function! s:term(p) abort
-  return get(a:p, 4) !=# '' ? 'term='.a:p[4].' cterm='.a:p[4].' gui='.a:p[4] : ''
-endfunction
-
-if exists('*uniq')
-  let s:uniq = function('uniq')
-else
-  function! s:uniq(xs) abort
-    let i = len(a:xs) - 1
-    while i > 0
-      if a:xs[i] ==# a:xs[i - 1]
-        call remove(a:xs, i)
-      endif
-      let i -= 1
-    endwhile
-    return a:xs
-  endfunction
-endif
-
-function! lightline#highlight(...) abort
-  let [c, f] = [s:lightline.palette, s:lightline.mode_fallback]
-  let [s:lightline.llen, s:lightline.rlen] = [len(c.normal.left), len(c.normal.right)]
-  let [s:lightline.tab_llen, s:lightline.tab_rlen] = [len(has_key(get(c, 'tabline', {}), 'left') ? c.tabline.left : c.normal.left), len(has_key(get(c, 'tabline', {}), 'right') ? c.tabline.right : c.normal.right)]
-  let types = map(s:uniq(sort(filter(values(s:lightline.component_type), 'v:val !=# "raw"'))), '[v:val, 1]')
-  let modes = a:0 ? [a:1] : extend(['normal', 'insert', 'replace', 'visual', 'inactive', 'command', 'select', 'tabline'], exists(':terminal') == 2 ? ['terminal'] : [])
-  for mode in modes
-    let s:highlight[mode] = 1
-    let d = has_key(c, mode) ? mode : has_key(f, mode) && has_key(c, f[mode]) ? f[mode] : 'normal'
-    let left = d ==# 'tabline' ? s:lightline.tabline.left : d ==# 'inactive' ? s:lightline.inactive.left : s:lightline.active.left
-    let right = d ==# 'tabline' ? s:lightline.tabline.right : d ==# 'inactive' ? s:lightline.inactive.right : s:lightline.active.right
-    let ls = has_key(get(c, d, {}), 'left') ? c[d].left : has_key(f, d) && has_key(get(c, f[d], {}), 'left') ? c[f[d]].left : c.normal.left
-    let ms = has_key(get(c, d, {}), 'middle') ? c[d].middle[0] : has_key(f, d) && has_key(get(c, f[d], {}), 'middle') ? c[f[d]].middle[0] : c.normal.middle[0]
-    let rs = has_key(get(c, d, {}), 'right') ? c[d].right : has_key(f, d) && has_key(get(c, f[d], {}), 'right') ? c[f[d]].right : c.normal.right
-    for [p, l, zs] in [['Left', len(left), ls], ['Right', len(right), rs]]
-      for [i, t] in map(range(0, l), '[v:val, 0]') + types
-        if i < l || i < 1
-          let r = t ? (has_key(get(c, d, []), i) ? c[d][i][0] : has_key(get(c, 'tabline', {}), i) ? c.tabline[i][0] : get(c.normal, i, zs)[0]) : get(zs, i, ms)
-          exec printf('hi Lightline%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', p, mode, i, r[0], r[1], r[2], r[3], s:term(r))
-        endif
-        for [j, s] in map(range(0, l), '[v:val, 0]') + types
-          if i + 1 == j || t || s && i != l
-            let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
-            exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
-          endif
-        endfor
-      endfor
-    endfor
-    exec printf('hi LightlineMiddle_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', mode, ms[0], ms[1], ms[2], ms[3], s:term(ms))
-  endfor
-endfunction
-
-function! s:subseparator(components, subseparator, expanded) abort
-  let [a, c, f, v, u] = [a:components, s:lightline.component, s:lightline.component_function, s:lightline.component_visible_condition, s:lightline.component_function_visible_condition]
-  let xs = map(range(len(a:components)), 'a:expanded[v:val] ? "1" :
-        \ has_key(f, a[v:val]) ? (has_key(u, a[v:val]) ? "(".u[a[v:val]].")" : (exists("*".f[a[v:val]]) ? "" : "exists(\"*".f[a[v:val]]."\")&&").f[a[v:val]]."()!=#\"\"") :
-        \ has_key(v, a[v:val]) ? "(".v[a[v:val]].")" : has_key(c, a[v:val]) ? "1" : "0"')
-  return '%{' . (xs[0] ==# '1' || xs[0] ==# '(1)' ? '' : xs[0] . '&&(') . join(xs[1:], '||') . (xs[0] ==# '1' || xs[0] ==# '(1)' ? '' : ')') . '?"' . a:subseparator . '":""}'
-endfunction
-
-function! lightline#concatenate(xs, right) abort
-  let separator = a:right ? s:lightline.subseparator.right : s:lightline.subseparator.left
-  return join(filter(copy(a:xs), 'v:val !=# ""'), ' ' . separator . ' ')
-endfunction
-
-function! lightline#statusline(inactive) abort
-  if a:inactive && !has_key(s:highlight, 'inactive')
-    call lightline#highlight('inactive')
-  endif
-  return s:line(0, a:inactive)
-endfunction
-
-function! s:normalize(result) abort
-  if type(a:result) == 3
-    return map(a:result, 'type(v:val) == 1 ? v:val : string(v:val)')
-  elseif type(a:result) == 1
-    return [a:result]
-  else
-    return [string(a:result)]
-  endif
-endfunction
-
-function! s:evaluate_expand(component) abort
-  try
-    let result = eval(a:component . '()')
-    if type(result) == 1 && result ==# ''
-      return []
-    endif
-  catch
-    return []
-  endtry
-  return map(type(result) == 3 ? (result + [[], [], []])[:2] : [[], [result], []], 'filter(s:normalize(v:val), "v:val !=# ''''")')
-endfunction
-
-function! s:convert(name, index) abort
-  if has_key(s:lightline.component_expand, a:name)
-    let type = get(s:lightline.component_type, a:name, a:index)
-    let is_raw = get(s:lightline.component_raw, a:name) || type ==# 'raw'
-    return filter(s:map(s:evaluate_expand(s:lightline.component_expand[a:name]),
-          \ '[v:val, 1 + ' . is_raw . ', v:key == 1 && ' . (type !=# 'raw') . ' ? "' . type . '" : "' . a:index . '", "' . a:index . '"]'), 'v:val[0] != []')
-  else
-    return [[[a:name], 0, a:index, a:index]]
-  endif
-endfunction
-
-function! s:flatten_twice(xss) abort
-  let ys = []
-  for xs in a:xss
-    for x in xs
-      let ys += x
-    endfor
-  endfor
-  return ys
-endfunction
-
-if v:version > 702 || v:version == 702 && has('patch295')
-  let s:map = function('map')
-else
-  function! s:map(xs, f) abort
-    let ys = []
-    for i in range(len(a:xs))
-      call extend(ys, map(a:xs[(i):(i)], substitute(a:f, 'v:key', i, 'g')))
-    endfor
-    return ys
-  endfunction
-endif
-
-function! s:expand(components) abort
-  let components = []
-  let expanded = []
-  let indices = []
-  let prevtype = ''
-  let previndex = -1
-  let xs = s:flatten_twice(s:map(deepcopy(a:components), 'map(v:val, "s:convert(v:val, ''" . v:key . "'')")'))
-  for [component, expand, type, index] in xs
-    if prevtype !=# type
-      for i in range(previndex + 1, max([previndex, index - 1]))
-        call add(indices, string(i))
-        call add(components, [])
-        call add(expanded, [])
-      endfor
-      call add(indices, type)
-      call add(components, [])
-      call add(expanded, [])
-    endif
-    call extend(components[-1], component)
-    call extend(expanded[-1], repeat([expand], len(component)))
-    let prevtype = type
-    let previndex = index
-  endfor
-  for i in range(previndex + 1, max([previndex, len(a:components) - 1]))
-    call add(indices, string(i))
-    call add(components, [])
-    call add(expanded, [])
-  endfor
-  call add(indices, string(len(a:components)))
-  return [components, expanded, indices]
-endfunction
-
-function! s:line(tabline, inactive) abort
-  let _ = a:tabline ? '' : '%{lightline#link()}'
-  if s:lightline.palette == {}
-    call lightline#colorscheme()
-  endif
-  let [l, r] = a:tabline ? [s:lightline.tab_llen, s:lightline.tab_rlen] : [s:lightline.llen, s:lightline.rlen]
-  let [p, s] = a:tabline ? [s:lightline.tabline_separator, s:lightline.tabline_subseparator] : [s:lightline.separator, s:lightline.subseparator]
-  let [c, f, t, w] = [s:lightline.component, s:lightline.component_function, s:lightline.component_type, s:lightline.component_raw]
-  let mode = a:tabline ? 'tabline' : a:inactive ? 'inactive' : 'active'
-  let l_ = has_key(s:lightline, mode) ? s:lightline[mode].left : s:lightline.active.left
-  let [lt, lc, ll] = s:expand(copy(l_))
-  let r_ = has_key(s:lightline, mode) ? s:lightline[mode].right : s:lightline.active.right
-  let [rt, rc, rl] = s:expand(copy(r_))
-  for i in range(len(lt))
-    let _ .= '%#LightlineLeft_' . mode . '_' . ll[i] . '#'
-    for j in range(len(lt[i]))
-      let x = lc[i][j] ? lt[i][j] : has_key(f, lt[i][j]) ? (exists('*' . f[lt[i][j]]) ? '%{' . f[lt[i][j]] . '()}' : '%{exists("*' . f[lt[i][j]] . '")?' . f[lt[i][j]] . '():""}') : get(c, lt[i][j], '')
-      let _ .= has_key(t, lt[i][j]) && t[lt[i][j]] ==# 'raw' || get(w, lt[i][j]) || lc[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
-      if j < len(lt[i]) - 1 && s.left !=# ''
-        let _ .= s:subseparator(lt[i][(j):], s.left, lc[i][(j):])
-      endif
-    endfor
-    let _ .= '%#LightlineLeft_' . mode . '_' . ll[i] . '_' . ll[i + 1] . '#'
-    let _ .= i < l + len(lt) - len(l_) && ll[i] < l || ll[i] != ll[i + 1] ? p.left : len(lt[i]) ? s.left : ''
-  endfor
-  let _ .= '%#LightlineMiddle_' . mode . '#%='
-  for i in range(len(rt) - 1, 0, -1)
-    let _ .= '%#LightlineRight_' . mode . '_' . rl[i] . '_' . rl[i + 1] . '#'
-    let _ .= i < r + len(rt) - len(r_) && rl[i] < r || rl[i] != rl[i + 1] ? p.right : len(rt[i]) ? s.right : ''
-    let _ .= '%#LightlineRight_' . mode . '_' . rl[i] . '#'
-    for j in range(len(rt[i]))
-      let x = rc[i][j] ? rt[i][j] : has_key(f, rt[i][j]) ? (exists('*' . f[rt[i][j]]) ? '%{' . f[rt[i][j]] . '()}' : '%{exists("*' . f[rt[i][j]] . '")?' . f[rt[i][j]] . '():""}') : get(c, rt[i][j], '')
-      let _ .= has_key(t, rt[i][j]) && t[rt[i][j]] ==# 'raw' || get(w, rt[i][j]) || rc[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
-      if j < len(rt[i]) - 1 && s.right !=# ''
-        let _ .= s:subseparator(rt[i][(j):], s.right, rc[i][(j):])
-      endif
-    endfor
-  endfor
-  return _
-endfunction
-
-let s:tabnr = -1
-let s:tabcnt = -1
-let s:tabline = ''
-function! lightline#tabline() abort
-  if !has_key(s:highlight, 'tabline')
-    call lightline#highlight('tabline')
-  endif
-  if s:lightline.tabline_configured || s:tabnr != tabpagenr() || s:tabcnt != tabpagenr('$')
-    let s:tabnr = tabpagenr()
-    let s:tabcnt = tabpagenr('$')
-    let s:tabline = s:line(1, 0)
-  endif
-  return s:tabline
-endfunction
-
-function! lightline#tabs() abort
-  let [x, y, z] = [[], [], []]
-  let nr = tabpagenr()
-  let cnt = tabpagenr('$')
-  for i in range(1, cnt)
-    call add(i < nr ? x : i == nr ? y : z, (i > nr + 3 ? '%<' : '') . '%'. i . 'T%{lightline#onetab(' . i . ',' . (i == nr) . ')}' . (i == cnt ? '%T' : ''))
-  endfor
-  let abbr = '...'
-  let n = min([max([s:lightline.winwidth / 40, 2]), 8])
-  if len(x) > n && len(z) > n
-    let x = extend(add(x[:n/2-1], abbr), x[-(n+1)/2:])
-    let z = extend(add(z[:(n+1)/2-1], abbr), z[-n/2:])
-  elseif len(x) + len(z) > 2 * n
-    if len(x) > n
-      let x = extend(add(x[:(2*n-len(z))/2-1], abbr), x[-(2*n-len(z)+1)/2:])
-    elseif len(z) > n
-      let z = extend(add(z[:(2*n-len(x)+1)/2-1], abbr), z[-(2*n-len(x))/2:])
-    endif
-  endif
-  return [x, y, z]
-endfunction
-
-function! lightline#onetab(n, active) abort
-  let _ = []
-  for name in a:active ? s:lightline.tab.active : s:lightline.tab.inactive
-    if has_key(s:lightline.tab_component_function, name)
-      call add(_, call(s:lightline.tab_component_function[name], [a:n]))
-    else
-      call add(_, get(s:lightline.tab_component, name, ''))
-    endif
-  endfor
-  return join(filter(_, 'v:val !=# ""'), ' ')
-endfunction
-
-function! lightline#error(msg) abort
-  echohl ErrorMsg
-  echomsg 'lightline.vim: '.a:msg
-  echohl None
-endfunction
-
-let &cpo = s:save_cpo
-unlet s:save_cpo
diff --git a/sources_non_forked/lightline.vim/autoload/lightline/colorscheme.vim b/sources_non_forked/lightline.vim/autoload/lightline/colorscheme.vim
deleted file mode 100644
index 9cd7fa4..0000000
--- a/sources_non_forked/lightline.vim/autoload/lightline/colorscheme.vim
+++ /dev/null
@@ -1,257 +0,0 @@
-" =============================================================================
-" Filename: autoload/lightline/colorscheme.vim
-" Author: itchyny
-" License: MIT License
-" Last Change: 2019/09/07 11:20:37.
-" =============================================================================
-
-let s:save_cpo = &cpo
-set cpo&vim
-
-let s:cuicolor = {
-      \ 'black'          : 16,
-      \ 'white'          : 231,
-      \
-      \ 'darkestgreen'   : 22,
-      \ 'darkgreen'      : 28,
-      \ 'mediumgreen'    : 70,
-      \ 'brightgreen'    : 148,
-      \
-      \ 'darkestcyan'    : 23,
-      \ 'mediumcyan'     : 117,
-      \
-      \ 'darkestblue'    : 24,
-      \ 'darkblue'       : 31,
-      \
-      \ 'darkestred'     : 52,
-      \ 'darkred'        : 88,
-      \ 'mediumred'      : 124,
-      \ 'brightred'      : 160,
-      \ 'brightestred'   : 196,
-      \
-      \ 'darkestpurple'  : 55,
-      \ 'mediumpurple'   : 98,
-      \ 'brightpurple'   : 189,
-      \
-      \ 'brightorange'   : 208,
-      \ 'brightestorange': 214,
-      \
-      \ 'gray0'          : 233,
-      \ 'gray1'          : 235,
-      \ 'gray2'          : 236,
-      \ 'gray3'          : 239,
-      \ 'gray4'          : 240,
-      \ 'gray5'          : 241,
-      \ 'gray6'          : 244,
-      \ 'gray7'          : 245,
-      \ 'gray8'          : 247,
-      \ 'gray9'          : 250,
-      \ 'gray10'         : 252,
-      \
-      \ 'yellow'         : 136,
-      \ 'orange'         : 166,
-      \ 'red'            : 160,
-      \ 'magenta'        : 125,
-      \ 'violet'         : 61,
-      \ 'blue'           : 33,
-      \ 'cyan'           : 37,
-      \ 'green'          : 64,
-      \ }
-
-let s:guicolor = {
-      \ 'black'          : '#000000',
-      \ 'white'          : '#ffffff',
-      \
-      \ 'darkestgreen'   : '#005f00',
-      \ 'darkgreen'      : '#008700',
-      \ 'mediumgreen'    : '#5faf00',
-      \ 'brightgreen'    : '#afdf00',
-      \
-      \ 'darkestcyan'    : '#005f5f',
-      \ 'mediumcyan'     : '#87dfff',
-      \
-      \ 'darkestblue'    : '#005f87',
-      \ 'darkblue'       : '#0087af',
-      \
-      \ 'darkestred'     : '#5f0000',
-      \ 'darkred'        : '#870000',
-      \ 'mediumred'      : '#af0000',
-      \ 'brightred'      : '#df0000',
-      \ 'brightestred'   : '#ff0000',
-      \
-      \ 'darkestpurple'  : '#5f00af',
-      \ 'mediumpurple'   : '#875fdf',
-      \ 'brightpurple'   : '#dfdfff',
-      \
-      \ 'brightorange'   : '#ff8700',
-      \ 'brightestorange': '#ffaf00',
-      \
-      \ 'gray0'          : '#121212',
-      \ 'gray1'          : '#262626',
-      \ 'gray2'          : '#303030',
-      \ 'gray3'          : '#4e4e4e',
-      \ 'gray4'          : '#585858',
-      \ 'gray5'          : '#606060',
-      \ 'gray6'          : '#808080',
-      \ 'gray7'          : '#8a8a8a',
-      \ 'gray8'          : '#9e9e9e',
-      \ 'gray9'          : '#bcbcbc',
-      \ 'gray10'         : '#d0d0d0',
-      \
-      \ 'yellow'         : '#b58900',
-      \ 'orange'         : '#cb4b16',
-      \ 'red'            : '#dc322f',
-      \ 'magenta'        : '#d33682',
-      \ 'violet'         : '#6c71c4',
-      \ 'blue'           : '#268bd2',
-      \ 'cyan'           : '#2aa198',
-      \ 'green'          : '#859900',
-      \ }
-
-function! s:convert(rgb) abort
-  let rgb = map(matchlist(a:rgb, '#\(..\)\(..\)\(..\)')[1:3], '0 + ("0x".v:val)')
-  if len(rgb) == 0
-    return 0
-  endif
-  if rgb[0] == 0xc0 && rgb[1] == 0xc0 && rgb[2] == 0xc0
-    return 7
-  elseif rgb[0] == 0x80 && rgb[1] == 0x80 && rgb[2] == 0x80
-    return 8
-  elseif (rgb[0] == 0x80 || rgb[0] == 0x00) && (rgb[1] == 0x80 || rgb[1] == 0x00) && (rgb[2] == 0x80 || rgb[2] == 0x00)
-    return (rgb[0] / 0x80) + (rgb[1] / 0x80) * 2 + (rgb[1] / 0x80) * 4
-  elseif abs(rgb[0]-rgb[1]) < 3 && abs(rgb[1]-rgb[2]) < 3 && abs(rgb[2]-rgb[0]) < 3
-    return s:black((rgb[0] + rgb[1] + rgb[2]) / 3)
-  else
-    return 16 + ((s:nr(rgb[0]) * 6) + s:nr(rgb[1])) * 6 + s:nr(rgb[2])
-  endif
-endfunction
-
-function! s:black(x) abort
-  if a:x < 0x04
-    return 16
-  elseif a:x > 0xf4
-    return 231
-  elseif index([0x00, 0x5f, 0x87, 0xaf, 0xdf, 0xff], a:x) >= 0
-    let l = a:x / 0x30
-    return ((l * 6) + l) * 6 + l + 16
-  else
-    return 232 + (a:x < 8 ? 0 : a:x < 0x60 ? (a:x-8)/10 : a:x < 0x76 ? (a:x-0x60)/6+9 : (a:x-8)/10)
-  endif
-endfunction
-
-function! s:nr(x) abort
-  return a:x < 0x2f ? 0 : a:x < 0x73 ? 1 : a:x < 0x9b ? 2 : a:x < 0xc7 ? 3 : a:x < 0xef ? 4 : 5
-endfunction
-
-function! s:rgb(r, g, b) abort
-  return printf('#%02x%02x%02x', a:r, a:g, a:b)
-endfunction
-
-function! s:upconvert(nr) abort
-  let x = a:nr * 1
-  if x < 7
-    let [b, rg] = [x / 4, x % 4]
-    let [g, r] = [rg / 2, rg % 2]
-    return s:rgb(r * 0x80, g * 0x80, b * 0x80)
-  elseif x == 7
-    return s:rgb(0xc0, 0xc0, 0xc0)
-  elseif x == 8
-    return s:rgb(0x80, 0x80, 0x80)
-  elseif x < 16
-    let y = x - 8
-    let [b, rg] = [y / 4, y % 4]
-    let [g, r] = [rg / 2, rg % 2]
-    return s:rgb(r * 0xff, g * 0xff, b * 0xff)
-  elseif x < 232
-    let y = x - 16
-    let [rg, b] = [y / 6, y % 6]
-    let [r, g] = [rg / 6, rg % 6]
-    let l = [0x00, 0x5f, 0x87, 0xaf, 0xdf, 0xff]
-    return s:rgb(l[r], l[g], l[b])
-  elseif x < 241
-    let k = (x - 232) * 10 + 8
-    return s:rgb(k, k, k)
-  elseif x < 243
-    let k = (x - 241) * 6 + 0x60
-    return s:rgb(k, k, k)
-  else
-    let k = (x - 232) * 10 + 8
-    return s:rgb(k, k, k)
-  endif
-endfunction
-
-function! lightline#colorscheme#fill(p) abort
-  for k in values(a:p)
-    for l in values(k)
-      for m in l
-        if len(m) < 4
-          if type(m[0]) == 1 && type(m[1]) == 1
-            if m[0] =~# '^\d\+$' && m[1] =~# '^\d\+$'
-              call insert(m, s:upconvert(m[1]), 0)
-              call insert(m, s:upconvert(m[1]), 0)
-            else
-              call insert(m, get(s:cuicolor, m[0], s:convert(m[0])), 2)
-              call insert(m, get(s:cuicolor, m[1], s:convert(m[1])), 3)
-              let m[0] = get(s:guicolor, m[0], m[0])
-              let m[1] = get(s:guicolor, m[1], m[1])
-            endif
-          elseif type(m[0]) == 0 && type(m[1]) == 0
-              call insert(m, s:upconvert(m[1]), 0)
-              call insert(m, s:upconvert(m[1]), 0)
-          endif
-        endif
-      endfor
-    endfor
-  endfor
-  return a:p
-endfunction
-
-function! lightline#colorscheme#flatten(p) abort
-  for k in values(a:p)
-    for l in values(k)
-      for m in range(len(l))
-        let attr = ''
-        if len(l[m]) == 3 && type(l[m][2]) == 1
-          let attr = l[m][2]
-        endif
-        let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
-        if !empty(attr)
-          call add(l[m], attr)
-        endif
-      endfor
-    endfor
-  endfor
-  return a:p
-endfunction
-
-if has('gui_running') || (has('termguicolors') && &termguicolors)
-  function! lightline#colorscheme#background() abort
-    return &background
-  endfunction
-else
-  " &background is set inappropriately when the colorscheme sets ctermbg of the Normal group
-  function! lightline#colorscheme#background() abort
-    let bg_color = synIDattr(synIDtrans(hlID('Normal')), 'bg', 'cterm')
-    if bg_color !=# ''
-      if bg_color < 16
-        return &background
-      elseif 232 <= bg_color && bg_color < 244
-        return 'dark'
-      elseif 244 <= bg_color
-        return 'light'
-      endif
-    endif
-    let fg_color = synIDattr(synIDtrans(hlID('Normal')), 'fg', 'cterm')
-    if fg_color !=# ''
-      if fg_color < 7 || 232 <= fg_color && fg_color < 244
-        return 'light'
-      elseif 8 <= fg_color && fg_color < 16 || 244 <= fg_color
-        return 'dark'
-      endif
-    endif
-    return &background
-  endfunction
-endif
-
-let &cpo = s:save_cpo
-unlet s:save_cpo
diff --git a/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/16color.vim b/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/16color.vim
deleted file mode 100644
index 41e6497..0000000
--- a/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/16color.vim
+++ /dev/null
@@ -1,49 +0,0 @@
-" =============================================================================
-" Filename: autoload/lightline/colorscheme/16color.vim
-" Author: itchyny
-" License: MIT License
-" Last Change: 2017/11/25 11:14:04.
-" =============================================================================
-
-let s:base03 = [ '#808080', 8 ]
-let s:base02 = [ '#000000', 0 ]
-let s:base01 = [ '#00ff00', 10 ]
-let s:base00 = [ '#ffff00', 11  ]
-let s:base0 = [ '#0000ff', 12 ]
-let s:base1 = [ '#00ffff', 14 ]
-let s:base2 = [ '#c0c0c0', 7 ]
-let s:base3 = [ '#ffffff', 15 ]
-let s:yellow = [ '#808000', 3 ]
-let s:orange = [ '#ff0000', 9 ]
-let s:red = [ '#800000', 1 ]
-let s:magenta = [ '#800080', 5 ]
-let s:violet = [ '#ff00ff', 13 ]
-let s:blue = [ '#000080', 4 ]
-let s:cyan = [ '#008080', 6 ]
-let s:green = [ '#008000', 2 ]
-
-if lightline#colorscheme#background() ==# 'light'
-  let [s:base03, s:base3] = [s:base3, s:base03]
-  let [s:base02, s:base2] = [s:base2, s:base02]
-  let [s:base01, s:base1] = [s:base1, s:base01]
-  let [s:base00, s:base0] = [s:base0, s:base00]
-endif
-
-let s:p = {'normal': {}, 'inactive': {}, 'insert': {}, 'replace': {}, 'visual': {}, 'tabline': {}}
-let s:p.normal.left = [ [ s:base3, s:blue ], [ s:base3, s:base01 ] ]
-let s:p.normal.right = [ [ s:base02, s:base0 ], [ s:base1, s:base01 ] ]
-let s:p.inactive.right = [ [ s:base02, s:base01 ], [ s:base00, s:base02 ] ]
-let s:p.inactive.left =  [ [ s:base0, s:base02 ], [ s:base00, s:base02 ] ]
-let s:p.insert.left = [ [ s:base3, s:green ], [ s:base3, s:base01 ] ]
-let s:p.replace.left = [ [ s:base3, s:red ], [ s:base3, s:base01 ] ]
-let s:p.visual.left = [ [ s:base3, s:magenta ], [ s:base3, s:base01 ] ]
-let s:p.normal.middle = [ [ s:base1, s:base02 ] ]
-let s:p.inactive.middle = [ [ s:base0, s:base02 ] ]
-let s:p.tabline.left = [ [ s:base2, s:base01 ] ]
-let s:p.tabline.tabsel = [ [ s:base2, s:base02 ] ]
-let s:p.tabline.middle = [ [ s:base01, s:base2 ] ]
-let s:p.tabline.right = copy(s:p.normal.right)
-let s:p.normal.error = [ [ s:base2, s:red ] ]
-let s:p.normal.warning = [ [ s:base02, s:yellow ] ]
-
-let g:lightline#colorscheme#16color#palette = lightline#colorscheme#flatten(s:p)
diff --git a/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/OldHope.vim b/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/OldHope.vim
deleted file mode 100644
index ff78290..0000000
--- a/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/OldHope.vim
+++ /dev/null
@@ -1,44 +0,0 @@
-" =============================================================================
-" Filename: autoload/lightline/colorscheme/OldHope.vim
-" Author: tomb0y
-" License: MIT License
-" Last Change: 2017/10/15 06:20:54.
-" =============================================================================
-
-let s:yellow = [ '#e5cd52' , 221 ]
-let s:blue = [ '#4fb4d8' , 39 ]
-let s:red = [ '#f92672' , 161 ]
-let s:green = [ '#78bd65' , 41 ]
-let s:orange = [ '#ef7c2a' , 202 ]
-let s:white = [ '#ffffff' , 15 ]
-let s:lightGray = [ '#848794' , 245 ]
-let s:gray = [ '#686b78' , 242 ]
-let s:darkGray = [ '#45474f' , 238 ]
-let s:veryDarkGray = [ '#1c1d21' , 234 ]
-
-let s:p = {'normal': {}, 'inactive': {}, 'insert': {}, 'replace': {}, 'visual': {}, 'tabline': {}}
-
-let s:p.normal.left = [ [ s:white, s:blue ], [ s:white, s:gray ] ]
-let s:p.insert.left = [ [ s:white, s:green ], [ s:white, s:gray ] ]
-let s:p.visual.left = [ [ s:white, s:orange ], [ s:white, s:gray ] ]
-let s:p.replace.left = [ [ s:white, s:red ], [ s:white, s:gray ] ]
-
-let s:p.inactive.right = [ [ s:darkGray, s:gray ], [ s:darkGray, s:gray ] ]
-let s:p.inactive.left = [ [ s:lightGray, s:darkGray ], [ s:white, s:darkGray ] ]
-let s:p.inactive.middle = [ [ s:white, s:darkGray ] ]
-
-let s:p.normal.middle = [ [ s:white, s:darkGray ] ]
-let s:p.normal.error = [ [ s:red, s:darkGray ] ]
-let s:p.normal.warning = [ [ s:orange, s:darkGray ] ]
-
-let s:p.tabline.left = [ [ s:lightGray, s:darkGray ] ]
-let s:p.tabline.tabsel = [ [ s:darkGray, s:yellow ] ]
-let s:p.tabline.middle = [ [ s:yellow, s:veryDarkGray ] ]
-
-let s:p.normal.right = copy(s:p.normal.left)
-let s:p.insert.right = copy(s:p.insert.left)
-let s:p.visual.right = copy(s:p.visual.left)
-let s:p.replace.right = copy(s:p.replace.left)
-let s:p.tabline.right = copy(s:p.tabline.left)
-
-let g:lightline#colorscheme#OldHope#palette = lightline#colorscheme#flatten(s:p)
diff --git a/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/PaperColor.vim b/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/PaperColor.vim
deleted file mode 100644
index 90aa426..0000000
--- a/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/PaperColor.vim
+++ /dev/null
@@ -1,12 +0,0 @@
-" =============================================================================
-" Filename: autoload/lightline/colorscheme/PaperColor.vim
-" Author: TKNGUE
-" License: MIT License
-" Last Change: 2017/11/25 11:13:35.
-" =============================================================================
-
-if lightline#colorscheme#background() ==# 'light'
-  let g:lightline#colorscheme#PaperColor#palette = g:lightline#colorscheme#PaperColor_light#palette
-else
-  let g:lightline#colorscheme#PaperColor#palette = g:lightline#colorscheme#PaperColor_dark#palette
-endif
diff --git a/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/PaperColor_dark.vim b/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/PaperColor_dark.vim
deleted file mode 100644
index 0a70b34..0000000
--- a/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/PaperColor_dark.vim
+++ /dev/null
@@ -1,60 +0,0 @@
-" =============================================================================
-" Filename: autoload/lightline/colorscheme/PaperColor_dark.vim
-" Author: TKNGUE
-" License: MIT License
-" Last Change: 2015-07-27 06:01
-" =============================================================================
-
-let s:red = '#df0000'
-let s:green = '#008700'
-let s:blue = '#00afaf'
-
-let s:pink = '#afdf00'
-let s:olive = '#dfaf5f'
-let s:navy = '#df875f'
-
-let s:orange = '#d75f00'
-let s:purple = '#8959a8'
-let s:aqua = '#3e999f'
-
-" Basics:
-let s:foreground = '#d0d0d0'
-let s:background = '#444444'
-let s:window = '#efefef'
-let s:status = '#c6c6c6'
-let s:error = '#5f0000'
-
-" Tabline:
-let s:tabline_bg = '#3a3a3a'
-let s:tabline_active_fg = '#1c1c1c'
-let s:tabline_active_bg = '#00afaf'
-let s:tabline_inactive_fg = '#c6c6c6'
-let s:tabline_inactive_bg = '#585858'
-
-" Statusline:
-let s:statusline_active_fg = '#1c1c1c'
-let s:statusline_active_bg = '#5f8787'
-let s:statusline_inactive_fg = '#c6c6c6'
-let s:statusline_inactive_bg = '#444444'
-
-" Visual:
-let s:visual_fg = '#000000'
-let s:visual_bg = '#8787af'
-
-let s:p = {'normal': {}, 'inactive': {}, 'insert': {}, 'replace': {}, 'visual': {}, 'tabline': {}}
-let s:p.normal.left = [ [ s:foreground, s:background ], [ s:statusline_active_fg, s:status ], [ s:statusline_active_fg, s:statusline_active_bg ] ]
-let s:p.normal.right = [ [ s:foreground, s:background ], [ s:statusline_active_fg, s:status ], [ s:statusline_active_fg, s:statusline_active_bg ] ]
-let s:p.normal.middle = [ [ s:statusline_active_fg, s:statusline_active_bg ]]
-let s:p.inactive.right = [ [ s:foreground, s:background ], [ s:foreground, s:background ] ]
-let s:p.inactive.left = [ [ s:foreground, s:background ], [ s:foreground, s:background ] ]
-let s:p.inactive.middle = [ [ s:foreground, s:background ], ]
-let s:p.insert.left = [ [ s:background, s:blue], [ s:statusline_active_fg, s:status ], [ s:statusline_active_fg, s:statusline_active_bg ] ]
-let s:p.replace.left = [ [ s:background, s:pink ], [s:statusline_active_fg, s:status ], [ s:statusline_active_fg, s:statusline_active_bg ] ]
-let s:p.visual.left = [ [ s:visual_fg, s:visual_bg ], [s:statusline_active_fg, s:status ], [ s:statusline_active_fg, s:statusline_active_bg ] ]
-let s:p.tabline.left = [ [s:tabline_inactive_fg, s:tabline_inactive_bg ]]
-let s:p.tabline.tabsel = [ [s:tabline_active_fg, s:tabline_active_bg ] ]
-let s:p.tabline.middle = [ [s:tabline_bg, s:tabline_bg]]
-let s:p.tabline.right = copy(s:p.normal.right)
-let s:p.normal.error = [ [ s:background, s:error ] ]
-
-let g:lightline#colorscheme#PaperColor_dark#palette = lightline#colorscheme#fill(s:p)
diff --git a/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/PaperColor_light.vim b/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/PaperColor_light.vim
deleted file mode 100644
index aef0b86..0000000
--- a/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/PaperColor_light.vim
+++ /dev/null
@@ -1,55 +0,0 @@
-" =============================================================================
-" Filename: autoload/lightline/colorscheme/PaperColor_light.vim
-" Author: TKNGUE
-" License: MIT License
-" Last Change: 2015/07/28 07:46:40.
-" =============================================================================
-
-let s:red = '#df0000'
-let s:green = '#008700'
-let s:blue = '#4271ae'
-let s:pink = '#d7005f'
-let s:olive = '#718c00'
-let s:navy = '#005f87'
-let s:orange = '#d75f00'
-let s:purple = '#8959a8'
-let s:aqua = '#3e999f'
-
-" Basics:
-let s:foreground = '#4d4d4c'
-let s:background = '#F5F5F5'
-let s:window = '#efefef'
-let s:status = s:aqua
-let s:error = '#ffafdf'
-
-" Tabline:
-let s:tabline_bg = s:navy
-let s:tabline_active_fg = s:foreground
-let s:tabline_active_bg = s:window
-let s:tabline_inactive_fg = s:background
-let s:tabline_inactive_bg = s:aqua
-
-" Statusline:
-let s:statusline_active_fg = s:window
-let s:statusline_active_bg = s:navy
-let s:statusline_inactive_fg = s:foreground
-let s:statusline_inactive_bg = '#dadada'
-
-let s:p = {'normal': {}, 'inactive': {}, 'insert': {}, 'replace': {}, 'visual': {}, 'tabline': {}}
-let s:p.normal.left = [ [ s:foreground, s:background ], [ s:statusline_active_fg, s:status ], [ s:statusline_active_fg, s:statusline_active_bg ] ]
-let s:p.normal.right = [ [ s:foreground, s:background ], [ s:statusline_active_fg, s:status ], [ s:statusline_active_fg, s:statusline_active_bg ] ]
-let s:p.normal.middle = [ [ s:statusline_active_fg, s:statusline_active_bg ]]
-let s:p.inactive.right = [ [ s:foreground, s:background ], [ s:foreground, s:background ] ]
-let s:p.inactive.left = [ [ s:foreground, s:background ], [ s:foreground, s:background ] ]
-let s:p.inactive.middle = [ [ s:foreground, s:background ], ]
-let s:p.insert.left = [ [ s:blue, s:background ], [ s:statusline_active_fg, s:status ], [ s:statusline_active_fg, s:statusline_active_bg ] ]
-let s:p.replace.left = [ [ s:background, s:pink ], [s:statusline_active_fg, s:status ], [ s:statusline_active_fg, s:statusline_active_bg ] ]
-let s:p.visual.left = [ [ s:background, s:orange ], [s:statusline_active_fg, s:status ], [ s:statusline_active_fg, s:statusline_active_bg ] ]
-let s:p.tabline.left = [ [s:tabline_inactive_fg, s:tabline_inactive_bg ]]
-let s:p.tabline.tabsel = [ [s:tabline_active_fg, s:tabline_active_bg ] ]
-let s:p.tabline.middle = [ [s:tabline_bg, s:tabline_bg]]
-let s:p.tabline.right = copy(s:p.normal.right)
-let s:p.normal.error = [ [ s:background, s:error ] ]
-let s:p.normal.warning = [ [ s:background, s:olive ] ]
-
-let g:lightline#colorscheme#PaperColor_light#palette = lightline#colorscheme#fill(s:p)
diff --git a/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/Tomorrow.vim b/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/Tomorrow.vim
deleted file mode 100644
index 8255966..0000000
--- a/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/Tomorrow.vim
+++ /dev/null
@@ -1,41 +0,0 @@
-" =============================================================================
-" Filename: autoload/lightline/colorscheme/Tomorrow.vim
-" Author: itchyny
-" License: MIT License
-" Last Change: 2013/09/07 12:22:37.
-" =============================================================================
-let s:base03 = '#fafafa'
-let s:base023 = '#dfdfdf'
-let s:base02 = '#c8c8c8'
-let s:base01 = '#b4b4b4'
-let s:base00 = '#808080'
-let s:base0 = '#666666'
-let s:base1 = '#555555'
-let s:base2 = '#4f4f4f'
-let s:base3 = '#4d4d4c'
-let s:red = '#c82829'
-let s:orange = '#f5871f'
-let s:yellow = '#eab700'
-let s:green = '#718c00'
-let s:cyan = '#3e999f'
-let s:blue = '#4271ae'
-let s:magenta = '#8959a8'
-
-let s:p = {'normal': {}, 'inactive': {}, 'insert': {}, 'replace': {}, 'visual': {}, 'tabline': {}}
-let s:p.normal.left = [ [ s:base02, s:blue ], [ s:base3, s:base01 ] ]
-let s:p.normal.right = [ [ s:base02, s:base0 ], [ s:base1, s:base01 ] ]
-let s:p.inactive.right = [ [ s:base02, s:base00 ], [ s:base00, s:base02 ] ]
-let s:p.inactive.left =  [ [ s:base0, s:base02 ], [ s:base00, s:base03 ] ]
-let s:p.insert.left = [ [ s:base02, s:green ], [ s:base3, s:base01 ] ]
-let s:p.replace.left = [ [ s:base02, s:orange ], [ s:base3, s:base01 ] ]
-let s:p.visual.left = [ [ s:base02, s:magenta ], [ s:base3, s:base01 ] ]
-let s:p.normal.middle = [ [ s:base1, s:base02 ] ]
-let s:p.inactive.middle = [ [ s:base0, s:base02 ] ]
-let s:p.tabline.left = [ [ s:base2, s:base01 ] ]
-let s:p.tabline.tabsel = [ [ s:base2, s:base023 ] ]
-let s:p.tabline.middle = [ [ s:base01, s:base00 ] ]
-let s:p.tabline.right = copy(s:p.normal.right)
-let s:p.normal.error = [ [ s:red, s:base01 ] ]
-let s:p.normal.warning = [ [ s:yellow, s:base0 ] ]
-
-let g:lightline#colorscheme#Tomorrow#palette = lightline#colorscheme#fill(s:p)
diff --git a/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/Tomorrow_Night.vim b/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/Tomorrow_Night.vim
deleted file mode 100644
index 8903180..0000000
--- a/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/Tomorrow_Night.vim
+++ /dev/null
@@ -1,41 +0,0 @@
-" =============================================================================
-" Filename: autoload/lightline/colorscheme/Tomorrow_Night.vim
-" Author: itchyny
-" License: MIT License
-" Last Change: 2013/09/07 12:23:38.
-" =============================================================================
-let s:base3 = '#c5c8c6'
-let s:base2 = '#bababa'
-let s:base1 = '#a0a0a0'
-let s:base0 = '#909090'
-let s:base00 = '#666666'
-let s:base01 = '#555555'
-let s:base02 = '#434343'
-let s:base023 = '#303030'
-let s:base03 = '#1d1f21'
-let s:red = '#cc6666'
-let s:orange = '#de935f'
-let s:yellow = '#f0c674'
-let s:green = '#b5bd68'
-let s:cyan = '#8abeb7'
-let s:blue = '#81a2be'
-let s:magenta = '#b294bb'
-
-let s:p = {'normal': {}, 'inactive': {}, 'insert': {}, 'replace': {}, 'visual': {}, 'tabline': {}}
-let s:p.normal.left = [ [ s:base02, s:blue ], [ s:base3, s:base01 ] ]
-let s:p.normal.right = [ [ s:base02, s:base0 ], [ s:base1, s:base01 ] ]
-let s:p.inactive.right = [ [ s:base02, s:base00 ], [ s:base00, s:base02 ] ]
-let s:p.inactive.left =  [ [ s:base0, s:base02 ], [ s:base00, s:base03 ] ]
-let s:p.insert.left = [ [ s:base02, s:green ], [ s:base3, s:base01 ] ]
-let s:p.replace.left = [ [ s:base02, s:orange ], [ s:base3, s:base01 ] ]
-let s:p.visual.left = [ [ s:base02, s:magenta ], [ s:base3, s:base01 ] ]
-let s:p.normal.middle = [ [ s:base1, s:base02 ] ]
-let s:p.inactive.middle = [ [ s:base0, s:base02 ] ]
-let s:p.tabline.left = [ [ s:base2, s:base01 ] ]
-let s:p.tabline.tabsel = [ [ s:base2, s:base023 ] ]
-let s:p.tabline.middle = [ [ s:base01, s:base0 ] ]
-let s:p.tabline.right = copy(s:p.normal.right)
-let s:p.normal.error = [ [ s:red, s:base023 ] ]
-let s:p.normal.warning = [ [ s:yellow, s:base02 ] ]
-
-let g:lightline#colorscheme#Tomorrow_Night#palette = lightline#colorscheme#fill(s:p)
diff --git a/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/Tomorrow_Night_Blue.vim b/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/Tomorrow_Night_Blue.vim
deleted file mode 100644
index 31c27f3..0000000
--- a/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/Tomorrow_Night_Blue.vim
+++ /dev/null
@@ -1,43 +0,0 @@
-" =============================================================================
-" Filename: autoload/lightline/colorscheme/Tomorrow_Night_Blue.vim
-" Author: itchyny
-" License: MIT License
-" Last Change: 2013/09/07 14:13:21.
-" =============================================================================
-let s:base3 = '#ffffff'
-let s:base23 = '#ffffff'
-let s:base2 = '#ffffff'
-let s:base1 = '#ffffff'
-let s:base0 = '#ffffff'
-let s:base00 = '#6060df'
-let s:base01 = '#6060af'
-let s:base02 = '#606087'
-let s:base023 = '#202087'
-let s:base03 = '#002451'
-let s:red = '#ff9da4'
-let s:orange = '#ffc58f'
-let s:yellow = '#ffeead'
-let s:green = '#d1f1a9'
-let s:cyan = '#99ffff'
-let s:blue = '#bbdaff'
-let s:magenta = '#ebbbff'
-
-
-let s:p = {'normal': {}, 'inactive': {}, 'insert': {}, 'replace': {}, 'visual': {}, 'tabline': {}}
-let s:p.normal.left = [ [ s:base023, s:blue ], [ s:base3, s:base01 ] ]
-let s:p.normal.right = [ [ s:base02, s:base1 ], [ s:base2, s:base01 ] ]
-let s:p.inactive.right = [ [ s:base02, s:base0 ], [ s:base1, s:base01 ] ]
-let s:p.inactive.left =  [ [ s:base02, s:base0 ], [ s:base00, s:base03 ] ]
-let s:p.insert.left = [ [ s:base023, s:green ], [ s:base3, s:base01 ] ]
-let s:p.replace.left = [ [ s:base023, s:orange ], [ s:base3, s:base01 ] ]
-let s:p.visual.left = [ [ s:base023, s:magenta ], [ s:base3, s:base01 ] ]
-let s:p.normal.middle = [ [ s:base1, s:base02 ] ]
-let s:p.inactive.middle = [ [ s:base0, s:base02 ] ]
-let s:p.tabline.left = [ [ s:base2, s:base01 ] ]
-let s:p.tabline.tabsel = [ [ s:base2, s:base03 ] ]
-let s:p.tabline.middle = [ [ s:base01, s:base1 ] ]
-let s:p.tabline.right = copy(s:p.normal.right)
-let s:p.normal.error = [ [ s:base023, s:red ] ]
-let s:p.normal.warning = [ [ s:base023, s:yellow ] ]
-
-let g:lightline#colorscheme#Tomorrow_Night_Blue#palette = lightline#colorscheme#fill(s:p)
diff --git a/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/Tomorrow_Night_Bright.vim b/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/Tomorrow_Night_Bright.vim
deleted file mode 100644
index 5b81a31..0000000
--- a/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/Tomorrow_Night_Bright.vim
+++ /dev/null
@@ -1,42 +0,0 @@
-" =============================================================================
-" Filename: autoload/lightline/colorscheme/Tomorrow_Night_Bright.vim
-" Author: itchyny
-" License: MIT License
-" Last Change: 2013/09/07 14:13:26.
-" =============================================================================
-let s:base3 = '#eaeaea'
-let s:base23 = '#d0d0d0'
-let s:base2 = '#c6c6c6'
-let s:base1 = '#b2b2b2'
-let s:base0 = '#949494'
-let s:base00 = '#767676'
-let s:base01 = '#606060'
-let s:base02 = '#4e4e4e'
-let s:base023 = '#262626'
-let s:base03 = '#12124c'
-let s:red = '#d54e53'
-let s:orange = '#e78c45'
-let s:yellow = '#e7c547'
-let s:green = '#b9ca4a'
-let s:cyan = '#70c0b1'
-let s:blue = '#7aa6da'
-let s:magenta = '#c397d8'
-
-let s:p = {'normal': {}, 'inactive': {}, 'insert': {}, 'replace': {}, 'visual': {}, 'tabline': {}}
-let s:p.normal.left = [ [ s:base023, s:blue ], [ s:base3, s:base01 ] ]
-let s:p.normal.right = [ [ s:base02, s:base1 ], [ s:base2, s:base01 ] ]
-let s:p.inactive.right = [ [ s:base02, s:base0 ], [ s:base1, s:base01 ] ]
-let s:p.inactive.left =  [ [ s:base02, s:base0 ], [ s:base00, s:base03 ] ]
-let s:p.insert.left = [ [ s:base023, s:green ], [ s:base3, s:base01 ] ]
-let s:p.replace.left = [ [ s:base023, s:orange ], [ s:base3, s:base01 ] ]
-let s:p.visual.left = [ [ s:base023, s:magenta ], [ s:base3, s:base01 ] ]
-let s:p.normal.middle = [ [ s:base1, s:base02 ] ]
-let s:p.inactive.middle = [ [ s:base0, s:base02 ] ]
-let s:p.tabline.left = [ [ s:base2, s:base01 ] ]
-let s:p.tabline.tabsel = [ [ s:base2, s:base023 ] ]
-let s:p.tabline.middle = [ [ s:base01, s:base1 ] ]
-let s:p.tabline.right = copy(s:p.normal.right)
-let s:p.normal.error = [ [ s:red, s:base023 ] ]
-let s:p.normal.warning = [ [ s:yellow, s:base02 ] ]
-
-let g:lightline#colorscheme#Tomorrow_Night_Bright#palette = lightline#colorscheme#fill(s:p)
diff --git a/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/Tomorrow_Night_Eighties.vim b/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/Tomorrow_Night_Eighties.vim
deleted file mode 100644
index 5124ecc..0000000
--- a/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/Tomorrow_Night_Eighties.vim
+++ /dev/null
@@ -1,42 +0,0 @@
-" =============================================================================
-" Filename: autoload/lightline/colorscheme/Tomorrow_Night_Eighties.vim
-" Author: itchyny
-" License: MIT License
-" Last Change: 2013/09/07 14:14:14.
-" =============================================================================
-let s:base3 = '#cccccc'
-let s:base23 = '#bbbbbb'
-let s:base2 = '#aaaaaa'
-let s:base1 = '#999999'
-let s:base0 = '#777777'
-let s:base00 = '#666666'
-let s:base01 = '#555555'
-let s:base02 = '#444444'
-let s:base023 = '#333333'
-let s:base03 = '#2d2d2d'
-let s:red = '#f2777a'
-let s:orange = '#f99157'
-let s:yellow = '#ffcc66'
-let s:green = '#99cc99'
-let s:cyan = '#009999'
-let s:blue = '#99cccc'
-let s:magenta = '#cc99cc'
-
-let s:p = {'normal': {}, 'inactive': {}, 'insert': {}, 'replace': {}, 'visual': {}, 'tabline': {}}
-let s:p.normal.left = [ [ s:base023, s:blue ], [ s:base3, s:base01 ] ]
-let s:p.normal.right = [ [ s:base02, s:base1 ], [ s:base2, s:base01 ] ]
-let s:p.inactive.right = [ [ s:base02, s:base0 ], [ s:base1, s:base01 ] ]
-let s:p.inactive.left =  [ [ s:base02, s:base0 ], [ s:base00, s:base03 ] ]
-let s:p.insert.left = [ [ s:base023, s:green ], [ s:base3, s:base01 ] ]
-let s:p.replace.left = [ [ s:base023, s:orange ], [ s:base3, s:base01 ] ]
-let s:p.visual.left = [ [ s:base023, s:magenta ], [ s:base3, s:base01 ] ]
-let s:p.normal.middle = [ [ s:base1, s:base02 ] ]
-let s:p.inactive.middle = [ [ s:base0, s:base02 ] ]
-let s:p.tabline.left = [ [ s:base2, s:base01 ] ]
-let s:p.tabline.tabsel = [ [ s:base2, s:base03 ] ]
-let s:p.tabline.middle = [ [ s:base01, s:base1 ] ]
-let s:p.tabline.right = copy(s:p.normal.right)
-let s:p.normal.error = [ [ s:base023, s:red ] ]
-let s:p.normal.warning = [ [ s:base023, s:yellow ] ]
-
-let g:lightline#colorscheme#Tomorrow_Night_Eighties#palette = lightline#colorscheme#fill(s:p)
diff --git a/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/ayu_dark.vim b/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/ayu_dark.vim
deleted file mode 100644
index cb10a25..0000000
--- a/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/ayu_dark.vim
+++ /dev/null
@@ -1,42 +0,0 @@
-" =============================================================================
-" Filename: autoload/lightline/colorscheme/ayu_dark.vim
-" Author: danielpeng2
-" License: MIT License
-" Last Change: 2020/05/01 19:37:33.
-" =============================================================================
-
-let s:base0 = '#e6e1cf'
-let s:base1 = '#e6e1cf'
-let s:base2 = '#3e4b59'
-let s:base3 = '#e6e1cf'
-let s:base00 = '#14191f'
-let s:base01 = '#14191f'
-let s:base02 = '#0f1419'
-let s:base023 = '#0f1419'
-let s:base03 = '#e6b673'
-let s:yellow = '#e6b673'
-let s:orange = '#ff7733'
-let s:red = '#f07178'
-let s:magenta = '#ffee99'
-let s:blue = '#36a3d9'
-let s:cyan = s:blue
-let s:green = '#b8cc52'
-
-let s:p = {'normal': {}, 'inactive': {}, 'insert': {}, 'replace': {}, 'visual': {}, 'tabline': {}}
-let s:p.normal.left = [ [ s:base02, s:blue ], [ s:base3, s:base01 ] ]
-let s:p.normal.middle = [ [ s:base2, s:base02 ] ]
-let s:p.normal.right = [ [ s:base02, s:base0 ], [ s:base1, s:base01 ] ]
-let s:p.inactive.left =  [ [ s:base1, s:base01 ], [ s:base3, s:base01 ] ]
-let s:p.inactive.middle = [ [ s:base1, s:base023 ] ]
-let s:p.inactive.right = [ [ s:base1, s:base01 ], [ s:base2, s:base02 ] ]
-let s:p.insert.left = [ [ s:base02, s:green ], [ s:base3, s:base01 ] ]
-let s:p.replace.left = [ [ s:base023, s:red ], [ s:base3, s:base01 ] ]
-let s:p.visual.left = [ [ s:base02, s:magenta ], [ s:base3, s:base01 ] ]
-let s:p.tabline.tabsel = [ [ s:base02, s:base03 ] ]
-let s:p.tabline.left = [ [ s:base3, s:base00 ] ]
-let s:p.tabline.middle = [ [ s:base2, s:base02 ] ]
-let s:p.tabline.right = [ [ s:base2, s:base00 ] ]
-let s:p.normal.error = [ [ s:base03, s:red ] ]
-let s:p.normal.warning = [ [ s:base023, s:yellow ] ]
-
-let g:lightline#colorscheme#ayu_dark#palette = lightline#colorscheme#fill(s:p)
diff --git a/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/ayu_light.vim b/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/ayu_light.vim
deleted file mode 100644
index d1f781a..0000000
--- a/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/ayu_light.vim
+++ /dev/null
@@ -1,42 +0,0 @@
-" =============================================================================
-" Filename: autoload/lightline/colorscheme/ayu_light.vim
-" Author: christalib
-" License: MIT License
-" Last Change: 2020/05/01 19:38:21.
-" =============================================================================
-
-let s:base0 = '#5C6773'
-let s:base1 = '#5C6773'
-let s:base2 = '#828C99'
-let s:base3 = '#5C6773'
-let s:base00 = '#FFFFFF'
-let s:base01 = '#FFFFFF'
-let s:base02 = '#FAFAFA'
-let s:base023 = '#FAFAFA'
-let s:base03 = '#E6B673'
-let s:yellow = '#E6B673'
-let s:orange = '#FF7733'
-let s:red = '#f07178'
-let s:magenta = '#A37ACC'
-let s:blue = '#59c2ff'
-let s:cyan = s:blue
-let s:green = '#86B300'
-
-let s:p = {'normal': {}, 'inactive': {}, 'insert': {}, 'replace': {}, 'visual': {}, 'tabline': {}}
-let s:p.normal.left = [ [ s:base02, s:blue ], [ s:base3, s:base01 ] ]
-let s:p.normal.middle = [ [ s:base2, s:base02 ] ]
-let s:p.normal.right = [ [ s:base02, s:base0 ], [ s:base1, s:base01 ] ]
-let s:p.inactive.left =  [ [ s:base1, s:base01 ], [ s:base3, s:base01 ] ]
-let s:p.inactive.middle = [ [ s:base1, s:base023 ] ]
-let s:p.inactive.right = [ [ s:base1, s:base01 ], [ s:base2, s:base02 ] ]
-let s:p.insert.left = [ [ s:base02, s:green ], [ s:base3, s:base01 ] ]
-let s:p.replace.left = [ [ s:base023, s:red ], [ s:base3, s:base01 ] ]
-let s:p.visual.left = [ [ s:base02, s:magenta ], [ s:base3, s:base01 ] ]
-let s:p.tabline.tabsel = [ [ s:base02, s:base03 ] ]
-let s:p.tabline.left = [ [ s:base3, s:base00 ] ]
-let s:p.tabline.middle = [ [ s:base2, s:base02 ] ]
-let s:p.tabline.right = [ [ s:base2, s:base00 ] ]
-let s:p.normal.error = [ [ s:base03, s:red ] ]
-let s:p.normal.warning = [ [ s:base023, s:yellow ] ]
-
-let g:lightline#colorscheme#ayu_light#palette = lightline#colorscheme#fill(s:p)
diff --git a/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/ayu_mirage.vim b/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/ayu_mirage.vim
deleted file mode 100644
index fe7506f..0000000
--- a/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/ayu_mirage.vim
+++ /dev/null
@@ -1,42 +0,0 @@
-" =============================================================================
-" Filename: autoload/lightline/colorscheme/ayu_mirage.vim
-" Author: impulse
-" License: MIT License
-" Last Change: 2020/05/01 19:37:21.
-" =============================================================================
-
-let s:base0 = '#d9d7ce'
-let s:base1 = '#d9d7ce'
-let s:base2 = '#607080'
-let s:base3 = '#d9d7ce'
-let s:base00 = '#272d38'
-let s:base01 = '#272d38'
-let s:base02 = '#212733'
-let s:base023 = '#212733'
-let s:base03 = '#ffc44c'
-let s:yellow = '#ffc44c'
-let s:orange = '#ffae57'
-let s:red = '#f07178'
-let s:magenta = '#d4bfff'
-let s:blue = '#59c2ff'
-let s:cyan = s:blue
-let s:green = '#bbe67e'
-
-let s:p = {'normal': {}, 'inactive': {}, 'insert': {}, 'replace': {}, 'visual': {}, 'tabline': {}}
-let s:p.normal.left = [ [ s:base02, s:blue ], [ s:base3, s:base01 ] ]
-let s:p.normal.middle = [ [ s:base2, s:base02 ] ]
-let s:p.normal.right = [ [ s:base02, s:base0 ], [ s:base1, s:base01 ] ]
-let s:p.inactive.left =  [ [ s:base1, s:base01 ], [ s:base3, s:base01 ] ]
-let s:p.inactive.middle = [ [ s:base1, s:base023 ] ]
-let s:p.inactive.right = [ [ s:base1, s:base01 ], [ s:base2, s:base02 ] ]
-let s:p.insert.left = [ [ s:base02, s:green ], [ s:base3, s:base01 ] ]
-let s:p.replace.left = [ [ s:base023, s:red ], [ s:base3, s:base01 ] ]
-let s:p.visual.left = [ [ s:base02, s:magenta ], [ s:base3, s:base01 ] ]
-let s:p.tabline.tabsel = [ [ s:base02, s:base03 ] ]
-let s:p.tabline.left = [ [ s:base3, s:base00 ] ]
-let s:p.tabline.middle = [ [ s:base2, s:base02 ] ]
-let s:p.tabline.right = [ [ s:base2, s:base00 ] ]
-let s:p.normal.error = [ [ s:base03, s:red ] ]
-let s:p.normal.warning = [ [ s:base023, s:yellow ] ]
-
-let g:lightline#colorscheme#ayu_mirage#palette = lightline#colorscheme#fill(s:p)
diff --git a/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/darcula.vim b/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/darcula.vim
deleted file mode 100644
index 928e8b7..0000000
--- a/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/darcula.vim
+++ /dev/null
@@ -1,37 +0,0 @@
-" =============================================================================
-" Filename: autoload/lightline/colorscheme/darcula.vim
-" Author: kkopec
-" License: MIT License
-" Last Change: 2017/02/11 21:18:54.
-" =============================================================================
-
-let s:black = [ '#2b2b2b', 235 ]
-let s:gray = [ '#323232', 236 ]
-let s:white = [ '#a9b7c6', 250 ]
-let s:blue = [ '#6897bb' , 67 ] 
-let s:green = [ '#629755', 71 ] 
-let s:purple = [ '#9876aa', 104 ]
-let s:red = [ '#ff6b68', 204 ]
-let s:yellow = [ '#ffc66d', 222 ]
-
-let s:p = {'normal': {}, 'inactive': {}, 'insert': {}, 'replace': {}, 'visual': {}, 'tabline': {}}
-let s:p.normal.left = [ [ s:black, s:purple ], [ s:purple, s:gray ] ]
-let s:p.normal.right = [ [ s:black, s:purple ], [ s:purple, s:gray ] ]
-let s:p.inactive.left =  [ [ s:black, s:blue ], [ s:blue, s:gray ] ]
-let s:p.inactive.right = [ [ s:black, s:blue ], [ s:blue, s:gray ] ]
-let s:p.insert.left = [ [ s:black, s:green ], [ s:green, s:gray ] ] 
-let s:p.insert.right = [ [ s:black, s:green ], [ s:green, s:gray ] ]
-let s:p.replace.left = [ [ s:black, s:red ], [ s:red, s:gray ] ]
-let s:p.replace.right = [ [ s:black, s:red ], [ s:red, s:gray ] ]
-let s:p.visual.left = [ [ s:black, s:yellow ], [ s:yellow, s:gray ] ]
-let s:p.visual.right = [ [ s:black, s:yellow ], [ s:yellow, s:gray ] ]
-let s:p.normal.middle = [ [ s:white, s:gray ] ]
-let s:p.inactive.middle = [ [ s:white, s:gray ] ]
-let s:p.tabline.left = [ [ s:blue, s:gray ] ]
-let s:p.tabline.tabsel = [ [ s:black, s:blue ] ]
-let s:p.tabline.middle = [ [ s:blue, s:gray ] ]
-let s:p.tabline.right = [ [ s:black, s:blue ] ]
-let s:p.normal.error = [ [ s:red, s:black ] ]
-let s:p.normal.warning = [ [ s:yellow, s:black ] ]
-
-let g:lightline#colorscheme#darcula#palette = lightline#colorscheme#flatten(s:p)
diff --git a/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/default.vim b/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/default.vim
deleted file mode 100644
index ee9835c..0000000
--- a/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/default.vim
+++ /dev/null
@@ -1,8 +0,0 @@
-" =============================================================================
-" Filename: autoload/lightline/colorscheme/default.vim
-" Author: itchyny
-" License: MIT License
-" Last Change: 2013/08/22 06:05:52.
-" =============================================================================
-
-let g:lightline#colorscheme#default#palette = g:lightline#colorscheme#powerline#palette
diff --git a/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/deus.vim b/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/deus.vim
deleted file mode 100644
index 3f9f226..0000000
--- a/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/deus.vim
+++ /dev/null
@@ -1,39 +0,0 @@
-" =============================================================================
-" Filename: autoload/lightline/colorscheme/deus.vim
-" Author: nikersify
-" License: MIT License
-" Last Change: 2020/02/15 20:56:45.
-" =============================================================================
-
-let s:term_red = 204
-let s:term_green = 114
-let s:term_yellow = 180
-let s:term_blue = 39
-let s:term_purple = 170
-let s:term_white = 145
-let s:term_black = 235
-let s:term_grey = 236
-
-let s:p = {'normal': {}, 'inactive': {}, 'insert': {}, 'replace': {}, 'visual': {}, 'tabline': {}}
-
-let s:p.normal.left = [ [ '#292c33', '#98c379', s:term_black, s:term_green, 'bold' ], [ '#98c379', '#292c33', s:term_green, s:term_black ] ]
-let s:p.normal.right = [ [ '#292c33', '#98c379', s:term_black, s:term_green ], [ '#abb2bf', '#3e4452', s:term_white, s:term_grey ], [ '#98c379', '#292c33', s:term_green, s:term_black ] ]
-let s:p.inactive.right = [ [ '#292c33', '#61afef', s:term_black, s:term_blue], [ '#abb2bf', '#3e4452', s:term_white, s:term_grey ] ]
-let s:p.inactive.left = s:p.inactive.right[1:]
-let s:p.insert.left = [ [ '#292c33', '#61afef', s:term_black, s:term_blue, 'bold' ], [ '#61afef', '#292c33', s:term_blue, s:term_black ] ]
-let s:p.insert.right = [ [ '#292c33', '#61afef', s:term_black, s:term_blue ], [ '#ABB2BF', '#3E4452', s:term_white, s:term_grey ], [ '#61afef', '#292c33', s:term_blue, s:term_black ] ]
-let s:p.replace.left = [ [ '#292c33', '#e06c75', s:term_black, s:term_red, 'bold' ], [ '#e06c75', '#292c33', s:term_red, s:term_black ] ]
-let s:p.replace.right = [ [ '#292c33', '#e06c75', s:term_black, s:term_red ], s:p.normal.right[1], [ '#e06c75', '#292c33', s:term_red, s:term_black ] ]
-let s:p.visual.left = [ [ '#292c33', '#c678dd', s:term_black, s:term_purple, 'bold' ], [ '#c678dd', '#292c33', s:term_purple, s:term_black ] ]
-let s:p.visual.right = [ [ '#292c33', '#c678dd', s:term_black, s:term_purple ], s:p.normal.right[1], [ '#c678dd', '#292c33', s:term_purple, s:term_black ] ]
-let s:p.normal.middle = [ [ '#abb2bf', '#292c33', s:term_white, s:term_black ] ]
-let s:p.insert.middle = s:p.normal.middle
-let s:p.replace.middle = s:p.normal.middle
-let s:p.tabline.left = [ s:p.normal.left[1] ]
-let s:p.tabline.tabsel = [ s:p.normal.left[0] ]
-let s:p.tabline.middle = s:p.normal.middle
-let s:p.tabline.right = [ s:p.normal.left[1] ]
-let s:p.normal.error = [ [ '#292c33', '#e06c75', s:term_black, s:term_red ] ]
-let s:p.normal.warning = [ [ '#292c33', '#e5c07b', s:term_black, s:term_yellow ] ]
-
-let g:lightline#colorscheme#deus#palette = lightline#colorscheme#fill(s:p)
diff --git a/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/jellybeans.vim b/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/jellybeans.vim
deleted file mode 100644
index 262442a..0000000
--- a/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/jellybeans.vim
+++ /dev/null
@@ -1,40 +0,0 @@
-" =============================================================================
-" Filename: autoload/lightline/colorscheme/jellybeans.vim
-" Author: itchyny
-" License: MIT License
-" Last Change: 2013/09/07 12:21:04.
-" =============================================================================
-let s:base03 = [ '#151513', 233 ]
-let s:base02 = [ '#30302c', 236 ]
-let s:base01 = [ '#4e4e43', 239 ]
-let s:base00 = [ '#666656', 242  ]
-let s:base0 = [ '#808070', 244 ]
-let s:base1 = [ '#949484', 246 ]
-let s:base2 = [ '#a8a897', 248 ]
-let s:base3 = [ '#e8e8d3', 253 ]
-let s:yellow = [ '#ffb964', 215 ]
-let s:orange = [ '#fad07a', 222 ]
-let s:red = [ '#cf6a4c', 167 ]
-let s:magenta = [ '#f0a0c0', 217 ]
-let s:blue = [ '#8197bf', 103 ]
-let s:cyan = [ '#8fbfdc', 110 ]
-let s:green = [ '#99ad6a', 107 ]
-
-let s:p = {'normal': {}, 'inactive': {}, 'insert': {}, 'replace': {}, 'visual': {}, 'tabline': {}}
-let s:p.normal.left = [ [ s:base02, s:blue ], [ s:base3, s:base01 ] ]
-let s:p.normal.right = [ [ s:base02, s:base1 ], [ s:base2, s:base01 ] ]
-let s:p.inactive.right = [ [ s:base02, s:base00 ], [ s:base0, s:base02 ] ]
-let s:p.inactive.left =  [ [ s:base0, s:base02 ], [ s:base00, s:base02 ] ]
-let s:p.insert.left = [ [ s:base02, s:green ], [ s:base3, s:base01 ] ]
-let s:p.replace.left = [ [ s:base02, s:red ], [ s:base3, s:base01 ] ]
-let s:p.visual.left = [ [ s:base02, s:magenta ], [ s:base3, s:base01 ] ]
-let s:p.normal.middle = [ [ s:base0, s:base02 ] ]
-let s:p.inactive.middle = [ [ s:base00, s:base02 ] ]
-let s:p.tabline.left = [ [ s:base3, s:base00 ] ]
-let s:p.tabline.tabsel = [ [ s:base3, s:base02 ] ]
-let s:p.tabline.middle = [ [ s:base01, s:base1 ] ]
-let s:p.tabline.right = copy(s:p.normal.right)
-let s:p.normal.error = [ [ s:red, s:base02 ] ]
-let s:p.normal.warning = [ [ s:yellow, s:base01 ] ]
-
-let g:lightline#colorscheme#jellybeans#palette = lightline#colorscheme#flatten(s:p)
diff --git a/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/landscape.vim b/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/landscape.vim
deleted file mode 100644
index 68d0920..0000000
--- a/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/landscape.vim
+++ /dev/null
@@ -1,25 +0,0 @@
-" =============================================================================
-" Filename: autoload/lightline/colorscheme/landscape.vim
-" Author: itchyny
-" License: MIT License
-" Last Change: 2015/11/26 21:49:44.
-" =============================================================================
-
-let s:p = {'normal': {}, 'inactive': {}, 'insert': {}, 'replace': {}, 'visual': {}, 'tabline': {}}
-let s:p.normal.left = [ ['#0000ff', '#ffffff', 21, 231, 'bold' ], [ '#ffffff', '#0000ff', 231, 21 ] ]
-let s:p.normal.right = [ [ '#303030', '#d0d0d0', 236, 252 ], [ '#303030', '#8a8a8a', 236, 245 ], [ '#bcbcbc', '#585858', 250, 240 ] ]
-let s:p.inactive.right = [ [ '#121212', '#606060', 233, 241 ], [ '#121212', '#3a3a3a', 233, 237 ], [ '#121212', '#262626', 233, 235 ] ]
-let s:p.inactive.left = s:p.inactive.right[1:]
-let s:p.insert.left =  [ ['#005f00', '#ffffff', 22, 231, 'bold' ], [ '#ffffff', '#005f00', 231, 22 ] ]
-let s:p.replace.left = [ [ '#af0000', '#ffffff', 124, 231, 'bold' ], [ '#ffffff', '#af0000', 231, 124 ] ]
-let s:p.visual.left = [ [ '#5f00ff', '#ffffff', 57, 231, 'bold' ], [ '#ffffff', '#5f00ff', 231, 57 ] ]
-let s:p.normal.middle = [ [ '#8a8a8a', '#303030', 245, 236 ] ]
-let s:p.inactive.middle = [ [ '#303030', '#121212', 236, 233 ] ]
-let s:p.tabline.left = [ [ '#d0d0d0', '#666666', 252, 242 ] ]
-let s:p.tabline.tabsel = [ [ '#dadada', '#121212', 253, 233 ] ]
-let s:p.tabline.middle = [ [ '#8a8a8a', '#3a3a3a', 245, 237 ] ]
-let s:p.tabline.right = [ [ '#d0d0d0', '#666666', 252, 242 ] ]
-let s:p.normal.error = [ [ '#d0d0d0', '#ff0000', 252, 196 ] ]
-let s:p.normal.warning = [ [ '#262626', '#ffff00', 235, 226 ] ]
-
-let g:lightline#colorscheme#landscape#palette = s:p
diff --git a/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/materia.vim b/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/materia.vim
deleted file mode 100644
index fdab2cb..0000000
--- a/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/materia.vim
+++ /dev/null
@@ -1,63 +0,0 @@
-" =============================================================================
-" Filename: autoload/lightline/colorscheme/materia.vim
-" Author: Lokesh Krishna
-" License: MIT License
-" Last Change: 2017/11/25 11:13:40.
-" =============================================================================
-
-" Common colors
-let s:fg     = '#d5dbe5'
-let s:blue   = '#89ddff'
-let s:green  = '#8bd649'
-let s:purple = '#82aaff'
-let s:red1   = '#ec5f67'
-let s:red2   = '#ec5f67'
-let s:yellow = '#ffcc00'
-
-let s:p = {'normal': {}, 'inactive': {}, 'insert': {}, 'replace': {}, 'visual': {}, 'tabline': {}}
-
-if lightline#colorscheme#background() ==# 'light'
-  " Light variant
-  let s:bg     = '#ffffff'
-  let s:gray1  = '#2c393f'
-  let s:gray2  = '#d5dbe5'
-  let s:gray3  = '#707880'
-
-  let s:p.normal.left     = [ [ s:bg, s:green, 'bold' ], [ s:gray1, s:gray3 ] ]
-  let s:p.normal.middle   = [ [ s:gray1, s:gray2 ] ]
-  let s:p.inactive.left   = [ [ s:bg,  s:gray3 ], [ s:bg, s:gray3 ] ]
-  let s:p.inactive.middle = [ [ s:gray3, s:gray2 ] ]
-  let s:p.inactive.right  = [ [ s:bg, s:gray3 ], [ s:bg, s:gray3 ] ]
-  let s:p.insert.left     = [ [ s:bg, s:blue, 'bold' ], [ s:gray1, s:gray3 ] ]
-  let s:p.replace.left    = [ [ s:bg, s:red1, 'bold' ], [ s:gray1, s:gray3 ] ]
-  let s:p.visual.left     = [ [ s:bg, s:purple, 'bold' ], [ s:gray1, s:gray3 ] ]
-else
-  " Dark variant
-  let s:bg     = '#263238'
-  let s:gray1  = '#37474f'
-  let s:gray2  = '#2c393f'
-  let s:gray3  = '#37474f'
-
-  let s:p.normal.left     = [ [ s:bg, s:green, 'bold' ], [ s:fg, s:gray3 ] ]
-  let s:p.normal.middle   = [ [ s:fg, s:gray2 ] ]
-  let s:p.inactive.left   = [ [ s:gray1,  s:bg ], [ s:gray1, s:bg ] ]
-  let s:p.inactive.middle = [ [ s:gray1, s:gray2 ] ]
-  let s:p.inactive.right  = [ [ s:gray1, s:bg ], [ s:gray1, s:bg ] ]
-  let s:p.insert.left     = [ [ s:bg, s:blue, 'bold' ], [ s:fg, s:gray3 ] ]
-  let s:p.replace.left    = [ [ s:bg, s:red1, 'bold' ], [ s:fg, s:gray3 ] ]
-  let s:p.visual.left     = [ [ s:bg, s:purple, 'bold' ], [ s:fg, s:gray3 ] ]
-endif
-
-" Common
-let s:p.normal.right   = [ [ s:bg, s:green, 'bold' ], [ s:bg, s:green, 'bold' ] ]
-let s:p.normal.error   = [ [ s:red2,   s:bg ] ]
-let s:p.normal.warning = [ [ s:yellow, s:bg ] ]
-let s:p.insert.right   = [ [ s:bg, s:blue, 'bold' ], [ s:bg, s:blue, 'bold' ] ]
-let s:p.replace.right  = [ [ s:bg, s:red1, 'bold' ], [ s:bg, s:red1, 'bold' ] ]
-let s:p.visual.right   = [ [ s:bg, s:purple, 'bold' ], [ s:bg, s:purple, 'bold' ] ]
-let s:p.tabline.left   = [ [ s:bg, s:gray3 ] ]
-let s:p.tabline.tabsel = [ [ s:bg, s:purple, 'bold' ] ]
-let s:p.tabline.middle = [ [ s:gray3, s:gray2 ] ]
-let s:p.tabline.right  = copy(s:p.normal.right)
-
-let g:lightline#colorscheme#materia#palette = lightline#colorscheme#fill(s:p)
diff --git a/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/material.vim b/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/material.vim
deleted file mode 100644
index 0d704b7..0000000
--- a/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/material.vim
+++ /dev/null
@@ -1,63 +0,0 @@
-" =============================================================================
-" Filename: autoload/lightline/colorscheme/material.vim
-" Author: Lokesh Krishna
-" License: MIT License
-" Last Change: 2017/11/25 11:13:42.
-" =============================================================================
-
-" Common colors
-let s:fg     = '#eeffff'
-let s:blue   = '#82aaff'
-let s:green  = '#c3e88d'
-let s:purple = '#c792ea'
-let s:red1   = '#f07178'
-let s:red2   = '#ff5370'
-let s:yellow = '#ffcb6b'
-
-let s:p = {'normal': {}, 'inactive': {}, 'insert': {}, 'replace': {}, 'visual': {}, 'tabline': {}}
-
-if lightline#colorscheme#background() ==# 'light'
-  " Light variant
-  let s:bg     = '#ffffff'
-  let s:gray1  = '#2e3c43'
-  let s:gray2  = '#eeffff'
-  let s:gray3  = '#546e7a'
-
-  let s:p.normal.left     = [ [ s:bg, s:blue, 'bold' ], [ s:gray1, s:gray3 ] ]
-  let s:p.normal.middle   = [ [ s:gray1, s:gray2 ] ]
-  let s:p.inactive.left   = [ [ s:bg,  s:gray3 ], [ s:bg, s:gray3 ] ]
-  let s:p.inactive.middle = [ [ s:gray3, s:gray2 ] ]
-  let s:p.inactive.right  = [ [ s:bg, s:gray3 ], [ s:bg, s:gray3 ] ]
-  let s:p.insert.left     = [ [ s:bg, s:green, 'bold' ], [ s:gray1, s:gray3 ] ]
-  let s:p.replace.left    = [ [ s:bg, s:red1, 'bold' ], [ s:gray1, s:gray3 ] ]
-  let s:p.visual.left     = [ [ s:bg, s:purple, 'bold' ], [ s:gray1, s:gray3 ] ]
-else
-  " Dark variant
-  let s:bg     = '#263238'
-  let s:gray1  = '#314549'
-  let s:gray2  = '#2E3C43'
-  let s:gray3  = '#314549'
-
-  let s:p.normal.left     = [ [ s:bg, s:blue, 'bold' ], [ s:fg, s:gray3 ] ]
-  let s:p.normal.middle   = [ [ s:fg, s:gray2 ] ]
-  let s:p.inactive.left   = [ [ s:gray1,  s:bg ], [ s:gray1, s:bg ] ]
-  let s:p.inactive.middle = [ [ s:gray1, s:gray2 ] ]
-  let s:p.inactive.right  = [ [ s:gray1, s:bg ], [ s:gray1, s:bg ] ]
-  let s:p.insert.left     = [ [ s:bg, s:green, 'bold' ], [ s:fg, s:gray3 ] ]
-  let s:p.replace.left    = [ [ s:bg, s:red1, 'bold' ], [ s:fg, s:gray3 ] ]
-  let s:p.visual.left     = [ [ s:bg, s:purple, 'bold' ], [ s:fg, s:gray3 ] ]
-endif
-
-" Common
-let s:p.normal.right   = [ [ s:bg, s:blue, 'bold' ], [ s:bg, s:blue, 'bold' ] ]
-let s:p.normal.error   = [ [ s:red2,   s:bg ] ]
-let s:p.normal.warning = [ [ s:yellow, s:bg ] ]
-let s:p.insert.right   = [ [ s:bg, s:green, 'bold' ], [ s:bg, s:green, 'bold' ] ]
-let s:p.replace.right  = [ [ s:bg, s:red1, 'bold' ], [ s:bg, s:red1, 'bold' ] ]
-let s:p.visual.right   = [ [ s:bg, s:purple, 'bold' ], [ s:bg, s:purple, 'bold' ] ]
-let s:p.tabline.left   = [ [ s:fg, s:gray3 ] ]
-let s:p.tabline.tabsel = [ [ s:bg, s:purple, 'bold' ] ]
-let s:p.tabline.middle = [ [ s:gray3, s:gray2 ] ]
-let s:p.tabline.right  = [ [ s:bg, s:red1, 'bold' ] ]
-
-let g:lightline#colorscheme#material#palette = lightline#colorscheme#fill(s:p)
diff --git a/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/molokai.vim b/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/molokai.vim
deleted file mode 100644
index c17cafb..0000000
--- a/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/molokai.vim
+++ /dev/null
@@ -1,36 +0,0 @@
-" =============================================================================
-" Filename: autoload/lightline/colorscheme/molokai.vim
-" Author: challsted
-" License: MIT License
-" Last Change: 2020/02/15 20:57:45.
-" =============================================================================
-
-let s:black = [ '#232526', 233 ]
-let s:gray = [ '#808080', 244 ]
-let s:white = [ '#f8f8f2', 234 ]
-let s:cyan = [ '#66d9ef', 81 ]
-let s:green = [ '#a6e22e', 118 ]
-let s:orange = [ '#ef5939', 166 ]
-let s:pink = [ '#f92672', 161 ]
-let s:red = [ '#ff0000', 160 ]
-let s:yellow = [ '#e6db74', 229 ]
-
-let s:p = {'normal': {}, 'inactive': {}, 'insert': {}, 'replace': {}, 'visual': {}, 'tabline': {}}
-
-let s:p.normal.left = [ [ s:black, s:cyan ], [ s:orange, s:black ] ]
-let s:p.normal.middle = [ [ s:orange, s:black ] ]
-let s:p.normal.right = [ [ s:pink, s:black ], [ s:black, s:pink ] ]
-let s:p.normal.error = [ [ s:pink, s:black ] ]
-let s:p.normal.warning = [ [ s:yellow, s:black ] ]
-let s:p.insert.left = [ [ s:black, s:green ], [ s:green, s:black ] ]
-let s:p.visual.left = [ [ s:black, s:yellow ], [ s:yellow, s:black ] ]
-let s:p.replace.left = [ [ s:black, s:red ], [ s:red, s:black ] ]
-let s:p.inactive.left =  [ [ s:pink, s:black ], [ s:white, s:black ] ]
-let s:p.inactive.middle = [ [ s:gray, s:black ] ]
-let s:p.inactive.right = [ [ s:white, s:pink ], [ s:pink, s:black ] ]
-let s:p.tabline.left = [ [ s:pink, s:black ] ]
-let s:p.tabline.middle = [ [ s:pink, s:black] ]
-let s:p.tabline.right = copy(s:p.normal.right)
-let s:p.tabline.tabsel = [ [ s:black, s:pink ] ]
-
-let g:lightline#colorscheme#molokai#palette = lightline#colorscheme#flatten(s:p)
diff --git a/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/nord.vim b/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/nord.vim
deleted file mode 100644
index 96d24ae..0000000
--- a/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/nord.vim
+++ /dev/null
@@ -1,46 +0,0 @@
-" =============================================================================
-" Filename: autoload/lightline/colorscheme/nord.vim
-" Author: arcticicestudio
-" License: MIT
-" Last Change: 2017/11/12 20:27:51
-" =============================================================================
-
-let s:p = {'normal': {}, 'inactive': {}, 'insert': {}, 'replace': {}, 'visual': {}, 'tabline': {}}
-
-let s:nord0 = ["#2E3440", "NONE"]
-let s:nord1 = ["#3B4252", 0]
-let s:nord2 = ["#434C5E", "NONE"]
-let s:nord3 = ["#4C566A", 8]
-let s:nord4 = ["#D8DEE9", "NONE"]
-let s:nord5 = ["#E5E9F0", 7]
-let s:nord6 = ["#ECEFF4", 15]
-let s:nord7 = ["#8FBCBB", 14]
-let s:nord8 = ["#88C0D0", 6]
-let s:nord9 = ["#81A1C1", 4]
-let s:nord10 = ["#5E81AC", 12]
-let s:nord11 = ["#BF616A", 1]
-let s:nord12 = ["#D08770", 11]
-let s:nord13 = ["#EBCB8B", 3]
-let s:nord14 = ["#A3BE8C", 2]
-let s:nord15 = ["#B48EAD", 5]
-
-let s:p.normal.left = [ [ s:nord1, s:nord8 ], [ s:nord5, s:nord1 ] ]
-let s:p.normal.middle = [ [ s:nord5, s:nord3 ] ]
-let s:p.normal.right = [ [ s:nord5, s:nord1 ], [ s:nord5, s:nord1 ] ]
-let s:p.normal.warning = [ [ s:nord1, s:nord13 ] ]
-let s:p.normal.error = [ [ s:nord1, s:nord11 ] ]
-
-let s:p.inactive.left =  [ [ s:nord1, s:nord8 ], [ s:nord5, s:nord1 ] ]
-let s:p.inactive.middle = [ [ s:nord5, s:nord1 ] ]
-let s:p.inactive.right = [ [ s:nord5, s:nord1 ], [ s:nord5, s:nord1 ] ]
-
-let s:p.insert.left = [ [ s:nord1, s:nord6 ], [ s:nord5, s:nord1 ] ]
-let s:p.replace.left = [ [ s:nord1, s:nord13 ], [ s:nord5, s:nord1 ] ]
-let s:p.visual.left = [ [ s:nord1, s:nord7 ], [ s:nord5, s:nord1 ] ]
-
-let s:p.tabline.left = [ [ s:nord5, s:nord3 ] ]
-let s:p.tabline.middle = [ [ s:nord5, s:nord3 ] ]
-let s:p.tabline.right = [ [ s:nord5, s:nord3 ] ]
-let s:p.tabline.tabsel = [ [ s:nord1, s:nord8 ] ]
-
-let g:lightline#colorscheme#nord#palette = lightline#colorscheme#flatten(s:p)
diff --git a/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/one.vim b/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/one.vim
deleted file mode 100644
index b986acf..0000000
--- a/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/one.vim
+++ /dev/null
@@ -1,60 +0,0 @@
-" =============================================================================
-" Filename: autoload/lightline/colorscheme/one.vim
-" Author: Zoltan Dalmadi
-" License: MIT License
-" Last Change: 2019/09/09 22:42:48.
-" =============================================================================
-
-" Common colors
-let s:blue   = [ '#61afef', 75 ]
-let s:green  = [ '#98c379', 76 ]
-let s:purple = [ '#c678dd', 176 ]
-let s:red1   = [ '#e06c75', 168 ]
-let s:red2   = [ '#be5046', 168 ]
-let s:yellow = [ '#e5c07b', 180 ]
-
-let s:p = {'normal': {}, 'inactive': {}, 'insert': {}, 'replace': {}, 'visual': {}, 'tabline': {}}
-
-if lightline#colorscheme#background() ==# 'light'
-  " Light variant
-  let s:fg    = [ '#494b53', 238 ]
-  let s:bg    = [ '#fafafa', 255 ]
-  let s:gray1 = [ '#494b53', 238 ]
-  let s:gray2 = [ '#f0f0f0', 255 ]
-  let s:gray3 = [ '#d0d0d0', 250 ]
-  let s:green = [ '#98c379', 35 ]
-
-  let s:p.inactive.left   = [ [ s:bg,  s:gray3 ], [ s:bg, s:gray3 ] ]
-  let s:p.inactive.middle = [ [ s:gray3, s:gray2 ] ]
-  let s:p.inactive.right  = [ [ s:bg, s:gray3 ] ]
-else
-  " Dark variant
-  let s:fg    = [ '#abb2bf', 145 ]
-  let s:bg    = [ '#282c34', 235 ]
-  let s:gray1 = [ '#5c6370', 241 ]
-  let s:gray2 = [ '#2c323d', 235 ]
-  let s:gray3 = [ '#3e4452', 240 ]
-
-  let s:p.inactive.left   = [ [ s:gray1,  s:bg ], [ s:gray1, s:bg ] ]
-  let s:p.inactive.middle = [ [ s:gray1, s:gray2 ] ]
-  let s:p.inactive.right  = [ [ s:gray1, s:bg ] ]
-endif
-
-" Common
-let s:p.normal.left    = [ [ s:bg, s:green, 'bold' ], [ s:fg, s:gray3 ] ]
-let s:p.normal.middle  = [ [ s:fg, s:gray2 ] ]
-let s:p.normal.right   = [ [ s:bg, s:green, 'bold' ], [ s:fg, s:gray3 ] ]
-let s:p.normal.error   = [ [ s:red2, s:bg ] ]
-let s:p.normal.warning = [ [ s:yellow, s:bg ] ]
-let s:p.insert.right   = [ [ s:bg, s:blue, 'bold' ], [ s:fg, s:gray3 ] ]
-let s:p.insert.left    = [ [ s:bg, s:blue, 'bold' ], [ s:fg, s:gray3 ] ]
-let s:p.replace.right  = [ [ s:bg, s:red1, 'bold' ], [ s:fg, s:gray3 ] ]
-let s:p.replace.left   = [ [ s:bg, s:red1, 'bold' ], [ s:fg, s:gray3 ] ]
-let s:p.visual.right   = [ [ s:bg, s:purple, 'bold' ], [ s:fg, s:gray3 ] ]
-let s:p.visual.left    = [ [ s:bg, s:purple, 'bold' ], [ s:fg, s:gray3 ] ]
-let s:p.tabline.left   = [ [ s:fg, s:gray3 ] ]
-let s:p.tabline.tabsel = [ [ s:bg, s:purple, 'bold' ] ]
-let s:p.tabline.middle = [ [ s:gray3, s:gray2 ] ]
-let s:p.tabline.right  = copy(s:p.normal.right)
-
-let g:lightline#colorscheme#one#palette = lightline#colorscheme#flatten(s:p)
diff --git a/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/powerline.vim b/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/powerline.vim
deleted file mode 100644
index 40e48d4..0000000
--- a/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/powerline.vim
+++ /dev/null
@@ -1,28 +0,0 @@
-" =============================================================================
-" Filename: autoload/lightline/colorscheme/powerline.vim
-" Author: itchyny
-" License: MIT License
-" Last Change: 2013/09/07 15:54:41.
-" =============================================================================
-
-let s:p = {'normal': {}, 'inactive': {}, 'insert': {}, 'replace': {}, 'visual': {}, 'tabline': {}}
-let s:p.normal.left = [ ['darkestgreen', 'brightgreen', 'bold'], ['white', 'gray4'] ]
-let s:p.normal.right = [ ['gray5', 'gray10'], ['gray9', 'gray4'], ['gray8', 'gray2'] ]
-let s:p.inactive.right = [ ['gray1', 'gray5'], ['gray4', 'gray1'], ['gray4', 'gray0'] ]
-let s:p.inactive.left = s:p.inactive.right[1:]
-let s:p.insert.left = [ ['darkestcyan', 'white', 'bold'], ['white', 'darkblue'] ]
-let s:p.insert.right = [ [ 'darkestcyan', 'mediumcyan' ], [ 'mediumcyan', 'darkblue' ], [ 'mediumcyan', 'darkestblue' ] ]
-let s:p.replace.left = [ ['white', 'brightred', 'bold'], ['white', 'gray4'] ]
-let s:p.visual.left = [ ['darkred', 'brightorange', 'bold'], ['white', 'gray4'] ]
-let s:p.normal.middle = [ [ 'gray7', 'gray2' ] ]
-let s:p.insert.middle = [ [ 'mediumcyan', 'darkestblue' ] ]
-let s:p.replace.middle = s:p.normal.middle
-let s:p.replace.right = s:p.normal.right
-let s:p.tabline.left = [ [ 'gray9', 'gray4' ] ]
-let s:p.tabline.tabsel = [ [ 'gray9', 'gray1' ] ]
-let s:p.tabline.middle = [ [ 'gray2', 'gray8' ] ]
-let s:p.tabline.right = [ [ 'gray9', 'gray3' ] ]
-let s:p.normal.error = [ [ 'gray9', 'brightestred' ] ]
-let s:p.normal.warning = [ [ 'gray1', 'yellow' ] ]
-
-let g:lightline#colorscheme#powerline#palette = lightline#colorscheme#fill(s:p)
diff --git a/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/powerlineish.vim b/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/powerlineish.vim
deleted file mode 100644
index 34058a8..0000000
--- a/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/powerlineish.vim
+++ /dev/null
@@ -1,28 +0,0 @@
-" =============================================================================
-" Filename: autoload/lightline/colorscheme/powerlineish.vim
-" Author: itchyny
-" License: MIT License
-" Last Change: 2019/06/12 18:47:00.
-" =============================================================================
-
-let s:p = {'normal': {}, 'inactive': {}, 'insert': {}, 'replace': {}, 'visual': {}, 'tabline': {}}
-let s:p.normal.left = [ ['darkestgreen', 'brightgreen', 'bold'], ['white', 'gray0'] ]
-let s:p.normal.right = [ ['gray10', 'gray2'], ['white', 'gray1'], ['white', 'gray0'] ]
-let s:p.inactive.right = [ ['gray1', 'gray5'], ['gray4', 'gray1'], ['gray4', 'gray0'] ]
-let s:p.inactive.left = s:p.inactive.right[1:]
-let s:p.insert.left = [ ['darkestcyan', 'white', 'bold'], ['mediumcyan', 'darkestblue'] ]
-let s:p.insert.right = [ [ 'darkestblue', 'mediumcyan' ], [ 'mediumcyan', 'darkblue' ], [ 'mediumcyan', 'darkestblue' ] ]
-let s:p.replace.left = [ ['white', 'brightred', 'bold'], ['white', 'gray0'] ]
-let s:p.visual.left = [ ['black', 'brightestorange', 'bold'], ['white', 'gray0'] ]
-let s:p.normal.middle = [ [ 'white', 'gray0' ] ]
-let s:p.insert.middle = [ [ 'mediumcyan', 'darkestblue' ] ]
-let s:p.replace.middle = s:p.normal.middle
-let s:p.replace.right = s:p.normal.right
-let s:p.tabline.left = [ [ 'gray9', 'gray0' ] ]
-let s:p.tabline.tabsel = [ [ 'gray9', 'gray2' ] ]
-let s:p.tabline.middle = [ [ 'gray2', 'gray0' ] ]
-let s:p.tabline.right = [ [ 'gray9', 'gray1' ] ]
-let s:p.normal.error = [ [ 'gray9', 'brightestred' ] ]
-let s:p.normal.warning = [ [ 'gray1', 'yellow' ] ]
-
-let g:lightline#colorscheme#powerlineish#palette = lightline#colorscheme#fill(s:p)
diff --git a/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/selenized_black.vim b/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/selenized_black.vim
deleted file mode 100644
index 4b49793..0000000
--- a/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/selenized_black.vim
+++ /dev/null
@@ -1,49 +0,0 @@
-" =============================================================================
-" Filename: autoload/lightline/colorscheme/selenized_black.vim
-" Author: itchyny
-" License: MIT License
-" Last Change: 2020/05/02 16:56:50.
-" =============================================================================
-
-" https://github.com/jan-warchol/selenized/blob/master/the-values.md#selenized-black
-let s:bg_1      = ['#252525', 0]
-let s:bg_2      = ['#3b3b3b', 8]
-let s:dim_0     = ['#777777', 7]
-let s:red       = ['#ed4a46', 1]
-let s:green     = ['#70b433', 2]
-let s:yellow    = ['#dbb32d', 3]
-let s:blue      = ['#368aeb', 4]
-let s:magenta   = ['#eb6eb7', 5]
-let s:cyan      = ['#3fc5b7', 6]
-let s:brred     = ['#ff5e56', 9]
-let s:brgreen   = ['#83c746', 10]
-let s:bryellow  = ['#efc541', 11]
-let s:brblue    = ['#4f9cfe', 12]
-let s:brmagenta = ['#ff81ca', 13]
-let s:brcyan    = ['#56d8c9', 14]
-
-let s:p = {'normal': {}, 'inactive': {}, 'insert': {}, 'replace': {}, 'visual': {}, 'tabline': {}}
-
-let s:p.normal.right = [[ s:bg_1, s:blue ], [ s:cyan, s:bg_2 ], [ s:dim_0, s:bg_1 ]]
-let s:p.normal.left = [[ s:bg_1, s:blue ], [ s:cyan, s:bg_2 ]]
-let s:p.normal.middle = [[ s:bg_1, s:bg_1 ]]
-let s:p.normal.error = [[ s:bg_1, s:red ]]
-let s:p.normal.warning = [[ s:bg_1, s:yellow ]]
-
-let s:p.insert.right = [[ s:bg_1, s:green ], [ s:cyan, s:bg_2 ], [ s:dim_0, s:bg_1 ]]
-let s:p.insert.left = [[ s:bg_1, s:green ], [ s:cyan, s:bg_2 ]]
-
-let s:p.visual.right = [[ s:bg_1, s:magenta ], [ s:cyan, s:bg_2 ], [ s:dim_0, s:bg_1 ]]
-let s:p.visual.left = [[ s:bg_1, s:magenta ], [ s:cyan, s:bg_2 ]]
-
-let s:p.inactive.left = [[ s:brblue, s:bg_2 ], [ s:cyan, s:bg_2 ]]
-let s:p.inactive.right = [[ s:brblue, s:bg_2 ], [ s:cyan, s:bg_2 ]]
-
-let s:p.replace.right = [[ s:bg_1, s:red ], [ s:cyan, s:bg_2 ], [ s:dim_0, s:bg_1 ]]
-let s:p.replace.left = [[ s:bg_1, s:red ], [ s:cyan, s:bg_2 ]]
-
-let s:p.tabline.right = [[ s:bg_1, s:red ]]
-let s:p.tabline.left = [[ s:cyan, s:bg_2 ]]
-let s:p.tabline.tabsel = [[ s:bg_1, s:blue ]]
-
-let g:lightline#colorscheme#selenized_black#palette = lightline#colorscheme#flatten(s:p)
diff --git a/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/selenized_dark.vim b/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/selenized_dark.vim
deleted file mode 100644
index 619ee8c..0000000
--- a/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/selenized_dark.vim
+++ /dev/null
@@ -1,49 +0,0 @@
-" =============================================================================
-" Filename: autoload/lightline/colorscheme/selenized_dark.vim
-" Author: Charles Hall
-" License: MIT License
-" Last Change: 2020/05/02 16:53:17.
-" =============================================================================
-
-" https://github.com/jan-warchol/selenized/blob/master/the-values.md#selenized-dark
-let s:bg_1      = ['#184956', 0]
-let s:bg_2      = ['#2d5b69', 8]
-let s:dim_0     = ['#72898f', 7]
-let s:red       = ['#fa5750', 1]
-let s:green     = ['#75b938', 2]
-let s:yellow    = ['#dbb32d', 3]
-let s:blue      = ['#4695f7', 4]
-let s:magenta   = ['#f275be', 5]
-let s:cyan      = ['#41c7b9', 6]
-let s:brred     = ['#ff665c', 9]
-let s:brgreen   = ['#84c747', 10]
-let s:bryellow  = ['#ebc13d', 11]
-let s:brblue    = ['#58a3ff', 12]
-let s:brmagenta = ['#ff84cd', 13]
-let s:brcyan    = ['#53d6c7', 14]
-
-let s:p = {'normal': {}, 'inactive': {}, 'insert': {}, 'replace': {}, 'visual': {}, 'tabline': {}}
-
-let s:p.normal.right = [[ s:bg_1, s:blue ], [ s:cyan, s:bg_2 ], [ s:dim_0, s:bg_1 ]]
-let s:p.normal.left = [[ s:bg_1, s:blue ], [ s:cyan, s:bg_2 ]]
-let s:p.normal.middle = [[ s:bg_1, s:bg_1 ]]
-let s:p.normal.error = [[ s:bg_1, s:red ]]
-let s:p.normal.warning = [[ s:bg_1, s:yellow ]]
-
-let s:p.insert.right = [[ s:bg_1, s:green ], [ s:cyan, s:bg_2 ], [ s:dim_0, s:bg_1 ]]
-let s:p.insert.left = [[ s:bg_1, s:green ], [ s:cyan, s:bg_2 ]]
-
-let s:p.visual.right = [[ s:bg_1, s:magenta ], [ s:cyan, s:bg_2 ], [ s:dim_0, s:bg_1 ]]
-let s:p.visual.left = [[ s:bg_1, s:magenta ], [ s:cyan, s:bg_2 ]]
-
-let s:p.inactive.left = [[ s:brblue, s:bg_2 ], [ s:cyan, s:bg_2 ]]
-let s:p.inactive.right = [[ s:brblue, s:bg_2 ], [ s:cyan, s:bg_2 ]]
-
-let s:p.replace.right = [[ s:bg_1, s:red ], [ s:cyan, s:bg_2 ], [ s:dim_0, s:bg_1 ]]
-let s:p.replace.left = [[ s:bg_1, s:red ], [ s:cyan, s:bg_2 ]]
-
-let s:p.tabline.right = [[ s:bg_1, s:red ]]
-let s:p.tabline.left = [[ s:cyan, s:bg_2 ]]
-let s:p.tabline.tabsel = [[ s:bg_1, s:blue ]]
-
-let g:lightline#colorscheme#selenized_dark#palette = lightline#colorscheme#flatten(s:p)
diff --git a/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/selenized_light.vim b/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/selenized_light.vim
deleted file mode 100644
index 1b3f211..0000000
--- a/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/selenized_light.vim
+++ /dev/null
@@ -1,49 +0,0 @@
-" =============================================================================
-" Filename: autoload/lightline/colorscheme/selenized_light.vim
-" Author: itchyny
-" License: MIT License
-" Last Change: 2020/05/02 16:58:00.
-" =============================================================================
-
-" https://github.com/jan-warchol/selenized/blob/master/the-values.md#selenized-light
-let s:bg_1      = ['#ece3cc', 0]
-let s:bg_2      = ['#d5cdb6', 8]
-let s:dim_0     = ['#909995', 7]
-let s:red       = ['#d2212d', 1]
-let s:green     = ['#489100', 2]
-let s:yellow    = ['#ad8900', 3]
-let s:blue      = ['#0072d4', 4]
-let s:magenta   = ['#ca4898', 5]
-let s:cyan      = ['#009c8f', 6]
-let s:brred     = ['#cc1729', 9]
-let s:brgreen   = ['#428b00', 10]
-let s:bryellow  = ['#a78300', 11]
-let s:brblue    = ['#006dce', 12]
-let s:brmagenta = ['#c44392', 13]
-let s:brcyan    = ['#00978a', 14]
-
-let s:p = {'normal': {}, 'inactive': {}, 'insert': {}, 'replace': {}, 'visual': {}, 'tabline': {}}
-
-let s:p.normal.right = [[ s:bg_1, s:blue ], [ s:cyan, s:bg_2 ], [ s:dim_0, s:bg_1 ]]
-let s:p.normal.left = [[ s:bg_1, s:blue ], [ s:cyan, s:bg_2 ]]
-let s:p.normal.middle = [[ s:bg_1, s:bg_1 ]]
-let s:p.normal.error = [[ s:bg_1, s:red ]]
-let s:p.normal.warning = [[ s:bg_1, s:yellow ]]
-
-let s:p.insert.right = [[ s:bg_1, s:green ], [ s:cyan, s:bg_2 ], [ s:dim_0, s:bg_1 ]]
-let s:p.insert.left = [[ s:bg_1, s:green ], [ s:cyan, s:bg_2 ]]
-
-let s:p.visual.right = [[ s:bg_1, s:magenta ], [ s:cyan, s:bg_2 ], [ s:dim_0, s:bg_1 ]]
-let s:p.visual.left = [[ s:bg_1, s:magenta ], [ s:cyan, s:bg_2 ]]
-
-let s:p.inactive.left = [[ s:brblue, s:bg_2 ], [ s:cyan, s:bg_2 ]]
-let s:p.inactive.right = [[ s:brblue, s:bg_2 ], [ s:cyan, s:bg_2 ]]
-
-let s:p.replace.right = [[ s:bg_1, s:red ], [ s:cyan, s:bg_2 ], [ s:dim_0, s:bg_1 ]]
-let s:p.replace.left = [[ s:bg_1, s:red ], [ s:cyan, s:bg_2 ]]
-
-let s:p.tabline.right = [[ s:bg_1, s:red ]]
-let s:p.tabline.left = [[ s:cyan, s:bg_2 ]]
-let s:p.tabline.tabsel = [[ s:bg_1, s:blue ]]
-
-let g:lightline#colorscheme#selenized_light#palette = lightline#colorscheme#flatten(s:p)
diff --git a/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/selenized_white.vim b/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/selenized_white.vim
deleted file mode 100644
index 402818e..0000000
--- a/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/selenized_white.vim
+++ /dev/null
@@ -1,49 +0,0 @@
-" =============================================================================
-" Filename: autoload/whiteline/colorscheme/selenized_white.vim
-" Author: itchyny
-" License: MIT License
-" Last Change: 2020/05/03 19:34:07.
-" =============================================================================
-
-" https://github.com/jan-warchol/selenized/blob/master/the-values.md#selenized-white
-let s:bg_1      = ['#ebebeb', 0]
-let s:bg_2      = ['#cdcdcd', 8]
-let s:dim_0     = ['#878787', 7]
-let s:red       = ['#d6000c', 1]
-let s:green     = ['#1d9700', 2]
-let s:yellow    = ['#c49700', 3]
-let s:blue      = ['#0064e4', 4]
-let s:magenta   = ['#dd0f9d', 5]
-let s:cyan      = ['#00ad9c', 6]
-let s:brred     = ['#bf0000', 9]
-let s:brgreen   = ['#008400', 10]
-let s:bryellow  = ['#af8500', 11]
-let s:brblue    = ['#0054cf', 12]
-let s:brmagenta = ['#c7008b', 13]
-let s:brcyan    = ['#009a8a', 14]
-
-let s:p = {'normal': {}, 'inactive': {}, 'insert': {}, 'replace': {}, 'visual': {}, 'tabline': {}}
-
-let s:p.normal.right = [[ s:bg_1, s:blue ], [ s:cyan, s:bg_2 ], [ s:dim_0, s:bg_1 ]]
-let s:p.normal.left = [[ s:bg_1, s:blue ], [ s:cyan, s:bg_2 ]]
-let s:p.normal.middle = [[ s:bg_1, s:bg_1 ]]
-let s:p.normal.error = [[ s:bg_1, s:red ]]
-let s:p.normal.warning = [[ s:bg_1, s:yellow ]]
-
-let s:p.insert.right = [[ s:bg_1, s:green ], [ s:cyan, s:bg_2 ], [ s:dim_0, s:bg_1 ]]
-let s:p.insert.left = [[ s:bg_1, s:green ], [ s:cyan, s:bg_2 ]]
-
-let s:p.visual.right = [[ s:bg_1, s:magenta ], [ s:cyan, s:bg_2 ], [ s:dim_0, s:bg_1 ]]
-let s:p.visual.left = [[ s:bg_1, s:magenta ], [ s:cyan, s:bg_2 ]]
-
-let s:p.inactive.left = [[ s:brblue, s:bg_2 ], [ s:cyan, s:bg_2 ]]
-let s:p.inactive.right = [[ s:brblue, s:bg_2 ], [ s:cyan, s:bg_2 ]]
-
-let s:p.replace.right = [[ s:bg_1, s:red ], [ s:cyan, s:bg_2 ], [ s:dim_0, s:bg_1 ]]
-let s:p.replace.left = [[ s:bg_1, s:red ], [ s:cyan, s:bg_2 ]]
-
-let s:p.tabline.right = [[ s:bg_1, s:red ]]
-let s:p.tabline.left = [[ s:cyan, s:bg_2 ]]
-let s:p.tabline.tabsel = [[ s:bg_1, s:blue ]]
-
-let g:lightline#colorscheme#selenized_white#palette = lightline#colorscheme#flatten(s:p)
diff --git a/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/seoul256.vim b/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/seoul256.vim
deleted file mode 100644
index 8bc3e5d..0000000
--- a/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/seoul256.vim
+++ /dev/null
@@ -1,42 +0,0 @@
-" =============================================================================
-" Filename: autoload/lightline/colorscheme/seoul256.vim
-" Author: atweiden
-" License: MIT License
-" Last Change: 2015/11/02 08:23:27.
-" =============================================================================
-let s:base03 = [ '#151513', 233 ]
-let s:base02 = [ '#30302c', 236 ]
-let s:base01 = [ '#4e4e43', 239 ]
-let s:base00 = [ '#666656', 242  ]
-let s:base0 = [ '#808070', 244 ]
-let s:base1 = [ '#949484', 246 ]
-let s:base2 = [ '#a8a897', 248 ]
-let s:base3 = [ '#e8e8d3', 253 ]
-let s:yellow = [ '#d8af5f', 3 ]
-let s:orange = [ '#d7875f', 216 ]
-let s:red = [ '#d68787', 131 ]
-let s:magenta = [ '#df5f87', 168 ]
-let s:peach = [ '#d7afaf', 181 ]
-let s:blue = [ '#87afaf', 109 ]
-let s:cyan = [ '#87d7d7', 23 ]
-let s:green = [ '#87af87', 108 ]
-let s:white = [ '#d0d0d0', 252 ]
-
-let s:p = {'normal': {}, 'inactive': {}, 'insert': {}, 'replace': {}, 'visual': {}, 'tabline': {}}
-let s:p.normal.left = [ [ s:base02, s:blue ], [ s:base3, s:base01 ] ]
-let s:p.normal.right = [ [ s:base02, s:base1 ], [ s:base2, s:base01 ] ]
-let s:p.inactive.right = [ [ s:base02, s:base00 ], [ s:base0, s:base02 ] ]
-let s:p.inactive.left =  [ [ s:base0, s:base02 ], [ s:base00, s:base02 ] ]
-let s:p.insert.left = [ [ s:base02, s:green ], [ s:base3, s:base01 ] ]
-let s:p.replace.left = [ [ s:base02, s:magenta ], [ s:base3, s:base01 ] ]
-let s:p.visual.left = [ [ s:base02, s:peach ], [ s:base3, s:base01 ] ]
-let s:p.normal.middle = [ [ s:base0, s:base02 ] ]
-let s:p.inactive.middle = [ [ s:base00, s:base02 ] ]
-let s:p.tabline.left = [ [ s:base3, s:base00 ] ]
-let s:p.tabline.tabsel = [ [ s:base3, s:base02 ] ]
-let s:p.tabline.middle = [ [ s:base01, s:base1 ] ]
-let s:p.tabline.right = copy(s:p.normal.right)
-let s:p.normal.error = [ [ s:red, s:base02 ] ]
-let s:p.normal.warning = [ [ s:yellow, s:base01 ] ]
-
-let g:lightline#colorscheme#seoul256#palette = lightline#colorscheme#flatten(s:p)
diff --git a/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/simpleblack.vim b/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/simpleblack.vim
deleted file mode 100644
index d92610d..0000000
--- a/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/simpleblack.vim
+++ /dev/null
@@ -1,43 +0,0 @@
-" =============================================================================
-" Filename: autoload/lightline/colorscheme/simpleblack.vim
-" Author: lucasprag
-" License: MIT License
-" Last Change: 2019/10/28 22:54:01.
-" =============================================================================
-let s:black = [ '#000000', '0' ]
-let s:black2 = [ '#121212', '233' ]
-
-let s:gray = [ '#262626', '235' ]
-let s:gray2 = [ '#3a3a3a', '237' ]
-let s:gray3 = [ '#4e4e4e', '239' ]
-let s:gray4 = [ '#626262', '241' ]
-
-let s:violet = [ '#cf73e6', '170' ]
-
-let s:blue = [ '#5f87af', '67' ]
-let s:blue2 = [ '#91aadf', '110' ]
-
-let s:green = [ '#57ba37', '71' ]
-let s:gold = [ '#f0d50c', '220' ]
-let s:red = [ '#d70000', '160' ]
-let s:none = [ 'NONE', 'NONE' ]
-
-
-let s:p = {'normal': {}, 'inactive': {}, 'insert': {}, 'replace': {}, 'visual': {}, 'tabline': {}}
-let s:p.normal.left = [ [ s:black, s:blue ], [ s:gray4, s:black2 ] ]
-let s:p.normal.right = [ [ s:gray, s:gray4 ], [ s:gray3, s:gray ], [ s:gray2, s:black2 ] ]
-let s:p.inactive.right = [ [ s:black, s:black2 ], [ s:gray, s:black ] ]
-let s:p.inactive.left =  [ [ s:gray, s:black ], [ s:black2, s:black ] ]
-let s:p.insert.left = [ [ s:black, s:green ], [ s:gray4, s:black2 ] ]
-let s:p.replace.left = [ [ s:black, s:red ], [ s:gray4, s:black2 ] ]
-let s:p.visual.left = [ [ s:black, s:violet ], [ s:gray4, s:black2 ] ]
-let s:p.normal.middle = [ [ s:gray, s:black ] ]
-let s:p.inactive.middle = [ [ s:black2, s:black ] ]
-let s:p.tabline.left = [ [ s:gray4, s:black ] ]
-let s:p.tabline.tabsel = [ [ s:blue, s:black ] ]
-let s:p.tabline.middle = [ [ s:black2, s:black ] ]
-let s:p.tabline.right = copy(s:p.normal.right)
-let s:p.normal.error = [ [ s:red, s:black ] ]
-let s:p.normal.warning = [ [ s:gold, s:black2 ] ]
-
-let g:lightline#colorscheme#simpleblack#palette = lightline#colorscheme#flatten(s:p)
diff --git a/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/solarized.vim b/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/solarized.vim
deleted file mode 100644
index 5378831..0000000
--- a/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/solarized.vim
+++ /dev/null
@@ -1,80 +0,0 @@
-" =============================================================================
-" Filename: autoload/lightline/colorscheme/solarized.vim
-" Author: itchyny
-" License: MIT License
-" Last Change: 2020/04/06 19:22:53.
-" =============================================================================
-
-let s:cuicolors = {
-      \ 'base03': [ '8', '234', 'DarkGray' ],
-      \ 'base02': [ '0', '235', 'Black' ],
-      \ 'base01': [ '10', '239', 'LightGreen' ],
-      \ 'base00': [ '11', '240', 'LightYellow' ],
-      \ 'base0':  [ '12', '244', 'LightBlue' ],
-      \ 'base1':  [ '14', '245', 'LightCyan' ],
-      \ 'base2': [ '7', '187', 'LightGray' ],
-      \ 'base3': [ '15', '230', 'White' ],
-      \ 'yellow': [ '3', '136', 'DarkYellow' ],
-      \ 'orange': [ '9', '166', 'LightRed' ],
-      \ 'red': [ '1', '124', 'DarkRed' ],
-      \ 'magenta': [ '5', '125', 'DarkMagenta' ],
-      \ 'violet': [ '13', '61', 'LightMagenta' ],
-      \ 'blue': [ '4', '33', 'DarkBlue' ],
-      \ 'cyan': [ '6', '37', 'DarkCyan' ],
-      \ 'green': [ '2', '64', 'DarkGreen' ],
-      \ }
-
-" The following condition only applies for the console and is the same
-" condition vim-colors-solarized uses to determine which set of colors
-" to use.
-let s:solarized_termcolors = get(g:, 'solarized_termcolors', 256)
-if s:solarized_termcolors != 256 && &t_Co >= 16
-  let s:cuiindex = 0
-elseif s:solarized_termcolors == 256
-  let s:cuiindex = 1
-else
-  let s:cuiindex = 2
-endif
-
-let s:base03 = [ '#002b36', s:cuicolors.base03[s:cuiindex] ]
-let s:base02 = [ '#073642', s:cuicolors.base02[s:cuiindex] ]
-let s:base01 = [ '#586e75', s:cuicolors.base01[s:cuiindex] ]
-let s:base00 = [ '#657b83', s:cuicolors.base00[s:cuiindex] ]
-let s:base0 = [ '#839496', s:cuicolors.base0[s:cuiindex] ]
-let s:base1 = [ '#93a1a1', s:cuicolors.base1[s:cuiindex] ]
-let s:base2 = [ '#eee8d5', s:cuicolors.base2[s:cuiindex] ]
-let s:base3 = [ '#fdf6e3', s:cuicolors.base3[s:cuiindex] ]
-let s:yellow = [ '#b58900', s:cuicolors.yellow[s:cuiindex] ]
-let s:orange = [ '#cb4b16', s:cuicolors.orange[s:cuiindex] ]
-let s:red = [ '#dc322f', s:cuicolors.red[s:cuiindex] ]
-let s:magenta = [ '#d33682', s:cuicolors.magenta[s:cuiindex] ]
-let s:violet = [ '#6c71c4', s:cuicolors.violet[s:cuiindex] ]
-let s:blue = [ '#268bd2', s:cuicolors.blue[s:cuiindex] ]
-let s:cyan = [ '#2aa198', s:cuicolors.cyan[s:cuiindex] ]
-let s:green = [ '#859900', s:cuicolors.green[s:cuiindex] ]
-
-if lightline#colorscheme#background() ==# 'light'
-  let [ s:base03, s:base3 ] = [ s:base3, s:base03 ]
-  let [ s:base02, s:base2 ] = [ s:base2, s:base02 ]
-  let [ s:base01, s:base1 ] = [ s:base1, s:base01 ]
-  let [ s:base00, s:base0 ] = [ s:base0, s:base00 ]
-endif
-
-let s:p = {'normal': {}, 'inactive': {}, 'insert': {}, 'replace': {}, 'visual': {}, 'tabline': {}}
-let s:p.normal.left = [ [ s:base03, s:blue ], [ s:base03, s:base00 ] ]
-let s:p.normal.right = [ [ s:base03, s:base1 ], [ s:base03, s:base00 ] ]
-let s:p.inactive.right = [ [ s:base03, s:base00 ], [ s:base0, s:base02 ] ]
-let s:p.inactive.left =  [ [ s:base0, s:base02 ], [ s:base0, s:base02 ] ]
-let s:p.insert.left = [ [ s:base03, s:green ], [ s:base03, s:base00 ] ]
-let s:p.replace.left = [ [ s:base03, s:red ], [ s:base03, s:base00 ] ]
-let s:p.visual.left = [ [ s:base03, s:magenta ], [ s:base03, s:base00 ] ]
-let s:p.normal.middle = [ [ s:base1, s:base02 ] ]
-let s:p.inactive.middle = [ [ s:base01, s:base02 ] ]
-let s:p.tabline.left = [ [ s:base03, s:base00 ] ]
-let s:p.tabline.tabsel = [ [ s:base03, s:base1 ] ]
-let s:p.tabline.middle = [ [ s:base0, s:base02 ] ]
-let s:p.tabline.right = copy(s:p.tabline.left)
-let s:p.normal.error = [ [ s:base03, s:red ] ]
-let s:p.normal.warning = [ [ s:base03, s:yellow ] ]
-
-let g:lightline#colorscheme#solarized#palette = lightline#colorscheme#flatten(s:p)
diff --git a/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/srcery_drk.vim b/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/srcery_drk.vim
deleted file mode 100644
index 5aa3a8a..0000000
--- a/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/srcery_drk.vim
+++ /dev/null
@@ -1,44 +0,0 @@
-" =============================================================================
-" Filename: autoload/lightline/colorscheme/srcery_drk.vim
-" Author: Christopher Vittal
-" License: MIT License
-" Last Change: 2018/05/19
-" =============================================================================
-let s:base03 = [ '#151513', 233 ]
-let s:base02 = [ '#30302c', 236 ]
-let s:base01 = [ '#4e4e43', 239 ]
-let s:base00 = [ '#666656', 242  ]
-let s:base0 = [ '#808070', 244 ]
-let s:base1 = [ '#949484', 246 ]
-let s:base2 = [ '#a8a897', 248 ]
-let s:base3 = [ '#e8e8d3', 253 ]
-let s:yellow = [ '#fbb829', 3 ]
-let s:orange = [ '#d75f00', 166 ]
-let s:red = [ '#ff3128', 1 ]
-let s:magenta = [ '#e02c6d', 5 ]
-let s:bright_magenta = [ '#e35682', 13 ]
-let s:blue = [ '#5573a3', 4 ]
-let s:bright_blue = [ '#8eb2f7', 12 ]
-let s:cyan = [ '#0aaeb3', 6 ]
-let s:green = [ '#519f50', 2 ]
-let s:bright_green = [ '#98bc37', 10 ]
-let s:white = [ '#fce8c3', 15 ]
-
-let s:p = {'normal': {}, 'inactive': {}, 'insert': {}, 'replace': {}, 'visual': {}, 'tabline': {}}
-let s:p.normal.left = [ [ s:base02, s:bright_blue, 'bold' ], [ s:base3, s:base01 ] ]
-let s:p.normal.right = [ [ s:base02, s:base1 ], [ s:base2, s:base01 ] ]
-let s:p.inactive.right = [ [ s:base02, s:base00 ], [ s:base0, s:base02 ] ]
-let s:p.inactive.left =  [ [ s:base0, s:base02 ], [ s:base00, s:base02 ] ]
-let s:p.insert.left = [ [ s:base02, s:bright_green, 'bold' ], [ s:base3, s:base01 ] ]
-let s:p.replace.left = [ [ s:base3, s:red, 'bold' ], [ s:base3, s:base01 ] ]
-let s:p.visual.left = [ [ s:base3, s:bright_magenta, 'bold' ], [ s:base3, s:base01 ] ]
-let s:p.normal.middle = [ [ s:base0, s:base02 ] ]
-let s:p.inactive.middle = [ [ s:base00, s:base02 ] ]
-let s:p.tabline.left = [ [ s:base3, s:base00, 'bold'] ]
-let s:p.tabline.tabsel = [ [ s:base3, s:base02 ] ]
-let s:p.tabline.middle = [ [ s:base01, s:base1 ] ]
-let s:p.tabline.right = copy(s:p.normal.right)
-let s:p.normal.error = [ [ s:red, s:base02 ] ]
-let s:p.normal.warning = [ [ s:yellow, s:base01 ] ]
-
-let g:lightline#colorscheme#srcery_drk#palette = lightline#colorscheme#flatten(s:p)
diff --git a/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/wombat.vim b/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/wombat.vim
deleted file mode 100644
index 9fee12e..0000000
--- a/sources_non_forked/lightline.vim/autoload/lightline/colorscheme/wombat.vim
+++ /dev/null
@@ -1,40 +0,0 @@
-" =============================================================================
-" Filename: autoload/lightline/colorscheme/wombat.vim
-" Author: itchyny
-" License: MIT License
-" Last Change: 2015/11/30 08:37:43.
-" =============================================================================
-let s:base03 = [ '#242424', 235 ]
-let s:base023 = [ '#353535', 236 ]
-let s:base02 = [ '#444444', 238 ]
-let s:base01 = [ '#585858', 240 ]
-let s:base00 = [ '#666666', 242  ]
-let s:base0 = [ '#808080', 244 ]
-let s:base1 = [ '#969696', 247 ]
-let s:base2 = [ '#a8a8a8', 248 ]
-let s:base3 = [ '#d0d0d0', 252 ]
-let s:yellow = [ '#cae682', 180 ]
-let s:orange = [ '#e5786d', 173 ]
-let s:red = [ '#e5786d', 203 ]
-let s:magenta = [ '#f2c68a', 216 ]
-let s:blue = [ '#8ac6f2', 117 ]
-let s:cyan = s:blue
-let s:green = [ '#95e454', 119 ]
-let s:p = {'normal': {}, 'inactive': {}, 'insert': {}, 'replace': {}, 'visual': {}, 'tabline': {}}
-let s:p.normal.left = [ [ s:base02, s:blue ], [ s:base3, s:base01 ] ]
-let s:p.normal.right = [ [ s:base02, s:base0 ], [ s:base1, s:base01 ] ]
-let s:p.inactive.right = [ [ s:base023, s:base01 ], [ s:base00, s:base02 ] ]
-let s:p.inactive.left =  [ [ s:base1, s:base02 ], [ s:base00, s:base023 ] ]
-let s:p.insert.left = [ [ s:base02, s:green ], [ s:base3, s:base01 ] ]
-let s:p.replace.left = [ [ s:base023, s:red ], [ s:base3, s:base01 ] ]
-let s:p.visual.left = [ [ s:base02, s:magenta ], [ s:base3, s:base01 ] ]
-let s:p.normal.middle = [ [ s:base2, s:base02 ] ]
-let s:p.inactive.middle = [ [ s:base1, s:base023 ] ]
-let s:p.tabline.left = [ [ s:base3, s:base00 ] ]
-let s:p.tabline.tabsel = [ [ s:base3, s:base03 ] ]
-let s:p.tabline.middle = [ [ s:base2, s:base02 ] ]
-let s:p.tabline.right = [ [ s:base2, s:base00 ] ]
-let s:p.normal.error = [ [ s:base03, s:red ] ]
-let s:p.normal.warning = [ [ s:base023, s:yellow ] ]
-
-let g:lightline#colorscheme#wombat#palette = lightline#colorscheme#flatten(s:p)
diff --git a/sources_non_forked/lightline.vim/autoload/lightline/colortable.vim b/sources_non_forked/lightline.vim/autoload/lightline/colortable.vim
deleted file mode 100644
index 6cdddd8..0000000
--- a/sources_non_forked/lightline.vim/autoload/lightline/colortable.vim
+++ /dev/null
@@ -1,52 +0,0 @@
-" =============================================================================
-" Filename: autoload/lightline/colortable.vim
-" Author: itchyny
-" License: MIT License
-" Last Change: 2020/06/19 11:07:13.
-" =============================================================================
-
-let s:save_cpo = &cpo
-set cpo&vim
-
-function! s:load() abort
-  let rgbfile = $VIMRUNTIME . '/rgb.txt'
-  let table = {}
-  if filereadable(rgbfile)
-    for _ in map(filter(readfile(rgbfile), 'v:val !~# "^!"'), 'matchlist(v:val, "^\\s*\\(\\d\\+\\)\\s\\+\\(\\d\\+\\)\\s\\+\\(\\d\\+\\)\\s\\+\\(.*\\)")[1:4]')
-      let table[tolower(_[3])] = _[0:2]
-    endfor
-  endif
-  return table
-endfunction
-
-let s:table = s:load()
-
-function! lightline#colortable#name_to_rgb(name) abort
-  let name = tolower(a:name)
-  return has_key(s:table, name) ? s:table[name] : []
-endfunction
-
-function! lightline#colortable#gui2cui(rgb, fallback) abort
-  let rgb = map(matchlist(a:rgb, '#\(..\)\(..\)\(..\)')[1:3], '0 + ("0x".v:val)')
-  if len(rgb) == 0
-    let rgb = lightline#colortable#name_to_rgb(a:rgb)
-    if len(rgb) == 0
-      return a:fallback % 128
-    endif
-  endif
-  let rgb = [rgb[0] > 127 ? 4 : 0, rgb[1] > 127 ? 2 : 0, rgb[2] > 127 ? 1 : 0]
-  return rgb[0] + rgb[1] + rgb[2]
-endfunction
-
-function! lightline#colortable#gui2cui_palette(palette) abort
-  for u in values(a:palette)
-    for v in values(u)
-      for w in v
-        let [w[2], w[3]] = [lightline#colortable#gui2cui(w[0], w[2]), lightline#colortable#gui2cui(w[1], w[3])]
-      endfor
-    endfor
-  endfor
-endfunction
-
-let &cpo = s:save_cpo
-unlet s:save_cpo
diff --git a/sources_non_forked/lightline.vim/autoload/lightline/tab.vim b/sources_non_forked/lightline.vim/autoload/lightline/tab.vim
deleted file mode 100644
index f2accc1..0000000
--- a/sources_non_forked/lightline.vim/autoload/lightline/tab.vim
+++ /dev/null
@@ -1,33 +0,0 @@
-" =============================================================================
-" Filename: autoload/lightline/tab.vim
-" Author: itchyny
-" License: MIT License
-" Last Change: 2016/05/07 22:31:02.
-" =============================================================================
-
-let s:save_cpo = &cpo
-set cpo&vim
-
-function! lightline#tab#filename(n) abort
-  let buflist = tabpagebuflist(a:n)
-  let winnr = tabpagewinnr(a:n)
-  let _ = expand('#'.buflist[winnr - 1].':t')
-  return _ !=# '' ? _ : '[No Name]'
-endfunction
-
-function! lightline#tab#modified(n) abort
-  let winnr = tabpagewinnr(a:n)
-  return gettabwinvar(a:n, winnr, '&modified') ? '+' : gettabwinvar(a:n, winnr, '&modifiable') ? '' : '-'
-endfunction
-
-function! lightline#tab#readonly(n) abort
-  let winnr = tabpagewinnr(a:n)
-  return gettabwinvar(a:n, winnr, '&readonly') ? 'RO' : ''
-endfunction
-
-function! lightline#tab#tabnum(n) abort
-  return a:n
-endfunction
-
-let &cpo = s:save_cpo
-unlet s:save_cpo
diff --git a/sources_non_forked/lightline.vim/colorscheme.md b/sources_non_forked/lightline.vim/colorscheme.md
deleted file mode 100644
index 6d43183..0000000
--- a/sources_non_forked/lightline.vim/colorscheme.md
+++ /dev/null
@@ -1,137 +0,0 @@
-# Available Colorschemes
-
-### powerline (default)
-
-![lightline.vim - powerline](https://raw.githubusercontent.com/wiki/itchyny/lightline.vim/image/powerline.png)
-
-### powerlineish
-
-![lightline.vim - powerlineish](https://raw.githubusercontent.com/wiki/itchyny/lightline.vim/image/powerlineish.png)
-
-### wombat
-
-![lightline.vim - wombat](https://raw.githubusercontent.com/wiki/itchyny/lightline.vim/image/wombat.png)
-
-### OldHope
-
-![lightline.vim - OldHope](https://raw.githubusercontent.com/wiki/itchyny/lightline.vim/image/OldHope.png)
-
-### PaperColor dark
-
-![lightline.vim - PaperColor dark](https://raw.githubusercontent.com/wiki/itchyny/lightline.vim/image/PaperColor_dark.png)
-
-### PaperColor light
-
-![lightline.vim - PaperColor light](https://raw.githubusercontent.com/wiki/itchyny/lightline.vim/image/PaperColor_light.png)
-
-### Tomorrow
-
-![lightline.vim - Tomorrow](https://raw.githubusercontent.com/wiki/itchyny/lightline.vim/image/Tomorrow.png)
-
-### Tomorrow Night
-
-![lightline.vim - Tomorrow Night](https://raw.githubusercontent.com/wiki/itchyny/lightline.vim/image/Tomorrow_Night.png)
-
-### Tomorrow Night Blue
-
-![lightline.vim - Tomorrow Night Blue](https://raw.githubusercontent.com/wiki/itchyny/lightline.vim/image/Tomorrow_Night_Blue.png)
-
-### Tomorrow Night Bright
-
-![lightline.vim - Tomorrow Night Bright](https://raw.githubusercontent.com/wiki/itchyny/lightline.vim/image/Tomorrow_Night_Bright.png)
-
-### Tomorrow Night Eighties
-
-![lightline.vim - Tomorrow Night Eighties](https://raw.githubusercontent.com/wiki/itchyny/lightline.vim/image/Tomorrow_Night_Eighties.png)
-
-### ayu_mirage
-
-![lightline.vim - ayu mirage](https://raw.githubusercontent.com/wiki/itchyny/lightline.vim/image/ayu_mirage.png)
-
-### ayu_light
-
-![lightline.vim - ayu light](https://raw.githubusercontent.com/wiki/itchyny/lightline.vim/image/ayu_light.png)
-
-### ayu_dark
-
-![lightline.vim - ayu dark](https://raw.githubusercontent.com/wiki/itchyny/lightline.vim/image/ayu_dark.png)
-
-### darcula
-
-![lightline.vim - darcula](https://raw.githubusercontent.com/wiki/itchyny/lightline.vim/image/darcula.png)
-
-### deus
-
-![lightline.vim - deus](https://raw.githubusercontent.com/wiki/itchyny/lightline.vim/image/deus.png)
-
-### jellybeans
-
-![lightline.vim - jellybeans](https://raw.githubusercontent.com/wiki/itchyny/lightline.vim/image/jellybeans.png)
-
-### selenized dark
-
-![lightline.vim - selenized dark](https://raw.githubusercontent.com/wiki/itchyny/lightline.vim/image/selenized_dark.png)
-
-### selenized black
-
-![lightline.vim - selenized black](https://raw.githubusercontent.com/wiki/itchyny/lightline.vim/image/selenized_black.png)
-
-### selenized light
-
-![lightline.vim - selenized light](https://raw.githubusercontent.com/wiki/itchyny/lightline.vim/image/selenized_light.png)
-
-### selenized white
-
-![lightline.vim - selenized white](https://raw.githubusercontent.com/wiki/itchyny/lightline.vim/image/selenized_white.png)
-
-### solarized dark
-
-![lightline.vim - solarized dark](https://raw.githubusercontent.com/wiki/itchyny/lightline.vim/image/solarized_dark.png)
-
-### solarized light
-
-![lightline.vim - solarized light](https://raw.githubusercontent.com/wiki/itchyny/lightline.vim/image/solarized_light.png)
-
-### materia
-
-![lightline.vim - materia](https://raw.githubusercontent.com/wiki/itchyny/lightline.vim/image/materia.png)
-
-### material
-
-![lightline.vim - material](https://raw.githubusercontent.com/wiki/itchyny/lightline.vim/image/material.png)
-
-### molokai
-
-![lightline.vim - molokai](https://raw.githubusercontent.com/wiki/itchyny/lightline.vim/image/molokai.png)
-
-### nord
-
-![lightline.vim - nord](https://raw.githubusercontent.com/wiki/itchyny/lightline.vim/image/nord.png)
-
-### seoul256
-
-![lightline.vim - seoul256](https://raw.githubusercontent.com/wiki/itchyny/lightline.vim/image/seoul256.png)
-
-### one dark
-
-![lightline.vim - one dark](https://raw.githubusercontent.com/wiki/itchyny/lightline.vim/image/one_dark.png)
-
-### one light
-
-![lightline.vim - one light](https://raw.githubusercontent.com/wiki/itchyny/lightline.vim/image/one_light.png)
-
-### srcery_drk
-
-![lightline.vim - srcery_drk](https://raw.githubusercontent.com/wiki/itchyny/lightline.vim/image/srcery_drk.png)
-
-### simpleblack
-
-![lightline.vim - simpleblack](https://raw.githubusercontent.com/wiki/itchyny/lightline.vim/image/simpleblack.png)
-
-### landscape
-
-![lightline.vim - landscape](https://raw.githubusercontent.com/wiki/itchyny/lightline.vim/image/landscape.png)
-
-### 16color
-
-![lightline.vim - 16color](https://raw.githubusercontent.com/wiki/itchyny/lightline.vim/image/16color.png)
diff --git a/sources_non_forked/lightline.vim/doc/lightline.txt b/sources_non_forked/lightline.vim/doc/lightline.txt
deleted file mode 100644
index 1b308e9..0000000
--- a/sources_non_forked/lightline.vim/doc/lightline.txt
+++ /dev/null
@@ -1,1330 +0,0 @@
-*lightline.txt*	A light and configurable statusline/tabline for Vim
-
-Version: 0.1
-Author: itchyny (https://github.com/itchyny)
-License: MIT License
-Repository: https://github.com/itchyny/lightline.vim
-Last Change: 2020/05/02 17:05:15.
-
-CONTENTS					*lightline-contents*
-
-Introduction				|lightline-introduction|
-Spirit					|lightline-spirit|
-Option					|lightline-option|
-Font					|lightline-font|
-Function				|lightline-function|
-Component Expansion			|lightline-component-expansion|
-Colorscheme				|lightline-colorscheme|
-Examples				|lightline-examples|
-Nice Examples				|lightline-nice-examples|
-Powerful Example			|lightline-powerful-example|
-Troubleshooting				|lightline-troubleshooting|
-
-==============================================================================
-INTRODUCTION					*lightline-introduction*
-
-The *lightline* plugin is a light and configurable statusline/tabline for Vim.
-
-------------------------------------------------------------------------------
-SPIRIT						*lightline-spirit*
-
-	Minimalism
-	    The core script is very small to achieve enough functions as a
-	    statusline plugin.
-
-	Configurability
-	    You can create your own component and easily add to the statusline
-	    and the tabline.
-
-	Orthogonality
-	    The plugin does not rely on the implementation of other plugins.
-	    Such plugin crossing settings should be configured by users.
-
-	You find this plugin does not integrate with other plugins by default.
-	This plugin does not provide branch information, which is a basic
-	component in existing statusline plugins. It is a design of
-	lightline.vim that such plugin crossing configuration should be
-	written by users. Once a plugin starts to integrate with some famous
-	plugins, it should be kept updated to follow the changes of the
-	plugins and should accept integration requests with new plugins.
-	Instead, lightline.vim is designed very carefully so that users can
-	easily integrate with other plugins. Good APIs keep a plugin clean.
-
-------------------------------------------------------------------------------
-OPTIONS						*lightline-option*
-
-	g:lightline				*g:lightline*
-		All the configurations are stored in this global variable.
-
-	g:lightline.active			*g:lightline.active*
-	g:lightline.inactive			*g:lightline.inactive*
-	g:lightline.tabline			*g:lightline.tabline*
-		Dictionaries to store the statusline/tabline components.
-		Note that right groups of components are stored from right to
-		left.
-		The default values are:
->
-		let g:lightline.active = {
-		    \ 'left': [ [ 'mode', 'paste' ],
-		    \           [ 'readonly', 'filename', 'modified' ] ],
-		    \ 'right': [ [ 'lineinfo' ],
-		    \            [ 'percent' ],
-		    \            [ 'fileformat', 'fileencoding', 'filetype' ] ] }
-		let g:lightline.inactive = {
-		    \ 'left': [ [ 'filename' ] ],
-		    \ 'right': [ [ 'lineinfo' ],
-		    \            [ 'percent' ] ] }
-		let g:lightline.tabline = {
-		    \ 'left': [ [ 'tabs' ] ],
-		    \ 'right': [ [ 'close' ] ] }
-<
-	g:lightline.tab				*g:lightline.tab*
-		A dictionary to store the tab components in each tabs.
-		The default values are:
->
-		let g:lightline.tab = {
-		    \ 'active': [ 'tabnum', 'filename', 'modified' ],
-		    \ 'inactive': [ 'tabnum', 'filename', 'modified' ] }
-<
-	g:lightline.component			*g:lightline.component*
-		A dictionary for statusline/tabline components.
-		The default value is:
->
-		let g:lightline.component = {
-		    \ 'mode': '%{lightline#mode()}',
-		    \ 'absolutepath': '%F',
-		    \ 'relativepath': '%f',
-		    \ 'filename': '%t',
-		    \ 'modified': '%M',
-		    \ 'bufnum': '%n',
-		    \ 'paste': '%{&paste?"PASTE":""}',
-		    \ 'readonly': '%R',
-		    \ 'charvalue': '%b',
-		    \ 'charvaluehex': '%B',
-		    \ 'fileencoding': '%{&fenc!=#""?&fenc:&enc}',
-		    \ 'fileformat': '%{&ff}',
-		    \ 'filetype': '%{&ft!=#""?&ft:"no ft"}',
-		    \ 'percent': '%3p%%',
-		    \ 'percentwin': '%P',
-		    \ 'spell': '%{&spell?&spelllang:""}',
-		    \ 'lineinfo': '%3l:%-2v',
-		    \ 'line': '%l',
-		    \ 'column': '%c',
-		    \ 'close': '%999X X ',
-		    \ 'winnr': '%{winnr()}' }
-<
-	g:lightline.component_visible_condition
-						*g:lightline.component_visible_condition*
-		A dictionary to store the visible condition of the components.
-		Note that this configuration is used to control the visibility
-		of the subseparators, not to control the visibility of the
-		components themselves. Each expression should correspond to
-		the condition on which each component is not empty.
-		The default value is:
->
-		let g:lightline.component_visible_condition = {
-		    \ 'modified': '&modified||!&modifiable',
-		    \ 'readonly': '&readonly',
-		    \ 'paste': '&paste',
-		    \ 'spell': '&spell' }
-<
-	g:lightline.component_function		*g:lightline.component_function*
-		A dictionary to store the function components.
-		This is useful to write a complex component configuration and
-		to integrate with other plugins. If a component set in both
-		component and component_function, the configuration of
-		component_function has priority.
-
-		The default value is:
->
-		let g:lightline.component_function = {}
-<
-		For example, if you want to display the name of the git branch,
-		install |vim-fugitive| plugin and then configure as:
->
-		let g:lightline = {
-			\ 'active': {
-			\   'left': [ [ 'mode', 'paste' ],
-			\             [ 'gitbranch', 'readonly', 'filename', 'modified' ] ]
-			\ },
-			\ 'component_function': {
-			\   'gitbranch': 'FugitiveHead'
-			\ },
-			\ }
-<
-	g:lightline.component_function_visible_condition
-						*g:lightline.component_function_visible_condition*
-		A dictionary to store the visible conditions of the function
-		components. Each expression should correspond to the condition
-		each component is not empty. This configuration is used to
-		control the visibility of the sub-separators. You can use this
-		configuration to reduce the number of function calls for
-		performance improvement by setting the value 1 (to tell lightline
-		that the component is always visible).
-		The default value is:
->
-		let g:lightline.component_function_visible_condition = {}
-<
-	g:lightline.component_expand		*g:lightline.component_expand*
-		A dictionary to store expanding components. You can create
-		warning and critical components. The values should be the name
-		of functions should return either one of:
-			+ a string
-			+ an array of three elements:
-				[[ left ], [ middle ], [ right ]]
-		The component in this dictionary has priority over
-		|g:lightline.component| and |g:lightline.component_function|.
-		Note that the return string is appended to the statusline
-		string without any conversion. So you should replace all the
-		% signs with %%. Otherwise, lightline will be disabled in case
-		the text has a % sign.
-		(example: return substitute(text, '%', '%%', 'g')).
-		See |lightline-component-expansion| for more detail.
->
-		let g:lightline.component_expand = {
-		    \ 'tabs': 'lightline#tabs' }
-<
-	g:lightline.component_type		*g:lightline.component_type*
-		A dictionary to specify the types for components in
-		|g:lightline.component_expand|. The types are used to specify
-		the color. Specifically, the type raw is used to specify a
-		component which should not be wrapped by item group: %(...%).
-		If you want to specify the type of a raw component, please use
-		|g:lightline.component_raw|.
-		The default value is: >
-
-		let g:lightline.component_type = {
-		    \ 'tabs': 'tabsel',
-		    \ 'close': 'raw' }
-<
-	g:lightline.component_raw		*g:lightline.component_raw*
-		A dictionary to specify the raw type components. When you
-		register a component to this dictionary (like >
-		let g:lightline.component_raw = { 'example': 1 }
-<		), the example component is not wrapped by item group: %(...%).
-		The default value is: >
-
-		let g:lightline.component_raw = {}
-<
-	g:lightline.tab_component		*g:lightline.tab_component*
-		A dictionary for components in one tab.
-		The default value is: >
-
-		let g:lightline.tab_component = {}
-<
-	g:lightline.tab_component_function	*g:lightline.tab_component_function*
-		Another dictionary for components in one tab.
-		A function specified as a tab component takes one argument:
-		the tab [count].
-		The default value is:
->
-		let g:lightline.tab_component_function = {
-		      \ 'filename': 'lightline#tab#filename',
-		      \ 'modified': 'lightline#tab#modified',
-		      \ 'readonly': 'lightline#tab#readonly',
-		      \ 'tabnum': 'lightline#tab#tabnum' }
-<
-	g:lightline.colorscheme			*g:lightline.colorscheme*
-		The colorscheme for lightline.vim.
-		Currently, wombat, solarized, powerline, powerlineish,
-		jellybeans, molokai, seoul256, darcula,
-		selenized_dark, selenized_black, selenized_light, selenized_white,
-		Tomorrow, Tomorrow_Night, Tomorrow_Night_Blue,
-		Tomorrow_Night_Bright, Tomorrow_Night_Eighties, PaperColor,
-		landscape, one, materia, material, OldHope, nord, deus,
-		simpleblack, srcery_drk, ayu_mirage, ayu_light, ayu_dark and
-		16color are available.
-		The default value is:
->
-		let g:lightline.colorscheme = 'default'
-<
-		Note that the default colorscheme is exactly the same as the
-		powerline theme.
-
-	g:lightline.mode_map			*g:lightline.mode_map*
-		A dictionary of names for the modes. The keys are the return
-		values of |mode()|.
-		The default value is:
->
-		let g:lightline.mode_map = {
-		    \ 'n' : 'NORMAL',
-		    \ 'i' : 'INSERT',
-		    \ 'R' : 'REPLACE',
-		    \ 'v' : 'VISUAL',
-		    \ 'V' : 'V-LINE',
-		    \ "\<C-v>": 'V-BLOCK',
-		    \ 'c' : 'COMMAND',
-		    \ 's' : 'SELECT',
-		    \ 'S' : 'S-LINE',
-		    \ "\<C-s>": 'S-BLOCK',
-		    \ 't': 'TERMINAL',
-		    \ }
-<
-		When you search a word, you get into the command mode. But if
-		you want to keep the mode indicator as 'NORMAL', add >
-		let g:lightline = { 'mode_map': { 'c': 'NORMAL' } }
-<		to your .vimrc.
-
-	g:lightline.separator			*g:lightline.separator*
-	g:lightline.subseparator		*g:lightline.subseparator*
-		Dictionaries to store separators.
-		The default value is
->
-		let g:lightline.separator = { 'left': '', 'right': '' }
-		let g:lightline.subseparator = { 'left': '|', 'right': '|' }
-<
-	g:lightline.tabline_separator			*g:lightline.tabline_separator*
-	g:lightline.tabline_subseparator		*g:lightline.tabline_subseparator*
-		Dictionaries to store separators for the tabline.
-		The default value is
->
-		let g:lightline.tabline_separator = g:lightline.separator
-		let g:lightline.tabline_subseparator = g:lightline.subseparator
-<
-	g:lightline.enable			*g:lightline.enable*
-		A dictionary to specify which feature is turned on.
-		The default value is
->
-		let g:lightline.enable = {
-		    \ 'statusline': 1,
-		    \ 'tabline': 1
-		    \ }
-<
-==============================================================================
-FONT						*lightline-font*
-You can use the patched font you used for |vim-powerline| and |powerline|.
-
-The patched fonts for |powerline| are available at
-https://github.com/Lokaltog/powerline-fonts
-
-A tutorial to create a patched font for |vim-powerline| is available at
-https://github.com/Lokaltog/vim-powerline/tree/develop/fontpatcher
-
-If you have installed the patched font for |powerline|, following settings look
-nice.
->
-	let g:lightline = {
-		\ 'component': {
-		\   'lineinfo': ' %3l:%-2v',
-		\ },
-		\ 'component_function': {
-		\   'readonly': 'LightlineReadonly',
-		\   'fugitive': 'LightlineFugitive'
-		\ },
-		\ 'separator': { 'left': '', 'right': '' },
-		\ 'subseparator': { 'left': '', 'right': '' }
-		\ }
-	function! LightlineReadonly()
-		return &readonly ? '' : ''
-	endfunction
-	function! LightlineFugitive()
-		if exists('*FugitiveHead')
-			let branch = FugitiveHead()
-			return branch !=# '' ? ''.branch : ''
-		endif
-		return ''
-	endfunction
-<
-If you have installed the patched font for |vim-powerline|, following settings
-look nice.
->
-	let g:lightline = {
-		\ 'component': {
-		\   'lineinfo': ' %3l:%-2v',
-		\ },
-		\ 'component_function': {
-		\   'readonly': 'LightlineReadonly',
-		\   'fugitive': 'LightlineFugitive'
-		\ },
-		\ 'separator': { 'left': '', 'right': '' },
-		\ 'subseparator': { 'left': '', 'right': '' }
-		\ }
-	function! LightlineReadonly()
-		return &readonly ? '' : ''
-	endfunction
-	function! LightlineFugitive()
-		if exists('*FugitiveHead')
-			let branch = FugitiveHead()
-			return branch !=# '' ? ' '.branch : ''
-		endif
-		return ''
-	endfunction
-<
-If the statusline does not correctly show the special characters, use the
-unicode numbers. For |powerline| font users:
->
-		\ 'separator': { 'left': "\ue0b0", 'right': "\ue0b2" },
-		\ 'subseparator': { 'left': "\ue0b1", 'right': "\ue0b3" }
-<
-For |vim-powerline| font users:
->
-		\ 'separator': { 'left': "\u2b80", 'right': "\u2b82" },
-		\ 'subseparator': { 'left': "\u2b81", 'right': "\u2b83" }
-<
-See |lightline-problem-9| for more detail.
-==============================================================================
-FUNCTION					*lightline-function*
-Exposed functions for lightline.vim.
-
-	lightline#mode()			*lightline#mode()*
-		Returns the mode of the Vim using |g:lightline.mode_map|.
-
-	lightline#init()			*lightline#init()*
-		Initializes the internal state from |g:lightline|.
-
-	lightline#colorscheme()			*lightline#colorscheme()*
-		Initializes the colorscheme and the highlight groups.
-
-	lightline#update()			*lightline#update()*
-		Updates all the statuslines of existing windows.
-
-	lightline#update_once()			*lightline#update_once()*
-		Updates the statuslines only once.
-
-	lightline#enable()			*lightline#enable()*
-		Enables |lightline|.
-
-	lightline#disable()			*lightline#disable()*
-		Disables |lightline|.
-
-	lightline#toggle()			*lightline#toggle()*
-		Toggles |lightline|.
-
-	lightline#link([mode])			*lightline#link()*
-		Creates links of the highlight groups for the active window.
-		This function accepts an optional argument. It should be one
-		of the return value of |mode()|.
-
-	lightline#highlight()			*lightline#highlight()*
-		Set the highlight groups.
-
-	lightline#statusline({inactive})	*lightline#statusline()*
-		Returns |statusline| strings. If the argument is 0, it returns
-		the statusline for active window, and the statusline for
-		inactive window otherwise.
-
-	lightline#tabline()			*lightline#tabline()*
-		Returns the tabline string.
-
-	lightline#concatenate({list}, {num})	*lightline#concatenate()*
-		A string concatenation function. Concatenating all the strings
-		in {list} using the sub-separator of lightline. If {num} is 0,
-		then the left sub-separator is used. Otherwise, the right
-		sub-separator is used.
-
-	lightline#palette()			*lightline#palette()*
-		Returns the palette data.
-
-==============================================================================
-COMPONENT EXPANSION				*lightline-component-expansion*
-You can create components, which have specific colors. This section gives an
-example using |syntastic|.
-
-If you want to add the |syntastic| flag to the statusline, an easy example is:
->
-	" Example A
-	let g:lightline = {
-	      \ 'active': {
-	      \   'right': [ [ 'lineinfo', 'syntastic' ],
-	      \              [ 'percent' ],
-	      \              [ 'fileformat', 'fileencoding', 'filetype' ] ]
-	      \ },
-	      \ 'component_function': {
-	      \   'syntastic': 'SyntasticStatuslineFlag',
-	      \ }
-	      \ }
-	let g:syntastic_mode_map = { 'mode': 'passive',
-	      \                      'active_filetypes': ['c', 'cpp'] }
-<
-However, the color of the syntastic component is the same as the lineinfo
-component.
-
-In order to change the syntastic component more outstanding, you have to use
-|g:lightline.component_expand|. See the following example:
->
-	" Example B
-	let g:lightline = {
-	      \ 'active': {
-	      \   'right': [ [ 'syntastic', 'lineinfo' ],
-	      \              [ 'percent' ],
-	      \              [ 'fileformat', 'fileencoding', 'filetype' ] ]
-	      \ },
-	      \ 'component_expand': {
-	      \   'syntastic': 'SyntasticStatuslineFlag',
-	      \ },
-	      \ 'component_type': {
-	      \   'syntastic': 'error',
-	      \ }
-	      \ }
-	" Syntastic can call a post-check hook, let's update lightline there
-	" For more information: :help syntastic-loclist-callback
-	function! SyntasticCheckHook(errors)
-	  call lightline#update()
-	endfunction
-<
-In order to understand the above codes, you firstly should know how the
-colorschemes work in lightline.vim. Open the following file.
-		autoload/lightline/colorscheme/powerline.vim
-The colorscheme is created by one dictionary: s:p (abbreviation for palette).
-See the value of s:p.normal.right.
->
-	let s:p.normal.right = [ ['gray5', 'gray10'],
-	      \                  ['gray9', 'gray4'],
-	      \                  ['gray8', 'gray2'] ]
-<
-This array corresponds to the structure of g:lightline.active.right. Recall
-the example A.
->
-	" Example A
-	let g:lightline.active.right = [ [ 'lineinfo', 'syntastic' ],
-	      \                          [ 'percent' ],
-	      \                          [ 'fileformat', 'fileencoding', 'filetype' ] ]
-<
-The colors are ([fgcolor, bgcolor):
->
-	(0) [ 'lineinfo', 'syntastic' ]                   ---  s:p.normal.right[0] = ['gray5', 'gray10']
-	(1) [ 'percent' ]                                 ---  s:p.normal.right[1] = ['gray9', 'gray4']
-	(2) [ 'fileformat', 'fileencoding', 'filetype' ]  ---  s:p.normal.right[2] = ['gray8', 'gray2']
-<
-Recall the example B.
->
-	" Example B
-	let g:lightline.active.right = [ [ 'syntastic', 'lineinfo' ],
-	      \                          [ 'percent' ],
-	      \                          [ 'fileformat', 'fileencoding', 'filetype' ] ]
-<
-If a component is specified in |g:lightline.component_expand|, lightline.vim
-expands the components before setting to statusline/tabline. In this example,
-the syntastic component is expanded using the |SyntasticStatuslineFlag| function.
-This function returns a {string}. Let us call it `syntastic_flag`.
->
-	let syntastic_flag = SyntasticStatuslineFlag()
-<
-The syntastic component is now expanded, so it go up to one component group.
-The type of the syntastic component is error, and the palette has error
-colors, the result is:
->
-	" Expanded result of Example B
-	(error) [ syntastic_flag ]                            ---  s:p.normal.error[0] = ['gray9', 'brightestred']
-	(0)     [ 'lineinfo' ]                                ---  s:p.normal.right[0] = ['gray5', 'gray10']
-	(1)     [ 'percent' ]                                 ---  s:p.normal.right[1] = ['gray9', 'gray4']
-	(2)     [ 'fileformat', 'fileencoding', 'filetype' ]  ---  s:p.normal.right[2] = ['gray8', 'gray2']
-<
-Thus the syntastic component has the red color.
-
-
-Another example for |g:lightline.component_expand| is the tabs component.
-Actually, the expand feature is created for the tabs component.
->
-	let g:lightline.tabline.left = [ [ 'tabs' ] ]
-	let g:lightline.component_expand = {
-	    \ 'tabs': 'lightline#tabs' }
-<
-Create three tabs and select the middle tab. Then execute
->
-	echo lightline#tabs()
-	" [['%1T%{lightline#onetab(1,0)}'],
-	"  ['%2T%{lightline#onetab(2,1)}'],
-	"  ['%3T%{lightline#onetab(3,0)}%T']]
-<
-It returns an array of three elements. The expanded result is:
->
-	" Expanded result of tabline
-	(0)      ['%1T%{lightline#onetab(1,0)}']    ---  s:p.tabline.left[0] = ['gray9', 'gray4']
-	(tabsel) ['%2T%{lightline#onetab(2,1)}']    ---  s:p.tabline.tabsel[0] = ['gray9', 'gray1']
-	(0)      ['%3T%{lightline#onetab(3,0)}%T']  ---  s:p.tabline.left[0] = ['gray9', 'gray4']
-<
-If the tabline components are
->
-	let g:lightline.tabline.left = [ [ 'A', 'B', 'tabs', 'C', 'D' ] ]
-<
-then the expanded result is:
->
-	(0)      ['A', 'B', '%1T%{lightline#onetab(1,0)}']    ---  s:p.tabline.left[0]
-	(tabsel) ['%2T%{lightline#onetab(2,1)}']              ---  s:p.tabline.tabsel[0]
-	(0)      ['%3T%{lightline#onetab(3,0)}%T', 'C', 'D']  ---  s:p.tabline.left[0]
-<
-In summary, when a function in |g:lightline.component_expand| returns an
-array of three elements, the first element and the last element remains as a
-part of existing component group. And the middle element goes up to new
-component group.
-------------------------------------------------------------------------------
-COLORSCHEME					*lightline-colorscheme*
-You can configure the colorscheme of lightline. For example,
->
-	let g:lightline = {
-		\ 'colorscheme': 'wombat',
-		\ }
-<
-The colorscheme files are found in the directory
-
-	lightline.vim/autoload/lightline/colorscheme/
-
-In each file, one global variable is defined. For example, in the landscape.vim
-file, you see
->
-	let g:lightline#colorscheme#landscape#palette = s:p
-<
-In the file, the colors for the landscape colorscheme are defined. For example,
->
-	let s:p.normal.left = [ ['#0000ff', '#ffffff', 21, 231, 'bold' ], [ '#ffffff', '#0000ff', 231, 21 ] ]
-<
-defines the colors for the components on the left hand side, in normal mode.
->
-	let s:p.tabline.tabsel = [ [ '#dadada', '#121212', 253, 233 ] ]
-<
-defines the colors for the selected tab in tabline. In general, each palette
-follows the following style:
->
-	let s:p.{mode}.{where} = [ [ {guifg}, {guibg}, {ctermfg}, {ctermbg} ], ... ]
-<
-
-
-Now, you can create your own colorscheme for lightline. Create a
-yourcolorscheme.vim at
-
-	{one of the paths in &rtp}/autoload/lightline/colorscheme/yourcolorscheme.vim
-
-The following code gives the minimal palette definition for lightline.
->
-	let s:p = {'normal': {}}
-	let s:p.normal.left = [ [ ... ] ]
-	let s:p.normal.right = [ [ ... ] ]
-	let s:p.normal.middle = [ [ ... ] ]
-	let g:lightline#colorscheme#yourcolorscheme#palette = s:p
-<
-And if you add the colorscheme configuration to your .vimrc(_vimrc),
->
-	let g:lightline = {
-		\ 'colorscheme': 'yourcolorscheme',
-		\ }
-<
-you find it possible to change the lightline colors as you wish.
-
-Moreover, if you want to change the colors based on the mode of vim, write
-something like this:
->
-	let s:p.insert.left = [ [ ... ] ]
-	let s:p.insert.right = [ [ ... ] ]
-	let s:p.replace.left = [ [ ... ] ]
-	let s:p.replace.right = [ [ ... ] ]
-	...
-	...
-<
-For expanded components, you are recommended to define the following two
-colors.
->
-	let s:p.normal.error = [ [ ... ] ]
-	let s:p.normal.warning = [ [ ... ] ]
-<
-For the complete list of components the color of which you should define in
-your colorscheme, see the colorscheme files in lightline.
-
-It is sometimes painful to write all the colors for both gui and cterm.
-Actually, lightline has some useful functions for writing colorschemes. For
-example, see
-	lightline.vim/autoload/lightline/colorscheme/Tomorrow_Night.vim
-this colorscheme is defined using only gui color numbers. And convert to the
-normal colorscheme form using:
->
-	let g:lightline#colorscheme#Tomorrow_Night#palette = lightline#colorscheme#fill(s:p)
-<
-This function fills the cterm colors for a palette which has only gui colors, or
-vice versa. However, note that using the convenient function sources an
-additional Vim script file (autoload/lightline/colorscheme.vim), which causes
-a little slow down. If you want to avoid this situation, write all the colors
-as done in autoload/lightline/colorscheme/landscape.vim; firstly create the
-colorscheme using the fill function, and see the result, in a sense, the
-compiled version of your colorscheme.
->
-	echo g:lightline#colorscheme#yourcolorscheme#palette
-<
-Then copy and paste the result to the colorscheme file.
-
-If you want to contribute a new colorscheme that is not currently available
-please follow the following rules:
-    *) All hex codes should be lowercase only
-    *) Use 2 space soft tabs
-    *) If your colorscheme has both light and dark variants, use a single file
-    *) Normal Mode should default to Cyan
-    *) Insert Mode should default to Green
-    *) Visual Mode should default to Yellow
-    *) Replace Mode should default to Red
-
-==============================================================================
-EXAMPLES					*lightline-examples*
-You can configure the appearance of statusline.
-Write the following examples in you .vimrc(_vimrc).
-
-In order to change the colorscheme:
->
-	let g:lightline = {
-		\ 'colorscheme': 'wombat',
-		\ }
-<
-
-In order to define your own component:
->
-	let g:lightline = {
-		\ 'active': {
-		\   'left': [ [ 'mode', 'paste' ], [ 'myfilename' ] ]
-		\ },
-		\ 'component_function': {
-		\   'myfilename': 'LightlineFilename',
-		\   'myreadonly': 'LightlineReadonly',
-		\   'mymodified': 'LightlineModified',
-		\ }
-		\ }
-	function! LightlineFilename()
-		return (LightlineReadonly() !=# '' ? LightlineReadonly() . ' ' : '') .
-		      \ (&ft ==# 'vimfiler' ? vimfiler#get_status_string() :
-		      \  &ft ==# 'unite' ? unite#get_status_string() :
-		      \ expand('%:t') !=# '' ? expand('%:t') : '[No Name]') .
-		      \ (LightlineModified() !=# '' ? ' ' . LightlineModified() : '')
-	endfunction
-	function! LightlineReadonly()
-		return &ft !~? 'help' && &readonly ? 'RO' : ''
-	endfunction
-	function! LightlineModified()
-		return &modifiable && &modified ? '+' : ''
-	endfunction
-<
-
-Separators settings:
->
-	let g:lightline = {
-		\ 'separator': { 'left': '', 'right': '' },
-		\ 'subseparator': { 'left': '|', 'right': '|' }
-		\ }
-<
-
-For |powerline| font users:
->
-	let g:lightline = {
-		\ 'separator': { 'left': '', 'right': '' },
-		\ 'subseparator': { 'left': '', 'right': '' }
-		\ }
-<
-
-For |vim-powerline| font users:
->
-	let g:lightline = {
-		\ 'separator': { 'left': '', 'right': '' },
-		\ 'subseparator': { 'left': '', 'right': '' }
-		\ }
-<
-
-------------------------------------------------------------------------------
-NICE EXAMPLES					*lightline-nice-examples*
-
-A nice example for non-patched font users.
->
-	let g:lightline = {
-		\ 'colorscheme': 'wombat',
-		\ 'active': {
-		\   'left': [ [ 'mode', 'paste' ], [ 'fugitive', 'filename' ] ]
-		\ },
-		\ 'component_function': {
-		\   'fugitive': 'LightlineFugitive',
-		\   'filename': 'LightlineFilename'
-		\ }
-		\ }
-	function! LightlineModified()
-		return &ft =~# 'help\|vimfiler' ? '' : &modified ? '+' : &modifiable ? '' : '-'
-	endfunction
-	function! LightlineReadonly()
-		return &ft !~? 'help\|vimfiler' && &readonly ? 'RO' : ''
-	endfunction
-	function! LightlineFilename()
-		return (LightlineReadonly() !=# '' ? LightlineReadonly() . ' ' : '') .
-		\ (&ft ==# 'vimfiler' ? vimfiler#get_status_string() :
-		\  &ft ==# 'unite' ? unite#get_status_string() :
-		\  &ft ==# 'vimshell' ? vimshell#get_status_string() :
-		\ expand('%:t') !=# '' ? expand('%:t') : '[No Name]') .
-		\ (LightlineModified() !=# '' ? ' ' . LightlineModified() : '')
-	endfunction
-	function! LightlineFugitive()
-		if &ft !~? 'vimfiler' && exists('*FugitiveHead')
-			return FugitiveHead()
-		endif
-		return ''
-	endfunction
-<
-A nice example for |vim-powerline| font users:
->
-	let g:lightline = {
-		\ 'colorscheme': 'wombat',
-		\ 'active': {
-		\   'left': [ [ 'mode', 'paste' ], [ 'fugitive', 'filename' ] ]
-		\ },
-		\ 'component_function': {
-		\   'fugitive': 'LightlineFugitive',
-		\   'filename': 'LightlineFilename'
-		\ },
-		\ 'separator': { 'left': '', 'right': '' },
-		\ 'subseparator': { 'left': '', 'right': '' }
-		\ }
-	function! LightlineModified()
-		return &ft =~# 'help\|vimfiler' ? '' : &modified ? '+' : &modifiable ? '' : '-'
-	endfunction
-	function! LightlineReadonly()
-		return &ft !~? 'help\|vimfiler' && &readonly ? '' : ''
-	endfunction
-	function! LightlineFilename()
-		return (LightlineReadonly() !=# '' ? LightlineReadonly() . ' ' : '') .
-		\ (&ft ==# 'vimfiler' ? vimfiler#get_status_string() :
-		\  &ft ==# 'unite' ? unite#get_status_string() :
-		\  &ft ==# 'vimshell' ? vimshell#get_status_string() :
-		\ expand('%:t') !=# '' ? expand('%:t') : '[No Name]') .
-		\ (LightlineModified() !=# '' ? ' ' . LightlineModified() : '')
-	endfunction
-	function! LightlineFugitive()
-		if &ft !~? 'vimfiler' && exists('*FugitiveHead')
-			let branch = FugitiveHead()
-			return branch !=# '' ? ' '.branch : ''
-		endif
-		return ''
-	endfunction
-<
-
-------------------------------------------------------------------------------
-POWERFUL EXAMPLE				*lightline-powerful-example*
-
-For users who uses lots of plugins:
->
-	let g:lightline = {
-	      \ 'colorscheme': 'wombat',
-	      \ 'active': {
-	      \   'left': [ [ 'mode', 'paste' ], [ 'fugitive', 'filename' ], ['ctrlpmark'] ],
-	      \   'right': [ [ 'syntastic', 'lineinfo' ], ['percent'], [ 'fileformat', 'fileencoding', 'filetype' ] ]
-	      \ },
-	      \ 'component_function': {
-	      \   'fugitive': 'LightlineFugitive',
-	      \   'filename': 'LightlineFilename',
-	      \   'fileformat': 'LightlineFileformat',
-	      \   'filetype': 'LightlineFiletype',
-	      \   'fileencoding': 'LightlineFileencoding',
-	      \   'mode': 'LightlineMode',
-	      \   'ctrlpmark': 'CtrlPMark',
-	      \ },
-	      \ 'component_expand': {
-	      \   'syntastic': 'SyntasticStatuslineFlag',
-	      \ },
-	      \ 'component_type': {
-	      \   'syntastic': 'error',
-	      \ },
-	      \ 'subseparator': { 'left': '|', 'right': '|' }
-	      \ }
-
-	function! LightlineModified()
-	  return &ft ==# 'help' ? '' : &modified ? '+' : &modifiable ? '' : '-'
-	endfunction
-
-	function! LightlineReadonly()
-	  return &ft !~? 'help' && &readonly ? 'RO' : ''
-	endfunction
-
-	function! LightlineFilename()
-	  let fname = expand('%:t')
-	  return fname ==# 'ControlP' && has_key(g:lightline, 'ctrlp_item') ? g:lightline.ctrlp_item :
-	        \ fname =~# '^__Tagbar__\|__Gundo\|NERD_tree' ? '' :
-	        \ &ft ==# 'vimfiler' ? vimfiler#get_status_string() :
-	        \ &ft ==# 'unite' ? unite#get_status_string() :
-	        \ &ft ==# 'vimshell' ? vimshell#get_status_string() :
-	        \ (LightlineReadonly() !=# '' ? LightlineReadonly() . ' ' : '') .
-	        \ (fname !=# '' ? fname : '[No Name]') .
-	        \ (LightlineModified() !=# '' ? ' ' . LightlineModified() : '')
-	endfunction
-
-	function! LightlineFugitive()
-	  try
-	    if expand('%:t') !~? 'Tagbar\|Gundo\|NERD' && &ft !~? 'vimfiler' && exists('*FugitiveHead')
-	      let mark = ''  " edit here for cool mark
-	      let branch = FugitiveHead()
-	      return branch !=# '' ? mark.branch : ''
-	    endif
-	  catch
-	  endtry
-	  return ''
-	endfunction
-
-	function! LightlineFileformat()
-	  return winwidth(0) > 70 ? &fileformat : ''
-	endfunction
-
-	function! LightlineFiletype()
-	  return winwidth(0) > 70 ? (&filetype !=# '' ? &filetype : 'no ft') : ''
-	endfunction
-
-	function! LightlineFileencoding()
-	  return winwidth(0) > 70 ? (&fenc !=# '' ? &fenc : &enc) : ''
-	endfunction
-
-	function! LightlineMode()
-	  let fname = expand('%:t')
-	  return fname =~# '^__Tagbar__' ? 'Tagbar' :
-	        \ fname ==# 'ControlP' ? 'CtrlP' :
-	        \ fname ==# '__Gundo__' ? 'Gundo' :
-	        \ fname ==# '__Gundo_Preview__' ? 'Gundo Preview' :
-	        \ fname =~# 'NERD_tree' ? 'NERDTree' :
-	        \ &ft ==# 'unite' ? 'Unite' :
-	        \ &ft ==# 'vimfiler' ? 'VimFiler' :
-	        \ &ft ==# 'vimshell' ? 'VimShell' :
-	        \ winwidth(0) > 60 ? lightline#mode() : ''
-	endfunction
-
-	function! CtrlPMark()
-	  if expand('%:t') ==# 'ControlP' && has_key(g:lightline, 'ctrlp_item')
-	    call lightline#link('iR'[g:lightline.ctrlp_regex])
-	    return lightline#concatenate([g:lightline.ctrlp_prev, g:lightline.ctrlp_item
-	          \ , g:lightline.ctrlp_next], 0)
-	  else
-	    return ''
-	  endif
-	endfunction
-
-	let g:ctrlp_status_func = {
-	  \ 'main': 'CtrlPStatusFunc_1',
-	  \ 'prog': 'CtrlPStatusFunc_2',
-	  \ }
-
-	function! CtrlPStatusFunc_1(focus, byfname, regex, prev, item, next, marked)
-	  let g:lightline.ctrlp_regex = a:regex
-	  let g:lightline.ctrlp_prev = a:prev
-	  let g:lightline.ctrlp_item = a:item
-	  let g:lightline.ctrlp_next = a:next
-	  return lightline#statusline(0)
-	endfunction
-
-	function! CtrlPStatusFunc_2(str)
-	  return lightline#statusline(0)
-	endfunction
-
-	let g:tagbar_status_func = 'TagbarStatusFunc'
-
-	function! TagbarStatusFunc(current, sort, fname, ...) abort
-	  return lightline#statusline(0)
-	endfunction
-
-	" Syntastic can call a post-check hook, let's update lightline there
-	" For more information: :help syntastic-loclist-callback
-	function! SyntasticCheckHook(errors)
-	  call lightline#update()
-	endfunction
-
-	let g:unite_force_overwrite_statusline = 0
-	let g:vimfiler_force_overwrite_statusline = 0
-	let g:vimshell_force_overwrite_statusline = 0
-<
-------------------------------------------------------------------------------
-TROUBLESHOOTING					*lightline-troubleshooting*
-
-Problem 1:				|lightline-problem-1|
-	How to install this plugin.
-
-Problem 2:				|lightline-problem-2|
-	How to update this plugin.
-
-Problem 3:				|lightline-problem-3|
-	How to uninstall this plugin.
-
-Problem 4:				|lightline-problem-4|
-	Cool statuslines appear only on |:vsp|.
-
-Problem 5:				|lightline-problem-5|
-	The statusline does not seem to be correctly colored.
-
-Problem 6:				|lightline-problem-6|
-	How to install a patched font.
-
-Problem 7:				|lightline-problem-7|
-	Right triangles do not stick to the right components with the
-	patched font.
-
-Problem 8:				|lightline-problem-8|
-	Triangles do not appear. Triangles look weird.
-
-Problem 9:				|lightline-problem-9|
-	Where can I find the list of all the cool characters for patched fonts?
-
-Problem 10:				|lightline-problem-10|
-	Cool statusline disappears in |unite|, |vimfiler| and |vimshell|
-	buffers.
-
-Problem 11:				|lightline-problem-11|
-	Cool statusline disappears in |CtrlP|, |Tagbar| buffers.
-
-Problem 12:				|lightline-problem-12|
-	How to make the plus sign red like |powerline|?
-
-Problem 13:				|lightline-problem-13|
-	How to change the lightline colorscheme on the fly.
-
-Problem 14:				|lightline-problem-14|
-	The 'E541' warning appears on the right hand side.
-	Many components disable the statusline of lightline.
-
-Problem 15:				|lightline-problem-15|
-	Do not deal with the tabline.
-	Do not use the fancy separators in the tabline.
-
-Problem 16:				|lightline-problem-16|
-	When changed the component to a function component to an expanding
-	component, the statusline of lightline is sometimes disabled.
-
-Problem 17:				|lightline-problem-17|
-	Found a bug of this plugin.
-	Got many errors while using this plugin.
-	Vim hangs while using this plugin.
-	Want this plugin to be more configurable.
-	This troubleshooting is not helpful.
-
-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
-
-Problem 1:					*lightline-problem-1*
-	How to install this plugin.
-
-		If you are to install this plugin manually:
-
-			1. Put all the files under $VIM.
-
-		If you are to install this plugin using |vim-pathogen|:
-
-			1. Install this plugin with the following command.
->
-			git clone https://github.com/itchyny/lightline.vim \
-			    ~/.vim/bundle/lightline.vim
-<
-			2. Generate help tags with |:Helptags|.
-
-		If you are to install this plugin using |Vundle|:
-
-			1. Add the following configuration to your
-			.vimrc(_vimrc).
->
-			Plugin 'itchyny/lightline.vim'
-<
-			2. Install with |:PluginInstall|.
-
-		If you are to install this plugin using |NeoBundle|:
-
-			1. Add the following configuration to your
-			.vimrc(_vimrc).
->
-			NeoBundle 'itchyny/lightline.vim'
-<
-			2. Install with |:NeoBundleInstall|.
-
-		If you are to install this plugin using |vim-plug|:
-
-			1. Add the following configuration to your
-			.vimrc(_vimrc).
->
-			Plug 'itchyny/lightline.vim'
-<
-			2. Install with |:PlugInstall|.
-
-Problem 2:					*lightline-problem-2*
-	How to update this plugin.
-
-		If you have installed this plugin manually:
-
-			1. Access https://github.com/itchyny/lightline.vim .
-			2. Download the latest scripts.
-			3. Place the scripts as written in Problem 1.
-
-		If you have installed this plugin using Vundle:
-
-			1. Execute |:PluginUpdate|.
-
-		If you have installed this plugin using NeoBundle:
-
-			1. Execute |:NeoBundleUpdate|.
-
-		If you have installed this plugin using vim-plug:
-
-			1. Execute |:PlugUpdate|.
-
-Problem 3:					*lightline-problem-3*
-	How to uninstall this plugin.
-
-		If you have installed this plugin manually:
-
-			1. Remove all the lightline.*s under $VIM.
-
-		If you have installed this plugin using Vundle:
-
-			1. Remove the :Plugin 'itchyny/lightline.vim'
-			configuration from your .vimrc(_vimrc).
-			2. Update with |:PluginClean|.
-
-		If you have installed this plugin using NeoBundle:
-
-			1. Remove the :NeoBundle 'itchyny/lightline.vim'
-			configuration from your .vimrc(_vimrc).
-			2. Update with |:NeoBundleClean|.
-
-		If you have installed this plugin using vim-plug:
-
-			1. Remove the :Plug 'itchyny/lightline.vim'
-			configuration from your .vimrc(_vimrc).
-			2. Update with |:PlugClean|.
-
-Problem 4:					*lightline-problem-4*
-	Cool statuslines appear only on |:vsp|.
-
-		Add the following setting to your .vimrc(_vimrc).
->
-			set laststatus=2
-<
-Problem 5:					*lightline-problem-5*
-	The statusline does not seem to be correctly colored.
-
-		Add
->
-			export TERM=xterm-256color
-<
-		to your .*shrc and add
->
-			if !has('gui_running')
-			  set t_Co=256
-			endif
-<
-		to your .vimrc(_vimrc).
-
-Problem 6:					*lightline-problem-6*
-	How to install a patched font.
-
-		There are two kinds of patched fonts:
-
-		+ The patched fonts for |vim-powerline|
-		(https://github.com/Lokaltog/vim-powerline):
-		follow the guide https://github.com/Lokaltog/vim-powerline/tree/develop/fontpatcher
-		+ The patched fonts for |powerline|
-		(https://github.com/Lokaltog/powerline):
-		download from https://github.com/Lokaltog/powerline-fonts
-
-Problem 7:					*lightline-problem-7*
-	Right triangles do not stick to the right components with patched
-	font.
-
-		Remove the following setting from your .vimrc(_vimrc).
->
-			set ambiwidth=double
-<
-		If you want to keep this setting, try the patched font for
-		|vim-powerline|.
-
-Problem 8:					*lightline-problem-8*
-	Triangles do not appear. Triangles look weird.
-
-		If the triangles do not appear (but you get some spaces or
-		weird characters like <bf> or ), firstly try adding
->
-			scriptencoding utf-8
-			set encoding=utf-8
-<
-		to the head of your .vimrc(_vimrc). Still you have weird
-		characters, use the unicode numbers. For |powerline| font
-		users:
->
-		\ 'separator': { 'left': "\ue0b0", 'right': "\ue0b2" },
-		\ 'subseparator': { 'left': "\ue0b1", 'right': "\ue0b3" }
-<
-		For |vim-powerline| font users:
->
-		\ 'separator': { 'left': "\u2b80", 'right': "\u2b82" },
-		\ 'subseparator': { 'left': "\u2b81", 'right': "\u2b83" }
-<
-		The full list of unicode numbers for fancy characters is shown
-		in |lightline-problem-9|.
-
-		If the triangles are shown in appropriate characters but the
-		colors do not look correctly, see the following.
-		If you are using iTerm2, change the following settings.
-
-		    + set Profiles>Colors>Minimum contrast to the Lowest.
-		    + set Profiles>Window>Transparency to the Opaquest.
-
-		For other terminals, this weird-triangle problem will be
-		resolved by disabling transparency or contrast adjustment.
-
-Problem 9:					*lightline-problem-9*
-	Where can I find the list of all the cool characters for patched fonts?
-
-				Default		powerline	vim-powerline
-	separator.left		''		'' (\ue0b0)		'' (\u2b80)
-	separator.right		''		'' (\ue0b2)		'' (\u2b82)
-	subseparator.left	'|'		'' (\ue0b1)		'' (\u2b81)
-	subseparator.right	'|'		'' (\ue0b3)		'' (\u2b83)
-	branch symbol		--		'' (\ue0a0)		'' (\u2b60)
-	readonly symbol		--		'' (\ue0a2)		'' (\u2b64)
-	linecolumn symbol	--		'' (\ue0a1)		'' (\u2b61)
-
-Problem 10:					*lightline-problem-10*
-	Cool statusline disappears on |unite|, |vimfiler| and |vimshell|
-	buffers.
-
-		Add the following settings to your .vimrc(_vimrc).
->
-		let g:unite_force_overwrite_statusline = 0
-		let g:vimfiler_force_overwrite_statusline = 0
-		let g:vimshell_force_overwrite_statusline = 0
-<
-Problem 11:					*lightline-problem-11*
-	Cool statusline disappears in |CtrlP|, |Tagbar| buffers.
-
-		Add the following settings to your .vimrc(_vimrc).
->
-		let g:ctrlp_status_func = {
-		  \ 'main': 'CtrlPStatusFunc_1',
-		  \ 'prog': 'CtrlPStatusFunc_2',
-		  \ }
-		function! CtrlPStatusFunc_1(focus, byfname, regex, prev, item, next, marked)
-		  return lightline#statusline(0)
-		endfunction
-		function! CtrlPStatusFunc_2(str)
-		  return lightline#statusline(0)
-		endfunction
-
-		let g:tagbar_status_func = 'TagbarStatusFunc'
-		function! TagbarStatusFunc(current, sort, fname, ...) abort
-		  return lightline#statusline(0)
-		endfunction
-<
-		See |lightline-powerful-example| for more cool settings for
-		these plugins.
-
-Problem 12:					*lightline-problem-12*
-	How to make the plus sign red like |powerline|?
-
-		Use the following settings.
->
-		let g:lightline = {
-		      \ 'component': {
-		      \   'modified': '%#ModifiedColor#%{LightlineModified()}',
-		      \ }
-		      \ }
-		function! LightlineModified()
-		  let map = { 'V': 'n', "\<C-v>": 'n', 's': 'n', 'v': 'n', "\<C-s>": 'n', 'c': 'n', 'R': 'n'}
-		  let mode = get(map, mode()[0], mode()[0])
-		  let bgcolor = {'n': [240, '#585858'], 'i': [31, '#0087af']}
-		  let color = get(bgcolor, mode, bgcolor.n)
-		  exe printf('hi ModifiedColor ctermfg=196 ctermbg=%d guifg=#ff0000 guibg=%s term=bold cterm=bold',
-			\ color[0], color[1])
-		  return &modified ? '+' : &modifiable ? '' : '-'
-		endfunction
-<
-		It's surely complicated. There's no easy API to do a thing
-		like this. But it means that your request does not match
-		the spirit of lightline.
-
-Problem 13:					*lightline-problem-13*
-	How to change the lightline colorscheme on the fly.
-
-		To update your lightline colorscheme in sync with your vim
-		colorscheme (only for select colorschemes which exist for
-		both), add the following settings to your .vimrc(_vimrc).
->
-		augroup LightlineColorscheme
-		  autocmd!
-		  autocmd ColorScheme * call s:lightline_update()
-		augroup END
-		function! s:lightline_update()
-		  if !exists('g:loaded_lightline')
-		    return
-		  endif
-		  try
-		    if g:colors_name =~# 'wombat\|solarized\|landscape\|jellybeans\|seoul256\|Tomorrow'
-		      let g:lightline.colorscheme =
-		            \ substitute(substitute(g:colors_name, '-', '_', 'g'), '256.*', '', '')
-		      call lightline#init()
-		      call lightline#colorscheme()
-		      call lightline#update()
-		    endif
-		  catch
-		  endtry
-		endfunction
-<
-		If you have not settled on a single lightline colorscheme, you
-		can easily switch between lightline colorschemes by adding the
-		following LightlineColorscheme command to your .vimrc(_vimrc).
->
-		function! s:set_lightline_colorscheme(name) abort
-		  let g:lightline.colorscheme = a:name
-		  call lightline#init()
-		  call lightline#colorscheme()
-		  call lightline#update()
-		endfunction
-
-		function! s:lightline_colorschemes(...) abort
-		  return join(map(
-		        \ globpath(&rtp,"autoload/lightline/colorscheme/*.vim",1,1),
-		        \ "fnamemodify(v:val,':t:r')"),
-		        \ "\n")
-		endfunction
-
-		command! -nargs=1 -complete=custom,s:lightline_colorschemes LightlineColorscheme
-		      \ call s:set_lightline_colorscheme(<q-args>)
-<
-Problem 14:					*lightline-problem-14*
-	The 'E541' warning appears on the right hand side.
-	Many components disable the statusline of lightline.
-
-		The number of items in statusline/tabline is limited to 80
-		(see |E541|). You cannot register too much components.
-
-Problem 15:					*lightline-problem-15*
-	Do not deal with the tabline.
-	Do not use the fancy separators in the tabline.
-
-		You can disable the tabline feature of lightline.vim using:
->
-		let g:lightline = {
-			\ 'enable': { 'tabline': 0 },
-			\ }
-<
-		If you don't like the separators in the tabline, use:
->
-		let g:lightline = {
-			\ 'tabline_separator': { 'left': "", 'right': "" },
-			\ 'tabline_subseparator': { 'left': "", 'right': "" },
-			\ }
-<
-Problem 16:					*lightline-problem-16*
-	When changed the component to a function component to an expanding
-	component, the statusline of lightline is sometimes disabled.
-
-		When you changed from
->
-			\ 'component_function': {
-			\   'my': 'My',
-			\ }
-<
-		to
->
-			\ 'component_expand': {
-			\   'my': 'My',
-			\ }
-<
-		the statusline of lightline is disabled unexpectedly.
-		In such a case, the text returned by 'My' function may include
-		the '%' character. Replace all the '%' signs with '%%'.
->
-		function My()
-		  ...
-		  return substitute(text, '%', '%%', 'g')
-		endfunction
-<
-Problem 17:					*lightline-problem-17*
-	Found a bug of this plugin.
-	Got many errors while using this plugin.
-	Vim hangs while using this plugin.
-	Want this plugin to be more configurable.
-	This troubleshooting is not helpful.
-
-		Report/Request the issue/feature at
-		https://github.com/itchyny/lightline.vim/issues.
-
-==============================================================================
-vim:tw=78:sw=4:ts=8:ft=help:norl:noet:
diff --git a/sources_non_forked/lightline.vim/plugin/lightline.vim b/sources_non_forked/lightline.vim/plugin/lightline.vim
deleted file mode 100644
index a11d662..0000000
--- a/sources_non_forked/lightline.vim/plugin/lightline.vim
+++ /dev/null
@@ -1,33 +0,0 @@
-" =============================================================================
-" Filename: plugin/lightline.vim
-" Author: itchyny
-" License: MIT License
-" Last Change: 2020/03/16 19:08:41.
-" =============================================================================
-
-if exists('g:loaded_lightline') || v:version < 700
-  finish
-endif
-let g:loaded_lightline = 1
-
-let s:save_cpo = &cpo
-set cpo&vim
-
-augroup lightline
-  autocmd!
-  autocmd WinEnter,BufEnter,BufDelete,SessionLoadPost,FileChangedShellPost * call lightline#update()
-  if !has('patch-8.1.1715')
-    autocmd FileType qf call lightline#update()
-  endif
-  autocmd SessionLoadPost * call lightline#highlight()
-  autocmd ColorScheme * if !has('vim_starting') || expand('<amatch>') !=# 'macvim'
-        \ | call lightline#update() | call lightline#highlight() | endif
-augroup END
-
-" This quickfix option was introduced at Vim 85850f3a5ef9, which is the commit
-" just before 8.1.1715. Before this patch, autocmd FileType is required to
-" overwrite the statusline of the quickfix and location windows.
-let g:qf_disable_statusline = 1
-
-let &cpo = s:save_cpo
-unlet s:save_cpo
diff --git a/sources_non_forked/lightline.vim/test/.themisrc b/sources_non_forked/lightline.vim/test/.themisrc
deleted file mode 100644
index 6e0121c..0000000
--- a/sources_non_forked/lightline.vim/test/.themisrc
+++ /dev/null
@@ -1,22 +0,0 @@
-let s:sids = {}
-function! s:sid(path) abort
-  if has_key(s:sids, a:path)
-    return s:sids[a:path]
-  endif
-  redir => scriptnames
-    silent! scriptnames
-  redir END
-  for line in split(scriptnames, '\n')
-    if line =~# a:path
-      let sid =  matchstr(line, '\v^\s*\zs\d+\ze')
-      let s:sids[a:path] = sid
-      return sid
-    endif
-  endfor
-endfunction
-
-function! SID(name) abort
-  return function(printf("\<SNR>%d_%s", s:sid('autoload/lightline.vim'), a:name))
-endfunction
-
-filetype plugin on
diff --git a/sources_non_forked/lightline.vim/test/autocmd.vim b/sources_non_forked/lightline.vim/test/autocmd.vim
deleted file mode 100644
index 934509b..0000000
--- a/sources_non_forked/lightline.vim/test/autocmd.vim
+++ /dev/null
@@ -1,23 +0,0 @@
-if !has("patch-8.2.0996")
-  finish
-endif
-
-let s:suite = themis#suite('autocmd')
-let s:assert = themis#helper('assert')
-
-function! s:suite.before_each()
-  let g:lightline = {}
-  call lightline#init()
-  tabnew
-  tabonly
-endfunction
-
-function! s:suite.doautoall()
-  tabnew
-  tabnew
-  tabprevious
-  doautoall WinEnter
-  let statusline = getwinvar(1, '&statusline')
-  call s:assert.match(statusline, 'lightline')
-  call s:assert.match(statusline, '_active_')
-endfunction
diff --git a/sources_non_forked/lightline.vim/test/concatenate.vim b/sources_non_forked/lightline.vim/test/concatenate.vim
deleted file mode 100644
index 6fd2723..0000000
--- a/sources_non_forked/lightline.vim/test/concatenate.vim
+++ /dev/null
@@ -1,90 +0,0 @@
-let s:suite = themis#suite('concatenate')
-let s:assert = themis#helper('assert')
-
-function! s:suite.before_each()
-  let g:lightline = { 'subseparator': { 'left': '>', 'right': '<' } }
-  call lightline#init()
-endfunction
-
-function! s:suite.nil()
-  call s:assert.equals(lightline#concatenate([], 0), '')
-  call s:assert.equals(lightline#concatenate([], 1), '')
-endfunction
-
-function! s:suite.one()
-  call s:assert.equals(lightline#concatenate(['foo'], 0), 'foo')
-  call s:assert.equals(lightline#concatenate(['foo'], 1), 'foo')
-endfunction
-
-function! s:suite.two()
-  call s:assert.equals(lightline#concatenate(['foo', 'bar'], 0), 'foo > bar')
-  call s:assert.equals(lightline#concatenate(['foo', 'bar'], 1), 'foo < bar')
-endfunction
-
-function! s:suite.three()
-  call s:assert.equals(lightline#concatenate(['foo', 'bar', 'baz'], 0), 'foo > bar > baz')
-  call s:assert.equals(lightline#concatenate(['foo', 'bar', 'baz'], 1), 'foo < bar < baz')
-endfunction
-
-function! s:suite.one_empty()
-  call s:assert.equals(lightline#concatenate([''], 0), '')
-  call s:assert.equals(lightline#concatenate([''], 1), '')
-endfunction
-
-function! s:suite.two_empty_left()
-  call s:assert.equals(lightline#concatenate(['', 'bar'], 0), 'bar')
-  call s:assert.equals(lightline#concatenate(['', 'bar'], 1), 'bar')
-endfunction
-
-function! s:suite.two_empty_right()
-  call s:assert.equals(lightline#concatenate(['foo', ''], 0), 'foo')
-  call s:assert.equals(lightline#concatenate(['foo', ''], 1), 'foo')
-endfunction
-
-function! s:suite.two_empty_both()
-  call s:assert.equals(lightline#concatenate(['', ''], 0), '')
-  call s:assert.equals(lightline#concatenate(['', ''], 1), '')
-endfunction
-
-function! s:suite.three_empty_left()
-  call s:assert.equals(lightline#concatenate(['', 'bar', 'baz'], 0), 'bar > baz')
-  call s:assert.equals(lightline#concatenate(['', 'bar', 'baz'], 1), 'bar < baz')
-endfunction
-
-function! s:suite.three_empty_middle()
-  call s:assert.equals(lightline#concatenate(['foo', '', 'baz'], 0), 'foo > baz')
-  call s:assert.equals(lightline#concatenate(['foo', '', 'baz'], 1), 'foo < baz')
-endfunction
-
-function! s:suite.three_empty_right()
-  call s:assert.equals(lightline#concatenate(['foo', 'bar', ''], 0), 'foo > bar')
-  call s:assert.equals(lightline#concatenate(['foo', 'bar', ''], 1), 'foo < bar')
-endfunction
-
-function! s:suite.three_empty_middle_right()
-  call s:assert.equals(lightline#concatenate(['foo', '', ''], 0), 'foo')
-  call s:assert.equals(lightline#concatenate(['foo', '', ''], 1), 'foo')
-endfunction
-
-function! s:suite.three_empty_left_right()
-  call s:assert.equals(lightline#concatenate(['', 'bar', ''], 0), 'bar')
-  call s:assert.equals(lightline#concatenate(['', 'bar', ''], 1), 'bar')
-endfunction
-
-function! s:suite.three_empty_left_middle()
-  call s:assert.equals(lightline#concatenate(['', '', 'baz'], 0), 'baz')
-  call s:assert.equals(lightline#concatenate(['', '', 'baz'], 1), 'baz')
-endfunction
-
-function! s:suite.three_empty_all()
-  call s:assert.equals(lightline#concatenate(['', '', ''], 0), '')
-  call s:assert.equals(lightline#concatenate(['', '', ''], 1), '')
-endfunction
-
-function! s:suite.keep_original()
-  let xs = ['', 'bar', '']
-  call s:assert.equals(lightline#concatenate(xs, 0), 'bar')
-  call s:assert.equals(xs, ['', 'bar', ''])
-  call s:assert.equals(lightline#concatenate(xs, 1), 'bar')
-  call s:assert.equals(xs, ['', 'bar', ''])
-endfunction
diff --git a/sources_non_forked/lightline.vim/test/error.vim b/sources_non_forked/lightline.vim/test/error.vim
deleted file mode 100644
index 8fdabf4..0000000
--- a/sources_non_forked/lightline.vim/test/error.vim
+++ /dev/null
@@ -1,15 +0,0 @@
-let s:suite = themis#suite('error')
-let s:assert = themis#helper('assert')
-
-function! s:message() abort
-  redir => messages
-    silent! messages
-  redir END
-  return split(messages, '\n')[-1]
-endfunction
-
-function! s:suite.error()
-  let message = 'An error occurred.'
-  call lightline#error(message)
-  call s:assert.equals(s:message(), 'lightline.vim: ' . message)
-endfunction
diff --git a/sources_non_forked/lightline.vim/test/expand.vim b/sources_non_forked/lightline.vim/test/expand.vim
deleted file mode 100644
index e1ac310..0000000
--- a/sources_non_forked/lightline.vim/test/expand.vim
+++ /dev/null
@@ -1,667 +0,0 @@
-let s:suite = themis#suite('expand')
-let s:assert = themis#helper('assert')
-
-function! s:expand(...)
-  return call(SID('expand'), a:000)
-endfunction
-
-function! s:suite.expand()
-  let g:lightline = {}
-  call lightline#init()
-  call s:assert.equals(s:expand([]),
-        \ [[], [], ['0']])
-endfunction
-
-function! s:suite.default()
-  let g:lightline = {}
-  call lightline#init()
-  call s:assert.equals(s:expand([['mode', 'paste'], ['readonly', 'filename', 'modified']]),
-        \ [[['mode', 'paste'], ['readonly', 'filename', 'modified']], [[0, 0], [0, 0, 0]], ['0', '1', '2']])
-endfunction
-
-function! s:suite.custom()
-  function! Custom()
-    return [ ['left'], ['middle'], ['right'] ]
-  endfunction
-  let g:lightline = { 'component_expand': { 'custom': 'Custom' } }
-  call lightline#init()
-  call s:assert.equals(s:expand([['readonly', 'filename'], ['custom'], ['modified']]),
-        \ [[['readonly', 'filename'], ['left', 'middle', 'right'], ['modified']], [[0, 0], [1, 1, 1], [0]], ['0', '1', '2', '3']])
-  call s:assert.equals(s:expand([['readonly', 'filename', 'custom', 'modified']]),
-        \ [[['readonly', 'filename', 'left', 'middle', 'right', 'modified']], [[0, 0, 1, 1, 1, 0]], ['0', '1']])
-  delfunction Custom
-endfunction
-
-function! s:suite.custom_type()
-  function! Custom()
-    return [ ['left'], ['middle'], ['right'] ]
-  endfunction
-  let g:lightline = { 'component_expand': { 'custom': 'Custom' }, 'component_type': { 'custom': 'custom' } }
-  call lightline#init()
-  call s:assert.equals(s:expand([['readonly', 'filename'], ['custom'], ['modified']]),
-        \ [[['readonly', 'filename'], ['left'], ['middle'], ['right'], ['modified']], [[0, 0], [1], [1], [1], [0]], ['0', '1', 'custom', '1', '2', '3']])
-  call s:assert.equals(s:expand([['readonly', 'filename', 'custom', 'modified']]),
-        \ [[['readonly', 'filename', 'left'], ['middle'], ['right', 'modified']], [[0, 0, 1], [1], [1, 0]], ['0', 'custom', '0', '1']])
-  delfunction Custom
-endfunction
-
-function! s:suite.raw_type()
-  function! Custom()
-    return [ ['left'], ['middle'], ['right'] ]
-  endfunction
-  let g:lightline = { 'component_expand': { 'custom': 'Custom' }, 'component_type': { 'custom': 'raw' } }
-  call lightline#init()
-  call s:assert.equals(s:expand([['readonly', 'filename'], ['custom'], ['modified']]),
-        \ [[['readonly', 'filename'], ['left', 'middle', 'right'], ['modified']], [[0, 0], [2, 2, 2], [0]], ['0', '1', '2', '3']])
-  call s:assert.equals(s:expand([['readonly', 'filename', 'custom', 'modified']]),
-        \ [[['readonly', 'filename', 'left', 'middle', 'right', 'modified']], [[0, 0, 2, 2, 2, 0]], ['0', '1']])
-  delfunction Custom
-endfunction
-
-function! s:suite.component_raw()
-  function! Custom()
-    return [ ['left'], ['middle'], ['right'] ]
-  endfunction
-  let g:lightline = { 'component_expand': { 'custom': 'Custom' }, 'component_type': { 'custom': 'custom' }, 'component_raw': { 'custom': 1 } }
-  call lightline#init()
-  call s:assert.equals(s:expand([['readonly', 'filename'], ['custom'], ['modified']]),
-        \ [[['readonly', 'filename'], ['left'], ['middle'], ['right'], ['modified']], [[0, 0], [2], [2], [2], [0]], ['0', '1', 'custom', '1', '2', '3']])
-  call s:assert.equals(s:expand([['readonly', 'filename', 'custom', 'modified']]),
-        \ [[['readonly', 'filename', 'left'], ['middle'], ['right', 'modified']], [[0, 0, 2], [2], [2, 0]], ['0', 'custom', '0', '1']])
-  delfunction Custom
-endfunction
-
-function! s:suite.multiple()
-  function! Custom()
-    return [ ['x0', 'x1', 'x2'], ['y0', 'y1', 'y2'], ['z0', 'z1', 'z2'] ]
-  endfunction
-  let g:lightline = { 'component_expand': { 'custom': 'Custom' } }
-  call lightline#init()
-  call s:assert.equals(s:expand([['readonly', 'filename'], ['custom'], ['modified']]),
-        \ [[['readonly', 'filename'], ['x0', 'x1', 'x2', 'y0', 'y1', 'y2', 'z0', 'z1', 'z2'], ['modified']], [[0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1], [0]], ['0', '1', '2', '3']])
-  call s:assert.equals(s:expand([['readonly', 'filename', 'custom', 'modified']]),
-        \ [[['readonly', 'filename', 'x0', 'x1', 'x2', 'y0', 'y1', 'y2', 'z0', 'z1', 'z2', 'modified']], [[0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0]], ['0', '1']])
-  delfunction Custom
-endfunction
-
-function! s:suite.multiple_type()
-  function! Custom()
-    return [ ['x0', 'x1', 'x2'], ['y0', 'y1', 'y2'], ['z0', 'z1', 'z2'] ]
-  endfunction
-  let g:lightline = { 'component_expand': { 'custom': 'Custom' }, 'component_type': { 'custom': 'custom' } }
-  call lightline#init()
-  call s:assert.equals(s:expand([['readonly', 'filename'], ['custom'], ['modified']]),
-        \ [[['readonly', 'filename'], ['x0', 'x1', 'x2'], ['y0', 'y1', 'y2'], ['z0', 'z1', 'z2'], ['modified']], [[0, 0], [1, 1, 1], [1, 1, 1], [1, 1, 1], [0]], ['0', '1', 'custom', '1', '2', '3']])
-  call s:assert.equals(s:expand([['readonly', 'filename', 'custom', 'modified']]),
-        \ [[['readonly', 'filename', 'x0', 'x1', 'x2'], ['y0', 'y1', 'y2'], ['z0', 'z1', 'z2', 'modified']], [[0, 0, 1, 1, 1], [1, 1, 1], [1, 1, 1, 0]], ['0', 'custom', '0', '1']])
-  delfunction Custom
-endfunction
-
-function! s:suite.flatten()
-  function! Custom()
-    return [ 'left', 'middle', 'right' ]
-  endfunction
-  let g:lightline = { 'component_expand': { 'custom': 'Custom' } }
-  call lightline#init()
-  call s:assert.equals(s:expand([['readonly', 'filename'], ['custom'], ['modified']]),
-        \ [[['readonly', 'filename'], ['left', 'middle', 'right'], ['modified']], [[0, 0], [1, 1, 1], [0]], ['0', '1', '2', '3']])
-  call s:assert.equals(s:expand([['readonly', 'filename', 'custom', 'modified']]),
-        \ [[['readonly', 'filename', 'left', 'middle', 'right', 'modified']], [[0, 0, 1, 1, 1, 0]], ['0', '1']])
-  delfunction Custom
-endfunction
-
-function! s:suite.custom_type_flatten()
-  function! Custom()
-    return [ 'left', 'middle', 'right' ]
-  endfunction
-  let g:lightline = { 'component_expand': { 'custom': 'Custom' }, 'component_type': { 'custom': 'custom' } }
-  call lightline#init()
-  call s:assert.equals(s:expand([['readonly', 'filename'], ['custom'], ['modified']]),
-        \ [[['readonly', 'filename'], ['left'], ['middle'], ['right'], ['modified']], [[0, 0], [1], [1], [1], [0]], ['0', '1', 'custom', '1', '2', '3']])
-  call s:assert.equals(s:expand([['readonly', 'filename', 'custom', 'modified']]),
-        \ [[['readonly', 'filename', 'left'], ['middle'], ['right', 'modified']], [[0, 0, 1], [1], [1, 0]], ['0', 'custom', '0', '1']])
-  delfunction Custom
-endfunction
-
-function! s:suite.custom_string()
-  function! Custom()
-    return 'custom'
-  endfunction
-  let g:lightline = { 'component_expand': { 'custom': 'Custom' } }
-  call lightline#init()
-  call s:assert.equals(s:expand([['readonly', 'filename'], ['custom'], ['modified']]),
-        \ [[['readonly', 'filename'], ['custom'], ['modified']], [[0, 0], [1], [0]], ['0', '1', '2', '3']])
-  call s:assert.equals(s:expand([['readonly', 'filename', 'custom', 'modified']]),
-        \ [[['readonly', 'filename', 'custom', 'modified']], [[0, 0, 1, 0]], ['0', '1']])
-  delfunction Custom
-endfunction
-
-function! s:suite.custom_type_string()
-  function! Custom()
-    return 'custom'
-  endfunction
-  let g:lightline = { 'component_expand': { 'custom': 'Custom' }, 'component_type': { 'custom': 'custom' } }
-  call lightline#init()
-  call s:assert.equals(s:expand([['readonly', 'filename'], ['custom'], ['modified']]),
-        \ [[['readonly', 'filename'], ['custom'], ['modified']], [[0, 0], [1], [0]], ['0', 'custom', '2', '3']])
-  call s:assert.equals(s:expand([['readonly', 'filename', 'custom', 'modified']]),
-        \ [[['readonly', 'filename'], ['custom'], ['modified']], [[0, 0], [1], [0]], ['0', 'custom', '0', '1']])
-  delfunction Custom
-endfunction
-
-function! s:suite.custom_void_string()
-  function! Custom()
-    return ''
-  endfunction
-  let g:lightline = { 'component_expand': { 'custom': 'Custom' } }
-  call lightline#init()
-  call s:assert.equals(s:expand([['readonly', 'filename'], ['custom'], ['modified']]),
-        \ [[['readonly', 'filename'], [], ['modified']], [[0, 0], [], [0]], ['0', '1', '2', '3']])
-  call s:assert.equals(s:expand([['readonly', 'filename', 'custom', 'modified']]),
-        \ [[['readonly', 'filename', 'modified']], [[0, 0, 0]], ['0', '1']])
-  delfunction Custom
-endfunction
-
-function! s:suite.custom_type_void_string()
-  function! Custom()
-    return ''
-  endfunction
-  let g:lightline = { 'component_expand': { 'custom': 'Custom' }, 'component_type': { 'custom': 'custom' } }
-  call lightline#init()
-  call s:assert.equals(s:expand([['readonly', 'filename'], ['custom'], ['modified']]),
-        \ [[['readonly', 'filename'], [], ['modified']], [[0, 0], [], [0]], ['0', '1', '2', '3']])
-  call s:assert.equals(s:expand([['readonly', 'filename', 'custom', 'modified']]),
-        \ [[['readonly', 'filename', 'modified']], [[0, 0, 0]], ['0', '1']])
-  delfunction Custom
-endfunction
-
-function! s:suite.custom_number()
-  function! Custom()
-    return 24
-  endfunction
-  let g:lightline = { 'component_expand': { 'custom': 'Custom' } }
-  call lightline#init()
-  call s:assert.equals(s:expand([['readonly', 'filename'], ['custom'], ['modified']]),
-        \ [[['readonly', 'filename'], ['24'], ['modified']], [[0, 0], [1], [0]], ['0', '1', '2', '3']])
-  call s:assert.equals(s:expand([['readonly', 'filename', 'custom', 'modified']]),
-        \ [[['readonly', 'filename', '24', 'modified']], [[0, 0, 1, 0]], ['0', '1']])
-  delfunction Custom
-endfunction
-
-function! s:suite.custom_type_number()
-  function! Custom()
-    return 24
-  endfunction
-  let g:lightline = { 'component_expand': { 'custom': 'Custom' }, 'component_type': { 'custom': 'custom' } }
-  call lightline#init()
-  call s:assert.equals(s:expand([['readonly', 'filename'], ['custom'], ['modified']]),
-        \ [[['readonly', 'filename'], ['24'], ['modified']], [[0, 0], [1], [0]], ['0', 'custom', '2', '3']])
-  call s:assert.equals(s:expand([['readonly', 'filename', 'custom', 'modified']]),
-        \ [[['readonly', 'filename'], ['24'], ['modified']], [[0, 0], [1], [0]], ['0', 'custom', '0', '1']])
-  delfunction Custom
-endfunction
-
-function! s:suite.custom_void_string_array()
-  function! Custom()
-    return ['', '', '']
-  endfunction
-  let g:lightline = { 'component_expand': { 'custom': 'Custom' } }
-  call lightline#init()
-  call s:assert.equals(s:expand([['readonly', 'filename'], ['custom'], ['modified']]),
-        \ [[['readonly', 'filename'], [], ['modified']], [[0, 0], [], [0]], ['0', '1', '2', '3']])
-  call s:assert.equals(s:expand([['readonly', 'filename', 'custom', 'modified']]),
-        \ [[['readonly', 'filename', 'modified']], [[0, 0, 0]], ['0', '1']])
-  delfunction Custom
-endfunction
-
-function! s:suite.custom_type_void_string_array()
-  function! Custom()
-    return ['', '', '']
-  endfunction
-  let g:lightline = { 'component_expand': { 'custom': 'Custom' }, 'component_type': { 'custom': 'custom' } }
-  call lightline#init()
-  call s:assert.equals(s:expand([['readonly', 'filename'], ['custom'], ['modified']]),
-        \ [[['readonly', 'filename'], [], ['modified']], [[0, 0], [], [0]], ['0', '1', '2', '3']])
-  call s:assert.equals(s:expand([['readonly', 'filename', 'custom', 'modified']]),
-        \ [[['readonly', 'filename', 'modified']], [[0, 0, 0]], ['0', '1']])
-  delfunction Custom
-endfunction
-
-function! s:suite.custom_void_string_array_2()
-  function! Custom()
-    return [[''], [''], ['']]
-  endfunction
-  let g:lightline = { 'component_expand': { 'custom': 'Custom' } }
-  call lightline#init()
-  call s:assert.equals(s:expand([['readonly', 'filename'], ['custom'], ['modified']]),
-        \ [[['readonly', 'filename'], [], ['modified']], [[0, 0], [], [0]], ['0', '1', '2', '3']])
-  call s:assert.equals(s:expand([['readonly', 'filename', 'custom', 'modified']]),
-        \ [[['readonly', 'filename', 'modified']], [[0, 0, 0]], ['0', '1']])
-  delfunction Custom
-endfunction
-
-function! s:suite.custom_type_void_string_array_2()
-  function! Custom()
-    return [[''], [''], ['']]
-  endfunction
-  let g:lightline = { 'component_expand': { 'custom': 'Custom' }, 'component_type': { 'custom': 'custom' } }
-  call lightline#init()
-  call s:assert.equals(s:expand([['readonly', 'filename'], ['custom'], ['modified']]),
-        \ [[['readonly', 'filename'], [], ['modified']], [[0, 0], [], [0]], ['0', '1', '2', '3']])
-  call s:assert.equals(s:expand([['readonly', 'filename', 'custom', 'modified']]),
-        \ [[['readonly', 'filename', 'modified']], [[0, 0, 0]], ['0', '1']])
-  delfunction Custom
-endfunction
-
-function! s:suite.custom_void_string_array_3()
-  function! Custom()
-    return ['', 'custom', '']
-  endfunction
-  let g:lightline = { 'component_expand': { 'custom': 'Custom' } }
-  call lightline#init()
-  call s:assert.equals(s:expand([['readonly', 'filename'], ['custom'], ['modified']]),
-        \ [[['readonly', 'filename'], ['custom'], ['modified']], [[0, 0], [1], [0]], ['0', '1', '2', '3']])
-  call s:assert.equals(s:expand([['readonly', 'filename', 'custom', 'modified']]),
-        \ [[['readonly', 'filename', 'custom', 'modified']], [[0, 0, 1, 0]], ['0', '1']])
-  delfunction Custom
-endfunction
-
-function! s:suite.custom_type_void_string_array_3()
-  function! Custom()
-    return ['', 'custom', '']
-  endfunction
-  let g:lightline = { 'component_expand': { 'custom': 'Custom' }, 'component_type': { 'custom': 'custom' } }
-  call lightline#init()
-  call s:assert.equals(s:expand([['readonly', 'filename'], ['custom'], ['modified']]),
-        \ [[['readonly', 'filename'], ['custom'], ['modified']], [[0, 0], [1], [0]], ['0', 'custom', '2', '3']])
-  call s:assert.equals(s:expand([['readonly', 'filename', 'custom', 'modified']]),
-        \ [[['readonly', 'filename'], ['custom'], ['modified']], [[0, 0], [1], [0]], ['0', 'custom', '0', '1']])
-  delfunction Custom
-endfunction
-
-function! s:suite.custom_void_string_array_4()
-  function! Custom()
-    return [[''], ['custom'], ['']]
-  endfunction
-  let g:lightline = { 'component_expand': { 'custom': 'Custom' } }
-  call lightline#init()
-  call s:assert.equals(s:expand([['readonly', 'filename'], ['custom'], ['modified']]),
-        \ [[['readonly', 'filename'], ['custom'], ['modified']], [[0, 0], [1], [0]], ['0', '1', '2', '3']])
-  call s:assert.equals(s:expand([['readonly', 'filename', 'custom', 'modified']]),
-        \ [[['readonly', 'filename', 'custom', 'modified']], [[0, 0, 1, 0]], ['0', '1']])
-  delfunction Custom
-endfunction
-
-function! s:suite.custom_type_void_string_array_4()
-  function! Custom()
-    return [[''], ['custom'], ['']]
-  endfunction
-  let g:lightline = { 'component_expand': { 'custom': 'Custom' }, 'component_type': { 'custom': 'custom' } }
-  call lightline#init()
-  call s:assert.equals(s:expand([['readonly', 'filename'], ['custom'], ['modified']]),
-        \ [[['readonly', 'filename'], ['custom'], ['modified']], [[0, 0], [1], [0]], ['0', 'custom', '2', '3']])
-  call s:assert.equals(s:expand([['readonly', 'filename', 'custom', 'modified']]),
-        \ [[['readonly', 'filename'], ['custom'], ['modified']], [[0, 0], [1], [0]], ['0', 'custom', '0', '1']])
-  delfunction Custom
-endfunction
-
-function! s:suite.custom_left_nil()
-  function! Custom()
-    return [ [], ['y0', 'y1'], ['z0', 'z1'] ]
-  endfunction
-  let g:lightline = { 'component_expand': { 'custom': 'Custom' } }
-  call lightline#init()
-  call s:assert.equals(s:expand([['filename'], ['custom'], ['modified']]),
-        \ [[['filename'], ['y0', 'y1', 'z0', 'z1'], ['modified']], [[0], [1, 1, 1, 1], [0]], ['0', '1', '2', '3']])
-  call s:assert.equals(s:expand([['filename', 'custom', 'modified']]),
-        \ [[['filename', 'y0', 'y1', 'z0', 'z1', 'modified']], [[0, 1, 1, 1, 1, 0]], ['0', '1']])
-  delfunction Custom
-endfunction
-
-function! s:suite.custom_type_left_nil()
-  function! Custom()
-    return [ [], ['y0', 'y1'], ['z0', 'z1'] ]
-  endfunction
-  let g:lightline = { 'component_expand': { 'custom': 'Custom' }, 'component_type': { 'custom': 'custom' } }
-  call lightline#init()
-  call s:assert.equals(s:expand([['filename'], ['custom'], ['modified']]),
-        \ [[['filename'], ['y0', 'y1'], ['z0', 'z1'], ['modified']], [[0], [1, 1], [1, 1], [0]], ['0', 'custom', '1', '2', '3']])
-  call s:assert.equals(s:expand([['filename', 'custom', 'modified']]),
-        \ [[['filename'], ['y0', 'y1'], ['z0', 'z1', 'modified']], [[0], [1, 1], [1, 1, 0]], ['0', 'custom', '0', '1']])
-  delfunction Custom
-endfunction
-
-function! s:suite.custom_right_nil()
-  function! Custom()
-    return [ ['x0', 'x1'], ['y0', 'y1'], [] ]
-  endfunction
-  let g:lightline = { 'component_expand': { 'custom': 'Custom' } }
-  call lightline#init()
-  call s:assert.equals(s:expand([['filename'], ['custom'], ['modified']]),
-        \ [[['filename'], ['x0', 'x1', 'y0', 'y1'], ['modified']], [[0], [1, 1, 1, 1], [0]], ['0', '1', '2', '3']])
-  call s:assert.equals(s:expand([['filename', 'custom', 'modified']]),
-        \ [[['filename', 'x0', 'x1', 'y0', 'y1', 'modified']], [[0, 1, 1, 1, 1, 0]], ['0', '1']])
-  delfunction Custom
-endfunction
-
-function! s:suite.custom_type_right_nil()
-  function! Custom()
-    return [ ['x0', 'x1'], ['y0', 'y1'], [] ]
-  endfunction
-  let g:lightline = { 'component_expand': { 'custom': 'Custom' }, 'component_type': { 'custom': 'custom' } }
-  call lightline#init()
-  call s:assert.equals(s:expand([['filename'], ['custom'], ['modified']]),
-        \ [[['filename'], ['x0', 'x1'], ['y0', 'y1'], ['modified']], [[0], [1, 1], [1, 1], [0]], ['0', '1', 'custom', '2', '3']])
-  call s:assert.equals(s:expand([['filename', 'custom', 'modified']]),
-        \ [[['filename', 'x0', 'x1'], ['y0', 'y1'], ['modified']], [[0, 1, 1], [1, 1], [0]], ['0', 'custom', '0', '1']])
-  delfunction Custom
-endfunction
-
-function! s:suite.custom_one()
-  function! Custom()
-    return [ 'left' ]
-  endfunction
-  let g:lightline = { 'component_expand': { 'custom': 'Custom' } }
-  call lightline#init()
-  call s:assert.equals(s:expand([['readonly', 'filename'], ['custom'], ['modified']]),
-        \ [[['readonly', 'filename'], ['left'], ['modified']], [[0, 0], [1], [0]], ['0', '1', '2', '3']])
-  call s:assert.equals(s:expand([['readonly', 'filename', 'custom', 'modified']]),
-        \ [[['readonly', 'filename', 'left', 'modified']], [[0, 0, 1, 0]], ['0', '1']])
-  delfunction Custom
-endfunction
-
-function! s:suite.custom_type_one()
-  function! Custom()
-    return [ 'left' ]
-  endfunction
-  let g:lightline = { 'component_expand': { 'custom': 'Custom' }, 'component_type': { 'custom': 'custom' } }
-  call lightline#init()
-  call s:assert.equals(s:expand([['readonly', 'filename'], ['custom'], ['modified']]),
-        \ [[['readonly', 'filename'], ['left'], ['modified']], [[0, 0], [1], [0]], ['0', '1', '2', '3']])
-  call s:assert.equals(s:expand([['readonly', 'filename', 'custom', 'modified']]),
-        \ [[['readonly', 'filename', 'left', 'modified']], [[0, 0, 1, 0]], ['0', '1']])
-  delfunction Custom
-endfunction
-
-function! s:suite.custom_two()
-  function! Custom()
-    return [ 'left', 'middle']
-  endfunction
-  let g:lightline = { 'component_expand': { 'custom': 'Custom' } }
-  call lightline#init()
-  call s:assert.equals(s:expand([['readonly', 'filename'], ['custom'], ['modified']]),
-        \ [[['readonly', 'filename'], ['left', 'middle'], ['modified']], [[0, 0], [1, 1], [0]], ['0', '1', '2', '3']])
-  call s:assert.equals(s:expand([['readonly', 'filename', 'custom', 'modified']]),
-        \ [[['readonly', 'filename', 'left', 'middle', 'modified']], [[0, 0, 1, 1, 0]], ['0', '1']])
-  delfunction Custom
-endfunction
-
-function! s:suite.custom_type_two()
-  function! Custom()
-    return [ 'left', 'middle' ]
-  endfunction
-  let g:lightline = { 'component_expand': { 'custom': 'Custom' }, 'component_type': { 'custom': 'custom' } }
-  call lightline#init()
-  call s:assert.equals(s:expand([['readonly', 'filename'], ['custom'], ['modified']]),
-        \ [[['readonly', 'filename'], ['left'], ['middle'], ['modified']], [[0, 0], [1], [1], [0]], ['0', '1', 'custom', '2', '3']])
-  call s:assert.equals(s:expand([['readonly', 'filename', 'custom', 'modified']]),
-        \ [[['readonly', 'filename', 'left'], ['middle'], ['modified']], [[0, 0, 1], [1], [0]], ['0', 'custom', '0', '1']])
-  delfunction Custom
-endfunction
-
-function! s:suite.custom_mixed()
-  function! Custom()
-    return ['left', { 'custom': 24 }, [function('tr')]]
-  endfunction
-  let g:lightline = { 'component_expand': { 'custom': 'Custom' } }
-  call lightline#init()
-  call s:assert.equals(s:expand([['readonly', 'filename'], ['custom'], ['modified']]),
-        \ [[['readonly', 'filename'], ['left', '{''custom'': 24}', 'function(''tr'')'], ['modified']], [[0, 0], [1, 1, 1], [0]], ['0', '1', '2', '3']])
-  call s:assert.equals(s:expand([['readonly', 'filename', 'custom', 'modified']]),
-        \ [[['readonly', 'filename', 'left', '{''custom'': 24}', 'function(''tr'')', 'modified']], [[0, 0, 1, 1, 1, 0]], ['0', '1']])
-  delfunction Custom
-endfunction
-
-function! s:suite.custom_type_mixed()
-  function! Custom()
-    return ['left', { 'custom': 24 }, [function('tr')]]
-  endfunction
-  let g:lightline = { 'component_expand': { 'custom': 'Custom' }, 'component_type': { 'custom': 'custom' } }
-  call lightline#init()
-  call s:assert.equals(s:expand([['readonly', 'filename'], ['custom'], ['modified']]),
-        \ [[['readonly', 'filename'], ['left'], ['{''custom'': 24}'], ['function(''tr'')'], ['modified']], [[0, 0], [1], [1], [1], [0]], ['0', '1', 'custom', '1', '2', '3']])
-  call s:assert.equals(s:expand([['readonly', 'filename', 'custom', 'modified']]),
-        \ [[['readonly', 'filename', 'left'], ['{''custom'': 24}'], ['function(''tr'')', 'modified']], [[0, 0, 1], [1], [1, 0]], ['0', 'custom', '0', '1']])
-  delfunction Custom
-endfunction
-
-function! s:suite.custom_mixed_2()
-  function! Custom()
-    return [['left', ''], ['', { 'custom': 24 }, ''], [[function('tr')], '']]
-  endfunction
-  let g:lightline = { 'component_expand': { 'custom': 'Custom' } }
-  call lightline#init()
-  call s:assert.equals(s:expand([['readonly', 'filename'], ['custom'], ['modified']]),
-        \ [[['readonly', 'filename'], ['left', '{''custom'': 24}', '[function(''tr'')]'], ['modified']], [[0, 0], [1, 1, 1], [0]], ['0', '1', '2', '3']])
-  call s:assert.equals(s:expand([['readonly', 'filename', 'custom', 'modified']]),
-        \ [[['readonly', 'filename', 'left', '{''custom'': 24}', '[function(''tr'')]', 'modified']], [[0, 0, 1, 1, 1, 0]], ['0', '1']])
-  delfunction Custom
-endfunction
-
-function! s:suite.custom_type_mixed_2()
-  function! Custom()
-    return [['left', ''], ['', { 'custom': 24 }, ''], [[function('tr')], '']]
-  endfunction
-  let g:lightline = { 'component_expand': { 'custom': 'Custom' }, 'component_type': { 'custom': 'custom' } }
-  call lightline#init()
-  call s:assert.equals(s:expand([['readonly', 'filename'], ['custom'], ['modified']]),
-        \ [[['readonly', 'filename'], ['left'], ['{''custom'': 24}'], ['[function(''tr'')]'], ['modified']], [[0, 0], [1], [1], [1], [0]], ['0', '1', 'custom', '1', '2', '3']])
-  call s:assert.equals(s:expand([['readonly', 'filename', 'custom', 'modified']]),
-        \ [[['readonly', 'filename', 'left'], ['{''custom'': 24}'], ['[function(''tr'')]', 'modified']], [[0, 0, 1], [1], [1, 0]], ['0', 'custom', '0', '1']])
-  delfunction Custom
-endfunction
-
-function! s:suite.custom_error()
-  function! Custom()
-    throw 'error'
-    return 'custom'
-  endfunction
-  let g:lightline = { 'component_expand': { 'custom': 'Custom' } }
-  call lightline#init()
-  call s:assert.equals(s:expand([['readonly', 'filename'], ['custom'], ['modified']]),
-        \ [[['readonly', 'filename'], [], ['modified']], [[0, 0], [], [0]], ['0', '1', '2', '3']])
-  call s:assert.equals(s:expand([['readonly', 'filename', 'custom', 'modified']]),
-        \ [[['readonly', 'filename', 'modified']], [[0, 0, 0]], ['0', '1']])
-  delfunction Custom
-endfunction
-
-function! s:suite.custom_type_error()
-  function! Custom()
-    throw 'error'
-    return 'custom'
-  endfunction
-  let g:lightline = { 'component_expand': { 'custom': 'Custom' }, 'component_type': { 'custom': 'custom' } }
-  call lightline#init()
-  call s:assert.equals(s:expand([['readonly', 'filename'], ['custom'], ['modified']]),
-        \ [[['readonly', 'filename'], [], ['modified']], [[0, 0], [], [0]], ['0', '1', '2', '3']])
-  call s:assert.equals(s:expand([['readonly', 'filename', 'custom', 'modified']]),
-        \ [[['readonly', 'filename', 'modified']], [[0, 0, 0]], ['0', '1']])
-  delfunction Custom
-endfunction
-
-function! s:suite.notfound()
-  let g:lightline = { 'component_expand': { 'custom': 'NotFound' } }
-  call lightline#init()
-  call s:assert.equals(s:expand([['readonly', 'filename'], ['custom'], ['modified']]),
-        \ [[['readonly', 'filename'], [], ['modified']], [[0, 0], [], [0]], ['0', '1', '2', '3']])
-  call s:assert.equals(s:expand([['readonly', 'filename', 'custom', 'modified']]),
-        \ [[['readonly', 'filename', 'modified']], [[0, 0, 0]], ['0', '1']])
-endfunction
-
-function! s:suite.custom_type_notfound()
-  let g:lightline = { 'component_expand': { 'custom': 'NotFound' }, 'component_type': { 'custom': 'custom' } }
-  call lightline#init()
-  call s:assert.equals(s:expand([['readonly', 'filename'], ['custom'], ['modified']]),
-        \ [[['readonly', 'filename'], [], ['modified']], [[0, 0], [], [0]], ['0', '1', '2', '3']])
-  call s:assert.equals(s:expand([['readonly', 'filename', 'custom', 'modified']]),
-        \ [[['readonly', 'filename', 'modified']], [[0, 0, 0]], ['0', '1']])
-endfunction
-
-function! s:suite.duplicated_string()
-  function! Custom()
-    return 'custom'
-  endfunction
-  function! Modified()
-    return ''
-  endfunction
-  let g:lightline = { 'component_expand': { 'custom': 'Custom', 'modified': 'Modified' } }
-  call lightline#init()
-  call s:assert.equals(s:expand([['filename'], ['custom', 'custom'], ['modified']]),
-        \ [[['filename'], ['custom', 'custom'], []], [[0], [1, 1], []], ['0', '1', '2', '3']])
-  call s:assert.equals(s:expand([['filename', 'custom', 'custom', 'modified']]),
-        \ [[['filename', 'custom', 'custom']], [[0, 1, 1]], ['0', '1']])
-  delfunction Custom
-  delfunction Modified
-endfunction
-
-function! s:suite.duplicated_left_nil()
-  function! Custom()
-    return [ [], ['y0', 'y1'], ['z0', 'z1'] ]
-  endfunction
-  let g:lightline = { 'component_expand': { 'custom': 'Custom' } }
-  call lightline#init()
-  call s:assert.equals(s:expand([['filename'], ['custom', 'custom'], ['modified']]),
-        \ [[['filename'], ['y0', 'y1', 'z0', 'z1', 'y0', 'y1', 'z0', 'z1'], ['modified']], [[0], [1, 1, 1, 1, 1, 1, 1, 1], [0]], ['0', '1', '2', '3']])
-  call s:assert.equals(s:expand([['filename', 'custom', 'custom', 'modified']]),
-        \ [[['filename', 'y0', 'y1', 'z0', 'z1', 'y0', 'y1', 'z0', 'z1', 'modified']], [[0, 1, 1, 1, 1, 1, 1, 1, 1, 0]], ['0', '1']])
-  delfunction Custom
-endfunction
-
-function! s:suite.duplicated_type_left_nil()
-  function! Custom()
-    return [ [], ['y0', 'y1'], ['z0', 'z1'] ]
-  endfunction
-  let g:lightline = { 'component_expand': { 'custom': 'Custom' }, 'component_type': { 'custom': 'custom' } }
-  call lightline#init()
-  call s:assert.equals(s:expand([['filename'], ['custom', 'custom'], ['modified']]),
-        \ [[['filename'], ['y0', 'y1'], ['z0', 'z1'], ['y0', 'y1'], ['z0', 'z1'], ['modified']], [[0], [1, 1], [1, 1], [1, 1], [1, 1], [0]], ['0', 'custom', '1', 'custom', '1', '2', '3']])
-  call s:assert.equals(s:expand([['filename', 'custom', 'custom', 'modified']]),
-        \ [[['filename'], ['y0', 'y1'], ['z0', 'z1'], ['y0', 'y1'], ['z0', 'z1', 'modified']], [[0], [1, 1], [1, 1], [1, 1], [1, 1, 0]], ['0', 'custom', '0', 'custom', '0', '1']])
-  delfunction Custom
-endfunction
-
-function! s:suite.duplicated_right_nil()
-  function! Custom()
-    return [ ['x0', 'x1'], ['y0', 'y1'], [] ]
-  endfunction
-  let g:lightline = { 'component_expand': { 'custom': 'Custom' } }
-  call lightline#init()
-  call s:assert.equals(s:expand([['filename'], ['custom', 'custom'], ['modified']]),
-        \ [[['filename'], ['x0', 'x1', 'y0', 'y1', 'x0', 'x1', 'y0', 'y1'], ['modified']], [[0], [1, 1, 1, 1, 1, 1, 1, 1], [0]], ['0', '1', '2', '3']])
-  call s:assert.equals(s:expand([['filename', 'custom', 'custom', 'modified']]),
-        \ [[['filename', 'x0', 'x1', 'y0', 'y1', 'x0', 'x1', 'y0', 'y1', 'modified']], [[0, 1, 1, 1, 1, 1, 1, 1, 1, 0]], ['0', '1']])
-  delfunction Custom
-endfunction
-
-function! s:suite.duplicated_type_right_nil()
-  function! Custom()
-    return [ ['x0', 'x1'], ['y0', 'y1'], [] ]
-  endfunction
-  let g:lightline = { 'component_expand': { 'custom': 'Custom' }, 'component_type': { 'custom': 'custom' } }
-  call lightline#init()
-  call s:assert.equals(s:expand([['filename'], ['custom', 'custom'], ['modified']]),
-        \ [[['filename'], ['x0', 'x1'], ['y0', 'y1'], ['x0', 'x1'], ['y0', 'y1'], ['modified']], [[0], [1, 1], [1, 1], [1, 1], [1, 1], [0]], ['0', '1', 'custom', '1', 'custom', '2', '3']])
-  call s:assert.equals(s:expand([['filename', 'custom', 'custom', 'modified']]),
-        \ [[['filename', 'x0', 'x1'], ['y0', 'y1'], ['x0', 'x1'], ['y0', 'y1'], ['modified']], [[0, 1, 1], [1, 1], [1, 1], [1, 1], [0]], ['0', 'custom', '0', 'custom', '0', '1']])
-  delfunction Custom
-endfunction
-
-function! s:suite.duplicated_both_nil()
-  function! Custom()
-    return [ [], ['y0', 'y1'], [] ]
-  endfunction
-  let g:lightline = { 'component_expand': { 'custom': 'Custom' } }
-  call lightline#init()
-  call s:assert.equals(s:expand([['filename'], ['custom', 'custom'], ['modified']]),
-        \ [[['filename'], ['y0', 'y1', 'y0', 'y1'], ['modified']], [[0], [1, 1, 1, 1], [0]], ['0', '1', '2', '3']])
-  call s:assert.equals(s:expand([['filename', 'custom', 'custom', 'modified']]),
-        \ [[['filename', 'y0', 'y1', 'y0', 'y1', 'modified']], [[0, 1, 1, 1, 1, 0]], ['0', '1']])
-  delfunction Custom
-endfunction
-
-function! s:suite.duplicated_type_both_nil()
-  function! Custom()
-    return [ [], ['y0', 'y1'], [] ]
-  endfunction
-  let g:lightline = { 'component_expand': { 'custom': 'Custom' }, 'component_type': { 'custom': 'custom' } }
-  call lightline#init()
-  call s:assert.equals(s:expand([['filename'], ['custom', 'custom'], ['modified']]),
-        \ [[['filename'], ['y0', 'y1', 'y0', 'y1'], ['modified']], [[0], [1, 1, 1, 1], [0]], ['0', 'custom', '2', '3']])
-  call s:assert.equals(s:expand([['filename', 'custom', 'custom', 'modified']]),
-        \ [[['filename'], ['y0', 'y1', 'y0', 'y1'], ['modified']], [[0], [1, 1, 1, 1], [0]], ['0', 'custom', '0', '1']])
-  delfunction Custom
-endfunction
-
-function! s:suite.duplicated_both_nil_left_most()
-  function! Custom()
-    return [ [], ['y0', 'y1'], [] ]
-  endfunction
-  let g:lightline = { 'component_expand': { 'custom': 'Custom' } }
-  call lightline#init()
-  call s:assert.equals(s:expand([['custom', 'custom'], ['modified']]),
-        \ [[['y0', 'y1', 'y0', 'y1'], ['modified']], [[1, 1, 1, 1], [0]], ['0', '1', '2']])
-  call s:assert.equals(s:expand([['custom', 'custom', 'modified']]),
-        \ [[['y0', 'y1', 'y0', 'y1', 'modified']], [[1, 1, 1, 1, 0]], ['0', '1']])
-  delfunction Custom
-endfunction
-
-function! s:suite.duplicated_type_both_nil_left_most()
-  function! Custom()
-    return [ [], ['y0', 'y1'], [] ]
-  endfunction
-  let g:lightline = { 'component_expand': { 'custom': 'Custom' }, 'component_type': { 'custom': 'custom' } }
-  call lightline#init()
-  call s:assert.equals(s:expand([['custom', 'custom'], ['modified']]),
-        \ [[['y0', 'y1', 'y0', 'y1'], ['modified']], [[1, 1, 1, 1], [0]], ['custom', '1', '2']])
-  call s:assert.equals(s:expand([['custom', 'custom', 'modified']]),
-        \ [[['y0', 'y1', 'y0', 'y1'], ['modified']], [[1, 1, 1, 1], [0]], ['custom', '0', '1']])
-  delfunction Custom
-endfunction
-
-function! s:suite.duplicated_both_nil_right_most()
-  function! Custom()
-    return [ [], ['y0', 'y1'], [] ]
-  endfunction
-  let g:lightline = { 'component_expand': { 'custom': 'Custom' } }
-  call lightline#init()
-  call s:assert.equals(s:expand([['filename'], ['custom', 'custom']]),
-        \ [[['filename'], ['y0', 'y1', 'y0', 'y1']], [[0], [1, 1, 1, 1]], ['0', '1', '2']])
-  call s:assert.equals(s:expand([['filename', 'custom', 'custom']]),
-        \ [[['filename', 'y0', 'y1', 'y0', 'y1']], [[0, 1, 1, 1, 1]], ['0', '1']])
-  delfunction Custom
-endfunction
-
-function! s:suite.duplicated_type_both_nil_right_most()
-  function! Custom()
-    return [ [], ['y0', 'y1'], [] ]
-  endfunction
-  let g:lightline = { 'component_expand': { 'custom': 'Custom' }, 'component_type': { 'custom': 'custom' } }
-  call lightline#init()
-  call s:assert.equals(s:expand([['filename'], ['custom', 'custom']]),
-        \ [[['filename'], ['y0', 'y1', 'y0', 'y1']], [[0], [1, 1, 1, 1]], ['0', 'custom', '2']])
-  call s:assert.equals(s:expand([['filename', 'custom', 'custom']]),
-        \ [[['filename'], ['y0', 'y1', 'y0', 'y1']], [[0], [1, 1, 1, 1]], ['0', 'custom', '1']])
-  delfunction Custom
-endfunction
-
-function! s:suite.dictionary_function()
-  let g:lightline = { 'component_expand': { 'custom': 'g:lightline.Custom' } }
-  function! g:lightline.Custom()
-    return [ ['left'], ['middle'], ['right'] ]
-  endfunction
-  call lightline#init()
-  call s:assert.equals(s:expand([['readonly', 'filename'], ['custom'], ['modified']]),
-        \ [[['readonly', 'filename'], ['left', 'middle', 'right'], ['modified']], [[0, 0], [1, 1, 1], [0]], ['0', '1', '2', '3']])
-  call s:assert.equals(s:expand([['readonly', 'filename', 'custom', 'modified']]),
-        \ [[['readonly', 'filename', 'left', 'middle', 'right', 'modified']], [[0, 0, 1, 1, 1, 0]], ['0', '1']])
-endfunction
diff --git a/sources_non_forked/lightline.vim/test/highlight.vim b/sources_non_forked/lightline.vim/test/highlight.vim
deleted file mode 100644
index 0e9e656..0000000
--- a/sources_non_forked/lightline.vim/test/highlight.vim
+++ /dev/null
@@ -1,171 +0,0 @@
-let s:suite = themis#suite('highlight')
-let s:assert = themis#helper('assert')
-
-function! s:suite.before_each()
-  hi clear
-endfunction
-
-function! s:hi(name)
-  redir => hi
-    silent! exec 'hi' a:name
-  redir END
-  return substitute(join(split(hi, "\n"), ''), ' \+', ' ', 'g')
-endfunction
-
-function! s:pattern(xs, ...) abort
-  let ys = a:0 ? a:xs[1:] : a:xs
-  let zs = get(a:000, 0, a:xs)
-  return 'ctermfg=' . ys[2] . ' ctermbg=' . zs[3] . '.*guifg=' . ys[0] . ' guibg=' . zs[1]
-endfunction
-
-function! s:suite.highlight()
-  let g:lightline = {}
-  call lightline#init()
-  call lightline#colorscheme()
-  let palette = lightline#palette()
-  call s:assert.match(s:hi('LightlineLeft_normal_0'), s:pattern(palette.normal.left[0]))
-  call s:assert.match(s:hi('LightlineLeft_normal_1'), s:pattern(palette.normal.left[1]))
-  call s:assert.match(s:hi('LightlineLeft_normal_2'), 'E411: highlight group not found\|cleared')
-  call s:assert.match(s:hi('LightlineRight_normal_0'), s:pattern(palette.normal.right[0]))
-  call s:assert.match(s:hi('LightlineRight_normal_1'), s:pattern(palette.normal.right[1]))
-  call s:assert.match(s:hi('LightlineRight_normal_2'), s:pattern(palette.normal.right[2]))
-  call s:assert.match(s:hi('LightlineRight_normal_3'), 'E411: highlight group not found\|cleared')
-  call s:assert.match(s:hi('LightlineMiddle_normal'), s:pattern(palette.normal.middle[0]))
-endfunction
-
-function! s:suite.insert()
-  let g:lightline = {}
-  call lightline#init()
-  call lightline#colorscheme()
-  call lightline#highlight('insert')
-  let palette = lightline#palette()
-  call s:assert.match(s:hi('LightlineLeft_insert_0'), s:pattern(palette.insert.left[0]))
-  call s:assert.match(s:hi('LightlineLeft_insert_1'), s:pattern(palette.insert.left[1]))
-  call s:assert.match(s:hi('LightlineLeft_insert_2'), 'E411: highlight group not found\|cleared')
-  call s:assert.match(s:hi('LightlineRight_insert_0'), s:pattern(palette.insert.right[0]))
-  call s:assert.match(s:hi('LightlineRight_insert_1'), s:pattern(palette.insert.right[1]))
-  call s:assert.match(s:hi('LightlineRight_insert_2'), s:pattern(palette.insert.right[2]))
-  call s:assert.match(s:hi('LightlineRight_insert_3'), 'E411: highlight group not found\|cleared')
-  call s:assert.match(s:hi('LightlineMiddle_insert'), s:pattern(palette.insert.middle[0]))
-endfunction
-
-
-function! s:suite.visual()
-  let g:lightline = {}
-  call lightline#init()
-  call lightline#colorscheme()
-  call lightline#highlight('visual')
-  let palette = lightline#palette()
-  call s:assert.match(s:hi('LightlineLeft_visual_0'), s:pattern(palette.visual.left[0]))
-  call s:assert.match(s:hi('LightlineLeft_visual_1'), s:pattern(palette.visual.left[1]))
-  call s:assert.match(s:hi('LightlineLeft_visual_2'), 'E411: highlight group not found\|cleared')
-  call s:assert.match(s:hi('LightlineRight_visual_0'), s:pattern(palette.normal.right[0]))
-  call s:assert.match(s:hi('LightlineRight_visual_1'), s:pattern(palette.normal.right[1]))
-  call s:assert.match(s:hi('LightlineRight_visual_2'), s:pattern(palette.normal.right[2]))
-  call s:assert.match(s:hi('LightlineRight_visual_3'), 'E411: highlight group not found\|cleared')
-  call s:assert.match(s:hi('LightlineMiddle_normal'), s:pattern(palette.normal.middle[0]))
-endfunction
-
-function! s:suite.replace()
-  let g:lightline = {}
-  call lightline#init()
-  call lightline#colorscheme()
-  call lightline#highlight('replace')
-  let palette = lightline#palette()
-  call s:assert.match(s:hi('LightlineLeft_replace_0'), s:pattern(palette.replace.left[0]))
-  call s:assert.match(s:hi('LightlineLeft_replace_1'), s:pattern(palette.replace.left[1]))
-  call s:assert.match(s:hi('LightlineLeft_replace_2'), 'E411: highlight group not found\|cleared')
-  call s:assert.match(s:hi('LightlineRight_replace_0'), s:pattern(palette.replace.right[0]))
-  call s:assert.match(s:hi('LightlineRight_replace_1'), s:pattern(palette.replace.right[1]))
-  call s:assert.match(s:hi('LightlineRight_replace_2'), s:pattern(palette.replace.right[2]))
-  call s:assert.match(s:hi('LightlineRight_replace_3'), 'E411: highlight group not found\|cleared')
-  call s:assert.match(s:hi('LightlineMiddle_replace'), s:pattern(palette.replace.middle[0]))
-endfunction
-
-function! s:suite.left_right()
-  let g:lightline = {
-        \   'active': {
-        \     'left': [ [ 'mode', 'paste' ], [ 'readonly' ], [ 'filename' ], [ 'modified' ] ],
-        \     'right': [ [ 'lineinfo' ], [ 'percent' ], [ 'fileformat' ], [ 'fileencoding' ], [ 'filetype' ] ]
-        \   },
-        \ }
-  call lightline#init()
-  call lightline#colorscheme()
-  let palette = lightline#palette()
-  call s:assert.match(s:hi('LightlineLeft_normal_0'), s:pattern(palette.normal.left[0]))
-  call s:assert.match(s:hi('LightlineLeft_normal_1'), s:pattern(palette.normal.left[1]))
-  call s:assert.match(s:hi('LightlineLeft_normal_2'), s:pattern(palette.normal.middle[0]))
-  call s:assert.match(s:hi('LightlineLeft_normal_3'), s:pattern(palette.normal.middle[0]))
-  call s:assert.match(s:hi('LightlineLeft_normal_4'), 'E411: highlight group not found\|cleared')
-  call s:assert.match(s:hi('LightlineRight_normal_0'), s:pattern(palette.normal.right[0]))
-  call s:assert.match(s:hi('LightlineRight_normal_1'), s:pattern(palette.normal.right[1]))
-  call s:assert.match(s:hi('LightlineRight_normal_2'), s:pattern(palette.normal.right[2]))
-  call s:assert.match(s:hi('LightlineRight_normal_3'), s:pattern(palette.normal.middle[0]))
-  call s:assert.match(s:hi('LightlineRight_normal_4'), s:pattern(palette.normal.middle[0]))
-  call s:assert.match(s:hi('LightlineRight_normal_5'), 'E411: highlight group not found\|cleared')
-  call s:assert.match(s:hi('LightlineMiddle_normal'), s:pattern(palette.normal.middle[0]))
-endfunction
-
-function! s:suite.no_components()
-  let g:lightline = {
-        \   'active': {
-        \     'left': [],
-        \     'right': []
-        \   },
-        \   'inactive': {
-        \     'left': [],
-        \     'right': []
-        \   },
-        \ }
-  call lightline#init()
-  call lightline#colorscheme()
-  let palette = lightline#palette()
-  call s:assert.match(s:hi('LightlineLeft_normal_0'), s:pattern(palette.normal.left[0]))
-  call s:assert.match(s:hi('LightlineLeft_normal_1'), 'E411: highlight group not found\|cleared')
-  call s:assert.match(s:hi('LightlineRight_normal_0'), s:pattern(palette.normal.right[0]))
-  call s:assert.match(s:hi('LightlineRight_normal_1'), 'E411: highlight group not found\|cleared')
-  call s:assert.match(s:hi('LightlineMiddle_normal'), s:pattern(palette.normal.middle[0]))
-endfunction
-
-function! s:suite.subseparator()
-  let g:lightline = {
-        \   'active': {
-        \     'left': [ [ 'mode', 'paste' ], [ 'readonly' ], [ 'filename' ], [ 'modified' ] ],
-        \     'right': [ [ 'lineinfo' ], [ 'percent' ], [ 'fileformat' ], [ 'fileencoding' ], [ 'filetype' ] ]
-        \   },
-        \ }
-  call lightline#init()
-  call lightline#colorscheme()
-  let palette = lightline#palette()
-  for i in range(4)
-    for j in range(5)
-      if i + 1 == j
-        call s:assert.match(s:hi(printf('LightlineLeft_normal_%s_%s', i, j)), s:pattern(get(palette.normal.left, i, palette.normal.middle[0]), get(palette.normal.left, j, palette.normal.middle[0])))
-      else
-        call s:assert.match(s:hi(printf('LightlineLeft_normal_%s_%s', i, j)), 'E411: highlight group not found\|cleared')
-      endif
-    endfor
-  endfor
-endfunction
-
-function! s:suite.component_type()
-  let g:lightline = { 'component_type': { 'error': 'error', 'warning': 'warning' } }
-  call lightline#init()
-  call lightline#colorscheme()
-  let palette = lightline#palette()
-  for type in ['error', 'warning']
-    call s:assert.match(s:hi(printf('LightlineLeft_normal_%s', type)), s:pattern(palette.normal[type][0]))
-    call s:assert.match(s:hi(printf('LightlineLeft_normal_0_%s', type)), s:pattern(palette.normal.left[0], palette.normal[type][0]))
-    call s:assert.match(s:hi(printf('LightlineLeft_normal_1_%s', type)), s:pattern(palette.normal.left[1], palette.normal[type][0]))
-    call s:assert.match(s:hi(printf('LightlineLeft_normal_2_%s', type)), 'E411: highlight group not found\|cleared')
-    call s:assert.match(s:hi(printf('LightlineLeft_normal_%s_0', type)), s:pattern(palette.normal[type][0], palette.normal.left[0]))
-    call s:assert.match(s:hi(printf('LightlineLeft_normal_%s_1', type)), s:pattern(palette.normal[type][0], palette.normal.left[1]))
-    call s:assert.match(s:hi(printf('LightlineLeft_normal_%s_2', type)), s:pattern(palette.normal[type][0], palette.normal.middle[0]))
-    call s:assert.match(s:hi(printf('LightlineLeft_normal_%s_3', type)), 'E411: highlight group not found\|cleared')
-  endfor
-  for type1 in ['error', 'warning']
-    for type2 in ['error', 'warning']
-      call s:assert.match(s:hi(printf('LightlineLeft_normal_%s_%s', type1, type2)), s:pattern(palette.normal[type1][0], palette.normal[type2][0]))
-    endfor
-  endfor
-endfunction
diff --git a/sources_non_forked/lightline.vim/test/link.vim b/sources_non_forked/lightline.vim/test/link.vim
deleted file mode 100644
index 98e409e..0000000
--- a/sources_non_forked/lightline.vim/test/link.vim
+++ /dev/null
@@ -1,143 +0,0 @@
-let s:suite = themis#suite('link')
-let s:assert = themis#helper('assert')
-
-function! s:suite.before_each()
-  call s:clear()
-  let g:lightline = {}
-  call lightline#init()
-  call lightline#colorscheme()
-endfunction
-
-function! s:clear()
-  hi clear
-  redir => hi
-    silent! hi
-  redir END
-  for line in split(hi, '\n')
-    if match(line, 'links to') > 0
-      exec 'hi link' matchstr(line, '^\S*') 'NONE'
-    endif
-  endfor
-endfunction
-
-function! s:hi(name)
-  redir => hi
-    silent! exec 'hi' a:name
-  redir END
-  return substitute(join(split(hi, "\n"), ''), ' \+', ' ', 'g')
-endfunction
-
-function! s:suite.link()
-  call lightline#link()
-  call s:assert.match(s:hi('LightlineLeft_active_0'), 'LightlineLeft_normal_0')
-  call s:assert.match(s:hi('LightlineLeft_active_1'), 'LightlineLeft_normal_1')
-  call s:assert.match(s:hi('LightlineLeft_active_2'), 'E411: highlight group not found\|cleared')
-  call s:assert.match(s:hi('LightlineRight_active_0'), 'LightlineRight_normal_0')
-  call s:assert.match(s:hi('LightlineRight_active_1'), 'LightlineRight_normal_1')
-  call s:assert.match(s:hi('LightlineRight_active_2'), 'LightlineRight_normal_2')
-  call s:assert.match(s:hi('LightlineRight_active_3'), 'E411: highlight group not found\|cleared')
-  call s:assert.match(s:hi('LightlineMiddle_active'), 'LightlineMiddle_normal')
-endfunction
-
-function! s:suite.insert()
-  call lightline#link('i')
-  call s:assert.match(s:hi('LightlineLeft_active_0'), 'LightlineLeft_insert_0')
-  call s:assert.match(s:hi('LightlineLeft_active_1'), 'LightlineLeft_insert_1')
-  call s:assert.match(s:hi('LightlineLeft_active_2'), 'E411: highlight group not found\|cleared')
-  call s:assert.match(s:hi('LightlineRight_active_0'), 'LightlineRight_insert_0')
-  call s:assert.match(s:hi('LightlineRight_active_1'), 'LightlineRight_insert_1')
-  call s:assert.match(s:hi('LightlineRight_active_2'), 'LightlineRight_insert_2')
-  call s:assert.match(s:hi('LightlineRight_active_3'), 'E411: highlight group not found\|cleared')
-  call s:assert.match(s:hi('LightlineMiddle_active'), 'LightlineMiddle_insert')
-endfunction
-
-function! s:suite.visual()
-  call lightline#link('v')
-  call s:assert.match(s:hi('LightlineLeft_active_0'), 'LightlineLeft_visual_0')
-  call s:assert.match(s:hi('LightlineLeft_active_1'), 'LightlineLeft_visual_1')
-  call s:assert.match(s:hi('LightlineLeft_active_2'), 'E411: highlight group not found\|cleared')
-  call s:assert.match(s:hi('LightlineRight_active_0'), 'LightlineRight_visual_0')
-  call s:assert.match(s:hi('LightlineRight_active_1'), 'LightlineRight_visual_1')
-  call s:assert.match(s:hi('LightlineRight_active_2'), 'LightlineRight_visual_2')
-  call s:assert.match(s:hi('LightlineRight_active_3'), 'E411: highlight group not found\|cleared')
-  call s:assert.match(s:hi('LightlineMiddle_active'), 'LightlineMiddle_visual')
-endfunction
-
-function! s:suite.replace()
-  call lightline#link('R')
-  call s:assert.match(s:hi('LightlineLeft_active_0'), 'LightlineLeft_replace_0')
-  call s:assert.match(s:hi('LightlineLeft_active_1'), 'LightlineLeft_replace_1')
-  call s:assert.match(s:hi('LightlineLeft_active_2'), 'E411: highlight group not found\|cleared')
-  call s:assert.match(s:hi('LightlineRight_active_0'), 'LightlineRight_replace_0')
-  call s:assert.match(s:hi('LightlineRight_active_1'), 'LightlineRight_replace_1')
-  call s:assert.match(s:hi('LightlineRight_active_2'), 'LightlineRight_replace_2')
-  call s:assert.match(s:hi('LightlineRight_active_3'), 'E411: highlight group not found\|cleared')
-  call s:assert.match(s:hi('LightlineMiddle_active'), 'LightlineMiddle_replace')
-endfunction
-
-function! s:suite.left_right()
-  let g:lightline = {
-        \   'active': {
-        \     'left': [ [ 'mode', 'paste' ], [ 'readonly' ], [ 'filename' ], [ 'modified' ] ],
-        \     'right': [ [ 'lineinfo' ], [ 'percent' ], [ 'fileformat' ], [ 'fileencoding' ], [ 'filetype' ] ]
-        \   },
-        \ }
-  call lightline#init()
-  call lightline#colorscheme()
-  call lightline#link()
-  call s:assert.match(s:hi('LightlineLeft_active_0'), 'LightlineLeft_normal_0')
-  call s:assert.match(s:hi('LightlineLeft_active_1'), 'LightlineLeft_normal_1')
-  call s:assert.match(s:hi('LightlineLeft_active_2'), 'LightlineLeft_normal_2')
-  call s:assert.match(s:hi('LightlineLeft_active_3'), 'LightlineLeft_normal_3')
-  call s:assert.match(s:hi('LightlineLeft_active_4'), 'E411: highlight group not found')
-  call s:assert.match(s:hi('LightlineRight_active_0'), 'LightlineRight_normal_0')
-  call s:assert.match(s:hi('LightlineRight_active_1'), 'LightlineRight_normal_1')
-  call s:assert.match(s:hi('LightlineRight_active_2'), 'LightlineRight_normal_2')
-  call s:assert.match(s:hi('LightlineRight_active_3'), 'LightlineRight_normal_3')
-  call s:assert.match(s:hi('LightlineRight_active_4'), 'LightlineRight_normal_4')
-  call s:assert.match(s:hi('LightlineRight_active_5'), 'E411: highlight group not found')
-  call s:assert.match(s:hi('LightlineMiddle_active'), 'LightlineMiddle_normal')
-endfunction
-
-function! s:suite.subseparator()
-  let g:lightline = {
-        \   'active': {
-        \     'left': [ [ 'mode', 'paste' ], [ 'readonly' ], [ 'filename' ], [ 'modified' ] ],
-        \     'right': [ [ 'lineinfo' ], [ 'percent' ], [ 'fileformat' ], [ 'fileencoding' ], [ 'filetype' ] ]
-        \   },
-        \ }
-  call lightline#init()
-  call lightline#colorscheme()
-  call lightline#link()
-  for i in range(4)
-    for j in range(5)
-      if i + 1 == j
-        call s:assert.match(s:hi(printf('LightlineLeft_active_%s_%s', i, j)), printf('LightlineLeft_normal_%s_%s', i, j))
-      else
-        call s:assert.match(s:hi(printf('LightlineLeft_active_%s_%s', i, j)), 'E411: highlight group not found')
-      endif
-    endfor
-  endfor
-endfunction
-
-function! s:suite.component_type()
-  let g:lightline = { 'component_type': { 'error': 'error', 'warning': 'warning' } }
-  call lightline#init()
-  call lightline#colorscheme()
-  call lightline#link()
-  for type in ['error', 'warning']
-    call s:assert.match(s:hi(printf('LightlineLeft_active_%s', type)), printf('LightlineLeft_normal_%s', type))
-    call s:assert.match(s:hi(printf('LightlineLeft_active_0_%s', type)), printf('LightlineLeft_normal_0_%s', type))
-    call s:assert.match(s:hi(printf('LightlineLeft_active_1_%s', type)), printf('LightlineLeft_normal_1_%s', type))
-    call s:assert.match(s:hi(printf('LightlineLeft_active_2_%s', type)), 'E411: highlight group not found')
-    call s:assert.match(s:hi(printf('LightlineLeft_active_%s_0', type)), printf('LightlineLeft_normal_%s_0', type))
-    call s:assert.match(s:hi(printf('LightlineLeft_active_%s_1', type)), printf('LightlineLeft_normal_%s_1', type))
-    call s:assert.match(s:hi(printf('LightlineLeft_active_%s_2', type)), printf('LightlineLeft_normal_%s_2', type))
-    call s:assert.match(s:hi(printf('LightlineLeft_active_%s_3', type)), 'E411: highlight group not found')
-  endfor
-  for type1 in ['error', 'warning']
-    for type2 in ['error', 'warning']
-      call s:assert.match(s:hi(printf('LightlineLeft_active_%s_%s', type1, type2)), printf('LightlineLeft_normal_%s_%s', type1, type2))
-    endfor
-  endfor
-endfunction
diff --git a/sources_non_forked/lightline.vim/test/mode.vim b/sources_non_forked/lightline.vim/test/mode.vim
deleted file mode 100644
index 53280f5..0000000
--- a/sources_non_forked/lightline.vim/test/mode.vim
+++ /dev/null
@@ -1,14 +0,0 @@
-let s:suite = themis#suite('mode')
-let s:assert = themis#helper('assert')
-
-function! s:suite.mode()
-  let g:lightline = {}
-  call lightline#init()
-  call s:assert.equals(lightline#mode(), 'NORMAL')
-endfunction
-
-function! s:suite.mode_map()
-  let g:lightline = { 'mode_map': { 'n': 'N' } }
-  call lightline#init()
-  call s:assert.equals(lightline#mode(), 'N')
-endfunction
diff --git a/sources_non_forked/lightline.vim/test/onetab.vim b/sources_non_forked/lightline.vim/test/onetab.vim
deleted file mode 100644
index 529d833..0000000
--- a/sources_non_forked/lightline.vim/test/onetab.vim
+++ /dev/null
@@ -1,98 +0,0 @@
-let s:suite = themis#suite('onetab')
-let s:assert = themis#helper('assert')
-
-function! s:suite.before_each()
-  let g:lightline = {}
-  call lightline#init()
-  tabnew
-  tabonly
-endfunction
-
-function! s:suite.onetab()
-  call s:assert.equals(lightline#onetab(1, 1), '1 [No Name]')
-endfunction
-
-function! s:suite.tabnew()
-  tabnew
-  call s:assert.equals(lightline#onetab(1, 0), '1 [No Name]')
-  call s:assert.equals(lightline#onetab(2, 1), '2 [No Name]')
-endfunction
-
-function! s:suite.tabnew_tabnew()
-  tabnew
-  tabnew
-  call s:assert.equals(lightline#onetab(1, 0), '1 [No Name]')
-  call s:assert.equals(lightline#onetab(2, 0), '2 [No Name]')
-  call s:assert.equals(lightline#onetab(3, 1), '3 [No Name]')
-endfunction
-
-function! s:suite.modified()
-  call append(0, '')
-  call s:assert.equals(lightline#onetab(1, 1), '1 [No Name] +')
-  undo
-endfunction
-
-function! s:suite.filename()
-  edit test
-  call s:assert.equals(lightline#onetab(1, 1), '1 test')
-  tabnew
-  bunload test
-endfunction
-
-function! s:suite.filename_modified()
-  edit test
-  call append(0, '')
-  call s:assert.equals(lightline#onetab(1, 1), '1 test +')
-  tabnew
-  bunload! test
-endfunction
-
-function! s:suite.active_inactive()
-  let g:lightline = { 'tab': { 'active': [ 'tabnum', 'filename' ], 'inactive': [ 'filename' ] } }
-  call lightline#init()
-  edit test
-  call append(0, '')
-  call s:assert.equals(lightline#onetab(1, 1), '1 test')
-  call s:assert.equals(lightline#onetab(1, 0), 'test')
-  tabnew
-  bunload! test
-endfunction
-
-function! s:suite.tab_component()
-  let g:lightline = { 'tab': { 'active': [ 'custom' ] }, 'tab_component': { 'custom': 'custom' } }
-  call lightline#init()
-  call s:assert.equals(lightline#onetab(1, 1), 'custom')
-  call s:assert.equals(lightline#onetab(2, 1), 'custom')
-endfunction
-
-function! s:suite.tab_component_function()
-  function! Custom(n)
-    return 'custom: ' . a:n
-  endfunction
-  let g:lightline = { 'tab': { 'active': [ 'custom' ] }, 'tab_component_function': { 'custom': 'Custom' } }
-  call lightline#init()
-  call s:assert.equals(lightline#onetab(1, 1), 'custom: 1')
-  call s:assert.equals(lightline#onetab(2, 1), 'custom: 2')
-  delfunction Custom
-endfunction
-
-function! s:suite.tab_component_empty_middle()
-  let g:lightline = { 'tab': { 'active': [ 'tabnum', 'custom', 'filename' ], 'inactive': [ 'tabnum', 'custom', 'custom', 'filename' ] }, 'tab_component': { 'custom': '' } }
-  call lightline#init()
-  call s:assert.equals(lightline#onetab(1, 1), '1 [No Name]')
-  call s:assert.equals(lightline#onetab(2, 1), '2 [No Name]')
-endfunction
-
-function! s:suite.tab_component_empty_left()
-  let g:lightline = { 'tab': { 'active': [ 'custom', 'filename' ], 'inactive': [ 'custom', 'custom', 'filename' ] }, 'tab_component': { 'custom': '' } }
-  call lightline#init()
-  call s:assert.equals(lightline#onetab(1, 1), '[No Name]')
-  call s:assert.equals(lightline#onetab(2, 1), '[No Name]')
-endfunction
-
-function! s:suite.tab_component_empty_middle()
-  let g:lightline = { 'tab': { 'active': [ 'tabnum', 'custom' ], 'inactive': [ 'tabnum', 'custom', 'custom' ] }, 'tab_component': { 'custom': '' } }
-  call lightline#init()
-  call s:assert.equals(lightline#onetab(1, 1), '1')
-  call s:assert.equals(lightline#onetab(2, 1), '2')
-endfunction
diff --git a/sources_non_forked/lightline.vim/test/popup.vim b/sources_non_forked/lightline.vim/test/popup.vim
deleted file mode 100644
index cc4e882..0000000
--- a/sources_non_forked/lightline.vim/test/popup.vim
+++ /dev/null
@@ -1,19 +0,0 @@
-if !exists('*popup_menu') || !exists('*win_execute')
-  finish
-endif
-
-let s:suite = themis#suite('popup')
-let s:assert = themis#helper('assert')
-
-function! s:suite.before_each()
-  let g:lightline = {}
-  call lightline#init()
-  tabnew
-  tabonly
-endfunction
-
-function! s:suite.win_execute_setfiletype()
-  let id = popup_menu(['aaa', 'bbb'], {})
-  call win_execute(id, 'setfiletype vim')
-  call popup_close(id)
-endfunction
diff --git a/sources_non_forked/lightline.vim/test/quickfix.vim b/sources_non_forked/lightline.vim/test/quickfix.vim
deleted file mode 100644
index df4fce7..0000000
--- a/sources_non_forked/lightline.vim/test/quickfix.vim
+++ /dev/null
@@ -1,25 +0,0 @@
-let s:suite = themis#suite('quickfix')
-let s:assert = themis#helper('assert')
-
-function! s:suite.before_each()
-  let g:lightline = {}
-  call lightline#init()
-  tabnew
-  tabonly
-endfunction
-
-function! s:suite.quickfix_statusline()
-  call setloclist(winnr(), [])
-  lopen
-  wincmd p
-  call setloclist(winnr(), [])
-  for n in range(1, winnr('$'))
-    let statusline = getwinvar(n, '&statusline')
-    call s:assert.match(statusline, 'lightline')
-    if has('patch-8.1.1715')
-      call s:assert.match(statusline, n == 1 ? '_active_' : '_inactive_')
-    else
-      call s:assert.match(statusline, n != 1 ? '_active_' : '_inactive_')
-    endif
-  endfor
-endfunction
diff --git a/sources_non_forked/lightline.vim/test/subseparator.vim b/sources_non_forked/lightline.vim/test/subseparator.vim
deleted file mode 100644
index 2393840..0000000
--- a/sources_non_forked/lightline.vim/test/subseparator.vim
+++ /dev/null
@@ -1,407 +0,0 @@
-let s:suite = themis#suite('subseparator')
-let s:assert = themis#helper('assert')
-
-function! s:subseparator(...)
-  return eval(substitute(call(SID('subseparator'), a:000), '^%{\|}$', '', 'g'))
-endfunction
-
-function! s:suite.subseparator_component()
-  let g:lightline = { 'component': { 'custom1': 'custom1', 'custom2': 'custom2', 'custom3': 'custom3' } }
-  call lightline#init()
-  call s:assert.equals(s:subseparator(['custom1', 'custom2', 'custom3'], '|', [0, 0, 0]), '|')
-endfunction
-
-function! s:suite.subseparator_component_visible_condition_1()
-  let g:lightline = { 'component': { 'custom1': 'custom1', 'custom2': 'custom2', 'custom3': 'custom3' }, 'component_visible_condition': { 'custom1': '1', 'custom2': '1', 'custom3': '1' } }
-  call lightline#init()
-  call s:assert.equals(s:subseparator(['custom1', 'custom2', 'custom3'], '|', [0, 0, 0]), '|')
-endfunction
-
-function! s:suite.subseparator_component_visible_condition_2()
-  let g:lightline = { 'component': { 'custom1': 'custom1', 'custom2': 'custom2', 'custom3': 'custom3' }, 'component_visible_condition': { 'custom1': '0', 'custom2': '1', 'custom3': '1' } }
-  call lightline#init()
-  call s:assert.equals(s:subseparator(['custom1', 'custom2', 'custom3'], '|', [0, 0, 0]), '')
-endfunction
-
-function! s:suite.subseparator_component_visible_condition_3()
-  let g:lightline = { 'component': { 'custom1': 'custom1', 'custom2': 'custom2', 'custom3': 'custom3' }, 'component_visible_condition': { 'custom1': '1', 'custom2': '0', 'custom3': '1' } }
-  call lightline#init()
-  call s:assert.equals(s:subseparator(['custom1', 'custom2', 'custom3'], '|', [0, 0, 0]), '|')
-endfunction
-
-function! s:suite.subseparator_component_visible_condition_4()
-  let g:lightline = { 'component': { 'custom1': 'custom1', 'custom2': 'custom2', 'custom3': 'custom3' }, 'component_visible_condition': { 'custom1': '1', 'custom2': '0', 'custom3': '0' } }
-  call lightline#init()
-  call s:assert.equals(s:subseparator(['custom1', 'custom2', 'custom3'], '|', [0, 0, 0]), '')
-endfunction
-
-function! s:suite.subseparator_component_visible_condition_5()
-  let g:lightline = { 'component': { 'custom1': 'custom1', 'custom2': 'custom2', 'custom3': 'custom3' }, 'component_visible_condition': { 'custom1': '0', 'custom2': '0', 'custom3': '0' } }
-  call lightline#init()
-  call s:assert.equals(s:subseparator(['custom1', 'custom2', 'custom3'], '|', [0, 0, 0]), '')
-endfunction
-
-function! s:suite.subseparator_component_visible_condition_6()
-  let g:lightline = { 'component': { 'custom1': 'custom1', 'custom2': 'custom2', 'custom3': 'custom3' }, 'component_visible_condition': { 'custom1': '1||0', 'custom2': '0', 'custom3': '0' } }
-  call lightline#init()
-  call s:assert.equals(s:subseparator(['custom1', 'custom2', 'custom3'], '|', [0, 0, 0]), '')
-endfunction
-
-function! s:suite.subseparator_component_visible_condition_7()
-  let g:lightline = { 'component': { 'custom1': 'custom1', 'custom2': 'custom2', 'custom3': 'custom3' }, 'component_visible_condition': { 'custom1': '1||1', 'custom2': '0', 'custom3': '0' } }
-  call lightline#init()
-  call s:assert.equals(s:subseparator(['custom1', 'custom2', 'custom3'], '|', [0, 0, 0]), '')
-endfunction
-
-function! s:suite.subseparator_component_function()
-  function! Custom1()
-    return 'custom1'
-  endfunction
-  function! Custom2()
-    return 'custom2'
-  endfunction
-  function! Custom3()
-    return 'custom3'
-  endfunction
-  let g:lightline = { 'component_function': { 'custom1': 'Custom1', 'custom2': 'Custom2', 'custom3': 'Custom3' } }
-  call lightline#init()
-  call s:assert.equals(s:subseparator(['custom1', 'custom2', 'custom3'], '|', [0, 0, 0]), '|')
-  delfunction Custom1
-  delfunction Custom2
-  delfunction Custom3
-endfunction
-
-function! s:suite.subseparator_component_function_1()
-  function! Custom1()
-    return 'custom1'
-  endfunction
-  let g:lightline = { 'component_function': { 'custom1': 'Custom1', 'custom2': 'Custom2', 'custom3': 'Custom3' } }
-  call lightline#init()
-  call s:assert.equals(s:subseparator(['custom1', 'custom2', 'custom3'], '|', [0, 0, 0]), '')
-  delfunction Custom1
-endfunction
-
-function! s:suite.subseparator_component_function_2()
-  function! Custom1()
-    return 'custom1'
-  endfunction
-  function! Custom2()
-    return 'custom2'
-  endfunction
-  let g:lightline = { 'component_function': { 'custom1': 'Custom1', 'custom2': 'Custom2', 'custom3': 'Custom3' } }
-  call lightline#init()
-  call s:assert.equals(s:subseparator(['custom1', 'custom2', 'custom3'], '|', [0, 0, 0]), '|')
-  delfunction Custom1
-  delfunction Custom2
-endfunction
-
-function! s:suite.subseparator_component_function_3()
-  function! Custom1()
-    return 'custom1'
-  endfunction
-  function! Custom3()
-    return 'custom3'
-  endfunction
-  let g:lightline = { 'component_function': { 'custom1': 'Custom1', 'custom2': 'Custom2', 'custom3': 'Custom3' } }
-  call lightline#init()
-  call s:assert.equals(s:subseparator(['custom1', 'custom2', 'custom3'], '|', [0, 0, 0]), '|')
-  delfunction Custom1
-  delfunction Custom3
-endfunction
-
-function! s:suite.subseparator_component_function_4()
-  function! Custom2()
-    return 'custom2'
-  endfunction
-  function! Custom3()
-    return 'custom3'
-  endfunction
-  let g:lightline = { 'component_function': { 'custom1': 'Custom1', 'custom2': 'Custom2', 'custom3': 'Custom3' } }
-  call lightline#init()
-  call s:assert.equals(s:subseparator(['custom1', 'custom2', 'custom3'], '|', [0, 0, 0]), '')
-  delfunction Custom2
-  delfunction Custom3
-endfunction
-
-function! s:suite.subseparator_component_function_5()
-  function! Custom1()
-    return ''
-  endfunction
-  function! Custom2()
-    return 'custom2'
-  endfunction
-  function! Custom3()
-    return 'custom3'
-  endfunction
-  let g:lightline = { 'component_function': { 'custom1': 'Custom1', 'custom2': 'Custom2', 'custom3': 'Custom3' } }
-  call lightline#init()
-  call s:assert.equals(s:subseparator(['custom1', 'custom2', 'custom3'], '|', [0, 0, 0]), '')
-  delfunction Custom1
-  delfunction Custom2
-  delfunction Custom3
-endfunction
-
-function! s:suite.subseparator_component_function_6()
-  function! Custom1()
-    return ''
-  endfunction
-  function! Custom2()
-    return ''
-  endfunction
-  function! Custom3()
-    return 'custom3'
-  endfunction
-  let g:lightline = { 'component_function': { 'custom1': 'Custom1', 'custom2': 'Custom2', 'custom3': 'Custom3' } }
-  call lightline#init()
-  call s:assert.equals(s:subseparator(['custom1', 'custom2', 'custom3'], '|', [0, 0, 0]), '')
-  delfunction Custom1
-  delfunction Custom2
-  delfunction Custom3
-endfunction
-
-function! s:suite.subseparator_component_function_7()
-  function! Custom1()
-    return 'custom1'
-  endfunction
-  function! Custom2()
-    return ''
-  endfunction
-  function! Custom3()
-    return ''
-  endfunction
-  let g:lightline = { 'component_function': { 'custom1': 'Custom1', 'custom2': 'Custom2', 'custom3': 'Custom3' } }
-  call lightline#init()
-  call s:assert.equals(s:subseparator(['custom1', 'custom2', 'custom3'], '|', [0, 0, 0]), '')
-  delfunction Custom1
-  delfunction Custom2
-  delfunction Custom3
-endfunction
-
-function! s:suite.subseparator_component_function_visible_condition_1()
-  function! Custom1()
-    return 'custom1'
-  endfunction
-  function! Custom2()
-    return 'custom2'
-  endfunction
-  function! Custom3()
-    return 'custom3'
-  endfunction
-  let g:lightline = { 'component_function': { 'custom1': 'Custom1', 'custom2': 'Custom2', 'custom3': 'Custom3' }, 'component_function_visible_condition': { 'custom1': '1', 'custom2': '1', 'custom3': '1' } }
-  call lightline#init()
-  call s:assert.equals(s:subseparator(['custom1', 'custom2', 'custom3'], '|', [0, 0, 0]), '|')
-endfunction
-
-function! s:suite.subseparator_component_function_visible_condition_2()
-  function! Custom1()
-    return 'custom1'
-  endfunction
-  function! Custom2()
-    return 'custom2'
-  endfunction
-  function! Custom3()
-    return 'custom3'
-  endfunction
-  let g:lightline = { 'component_function': { 'custom1': 'Custom1', 'custom2': 'Custom2', 'custom3': 'Custom3' }, 'component_function_visible_condition': { 'custom1': '0', 'custom2': '1', 'custom3': '1' } }
-  call lightline#init()
-  call s:assert.equals(s:subseparator(['custom1', 'custom2', 'custom3'], '|', [0, 0, 0]), '')
-endfunction
-
-function! s:suite.subseparator_component_function_visible_condition_3()
-  function! Custom1()
-    return 'custom1'
-  endfunction
-  function! Custom2()
-    return 'custom2'
-  endfunction
-  function! Custom3()
-    return 'custom3'
-  endfunction
-  let g:lightline = { 'component_function': { 'custom1': 'Custom1', 'custom2': 'Custom2', 'custom3': 'Custom3' }, 'component_function_visible_condition': { 'custom1': '1', 'custom2': '0', 'custom3': '1' } }
-  call lightline#init()
-  call s:assert.equals(s:subseparator(['custom1', 'custom2', 'custom3'], '|', [0, 0, 0]), '|')
-endfunction
-
-function! s:suite.subseparator_component_function_visible_condition_4()
-  function! Custom1()
-    return 'custom1'
-  endfunction
-  function! Custom2()
-    return 'custom2'
-  endfunction
-  function! Custom3()
-    return 'custom3'
-  endfunction
-  let g:lightline = { 'component_function': { 'custom1': 'Custom1', 'custom2': 'Custom2', 'custom3': 'Custom3' }, 'component_function_visible_condition': { 'custom1': '1', 'custom2': '0', 'custom3': '0' } }
-  call lightline#init()
-  call s:assert.equals(s:subseparator(['custom1', 'custom2', 'custom3'], '|', [0, 0, 0]), '')
-endfunction
-
-function! s:suite.subseparator_component_function_visible_condition_5()
-  function! Custom1()
-    return 'custom1'
-  endfunction
-  function! Custom2()
-    return ''
-  endfunction
-  function! Custom3()
-    return ''
-  endfunction
-  let g:lightline = { 'component_function': { 'custom1': 'Custom1', 'custom2': 'Custom2', 'custom3': 'Custom3' }, 'component_function_visible_condition': { 'custom1': '0' } }
-  call lightline#init()
-  call s:assert.equals(s:subseparator(['custom1', 'custom2', 'custom3'], '|', [0, 0, 0]), '')
-endfunction
-
-function! s:suite.subseparator_component_function_visible_condition_6()
-  function! Custom1()
-    return ''
-  endfunction
-  function! Custom2()
-    return 'custom2'
-  endfunction
-  function! Custom3()
-    return 'custom3'
-  endfunction
-  let g:lightline = { 'component_function': { 'custom1': 'Custom1', 'custom2': 'Custom2', 'custom3': 'Custom3' }, 'component_function_visible_condition': { 'custom2': '1', 'custom3': '1' } }
-  call lightline#init()
-  call s:assert.equals(s:subseparator(['custom1', 'custom2', 'custom3'], '|', [0, 0, 0]), '')
-endfunction
-
-function! s:suite.subseparator_component_function_visible_condition_7()
-  function! Custom1()
-    return 'custom1'
-  endfunction
-  function! Custom2()
-    return ''
-  endfunction
-  function! Custom3()
-    return 'custom3'
-  endfunction
-  let g:lightline = { 'component_function': { 'custom1': 'Custom1', 'custom2': 'Custom2', 'custom3': 'Custom3' }, 'component_function_visible_condition': { 'custom3': '1' } }
-  call lightline#init()
-  call s:assert.equals(s:subseparator(['custom1', 'custom2', 'custom3'], '|', [0, 0, 0]), '|')
-endfunction
-
-function! s:suite.subseparator_component_expand()
-  function! Custom1()
-    return 'custom1'
-  endfunction
-  function! Custom2()
-    return 'custom2'
-  endfunction
-  function! Custom3()
-    return 'custom3'
-  endfunction
-  let g:lightline = { 'component_expand': { 'custom1': 'Custom1', 'custom2': 'Custom2', 'custom3': 'Custom3' } }
-  call lightline#init()
-  call s:assert.equals(s:subseparator(['custom1', 'custom2', 'custom3'], '|', [1, 1, 1]), '|')
-  delfunction Custom1
-  delfunction Custom2
-  delfunction Custom3
-endfunction
-
-function! s:suite.subseparator_component_expand()
-  function! Custom1()
-    return 'custom1'
-  endfunction
-  function! Custom2()
-    return 'custom2'
-  endfunction
-  function! Custom3()
-    return 'custom3'
-  endfunction
-  let g:lightline = { 'component_expand': { 'custom1': 'Custom1', 'custom2': 'Custom2', 'custom3': 'Custom3' } }
-  call lightline#init()
-  call s:assert.equals(s:subseparator(['custom1', 'custom2', 'custom3'], '|', [1, 1, 1]), '|')
-  delfunction Custom1
-  delfunction Custom2
-  delfunction Custom3
-endfunction
-
-function! s:suite.subseparator_component_expand_1()
-  function! Custom1()
-    return 'custom1'
-  endfunction
-  function! Custom2()
-    return 'custom2'
-  endfunction
-  function! Custom3()
-    return 'custom3'
-  endfunction
-  let g:lightline = { 'component_expand': { 'custom1': 'Custom1' }, 'component_function': { 'custom2': 'Custom2', 'custom3': 'Custom3' } }
-  call lightline#init()
-  call s:assert.equals(s:subseparator(['custom1', 'custom2', 'custom3'], '|', [1, 0, 0]), '|')
-  delfunction Custom1
-  delfunction Custom2
-  delfunction Custom3
-endfunction
-
-function! s:suite.subseparator_component_expand_2()
-  function! Custom1()
-    return 'custom1'
-  endfunction
-  function! Custom2()
-    return 'custom2'
-  endfunction
-  function! Custom3()
-    return 'custom3'
-  endfunction
-  let g:lightline = { 'component_expand': { 'custom1': 'Custom1', 'custom2': 'Custom2' }, 'component_function': { 'custom3': 'Custom3' } }
-  call lightline#init()
-  call s:assert.equals(s:subseparator(['custom1', 'custom2', 'custom3'], '|', [1, 1, 0]), '|')
-  delfunction Custom1
-  delfunction Custom2
-  delfunction Custom3
-endfunction
-
-function! s:suite.subseparator_component_expand_3()
-  function! Custom1()
-    return ''
-  endfunction
-  function! Custom2()
-    return 'custom2'
-  endfunction
-  function! Custom3()
-    return 'custom3'
-  endfunction
-  let g:lightline = { 'component_function': { 'custom1': 'Custom1', 'custom2': 'Custom2' }, 'component_expand': { 'custom3': 'Custom3' } }
-  call lightline#init()
-  call s:assert.equals(s:subseparator(['custom1', 'custom2', 'custom3'], '|', [0, 0, 1]), '')
-  delfunction Custom1
-  delfunction Custom2
-  delfunction Custom3
-endfunction
-
-function! s:suite.subseparator_component_not_found()
-  function! Custom1()
-    return 'custom1'
-  endfunction
-  let g:lightline = { 'component_function': { 'custom1': 'Custom1' } }
-  call lightline#init()
-  call s:assert.equals(s:subseparator(['custom1', 'custom2', 'custom3'], '|', [0, 0, 0]), '')
-  delfunction Custom1
-endfunction
-
-function! s:suite.subseparator_component_not_found_1()
-  function! Custom2()
-    return 'custom2'
-  endfunction
-  let g:lightline = { 'component_function': { 'custom2': 'Custom2' } }
-  call lightline#init()
-  call s:assert.equals(s:subseparator(['custom1', 'custom2', 'custom3'], '|', [0, 0, 0]), '')
-  delfunction Custom2
-endfunction
-
-function! s:suite.subseparator_component_not_found_2()
-  function! Custom1()
-    return 'custom1'
-  endfunction
-  function! Custom2()
-    return 'custom2'
-  endfunction
-  let g:lightline = { 'component_function': { 'custom1': 'Custom1', 'custom2': 'Custom2' } }
-  call lightline#init()
-  call s:assert.equals(s:subseparator(['custom1', 'custom2', 'custom3'], '|', [0, 0, 0]), '|')
-  delfunction Custom1
-  delfunction Custom2
-endfunction
diff --git a/sources_non_forked/lightline.vim/test/tabline.vim b/sources_non_forked/lightline.vim/test/tabline.vim
deleted file mode 100644
index 0a9879f..0000000
--- a/sources_non_forked/lightline.vim/test/tabline.vim
+++ /dev/null
@@ -1,67 +0,0 @@
-let s:suite = themis#suite('tabline')
-let s:assert = themis#helper('assert')
-
-function! s:suite.before_each()
-  let g:lightline = {}
-  call lightline#init()
-  tabnew
-  tabonly
-endfunction
-
-function! s:suite.tabline()
-  call s:assert.equals(&tabline, '%!lightline#tabline()')
-endfunction
-
-function! s:suite.enabled()
-  let g:lightline = { 'enable': { 'tabline': 1 } }
-  call lightline#init()
-  call s:assert.equals(&tabline, '%!lightline#tabline()')
-endfunction
-
-function! s:suite.disabled()
-  let g:lightline = { 'enable': { 'tabline': 0 } }
-  call lightline#init()
-  call s:assert.equals(&tabline, '')
-endfunction
-
-function! s:suite.tabnew()
-  let tabline = lightline#tabline()
-  tabnew
-  call s:assert.not_equals(lightline#tabline(), tabline)
-endfunction
-
-function! s:suite.tabnew_first()
-  let tabline = lightline#tabline()
-  0tabnew
-  call s:assert.not_equals(lightline#tabline(), tabline)
-endfunction
-
-function! s:suite.tabnext()
-  tabnew
-  let tabline = lightline#tabline()
-  tabnext
-  call s:assert.not_equals(lightline#tabline(), tabline)
-endfunction
-
-function! s:suite.tabonly()
-  tabnew
-  tabfirst
-  let tabline = lightline#tabline()
-  tabonly
-  call s:assert.not_equals(lightline#tabline(), tabline)
-endfunction
-
-function! s:suite.tabclose()
-  tabnew
-  let tabline = lightline#tabline()
-  tabclose
-  call s:assert.not_equals(lightline#tabline(), tabline)
-endfunction
-
-function! s:suite.tabclose_last()
-  tabnew
-  tabfirst
-  let tabline = lightline#tabline()
-  $tabclose
-  call s:assert.not_equals(lightline#tabline(), tabline)
-endfunction
diff --git a/sources_non_forked/lightline.vim/test/tabs.vim b/sources_non_forked/lightline.vim/test/tabs.vim
deleted file mode 100644
index 7851e70..0000000
--- a/sources_non_forked/lightline.vim/test/tabs.vim
+++ /dev/null
@@ -1,99 +0,0 @@
-let s:suite = themis#suite('tabs')
-let s:assert = themis#helper('assert')
-
-function! s:suite.before_each()
-  let g:lightline = { 'winwidth': 180 }
-  call lightline#init()
-  tabnew
-  tabonly
-endfunction
-
-function! s:tab(number, ...) abort
-  let active = get(a:000, 0, 0)
-  let last = get(a:000, 1, 0)
-  return '%' . a:number . 'T%{lightline#onetab(' . a:number . ',' . active . ')}' . (last ? '%T' : '')
-endfunction
-
-function! s:suite.tabs()
-  call s:assert.equals(lightline#tabs(), [[], [s:tab(1, 1, 1)], []])
-endfunction
-
-function! s:suite.tabnew()
-  tabnew
-  call s:assert.equals(lightline#tabs(), [[s:tab(1)], [s:tab(2, 1, 1)], []])
-endfunction
-
-function! s:suite.tabnew_tabnew()
-  tabnew
-  tabnew
-  call s:assert.equals(lightline#tabs(), [[s:tab(1), s:tab(2)], [s:tab(3, 1, 1)], []])
-endfunction
-
-function! s:suite.tabnew_tabfirst()
-  tabnew
-  tabfirst
-  call s:assert.equals(lightline#tabs(), [[], [s:tab(1, 1)], [s:tab(2, 0, 1)]])
-endfunction
-
-function! s:suite.tabnew_tabnew_tabfirst()
-  tabnew
-  tabnew
-  tabfirst
-  call s:assert.equals(lightline#tabs(), [[], [s:tab(1, 1)], [s:tab(2), s:tab(3, 0, 1)]])
-endfunction
-
-function! s:suite.tabnew_tabnew_tabprevious()
-  tabnew
-  tabnew
-  tabprevious
-  call s:assert.equals(lightline#tabs(), [[s:tab(1)], [s:tab(2, 1)], [s:tab(3, 0, 1)]])
-endfunction
-
-function! s:suite.tabnew_20()
-  for i in range(19)
-    tabnew
-  endfor
-  call s:assert.equals(lightline#tabs(), [[s:tab(1), s:tab(2), s:tab(3), s:tab(4), '...', s:tab(16), s:tab(17), s:tab(18), s:tab(19)], [s:tab(20, 1, 1)], []])
-endfunction
-
-function! s:suite.tabnew_20_tabfirst()
-  for i in range(19)
-    tabnew
-  endfor
-  tabfirst
-  call s:assert.equals(lightline#tabs(), [[], [s:tab(1, 1)], [s:tab(2), s:tab(3), s:tab(4), '%<' . s:tab(5), '...', '%<' . s:tab(17), '%<' . s:tab(18), '%<' . s:tab(19), '%<' . s:tab(20, 0, 1)]])
-endfunction
-
-function! s:suite.tabnew_20_tabfirst_tabnext()
-  for i in range(19)
-    tabnew
-  endfor
-  tabfirst
-  tabnext
-  call s:assert.equals(lightline#tabs(), [[s:tab(1)], [s:tab(2, 1)], [s:tab(3), s:tab(4), s:tab(5), '%<' . s:tab(6), '...', '%<' . s:tab(18), '%<' . s:tab(19), '%<' . s:tab(20, 0, 1)]])
-endfunction
-
-function! s:suite.tabnew_20_tabnext_10()
-  for i in range(19)
-    tabnew
-  endfor
-  tabnext 10
-  call s:assert.equals(lightline#tabs(), [[s:tab(1), s:tab(2), '...', s:tab(8), s:tab(9)], [s:tab(10, 1)], [s:tab(11), s:tab(12), '...', '%<' . s:tab(19), '%<' . s:tab(20, 0, 1)]])
-endfunction
-
-function! s:suite.tabnew_20_tabprevious()
-  for i in range(19)
-    tabnew
-  endfor
-  tabprevious
-  call s:assert.equals(lightline#tabs(), [[s:tab(1), s:tab(2), s:tab(3), '...', s:tab(15), s:tab(16), s:tab(17), s:tab(18)], [s:tab(19, 1)], [s:tab(20, 0, 1)]])
-endfunction
-
-function! s:suite.tabnew_20_tabprevious_tabprevious()
-  for i in range(19)
-    tabnew
-  endfor
-  tabprevious
-  tabprevious
-  call s:assert.equals(lightline#tabs(), [[s:tab(1), s:tab(2), s:tab(3), '...', s:tab(15), s:tab(16), s:tab(17)], [s:tab(18, 1)], [s:tab(19), s:tab(20, 0, 1)]])
-endfunction
diff --git a/sources_non_forked/lightline.vim/test/toggle.vim b/sources_non_forked/lightline.vim/test/toggle.vim
deleted file mode 100644
index 7df270f..0000000
--- a/sources_non_forked/lightline.vim/test/toggle.vim
+++ /dev/null
@@ -1,45 +0,0 @@
-let s:suite = themis#suite('toggle')
-let s:assert = themis#helper('assert')
-
-function! s:suite.before_each()
-  let g:lightline = {}
-  call lightline#init()
-  tabnew
-  tabonly
-endfunction
-
-function! s:suite.default()
-  call s:assert.equals(exists('#lightline'), 1)
-  call s:assert.equals(exists('#lightline-disable'), 0)
-  call s:assert.not_equals(&statusline, '')
-  call s:assert.not_equals(&tabline, '')
-endfunction
-
-function! s:suite.disable_enable()
-  call lightline#disable()
-  call s:assert.equals(exists('#lightline'), 0)
-  call s:assert.equals(exists('#lightline-disable'), 1)
-  call s:assert.equals(&statusline, '')
-  call s:assert.equals(&tabline, '')
-  call lightline#update()
-  call s:assert.equals(&statusline, '')
-  call s:assert.equals(&tabline, '')
-  call lightline#enable()
-  call s:assert.equals(exists('#lightline'), 1)
-  call s:assert.equals(exists('#lightline-disable'), 0)
-  call s:assert.not_equals(&statusline, '')
-  call s:assert.not_equals(&tabline, '')
-endfunction
-
-function! s:suite.toggle()
-  call lightline#toggle()
-  call s:assert.equals(exists('#lightline'), 0)
-  call s:assert.equals(exists('#lightline-disable'), 1)
-  call s:assert.equals(&statusline, '')
-  call s:assert.equals(&tabline, '')
-  call lightline#toggle()
-  call s:assert.equals(exists('#lightline'), 1)
-  call s:assert.equals(exists('#lightline-disable'), 0)
-  call s:assert.not_equals(&statusline, '')
-  call s:assert.not_equals(&tabline, '')
-endfunction
diff --git a/sources_non_forked/lightline.vim/test/uniq.vim b/sources_non_forked/lightline.vim/test/uniq.vim
deleted file mode 100644
index cdfaec0..0000000
--- a/sources_non_forked/lightline.vim/test/uniq.vim
+++ /dev/null
@@ -1,46 +0,0 @@
-let s:suite = themis#suite('uniq')
-let s:assert = themis#helper('assert')
-
-function! s:uniq(...)
-  try
-    return call(SID('uniq'), a:000)
-  catch
-    return call(function('uniq'), a:000)
-  endtry
-endfunction
-
-function! s:suite.nil()
-  call s:assert.equals(s:uniq([]), [])
-endfunction
-
-function! s:suite.one()
-  call s:assert.equals(s:uniq(['foo']), ['foo'])
-endfunction
-
-function! s:suite.two()
-  call s:assert.equals(s:uniq(['foo', 'bar']), ['foo', 'bar'])
-endfunction
-
-function! s:suite.three()
-  call s:assert.equals(s:uniq(['foo', 'bar', 'baz']), ['foo', 'bar', 'baz'])
-endfunction
-
-function! s:suite.two_duplicated()
-  call s:assert.equals(s:uniq(['foo', 'foo']), ['foo'])
-endfunction
-
-function! s:suite.three_duplicated()
-  call s:assert.equals(s:uniq(['foo', 'bar', 'foo']), ['foo', 'bar', 'foo'])
-endfunction
-
-function! s:suite.many1()
-  call s:assert.equals(s:uniq(['foo', 'foo', 'bar', 'baz', 'baz', 'qux', 'foo']), ['foo', 'bar', 'baz', 'qux', 'foo'])
-endfunction
-
-function! s:suite.many2()
-  call s:assert.equals(s:uniq(['foo', 'foo', 'foo', 'foo', 'bar', 'bar', 'bar']), ['foo', 'bar'])
-endfunction
-
-function! s:suite.many3()
-  call s:assert.equals(s:uniq(['foo', 'foo', 'bar', 'bar', 'bar', 'foo', 'foo', 'foo']), ['foo', 'bar', 'foo'])
-endfunction
diff --git a/sources_non_forked/mayansmoke/README b/sources_non_forked/mayansmoke/README
deleted file mode 100644
index 7f5b5c4..0000000
--- a/sources_non_forked/mayansmoke/README
+++ /dev/null
@@ -1,43 +0,0 @@
-This is a mirror of http://www.vim.org/scripts/script.php?script_id=3065
-
-This is a pleasant and ergonomic light-background color scheme, designed for long hours of coding and working. The UI elements are muted without being drab, the syntax elements are colorful without being garish, and the background is relaxing without being soporific. It is of a low-enough contrast so as not to cause eye-burn, but high-enough contrast so as not to cause eye-strain. The syntax coloration offers just a little higher resolution than most, distinguishing between class names vs. functions, strings and numbers vs. other constants, etc. Many of the colors in this color scheme are drawn from Mayan murals, paintings and codices, and thus the name.
-
-Screenshots:
-==========
-
-    - Python: http://jeetworks.org/files/images/mayansmoke-python1.png
-    - C++: http://jeetworks.org/files/images/mayansmoke-cpp1.png
-
-Customization:
-==============
-
-If any of the following highlights are defined (e.g., in your "~/.vimrc"), these will override the default highlight definitions:
-
-    MayanSmokeCursorLine    (will be applied to: CursorColumn and CursorLine)
-    MayanSmokeSearch        (will be applied to: Search and IncSearch)
-    MayanSmokeSpecialKey    (will be applied to: SpecialKey)
-
-For example, you can set the following in your "~/.vimrc" to select your own colors for these items:
-
-    hi MayanSmokeCursorLine     guifg=NONE   guibg=yellow  gui=NONE
-    hi MayanSmokeSearch         guifg=white  guibg=blue    gui=NONE
-    hi MayanSmokeSpecialKey     guifg=NONE   guibg=green   gui=NONE
-
-Alternatively, you can define one or more of the following values in your "~/.vimrc" to select different pre-defined levels of visibility for the above highlights:
-
-    let g:mayansmoke_cursor_line_visibility = 0  " lower visibility
-    let g:mayansmoke_cursor_line_visibility = 1  " medium visibility
-    let g:mayansmoke_cursor_line_visibility = 2  " higher visibility
-
-   let g:mayansmoke_search_visibility = 0 " low visibility
-   let g:mayansmoke_search_visibility = 1 " medium visibility (default)
-   let g:mayansmoke_search_visibility = 2 " high visibility
-   let g:mayansmoke_search_visibility = 3 " very high visibility
-   let g:mayansmoke_search_visibility = 4 " highest visibility
-
-    let g:mayansmoke_special_key_visibility = 0  " lower visibility
-    let g:mayansmoke_special_key_visibility = 1  " medium visibility
-    let g:mayansmoke_special_key_visibility = 2  " higher visibility
-
-
-
diff --git a/sources_non_forked/mayansmoke/colors/mayansmoke.vim b/sources_non_forked/mayansmoke/colors/mayansmoke.vim
deleted file mode 100644
index 6d146f8..0000000
--- a/sources_non_forked/mayansmoke/colors/mayansmoke.vim
+++ /dev/null
@@ -1,343 +0,0 @@
-" =============================================================================
-"
-" File:        mayansmoke.vim
-" Description: Vim color scheme file
-" Maintainer:  Jeet Sukumaran (GUI colors); Clayton Parker (cterm colors)
-"
-" =============================================================================
-
-"  Initialization and Setup {{{1
-" =============================================================================
-set background=light
-highlight clear
-if exists("syntax_on")
-  syntax reset
-endif
-let colors_name = "mayansmoke"
-" }}}
-
-"  Normal Color {{{1
-" =============================================================================
-hi Normal gui=NONE guifg=Black guibg=#F4F4E8
-" }}}
-
-"  Highlight Groups {{{1
-" =============================================================================
-" Groups (see ':help highlight-groups'):
-"    ColorColumn     highlight to use with ':set colorcolumn'
-"    Cursor          the character under the cursor
-"    CursorIM        like Cursor, but used when in IME mode |CursorIM|
-"    CursorColumn    the screen column that the cursor is in when 'cursorcolumn' is set
-"    CursorLine      the screen line that the cursor is in when 'cursorline' is set
-"    Directory       directory names (and other special names in listings)
-"    DiffAdd         diff mode: Added line |diff.txt|
-"    DiffChange      diff mode: Changed line |diff.txt|
-"    DiffDelete      diff mode: Deleted line |diff.txt|
-"    DiffText        diff mode: Changed text within a changed line |diff.txt|
-"    ErrorMsg        error messages on the command line
-"    VertSplit       the column separating vertically split windows
-"    Folded          line used for closed folds
-"    FoldColumn      'foldcolumn'
-"    SignColumn      column where |signs| are displayed
-"    IncSearch       'incsearch' highlighting; also used for the text replaced with ":s///c"
-"    LineNr          Line number for ":number" and ":#" commands, and when 'number' option is set.
-"    MatchParen      The character under the cursor or just before it, if it is a paired bracket, and its match. |pi_paren.txt|
-"    ModeMsg         'showmode' message (e.g., "-- INSERT --")
-"    MoreMsg         |more-prompt|
-"    NonText         '~' and '@' at the end of the window, etc.
-"    Normal          normal text
-"    Pmenu           Popup menu: normal item.
-"    PmenuSel        Popup menu: selected item.
-"    PmenuSbar       Popup menu: scrollbar.
-"    PmenuThumb      Popup menu: Thumb of the scrollbar.
-"    Question        |hit-enter| prompt and yes/no questions
-"    Search          Last search pattern highlighting (see 'hlsearch').
-"    SpecialKey      Meta and special keys listed with ":map", text that is displayed differently from what it really is (such as tabs, spaces in listchars etc.).
-"    SpellBad        Word that is not recognized by the spellchecker. |spell|
-"    SpellCap        Word that should start with a capital. |spell|
-"    SpellLocal      Word that is recognized by the spellchecker as one that is
-"    SpellRare       Word that is recognized by the spellchecker as one that is hardly ever used. |spell|
-"    StatusLine      status line of current window
-"    StatusLineNC    status lines of not-current windows
-"    TabLine         tab pages line, not active tab page label
-"    TabLineFill     tab pages line, where there are no labels
-"    TabLineSel      tab pages line, active tab page label
-"    Title           titles for output from ":set all", ":autocmd" etc.
-"    Visual          Visual mode selection
-"    VisualNOS       Visual mode selection when vim is "Not Owning the Selection".
-"    WarningMsg      warning messages
-"    WildMenu        current match in 'wildmenu' completion
-hi ColorColumn  guifg=NONE              guibg=#EEEEDD
-hi Cursor       guifg=bg                guibg=fg                gui=NONE
-if hlexists('MayanSmokeCursorLine')
-    hi link CursorColumn MayanSmokeCursorLine
-    hi link CursorLine MayanSmokeCursorLine
-elseif exists('g:mayansmoke_cursor_line_visibility') && g:mayansmoke_cursor_line_visibility >= 2
-    hi CursorColumn guifg=NONE              guibg=NavajoWhite   gui=NONE
-    hi CursorLine   guifg=NONE              guibg=NavajoWhite   gui=NONE
-elseif exists('g:mayansmoke_cursor_line_visibility') && g:mayansmoke_cursor_line_visibility >= 1
-    hi CursorColumn guifg=NONE              guibg=white         gui=NONE
-    hi CursorLine   guifg=NONE              guibg=white         gui=NONE
-else
-    hi CursorColumn guifg=NONE              guibg=#FFFDD0       gui=NONE
-    hi CursorLine   guifg=NONE              guibg=#FFFDD0       gui=NONE
-endif
-hi CursorIM     guifg=bg                guibg=fg                gui=NONE
-hi lCursor      guifg=bg                guibg=fg                gui=NONE
-hi DiffAdd      guifg=NONE              guibg=SeaGreen1         gui=NONE
-hi DiffChange   guifg=NONE              guibg=LightSkyBlue1     gui=NONE
-hi DiffDelete   guifg=NONE              guibg=LightCoral        gui=NONE
-hi DiffText     guifg=black             guibg=LightCyan1        gui=NONE
-hi Directory    guifg=#1600FF           guibg=bg                gui=NONE
-hi ErrorMsg     guifg=Red2              guibg=NONE              gui=NONE
-hi FoldColumn   guifg=SteelBlue4        guibg=LightYellow2      gui=bold
-hi Folded       guifg=SteelBlue4        guibg=Gainsboro      gui=italic
-if hlexists('MayanSmokeSearch')
-    hi link IncSearch MayanSmokeSearch
-    hi link Search MayanSmokeSearch
-elseif exists('g:mayansmoke_search_visibility') && g:mayansmoke_search_visibility >= 4
-    hi IncSearch    guifg=white             guibg=red           gui=NONE
-    hi Search       guifg=white             guibg=red           gui=NONE
-elseif exists('g:mayansmoke_search_visibility') && g:mayansmoke_search_visibility == 3
-    hi IncSearch    guifg=black             guibg=gold       gui=NONE
-    hi Search       guifg=black             guibg=gold        gui=NONE
-elseif exists('g:mayansmoke_search_visibility') && g:mayansmoke_search_visibility == 2
-    hi IncSearch    guifg=white             guibg=darkorange       gui=NONE
-    hi Search       guifg=white             guibg=darkorange        gui=NONE
-elseif exists('g:mayansmoke_search_visibility') && g:mayansmoke_search_visibility == 0
-    hi IncSearch    guifg=black             guibg=tan         gui=NONE
-    hi Search       guifg=black             guibg=tan         gui=NONE
-else
-    hi IncSearch    guifg=black             guibg=khaki          gui=NONE
-    hi Search       guifg=black             guibg=khaki          gui=NONE
-endif
-hi LineNr       guifg=#666677           guibg=#cccfbf    gui=NONE
-hi MatchParen   guifg=black             guibg=LemonChiffon3     gui=bold
-hi ModeMsg      guifg=White             guibg=tomato1           gui=bold
-hi MoreMsg      guifg=SeaGreen4         guibg=bg                gui=bold
-hi NonText      guifg=LightCyan3        guibg=bg                gui=bold
-
-hi Pmenu        guifg=Orange4           guibg=LightYellow3      gui=NONE
-hi PmenuSel     guifg=ivory2            guibg=NavajoWhite4      gui=bold
-hi PmenuSbar    guifg=White             guibg=#999666        gui=NONE
-hi PmenuThumb   guifg=White             guibg=#7B7939        gui=NONE
-
-hi Question     guifg=Chartreuse4       guibg=bg                gui=bold
-hi SignColumn   guifg=white             guibg=LightYellow3      gui=NONE
-if hlexists('MayanSmokeSpecialKey')
-    hi link SpecialKey MayanSmokeSpecialKey
-elseif exists('g:mayansmoke_special_key_visibility') && g:mayansmoke_special_key_visibility >= 2
-    hi SpecialKey   guifg=black         guibg=NavajoWhite       gui=NONE
-elseif exists('g:mayansmoke_special_key_visibility') && g:mayansmoke_special_key_visibility == 0
-    hi SpecialKey   guifg=bisque3       guibg=NONE              gui=NONE
-else
-    hi SpecialKey   guifg=white         guibg=ivory3            gui=NONE
-endif
-hi SpellBad     guisp=Firebrick2                                gui=undercurl
-hi SpellCap     guisp=Blue                                      gui=undercurl
-hi SpellLocal   guisp=DarkCyan                                  gui=undercurl
-hi SpellRare    guisp=Magenta                                   gui=undercurl
-hi StatusLine   guifg=#FFFEEE           guibg=#557788     gui=NONE
-" hi StatusLineNC guifg=#EAE6E2           guibg=LightSteelBlue3    gui=italic
-hi StatusLineNC guifg=#F4F4EE           guibg=#99aabb    gui=italic
-hi TabLine      guifg=fg                guibg=LightGrey         gui=underline
-hi TabLineFill  guifg=fg                guibg=bg                gui=reverse
-hi TabLineSel   guifg=fg                guibg=bg                gui=bold
-hi Title        guifg=DeepSkyBlue3      guibg=bg                gui=bold
-hi VertSplit    guifg=#99aabb     guibg=#99aabb
-hi Visual       guifg=white             guibg=DeepSkyBlue1      gui=NONE
-hi WarningMsg   guifg=Firebrick2        guibg=bg                gui=NONE
-hi WildMenu     guifg=Black             guibg=SkyBlue           gui=NONE
-" }}}
-
-" 256-Color Terminal Colors, by Clayton Parker {{{1
-" =============================================================================
-hi Normal cterm=NONE ctermfg=16  ctermbg=255
-hi Comment      ctermfg=110
-hi Constant     ctermfg=214
-    hi String   ctermfg=30
-    hi Boolean  ctermfg=88
-hi Identifier   ctermfg=160
-hi Function     ctermfg=132
-hi Statement    ctermfg=21
-hi Keyword      ctermfg=45
-hi PreProc      ctermfg=27
-hi Type         ctermfg=147
-hi Special      ctermfg=64
-hi Ignore       ctermfg=255
-hi Error        ctermfg=196             ctermbg=255     term=none
-hi Todo         ctermfg=136             ctermbg=255     cterm=NONE
-hi VimError         ctermfg=160          ctermbg=16
-hi VimCommentTitle  ctermfg=110
-hi qfLineNr         ctermfg=16           ctermbg=46        cterm=NONE
-hi pythonDecorator ctermfg=208   ctermbg=255 cterm=NONE
-hi Cursor       ctermfg=255             ctermbg=16              cterm=NONE
-hi CursorColumn ctermfg=NONE            ctermbg=255             cterm=NONE
-hi CursorIM     ctermfg=255             ctermbg=16              cterm=NONE
-hi CursorLine   ctermfg=NONE            ctermbg=254             cterm=NONE
-hi lCursor      ctermfg=255             ctermbg=16              cterm=NONE
-hi DiffAdd      ctermfg=16              ctermbg=48              cterm=NONE
-hi DiffChange   ctermfg=16              ctermbg=153             cterm=NONE
-hi DiffDelete   ctermfg=16              ctermbg=203             cterm=NONE
-hi DiffText     ctermfg=16              ctermbg=226             cterm=NONE
-hi Directory    ctermfg=21              ctermbg=255             cterm=NONE
-hi ErrorMsg     ctermfg=160             ctermbg=NONE            cterm=NONE
-hi FoldColumn   ctermfg=24              ctermbg=252             cterm=NONE
-hi Folded       ctermfg=24              ctermbg=252             cterm=NONE
-hi IncSearch    ctermfg=255             ctermbg=160             cterm=NONE
-hi LineNr       ctermfg=253             ctermbg=110             cterm=NONE
-hi NonText      ctermfg=110             ctermbg=255             cterm=NONE
-hi Pmenu        ctermfg=fg              ctermbg=195             cterm=NONE
-hi PmenuSbar    ctermfg=255             ctermbg=153             cterm=NONE
-hi PmenuSel     ctermfg=255             ctermbg=21              cterm=NONE
-hi PmenuThumb   ctermfg=111             ctermbg=255             cterm=NONE
-hi SignColumn   ctermfg=110             ctermbg=254             cterm=NONE
-hi Search       ctermfg=255             ctermbg=160             cterm=NONE
-hi SpecialKey   ctermfg=255             ctermbg=144             cterm=NONE
-hi SpellBad     ctermfg=16              ctermbg=229             cterm=NONE
-hi SpellCap     ctermfg=16              ctermbg=231             cterm=NONE
-hi SpellLocal   ctermfg=16              ctermbg=231             cterm=NONE
-hi SpellRare    ctermfg=16              ctermbg=226             cterm=NONE
-hi StatusLine   ctermfg=255             ctermbg=24              cterm=NONE
-hi StatusLineNC ctermfg=253             ctermbg=110             cterm=NONE
-hi Title        ctermfg=75              ctermbg=255             cterm=NONE
-hi VertSplit    ctermfg=255             ctermbg=24              cterm=NONE
-hi Visual       ctermfg=255             ctermbg=153             cterm=NONE
-hi WildMenu     ctermfg=16              ctermbg=117             cterm=NONE
-
-" 1}}}
-
-"  Syntax {{{1
-" =============================================================================
-
-"  General {{{2
-" -----------------------------------------------------------------------------
-" Groups ('*' = major; see 'help group-name'):
-"   *Comment        any comment
-"   *Constant       any constant
-"       String         a string constant: "this is a string"
-"       Character      a character constant: 'c', '\n'
-"       Number         a number constant: 234, 0xff
-"       Boolean        a boolean constant: TRUE, false
-"       Float          a floating point constant: 2.3e10
-"   *Identifier     any variable name
-"       Function       function name (also: methods for classes)
-"   *Statement      any statement
-"       Conditional    if, then, else, endif, switch, etc.
-"       Repeat         for, do, while, etc.
-"       Label          case, default, etc.
-"       Operator       "sizeof", "+", "*", etc.
-"       Keyword        any other keyword
-"       Exception      try, catch, throw
-"   *PreProc        generic Preprocessor
-"       Include        preprocessor #include
-"       Define         preprocessor #define
-"       Macro          same as Define
-"       PreCondit      preprocessor #if, #else, #endif, etc.
-"   *Type           int, long, char, etc.
-"       StorageClass   static, register, volatile, etc.
-"       Structure      struct, union, enum, etc.
-"       Typedef        A typedef
-"   *Special        any special symbol
-"       SpecialChar    special character in a constant
-"       Tag            you can use CTRL-] on this
-"       Delimiter      character that needs attention
-"       SpecialComment special things inside a comment
-"       Debug          debugging statements
-"   *Error          any erroneous construct
-"   *Todo           anything that needs extra attention
-" hi Comment      guifg=#A2B5CD         guibg=NONE      gui=italic
-hi Comment      guifg=#96AAC2         guibg=NONE      gui=italic
-hi Constant     guifg=DarkOrange        guibg=NONE      gui=NONE
-    hi String   guifg=Aquamarine4       guibg=NONE      gui=NONE
-    hi Boolean  guifg=IndianRed4        guibg=NONE      gui=NONE
-hi Identifier   guifg=brown3            guibg=NONE      gui=NONE
-hi Function     guifg=VioletRed4        guibg=NONE      gui=NONE
-hi Statement    guifg=blue1             guibg=NONE      gui=NONE
-hi Keyword      guifg=DodgerBlue        guibg=NONE      gui=NONE
-hi PreProc      guifg=blue1             guibg=NONE      gui=NONE
-hi Type         guifg=LightSlateBlue    guibg=NONE      gui=NONE
-hi Special      guifg=DarkOliveGreen4   guibg=NONE      gui=NONE
-hi Ignore       guifg=bg                guibg=NONE      gui=NONE
-hi Error        guifg=Red               guibg=NONE      gui=underline
-hi Todo         guifg=tan4              guibg=NONE      gui=underline
-" 2}}}
-
-"  Vim {{{2
-" -----------------------------------------------------------------------------
-hi VimError         guifg=red            guibg=Black   gui=bold
-hi VimCommentTitle  guifg=DarkSlateGray4 guibg=bg      gui=bold,italic
-" 2}}}
-
-" QuickFix {{{2
-" -----------------------------------------------------------------------------
-
-" syn match qfFileName  "^[^|]*" nextgroup=qfSeparator
-" syn match qfSeparator "|" nextgroup=qfLineNr contained
-" syn match qfLineNr    "[^|]*" contained contains=qfError
-" syn match qfError     "error" contained
-hi qfFileName  guifg=LightSkyBlue4     guibg=NONE      gui=italic
-hi qfLineNr    guifg=coral             guibg=NONE      gui=bold
-hi qfError     guifg=red               guibg=NONE      gui=bold
-" 2}}}
-
-" Python {{{2
-" -----------------------------------------------------------------------------
-hi pythonDecorator  guifg=orange3 guibg=NONE gui=bold
-hi link pythonDecoratorFunction pythonDecorator
-" 2}}}
-
-" Diff {{{2
-" -----------------------------------------------------------------------------
-hi diffOldFile          guifg=#006666           guibg=NONE      gui=NONE
-hi diffNewFile          guifg=#0088FF           guibg=NONE      gui=bold
-hi diffFile             guifg=#0000FF           guibg=NONE      gui=NONE
-hi link diffOnly        Constant
-hi link diffIdentical   Constant
-hi link diffDiffer      Constant
-hi link diffBDiffer     Constant
-hi link diffIsA         Constant
-hi link diffNoEOL       Constant
-hi link diffCommon      Constant
-hi diffRemoved          guifg=#BB0000           guibg=NONE      gui=NONE
-hi diffChanged          guifg=DarkSeaGreen      guibg=NONE      gui=NONE
-hi diffAdded            guifg=#00AA00           guibg=NONE      gui=NONE
-hi diffLine             guifg=thistle4          guibg=NONE      gui=italic
-hi link diffSubname     diffLine
-hi link diffComment     Comment
-" 2}}}
-
-" PHP (contributed by Ryan Kulla) {{{2
-" -----------------------------------------------------------------------------
-" Ryan Kulla's addition for PHP syntax highlighting (for regular/terminal vim)
-hi phpConditional ctermfg=21 cterm=NONE guifg=black
-hi phpIdentifier ctermfg=0 cterm=NONE guifg=black
-hi phpOperator ctermfg=black cterm=NONE guifg=black
-hi phpRegion ctermfg=132 cterm=NONE guifg=VioletRed4
-hi phpComparison ctermfg=black cterm=NONE guifg=black
-hi phpType ctermfg=darkgreen cterm=NONE guifg=darkgreen
-hi phpParent ctermfg=black cterm=NONE guifg=black
-hi phpMethodsVar ctermfg=132 cterm=NONE guifg=VioletRed4
-hi phpStatement ctermfg=21 cterm=NONE guifg=blue
-hi phpStorageClass ctermfg=21 cterm=NONE guifg=blue
-hi phpStringSingle ctermfg=30 cterm=NONE guifg=Aquamarine4
-hi phpStringDouble ctermfg=30 cterm=NONE guifg=Aquamarine4
-hi phpFunctions ctermfg=21 cterm=NONE guifg=blue
-hi phpSpecialFunction ctermfg=21 cterm=NONE guifg=blue
-hi phpRepeat ctermfg=21 cterm=NONE guifg=blue
-hi phpNumber ctermfg=214 cterm=bold guifg=brown
-hi phpTodo ctermfg=red cterm=bold guifg=red gui=bold
-hi phpDefine ctermfg=21 cterm=NONE guifg=blue
-hi phpConstant ctermfg=21 cterm=NONE guifg=black
-hi phpCoreConstant ctermfg=21 cterm=NONE guifg=black
-hi phpMemberSelector ctermfg=black cterm=NONE guifg=black
-hi phpLabel ctermfg=21 cterm=NONE guifg=blue
-hi phpStructure ctermfg=black cterm=NONE guifg=black
-hi phpRelation ctermfg=black cterm=NONE guifg=black
-hi phpEnvVar ctermfg=black cterm=NONE guifg=black
-hi phpIntVar ctermfg=0 cterm=bold guifg=black gui=bold
-hi phpBoolean ctermfg=58 cterm=NONE guifg=brown
-" 2}}}
-
-" 1}}}
-
diff --git a/sources_non_forked/nerdtree/.github/ISSUE_TEMPLATE/bug.md b/sources_non_forked/nerdtree/.github/ISSUE_TEMPLATE/bug.md
deleted file mode 100644
index dd35135..0000000
--- a/sources_non_forked/nerdtree/.github/ISSUE_TEMPLATE/bug.md
+++ /dev/null
@@ -1,45 +0,0 @@
----
-name: "Bug Report"
-about: "NERDTree is misbehaving? Tell us about it."
-labels: bug
----
-<!-- Attention! Please Read!
-
-Please fill out ALL the information below so that the issue can be fully
-understood. Omitting information will delay the resolution of your issue. It
-will be labeled "Needs More Info", and may be closed until there is enough
-information.
-
-Keep in mind that others may have the same question in the future. The better
-your information, the more likely they'll be able to help themselves. -->
-
-#### Self-Diagnosis
-<!-- Check the boxes after creating the issue, or use [x]. -->
-- [ ] I have searched the [issues](https://github.com/scrooloose/nerdtree/issues) for an answer to my question.
-- [ ] I have reviewed the NERDTree documentation. `:h NERDTree`
-- [ ] I have reviewed the [Wiki](https://github.com/scrooloose/nerdtree/wiki).
-- [ ] I have searched the web for an answer to my question.
-
-#### Environment (for bug reports)
-- [ ] Operating System: 
-- [ ] Vim/Neovim version `:echo v:version`: 
-- [ ] NERDTree version, found on 1st line in NERDTree quickhelp `?`: 
-- [ ] vimrc settings
-    - [ ] NERDTree variables
-    ```vim
-    ```
-    - Other NERDTree-dependent Plugins
-        - [ ] jistr/vim-nerdtree-tabs
-        - [ ] ryanoasis/vim-devicons
-        - [ ] tiagofumo/vim-nerdtree-syntax-highlight
-        - [ ] Xuyuanp/nerdtree-git-plugin
-        - [ ] Others (specify): 
-    - [ ] I've verified the issue occurs with only NERDTree installed.
-
-#### Steps to Reproduce the Issue
-1. 
-
-#### Current Result (Include screenshots where appropriate.)
-
-#### Expected Result
-
diff --git a/sources_non_forked/nerdtree/.github/ISSUE_TEMPLATE/feature_request.md b/sources_non_forked/nerdtree/.github/ISSUE_TEMPLATE/feature_request.md
deleted file mode 100644
index 35db0f6..0000000
--- a/sources_non_forked/nerdtree/.github/ISSUE_TEMPLATE/feature_request.md
+++ /dev/null
@@ -1,8 +0,0 @@
----
-name: "Feature Request"
-about: "What new feature are you requesting for NERDTree?"
-labels: "feature request"
----
-
-#### Description
-
diff --git a/sources_non_forked/nerdtree/.github/ISSUE_TEMPLATE/question.md b/sources_non_forked/nerdtree/.github/ISSUE_TEMPLATE/question.md
deleted file mode 100644
index 25f15b0..0000000
--- a/sources_non_forked/nerdtree/.github/ISSUE_TEMPLATE/question.md
+++ /dev/null
@@ -1,24 +0,0 @@
----
-name: "General Question"
-about: "Having trouble setting up NERDTree? Need clarification on a setting? Ask your question here."
-labels: "general question"
----
-<!-- Attention! Please Read!
-
-Please fill out ALL the information below so that the issue can be fully
-understood. Omitting information will delay the resolution of your issue. It
-will be labeled "Needs More Info", and may be closed until there is enough
-information.
-
-Keep in mind that others may have the same question in the future. The better
-your information, the more likely they'll be able to help themselves. -->
-
-#### Self-Diagnosis
-<!-- Check the boxes after creating the issue, or use [x]. -->
-- [ ] I have searched the [issues](https://github.com/scrooloose/nerdtree/issues) for an answer to my question.
-- [ ] I have reviewed the NERDTree documentation. `:h NERDTree`
-- [ ] I have reviewed the [Wiki](https://github.com/scrooloose/nerdtree/wiki).
-- [ ] I have searched the web for an answer to my question.
-
-#### State Your Question
-
diff --git a/sources_non_forked/nerdtree/.github/PULL_REQUEST_TEMPLATE.md b/sources_non_forked/nerdtree/.github/PULL_REQUEST_TEMPLATE.md
deleted file mode 100644
index 24dba3f..0000000
--- a/sources_non_forked/nerdtree/.github/PULL_REQUEST_TEMPLATE.md
+++ /dev/null
@@ -1,16 +0,0 @@
-### Description of Changes
-Closes #  <!-- Issue number this PR addresses. If none, remove this line. -->
-
-
----
-### New Version Info
-
-#### Author's Instructions
-- [ ] Derive a new `MAJOR.MINOR.PATCH` version number. Increment the:
-    - `MAJOR` version when you make incompatible API changes
-    - `MINOR` version when you add functionality in a backwards-compatible manner
-    - `PATCH` version when you make backwards-compatible bug fixes
-- [ ] Update [CHANGELOG.md](https://github.com/scrooloose/nerdtree/blob/master/CHANGELOG.md), following the established pattern.
-#### Collaborator's Instructions
-- [ ] Review [CHANGELOG.md](https://github.com/scrooloose/nerdtree/blob/master/CHANGELOG.md), suggesting a different version number if necessary.
-- [ ] After merge, tag the merge commit, e.g. `git tag -a 3.1.4 -m "v3.1.4" && git push origin --tags`
diff --git a/sources_non_forked/nerdtree/.github/workflows/vint.yml b/sources_non_forked/nerdtree/.github/workflows/vint.yml
deleted file mode 100644
index 36d7258..0000000
--- a/sources_non_forked/nerdtree/.github/workflows/vint.yml
+++ /dev/null
@@ -1,15 +0,0 @@
-name: Vint
-on: [push, pull_request]
-jobs:
-  vint:
-    strategy:
-      fail-fast: false
-    runs-on: ubuntu-latest
-    steps:
-    - name: Checkout
-      uses: actions/checkout@master
-    - name: Run vint with reviewdog
-      uses: reviewdog/action-vint@v1.0.1
-      with:
-        github_token: ${{ secrets.github_token }}
-        reporter: github-pr-review
diff --git a/sources_non_forked/nerdtree/.gitignore b/sources_non_forked/nerdtree/.gitignore
deleted file mode 100644
index 3698c0e..0000000
--- a/sources_non_forked/nerdtree/.gitignore
+++ /dev/null
@@ -1,3 +0,0 @@
-*~
-*.swp
-tags
diff --git a/sources_non_forked/nerdtree/.vintrc.yaml b/sources_non_forked/nerdtree/.vintrc.yaml
deleted file mode 100644
index c44b6ab..0000000
--- a/sources_non_forked/nerdtree/.vintrc.yaml
+++ /dev/null
@@ -1,5 +0,0 @@
-cmdargs:
-  severity: style_problem
-  color: true
-  env:
-    neovim: false
diff --git a/sources_non_forked/nerdtree/CHANGELOG.md b/sources_non_forked/nerdtree/CHANGELOG.md
deleted file mode 100644
index 0f1f1f5..0000000
--- a/sources_non_forked/nerdtree/CHANGELOG.md
+++ /dev/null
@@ -1,275 +0,0 @@
-# NERDTree Change Log
-<!-- Introduce a new MAJOR or MINOR version with a 4-hash header.
-     PATCH versions are listed from newest to oldest under their respective MAJOR.MINOR
-     version in an unordered list.  The format is:
-        - **.PATCH**: Pull Request Title (PR Author) [PR Number](Link to PR)
--->
-#### 6.8
-- **.0**: Allow concealed characters to show another character. (PhilRunninger) [#1138](https://github.com/preservim/nerdtree/pull/1138)
-#### 6.7
-- **.15**: Add curly braces to the list of characters to be escaped. (PhilRunninger) [#1128](https://github.com/preservim/nerdtree/pull/1128)
-- **.14**: Use backward-compatible `nerdtree#and()` in one place that was missed. (PhilRunninger) [#1134](https://github.com/preservim/nerdtree/pull/1134)
-- **.13**: `cmd.exe /c start "" <filename>` for windows default viewer support. (J. Altay) [#1130](https://github.com/preservim/nerdtree/pull/1130)
-- **.12**: Fixed a bug that caused the file-tree construction to slow down significantly. (Eugenij-W) [#1126](https://github.com/preservim/nerdtree/pull/1126)
-- **.11**: Fix exception in NERDTreeFind (on windows OS and If the file is located in the root directory of the disk) (Eugenij-W) [#1122](https://github.com/preservim/nerdtree/pull/1122)
-- **.10**: Do not consider the tree root to be "cascadable". (lifecrisis) [#1120](https://github.com/preservim/nerdtree/pull/1120)
-- **.9**: Force `:NERDTreeFocus` to allow events to be fired when switching windows. (PhilRunninger) [#1118](https://github.com/preservim/nerdtree/pull/1118)
-- **.8**: Fix example code for the `NERDTreeAddKeyMap()` function. (PhilRunninger) [#1116](https://github.com/preservim/nerdtree/pull/1116)
-- **.7**: Put `'%'` argument in `bufname()` for backwards compatibility. (PhilRunninger) [#1105](https://github.com/preservim/nerdtree/pull/1105)
-- **.6**: If a file's already open in the window, don't edit it again. (PhilRunninger) [#1103](https://github.com/preservim/nerdtree/pull/1103)
-- **.5**: Prevent unneeded tree creation in `:NERDTreeToggle[VCS] <path>` (PhilRunninger) [#1101](https://github.com/preservim/nerdtree/pull/1101)
-- **.4**: Add missing calls to the `shellescape()` function (lifecrisis) [#1099](https://github.com/preservim/nerdtree/pull/1099)
-- **.3**: Fix vsplit to not open empty buffers when opening previously closed file (AwkwardKore) [#1098](https://github.com/preservim/nerdtree/pull/1098)
-- **.2**: Fix infinity loop (on winvim) in FindParentVCSRoot (Eugenij-W) [#1095](https://github.com/preservim/nerdtree/pull/1095)
-- **.1**: File Move: Escape existing directory name when looking for open files. (PhilRunninger) [#1094](https://github.com/preservim/nerdtree/pull/1094)
-- **.0**: Open the parent directory when revealing a non-existent file with :NERDTreeFind (bouk) [#1090](https://github.com/preservim/nerdtree/pull/1090)
-#### 6.6
-- **.1**: [add] How to install using dein.vim (kazukazuinaina) [#1087](https://github.com/preservim/nerdtree/pull/1087)
-- **.0**: Add the ability to turn off directory arrows (PhilRunninger) [#1085](https://github.com/preservim/nerdtree/pull/1085)
-#### 6.5
-- **.0**: `NERDTreeToggle <start-directory>` always sets NERDTree root. (PhilRunninger) [#1083](https://github.com/preservim/nerdtree/pull/1083)
-#### 6.4
-- **.6**: NERDTreeFind shows expected message if file doesn't exist e.g. with vim-startify (andys8). [#1081](https://github.com/preservim/nerdtree/pull/1081)
-- **.5**: Ensure events are (or aren't) being ignored correctly. (PhilRunninger) [#1080](https://github.com/preservim/nerdtree/pull/1080)
-- **.4**: Prevent overwriting existing files/dirs on node move. (PhilRunninger) [#1079](https://github.com/preservim/nerdtree/pull/1079)
-- **.3**: Fix regex that finds keyword for minimal menu. (PhilRunninger) [#1075](https://github.com/preservim/nerdtree/pull/1075)
-- **.2**: Lint vimscript, fix errors and warnings, add CI job to review PRs (Caleb Maclennan) [#1071](https://github.com/preservim/nerdtree/pull/1071)
-- **.1**: Ensure backward compatibility. v:t_func is not available before Vim 8.0 (Phil Runninger)
-- **.0**: Allow use of function references as callbacks (HiPhish) [#1067](https://github.com/preservim/nerdtree/pull/1067)
-#### 6.3
-- **.0**: Add new command that behaves like NERDTreeToggle but defaults to the root of a VCS repository. (willfindlay) [#1060](https://github.com/preservim/nerdtree/pull/1060)
-#### 6.2
-- **.1**: Menu option, 'copy path to clipboard' is aware of VIM clipboard option (jhzn) [#1056](https://github.com/preservim/nerdtree/pull/1056)
-- **.0**: Support tab-specific CWDs (PhilRunninger) [#1032](https://github.com/preservim/nerdtree/pull/1032)
-#### 6.1
-- **.4**: Add VIM built-in package management to read me file. (pesarkhobeee) [#1049](https://github.com/preservim/nerdtree/pull/1049)
-- **.3**: Save/Set screen state also on WinLeave and WinEnter. (PhilRunninger) [#1048](https://github.com/preservim/nerdtree/pull/1048)
-- **.2**: Wrap saveScreenState's statements in a try-catch block. (PhilRunninger) [#1047](https://github.com/preservim/nerdtree/pull/1047)
-- **.1**: Catch errors when trying to read CHANGELOG.md. (PhilRunninger) [#1045](https://github.com/preservim/nerdtree/pull/1045)
-- **.0**: If file path doesn't exist, :NERDTreeFind its parent directory instead. (PhilRunninger) [#1043](https://github.com/preservim/nerdtree/pull/1043)
-#### 6.0
-- **.1**: Reintroduce necessary variable mistakenly removed. (PhilRunninger) [#1040](https://github.com/preservim/nerdtree/pull/1040)
-- **.0**: Make the behavior of window splits consistent (dragonxlwang, PhilRunninger) [#1035](https://github.com/preservim/nerdtree/pull/1035)
-#### 5.3
-- **.3**: Fix (p)ath not displaying in the minimal menu (tuzz) [#1038](https://github.com/preservim/nerdtree/pull/1038)
-- **.2**: Enable events when closing NerdTree window. (PhilRunninger) [#1037](https://github.com/preservim/nerdtree/pull/1037)
-- **.1**: Fix the `e` key mapping to use netrw if desired (PhilRunninger) [#1031](https://github.com/preservim/nerdtree/pull/1031)
-- **.0**: Add file extension and size to sorting capabilities (PhilRunninger) [#1029](https://github.com/preservim/nerdtree/pull/1029)
-#### 5.2
-- **.9**: Suppress events for intermediate window/tab/buffer changes (PhilRunninger) [#1026](https://github.com/preservim/nerdtree/pull/1026)
-- **.8**: Revert [#1019](https://github.com/preservim/nerdtree/pull/1019) to fix nvim artifacts and flickering. (PhilRunninger) [#1021](https://github.com/preservim/nerdtree/pull/1021)
-- **.7**: Use :mode only in neovim. MacVim still needs to use :redraw! (PhilRunninger) [#1019](https://github.com/preservim/nerdtree/pull/1019)
-- **.6**: In CHANGELOG.md and PR template, make reference to PR a true HTML link. (PhilRunninger) [#1017](https://github.com/preservim/nerdtree/pull/1017)
-- **.5**: Use `:mode` instead of `:redraw!` when updating menu. (PhilRunninger) [#1016](https://github.com/preservim/nerdtree/pull/1016)
-- **.4**: When searching for root line num, stop at end of file. (PhilRunninger) [#1015](https://github.com/preservim/nerdtree/pull/1015)
-- **.3**: Fix `<CR>` key map on the bookmark (lkebin) [#1014](https://github.com/preservim/nerdtree/pull/1014)
-- **.2**: Make Enter work on the `.. ( up a dir )` line (PhilRunninger) [#1013](https://github.com/preservim/nerdtree/pull/1013)
-- **.1**: Fix nerdtree#version() on Windows. (PhilRunninger)
-- **.0**: Expand functionality of `<CR>` mapping. (PhilRunninger) [#1011](https://github.com/preservim/nerdtree/pull/1011)
-#### 5.1
-- **.3**: Remove @mentions from PR template and change log. They weren't working. (PhilRunninger) [#1009](https://github.com/preservim/nerdtree/pull/1009)
-- **.2**: Fix NERDTree opening with the wrong size. (PhilRunninger) [#1008](https://github.com/preservim/nerdtree/pull/1008)
-- **.1**: Update Changelog and create PR Template (PhilRunninger) [#1007](https://github.com/preservim/nerdtree/pull/1007)
-- **.0**: Too many changes for one patch...
-    - Refresh a dir_node if the file wasn't found in it, and look once more. (PhilRunninger) [#1005](https://github.com/preservim/nerdtree/pull/1005)
-    - Add a "copy path to clipboard" menu option (PhilRunninger) [#1002](https://github.com/preservim/nerdtree/pull/1002)
-    - Enable root refresh on "vim ." a different way than [#999](https://github.com/preservim/nerdtree/pull/999). (PhilRunninger) [#1001](https://github.com/preservim/nerdtree/pull/1001)
-    - Fix refreshroot (PhilRunninger) [#999](https://github.com/preservim/nerdtree/pull/999)
-    - Change version check to look for 703 not 730 (vhalis) [#994](https://github.com/preservim/nerdtree/pull/994)
-    - Change minimum vim (PhilRunninger) [#991](https://github.com/preservim/nerdtree/pull/991)
-    - Allow multi-character DirArrows (PhilRunninger) [#985](https://github.com/preservim/nerdtree/pull/985)
-    - Remove redraw! while still clearing last message empty string. (PhilRunninger) [#979](https://github.com/preservim/nerdtree/pull/979)
-    - fix `_initChildren` function value set to numChildrenCached error (terryding77) [#969](https://github.com/preservim/nerdtree/pull/969)
-    - On Windows, do a case-insensitive comparison of paths. (PhilRunninger) [#967](https://github.com/preservim/nerdtree/pull/967)
-    - Remove the **Please wait... DONE** messages. (PhilRunninger) [#966](https://github.com/preservim/nerdtree/pull/966)
-    - Smarter delimiter default (PhilRunninger) [#963](https://github.com/preservim/nerdtree/pull/963)
-    - Update directory .vimdc readme example (spencerdcarlson) [#961](https://github.com/preservim/nerdtree/pull/961)
-    - Preview bookmarks (PhilRunninger) [#956](https://github.com/preservim/nerdtree/pull/956)
-    - Add new value to NERDTreeQuitOnOpen to close bookmark table (PhilRunninger) [#955](https://github.com/preservim/nerdtree/pull/955)
-    - Add an :EditBookmarks command to edit the bookmarks file (PhilRunninger) [#954](https://github.com/preservim/nerdtree/pull/954)
-    - Before copying, turn off &shellslash. Restore after copy is finished. (PhilRunninger) [#952](https://github.com/preservim/nerdtree/pull/952)
-    - Set a maximum window size when zooming. (PhilRunninger) [#950](https://github.com/preservim/nerdtree/pull/950)
-    - Confirm the wipeout of a unsaved buffer whose file has been renamed. (PhilRunninger) [#949](https://github.com/preservim/nerdtree/pull/949)
-    - Escape a backslash so it can be used in a key mapping. (PhilRunninger) [#948](https://github.com/preservim/nerdtree/pull/948)
-    - Add a NERDTreeMinimalMenu feature (tuzz) [#938](https://github.com/preservim/nerdtree/pull/938)
-    - fixed root path error for windows (zcodes) [#935](https://github.com/preservim/nerdtree/pull/935)
-    - Restore getDirChildren for use in nerdtree-project-plugin. (PhilRunninger) [#929](https://github.com/preservim/nerdtree/pull/929)
-    - Document NERDTreeNodeDelimiter [#912](https://github.com/preservim/nerdtree/pull/912) (PhilRunninger) [#926](https://github.com/preservim/nerdtree/pull/926)
-    - Allow modification of menu keybindings (Leandros) [#923](https://github.com/preservim/nerdtree/pull/923)
-    - Add two more disqualifications for isCascadable(). (PhilRunninger) [#914](https://github.com/preservim/nerdtree/pull/914)
-    - Allow highlighting more than one flag. (kristijanhusak) [#908](https://github.com/preservim/nerdtree/pull/908)
-    - Support sorting files and directories by modification time. (PhilRunninger) [#901](https://github.com/preservim/nerdtree/pull/901)
-    - Parse . and .. from path string with trailing slash. (PhilRunninger) [#899](https://github.com/preservim/nerdtree/pull/899)
-    - Force sort to recalculate the cached sortKey. (PhilRunninger) [#898](https://github.com/preservim/nerdtree/pull/898)
-    - Add NERDTreeRefreshRoot command (wgfm) [#897](https://github.com/preservim/nerdtree/pull/897)
-    - Call Resolve on the file's path when calling :NERDTreeFind. (PhilRunninger) [#896](https://github.com/preservim/nerdtree/pull/896)
-    - Catch all errors, not just NERDTree errors. (PhilRunninger) [#894](https://github.com/preservim/nerdtree/pull/894)
-    - Fix typo in help file (lvoisin) [#892](https://github.com/preservim/nerdtree/pull/892)
-    - Make NERDTreeCreator set the `'nolist'` option (lifecrisis) [#889](https://github.com/preservim/nerdtree/pull/889)
-    - Refresh buffers after `m`, `m` operation on a folder (PhilRunninger) [#888](https://github.com/preservim/nerdtree/pull/888)
-    - Use a better arg for FINDSTR when using the m,l command in Windows. (PhilRunninger) [#887](https://github.com/preservim/nerdtree/pull/887)
-    - Fix the <C-J>/<C-K> motions, which currently fail with cascades (lifecrisis) [#886](https://github.com/preservim/nerdtree/pull/886)
-    - Function "s:UI.getLineNum()" doesn't always work on cascades. (lifecrisis) [#882](https://github.com/preservim/nerdtree/pull/882)
-    - NERDTreeCWD: reset CWD if changed by NERDTreeFocus (PhilRunninger) [#878](https://github.com/preservim/nerdtree/pull/878)
-    - Use <count>tabnext instead of <count>gt to allow users to remap gt. (PhilRunninger) [#877](https://github.com/preservim/nerdtree/pull/877)
-    - Do a case sensitive comparison of new/existing buffers. (PhilRunninger) [#875](https://github.com/preservim/nerdtree/pull/875)
-    - Fix opening sub-directories that have commas in their name. (PhilRunninger) [#873](https://github.com/preservim/nerdtree/pull/873)
-    - Add new command to open NERDTree in the root of a VCS repository. (PhilRunninger) [#872](https://github.com/preservim/nerdtree/pull/872)
-    - Make sure the path to the bookmarks file exists before writing it. (PhilRunninger) [#871](https://github.com/preservim/nerdtree/pull/871)
-    - Unzoom NERDTree when opening a file (PhilRunninger) [#870](https://github.com/preservim/nerdtree/pull/870)
-    - Support unusual characters in file and directory names (PhilRunninger) [#868](https://github.com/preservim/nerdtree/pull/868)
-    - Reword renamed-buffer prompt to be more clear (aflock) [#867](https://github.com/preservim/nerdtree/pull/867)
-    - Default to placing cursor on root when closing bookmark table (lifecrisis) [#866](https://github.com/preservim/nerdtree/pull/866)
-    - Fix issues with sorting of nodes (PhilRunninger) [#856](https://github.com/preservim/nerdtree/pull/856)
-    - Better OSX detection (bubba-h57) [#853](https://github.com/preservim/nerdtree/pull/853)
-    - Bugfix - ensure keymaps dictionary exists before using it (mnussbaum) [#852](https://github.com/preservim/nerdtree/pull/852)
-    - Decrease startup-time by avoiding linear-time iteration over key mappings (mnussbaum) [#851](https://github.com/preservim/nerdtree/pull/851)
-    - Add code to sort mappings in quickhelp (lifecrisis) [#849](https://github.com/preservim/nerdtree/pull/849)
-    - Use ":clearjumps" in new NERDTree windows (lifecrisis) [#844](https://github.com/preservim/nerdtree/pull/844)
-    - Like m-c did before, create parent directories if needed on m-m. (PhilRunninger) [#840](https://github.com/preservim/nerdtree/pull/840)
-    - BUGFIX: Repair a problem with the `'u'` mapping. (lifecrisis) [#838](https://github.com/preservim/nerdtree/pull/838)
-    - Make the NERDTree buffer writable when rendering it. (PhilRunninger) [#837](https://github.com/preservim/nerdtree/pull/837)
-    - Code cleanup: Remove unsupported bookmark table mappings (lifecrisis) [#835](https://github.com/preservim/nerdtree/pull/835)
-    - Replace strcharpart() with substitute() for backward compatibility (bravestarr) [#834](https://github.com/preservim/nerdtree/pull/834)
-    - Fixed error `unknown function strcharpart` for older versions of Vim (hav4ik) [#833](https://github.com/preservim/nerdtree/pull/833)
-    - Clear output when NERDTree menu is aborted (lifecrisis) [#832](https://github.com/preservim/nerdtree/pull/832)
-    - Display a path with multi-byte characters correctly when it is truncated (bravestarr) [#830](https://github.com/preservim/nerdtree/pull/830)
-    - Support revealing file and executing file with xdg-open for Linux (ngnmhieu) [#824](https://github.com/preservim/nerdtree/pull/824)
-    - If node isn't open, count children on disk before deleting. (PhilRunninger) [#822](https://github.com/preservim/nerdtree/pull/822)
-    - Add new variable g:NERDTreeRemoveFileCmd (kutsan) [#816](https://github.com/preservim/nerdtree/pull/816)
-    - Use a better check for existence of the NERDTree buffer. (PhilRunninger) [#814](https://github.com/preservim/nerdtree/pull/814)
-    - Fix focussing previous buffer when closing NERDTree (mrubli) [#801](https://github.com/preservim/nerdtree/pull/801)
-    - Update the docs for "NERDTreeStatusline" (lifecrisis) [#796](https://github.com/preservim/nerdtree/pull/796)
-    - BUGFIX: Unstable behavior in the "getPath()" method (lifecrisis) [#795](https://github.com/preservim/nerdtree/pull/795)
-    - Revert the bugfix from pull request [#785](https://github.com/preservim/nerdtree/pull/785) (lifecrisis) [#794](https://github.com/preservim/nerdtree/pull/794)
-    - BUGFIX: Allow ":NERDTreeFind" to discover hidden files (lifecrisis) [#786](https://github.com/preservim/nerdtree/pull/786)
-    - BUGFIX: Allow ":NERDTreeFind" to reveal new files (lifecrisis) [#785](https://github.com/preservim/nerdtree/pull/785)
-    - Add modelines (lifecrisis) [#782](https://github.com/preservim/nerdtree/pull/782)
-    - Change the type of completion used by NERDTreeFind (lifecrisis) [#781](https://github.com/preservim/nerdtree/pull/781)
-    - change NERDTreeFind with args (zhenyangze) [#778](https://github.com/preservim/nerdtree/pull/778)
-    - Style Choice: Using confirm() when deleting a bookmark (lifecrisis) [#777](https://github.com/preservim/nerdtree/pull/777)
-    - remove useless substitute when `file =~# "/$"` (skyblueee) [#773](https://github.com/preservim/nerdtree/pull/773)
-    - remove useless removeLeadingSpaces in _stripMarkup (skyblueee) [#772](https://github.com/preservim/nerdtree/pull/772)
-    - Make the "o" mapping consistent with "x" (lifecrisis) [#769](https://github.com/preservim/nerdtree/pull/769)
-    - Fix a problem with the "x" handler (lifecrisis) [#768](https://github.com/preservim/nerdtree/pull/768)
-    - Clean up the handler for the "x" mapping (lifecrisis) [#767](https://github.com/preservim/nerdtree/pull/767)
-    - Revert change to tab opening method (lifecrisis) [#766](https://github.com/preservim/nerdtree/pull/766)
-    - BUGFIX: Add back support for "b:NERDTreeRoot" (lifecrisis) [#765](https://github.com/preservim/nerdtree/pull/765)
-    - Fix broken "t" and "T" mappings, tabs now open at end (lifecrisis) [#759](https://github.com/preservim/nerdtree/pull/759)
-    - Update doc with already existing mapping variables (asnr) [#699](https://github.com/preservim/nerdtree/pull/699)
-    - Fix the broken g:NERDTreeBookmarksSort setting (lifecrisis) [#696](https://github.com/preservim/nerdtree/pull/696)
-    - Correct NERDTreeIgnore pattern in doc (cntoplolicon) [#648](https://github.com/preservim/nerdtree/pull/648)
-    - Remove empty segments when splitting path (sooth-sayer) [#574](https://github.com/preservim/nerdtree/pull/574)
-    - Suppress autocmds less agressively (wincent) [#578](https://github.com/preservim/nerdtree/pull/578) [#691](https://github.com/preservim/nerdtree/pull/691)
-    - Add an Issues template to ask for more info initially.
-    - Fix markdown headers in readme (josephfrazier) [#676](https://github.com/preservim/nerdtree/pull/676)
-    - Don't touch `@o` and `@h` registers when rendering
-    - Fix bug with files and directories with dollar signs (alegen) [#649](https://github.com/preservim/nerdtree/pull/649)
-    - Reuse/reopen existing window trees where possible [#244](https://github.com/preservim/nerdtree/pull/244)
-    - Remove NERDTree.previousBuf()
-    - Change color of arrow (Leeiio) [#630](https://github.com/preservim/nerdtree/pull/630)
-    - Improved a tip in README.markdown (ggicci) [#628](https://github.com/preservim/nerdtree/pull/628)
-    - Shorten delete confimration of empty directory to `y` (mikeperri) [#530](https://github.com/preservim/nerdtree/pull/530)
-    - Fix API call to open directory tree in window (devm33) [#533](https://github.com/preservim/nerdtree/pull/533)
-    - Change default arrows on non-Windows platforms (gwilk) [#546](https://github.com/preservim/nerdtree/pull/546)
-    - Update to README - combine cd and git clone (zwhitchcox) [#584](https://github.com/preservim/nerdtree/pull/584)
-    - Update to README - Tip: start NERDTree when vim starts (therealplato) [#593](https://github.com/preservim/nerdtree/pull/593)
-    - Escape filename when moving an open buffer (zacharyvoase) [#595](https://github.com/preservim/nerdtree/pull/595)
-    - Fixed incorrect :helptags command in README (curran) [#619](https://github.com/preservim/nerdtree/pull/619)
-    - Fixed incomplete escaping of folder arrows (adityanatraj) [#548](https://github.com/preservim/nerdtree/pull/548)
-    - Added NERDTreeCascadeSingleChildDir option (juanibiapina) [#558](https://github.com/preservim/nerdtree/pull/558)
-    - Replace strchars() with backward compatible workaround.
-    - Add support for copy command in Windows (SkylerLipthay) [#231](https://github.com/preservim/nerdtree/pull/231)
-    - Fixed typo in README.markdown - :Helptags -> :helptags
-    - Rename "primary" and "secondary" trees to "tab" and "window" trees.
-    - Move a bunch of buffer level variables into the NERDTree and UI classes.
-    - Display cascading dirs on one line to save vertical/horizontal space (matt-gardner: brainstorming/testing)
-    - Remove the old style UI - Remove `NERDTreeDirArrows` option.
-    - On windows default to + and ~ for expand/collapse directory symbols.
-    - Lots more refactoring. Move a bunch of b: level vars into b:NERDTree and friends.
-
-#### 5.0.0
-- Refactor the code significantly:
-    * Break the classes out into their own files.
-    * Make the majority of the code OO - previously large parts were effectively a tangle of "global" methods.
-- Add an API to assign flags to nodes. This allows VCS plugins like https://github.com/Xuyuanp/nerdtree-git-plugin to exist. Thanks to **Xuyuanp** for helping design/test/build said API.
-- add `scope` argument to the key map API see :help NERDTreeAddKeyMap()
-- add magic [[dir]] and [[file]] flags to NERDTreeIgnore
-- add support for custom path filters. See :help NERDTreeAddPathFilter()
-- add path listener API. See :help NERDTreePathListenerAPI.
-- expand the fs menu functionality to list file properties (PhilRunninger, apbarrero, JESii)
-- make bookmarks work with `~` home shortcuts (hiberabyss)
-- show OSX specific fsmenu options in regular vim on mac (evindor)
-- make dir arrow icons configurable (PickRelated)
-- optimise node sorting performance when opening large dirs (vtsang)
-- make the root note render prettier by truncating it at a path slash (gcmt)
-- remove NERDChristmasTree option - its always christmas now
-- add "cascade" open and closing for dirs containing only another single dir. See :help NERDTreeCascadeOpenSingleChildDir (pendulm)
-- Many other fixes, doc updates and contributions from: **actionshrimp**, **agrussellknives**, **alvan**, **AndrewRadev**, **cperl82** (*many small fixes*), **devmanhinton**, **egalpin**, **franksort**, **gastropoda**, **handcraftedbits**, **kelaban**, **lucascaton**, **mixvin**, **pendulm**, **SchDen**, **shanesmith**, **staeff**, **stephenprater**, **toiffel**, **Twinside**, **WoLpH**, **xiaodili**, **zhangoose**
-
-#### 4.2.0
-- Add NERDTreeDirArrows option to make the UI use pretty arrow chars instead of the old +~| chars to define the tree structure (sickill)
-- shift the syntax highlighting out into its own syntax file (gnap)
-- add some mac specific options to the filesystem menu - for macvim only (andersonfreitas)
-- Add NERDTreeMinimalUI option to remove some non functional parts of the nerdtree ui (camthompson)
-- tweak the behaviour of :NERDTreeFind - see :help :NERDTreeFind for the new behaviour (benjamingeiger)
-- if no name is given to :Bookmark, make it default to the name of the target file/dir (minyoung)
-- use `file` completion when doing copying, create, and move operations (EvanDotPro)
-- lots of misc bug fixes from: **AndrewRadev**, **Bogdanov**, **camthompson**, **kml**, **mathias**, **paddyoloughlin**, **scottstvnsn**, **sdewald**, **Vitaly**, **wycats**, me RAWR!
-
-#### 4.1.0
-- features:
-    - NERDTreeFind to reveal the node for the current buffer in the tree, see `|NERDTreeFind|`. This effectively merges the FindInNERDTree plugin (by **Doug McInnes**) into the script.
-    - make NERDTreeQuitOnOpen apply to the t/T keymaps too. Thanks to **Stefan Ritter** and **Rmi Prvost**.
-    - truncate the root node if wider than the tree window. Thanks to **Victor Gonzalez**.
-
-- bugfixes:
-    - really fix window state restoring
-    - fix some win32 path escaping issues. Thanks to **Stephan Baumeister**, **Ricky**, **jfilip1024**, and **Chris Chambers**.
-
-#### 4.0.0
-- add a new programmable menu system (see `:help NERDTreeMenu`).
-- add new APIs to add menus/menu-items to the menu system as well as custom key mappings to the NERD tree buffer (see `:help NERDTreeAPI`).
-- removed the old API functions
-- added a mapping to maximize/restore the size of nerd tree window, thanks to Guillaume Duranceau for the patch. See :help NERDTree-A for details.
-- fix a bug where secondary nerd trees (netrw hijacked trees) and NERDTreeQuitOnOpen didnt play nicely, thanks to **Curtis Harvey**.
-- fix a bug where the script ignored directories whose name ended in a dot, thanks to **Aggelos Orfanakos** for the patch.
-- fix a bug when using the x mapping on the tree root, thanks to **Bryan Venteicher** for the patch.
-- fix a bug where the cursor position/window size of the nerd tree buffer wasnt being stored on closing the window, thanks to **Richard Hart**.
-- fix a bug where NERDTreeMirror would mirror the wrong tree
-
-#### 3.1.1
-- fix a bug where a non-listed no-name buffer was getting created every time the tree windows was created, thanks to **Derek Wyatt** and **owen1**
-- make `<CR>` behave the same as the `o` mapping
-- some helptag fixes in the doc, thanks **strull**.
-- fix a bug when using `:set nohidden` and opening a file where the previous buf was modified. Thanks **iElectric**.
-- other minor fixes
-
-#### 3.1.0
-- New features:
-    - add mappings to open files in a vsplit, see `:help NERDTree-s` and `:help NERDTree-gs`
-    - make the statusline for the nerd tree window default to something hopefully more useful. See `:help 'NERDTreeStatusline'`
-- Bugfixes:
-    - make the hijack netrw functionality work when vim is started with `vim <some dir>` (thanks to **Alf Mikula** for the patch).
-    - fix a bug where the CWD wasnt being changed for some operations even when NERDTreeChDirMode==2 (thanks to **Lucas S. Buchala**)
-    - add -bar to all the nerd tree :commands so they can chain with other :commands (thanks to **tpope**)
-    - fix bugs when ignorecase was set (thanks to **nach**)
-    - fix a bug with the relative path code (thanks to **nach**)
-    - fix a bug where doing a `:cd` would cause `:NERDTreeToggle` to fail (thanks **nach**)
-
-
-#### 3.0.1
-- Bugfixes:
-    - fix bugs with :NERDTreeToggle and :NERDTreeMirror when `'hidden'` was not set
-    - fix a bug where `:NERDTree <path>` would fail if `<path>` was relative and didnt start with a `./` or `../`  Thanks to **James Kanze**.
-    - make the `q` mapping work with secondary (`:e <dir>`  style) trees, thanks to **jamessan**
-    - fix a bunch of small bugs with secondary trees
-- More insane refactoring.
-
-#### 3.0.0
-- hijack netrw so that doing an `:edit <directory>`  will put a NERD tree in the window rather than a netrw browser. See :help 'NERDTreeHijackNetrw'
-- allow sharing of trees across tabs, see `:help :NERDTreeMirror`
-- remove "top" and "bottom" as valid settings for NERDTreeWinPos
-- change the `'<tab>'` mapping to `'i'`
-- change the `'H'` mapping to `'I'`
-- lots of refactoring
diff --git a/sources_non_forked/nerdtree/LICENCE b/sources_non_forked/nerdtree/LICENCE
deleted file mode 100644
index 8b1a9d8..0000000
--- a/sources_non_forked/nerdtree/LICENCE
+++ /dev/null
@@ -1,13 +0,0 @@
-           DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE
-                   Version 2, December 2004
-
-Copyright (C) 2004 Sam Hocevar <sam@hocevar.net>
-
-Everyone is permitted to copy and distribute verbatim or modified
-copies of this license document, and changing it is allowed as long
-as the name is changed.
-
-           DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE
-  TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
-
- 0. You just DO WHAT THE FUCK YOU WANT TO.
diff --git a/sources_non_forked/nerdtree/README.markdown b/sources_non_forked/nerdtree/README.markdown
deleted file mode 100644
index 09173a6..0000000
--- a/sources_non_forked/nerdtree/README.markdown
+++ /dev/null
@@ -1,157 +0,0 @@
-The NERDTree [![Vint](https://github.com/preservim/nerdtree/workflows/Vint/badge.svg)](https://github.com/preservim/nerdtree/actions?workflow=Vint)
-=============
-
-Introduction
-------------
-
-The NERDTree is a file system explorer for the Vim editor. Using this plugin,
-users can visually browse complex directory hierarchies, quickly open files for
-reading or editing, and perform basic file system operations.
-
-This plugin can also be extended with custom mappings using a special API. The
-details of this API and of other NERDTree features are described in the
-included documentation.
-
-![NERDTree Screenshot](https://github.com/preservim/nerdtree/raw/master/screenshot.png)
-
-Installation
-------------
-
-Below are just some of the methods for installing NERDTree. Do not follow all of these instructions; just pick your favorite one. Other plugin managers exist, and NERDTree should install just fine with any of them.
-
-#### Vim 8+ packages
-
-If you are using VIM version 8 or higher you can use its built-in package management; see `:help packages` for more information. Just run these commands in your terminal:
-
-```bash
-git clone https://github.com/preservim/nerdtree.git ~/.vim/pack/vendor/start/nerdtree
-vim -u NONE -c "helptags ~/.vim/pack/vendor/start/nerdtree/doc" -c q
-```
-
-Otherwise, these are some of the several 3rd-party plugin managers you can choose from. Be sure you read the instructions for your chosen plugin, as there typically are additional steps you nee d to take.
-
-#### [pathogen.vim](https://github.com/tpope/vim-pathogen)
-
-In the terminal,
-```bash
-git clone https://github.com/preservim/nerdtree.git ~/.vim/bundle/nerdtree
-```
-In your vimrc,
-```vim
-call pathogen#infect()
-syntax on
-filetype plugin indent on
-```
-
-Then reload vim, run `:helptags ~/.vim/bundle/nerdtree/doc/` or `:Helptags`.
-
-#### [Vundle.vim](https://github.com/VundleVim/Vundle.vim)
-```vim
-call vundle#begin()
-Plugin 'preservim/nerdtree'
-call vundle#end()
-```
-
-#### [vim-plug](https://github.com/junegunn/vim-plug)
-```vim
-call plug#begin()
-Plug 'preservim/nerdtree'
-call plug#end()
-```
-
-#### [dein.vim](https://github.com/Shougo/dein.vim)
-```vim
-call dein#begin()
-call dein#add('preservim/nerdtree')
-call dein#end()
-```
-
-#### [apt-vim](https://github.com/egalpin/apt-vim)
-```bash
-apt-vim install -y https://github.com/preservim/nerdtree.git
-```
-
-F.A.Q. (here, and in the [Wiki](https://github.com/preservim/nerdtree/wiki))
-------
-
-#### Is there any support for `git` flags?
-
-Yes, install [nerdtree-git-plugin](https://github.com/Xuyuanp/nerdtree-git-plugin).
-
----
-#### Can I have the nerdtree on every tab automatically?
-
-Nope. If this is something you want then chances are you aren't using tabs and
-buffers as they were intended to be used. Read this
-http://stackoverflow.com/questions/102384/using-vims-tabs-like-buffers
-
-If you are interested in this behaviour then consider [vim-nerdtree-tabs](https://github.com/jistr/vim-nerdtree-tabs)
-
----
-#### How can I open a NERDTree automatically when vim starts up?
-
-Stick this in your vimrc: `autocmd vimenter * NERDTree`
-
----
-#### How can I open a NERDTree automatically when vim starts up if no files were specified?
-
-Stick this in your vimrc:
-```vim
-autocmd StdinReadPre * let s:std_in=1
-autocmd VimEnter * if argc() == 0 && !exists("s:std_in") | NERDTree | endif
-```
-
-Note: Now start vim with plain `vim`, not `vim .`
-
----
-#### What if I'm also opening a saved session, for example `vim -S session_file.vim`? I don't want NERDTree to open in that scenario.
-```vim
-autocmd StdinReadPre * let s:std_in=1
-autocmd VimEnter * if argc() == 0 && !exists("s:std_in") && v:this_session == "" | NERDTree | endif
-```
-
----
-#### How can I open NERDTree automatically when vim starts up on opening a directory?
-```vim
-autocmd StdinReadPre * let s:std_in=1
-autocmd VimEnter * if argc() == 1 && isdirectory(argv()[0]) && !exists("s:std_in") | exe 'NERDTree' argv()[0] | wincmd p | ene | exe 'cd '.argv()[0] | endif
-```
-
-This window is tab-specific, meaning it's used by all windows in the tab. This trick also prevents NERDTree from hiding when first selecting a file.
-
-Note: Executing `vim ~/some-directory` will open NERDTree and a new edit window. `exe 'cd '.argv()[0]` sets the `pwd` of the new edit window to `~/some-directory`
-
----
-#### How can I map a specific key or shortcut to open NERDTree?
-
-Stick this in your vimrc to open NERDTree with `Ctrl+n` (you can set whatever key you want):
-```vim
-map <C-n> :NERDTreeToggle<CR>
-```
-
----
-#### How can I close vim if the only window left open is a NERDTree?
-
-Stick this in your vimrc:
-```vim
-autocmd bufenter * if (winnr("$") == 1 && exists("b:NERDTree") && b:NERDTree.isTabTree()) | q | endif
-```
-
----
-#### Can I have different highlighting for different file extensions?
-
-See here: https://github.com/preservim/nerdtree/issues/433#issuecomment-92590696
-
----
-#### How can I change default arrows?
-
-Use these variables in your vimrc. Note that below are default arrow symbols
-```vim
-let g:NERDTreeDirArrowExpandable = ''
-let g:NERDTreeDirArrowCollapsible = ''
-```
-You can remove the arrows altogether by setting these variables to empty strings, as shown below. This will remove not only the arrows, but a single space following them, shifting the whole tree two character positions to the left.
-```vim
-let g:NERDTreeDirArrowExpandable = ''
-let g:NERDTreeDirArrowCollapsible = ''
-```
diff --git a/sources_non_forked/nerdtree/_config.yml b/sources_non_forked/nerdtree/_config.yml
deleted file mode 100644
index c419263..0000000
--- a/sources_non_forked/nerdtree/_config.yml
+++ /dev/null
@@ -1 +0,0 @@
-theme: jekyll-theme-cayman
\ No newline at end of file
diff --git a/sources_non_forked/nerdtree/autoload/nerdtree.vim b/sources_non_forked/nerdtree/autoload/nerdtree.vim
deleted file mode 100644
index d0785a4..0000000
--- a/sources_non_forked/nerdtree/autoload/nerdtree.vim
+++ /dev/null
@@ -1,259 +0,0 @@
-if exists('g:loaded_nerdtree_autoload')
-    finish
-endif
-let g:loaded_nerdtree_autoload = 1
-
-let s:rootNERDTreePath = resolve(expand('<sfile>:p:h:h'))
-
-"FUNCTION: nerdtree#version(...) {{{1
-"  If any value is given as an argument, the entire line of text from the
-"  change log is shown for the current version; otherwise, only the version
-"  number is shown.
-function! nerdtree#version(...) abort
-    let l:text = 'Unknown'
-    try
-        let l:changelog = readfile(join([s:rootNERDTreePath, 'CHANGELOG.md'], nerdtree#slash()))
-        let l:line = 0
-        while l:line <= len(l:changelog)
-            if l:changelog[l:line] =~# '\d\+\.\d\+'
-                let l:text = substitute(l:changelog[l:line], '.*\(\d\+.\d\+\).*', '\1', '')
-                let l:text .= substitute(l:changelog[l:line+1], '^.\{-}\(\.\d\+\).\{-}:\(.*\)', a:0>0 ? '\1:\2' : '\1', '')
-                break
-            endif
-            let l:line += 1
-        endwhile
-    catch
-    endtry
-    return l:text
-endfunction
-
-" SECTION: General Functions {{{1
-"============================================================
-
-"FUNCTION: nerdtree#slash() {{{2
-function! nerdtree#slash() abort
-
-    if nerdtree#runningWindows()
-        if exists('+shellslash') && &shellslash
-            return '/'
-        endif
-
-        return '\'
-    endif
-
-    return '/'
-endfunction
-
-"FUNCTION: nerdtree#and(x,y) {{{2
-" Implements and() function for Vim <= 7.4
-function! nerdtree#and(x,y) abort
-    if exists('*and')
-        return and(a:x, a:y)
-    else
-        let l:x = a:x
-        let l:y = a:y
-        let l:n = 0
-        let l:result = 0
-        while l:x > 0 && l:y > 0
-            if (l:x % 2) && (l:y % 2)
-                let l:result += float2nr(pow(2, l:n))
-            endif
-            let l:x = float2nr(l:x / 2)
-            let l:y = float2nr(l:y / 2)
-            let l:n += 1
-        endwhile
-        return l:result
-    endif
-endfunction
-
-"FUNCTION: nerdtree#checkForBrowse(dir) {{{2
-"inits a window tree in the current buffer if appropriate
-function! nerdtree#checkForBrowse(dir) abort
-    if !isdirectory(a:dir)
-        return
-    endif
-
-    if s:reuseWin(a:dir)
-        return
-    endif
-
-    call g:NERDTreeCreator.CreateWindowTree(a:dir)
-endfunction
-
-"FUNCTION: s:reuseWin(dir) {{{2
-"finds a NERDTree buffer with root of dir, and opens it.
-function! s:reuseWin(dir) abort
-    let path = g:NERDTreePath.New(fnamemodify(a:dir, ':p'))
-
-    for i in range(1, bufnr('$'))
-        unlet! nt
-        let nt = getbufvar(i, 'NERDTree')
-        if empty(nt)
-            continue
-        endif
-
-        if nt.isWinTree() && nt.root.path.equals(path)
-            call nt.setPreviousBuf(bufnr('#'))
-            exec 'buffer ' . i
-            return 1
-        endif
-    endfor
-
-    return 0
-endfunction
-
-" FUNCTION: nerdtree#completeBookmarks(A,L,P) {{{2
-" completion function for the bookmark commands
-function! nerdtree#completeBookmarks(A,L,P) abort
-    return filter(g:NERDTreeBookmark.BookmarkNames(), 'v:val =~# "^' . a:A . '"')
-endfunction
-
-"FUNCTION: nerdtree#compareNodes(dir) {{{2
-function! nerdtree#compareNodes(n1, n2) abort
-    return a:n1.path.compareTo(a:n2.path)
-endfunction
-
-"FUNCTION: nerdtree#compareNodesBySortKey(n1, n2) {{{2
-function! nerdtree#compareNodesBySortKey(n1, n2) abort
-    let sortKey1 = a:n1.path.getSortKey()
-    let sortKey2 = a:n2.path.getSortKey()
-    let i = 0
-    while i < min([len(sortKey1), len(sortKey2)])
-        " Compare chunks upto common length.
-        " If chunks have different type, the one which has
-        " integer type is the lesser.
-        if type(sortKey1[i]) ==# type(sortKey2[i])
-            if sortKey1[i] <# sortKey2[i]
-                return - 1
-            elseif sortKey1[i] ># sortKey2[i]
-                return 1
-            endif
-        elseif type(sortKey1[i]) ==# v:t_number
-            return -1
-        elseif type(sortKey2[i]) ==# v:t_number
-            return 1
-        endif
-        let i = i + 1
-    endwhile
-
-    " Keys are identical upto common length.
-    " The key which has smaller chunks is the lesser one.
-    if len(sortKey1) < len(sortKey2)
-        return -1
-    elseif len(sortKey1) > len(sortKey2)
-        return 1
-    else
-        return 0
-    endif
-endfunction
-
-" FUNCTION: nerdtree#deprecated(func, [msg]) {{{2
-" Issue a deprecation warning for a:func. If a second arg is given, use this
-" as the deprecation message
-function! nerdtree#deprecated(func, ...) abort
-    let msg = a:0 ? a:func . ' ' . a:1 : a:func . ' is deprecated'
-
-    if !exists('s:deprecationWarnings')
-        let s:deprecationWarnings = {}
-    endif
-    if !has_key(s:deprecationWarnings, a:func)
-        let s:deprecationWarnings[a:func] = 1
-        echomsg msg
-    endif
-endfunction
-
-" FUNCTION: nerdtree#exec(cmd, ignoreAll) {{{2
-" Same as :exec cmd but, if ignoreAll is TRUE, set eventignore=all for the duration
-function! nerdtree#exec(cmd, ignoreAll) abort
-    let old_ei = &eventignore
-    if a:ignoreAll
-        set eventignore=all
-    endif
-    try
-        exec a:cmd
-    finally
-        let &eventignore = old_ei
-    endtry
-endfunction
-
-" FUNCTION: nerdtree#has_opt(options, name) {{{2
-function! nerdtree#has_opt(options, name) abort
-    return has_key(a:options, a:name) && a:options[a:name] ==# 1
-endfunction
-
-" FUNCTION: nerdtree#loadClassFiles() {{{2
-function! nerdtree#loadClassFiles() abort
-    runtime lib/nerdtree/path.vim
-    runtime lib/nerdtree/menu_controller.vim
-    runtime lib/nerdtree/menu_item.vim
-    runtime lib/nerdtree/key_map.vim
-    runtime lib/nerdtree/bookmark.vim
-    runtime lib/nerdtree/tree_file_node.vim
-    runtime lib/nerdtree/tree_dir_node.vim
-    runtime lib/nerdtree/opener.vim
-    runtime lib/nerdtree/creator.vim
-    runtime lib/nerdtree/flag_set.vim
-    runtime lib/nerdtree/nerdtree.vim
-    runtime lib/nerdtree/ui.vim
-    runtime lib/nerdtree/event.vim
-    runtime lib/nerdtree/notifier.vim
-endfunction
-
-" FUNCTION: nerdtree#postSourceActions() {{{2
-function! nerdtree#postSourceActions() abort
-    call g:NERDTreeBookmark.CacheBookmarks(1)
-    call nerdtree#ui_glue#createDefaultBindings()
-
-    "load all nerdtree plugins
-    runtime! nerdtree_plugin/**/*.vim
-endfunction
-
-"FUNCTION: nerdtree#runningWindows(dir) {{{2
-function! nerdtree#runningWindows() abort
-    return has('win16') || has('win32') || has('win64')
-endfunction
-
-"FUNCTION: nerdtree#runningCygwin(dir) {{{2
-function! nerdtree#runningCygwin() abort
-    return has('win32unix')
-endfunction
-
-" SECTION: View Functions {{{1
-"============================================================
-
-"FUNCTION: nerdtree#echo  {{{2
-"A wrapper for :echo. Appends 'NERDTree:' on the front of all messages
-"
-"Args:
-"msg: the message to echo
-function! nerdtree#echo(msg) abort
-    redraw
-    echomsg empty(a:msg) ? '' : ('NERDTree: ' . a:msg)
-endfunction
-
-"FUNCTION: nerdtree#echoError {{{2
-"Wrapper for nerdtree#echo, sets the message type to errormsg for this message
-"Args:
-"msg: the message to echo
-function! nerdtree#echoError(msg) abort
-    echohl errormsg
-    call nerdtree#echo(a:msg)
-    echohl normal
-endfunction
-
-"FUNCTION: nerdtree#echoWarning {{{2
-"Wrapper for nerdtree#echo, sets the message type to warningmsg for this message
-"Args:
-"msg: the message to echo
-function! nerdtree#echoWarning(msg) abort
-    echohl warningmsg
-    call nerdtree#echo(a:msg)
-    echohl normal
-endfunction
-
-"FUNCTION: nerdtree#renderView {{{2
-function! nerdtree#renderView() abort
-    call b:NERDTree.render()
-endfunction
-
-" vim: set sw=4 sts=4 et fdm=marker:
diff --git a/sources_non_forked/nerdtree/autoload/nerdtree/ui_glue.vim b/sources_non_forked/nerdtree/autoload/nerdtree/ui_glue.vim
deleted file mode 100644
index aef1b04..0000000
--- a/sources_non_forked/nerdtree/autoload/nerdtree/ui_glue.vim
+++ /dev/null
@@ -1,698 +0,0 @@
-if exists('g:loaded_nerdtree_ui_glue_autoload')
-    finish
-endif
-let g:loaded_nerdtree_ui_glue_autoload = 1
-
-" FUNCTION: nerdtree#ui_glue#createDefaultBindings() {{{1
-function! nerdtree#ui_glue#createDefaultBindings() abort
-    let s = '<SNR>' . s:SID() . '_'
-
-    call NERDTreeAddKeyMap({ 'key': '<MiddleMouse>', 'scope': 'all', 'callback': s . 'handleMiddleMouse' })
-    call NERDTreeAddKeyMap({ 'key': '<LeftRelease>', 'scope': 'all', 'callback': s.'handleLeftClick' })
-    call NERDTreeAddKeyMap({ 'key': '<2-LeftMouse>', 'scope': 'DirNode', 'callback': s.'activateDirNode' })
-    call NERDTreeAddKeyMap({ 'key': '<2-LeftMouse>', 'scope': 'FileNode', 'callback': s.'activateFileNode' })
-    call NERDTreeAddKeyMap({ 'key': '<2-LeftMouse>', 'scope': 'Bookmark', 'callback': s.'activateBookmark' })
-    call NERDTreeAddKeyMap({ 'key': '<2-LeftMouse>', 'scope': 'all', 'callback': s.'activateAll' })
-
-    call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapCustomOpen, 'scope':'FileNode', 'callback': s.'customOpenFile'})
-    call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapCustomOpen, 'scope':'DirNode', 'callback': s.'customOpenDir'})
-    call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapCustomOpen, 'scope':'Bookmark', 'callback': s.'customOpenBookmark'})
-    call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapCustomOpen, 'scope':'all', 'callback': s.'activateAll' })
-
-    call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapActivateNode, 'scope': 'DirNode', 'callback': s.'activateDirNode' })
-    call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapActivateNode, 'scope': 'FileNode', 'callback': s.'activateFileNode' })
-    call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapActivateNode, 'scope': 'Bookmark', 'callback': s.'activateBookmark' })
-    call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapPreview, 'scope': 'Bookmark', 'callback': s.'previewBookmark' })
-    call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapActivateNode, 'scope': 'all', 'callback': s.'activateAll' })
-
-    call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenSplit, 'scope': 'Node', 'callback': s.'openHSplit' })
-    call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenVSplit, 'scope': 'Node', 'callback': s.'openVSplit' })
-
-    call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapPreview, 'scope': 'Node', 'callback': s.'previewNodeCurrent' })
-    call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapPreviewVSplit, 'scope': 'Node', 'callback': s.'previewNodeVSplit' })
-    call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapPreviewSplit, 'scope': 'Node', 'callback': s.'previewNodeHSplit' })
-
-    call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenRecursively, 'scope': 'DirNode', 'callback': s.'openNodeRecursively' })
-
-    call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapUpdir, 'scope': 'all', 'callback': s . 'upDirCurrentRootClosed' })
-    call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapUpdirKeepOpen, 'scope': 'all', 'callback': s . 'upDirCurrentRootOpen' })
-    call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapChangeRoot, 'scope': 'Node', 'callback': s . 'chRoot' })
-
-    call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapChdir, 'scope': 'Node', 'callback': s.'chCwd' })
-
-    call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapQuit, 'scope': 'all', 'callback': s.'closeTreeWindow' })
-
-    call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapCWD, 'scope': 'all', 'callback': 'nerdtree#ui_glue#chRootCwd' })
-
-    call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapRefreshRoot, 'scope': 'all', 'callback': s.'refreshRoot' })
-    call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapRefresh, 'scope': 'Node', 'callback': s.'refreshCurrent' })
-
-    call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapHelp, 'scope': 'all', 'callback': s.'displayHelp' })
-    call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleZoom, 'scope': 'all', 'callback': s.'toggleZoom' })
-    call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleHidden, 'scope': 'all', 'callback': s.'toggleShowHidden' })
-    call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleFilters, 'scope': 'all', 'callback': s.'toggleIgnoreFilter' })
-    call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleFiles, 'scope': 'all', 'callback': s.'toggleShowFiles' })
-    call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleBookmarks, 'scope': 'all', 'callback': s.'toggleShowBookmarks' })
-
-    call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapCloseDir, 'scope': 'Node', 'callback': s.'closeCurrentDir' })
-    call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapCloseChildren, 'scope': 'DirNode', 'callback': s.'closeChildren' })
-
-    call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapMenu, 'scope': 'Node', 'callback': s.'showMenu' })
-
-    call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpParent, 'scope': 'Node', 'callback': s.'jumpToParent' })
-    call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpFirstChild, 'scope': 'Node', 'callback': s.'jumpToFirstChild' })
-    call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpLastChild, 'scope': 'Node', 'callback': s.'jumpToLastChild' })
-    call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpRoot, 'scope': 'all', 'callback': s.'jumpToRoot' })
-    call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpNextSibling, 'scope': 'Node', 'callback': s.'jumpToNextSibling' })
-    call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpPrevSibling, 'scope': 'Node', 'callback': s.'jumpToPrevSibling' })
-
-    call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenInTab, 'scope': 'Node', 'callback': s . 'openInNewTab' })
-    call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenInTabSilent, 'scope': 'Node', 'callback': s . 'openInNewTabSilent' })
-    call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenInTab, 'scope': 'Bookmark', 'callback': s . 'openInNewTab' })
-    call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenInTabSilent, 'scope': 'Bookmark', 'callback': s . 'openInNewTabSilent' })
-
-    call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenExpl, 'scope': 'DirNode', 'callback': s.'openExplorer' })
-    call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenExpl, 'scope': 'FileNode', 'callback': s.'openExplorer' })
-
-    call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapDeleteBookmark, 'scope': 'Bookmark', 'callback': s.'deleteBookmark' })
-endfunction
-
-
-"SECTION: Interface bindings {{{1
-"============================================================
-
-"FUNCTION: s:customOpenFile() {{{1
-" Open file node with the 'custom' key, initially <CR>.
-function! s:customOpenFile(node) abort
-    call a:node.activate(s:initCustomOpenArgs().file)
-endfunction
-
-"FUNCTION: s:customOpenDir() {{{1
-" Open directory node with the 'custom' key, initially <CR>.
-function! s:customOpenDir(node) abort
-    call s:activateDirNode(a:node, s:initCustomOpenArgs().dir)
-endfunction
-
-"FUNCTION: s:customOpenBookmark() {{{1
-" Open bookmark node with the 'custom' key, initially <CR>.
-function! s:customOpenBookmark(node) abort
-    if a:node.path.isDirectory
-        call a:node.activate(b:NERDTree, s:initCustomOpenArgs().dir)
-    else
-        call a:node.activate(b:NERDTree, s:initCustomOpenArgs().file)
-    endif
-endfunction
-
-"FUNCTION: s:initCustomOpenArgs() {{{1
-" Make sure NERDTreeCustomOpenArgs has needed keys
-function! s:initCustomOpenArgs() abort
-    let g:NERDTreeCustomOpenArgs = get(g:, 'NERDTreeCustomOpenArgs', {})
-    return extend(g:NERDTreeCustomOpenArgs, {'file':{'reuse': 'all', 'where': 'p'}, 'dir':{}}, 'keep')
-endfunction
-
-"FUNCTION: s:activateAll() {{{1
-"handle the user activating the updir line
-function! s:activateAll() abort
-    if getline('.') ==# g:NERDTreeUI.UpDirLine()
-        return nerdtree#ui_glue#upDir(0)
-    endif
-endfunction
-
-" FUNCTION: s:activateDirNode(directoryNode, options) {{{1
-" Open a directory with optional options
-function! s:activateDirNode(directoryNode, ...) abort
-
-    if a:directoryNode.isRoot() && a:directoryNode.isOpen
-        call nerdtree#echo('cannot close tree root')
-        return
-    endif
-
-    call a:directoryNode.activate((a:0 > 0) ? a:1 : {})
-endfunction
-
-"FUNCTION: s:activateFileNode() {{{1
-"handle the user activating a tree node
-function! s:activateFileNode(node) abort
-    call a:node.activate({'reuse': 'all', 'where': 'p'})
-endfunction
-
-"FUNCTION: s:activateBookmark(bookmark) {{{1
-"handle the user activating a bookmark
-function! s:activateBookmark(bm) abort
-    call a:bm.activate(b:NERDTree, !a:bm.path.isDirectory ? {'where': 'p'} : {})
-endfunction
-
-" FUNCTION: nerdtree#ui_glue#bookmarkNode(name) {{{1
-" Associate the current node with the given name
-function! nerdtree#ui_glue#bookmarkNode(...) abort
-    let currentNode = g:NERDTreeFileNode.GetSelected()
-    if currentNode !=# {}
-        let name = a:1
-        if empty(name)
-            let name = currentNode.path.getLastPathComponent(0)
-        endif
-        try
-            call currentNode.bookmark(name)
-            call b:NERDTree.render()
-        catch /^NERDTree.IllegalBookmarkNameError/
-            call nerdtree#echo('bookmark names must not contain spaces')
-        endtry
-    else
-        call nerdtree#echo('select a node first')
-    endif
-endfunction
-
-" FUNCTION: s:chCwd(node) {{{1
-function! s:chCwd(node) abort
-    try
-        call a:node.path.changeToDir()
-    catch /^NERDTree.PathChangeError/
-        call nerdtree#echoWarning('could not change cwd')
-    endtry
-endfunction
-
-" FUNCTION: s:chRoot(node) {{{1
-" changes the current root to the selected one
-function! s:chRoot(node) abort
-    call b:NERDTree.changeRoot(a:node)
-endfunction
-
-" FUNCTION: s:nerdtree#ui_glue#chRootCwd() {{{1
-" Change the NERDTree root to match the current working directory.
-function! nerdtree#ui_glue#chRootCwd() abort
-    NERDTreeCWD
-endfunction
-
-" FUNCTION: nnerdtree#ui_glue#clearBookmarks(bookmarks) {{{1
-function! nerdtree#ui_glue#clearBookmarks(bookmarks) abort
-    if a:bookmarks ==# ''
-        let currentNode = g:NERDTreeFileNode.GetSelected()
-        if currentNode !=# {}
-            call currentNode.clearBookmarks()
-        endif
-    else
-        for name in split(a:bookmarks, ' ')
-            let bookmark = g:NERDTreeBookmark.BookmarkFor(name)
-            call bookmark.delete()
-        endfor
-    endif
-    call b:NERDTree.root.refresh()
-    call b:NERDTree.render()
-endfunction
-
-" FUNCTION: s:closeChildren(node) {{{1
-" closes all childnodes of the current node
-function! s:closeChildren(node) abort
-    call a:node.closeChildren()
-    call b:NERDTree.render()
-    call a:node.putCursorHere(0, 0)
-endfunction
-
-" FUNCTION: s:closeCurrentDir(node) {{{1
-" Close the parent directory of the current node.
-function! s:closeCurrentDir(node) abort
-
-    if a:node.isRoot()
-        call nerdtree#echo('cannot close parent of tree root')
-        return
-    endif
-
-    let l:parent = a:node.parent
-
-    while l:parent.isCascadable()
-        let l:parent = l:parent.parent
-    endwhile
-
-    if l:parent.isRoot()
-        call nerdtree#echo('cannot close tree root')
-        return
-    endif
-
-    call l:parent.close()
-    call b:NERDTree.render()
-    call l:parent.putCursorHere(0, 0)
-endfunction
-
-" FUNCTION: s:closeTreeWindow() {{{1
-" close the tree window
-function! s:closeTreeWindow() abort
-    if b:NERDTree.isWinTree() && b:NERDTree.previousBuf() !=# -1
-        exec 'buffer ' . b:NERDTree.previousBuf()
-    else
-        if winnr('$') > 1
-            call g:NERDTree.Close()
-        else
-            call nerdtree#echo('Cannot close last window')
-        endif
-    endif
-endfunction
-
-" FUNCTION: s:deleteBookmark(bookmark) {{{1
-" Prompt the user to confirm the deletion of the selected bookmark.
-function! s:deleteBookmark(bookmark) abort
-    let l:message = 'Delete the bookmark "' . a:bookmark.name
-                \ . '" from the bookmark list?'
-
-    let l:choices = "&Yes\n&No"
-
-    echo | redraw
-    let l:selection = confirm(l:message, l:choices, 1, 'Warning')
-
-    if l:selection !=# 1
-        call nerdtree#echo('bookmark not deleted')
-        return
-    endif
-
-    try
-        call a:bookmark.delete()
-        silent call b:NERDTree.root.refresh()
-        call b:NERDTree.render()
-        echo | redraw
-    catch /^NERDTree/
-        call nerdtree#echoWarning('could not remove bookmark')
-    endtry
-endfunction
-
-" FUNCTION: s:displayHelp() {{{1
-" toggles the help display
-function! s:displayHelp() abort
-    call b:NERDTree.ui.toggleHelp()
-    call b:NERDTree.render()
-    call b:NERDTree.ui.centerView()
-endfunction
-
-" FUNCTION: s:findAndRevealPath(pathStr) {{{1
-function! s:findAndRevealPath(pathStr) abort
-    let l:pathStr = !empty(a:pathStr) ? a:pathStr : expand('%:p')
-    let l:revealOpts = {}
-
-    if empty(l:pathStr)
-        call nerdtree#echoWarning('no file for the current buffer')
-        return
-    endif
-
-    if !filereadable(l:pathStr)
-        let l:pathStr = fnamemodify(l:pathStr, ':h')
-        let l:revealOpts['open'] = 1
-    endif
-
-    try
-        let l:pathStr = g:NERDTreePath.Resolve(l:pathStr)
-        let l:pathObj = g:NERDTreePath.New(l:pathStr)
-    catch /^NERDTree.InvalidArgumentsError/
-        call nerdtree#echoWarning('invalid path')
-        return
-    endtry
-
-    if !g:NERDTree.ExistsForTab()
-        try
-            let l:cwd = g:NERDTreePath.New(getcwd())
-        catch /^NERDTree.InvalidArgumentsError/
-            call nerdtree#echo('current directory does not exist.')
-            let l:cwd = l:pathObj.getParent()
-        endtry
-
-        if l:pathObj.isUnder(l:cwd)
-            call g:NERDTreeCreator.CreateTabTree(l:cwd.str())
-        else
-            call g:NERDTreeCreator.CreateTabTree(l:pathObj.getParent().str())
-        endif
-    else
-        NERDTreeFocus
-
-        if !l:pathObj.isUnder(b:NERDTree.root.path)
-            call s:chRoot(g:NERDTreeDirNode.New(l:pathObj.getParent(), b:NERDTree))
-        endif
-    endif
-
-    if l:pathObj.isHiddenUnder(b:NERDTree.root.path)
-        call b:NERDTree.ui.setShowHidden(1)
-    endif
-
-    let l:node = b:NERDTree.root.reveal(l:pathObj, l:revealOpts)
-    call b:NERDTree.render()
-    call l:node.putCursorHere(1, 0)
-endfunction
-
-"FUNCTION: s:handleLeftClick() {{{1
-"Checks if the click should open the current node
-function! s:handleLeftClick() abort
-    let currentNode = g:NERDTreeFileNode.GetSelected()
-    if currentNode !=# {}
-
-        "the dir arrows are multibyte chars, and vim's string functions only
-        "deal with single bytes - so split the line up with the hack below and
-        "take the line substring manually
-        let line = split(getline(line('.')), '\zs')
-        let startToCur = ''
-        for i in range(0,len(line)-1)
-            let startToCur .= line[i]
-        endfor
-
-        if currentNode.path.isDirectory
-            if startToCur =~# g:NERDTreeUI.MarkupReg() && startToCur =~# '[+~'.g:NERDTreeDirArrowExpandable.g:NERDTreeDirArrowCollapsible.'] \?$'
-                call currentNode.activate()
-                return
-            endif
-        endif
-
-        if (g:NERDTreeMouseMode ==# 2 && currentNode.path.isDirectory) || g:NERDTreeMouseMode ==# 3
-            let char = strpart(startToCur, strlen(startToCur)-1, 1)
-            if char !~# g:NERDTreeUI.MarkupReg()
-                if currentNode.path.isDirectory
-                    call currentNode.activate()
-                else
-                    call currentNode.activate({'reuse': 'all', 'where': 'p'})
-                endif
-                return
-            endif
-        endif
-    endif
-endfunction
-
-" FUNCTION: s:handleMiddleMouse() {{{1
-function! s:handleMiddleMouse() abort
-
-    " A middle mouse click does not automatically position the cursor as one
-    " would expect. Forcing the execution of a regular left mouse click here
-    " fixes this problem.
-    execute "normal! \<LeftMouse>"
-
-    let l:currentNode = g:NERDTreeFileNode.GetSelected()
-    if empty(l:currentNode)
-        call nerdtree#echoError('use the pointer to select a node')
-        return
-    endif
-
-    if l:currentNode.path.isDirectory
-        call l:currentNode.openExplorer()
-    else
-        call l:currentNode.open({'where': 'h'})
-    endif
-endfunction
-
-" FUNCTION: nerdtree#ui_glue#invokeKeyMap(key) {{{1
-"this is needed since I cant figure out how to invoke dict functions from a
-"key map
-function! nerdtree#ui_glue#invokeKeyMap(key) abort
-    call g:NERDTreeKeyMap.Invoke(a:key)
-endfunction
-
-" FUNCTION: s:jumpToFirstChild(node) {{{1
-function! s:jumpToFirstChild(node) abort
-    call s:jumpToChild(a:node, 0)
-endfunction
-
-" FUNCTION: s:jumpToLastChild(node) {{{1
-function! s:jumpToLastChild(node) abort
-    call s:jumpToChild(a:node, 1)
-endfunction
-
-" FUNCTION: s:jumpToChild(node, last) {{{1
-" Jump to the first or last child node at the same file system level.
-"
-" Args:
-" node: the node on which the cursor currently sits
-" last: 1 (true) if jumping to last child, 0 (false) if jumping to first
-function! s:jumpToChild(node, last) abort
-    let l:node = a:node.path.isDirectory ? a:node.getCascadeRoot() : a:node
-
-    if l:node.isRoot()
-        return
-    endif
-
-    let l:parent = l:node.parent
-    let l:children = l:parent.getVisibleChildren()
-
-    let l:target = a:last ? l:children[len(l:children) - 1] : l:children[0]
-
-    call l:target.putCursorHere(1, 0)
-    call b:NERDTree.ui.centerView()
-endfunction
-
-" FUNCTION: s:jumpToParent(node) {{{1
-" Move the cursor to the parent of the specified node.  For a cascade, move to
-" the parent of the cascade's first node.  At the root node, do nothing.
-function! s:jumpToParent(node) abort
-    let l:node = a:node.path.isDirectory ? a:node.getCascadeRoot() : a:node
-
-    if l:node.isRoot()
-        return
-    endif
-
-    if empty(l:node.parent)
-        call nerdtree#echo('could not jump to parent node')
-        return
-    endif
-
-    call l:node.parent.putCursorHere(1, 0)
-    call b:NERDTree.ui.centerView()
-endfunction
-
-" FUNCTION: s:jumpToRoot() {{{1
-" moves the cursor to the root node
-function! s:jumpToRoot() abort
-    call b:NERDTree.root.putCursorHere(1, 0)
-    call b:NERDTree.ui.centerView()
-endfunction
-
-" FUNCTION: s:jumpToNextSibling(node) {{{1
-function! s:jumpToNextSibling(node) abort
-    call s:jumpToSibling(a:node, 1)
-endfunction
-
-" FUNCTION: s:jumpToPrevSibling(node) {{{1
-function! s:jumpToPrevSibling(node) abort
-    call s:jumpToSibling(a:node, 0)
-endfunction
-
-" FUNCTION: s:jumpToSibling(node, forward) {{{1
-" Move the cursor to the next or previous node at the same file system level.
-"
-" Args:
-" node: the node on which the cursor currently sits
-" forward: 0 to jump to previous sibling, 1 to jump to next sibling
-function! s:jumpToSibling(node, forward) abort
-    let l:node = a:node.path.isDirectory ? a:node.getCascadeRoot() : a:node
-    let l:sibling = l:node.findSibling(a:forward)
-
-    if empty(l:sibling)
-        return
-    endif
-
-    call l:sibling.putCursorHere(1, 0)
-    call b:NERDTree.ui.centerView()
-endfunction
-
-" FUNCTION: nerdtree#ui_glue#openBookmark(name) {{{1
-" Open the Bookmark that has the specified name. This function provides the
-" implementation for the :OpenBookmark command.
-function! nerdtree#ui_glue#openBookmark(name) abort
-    try
-        let l:bookmark = g:NERDTreeBookmark.BookmarkFor(a:name)
-    catch /^NERDTree.BookmarkNotFoundError/
-        call nerdtree#echoError('bookmark "' . a:name . '" not found')
-        return
-    endtry
-    if l:bookmark.path.isDirectory
-        call l:bookmark.open(b:NERDTree)
-    else
-        call l:bookmark.open(b:NERDTree, {'where': 'p'})
-    endif
-endfunction
-
-" FUNCTION: s:openHSplit(target) {{{1
-function! s:openHSplit(target) abort
-    call a:target.activate({'where': 'h'})
-endfunction
-
-" FUNCTION: s:openVSplit(target) {{{1
-function! s:openVSplit(target) abort
-    call a:target.activate({'where': 'v'})
-endfunction
-
-" FUNCTION: s:openExplorer(node) {{{1
-function! s:openExplorer(node) abort
-    call a:node.openExplorer()
-endfunction
-
-" FUNCTION: s:openInNewTab(target) {{{1
-function! s:openInNewTab(target) abort
-    let l:opener = g:NERDTreeOpener.New(a:target.path, {'where': 't'})
-    call l:opener.open(a:target)
-endfunction
-
-" FUNCTION: s:openInNewTabSilent(target) {{{1
-function! s:openInNewTabSilent(target) abort
-    let l:opener = g:NERDTreeOpener.New(a:target.path, {'where': 't', 'stay': 1})
-    call l:opener.open(a:target)
-endfunction
-
-" FUNCTION: s:openNodeRecursively(node) {{{1
-function! s:openNodeRecursively(node) abort
-    call nerdtree#echo('Recursively opening node. Please wait...')
-    call a:node.openRecursively()
-    call b:NERDTree.render()
-    call nerdtree#echo('')
-endfunction
-
-" FUNCTION: s:previewBookmark(bookmark) {{{1
-function! s:previewBookmark(bookmark) abort
-    if a:bookmark.path.isDirectory
-        execute 'NERDTreeFind '.a:bookmark.path.str()
-    else
-        call a:bookmark.activate(b:NERDTree, {'stay': 1, 'where': 'p', 'keepopen': 1})
-    endif
-endfunction
-
-"FUNCTION: s:previewNodeCurrent(node) {{{1
-function! s:previewNodeCurrent(node) abort
-    call a:node.open({'stay': 1, 'where': 'p', 'keepopen': 1})
-endfunction
-
-"FUNCTION: s:previewNodeHSplit(node) {{{1
-function! s:previewNodeHSplit(node) abort
-    call a:node.open({'stay': 1, 'where': 'h', 'keepopen': 1})
-endfunction
-
-"FUNCTION: s:previewNodeVSplit(node) {{{1
-function! s:previewNodeVSplit(node) abort
-    call a:node.open({'stay': 1, 'where': 'v', 'keepopen': 1})
-endfunction
-
-" FUNCTION: nerdtree#ui_glue#revealBookmark(name) {{{1
-" put the cursor on the node associate with the given name
-function! nerdtree#ui_glue#revealBookmark(name) abort
-    try
-        let targetNode = g:NERDTreeBookmark.GetNodeForName(a:name, 0, b:NERDTree)
-        call targetNode.putCursorHere(0, 1)
-    catch /^NERDTree.BookmarkNotFoundError/
-        call nerdtree#echo('Bookmark isnt cached under the current root')
-    endtry
-endfunction
-
-" FUNCTION: s:refreshRoot() {{{1
-" Reloads the current root. All nodes below this will be lost and the root dir
-" will be reloaded.
-function! s:refreshRoot() abort
-    if !g:NERDTree.IsOpen()
-        return
-    endif
-    call nerdtree#echo('Refreshing the root node. This could take a while...')
-
-    let l:curWin = winnr()
-    call nerdtree#exec(g:NERDTree.GetWinNum() . 'wincmd w', 1)
-    call b:NERDTree.root.refresh()
-    call b:NERDTree.render()
-    redraw
-    call nerdtree#exec(l:curWin . 'wincmd w', 1)
-    call nerdtree#echo('')
-endfunction
-
-" FUNCTION: s:refreshCurrent(node) {{{1
-" refreshes the root for the current node
-function! s:refreshCurrent(node) abort
-    let node = a:node
-    if !node.path.isDirectory
-        let node = node.parent
-    endif
-
-    call nerdtree#echo('Refreshing node. This could take a while...')
-    call node.refresh()
-    call b:NERDTree.render()
-    call nerdtree#echo('')
-endfunction
-
-" FUNCTION: nerdtree#ui_glue#setupCommands() {{{1
-function! nerdtree#ui_glue#setupCommands() abort
-    command! -n=? -complete=dir -bar NERDTree :call g:NERDTreeCreator.CreateTabTree('<args>')
-    command! -n=? -complete=dir -bar NERDTreeToggle :call g:NERDTreeCreator.ToggleTabTree('<args>')
-    command! -n=0 -bar NERDTreeClose :call g:NERDTree.Close()
-    command! -n=1 -complete=customlist,nerdtree#completeBookmarks -bar NERDTreeFromBookmark call g:NERDTreeCreator.CreateTabTree('<args>')
-    command! -n=0 -bar NERDTreeMirror call g:NERDTreeCreator.CreateMirror()
-    command! -n=? -complete=file -bar NERDTreeFind call s:findAndRevealPath('<args>')
-    command! -n=0 -bar NERDTreeRefreshRoot call s:refreshRoot()
-    command! -n=0 -bar NERDTreeFocus call NERDTreeFocus()
-    command! -n=0 -bar NERDTreeCWD call NERDTreeCWD()
-endfunction
-
-" Function: s:SID()   {{{1
-function! s:SID() abort
-    if !exists('s:sid')
-        let s:sid = matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze_SID$')
-    endif
-    return s:sid
-endfun
-
-" FUNCTION: s:showMenu(node) {{{1
-function! s:showMenu(node) abort
-    let mc = g:NERDTreeMenuController.New(g:NERDTreeMenuItem.AllEnabled())
-    call mc.showMenu()
-endfunction
-
-" FUNCTION: s:toggleIgnoreFilter() {{{1
-function! s:toggleIgnoreFilter() abort
-    call b:NERDTree.ui.toggleIgnoreFilter()
-endfunction
-
-" FUNCTION: s:toggleShowBookmarks() {{{1
-function! s:toggleShowBookmarks() abort
-    call b:NERDTree.ui.toggleShowBookmarks()
-endfunction
-
-" FUNCTION: s:toggleShowFiles() {{{1
-function! s:toggleShowFiles() abort
-    call b:NERDTree.ui.toggleShowFiles()
-endfunction
-
-" FUNCTION: s:toggleShowHidden() {{{1
-" toggles the display of hidden files
-function! s:toggleShowHidden() abort
-    call b:NERDTree.ui.toggleShowHidden()
-endfunction
-
-" FUNCTION: s:toggleZoom() {{{1
-function! s:toggleZoom() abort
-    call b:NERDTree.ui.toggleZoom()
-endfunction
-
-" FUNCTION: nerdtree#ui_glue#upDir(preserveState) {{{1
-" Move the NERDTree up one level.
-"
-" Args:
-" preserveState: if 1, the current root is left open when the new tree is
-" rendered; if 0, the current root node is closed
-function! nerdtree#ui_glue#upDir(preserveState) abort
-
-    try
-        call b:NERDTree.root.cacheParent()
-    catch /^NERDTree.CannotCacheParentError/
-        call nerdtree#echo('already at root directory')
-        return
-    endtry
-
-    let l:oldRoot = b:NERDTree.root
-    let l:newRoot = b:NERDTree.root.parent
-
-    call l:newRoot.open()
-    call l:newRoot.transplantChild(l:oldRoot)
-
-    if !a:preserveState
-        call l:oldRoot.close()
-    endif
-
-    call b:NERDTree.changeRoot(l:newRoot)
-    call l:oldRoot.putCursorHere(0, 0)
-endfunction
-
-" FUNCTION: s:upDirCurrentRootOpen() {{{1
-function! s:upDirCurrentRootOpen() abort
-    call nerdtree#ui_glue#upDir(1)
-endfunction
-
-" FUNCTION: s:upDirCurrentRootClosed() {{{1
-function! s:upDirCurrentRootClosed() abort
-    call nerdtree#ui_glue#upDir(0)
-endfunction
-
-" vim: set sw=4 sts=4 et fdm=marker:
diff --git a/sources_non_forked/nerdtree/doc/NERDTree.txt b/sources_non_forked/nerdtree/doc/NERDTree.txt
deleted file mode 100644
index 6c11a94..0000000
--- a/sources_non_forked/nerdtree/doc/NERDTree.txt
+++ /dev/null
@@ -1,1528 +0,0 @@
-*NERDTree.txt*   A tree explorer plugin to rule the Vim world. Bwahahaha!!
-
-                                    # #### ####                                ~
-                                  ### \/#|### |/####                           ~
-   d8   888                      ##\/#/ \||/##/_/##/_#                         ~
-  d88   888 ee   ,e e,         ###  \/###|/ \/ # ###                           ~
- d88888 888 88b d88 88b      ##_\_#\_\## | #/###_/_####                        ~
-  888   888 888 888   ,     ## #### # \ #| /  #### ##/##                       ~
-  888   888 888  "YeeP"     __#_--###`. |{,###---###-~                         ~
-                                     \ % @%                                    ~
-  Y88b Y88 888'Y88 888 88e  888 88e   \%@%  88P'888'Y88                        ~
-   Y88b Y8 888 ,'Y 888 888D 888 888b   %o%  P'  888  'Y 888,8,  ,e e,   ,e e,  ~
-  b Y88b Y 888C8   888 88"  888 8888D  %@%      888     888 "  d88 88b d88 88b ~
-  8b Y88b  888 ",d 888 b,   888 888P   %@%      888     888    888   , 888   , ~
-  88b Y88b 888,d88 888 88b, 888 88"    %@%      888     888     "YeeP"  "YeeP" ~
-                                 , -=-%{@%-^- _                                ~
-                                   ejm `}               Reference Manual       ~
-                                        {                                      ~
-==============================================================================
-CONTENTS                                                     *NERDTree-contents*
-
-    1.Intro...................................|NERDTree|
-    2.Functionality provided..................|NERDTreeFunctionality|
-        2.1.Global commands...................|NERDTreeGlobalCommands|
-        2.2.Bookmarks.........................|NERDTreeBookmarks|
-            2.2.1.The bookmark table..........|NERDTreeBookmarkTable|
-            2.2.2.Bookmark commands...........|NERDTreeBookmarkCommands|
-            2.2.3.Invalid bookmarks...........|NERDTreeInvalidBookmarks|
-        2.3.NERDTree mappings.................|NERDTreeMappings|
-        2.4.The NERDTree menu.................|NERDTreeMenu|
-    3.Settings................................|NERDTreeSettings|
-        3.1.Settings summary..................|NERDTreeSettingsSummary|
-        3.2.Settings details..................|NERDTreeSettingsDetails|
-    4.The NERDTree API........................|NERDTreeAPI|
-        4.1.Key map API.......................|NERDTreeKeymapAPI|
-        4.2.Menu API..........................|NERDTreeMenuAPI|
-        4.3.Menu API..........................|NERDTreeAddPathFilter()|
-        4.4.Path Listener API.................|NERDTreePathListenerAPI|
-    5.About...................................|NERDTreeAbout|
-    6.License.................................|NERDTreeLicense|
-
-==============================================================================
-1. Intro                                                              *NERDTree*
-
-What is this "NERDTree"??
-
-The NERDTree allows you to explore your filesystem and to open files and
-directories. It presents the filesystem to you in the form of a tree which you
-manipulate with the keyboard and/or mouse. It also allows you to perform
-simple filesystem operations.
-
-The following features and functionality are provided by the NERDTree:
-    * Files and directories are displayed in a hierarchical tree structure
-    * Different highlighting is provided for the following types of nodes:
-        * files
-        * directories
-        * sym-links
-        * windows .lnk files
-        * read-only files
-        * executable files
-    * Many (customisable) mappings are provided to manipulate the tree:
-        * Mappings to open/close/explore directory nodes
-        * Mappings to open files in new/existing windows/tabs
-        * Mappings to change the current root of the tree
-        * Mappings to navigate around the tree
-        * ...
-    * Directories and files can be bookmarked.
-    * Most NERDTree navigation can also be done with the mouse
-    * Filtering of tree content (can be toggled at runtime)
-        * custom file filters to prevent e.g. vim backup files being displayed
-        * optional displaying of hidden files (. files)
-        * files can be "turned off" so that only directories are displayed
-    * The position and size of the NERDTree window can be customised
-    * The order in which the nodes in the tree are listed can be customised.
-    * A model of your filesystem is created/maintained as you explore it. This
-      has several advantages:
-        * All filesystem information is cached and is only re-read on demand
-        * If you revisit a part of the tree that you left earlier in your
-          session, the directory nodes will be opened/closed as you left them
-    * The script remembers the cursor position and window position in the NERD
-      tree so you can toggle it off (or just close the tree window) and then
-      reopen it (with NERDTreeToggle) the NERDTree window will appear exactly
-      as you left it
-    * You can have a separate NERDTree for each tab, share trees across tabs,
-      or a mix of both.
-    * By default the script overrides the default file browser (netrw), so if
-      you :edit a directory a (slightly modified) NERDTree will appear in the
-      current window
-    * A programmable menu system is provided (simulates right clicking on a
-      node)
-        * one default menu plugin is provided to perform basic filesystem
-          operations (create/delete/move/copy files/directories)
-    * There's an API for adding your own keymappings
-
-
-==============================================================================
-2. Functionality provided                                *NERDTreeFunctionality*
-
-------------------------------------------------------------------------------
-2.1. Global Commands                                    *NERDTreeGlobalCommands*
-
-:NERDTree [<start-directory> | <bookmark>]                           *:NERDTree*
-    Opens a fresh NERDTree. The root of the tree depends on the argument
-    given. There are 3 cases: If no argument is given, the current directory
-    will be used.  If a directory is given, that will be used. If a bookmark
-    name is given, the corresponding directory will be used.  For example: >
-        :NERDTree /home/marty/vim7/src
-        :NERDTree foo   (foo is the name of a bookmark)
-<
-:NERDTreeVCS [<start-directory> | <bookmark>]                     *:NERDTreeVCS*
-    Like |:NERDTree|, but searches up the directory tree to find the top of
-    the version control system repository, and roots the NERDTree there. It
-    works with Git, Subversion, Mercurial, Bazaar, and Darcs repositories. A
-    couple of examples: >
-        :NERDTreeVCS /home/marty/nerdtree/doc  (opens /home/marty/nerdtree)
-        :NERDTreeVCS              (opens root of repository containing CWD)
-<
-:NERDTreeFromBookmark <bookmark>                         *:NERDTreeFromBookmark*
-    Opens a fresh NERDTree with the root initialized to the dir for
-    <bookmark>.  The only reason to use this command over :NERDTree is for
-    the completion (which is for bookmarks rather than directories).
-
-:NERDTreeToggle [<start-directory> | <bookmark>]               *:NERDTreeToggle*
-    If a NERDTree already exists for this tab, it is reopened and rendered
-    again. If <start-directory> or <bookmark> is given, the root of NERDTree
-    is set to that path. If no NERDTree exists for this tab then this command
-    acts the same as the |:NERDTree| command.
-
-:NERDTreeToggleVCS [<start-directory> | <bookmark>]            *:NERDTreeToggleVCS*
-    Like |:NERDTreeToggle|, but searches up the directory tree to find the top of
-    the version control system repository, and roots the NERDTree there. It
-    works with Git, Subversion, Mercurial, Bazaar, and Darcs repositories. A
-    couple of examples: >
-        :NERDTreeToggleVCS /home/marty/nerdtree/doc  (opens /home/marty/nerdtree)
-        :NERDTreeToggleVCS              (opens root of repository containing CWD)
-
-:NERDTreeFocus                                                  *:NERDTreeFocus*
-    Opens (or reopens) the NERDTree if it is not currently visible;
-    otherwise, the cursor is moved to the already-open NERDTree.
-
-:NERDTreeMirror                                                *:NERDTreeMirror*
-    Shares an existing NERDTree, from another tab, in the current tab.
-    Changes made to one tree are reflected in both as they are actually the
-    same buffer.
-
-    If only one other NERDTree exists, that tree is automatically mirrored.
-    If more than one exists, the script will ask which tree to mirror.
-
-:NERDTreeClose                                                  *:NERDTreeClose*
-    Close the NERDTree in this tab.
-
-:NERDTreeFind [<path>]                                           *:NERDTreeFind*
-    Without the optional argument, find and reveal the file for the active
-    buffer in the NERDTree window.  With the <path> argument, find and
-    reveal the specified path.
-
-    Focus will be shifted to the NERDTree window, and the cursor will be
-    placed on the tree node for the determined path.  If a NERDTree for the
-    current tab does not exist, a new one will be initialized.
-
-:NERDTreeCWD                                                      *:NERDTreeCWD*
-    Change the NERDTree root to the current working directory.  If no
-    NERDTree exists for this tab, a new one is opened.
-
-:NERDTreeRefreshRoot                                      *:NERDTreeRefreshRoot*
-    Refreshes the NERDTree root node.
-
-------------------------------------------------------------------------------
-2.2. Bookmarks                                               *NERDTreeBookmarks*
-
-Bookmarks in the NERDTree are a way to tag files or directories of interest.
-For example, you could use bookmarks to tag all of your project directories.
-
-------------------------------------------------------------------------------
-2.2.1. The Bookmark Table                                *NERDTreeBookmarkTable*
-
-If the bookmark table is active (see |NERDTree-B| and
-|NERDTreeShowBookmarks|), it will be rendered above the tree. You can double
-click bookmarks or use the |NERDTree-o| mapping to activate them. See also,
-|NERDTree-t| and |NERDTree-T|
-
-------------------------------------------------------------------------------
-2.2.2. Bookmark commands                              *NERDTreeBookmarkCommands*
-
-Note: The following commands are only available within the NERDTree buffer.
-
-:Bookmark [<name>]
-    Bookmark the current node as <name>. If there is already a <name>
-    bookmark, it is overwritten. <name> must not contain spaces.
-    If <name> is not provided, it defaults to the file or directory name.
-    For directories, a trailing slash is present.
-
-:BookmarkToRoot <bookmark>
-    Make the directory corresponding to <bookmark> the new root. If a treenode
-    corresponding to <bookmark> is already cached somewhere in the tree then
-    the current tree will be used, otherwise a fresh tree will be opened.
-    Note that if <bookmark> points to a file then its parent will be used
-    instead.
-
-:RevealBookmark <bookmark>
-    If the node is cached under the current root then it will be revealed
-    (i.e. directory nodes above it will be opened) and the cursor will be
-    placed on it.
-
-:OpenBookmark <name>
-    The Bookmark named <name> is opened as if |NERDTree-o| was applied to
-    its entry in the Bookmark table. If the Bookmark points to a directory,
-    it is made the new root of the current NERDTree. If the Bookmark points
-    to a file, that file is opened for editing in another window.
-
-:ClearBookmarks [<bookmarks>]
-    Remove all the given bookmarks. If no bookmarks are given then remove all
-    bookmarks on the current node.
-
-:ClearAllBookmarks
-    Remove all bookmarks.
-
-:EditBookmarks
-    Opens the bookmarks file for manual editing, e.g. for removing invalid
-    bookmarks.
-
-:ReadBookmarks
-    Re-read the bookmarks in the |NERDTreeBookmarksFile|.
-
-See also |:NERDTree| and |:NERDTreeFromBookmark|.
-
-------------------------------------------------------------------------------
-2.2.3. Invalid Bookmarks                              *NERDTreeInvalidBookmarks*
-
-If invalid bookmarks are detected, the script will issue an error message and
-the invalid bookmarks will become unavailable for use.
-
-These bookmarks will still be stored in the bookmarks file (see
-|NERDTreeBookmarksFile|), down at the bottom. There will always be a blank line
-after the valid bookmarks but before the invalid ones.
-
-Each line in the bookmarks file represents one bookmark. The proper format is:
-<bookmark name><space><full path to the bookmark location>
-
-You can use the :EditBookmarks command to open the bookmarks file for editing.
-After you have corrected any invalid bookmarks, either restart vim, or run
-:ReadBookmarks from the NERDTree window.
-
-------------------------------------------------------------------------------
-2.3. NERDTree Mappings                                        *NERDTreeMappings*
-
-Default~
-Key      Description                                                  help-tag~
-
-o........Open files, directories and bookmarks......................|NERDTree-o|
-go.......Open selected file, but leave cursor in the NERDTree......|NERDTree-go|
-         Open selected bookmark dir in current NERDTree
-t........Open selected node/bookmark in a new tab...................|NERDTree-t|
-T........Same as 't' but keep the focus on the current tab..........|NERDTree-T|
-i........Open selected file in a split window.......................|NERDTree-i|
-gi.......Same as i, but leave the cursor on the NERDTree...........|NERDTree-gi|
-s........Open selected file in a new vsplit.........................|NERDTree-s|
-gs.......Same as s, but leave the cursor on the NERDTree...........|NERDTree-gs|
-<CR>.....User-definable custom open action.......................|NERDTree-<CR>|
-O........Recursively open the selected directory....................|NERDTree-O|
-x........Close the current nodes parent.............................|NERDTree-x|
-X........Recursively close all children of the current node.........|NERDTree-X|
-e........Edit the current dir.......................................|NERDTree-e|
-
-double-click....same as |NERDTree-o|.
-middle-click....same as |NERDTree-i| for files, and |NERDTree-e| for dirs.
-
-D........Delete the current bookmark ...............................|NERDTree-D|
-
-P........Jump to the root node......................................|NERDTree-P|
-p........Jump to current nodes parent...............................|NERDTree-p|
-K........Jump up inside directories at the current tree depth.......|NERDTree-K|
-J........Jump down inside directories at the current tree depth.....|NERDTree-J|
-<C-J>....Jump down to next sibling of the current directory.......|NERDTree-C-J|
-<C-K>....Jump up to previous sibling of the current directory.....|NERDTree-C-K|
-
-C........Change the tree root to the selected dir...................|NERDTree-C|
-u........Move the tree root up one directory........................|NERDTree-u|
-U........Same as 'u' except the old root node is left open..........|NERDTree-U|
-r........Recursively refresh the current directory..................|NERDTree-r|
-R........Recursively refresh the current root.......................|NERDTree-R|
-m........Display the NERDTree menu..................................|NERDTree-m|
-cd.......Change the CWD to the dir of the selected node............|NERDTree-cd|
-CD.......Change tree root to the CWD...............................|NERDTree-CD|
-
-I........Toggle whether hidden files displayed......................|NERDTree-I|
-f........Toggle whether the file filters are used...................|NERDTree-f|
-F........Toggle whether files are displayed.........................|NERDTree-F|
-B........Toggle whether the bookmark table is displayed.............|NERDTree-B|
-
-q........Close the NERDTree window..................................|NERDTree-q|
-A........Zoom (maximize/minimize) the NERDTree window...............|NERDTree-A|
-?........Toggle the display of the quick help.......................|NERDTree-?|
-
-------------------------------------------------------------------------------
-                                                                    *NERDTree-o*
-Default key: o
-Map setting: NERDTreeMapActivateNode
-Applies to: files and directories.
-
-If a file node is selected, it is opened in the previous window.
-
-If a directory is selected it is opened or closed depending on its current
-state.
-
-If a bookmark that links to a directory is selected then that directory
-becomes the new root.
-
-If a bookmark that links to a file is selected then that file is opened in the
-previous window.
-
-------------------------------------------------------------------------------
-                                                                   *NERDTree-go*
-Default key: go
-Map setting: NERDTreeMapPreview
-Applies to: files.
-
-If a file node or a bookmark that links to a file is selected, it is opened in
-the previous window, but the cursor does not move.
-
-If a bookmark that links to a directory is selected, that directory is found
-in the current NERDTree. If the directory couldn't be found, a new NERDTree is
-created.
-
-The default key combo for this mapping is "g" + NERDTreeMapActivateNode (see
-|NERDTree-o|).
-
-------------------------------------------------------------------------------
-                                                                    *NERDTree-t*
-Default key: t
-Map setting: *NERDTreeMapOpenInTab*
-Applies to: files and directories.
-
-Opens the selected file in a new tab. If a directory is selected, a fresh
-NERDTree for that directory is opened in a new tab.
-
-If a bookmark which points to a directory is selected, open a NERDTree for
-that directory in a new tab. If the bookmark points to a file, open that file
-in a new tab.
-
-------------------------------------------------------------------------------
-                                                                    *NERDTree-T*
-Default key: T
-Map setting: *NERDTreeMapOpenInTabSilent*
-Applies to: files and directories.
-
-The same as |NERDTree-t| except that the focus is kept in the current tab.
-
-------------------------------------------------------------------------------
-                                                                    *NERDTree-i*
-Default key: i
-Map setting: *NERDTreeMapOpenSplit*
-Applies to: files.
-
-Opens the selected file in a new split window and puts the cursor in the new
-window.
-
-------------------------------------------------------------------------------
-                                                                   *NERDTree-gi*
-Default key: gi
-Map setting: *NERDTreeMapPreviewSplit*
-Applies to: files.
-
-The same as |NERDTree-i| except that the cursor is not moved.
-
-The default key combo for this mapping is "g" + NERDTreeMapOpenSplit (see
-|NERDTree-i|).
-
-------------------------------------------------------------------------------
-                                                                    *NERDTree-s*
-Default key: s
-Map setting: *NERDTreeMapOpenVSplit*
-Applies to: files.
-
-Opens the selected file in a new vertically split window and puts the cursor
-in the new window.
-
-------------------------------------------------------------------------------
-                                                                   *NERDTree-gs*
-Default key: gs
-Map setting: *NERDTreeMapPreviewVSplit*
-Applies to: files.
-
-The same as |NERDTree-s| except that the cursor is not moved.
-
-The default key combo for this mapping is "g" + NERDTreeMapOpenVSplit (see
-|NERDTree-s|).
-
-------------------------------------------------------------------------------
-                                                                 *NERDTree-<CR>*
-Default key: <CR>
-Map setting: *NERDTreeMapCustomOpen*
-Applies to: files, directories, and bookmarks
-
-Performs a customized open action on the selected node. This allows the user
-to define an action that behaves differently from any of the standard
-keys. See |NERDTreeCustomOpenArgs| for more details.
-------------------------------------------------------------------------------
-                                                                    *NERDTree-O*
-Default key: O
-Map setting: *NERDTreeMapOpenRecursively*
-Applies to: directories.
-
-Recursively opens the selected directory.
-
-All files and directories are cached, but if a directory would not be
-displayed due to file filters (see |NERDTreeIgnore| |NERDTree-f|) or the
-hidden file filter (see |NERDTreeShowHidden|) then its contents are not
-cached. This is handy, especially if you have .svn directories.
-
-------------------------------------------------------------------------------
-                                                                    *NERDTree-x*
-Default key: x
-Map setting: *NERDTreeMapCloseDir*
-Applies to: files and directories.
-
-Closes the parent of the selected node.
-
-------------------------------------------------------------------------------
-                                                                    *NERDTree-X*
-Default key: X
-Map setting: *NERDTreeMapCloseChildren*
-Applies to: directories.
-
-Recursively closes all children of the selected directory.
-
-Tip: To quickly "reset" the tree, use |NERDTree-P| with this mapping.
-
-------------------------------------------------------------------------------
-                                                                    *NERDTree-e*
-Default key: e
-Map setting: *NERDTreeMapOpenExpl*
-Applies to: files and directories.
-
-|:edit|s the selected directory, or the selected file's directory. This could
-result in a NERDTree or a netrw being opened, depending on
-|NERDTreeHijackNetrw|.
-
-------------------------------------------------------------------------------
-                                                                    *NERDTree-D*
-Default key: D
-Map setting: *NERDTreeMapDeleteBookmark*
-Applies to: lines in the bookmarks table
-
-Deletes the currently selected bookmark.
-
-------------------------------------------------------------------------------
-                                                                    *NERDTree-P*
-Default key: P
-Map setting: *NERDTreeMapJumpRoot*
-Applies to: no restrictions.
-
-Jump to the tree root.
-
-------------------------------------------------------------------------------
-                                                                    *NERDTree-p*
-Default key: p
-Map setting: *NERDTreeMapJumpParent*
-Applies to: files and directories.
-
-Jump to the parent node of the selected node.
-
-------------------------------------------------------------------------------
-                                                                    *NERDTree-K*
-Default key: K
-Map setting: *NERDTreeMapJumpFirstChild*
-Applies to: files and directories.
-
-Jump to the first child of the current nodes parent.
-
-If the cursor is already on the first node then do the following:
-    * loop back thru the siblings of the current nodes parent until we find an
-      open dir with children
-    * go to the first child of that node
-
-------------------------------------------------------------------------------
-                                                                    *NERDTree-J*
-Default key: J
-Map setting: *NERDTreeMapJumpLastChild*
-Applies to: files and directories.
-
-Jump to the last child of the current nodes parent.
-
-If the cursor is already on the last node then do the following:
-    * loop forward thru the siblings of the current nodes parent until we find
-      an open dir with children
-    * go to the last child of that node
-
-------------------------------------------------------------------------------
-                                                                  *NERDTree-C-J*
-Default key: <C-J>
-Map setting: *NERDTreeMapJumpNextSibling*
-Applies to: files and directories.
-
-Jump to the next sibling of the selected node.
-
-------------------------------------------------------------------------------
-                                                                  *NERDTree-C-K*
-Default key: <C-K>
-Map setting: *NERDTreeMapJumpPrevSibling*
-Applies to: files and directories.
-
-Jump to the previous sibling of the selected node.
-
-------------------------------------------------------------------------------
-                                                                    *NERDTree-C*
-Default key: C
-Map setting: *NERDTreeMapChangeRoot*
-Applies to: files and directories.
-
-Make the selected directory node the new tree root. If a file is selected, its
-parent is used.
-
-------------------------------------------------------------------------------
-                                                                    *NERDTree-u*
-Default key: u
-Map setting: *NERDTreeMapUpdir*
-Applies to: no restrictions.
-
-Move the tree root up a dir (like doing a "cd ..").
-
-------------------------------------------------------------------------------
-                                                                    *NERDTree-U*
-Default key: U
-Map setting: *NERDTreeMapUpdirKeepOpen*
-Applies to: no restrictions.
-
-Like |NERDTree-u| except that the old tree root is kept open.
-
-------------------------------------------------------------------------------
-                                                                    *NERDTree-r*
-Default key: r
-Map setting: *NERDTreeMapRefresh*
-Applies to: files and directories.
-
-If a dir is selected, recursively refresh that dir, i.e. scan the filesystem
-for changes and represent them in the tree.
-
-If a file node is selected then the above is done on it's parent.
-
-------------------------------------------------------------------------------
-                                                                    *NERDTree-R*
-Default key: R
-Map setting: *NERDTreeMapRefreshRoot*
-Applies to: no restrictions.
-
-Recursively refresh the tree root.
-
-------------------------------------------------------------------------------
-                                                                    *NERDTree-m*
-Default key: m
-Map setting: *NERDTreeMapMenu*
-Applies to: files and directories.
-
-Display the NERDTree menu. See |NERDTreeMenu| for details.
-
-------------------------------------------------------------------------------
-                                                                   *NERDTree-cd*
-Default key: cd
-Map setting: *NERDTreeMapChdir*
-Applies to: files and directories.
-
-Change Vim's current working directory to that of the selected node.
-
-------------------------------------------------------------------------------
-                                                                   *NERDTree-CD*
-Default key: CD
-Map setting: *NERDTreeMapCWD*
-Applies to: no restrictions.
-
-Change the NERDTree root to Vim's current working directory.
-
-------------------------------------------------------------------------------
-                                                                    *NERDTree-I*
-Default key: I
-Map setting: *NERDTreeMapToggleHidden*
-Applies to: no restrictions.
-
-Toggles whether hidden files (i.e. "dot files") are displayed.
-
-------------------------------------------------------------------------------
-                                                                    *NERDTree-f*
-Default key: f
-Map setting: *NERDTreeMapToggleFilters*
-Applies to: no restrictions.
-
-Toggles whether file filters are used. See |NERDTreeIgnore| for details.
-
-------------------------------------------------------------------------------
-                                                                    *NERDTree-F*
-Default key: F
-Map setting: *NERDTreeMapToggleFiles*
-Applies to: no restrictions.
-
-Toggles whether file nodes are displayed.
-
-------------------------------------------------------------------------------
-                                                                    *NERDTree-B*
-Default key: B
-Map setting: *NERDTreeMapToggleBookmarks*
-Applies to: no restrictions.
-
-Toggles whether the bookmarks table is displayed.
-
-------------------------------------------------------------------------------
-                                                                    *NERDTree-q*
-Default key: q
-Map setting: *NERDTreeMapQuit*
-Applies to: no restrictions.
-
-Closes the NERDTree window.
-
-------------------------------------------------------------------------------
-                                                                    *NERDTree-A*
-Default key: A
-Map setting: *NERDTreeMapToggleZoom*
-Applies to: no restrictions.
-
-Maximize (zoom) and minimize the NERDTree window.
-
-------------------------------------------------------------------------------
-                                                                    *NERDTree-?*
-Default key: ?
-Map setting: *NERDTreeMapHelp*
-Applies to: no restrictions.
-
-Toggles whether the quickhelp is displayed.
-
-------------------------------------------------------------------------------
- 2.3. The NERDTree menu                                           *NERDTreeMenu*
-
-The NERDTree has a menu that can be programmed via the an API (see
-|NERDTreeMenuAPI|). The idea is to simulate the "right click" menus that most
-file explorers have.
-
-The script comes with two default menu plugins: exec_menuitem.vim and
-fs_menu.vim. fs_menu.vim adds some basic filesystem operations to the menu for
-creating/deleting/moving/copying files and dirs. exec_menuitem.vim provides a
-menu item to execute executable files.
-
-Related tags: |NERDTree-m| |NERDTreeApi|
-
-------------------------------------------------------------------------------
-                                                                *NERDTreeMenu-j*
-Default key: j
-Map option: *NERDTreeMenuDown*
-Applies to: The NERDTree menu.
-
-Moves the cursor down.
-
-------------------------------------------------------------------------------
-                                                                *NERDTreeMenu-k*
-Default key: k
-Map option: *NERDTreeMenuUp*
-Applies to: The NERDTree menu.
-
-Moves the cursor up.
-
-==============================================================================
-3. Customisation                                              *NERDTreeSettings*
-
-
-------------------------------------------------------------------------------
-3.1. Customisation summary                             *NERDTreeSettingsSummary*
-
-The plugin provides the following settings that can customise the behaviour
-the NERDTree. These settings should be set in your vimrc, using `:let`.
-
-|loaded_nerd_tree|            Turns off the script.
-
-|NERDTreeAutoCenter|          Controls whether the NERDTree window centers
-                            when the cursor moves within a specified
-                            distance to the top/bottom of the window.
-
-|NERDTreeAutoCenterThreshold| Controls the sensitivity of autocentering.
-
-|NERDTreeCaseSensitiveSort|   Tells the NERDTree whether to be case
-                            sensitive or not when sorting nodes.
-
-|NERDTreeNaturalSort|         Tells the NERDTree whether to use natural sort
-                            order or not when sorting nodes.
-
-|NERDTreeSortHiddenFirst|     Tells the NERDTree whether to take the dot at
-                            the beginning of the hidden file names into
-                            account when sorting nodes.
-
-|NERDTreeChDirMode|           Tells the NERDTree if/when it should change
-                            vim's current working directory.
-
-|NERDTreeHighlightCursorline| Tell the NERDTree whether to highlight the
-                            current cursor line.
-
-|NERDTreeHijackNetrw|         Tell the NERDTree whether to replace the netrw
-                            autocommands for exploring local directories.
-
-|NERDTreeIgnore|              Tells the NERDTree which files to ignore.
-
-|NERDTreeRespectWildIgnore|   Tells the NERDTree to respect `'wildignore'`.
-
-|NERDTreeBookmarksFile|       Where the bookmarks are stored.
-
-|NERDTreeBookmarksSort|       Control how the Bookmark table is sorted.
-
-|NERDTreeMarkBookmarks|       Render bookmarked nodes with markers.
-
-|NERDTreeMouseMode|           Manage the interpretation of mouse clicks.
-
-|NERDTreeQuitOnOpen|          Closes the tree window or bookmark table after
-                            opening a file.
-
-|NERDTreeShowBookmarks|       Tells the NERDTree whether to display the
-                            bookmarks table on startup.
-
-|NERDTreeShowFiles|           Tells the NERDTree whether to display files in
-                            the tree on startup.
-
-|NERDTreeShowHidden|          Tells the NERDTree whether to display hidden
-                            files on startup.
-
-|NERDTreeShowLineNumbers|     Tells the NERDTree whether to display line
-                            numbers in the tree window.
-
-|NERDTreeSortOrder|           Tell the NERDTree how to sort the nodes in the
-                            tree.
-
-|NERDTreeStatusline|          Set a statusline for NERDTree windows.
-
-|NERDTreeWinPos|              Tells the script where to put the NERDTree
-                            window.
-
-|NERDTreeWinSize|             Sets the window size when the NERDTree is
-                            opened.
-
-|NERDTreeWinSizeMax|          Sets the maximum window size when the NERDTree
-                            is zoomed.
-
-|NERDTreeMinimalUI|           Disables display of the 'Bookmarks' label and
-                            'Press ? for help' text.
-
-|NERDTreeMinimalMenu|         Use a compact menu that fits on a single line
-                            for adding, copying, deleting, etc
-
-|NERDTreeCascadeSingleChildDir|
-                            Collapses on the same line directories that have
-                            only one child directory.
-
-|NERDTreeCascadeOpenSingleChildDir|
-                            Cascade open while selected directory has only
-                            one child that also is a directory.
-
-|NERDTreeAutoDeleteBuffer|    Tells the NERDTree to automatically remove a
-                            buffer when a file is being deleted or renamed
-                            via a context menu command.
-
-|NERDTreeCreatePrefix|        Specify a prefix to be used when creating the
-                            NERDTree window.
-
-|NERDTreeRemoveFileCmd|       Specify a custom shell command to be used when
-                            deleting files. Note that it should include one
-                            space character at the end of the command and it
-                            applies only to files.
-
-|NERDTreeRemoveDirCmd|        Specify a custom shell command to be used when
-                            deleting directories. Note that it should
-                            include one space character at the end of the
-                            command and it applies only to directories.
-
-|NERDTreeDirArrowCollapsible| These characters indicate when a directory is
-|NERDTreeDirArrowExpandable|  either collapsible or expandable.
-
-|NERDTreeNodeDelimiter|       A single character that is used to separate the
-                            file or directory name from the rest of the
-                            characters on the line of text.
-
-|NERDTreeCustomOpenArgs|      A dictionary with values that control how a node
-                            is opened with the |NERDTree-<CR>| key.
-
-------------------------------------------------------------------------------
-3.2. Customisation details                             *NERDTreeSettingsDetails*
-
-To enable any of the below settings you should put an appropriate >
-    let <setting>=<value>
-<line in your ~/.vimrc.
-
-                                                              *loaded_nerd_tree*
-If this plugin is making you feel homicidal, it may be a good idea to turn it
-off with this line in your vimrc: >
-    let loaded_nerd_tree=1
-<
-------------------------------------------------------------------------------
-                                                            *NERDTreeAutoCenter*
-Values: 0 or 1.
-Default: 1
-
-If set to 1, the NERDTree window will center around the cursor if it moves to
-within |NERDTreeAutoCenterThreshold| lines of the top/bottom of the window.
-
-This is ONLY done in response to tree navigation mappings,
-i.e. |NERDTree-J| |NERDTree-K| |NERDTree-C-J| |NERDTree-C-K| |NERDTree-p|
-|NERDTree-P|
-
-The centering is done with a |zz| operation.
-
-------------------------------------------------------------------------------
-                                                   *NERDTreeAutoCenterThreshold*
-Values: Any natural number.
-Default: 3
-
-This setting controls the "sensitivity" of the NERDTree auto centering. See
-|NERDTreeAutoCenter| for details.
-
-------------------------------------------------------------------------------
-                                                     *NERDTreeCaseSensitiveSort*
-Values: 0 or 1.
-Default: 0.
-
-By default the NERDTree does not sort nodes case sensitively, i.e. nodes
-could appear like this: >
-    bar.c
-    Baz.c
-    blarg.c
-    boner.c
-    Foo.c
-<
-But, if you set this setting to 1 then the case of the nodes will be taken
-into account. The above nodes would then be sorted like this: >
-    Baz.c
-    Foo.c
-    bar.c
-    blarg.c
-    boner.c
-<
-------------------------------------------------------------------------------
-                                                           *NERDTreeNaturalSort*
-Values: 0 or 1.
-Default: 0.
-
-By default the NERDTree does not sort nodes in natural sort order, i.e. nodes
-could appear like this: >
-    z1.txt
-    z10.txt
-    z100.txt
-    z11.txt
-    z110.txt
-    z2.txt
-    z20.txt
-    z3.txt
-<
-But if you set this setting to 1 then the natural sort order will be used. The
-above nodes would then be sorted like this: >
-    z1.txt
-    z2.txt
-    z3.txt
-    z10.txt
-    z11.txt
-    z20.txt
-    z100.txt
-    z110.txt
-<
-------------------------------------------------------------------------------
-                                                                *NERDTreeUseTCD*
-Values: 0 or 1.
-Default: 0.
-
-By default, NERDTree will use the `:cd` command to change the current working
-directory. If this setting is turned on, and the `:tcd` command is available, it
-will be used instead.
-
-------------------------------------------------------------------------------
-                                                             *NERDTreeChDirMode*
-Values: 0, 1, 2, or 3.
-Default: 0.
-
-Use this setting to tell the script when (if at all) to change the current
-working directory (CWD) for vim.
-
-If it is set to 0 then the CWD is never changed by the NERDTree.
-
-If set to 1 then the CWD is changed when the NERDTree is first loaded to the
-directory it is initialized in. For example, if you start the NERDTree with >
-    :NERDTree /home/marty/foobar
-<
-then the CWD will be changed to /home/marty/foobar and will not be changed
-again unless you init another NERDTree with a similar command.
-
-If the setting is set to 2 then it behaves the same as if set to 1 except that
-the CWD is changed whenever the tree root is changed. For example, if the CWD
-is /home/marty/foobar and you make the node for /home/marty/foobar/baz the new
-root then the CWD will become /home/marty/foobar/baz.
-
-If the set to 3, then it behaves the same as if set to 2, and the CWD is
-changed whenever changing tabs to whatever the tree root is on that tab.
-
-------------------------------------------------------------------------------
-                                                   *NERDTreeHighlightCursorline*
-Values: 0 or 1.
-Default: 1.
-
-If set to 1, the current cursor line in the NERDTree buffer will be
-highlighted. This is done using the `'cursorline'` Vim option.
-
-------------------------------------------------------------------------------
-                                                           *NERDTreeHijackNetrw*
-Values: 0 or 1.
-Default: 1.
-
-If set to 1, doing a >
-    :edit <some directory>
-<
-will open up a window level NERDTree instead of a netrw in the target window.
-
-Window level trees behaves slightly different from a regular trees in the
-following respects:
-    1. 'o' will open the selected file in the same window as the tree,
-       replacing it.
-    2. you can have one tree per window - instead of per tab.
-
-------------------------------------------------------------------------------
-                                                                *NERDTreeIgnore*
-Values: a list of regular expressions.
-Default: ['\~$'].
-
-This setting is used to specify which files the NERDTree should ignore.  It
-must be a list of regular expressions. When the NERDTree is rendered, any
-files/dirs that match any of the regex's in NERDTreeIgnore won't be
-displayed.
-
-For example if you put the following line in your vimrc: >
-    let NERDTreeIgnore=['\.vim$', '\~$']
-<
-then all files ending in .vim or ~ will be ignored.
-
-There are 2 magic flags that can be appended to the end of each regular
-expression to specify that the regex should match only files or only dirs.
-These flags are "[[dir]]" and "[[file]]". Example: >
-    let NERDTreeIgnore=['\.d$[[dir]]', '\.o$[[file]]']
-<
-This will cause all dirs ending in ".d" to be ignored and all files ending in
-".o" to be ignored.
-
-Note: to tell the NERDTree not to ignore any files you must use the following
-line: >
-    let NERDTreeIgnore=[]
-<
-The file filters can be turned on and off dynamically with the |NERDTree-f|
-mapping.
-
-------------------------------------------------------------------------------
-                                                     *NERDTreeRespectWildIgnore*
-Values: 0 or 1.
-Default: 0.
-
-If set to 1, the `'wildignore'` setting is respected.
-
-------------------------------------------------------------------------------
-                                                         *NERDTreeBookmarksFile*
-Values: a path
-Default: $HOME/.NERDTreeBookmarks
-
-This is where bookmarks are saved. See |NERDTreeBookmarkCommands|.
-
-------------------------------------------------------------------------------
-                                                         *NERDTreeBookmarksSort*
-Values: 0, 1, or 2
-Default: 1
-
-This setting controls the method by which the list of user bookmarks is
-sorted. When sorted, bookmarks will render in alphabetical order by name.
-
-If set to 0, the bookmarks list is not sorted.
-If set to 1, the bookmarks list is sorted in a case-insensitive manner.
-If set to 2, the bookmarks list is sorted in a case-sensitive manner.
-
-------------------------------------------------------------------------------
-                                                         *NERDTreeMarkBookmarks*
-Values: 0 or 1
-Default: 1
-
-If set to 1, Bookmarks will be specially marked whenever the NERDTree is
-rendered. Users of the |NERDTreeMinimalUI| setting may prefer to disable
-this setting for even less visual clutter.
-
-------------------------------------------------------------------------------
-                                                             *NERDTreeMouseMode*
-Values: 1, 2 or 3.
-Default: 1.
-
-If set to 1 then a double click on a node is required to open it.
-If set to 2 then a single click will open directory nodes, while a double
-click will still be required for file nodes.
-If set to 3 then a single click will open any node.
-
-Note: a double click anywhere on a line that a tree node is on will
-activate it, but all single-click activations must be done on name of the node
-itself. For example, if you have the following node: >
-    | | |-application.rb
-<
-then (to single click activate it) you must click somewhere in
-'application.rb'.
-
-------------------------------------------------------------------------------
-                                                            *NERDTreeQuitOnOpen*
-Values: 0,1,2 or 3.
-Default: 0
-
-This setting governs whether the NERDTree window or the bookmarks table closes
-after opening a file with the |NERDTree-o|, |NERDTree-i|, |NERDTree-t| and
-|NERDTree-T| mappings.
-
- Value  | NERDTree Window Behavior
- -------+-------------------------------------------------------
- 0      | No change
- 1      | Closes after opening a file
- 2      | Closes the bookmark table after opening a bookmark
- 3(1+2) | Same as both 1 and 2
-
-------------------------------------------------------------------------------
-                                                         *NERDTreeShowBookmarks*
-Values: 0 or 1.
-Default: 0.
-
-If this setting is set to 1 then the bookmarks table will be displayed.
-
-This setting can be toggled dynamically, per tree, with the |NERDTree-B|
-mapping.
-
-------------------------------------------------------------------------------
-                                                             *NERDTreeShowFiles*
-Values: 0 or 1.
-Default: 1.
-
-If this setting is set to 1 then files are displayed in the NERDTree. If it
-is set to 0 then only directories are displayed.
-
-This setting can be toggled dynamically, per tree, with the |NERDTree-F|
-mapping and is useful for drastically shrinking the tree when you are
-navigating to a different part of the tree.
-
-------------------------------------------------------------------------------
-                                                            *NERDTreeShowHidden*
-Values: 0 or 1.
-Default: 0.
-
-This setting tells vim whether to display hidden files by default. This
-setting can be dynamically toggled, per tree, with the |NERDTree-I| mapping.
-Use one of the follow lines for this setting: >
-    let NERDTreeShowHidden=0
-    let NERDTreeShowHidden=1
-<
-------------------------------------------------------------------------------
-                                                       *NERDTreeShowLineNumbers*
-Values: 0 or 1.
-Default: 0.
-
-This setting tells vim whether to display line numbers for the NERDTree
-window.  Use one of the follow lines for this setting: >
-    let NERDTreeShowLineNumbers=0
-    let NERDTreeShowLineNumbers=1
-<
-------------------------------------------------------------------------------
-                                                             *NERDTreeSortOrder*
-Values: a list of regular expressions.
-Default: ['\/$', '*', '\.swp$',  '\.bak$', '\~$']
-
-This setting is a list of regular expressions which are used to group or sort
-the nodes under their parent.
-
-For example, if the setting is: >
-    ['\.vim$', '\.c$', '\.h$', '*', 'foobar']
-<
-then all .vim files will be grouped at the top, followed by all .c files then
-all .h files. All files containing the string 'foobar' will be placed at the
-end.  The star is a special flag: it tells the script that every node that
-doesn't match any of the other regexps should be placed here.
-
-If no star is present in NERDTreeSortOrder, then one is automatically
-appended to the end of the list.
-
-The regex '\/$' should be used to match directory nodes.
-
-Files can also be sorted by 1) the modification timestamp, 2) the size, or 3)
-the extension. Directories are always sorted by name. To accomplish this, the
-following special flags are used:
-  [[timestamp]]   [[-timestamp]]   [[size]]   [[-size]]   [[extension]]
-The hyphen specifies a descending sort; extensions are sorted in ascending
-order only. If placed at the beginning of the list, files are sorted according
-to these flags first, and then grouped by the remaining items in the list. If
-the flags are in any other position of the list, this special sorting is done
-secondarily. See examples 4, 5, and 6 below.
-
-After this sorting is done, the files in each group are sorted alphabetically.
-
-Examples: >
-    (1) ['*', '\/$']
-    (2) []
-    (3) ['\/$', '\.rb$', '\.php$', '*', '\.swp$',  '\.bak$', '\~$']
-    (4) ['[[-size]]']
-    (5) ['\/$', '*', '[[timestamp]]']
-    (6) ['foo','\/$','[[extension]]']
-<
-1. Directories will appear last, everything else will appear above.
-2. Everything will simply appear in alphabetical order.
-3. Dirs will appear first, then ruby and php. Swap files, bak files and vim
-   backup files will appear last with everything else preceding them.
-4. Everything is sorted by size, largest to smallest, with directories
-   considered to have size 0 bytes.
-5. Directories will appear first alphabetically, followed by files, sorted by
-   timestamp, oldest first.
-6. Files and directories matching 'foo' first, followed by other directories,
-   then all other files. Each section of files is sorted by file extension.
-
-------------------------------------------------------------------------------
-                                                            *NERDTreeStatusline*
-Values: Any valid `'statusline'` setting.
-Default: %{exists('b:NERDTree')?b:NERDTree.root.path.str():''}
-
-Defines the value for the `'statusline'` setting in NERDTree windows.
-
-Note: The setting is actually applied using |:let-&|, not |:set|, so
-escaping spaces is not necessary.
-
-Setting this to -1 will deactivate it so that your global `'statusline'`
-setting is used.
-
-------------------------------------------------------------------------------
-                                                                *NERDTreeWinPos*
-Values: "left" or "right"
-Default: "left".
-
-This setting is used to determine where NERDTree window is placed on the
-screen.
-
-This setting makes it possible to use two different explorer plugins
-simultaneously. For example, you could have the taglist plugin on the left of
-the window and the NERDTree on the right.
-
-------------------------------------------------------------------------------
-                                                               *NERDTreeWinSize*
-Values: a positive integer.
-Default: 31.
-
-This setting is used to change the size of the NERDTree when it is loaded.
-
-------------------------------------------------------------------------------
-                                                             *NERDTreeMinimalUI*
-Values: 0 or 1
-Default: 0
-
-This setting disables the 'Bookmarks' label 'Press ? for help' text. Use one
-of the following lines for this setting: >
-    let NERDTreeMinimalUI=0
-    let NERDTreeMinimalUI=1
-<
-------------------------------------------------------------------------------
-                                                           *NERDTreeMinimalMenu*
-Values: 0 or 1
-Default: 0
-
-This setting makes NERDTree use a smaller, more compact menu for adding,
-copying, deleting nodes. This menu fits on a single line so Vim doesn't need to
-scroll down to present it. This setting is recommended for users already
-familiar with the menu items. It will look similar to this:
-
-  Menu: [ (a)dd ,m,d,r,o,q,c,l] (Use j/k/enter or shortcut):
-
-An action can be selected with its shortcut key or with the NERDTreeMenuUp and
-NERDTreeMenuDown keys, then pressing enter.
-
-Use one of the following lines for this setting: >
-    let NERDTreeMinimalMenu=0
-    let NERDTreeMinimalMenu=1
-<
-------------------------------------------------------------------------------
-                                                 *NERDTreeCascadeSingleChildDir*
-Values: 0 or 1
-Default: 1.
-
-When displaying dir nodes, this setting tells NERDTree to collapse dirs that
-have only one child. Use one of the following lines for this setting: >
-    let NERDTreeCascadeSingleChildDir=0
-    let NERDTreeCascadeSingleChildDir=1
-<
-------------------------------------------------------------------------------
-                                             *NERDTreeCascadeOpenSingleChildDir*
-Values: 0 or 1
-Default: 1.
-
-When opening dir nodes, this setting tells NERDTree to recursively open dirs
-that have only one child which is also a dir. NERDTree will stop when it finds
-a dir that contains anything but another single dir. This setting also causes
-the |NERDTree-x| mapping to close dirs in the same manner. This setting may be
-useful for Java projects. Use one of the following lines for this setting: >
-    let NERDTreeCascadeOpenSingleChildDir=0
-    let NERDTreeCascadeOpenSingleChildDir=1
-<
-------------------------------------------------------------------------------
-                                                      *NERDTreeAutoDeleteBuffer*
-Values: 0 or 1
-Default: 0.
-
-When using a context menu to delete or rename a file you may also want to
-delete the buffer which is no more valid. If the setting is not set you will
-see a confirmation if you really want to delete an old buffer. If you always
-press 'y' then it's worth it to set this setting to 1. Use one of the
-following lines for this setting: >
-    let NERDTreeAutoDeleteBuffer=0
-    let NERDTreeAutoDeleteBuffer=1
-<
-------------------------------------------------------------------------------
-                                                          *NERDTreeCreatePrefix*
-Values: Any valid command prefix.
-Default: "silent".
-
-Internally, NERDTree uses the |:edit| command to create a buffer in which to
-display its tree view. You can augment this behavior by specifying a prefix
-string such as "keepalt" or similar. For example, to have NERDTree create its
-tree window using `silent keepalt keepjumps edit`: >
-    let NERDTreeCreatePrefix='silent keepalt keepjumps'
-<
-------------------------------------------------------------------------------
-                        *NERDTreeDirArrowCollapsible* *NERDTreeDirArrowExpandable*
-Values: Any single character.
-Defaults:   Windows: ~ and +    Others:  and 
-
-These characters indicate whether a directory is collapsible or expandable.
-Example: >
-    let NERDTreeDirArrowExpandable=">"
-    let NERDTreeDirArrowCollapsible="v"
-<
-They can be set to "\u00a0" to replace the arrows with a non-breaking space.
-If you do this you may need to change the node delimiter. See
-|NERDTreeNodeDelimiter|. You cannot use the same character for both the arrows
-and the delimiter.
-
-Alternatively, they can be set to '' (an empty string). This removes the
-arrows and the single space that follows them, shifting the entire tree two
-character positions to the left.
-
-------------------------------------------------------------------------------
-                                                         *NERDTreeNodeDelimiter*
-Values: Any single character.
-Default: varies (see below)
-
-This character is used to separate the file or directory name from the rest of
-the characters in the line of text. It allows filenames to contain special
-characters that are otherwise used in the NERDTree, such as square brackets,
-braces, trailing asterisk, and leading space. For more details, see the
-responsible pull request: https://github.com/preservim/nerdtree/pull/868.
-
-The default value of this variable depends on the features compiled into your
-vim and the values of |NERDTreeDirArrowCollapsible| and
-|NERDTreeDirArrowExpandable|.
-  * If your vim is compiled with the +conceal feature, it is the "\x07" (BELL)
-    character, and it is hidden by setting 'conceallevel' to 3. If you use
-    autocommands, make sure none of them change that setting in the NERDTree_*
-    buffers.
-  * If your vim does NOT have the +conceal feature and you're using "\u00a0"
-    (non-breaking space) to hide the directory arrows, "\u00b7" (middle dot)
-    is used as the default delimiter.
-  * If neither condition above applies, NERDTree uses "\u00a0" (non-breaking
-    space) as the default delimiter.
-
-In the 2nd and 3rd cases, NERDTree will use the Ignore highlight group to
-"hide" the delimiter. It should appear as an empty space.
-
-Other plugins can interfere with these defaults, so if you need to change the
-delimiter, be sure to choose a character that won't appear in your filenames
-or any of the flags set by your installed NERDTree plugins. The suggestions
-below are but a few of the many possibilities. Remember to use double quotes
-when specifying by hex or Unicode. >
-    let NERDTreeNodeDelimiter="\x07"     "bell
-    let NERDTreeNodeDelimiter="\u00b7"   "middle dot
-    let NERDTreeNodeDelimiter="\u00a0"   "non-breaking space
-    let NERDTreeNodeDelimiter=""       "smiley face
-<
-------------------------------------------------------------------------------
-                                                        *NERDTreeCustomOpenArgs*
-Values: A nested dictionary, as described below
-Default: {'file': {'reuse': 'all', 'where': 'p'}, 'dir': {}}
-
-This dictionary contains two keys, 'file' and 'dir', whose values each are
-another dictionary. The inner dictionary is a set of parameters used by
-|NERDTree-<CR>| to open a file or directory. Setting these parameters allows you
-to customize the way the node is opened. The default value matches what
-|NERDTree-o| does. To change that behavior, use these keys and
-values in the inner dictionaries:
-
-'where':    specifies whether the node should be opened in a new split ("h" or
-            "v"), in a new tab ("t") or, in the last window ("p").
-'reuse':    if file is already shown in a window, jump there; takes values
-            "all", "currenttab", or empty
-'keepopen': boolean (0 or 1); if true, the tree window will not be closed
-'stay':     boolean (0 or 1); if true, remain in tree window after opening
-
-For example:
-To open files and directories (creating a new NERDTree) in a new tab, >
-    {'file':{'where': 't'}, 'dir':{'where':'t'}}
-<
-To open a file always in the current tab, and expand directories in place, >
-    {'file': {'reuse':'currenttab', 'where':'p', 'keepopen':1, 'stay':1}}
-<
-==============================================================================
-4. The NERDTree API                                                *NERDTreeAPI*
-
-The NERDTree script allows you to add custom key mappings and menu items via
-a set of API calls. Any scripts that use this API should be placed in
-~/.vim/nerdtree_plugin/ (*nix) or ~/vimfiles/nerdtree_plugin (windows).
-
-The script exposes some prototype objects that can be used to manipulate the
-tree and/or get information from it: >
-    g:NERDTreePath
-    g:NERDTreeDirNode
-    g:NERDTreeFileNode
-    g:NERDTreeBookmark
-<
-See the code/comments in NERD_tree.vim to find how to use these objects. The
-following code conventions are used:
-    * class members start with a capital letter
-    * instance members start with a lower case letter
-    * private members start with an underscore
-
-See this blog post for more details:
- http://got-ravings.blogspot.com/2008/09/vim-pr0n-prototype-based-objects.html
-
-A number of API functions take a callback argument to call. The callback can
-be either a string with the name of a function to call, or a |Funcref| object
-which will be called directly.
-
-------------------------------------------------------------------------------
-4.1. Key map API                                             *NERDTreeKeymapAPI*
-
-NERDTreeAddKeyMap({options})                               *NERDTreeAddKeyMap()*
-    Adds a new keymapping for all NERDTree buffers.
-    {options} must be a dictionary, and must contain the following keys:
-    "key" - the trigger key for the new mapping
-    "callback" - the function the new mapping will be bound to
-    "quickhelpText" - the text that will appear in the quickhelp (see
-    |NERDTree-?|)
-    "override" - if 1 then this new mapping will override whatever previous
-    mapping was defined for the key/scope combo. Useful for overriding the
-    default mappings.
-
-    Additionally, a "scope" argument may be supplied. This constrains the
-    mapping so that it is only activated if the cursor is on a certain object.
-    That object is then passed into the handling method. Possible values are:
-
-      "FileNode" .... a file node
-      "DirNode" ..... a directory node
-      "Node" ........ a file node OR a directory node
-      "Bookmark" .... a bookmark
-      "all" ......... global scope; handler receives no arguments (default)
-
-    Example: >
-        call NERDTreeAddKeyMap({
-               \ 'key': 'foo',
-               \ 'callback': 'NERDTreeEchoPathHandler',
-               \ 'quickhelpText': 'echo full path of current node',
-               \ 'scope': 'DirNode' })
-
-        function! NERDTreeEchoPathHandler(dirnode)
-            echo a:dirnode.path.str()
-        endfunction
-<
-    This code should sit in a file like ~/.vim/nerdtree_plugin/mymapping.vim.
-    It adds a (redundant) mapping on 'foo' which changes vim's CWD to that of
-    the current dir node. Note this mapping will only fire when the cursor is
-    on a directory node.
-
-------------------------------------------------------------------------------
-4.2. Menu API                                                  *NERDTreeMenuAPI*
-
-NERDTreeAddSubmenu({options})                             *NERDTreeAddSubmenu()*
-    Creates and returns a new submenu.
-
-    {options} must be a dictionary and must contain the following keys:
-    "text" - the text of the submenu that the user will see
-    "shortcut" - a shortcut key for the submenu (need not be unique)
-
-    The following keys are optional:
-    "isActiveCallback" - a function that will be called to determine whether
-    this submenu item will be displayed or not. The callback function must
-    return 0 or 1.
-    "parent" - the parent submenu of the new submenu (returned from a previous
-    invocation of NERDTreeAddSubmenu()). If this key is left out then the new
-    submenu will sit under the top level menu.
-
-    See below for an example.
-
-NERDTreeAddMenuItem({options})                           *NERDTreeAddMenuItem()*
-    Adds a new menu item to the NERDTree menu (see |NERDTreeMenu|).
-
-    {options} must be a dictionary and must contain the
-    following keys:
-    "text" - the text of the menu item which the user will see
-    "shortcut" - a shortcut key for the menu item (need not be unique)
-    "callback" - the function that will be called when the user activates the
-    menu item.
-
-    The following keys are optional:
-    "isActiveCallback" - a function that will be called to determine whether
-    this menu item will be displayed or not. The callback function must return
-    0 or 1.
-    "parent" - if the menu item belongs under a submenu then this key must be
-    specified. This value for this key will be the object that
-    was returned when the submenu was created with |NERDTreeAddSubmenu()|.
-
-    See below for an example.
-
-NERDTreeAddMenuSeparator([{options}])               *NERDTreeAddMenuSeparator()*
-    Adds a menu separator (a row of dashes).
-
-    {options} is an optional dictionary that may contain the following keys:
-    "isActiveCallback" - see description in |NERDTreeAddMenuItem()|.
-
-Below is an example of the menu API in action. >
-    call NERDTreeAddMenuSeparator()
-
-    call NERDTreeAddMenuItem({
-                \ 'text': 'a (t)op level menu item',
-                \ 'shortcut': 't',
-                \ 'callback': 'SomeFunction' })
-
-    let submenu = NERDTreeAddSubmenu({
-                \ 'text': 'a (s)ub menu',
-                \ 'shortcut': 's' })
-
-    call NERDTreeAddMenuItem({
-                \ 'text': '(n)ested item 1',
-                \ 'shortcut': 'n',
-                \ 'callback': 'SomeFunction',
-                \ 'parent': submenu })
-
-    call NERDTreeAddMenuItem({
-                \ 'text': '(n)ested item 2',
-                \ 'shortcut': 'n',
-                \ 'callback': 'SomeFunction',
-                \ 'parent': submenu })
-<
-This will create the following menu: >
-  --------------------
-  a (t)op level menu item
-  a (s)ub menu
-<
-Where selecting "a (s)ub menu" will lead to a second menu: >
-  (n)ested item 1
-  (n)ested item 2
-<
-When any of the 3 concrete menu items are selected the function "SomeFunction"
-will be called.
-
-------------------------------------------------------------------------------
-4.3 NERDTreeAddPathFilter(callback)                    *NERDTreeAddPathFilter()*
-
-Path filters are essentially a more powerful version of  |NERDTreeIgnore|.
-If the simple regex matching in |NERDTreeIgnore| is not enough then use
-|NERDTreeAddPathFilter()| to add a callback function that paths will be
-checked against when the decision to ignore them is made. Example >
-
-    call NERDTreeAddPathFilter('MyFilter')
-
-    function! MyFilter(params)
-        "params is a dict containing keys: 'nerdtree' and 'path' which are
-        "g:NERDTree and g:NERDTreePath objects
-
-        "return 1 to ignore params['path'] or 0 otherwise
-    endfunction
-<
-------------------------------------------------------------------------------
-4.4 Path Listener API                                  *NERDTreePathListenerAPI*
-
-Use this API if you want to run a callback for events on Path objects. E.G >
-
-    call g:NERDTreePathNotifier.AddListener("init", "MyListener")
-
-    "....
-
-    function! MyListener(event)
-        "This function will be called whenever a Path object is created.
-
-        "a:event is an object that contains a bunch of relevant info -
-        "including the affected path. See lib/nerdtree/event.vim for details.
-    endfunction
-<
-Current events supported:
-  init ~
-  refresh ~
-  refreshFlags ~
-
-------------------------------------------------------------------------------
-NERDTreeRender()                                              *NERDTreeRender()*
-    Re-renders the NERDTree buffer. Useful if you change the state of the
-    tree and you want to it to be reflected in the UI.
-
-==============================================================================
-5. About                                                         *NERDTreeAbout*
-
-The author of the NERDTree is a terrible terrible monster called Martyzilla
-who gobbles up small children with milk and sugar for breakfast.
-
-He can be reached at martin.grenfell at gmail dot com. He would love to hear
-from you, so feel free to send him suggestions and/or comments about this
-plugin.  Don't be shy --- the worst he can do is slaughter you and stuff you
-in the fridge for later ;)
-
-Martyzilla recruited two other unwitting accomplices to become his minions in
-his quest to conquer the Vim plugin world. While he may still love to receive
-your emails, the best way to send suggestions, bug reports, and questions is
-to submit an issue at http://github.com/preservim/nerdtree/issues.
-
-The latest stable and development versions are on Github.
-    Stable: http://github.com/preservim/nerdtree (master branch)
-    Development: http://github.com/preservim/nerdtree/branches
-
-Title Credit:
-  * http://ascii.co.uk/art/tree
-
-  * Patrick Gillespie's Text ASCII Art Generator
-    http://patorjk.com/software/taag
-    http://patorjk.com/software/taag/#p=display&f=Rozzo&t=the%20NERD%20Tree
-
-==============================================================================
-6. License                                                     *NERDTreeLicense*
-
-The NERDTree is released under the wtfpl.
-See http://sam.zoy.org/wtfpl/COPYING.
-
-------------------------------------------------------------------------------
- vim:tw=78:ts=8:ft=help:noet:nospell
diff --git a/sources_non_forked/nerdtree/lib/nerdtree/bookmark.vim b/sources_non_forked/nerdtree/lib/nerdtree/bookmark.vim
deleted file mode 100644
index 248bb07..0000000
--- a/sources_non_forked/nerdtree/lib/nerdtree/bookmark.vim
+++ /dev/null
@@ -1,365 +0,0 @@
-" ============================================================================
-" CLASS: Bookmark
-"
-" The Bookmark class serves two purposes:
-"   (1) It is the top-level prototype for new, concrete Bookmark objects.
-"   (2) It provides an interface for client code to query and manipulate the
-"       global list of Bookmark objects within the current Vim session.
-" ============================================================================
-
-
-let s:Bookmark = {}
-let g:NERDTreeBookmark = s:Bookmark
-
-" FUNCTION: Bookmark.activate(nerdtree) {{{1
-function! s:Bookmark.activate(nerdtree, ...)
-    call self.open(a:nerdtree, a:0 ? a:1 : {})
-endfunction
-
-" FUNCTION: Bookmark.AddBookmark(name, path) {{{1
-" Class method to add a new bookmark to the list, if a previous bookmark exists
-" with the same name, just update the path for that bookmark
-function! s:Bookmark.AddBookmark(name, path)
-    for i in s:Bookmark.Bookmarks()
-        if i.name ==# a:name
-            let i.path = a:path
-            return
-        endif
-    endfor
-    call add(s:Bookmark.Bookmarks(), s:Bookmark.New(a:name, a:path))
-endfunction
-
-" FUNCTION: Bookmark.Bookmarks() {{{1
-" Class method to get all bookmarks. Lazily initializes the bookmarks global
-" variable
-function! s:Bookmark.Bookmarks()
-    if !exists('g:NERDTreeBookmarks')
-        let g:NERDTreeBookmarks = []
-    endif
-    return g:NERDTreeBookmarks
-endfunction
-
-" FUNCTION: Bookmark.BookmarkExistsFor(name) {{{1
-" class method that returns 1 if a bookmark with the given name is found, 0
-" otherwise
-function! s:Bookmark.BookmarkExistsFor(name)
-    try
-        call s:Bookmark.BookmarkFor(a:name)
-        return 1
-    catch /^NERDTree.BookmarkNotFoundError/
-        return 0
-    endtry
-endfunction
-
-" FUNCTION: Bookmark.BookmarkFor(name) {{{1
-" Class method that returns the Bookmark object having the specified name.
-" Throws NERDTree.BookmarkNotFoundError if no Bookmark is found.
-function! s:Bookmark.BookmarkFor(name)
-    let l:result = {}
-    for l:bookmark in s:Bookmark.Bookmarks()
-        if l:bookmark.name ==# a:name
-            let l:result = l:bookmark
-            break
-        endif
-    endfor
-    if empty(l:result)
-        throw 'NERDTree.BookmarkNotFoundError: "' . a:name  . '" not found'
-    endif
-    return l:result
-endfunction
-
-" FUNCTION: Bookmark.BookmarkNames() {{{1
-" Class method to return an array of all bookmark names
-function! s:Bookmark.BookmarkNames()
-    let names = []
-    for i in s:Bookmark.Bookmarks()
-        call add(names, i.name)
-    endfor
-    return names
-endfunction
-
-" FUNCTION: Bookmark.CacheBookmarks(silent) {{{1
-" Class method to read all bookmarks from the bookmarks file initialize
-" bookmark objects for each one.
-"
-" Args:
-" silent - dont echo an error msg if invalid bookmarks are found
-function! s:Bookmark.CacheBookmarks(silent)
-    if filereadable(g:NERDTreeBookmarksFile)
-        let g:NERDTreeBookmarks = []
-        let g:NERDTreeInvalidBookmarks = []
-        let bookmarkStrings = readfile(g:NERDTreeBookmarksFile)
-        let invalidBookmarksFound = 0
-        for i in bookmarkStrings
-
-            "ignore blank lines
-            if i !=# ''
-
-                let name = substitute(i, '^\(.\{-}\) .*$', '\1', '')
-                let path = substitute(i, '^.\{-} \(.*\)$', '\1', '')
-                let path = fnamemodify(path, ':p')
-
-                try
-                    let bookmark = s:Bookmark.New(name, g:NERDTreePath.New(path))
-                    call add(g:NERDTreeBookmarks, bookmark)
-                catch /^NERDTree.InvalidArgumentsError/
-                    call add(g:NERDTreeInvalidBookmarks, i)
-                    let invalidBookmarksFound += 1
-                endtry
-            endif
-        endfor
-        if invalidBookmarksFound
-            call s:Bookmark.Write()
-            if !a:silent
-                call nerdtree#echo(invalidBookmarksFound . ' invalid bookmarks were read. See :help NERDTreeInvalidBookmarks for info.')
-            endif
-        endif
-    endif
-endfunction
-
-" FUNCTION: Bookmark.CompareBookmarksByName(firstBookmark, secondBookmark) {{{1
-" Class method that indicates the relative position of two bookmarks when
-" placed in alphabetical order by name. Case-sensitivity is determined by an
-" option. Supports the s:Bookmark.SortBookmarksList() method.
-function! s:Bookmark.CompareBookmarksByName(firstBookmark, secondBookmark)
-    let l:result = 0
-    if g:NERDTreeBookmarksSort ==# 1
-        if a:firstBookmark.name <? a:secondBookmark.name
-            let l:result = -1
-        elseif a:firstBookmark.name >? a:secondBookmark.name
-            let l:result = 1
-        endif
-    elseif g:NERDTreeBookmarksSort ==# 2
-        if a:firstBookmark.name <# a:secondBookmark.name
-            let l:result = -1
-        elseif a:firstBookmark.name ># a:secondBookmark.name
-            let l:result = 1
-        endif
-    endif
-    return l:result
-endfunction
-
-" FUNCTION: Bookmark.ClearAll() {{{1
-" Class method to delete all bookmarks.
-function! s:Bookmark.ClearAll()
-    for i in s:Bookmark.Bookmarks()
-        call i.delete()
-    endfor
-    call s:Bookmark.Write()
-endfunction
-
-" FUNCTION: Bookmark.delete() {{{1
-" Delete this bookmark. If the node for this bookmark is under the current
-" root, then recache bookmarks for its Path object
-function! s:Bookmark.delete()
-    call remove(s:Bookmark.Bookmarks(), index(s:Bookmark.Bookmarks(), self))
-    call s:Bookmark.Write()
-endfunction
-
-" FUNCTION: s:Edit() {{{1
-" opens the NERDTreeBookmarks file for manual editing
-function! s:Bookmark.Edit()
-    call nerdtree#exec('wincmd w', 1)
-    call nerdtree#exec('edit '.g:NERDTreeBookmarksFile, 1)
-endfunction
-
-" FUNCTION: Bookmark.getNode(nerdtree, searchFromAbsoluteRoot) {{{1
-" Returns the tree node object associated with this Bookmark.
-" Throws NERDTree.BookmarkedNodeNotFoundError if the node is not found.
-"
-" Args:
-" searchFromAbsoluteRoot: boolean flag, search from the highest cached node
-"   if true and from the current tree root if false
-function! s:Bookmark.getNode(nerdtree, searchFromAbsoluteRoot)
-    if a:searchFromAbsoluteRoot
-        let l:searchRoot = a:nerdtree.root.AbsoluteTreeRoot()
-    else
-        let l:searchRoot = a:nerdtree.root
-    endif
-    let l:targetNode = l:searchRoot.findNode(self.path)
-    if empty(l:targetNode)
-        throw 'NERDTree.BookmarkedNodeNotFoundError: node for bookmark "' . self.name . '" not found'
-    endif
-    return l:targetNode
-endfunction
-
-" FUNCTION: Bookmark.GetNodeForName(name, searchFromAbsoluteRoot, nerdtree) {{{1
-" Class method that returns the tree node object for the Bookmark with the
-" given name. Throws NERDTree.BookmarkNotFoundError if a Bookmark with the
-" name does not exist. Throws NERDTree.BookmarkedNodeNotFoundError if a
-" tree node for the named Bookmark could not be found.
-function! s:Bookmark.GetNodeForName(name, searchFromAbsoluteRoot, nerdtree)
-    let l:bookmark = s:Bookmark.BookmarkFor(a:name)
-    return l:bookmark.getNode(a:nerdtree, a:searchFromAbsoluteRoot)
-endfunction
-
-" FUNCTION: Bookmark.GetSelected() {{{1
-" returns the Bookmark the cursor is over, or {}
-function! s:Bookmark.GetSelected()
-    let line = getline('.')
-    let name = substitute(line, '^>\(.\{-}\) .\+$', '\1', '')
-    if name !=# line
-        try
-            return s:Bookmark.BookmarkFor(name)
-        catch /^NERDTree.BookmarkNotFoundError/
-            return {}
-        endtry
-    endif
-    return {}
-endfunction
-
-" FUNCTION: Bookmark.InvalidBookmarks() {{{1
-" Class method to get all invalid bookmark strings read from the bookmarks
-" file
-function! s:Bookmark.InvalidBookmarks()
-    if !exists('g:NERDTreeInvalidBookmarks')
-        let g:NERDTreeInvalidBookmarks = []
-    endif
-    return g:NERDTreeInvalidBookmarks
-endfunction
-
-" FUNCTION: Bookmark.mustExist() {{{1
-function! s:Bookmark.mustExist()
-    if !self.path.exists()
-        call s:Bookmark.CacheBookmarks(1)
-        throw 'NERDTree.BookmarkPointsToInvalidLocationError: the bookmark "'.
-            \ self.name .'" points to a non existing location: "'. self.path.str()
-    endif
-endfunction
-
-" FUNCTION: Bookmark.New(name, path) {{{1
-" Create a new bookmark object with the given name and path object
-function! s:Bookmark.New(name, path)
-    if a:name =~# ' '
-        throw 'NERDTree.IllegalBookmarkNameError: illegal name:' . a:name
-    endif
-
-    let newBookmark = copy(self)
-    let newBookmark.name = a:name
-    let newBookmark.path = a:path
-    return newBookmark
-endfunction
-
-" FUNCTION: Bookmark.open(nerdtree, [options]) {{{1
-"Args:
-"
-"nerdtree: the tree to load open the bookmark in
-"
-"A dictionary containing the following keys (all optional):
-"  'where': Specifies whether the node should be opened in new split/tab or in
-"           the previous window. Can be either 'v' (vertical split), 'h'
-"           (horizontal split), 't' (new tab) or 'p' (previous window).
-"  'reuse': if a window is displaying the file then jump the cursor there
-"  'keepopen': dont close the tree window
-"  'stay': open the file, but keep the cursor in the tree win
-"
-function! s:Bookmark.open(nerdtree, ...)
-    let opts = a:0 ? a:1 : {}
-
-    if nerdtree#and(g:NERDTreeQuitOnOpen,2)
-        call a:nerdtree.ui.toggleShowBookmarks()
-    endif
-
-    if self.path.isDirectory && !has_key(opts, 'where')
-        call self.toRoot(a:nerdtree)
-    else
-        let opener = g:NERDTreeOpener.New(self.path, opts)
-        call opener.open(self)
-    endif
-endfunction
-
-" FUNCTION: Bookmark.openInNewTab(options) {{{1
-" Create a new bookmark object with the given name and path object
-function! s:Bookmark.openInNewTab(options)
-    call nerdtree#deprecated('Bookmark.openInNewTab', 'is deprecated, use open() instead')
-    call self.open(a:options)
-endfunction
-
-" FUNCTION: Bookmark.setPath(path) {{{1
-" makes this bookmark point to the given path
-function! s:Bookmark.setPath(path)
-    let self.path = a:path
-endfunction
-
-" FUNCTION: Bookmark.SortBookmarksList() {{{1
-" Class method that sorts the global list of bookmarks alphabetically by name.
-" Note that case-sensitivity is determined by a user option.
-function! s:Bookmark.SortBookmarksList()
-    call sort(s:Bookmark.Bookmarks(), s:Bookmark.CompareBookmarksByName, s:Bookmark)
-endfunction
-
-" FUNCTION: Bookmark.str() {{{1
-" Get the string that should be rendered in the view for this bookmark
-function! s:Bookmark.str()
-    let pathStrMaxLen = winwidth(g:NERDTree.GetWinNum()) - 4 - strdisplaywidth(self.name)
-    if &number
-        let pathStrMaxLen = pathStrMaxLen - &numberwidth
-    endif
-
-    let pathStr = self.path.str({'format': 'UI'})
-    if strdisplaywidth(pathStr) > pathStrMaxLen
-        while strdisplaywidth(pathStr) > pathStrMaxLen && strchars(pathStr) > 0
-            let pathStr = substitute(pathStr, '^.', '', '')
-        endwhile
-        let pathStr = '<' . pathStr
-    endif
-    return '>' . self.name . ' ' . pathStr
-endfunction
-
-" FUNCTION: Bookmark.toRoot(nerdtree) {{{1
-" Set the root of the given NERDTree to the node for this Bookmark. If a node
-" for this Bookmark does not exist, a new one is initialized.
-function! s:Bookmark.toRoot(nerdtree)
-    if self.validate()
-        try
-            let l:targetNode = self.getNode(a:nerdtree, 1)
-            call l:targetNode.closeChildren()
-        catch /^NERDTree.BookmarkedNodeNotFoundError/
-            let l:targetNode = g:NERDTreeFileNode.New(s:Bookmark.BookmarkFor(self.name).path, a:nerdtree)
-        endtry
-        call a:nerdtree.changeRoot(l:targetNode)
-    endif
-endfunction
-
-" FUNCTION: Bookmark.ToRoot(name, nerdtree) {{{1
-" Class method that makes the Bookmark with the given name the root of
-" specified NERDTree.
-function! s:Bookmark.ToRoot(name, nerdtree)
-    let l:bookmark = s:Bookmark.BookmarkFor(a:name)
-    call l:bookmark.toRoot(a:nerdtree)
-endfunction
-
-" FUNCTION: Bookmark.validate() {{{1
-function! s:Bookmark.validate()
-    if self.path.exists()
-        return 1
-    else
-        call s:Bookmark.CacheBookmarks(1)
-        call nerdtree#echo(self.name . 'now points to an invalid location. See :help NERDTreeInvalidBookmarks for info.')
-        return 0
-    endif
-endfunction
-
-" FUNCTION: Bookmark.Write() {{{1
-" Class method to write all bookmarks to the bookmarks file
-function! s:Bookmark.Write()
-    let bookmarkStrings = []
-    for i in s:Bookmark.Bookmarks()
-        call add(bookmarkStrings, i.name . ' ' . fnamemodify(i.path.str(), ':~'))
-    endfor
-
-    "add a blank line before the invalid ones
-    call add(bookmarkStrings, '')
-
-    for j in s:Bookmark.InvalidBookmarks()
-        call add(bookmarkStrings, j)
-    endfor
-
-    try
-        call writefile(bookmarkStrings, g:NERDTreeBookmarksFile)
-    catch
-        call nerdtree#echoError('Failed to write bookmarks file. Make sure g:NERDTreeBookmarksFile points to a valid location.')
-    endtry
-endfunction
-
-" vim: set sw=4 sts=4 et fdm=marker:
diff --git a/sources_non_forked/nerdtree/lib/nerdtree/creator.vim b/sources_non_forked/nerdtree/lib/nerdtree/creator.vim
deleted file mode 100644
index f845361..0000000
--- a/sources_non_forked/nerdtree/lib/nerdtree/creator.vim
+++ /dev/null
@@ -1,399 +0,0 @@
-" ============================================================================
-" CLASS: Creator
-"
-" This class is responsible for creating NERDTree instances.  The new NERDTree
-" may be a tab tree, a window tree, or a mirrored tree.  In the process of
-" creating a NERDTree, it sets up all of the window and buffer options and key
-" mappings etc.
-" ============================================================================
-
-
-let s:Creator = {}
-let g:NERDTreeCreator = s:Creator
-
-" FUNCTION: s:Creator._bindMappings() {{{1
-function! s:Creator._bindMappings()
-    call g:NERDTreeKeyMap.BindAll()
-
-    command! -buffer -nargs=? Bookmark :call nerdtree#ui_glue#bookmarkNode('<args>')
-    command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=1 RevealBookmark :call nerdtree#ui_glue#revealBookmark('<args>')
-    command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=1 OpenBookmark call nerdtree#ui_glue#openBookmark('<args>')
-    command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=* ClearBookmarks call nerdtree#ui_glue#clearBookmarks('<args>')
-    command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=+ BookmarkToRoot call g:NERDTreeBookmark.ToRoot('<args>', b:NERDTree)
-    command! -buffer -nargs=0 ClearAllBookmarks call g:NERDTreeBookmark.ClearAll() <bar> call b:NERDTree.render()
-    command! -buffer -nargs=0 ReadBookmarks call g:NERDTreeBookmark.CacheBookmarks(0) <bar> call b:NERDTree.render()
-    command! -buffer -nargs=0 WriteBookmarks call g:NERDTreeBookmark.Write()
-    command! -buffer -nargs=0 EditBookmarks call g:NERDTreeBookmark.Edit()
-endfunction
-
-" FUNCTION: s:Creator._broadcastInitEvent() {{{1
-function! s:Creator._broadcastInitEvent()
-    silent doautocmd User NERDTreeInit
-endfunction
-
-" FUNCTION: s:Creator.BufNamePrefix() {{{1
-function! s:Creator.BufNamePrefix()
-    return 'NERD_tree_'
-endfunction
-
-" FUNCTION: s:Creator.CreateTabTree(a:name) {{{1
-function! s:Creator.CreateTabTree(name)
-    let creator = s:Creator.New()
-    call creator.createTabTree(a:name)
-endfunction
-
-" FUNCTION: s:Creator.createTabTree(a:name) {{{1
-" name: the name of a bookmark or a directory
-function! s:Creator.createTabTree(name)
-    let l:path = self._pathForString(a:name)
-
-    " Abort if an exception was thrown (i.e., if the bookmark or directory
-    " does not exist).
-    if empty(l:path)
-        return
-    endif
-
-    " Obey the user's preferences for changing the working directory.
-    if g:NERDTreeChDirMode != 0
-        call l:path.changeToDir()
-    endif
-
-    if g:NERDTree.ExistsForTab()
-        call g:NERDTree.Close()
-        call self._removeTreeBufForTab()
-    endif
-
-    call self._createTreeWin()
-    call self._createNERDTree(l:path, 'tab')
-    call b:NERDTree.render()
-    call b:NERDTree.root.putCursorHere(0, 0)
-
-    call self._broadcastInitEvent()
-endfunction
-
-" FUNCTION: s:Creator.CreateWindowTree(dir) {{{1
-function! s:Creator.CreateWindowTree(dir)
-    let creator = s:Creator.New()
-    call creator.createWindowTree(a:dir)
-endfunction
-
-" FUNCTION: s:Creator.createWindowTree(dir) {{{1
-function! s:Creator.createWindowTree(dir)
-    try
-        let path = g:NERDTreePath.New(a:dir)
-    catch /^NERDTree.InvalidArgumentsError/
-        call nerdtree#echo('Invalid directory name:' . a:dir)
-        return
-    endtry
-
-    "we want the directory buffer to disappear when we do the :edit below
-    setlocal bufhidden=wipe
-
-    let previousBuf = expand('#')
-
-    "we need a unique name for each window tree buffer to ensure they are
-    "all independent
-    exec g:NERDTreeCreatePrefix . ' edit ' . self._nextBufferName()
-
-    call self._createNERDTree(path, 'window')
-    let b:NERDTree._previousBuf = bufnr(previousBuf)
-    call self._setCommonBufOptions()
-
-    call b:NERDTree.render()
-
-    call self._broadcastInitEvent()
-endfunction
-
-" FUNCTION: s:Creator._createNERDTree(path) {{{1
-function! s:Creator._createNERDTree(path, type)
-    let b:NERDTree = g:NERDTree.New(a:path, a:type)
-
-    " TODO: This assignment is kept for compatibility reasons.  Many other
-    " plugins use b:NERDTreeRoot instead of b:NERDTree.root.  Remove this
-    " assignment in the future.
-    let b:NERDTreeRoot = b:NERDTree.root
-
-    call b:NERDTree.root.open()
-endfunction
-
-" FUNCTION: s:Creator.CreateMirror() {{{1
-function! s:Creator.CreateMirror()
-    let creator = s:Creator.New()
-    call creator.createMirror()
-endfunction
-
-" FUNCTION: s:Creator.createMirror() {{{1
-function! s:Creator.createMirror()
-    "get the names off all the nerd tree buffers
-    let treeBufNames = []
-    for i in range(1, tabpagenr('$'))
-        let nextName = self._tabpagevar(i, 'NERDTreeBufName')
-        if nextName != -1 && (!exists('t:NERDTreeBufName') || nextName != t:NERDTreeBufName)
-            call add(treeBufNames, nextName)
-        endif
-    endfor
-    let treeBufNames = self._uniq(treeBufNames)
-
-    "map the option names (that the user will be prompted with) to the nerd
-    "tree buffer names
-    let options = {}
-    let i = 0
-    while i < len(treeBufNames)
-        let bufName = treeBufNames[i]
-        let treeRoot = getbufvar(bufName, 'NERDTree').root
-        let options[i+1 . '. ' . treeRoot.path.str() . '  (buf name: ' . bufName . ')'] = bufName
-        let i = i + 1
-    endwhile
-
-    "work out which tree to mirror, if there is more than 1 then ask the user
-    let bufferName = ''
-    if len(keys(options)) > 1
-        let choices = ['Choose a tree to mirror']
-        let choices = extend(choices, sort(keys(options)))
-        let choice = inputlist(choices)
-        if choice < 1 || choice > len(options) || choice ==# ''
-            return
-        endif
-
-        let bufferName = options[sort(keys(options))[choice-1]]
-    elseif len(keys(options)) ==# 1
-        let bufferName = values(options)[0]
-    else
-        call nerdtree#echo('No trees to mirror')
-        return
-    endif
-
-    if g:NERDTree.ExistsForTab() && g:NERDTree.IsOpen()
-        call g:NERDTree.Close()
-    endif
-
-    let t:NERDTreeBufName = bufferName
-    call self._createTreeWin()
-    exec 'buffer ' .  bufferName
-    if !&hidden
-        call b:NERDTree.render()
-    endif
-endfunction
-
-" FUNCTION: s:Creator._createTreeWin() {{{1
-" Initialize the NERDTree window.  Open the window, size it properly, set all
-" local options, etc.
-function! s:Creator._createTreeWin()
-    let l:splitLocation = g:NERDTreeWinPos ==# 'left' ? 'topleft ' : 'botright '
-    let l:splitSize = g:NERDTreeWinSize
-
-    if !g:NERDTree.ExistsForTab()
-        let t:NERDTreeBufName = self._nextBufferName()
-        silent! execute l:splitLocation . 'vertical ' . l:splitSize . ' new'
-        silent! execute 'edit ' . t:NERDTreeBufName
-        silent! execute 'vertical resize '. l:splitSize
-    else
-        silent! execute l:splitLocation . 'vertical ' . l:splitSize . ' split'
-        silent! execute 'buffer ' . t:NERDTreeBufName
-    endif
-
-    setlocal winfixwidth
-
-    call self._setCommonBufOptions()
-
-    if has('patch-7.4.1925')
-        clearjumps
-    endif
-
-endfunction
-
-" FUNCTION: s:Creator._isBufHidden(nr) {{{1
-function! s:Creator._isBufHidden(nr)
-    redir => bufs
-    silent ls!
-    redir END
-
-    return bufs =~ a:nr . '..h'
-endfunction
-
-" FUNCTION: s:Creator.New() {{{1
-function! s:Creator.New()
-    let newCreator = copy(self)
-    return newCreator
-endfunction
-
-" FUNCTION: s:Creator._nextBufferName() {{{1
-" returns the buffer name for the next nerd tree
-function! s:Creator._nextBufferName()
-    let name = s:Creator.BufNamePrefix() . self._nextBufferNumber()
-    return name
-endfunction
-
-" FUNCTION: s:Creator._nextBufferNumber() {{{1
-" the number to add to the nerd tree buffer name to make the buf name unique
-function! s:Creator._nextBufferNumber()
-    if !exists('s:Creator._NextBufNum')
-        let s:Creator._NextBufNum = 1
-    else
-        let s:Creator._NextBufNum += 1
-    endif
-
-    return s:Creator._NextBufNum
-endfunction
-
-" FUNCTION: s:Creator._pathForString(str) {{{1
-" find a bookmark or adirectory for the given string
-function! s:Creator._pathForString(str)
-    let path = {}
-    if g:NERDTreeBookmark.BookmarkExistsFor(a:str)
-        let path = g:NERDTreeBookmark.BookmarkFor(a:str).path
-    else
-        let dir = a:str ==# '' ? getcwd() : a:str
-
-        "hack to get an absolute path if a relative path is given
-        if dir =~# '^\.'
-            let dir = getcwd() . g:NERDTreePath.Slash() . dir
-        endif
-
-        "hack to prevent removing slash if dir is the root of the file system.
-        if dir !=# '/'
-            let dir = g:NERDTreePath.Resolve(dir)
-        endif
-
-        try
-            let path = g:NERDTreePath.New(dir)
-        catch /^NERDTree.InvalidArgumentsError/
-            call nerdtree#echo('No bookmark or directory found for: ' . a:str)
-            return {}
-        endtry
-    endif
-    if !path.isDirectory
-        let path = path.getParent()
-    endif
-
-    return path
-endfunction
-
-" Function: s:Creator._removeTreeBufForTab()   {{{1
-function! s:Creator._removeTreeBufForTab()
-    let buf = bufnr(t:NERDTreeBufName)
-
-    "if &hidden is not set then it will already be gone
-    if buf != -1
-
-        "nerdtree buf may be mirrored/displayed elsewhere
-        if self._isBufHidden(buf)
-            exec 'bwipeout ' . buf
-        endif
-
-    endif
-
-    unlet t:NERDTreeBufName
-endfunction
-
-" FUNCTION: s:Creator._setCommonBufOptions() {{{1
-function! s:Creator._setCommonBufOptions()
-
-    " Options for a non-file/control buffer.
-    setlocal bufhidden=hide
-    setlocal buftype=nofile
-    setlocal noswapfile
-
-    " Options for controlling buffer/window appearance.
-    setlocal foldcolumn=0
-    setlocal foldmethod=manual
-    setlocal nobuflisted
-    setlocal nofoldenable
-    setlocal nolist
-    setlocal nospell
-    setlocal nowrap
-
-    if g:NERDTreeShowLineNumbers
-        setlocal number
-    else
-        setlocal nonumber
-        if v:version >= 703
-            setlocal norelativenumber
-        endif
-    endif
-
-    iabc <buffer>
-
-    if g:NERDTreeHighlightCursorline
-        setlocal cursorline
-    endif
-
-    call self._setupStatusline()
-    call self._bindMappings()
-
-    setlocal filetype=nerdtree
-endfunction
-
-" FUNCTION: s:Creator._setupStatusline() {{{1
-function! s:Creator._setupStatusline()
-    if g:NERDTreeStatusline != -1
-        let &l:statusline = g:NERDTreeStatusline
-    endif
-endfunction
-
-" FUNCTION: s:Creator._tabpagevar(tabnr, var) {{{1
-function! s:Creator._tabpagevar(tabnr, var)
-    let currentTab = tabpagenr()
-    let old_ei = &eventignore
-    set eventignore=all
-
-    try
-        exec 'tabnext ' . a:tabnr
-        let v = -1
-        if exists('t:' . a:var)
-            exec 'let v = t:' . a:var
-        endif
-        exec 'tabnext ' . currentTab
-
-    finally
-        let &eventignore = old_ei
-    endtry
-
-    return v
-endfunction
-
-" FUNCTION: s:Creator.ToggleTabTree(dir) {{{1
-function! s:Creator.ToggleTabTree(dir)
-    let creator = s:Creator.New()
-    call creator.toggleTabTree(a:dir)
-endfunction
-
-" FUNCTION: s:Creator.toggleTabTree(dir) {{{1
-" Toggles the NERD tree. I.e if the NERD tree is open, it is closed. If it is
-" closed, it is restored or initialized. If dir is not empty, it will be set
-" as the new root.
-"
-" Args:
-" dir: the full path for the root node (is used if the NERD tree is being
-" initialized, or to change the root to a new dir.)
-function! s:Creator.toggleTabTree(dir)
-    if g:NERDTree.ExistsForTab()
-        if !g:NERDTree.IsOpen()
-            call self._createTreeWin()
-            if !empty(a:dir) && a:dir !=# b:NERDTree.root.path.str()
-                call self.createTabTree(a:dir)
-            elseif !&hidden
-                call b:NERDTree.render()
-            endif
-            call b:NERDTree.ui.restoreScreenState()
-        else
-            call g:NERDTree.Close()
-        endif
-    else
-        call self.createTabTree(a:dir)
-    endif
-endfunction
-
-" Function: s:Creator._uniq(list)   {{{1
-" returns a:list without duplicates
-function! s:Creator._uniq(list)
-  let uniqlist = []
-  for elem in a:list
-    if index(uniqlist, elem) ==# -1
-      let uniqlist += [elem]
-    endif
-  endfor
-  return uniqlist
-endfunction
-
-" vim: set sw=4 sts=4 et fdm=marker:
diff --git a/sources_non_forked/nerdtree/lib/nerdtree/event.vim b/sources_non_forked/nerdtree/lib/nerdtree/event.vim
deleted file mode 100644
index 964e8ff..0000000
--- a/sources_non_forked/nerdtree/lib/nerdtree/event.vim
+++ /dev/null
@@ -1,13 +0,0 @@
-"CLASS: Event
-"============================================================
-let s:Event = {}
-let g:NERDTreeEvent = s:Event
-
-function! s:Event.New(nerdtree, subject, action, params) abort
-    let newObj = copy(self)
-    let newObj.nerdtree = a:nerdtree
-    let newObj.subject = a:subject
-    let newObj.action = a:action
-    let newObj.params = a:params
-    return newObj
-endfunction
diff --git a/sources_non_forked/nerdtree/lib/nerdtree/flag_set.vim b/sources_non_forked/nerdtree/lib/nerdtree/flag_set.vim
deleted file mode 100644
index 7552867..0000000
--- a/sources_non_forked/nerdtree/lib/nerdtree/flag_set.vim
+++ /dev/null
@@ -1,58 +0,0 @@
-"CLASS: FlagSet
-"============================================================
-let s:FlagSet = {}
-let g:NERDTreeFlagSet = s:FlagSet
-
-"FUNCTION: FlagSet.addFlag(scope, flag) {{{1
-function! s:FlagSet.addFlag(scope, flag)
-    let flags = self._flagsForScope(a:scope)
-    if index(flags, a:flag) == -1
-        call add(flags, a:flag)
-    end
-endfunction
-
-"FUNCTION: FlagSet.clearFlags(scope) {{{1
-function! s:FlagSet.clearFlags(scope)
-    let self._flags[a:scope] = []
-endfunction
-
-"FUNCTION: FlagSet._flagsForScope(scope) {{{1
-function! s:FlagSet._flagsForScope(scope)
-    if !has_key(self._flags, a:scope)
-        let self._flags[a:scope] = []
-    endif
-    return self._flags[a:scope]
-endfunction
-
-"FUNCTION: FlagSet.New() {{{1
-function! s:FlagSet.New()
-    let newObj = copy(self)
-    let newObj._flags = {}
-    return newObj
-endfunction
-
-"FUNCTION: FlagSet.removeFlag(scope, flag) {{{1
-function! s:FlagSet.removeFlag(scope, flag)
-    let flags = self._flagsForScope(a:scope)
-
-    let i = index(flags, a:flag)
-    if i >= 0
-        call remove(flags, i)
-    endif
-endfunction
-
-"FUNCTION: FlagSet.renderToString() {{{1
-function! s:FlagSet.renderToString()
-    let flagstring = ''
-    for i in values(self._flags)
-        let flagstring .= join(i)
-    endfor
-
-    if len(flagstring) == 0
-        return ''
-    endif
-
-    return '[' . flagstring . ']'
-endfunction
-
-" vim: set sw=4 sts=4 et fdm=marker:
diff --git a/sources_non_forked/nerdtree/lib/nerdtree/key_map.vim b/sources_non_forked/nerdtree/lib/nerdtree/key_map.vim
deleted file mode 100644
index f3268c2..0000000
--- a/sources_non_forked/nerdtree/lib/nerdtree/key_map.vim
+++ /dev/null
@@ -1,164 +0,0 @@
-"CLASS: KeyMap
-"============================================================
-let s:KeyMap = {}
-let g:NERDTreeKeyMap = s:KeyMap
-let s:keyMaps = {}
-
-"FUNCTION: KeyMap.All() {{{1
-function! s:KeyMap.All()
-    let sortedKeyMaps = values(s:keyMaps)
-    call sort(sortedKeyMaps, s:KeyMap.Compare, s:KeyMap)
-
-    return sortedKeyMaps
-endfunction
-
-"FUNCTION: KeyMap.Compare(keyMap1, keyMap2) {{{1
-function! s:KeyMap.Compare(keyMap1, keyMap2)
-
-    if a:keyMap1.key >? a:keyMap2.key
-        return 1
-    endif
-
-    if a:keyMap1.key <? a:keyMap2.key
-        return -1
-    endif
-
-    return 0
-endfunction
-
-"FUNCTION: KeyMap.FindFor(key, scope) {{{1
-function! s:KeyMap.FindFor(key, scope)
-    return get(s:keyMaps, a:key . a:scope, {})
-endfunction
-
-"FUNCTION: KeyMap.BindAll() {{{1
-function! s:KeyMap.BindAll()
-    for i in values(s:keyMaps)
-        call i.bind()
-    endfor
-endfunction
-
-"FUNCTION: KeyMap.bind() {{{1
-function! s:KeyMap.bind()
-    " If the key sequence we're trying to map contains any '<>' notation, we
-    " must replace each of the '<' characters with '<lt>' to ensure the string
-    " is not translated into its corresponding keycode during the later part
-    " of the map command below
-    " :he <>
-    let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
-    if self.key =~# specialNotationRegex
-        let keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
-    else
-        let keymapInvokeString = self.key
-    endif
-    let keymapInvokeString = escape(keymapInvokeString, '\')
-
-    let premap = self.key ==# '<LeftRelease>' ? ' <LeftRelease>' : ' '
-
-    exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
-endfunction
-
-"FUNCTION: KeyMap.Remove(key, scope) {{{1
-function! s:KeyMap.Remove(key, scope)
-    return remove(s:keyMaps, a:key . a:scope)
-endfunction
-
-"FUNCTION: KeyMap.invoke() {{{1
-"Call the KeyMaps callback function
-function! s:KeyMap.invoke(...)
-    let Callback = type(self.callback) ==# type(function('tr')) ? self.callback : function(self.callback)
-    if a:0
-        call Callback(a:1)
-    else
-        call Callback()
-    endif
-endfunction
-
-"FUNCTION: KeyMap.Invoke() {{{1
-"Find a keymapping for a:key and the current scope invoke it.
-"
-"Scope is determined as follows:
-"   * if the cursor is on a dir node then DirNode
-"   * if the cursor is on a file node then FileNode
-"   * if the cursor is on a bookmark then Bookmark
-"
-"If a keymap has the scope of 'all' then it will be called if no other keymap
-"is found for a:key and the scope.
-function! s:KeyMap.Invoke(key)
-
-    "required because clicking the command window below another window still
-    "invokes the <LeftRelease> mapping - but changes the window cursor
-    "is in first
-    "
-    "TODO: remove this check when the vim bug is fixed
-    if !g:NERDTree.ExistsForBuf()
-        return {}
-    endif
-
-    let node = g:NERDTreeFileNode.GetSelected()
-    if !empty(node)
-
-        "try file node
-        if !node.path.isDirectory
-            let km = s:KeyMap.FindFor(a:key, 'FileNode')
-            if !empty(km)
-                return km.invoke(node)
-            endif
-        endif
-
-        "try dir node
-        if node.path.isDirectory
-            let km = s:KeyMap.FindFor(a:key, 'DirNode')
-            if !empty(km)
-                return km.invoke(node)
-            endif
-        endif
-
-        "try generic node
-        let km = s:KeyMap.FindFor(a:key, 'Node')
-        if !empty(km)
-            return km.invoke(node)
-        endif
-
-    endif
-
-    "try bookmark
-    let bm = g:NERDTreeBookmark.GetSelected()
-    if !empty(bm)
-        let km = s:KeyMap.FindFor(a:key, 'Bookmark')
-        if !empty(km)
-            return km.invoke(bm)
-        endif
-    endif
-
-    "try all
-    let km = s:KeyMap.FindFor(a:key, 'all')
-    if !empty(km)
-        return km.invoke()
-    endif
-endfunction
-
-"FUNCTION: KeyMap.Create(options) {{{1
-function! s:KeyMap.Create(options)
-    let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
-
-    "dont override other mappings unless the 'override' option is given
-    if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
-        return
-    end
-
-    let newKeyMap = copy(self)
-    let newKeyMap.key = opts['key']
-    let newKeyMap.quickhelpText = opts['quickhelpText']
-    let newKeyMap.callback = opts['callback']
-    let newKeyMap.scope = opts['scope']
-
-    call s:KeyMap.Add(newKeyMap)
-endfunction
-
-"FUNCTION: KeyMap.Add(keymap) {{{1
-function! s:KeyMap.Add(keymap)
-    let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
-endfunction
-
-" vim: set sw=4 sts=4 et fdm=marker:
diff --git a/sources_non_forked/nerdtree/lib/nerdtree/menu_controller.vim b/sources_non_forked/nerdtree/lib/nerdtree/menu_controller.vim
deleted file mode 100644
index 952c67b..0000000
--- a/sources_non_forked/nerdtree/lib/nerdtree/menu_controller.vim
+++ /dev/null
@@ -1,211 +0,0 @@
-"CLASS: MenuController
-"============================================================
-let s:MenuController = {}
-let g:NERDTreeMenuController = s:MenuController
-
-"FUNCTION: MenuController.New(menuItems) {{{1
-"create a new menu controller that operates on the given menu items
-function! s:MenuController.New(menuItems)
-    let newMenuController =  copy(self)
-    if a:menuItems[0].isSeparator()
-        let newMenuController.menuItems = a:menuItems[1:-1]
-    else
-        let newMenuController.menuItems = a:menuItems
-    endif
-    return newMenuController
-endfunction
-
-" FUNCTION: s:MenuController.isMinimal() {{{1
-function! s:MenuController.isMinimal()
-    return g:NERDTreeMinimalMenu
-endfunction
-
-" FUNCTION: MenuController.showMenu() {{{1
-" Enter the main loop of the NERDTree menu, prompting the user to select
-" a menu item.
-function! s:MenuController.showMenu()
-    call self._saveOptions()
-
-    try
-        let self.selection = 0
-        let l:done = 0
-
-        while !l:done
-            if has('nvim')
-                mode
-            else
-                redraw!
-            endif
-            call self._echoPrompt()
-
-            let l:key = nr2char(getchar())
-            let l:done = self._handleKeypress(l:key)
-        endwhile
-    finally
-        call self._restoreOptions()
-
-        " Redraw when Ctrl-C or Esc is received.
-        if !l:done || self.selection ==# -1
-            redraw!
-        endif
-    endtry
-
-    if self.selection !=# -1
-        let l:m = self._current()
-        call l:m.execute()
-    endif
-endfunction
-
-"FUNCTION: MenuController._echoPrompt() {{{1
-function! s:MenuController._echoPrompt()
-    let navHelp = 'Use ' . g:NERDTreeMenuDown . '/' . g:NERDTreeMenuUp . '/enter'
-
-    if self.isMinimal()
-        let selection = self.menuItems[self.selection].text
-        let keyword = matchstr(selection, '[^ ]*([^ ]*')
-
-        let shortcuts = map(copy(self.menuItems), "v:val['shortcut']")
-        let shortcuts[self.selection] = ' ' . keyword . ' '
-
-        echo 'Menu: [' . join(shortcuts, ',') . '] (' . navHelp . ' or shortcut): '
-    else
-        echo 'NERDTree Menu. ' . navHelp . ', or the shortcuts indicated'
-        echo '========================================================='
-
-        for i in range(0, len(self.menuItems)-1)
-            if self.selection ==# i
-                echo '> ' . self.menuItems[i].text
-            else
-                echo '  ' . self.menuItems[i].text
-            endif
-        endfor
-    endif
-endfunction
-
-"FUNCTION: MenuController._current(key) {{{1
-"get the MenuItem that is currently selected
-function! s:MenuController._current()
-    return self.menuItems[self.selection]
-endfunction
-
-"FUNCTION: MenuController._handleKeypress(key) {{{1
-"change the selection (if appropriate) and return 1 if the user has made
-"their choice, 0 otherwise
-function! s:MenuController._handleKeypress(key)
-    if a:key ==# g:NERDTreeMenuDown
-        call self._cursorDown()
-    elseif a:key ==# g:NERDTreeMenuUp
-        call self._cursorUp()
-    elseif a:key ==# nr2char(27) "escape
-        let self.selection = -1
-        return 1
-    elseif a:key ==# "\r" || a:key ==# "\n" "enter and ctrl-j
-        return 1
-    else
-        let index = self._nextIndexFor(a:key)
-        if index !=# -1
-            let self.selection = index
-            if len(self._allIndexesFor(a:key)) ==# 1
-                return 1
-            endif
-        endif
-    endif
-
-    return 0
-endfunction
-
-"FUNCTION: MenuController._allIndexesFor(shortcut) {{{1
-"get indexes to all menu items with the given shortcut
-function! s:MenuController._allIndexesFor(shortcut)
-    let toReturn = []
-
-    for i in range(0, len(self.menuItems)-1)
-        if self.menuItems[i].shortcut ==# a:shortcut
-            call add(toReturn, i)
-        endif
-    endfor
-
-    return toReturn
-endfunction
-
-"FUNCTION: MenuController._nextIndexFor(shortcut) {{{1
-"get the index to the next menu item with the given shortcut, starts from the
-"current cursor location and wraps around to the top again if need be
-function! s:MenuController._nextIndexFor(shortcut)
-    for i in range(self.selection+1, len(self.menuItems)-1)
-        if self.menuItems[i].shortcut ==# a:shortcut
-            return i
-        endif
-    endfor
-
-    for i in range(0, self.selection)
-        if self.menuItems[i].shortcut ==# a:shortcut
-            return i
-        endif
-    endfor
-
-    return -1
-endfunction
-
-"FUNCTION: MenuController._setCmdheight() {{{1
-"sets &cmdheight to whatever is needed to display the menu
-function! s:MenuController._setCmdheight()
-    if self.isMinimal()
-        let &cmdheight = 1
-    else
-        let &cmdheight = len(self.menuItems) + 3
-    endif
-endfunction
-
-"FUNCTION: MenuController._saveOptions() {{{1
-"set any vim options that are required to make the menu work (saving their old
-"values)
-function! s:MenuController._saveOptions()
-    let self._oldLazyredraw = &lazyredraw
-    let self._oldCmdheight = &cmdheight
-    set nolazyredraw
-    call self._setCmdheight()
-endfunction
-
-"FUNCTION: MenuController._restoreOptions() {{{1
-"restore the options we saved in _saveOptions()
-function! s:MenuController._restoreOptions()
-    let &cmdheight = self._oldCmdheight
-    let &lazyredraw = self._oldLazyredraw
-endfunction
-
-"FUNCTION: MenuController._cursorDown() {{{1
-"move the cursor to the next menu item, skipping separators
-function! s:MenuController._cursorDown()
-    let done = 0
-    while !done
-        if self.selection < len(self.menuItems)-1
-            let self.selection += 1
-        else
-            let self.selection = 0
-        endif
-
-        if !self._current().isSeparator()
-            let done = 1
-        endif
-    endwhile
-endfunction
-
-"FUNCTION: MenuController._cursorUp() {{{1
-"move the cursor to the previous menu item, skipping separators
-function! s:MenuController._cursorUp()
-    let done = 0
-    while !done
-        if self.selection > 0
-            let self.selection -= 1
-        else
-            let self.selection = len(self.menuItems)-1
-        endif
-
-        if !self._current().isSeparator()
-            let done = 1
-        endif
-    endwhile
-endfunction
-
-" vim: set sw=4 sts=4 et fdm=marker:
diff --git a/sources_non_forked/nerdtree/lib/nerdtree/menu_item.vim b/sources_non_forked/nerdtree/lib/nerdtree/menu_item.vim
deleted file mode 100644
index 7f25917..0000000
--- a/sources_non_forked/nerdtree/lib/nerdtree/menu_item.vim
+++ /dev/null
@@ -1,118 +0,0 @@
-"CLASS: MenuItem
-"============================================================
-let s:MenuItem = {}
-let g:NERDTreeMenuItem = s:MenuItem
-
-"FUNCTION: MenuItem.All() {{{1
-"get all top level menu items
-function! s:MenuItem.All()
-    if !exists('s:menuItems')
-        let s:menuItems = []
-    endif
-    return s:menuItems
-endfunction
-
-"FUNCTION: MenuItem.AllEnabled() {{{1
-"get all top level menu items that are currently enabled
-function! s:MenuItem.AllEnabled()
-    let toReturn = []
-    for i in s:MenuItem.All()
-        if i.enabled()
-            call add(toReturn, i)
-        endif
-    endfor
-    return toReturn
-endfunction
-
-"FUNCTION: MenuItem.Create(options) {{{1
-"make a new menu item and add it to the global list
-function! s:MenuItem.Create(options)
-    let newMenuItem = copy(self)
-
-    let newMenuItem.text = a:options['text']
-    let newMenuItem.shortcut = a:options['shortcut']
-    let newMenuItem.children = []
-
-    let newMenuItem.isActiveCallback = -1
-    if has_key(a:options, 'isActiveCallback')
-        let newMenuItem.isActiveCallback = a:options['isActiveCallback']
-    endif
-
-    let newMenuItem.callback = -1
-    if has_key(a:options, 'callback')
-        let newMenuItem.callback = a:options['callback']
-    endif
-
-    if has_key(a:options, 'parent')
-        call add(a:options['parent'].children, newMenuItem)
-    else
-        call add(s:MenuItem.All(), newMenuItem)
-    endif
-
-    return newMenuItem
-endfunction
-
-"FUNCTION: MenuItem.CreateSeparator(options) {{{1
-"make a new separator menu item and add it to the global list
-function! s:MenuItem.CreateSeparator(options)
-    let standard_options = { 'text': '--------------------',
-                \ 'shortcut': -1,
-                \ 'callback': -1 }
-    let options = extend(a:options, standard_options, 'force')
-
-    return s:MenuItem.Create(options)
-endfunction
-
-"FUNCTION: MenuItem.CreateSubmenu(options) {{{1
-"make a new submenu and add it to global list
-function! s:MenuItem.CreateSubmenu(options)
-    let standard_options = { 'callback': -1 }
-    let options = extend(a:options, standard_options, 'force')
-
-    return s:MenuItem.Create(options)
-endfunction
-
-"FUNCTION: MenuItem.enabled() {{{1
-"return 1 if this menu item should be displayed
-"
-"delegates off to the isActiveCallback, and defaults to 1 if no callback was
-"specified
-function! s:MenuItem.enabled()
-    if self.isActiveCallback != -1
-        return type(self.isActiveCallback) == type(function('tr')) ? self.isActiveCallback() : {self.isActiveCallback}()
-    endif
-    return 1
-endfunction
-
-"FUNCTION: MenuItem.execute() {{{1
-"perform the action behind this menu item, if this menuitem has children then
-"display a new menu for them, otherwise deletegate off to the menuitem's
-"callback
-function! s:MenuItem.execute()
-    if len(self.children)
-        let mc = g:NERDTreeMenuController.New(self.children)
-        call mc.showMenu()
-    else
-        if self.callback != -1
-            if type(self.callback) == type(function('tr'))
-                call self.callback()
-            else
-                call {self.callback}()
-            endif
-        endif
-    endif
-endfunction
-
-"FUNCTION: MenuItem.isSeparator() {{{1
-"return 1 if this menuitem is a separator
-function! s:MenuItem.isSeparator()
-    return self.callback == -1 && self.children == []
-endfunction
-
-"FUNCTION: MenuItem.isSubmenu() {{{1
-"return 1 if this menuitem is a submenu
-function! s:MenuItem.isSubmenu()
-    return self.callback == -1 && !empty(self.children)
-endfunction
-
-" vim: set sw=4 sts=4 et fdm=marker:
diff --git a/sources_non_forked/nerdtree/lib/nerdtree/nerdtree.vim b/sources_non_forked/nerdtree/lib/nerdtree/nerdtree.vim
deleted file mode 100644
index 982db16..0000000
--- a/sources_non_forked/nerdtree/lib/nerdtree/nerdtree.vim
+++ /dev/null
@@ -1,215 +0,0 @@
-"CLASS: NERDTree
-"============================================================
-let s:NERDTree = {}
-let g:NERDTree = s:NERDTree
-
-"FUNCTION: s:NERDTree.AddPathFilter() {{{1
-function! s:NERDTree.AddPathFilter(callback)
-    call add(s:NERDTree.PathFilters(), a:callback)
-endfunction
-
-"FUNCTION: s:NERDTree.changeRoot(node) {{{1
-function! s:NERDTree.changeRoot(node)
-    if a:node.path.isDirectory
-        let self.root = a:node
-    else
-        call a:node.cacheParent()
-        let self.root = a:node.parent
-    endif
-
-    call self.root.open()
-
-    "change dir to the dir of the new root if instructed to
-    if g:NERDTreeChDirMode >= 2
-        call self.root.path.changeToDir()
-    endif
-
-    call self.render()
-    call self.root.putCursorHere(0, 0)
-
-    silent doautocmd User NERDTreeNewRoot
-endfunction
-
-"FUNCTION: s:NERDTree.Close() {{{1
-"Closes the tab tree window for this tab
-function! s:NERDTree.Close()
-    if !s:NERDTree.IsOpen()
-        return
-    endif
-
-    if winnr('$') !=# 1
-        " Use the window ID to identify the currently active window or fall
-        " back on the buffer ID if win_getid/win_gotoid are not available, in
-        " which case we'll focus an arbitrary window showing the buffer.
-        let l:useWinId = exists('*win_getid') && exists('*win_gotoid')
-
-        if winnr() ==# s:NERDTree.GetWinNum()
-            call nerdtree#exec('wincmd p', 1)
-            let l:activeBufOrWin = l:useWinId ? win_getid() : bufnr('')
-            call nerdtree#exec('wincmd p', 1)
-        else
-            let l:activeBufOrWin = l:useWinId ? win_getid() : bufnr('')
-        endif
-
-        call nerdtree#exec(s:NERDTree.GetWinNum() . ' wincmd w', 1)
-        call nerdtree#exec('close', 0)
-        if l:useWinId
-            call nerdtree#exec('call win_gotoid(' . l:activeBufOrWin . ')', 0)
-        else
-            call nerdtree#exec(bufwinnr(l:activeBufOrWin) . ' wincmd w', 0)
-        endif
-    else
-        close
-    endif
-endfunction
-
-"FUNCTION: s:NERDTree.CloseIfQuitOnOpen() {{{1
-"Closes the NERD tree window if the close on open option is set
-function! s:NERDTree.CloseIfQuitOnOpen()
-    if nerdtree#and(g:NERDTreeQuitOnOpen,1) && s:NERDTree.IsOpen()
-        call s:NERDTree.Close()
-    endif
-endfunction
-
-"FUNCTION: s:NERDTree.CursorToBookmarkTable(){{{1
-"Places the cursor at the top of the bookmarks table
-function! s:NERDTree.CursorToBookmarkTable()
-    if !b:NERDTree.ui.getShowBookmarks()
-        throw 'NERDTree.IllegalOperationError: cant find bookmark table, bookmarks arent active'
-    endif
-
-    if g:NERDTreeMinimalUI
-        return cursor(1, 2)
-    endif
-
-    let rootNodeLine = b:NERDTree.ui.getRootLineNum()
-
-    let line = 1
-    while getline(line) !~# '^>-\+Bookmarks-\+$'
-        let line = line + 1
-        if line >= rootNodeLine
-            throw 'NERDTree.BookmarkTableNotFoundError: didnt find the bookmarks table'
-        endif
-    endwhile
-    call cursor(line, 2)
-endfunction
-
-"FUNCTION: s:NERDTree.CursorToTreeWin(){{{1
-"Places the cursor in the nerd tree window
-function! s:NERDTree.CursorToTreeWin(...)
-    call g:NERDTree.MustBeOpen()
-    call nerdtree#exec(g:NERDTree.GetWinNum() . 'wincmd w', a:0 >0 ? a:1 : 1)
-endfunction
-
-" Function: s:NERDTree.ExistsForBuffer()   {{{1
-" Returns 1 if a nerd tree root exists in the current buffer
-function! s:NERDTree.ExistsForBuf()
-    return exists('b:NERDTree')
-endfunction
-
-" Function: s:NERDTree.ExistsForTab()   {{{1
-" Returns 1 if a nerd tree root exists in the current tab
-function! s:NERDTree.ExistsForTab()
-    if !exists('t:NERDTreeBufName')
-        return
-    end
-
-    "check b:NERDTree is still there and hasn't been e.g. :bdeleted
-    return !empty(getbufvar(bufnr(t:NERDTreeBufName), 'NERDTree'))
-endfunction
-
-function! s:NERDTree.ForCurrentBuf()
-    if s:NERDTree.ExistsForBuf()
-        return b:NERDTree
-    else
-        return {}
-    endif
-endfunction
-
-"FUNCTION: s:NERDTree.ForCurrentTab() {{{1
-function! s:NERDTree.ForCurrentTab()
-    if !s:NERDTree.ExistsForTab()
-        return
-    endif
-
-    let bufnr = bufnr(t:NERDTreeBufName)
-    return getbufvar(bufnr, 'NERDTree')
-endfunction
-
-"FUNCTION: s:NERDTree.getRoot() {{{1
-function! s:NERDTree.getRoot()
-    return self.root
-endfunction
-
-"FUNCTION: s:NERDTree.GetWinNum() {{{1
-"gets the nerd tree window number for this tab
-function! s:NERDTree.GetWinNum()
-    if exists('t:NERDTreeBufName')
-        return bufwinnr(t:NERDTreeBufName)
-    endif
-
-    " If WindowTree, there is no t:NERDTreeBufName variable. Search all windows.
-    for w in range(1,winnr('$'))
-        if bufname(winbufnr(w)) =~# '^' . g:NERDTreeCreator.BufNamePrefix() . '\d\+$'
-            return w
-        endif
-    endfor
-
-    return -1
-endfunction
-
-"FUNCTION: s:NERDTree.IsOpen() {{{1
-function! s:NERDTree.IsOpen()
-    return s:NERDTree.GetWinNum() !=# -1
-endfunction
-
-"FUNCTION: s:NERDTree.isTabTree() {{{1
-function! s:NERDTree.isTabTree()
-    return self._type ==# 'tab'
-endfunction
-
-"FUNCTION: s:NERDTree.isWinTree() {{{1
-function! s:NERDTree.isWinTree()
-    return self._type ==# 'window'
-endfunction
-
-"FUNCTION: s:NERDTree.MustBeOpen() {{{1
-function! s:NERDTree.MustBeOpen()
-    if !s:NERDTree.IsOpen()
-        throw 'NERDTree.TreeNotOpen'
-    endif
-endfunction
-
-"FUNCTION: s:NERDTree.New() {{{1
-function! s:NERDTree.New(path, type)
-    let newObj = copy(self)
-    let newObj.ui = g:NERDTreeUI.New(newObj)
-    let newObj.root = g:NERDTreeDirNode.New(a:path, newObj)
-    let newObj._type = a:type
-    return newObj
-endfunction
-
-"FUNCTION: s:NERDTree.PathFilters() {{{1
-function! s:NERDTree.PathFilters()
-    if !exists('s:NERDTree._PathFilters')
-        let s:NERDTree._PathFilters = []
-    endif
-    return s:NERDTree._PathFilters
-endfunction
-
-"FUNCTION: s:NERDTree.previousBuf() {{{1
-function! s:NERDTree.previousBuf()
-    return self._previousBuf
-endfunction
-
-function! s:NERDTree.setPreviousBuf(bnum)
-    let self._previousBuf = a:bnum
-endfunction
-
-"FUNCTION: s:NERDTree.render() {{{1
-"A convenience function - since this is called often
-function! s:NERDTree.render()
-    call self.ui.render()
-endfunction
-
-" vim: set sw=4 sts=4 et fdm=marker:
diff --git a/sources_non_forked/nerdtree/lib/nerdtree/notifier.vim b/sources_non_forked/nerdtree/lib/nerdtree/notifier.vim
deleted file mode 100644
index fc3155d..0000000
--- a/sources_non_forked/nerdtree/lib/nerdtree/notifier.vim
+++ /dev/null
@@ -1,35 +0,0 @@
-"CLASS: Notifier
-"============================================================
-let s:Notifier = {}
-
-function! s:Notifier.AddListener(event, funcname)
-    let listeners = s:Notifier.GetListenersForEvent(a:event)
-    if listeners == []
-        let listenersMap = s:Notifier.GetListenersMap()
-        let listenersMap[a:event] = listeners
-    endif
-    call add(listeners, a:funcname)
-endfunction
-
-function! s:Notifier.NotifyListeners(event, path, nerdtree, params)
-    let event = g:NERDTreeEvent.New(a:nerdtree, a:path, a:event, a:params)
-
-    for Listener in s:Notifier.GetListenersForEvent(a:event)
-    	let Callback = type(Listener) == type(function('tr')) ? Listener : function(Listener)
-        call Callback(event)
-    endfor
-endfunction
-
-function! s:Notifier.GetListenersMap()
-    if !exists('s:refreshListenersMap')
-        let s:refreshListenersMap = {}
-    endif
-    return s:refreshListenersMap
-endfunction
-
-function! s:Notifier.GetListenersForEvent(name)
-    let listenersMap = s:Notifier.GetListenersMap()
-    return get(listenersMap, a:name, [])
-endfunction
-
-let g:NERDTreePathNotifier = deepcopy(s:Notifier)
diff --git a/sources_non_forked/nerdtree/lib/nerdtree/opener.vim b/sources_non_forked/nerdtree/lib/nerdtree/opener.vim
deleted file mode 100644
index 6cdd9df..0000000
--- a/sources_non_forked/nerdtree/lib/nerdtree/opener.vim
+++ /dev/null
@@ -1,328 +0,0 @@
-" ============================================================================
-" CLASS: Opener
-"
-" The Opener class defines an API for 'opening' operations.
-" ============================================================================
-
-
-let s:Opener = {}
-let g:NERDTreeOpener = s:Opener
-
-" FUNCTION: s:Opener._bufInWindows(bnum) {{{1
-" [[STOLEN FROM VTREEEXPLORER.VIM]]
-" Determine the number of windows open to this buffer number.
-" Care of Yegappan Lakshman.  Thanks!
-"
-" Args:
-" bnum: the subject buffers buffer number
-function! s:Opener._bufInWindows(bnum)
-    let cnt = 0
-    let winnum = 1
-    while 1
-        let bufnum = winbufnr(winnum)
-        if bufnum < 0
-            break
-        endif
-        if bufnum ==# a:bnum
-            let cnt = cnt + 1
-        endif
-        let winnum = winnum + 1
-    endwhile
-
-    return cnt
-endfunction
-
-" FUNCTION: Opener._checkToCloseTree(newtab) {{{1
-" Check the class options and global options (i.e. NERDTreeQuitOnOpen) to see
-" if the tree should be closed now.
-"
-" Args:
-" a:newtab - boolean. If set, only close the tree now if we are opening the
-" target in a new tab. This is needed because we have to close tree before we
-" leave the tab
-function! s:Opener._checkToCloseTree(newtab)
-    if self._keepopen
-        return
-    endif
-
-    if (a:newtab && self._where ==# 't') || !a:newtab
-        call g:NERDTree.CloseIfQuitOnOpen()
-    endif
-endfunction
-
-" FUNCTION: s:Opener._firstUsableWindow() {{{1
-" find the window number of the first normal window
-function! s:Opener._firstUsableWindow()
-    let i = 1
-    while i <= winnr('$')
-        let bnum = winbufnr(i)
-        if bnum !=# -1 && getbufvar(bnum, '&buftype') ==# ''
-                    \ && !getwinvar(i, '&previewwindow')
-                    \ && (!getbufvar(bnum, '&modified') || &hidden)
-            return i
-        endif
-
-        let i += 1
-    endwhile
-    return -1
-endfunction
-
-" FUNCTION: Opener._gotoTargetWin() {{{1
-function! s:Opener._gotoTargetWin()
-    if b:NERDTree.isWinTree()
-        if self._where ==# 'v'
-            call self._newVSplit()
-        elseif self._where ==# 'h'
-            call self._newSplit()
-        elseif self._where ==# 't'
-            tabnew
-        endif
-    else
-        call self._checkToCloseTree(1)
-
-        if self._where ==# 'v'
-            call self._newVSplit()
-        elseif self._where ==# 'h'
-            call self._newSplit()
-        elseif self._where ==# 't'
-            tabnew
-        elseif self._where ==# 'p'
-            call self._previousWindow()
-        endif
-
-        call self._checkToCloseTree(0)
-    endif
-endfunction
-
-" FUNCTION: s:Opener._isWindowUsable(winnumber) {{{1
-" Returns 0 if opening a file from the tree in the given window requires it to
-" be split, 1 otherwise
-"
-" Args:
-" winnumber: the number of the window in question
-function! s:Opener._isWindowUsable(winnumber)
-    "gotta split if theres only one window (i.e. the NERD tree)
-    if winnr('$') ==# 1
-        return 0
-    endif
-
-    let oldwinnr = winnr()
-    call nerdtree#exec(a:winnumber . 'wincmd p', 1)
-    let specialWindow = getbufvar('%', '&buftype') !=# '' || getwinvar('%', '&previewwindow')
-    let modified = &modified
-    call nerdtree#exec(oldwinnr . 'wincmd p', 1)
-
-    "if its a special window e.g. quickfix or another explorer plugin then we
-    "have to split
-    if specialWindow
-        return 0
-    endif
-
-    if &hidden
-        return 1
-    endif
-
-    return !modified || self._bufInWindows(winbufnr(a:winnumber)) >= 2
-endfunction
-
-" FUNCTION: Opener.New(path, opts) {{{1
-" Instantiate a new NERDTreeOpener object.
-" Args:
-" a:path: the path object that is to be opened
-" a:opts: a dictionary containing the following optional keys...
-"   'where': specifies whether the node should be opened in new split, in
-"            a new tab or, in the last window; takes values 'v', 'h', or 't'
-"   'reuse': if file is already shown in a window, jump there; takes values
-"            'all', 'currenttab', or empty
-"   'keepopen': boolean (0 or 1); if true, the tree window will not be closed
-"   'stay': boolean (0 or 1); if true, remain in tree window after opening
-function! s:Opener.New(path, opts)
-    let l:newOpener = copy(self)
-
-    let l:newOpener._keepopen = nerdtree#has_opt(a:opts, 'keepopen')
-    let l:newOpener._nerdtree = b:NERDTree
-    let l:newOpener._path = a:path
-    let l:newOpener._reuse = has_key(a:opts, 'reuse') ? a:opts['reuse'] : ''
-    let l:newOpener._stay = nerdtree#has_opt(a:opts, 'stay')
-    let l:newOpener._where = has_key(a:opts, 'where') ? a:opts['where'] : ''
-
-    call l:newOpener._saveCursorPos()
-
-    return l:newOpener
-endfunction
-
-" FUNCTION: Opener._newSplit() {{{1
-function! s:Opener._newSplit()
-    let onlyOneWin = (winnr('$') ==# 1)
-    let savesplitright = &splitright
-    if onlyOneWin
-        let &splitright = (g:NERDTreeWinPos ==# 'left')
-    endif
-    " If only one window (ie. NERDTree), split vertically instead.
-    let splitMode = onlyOneWin ? 'vertical' : ''
-
-    " Open the new window
-    try
-        call nerdtree#exec('wincmd p', 1)
-        call nerdtree#exec(splitMode . ' split',1)
-    catch /^Vim\%((\a\+)\)\=:E37/
-        call g:NERDTree.CursorToTreeWin()
-        throw 'NERDTree.FileAlreadyOpenAndModifiedError: '. self._path.str() .' is already open and modified.'
-    catch /^Vim\%((\a\+)\)\=:/
-        "do nothing
-    endtry
-
-    "resize the tree window if no other window was open before
-    if onlyOneWin
-        let size = exists('b:NERDTreeOldWindowSize') ? b:NERDTreeOldWindowSize : g:NERDTreeWinSize
-        call nerdtree#exec('wincmd p', 1)
-        call nerdtree#exec('silent '. splitMode .' resize '. size, 1)
-        call nerdtree#exec('wincmd p', 0)
-    endif
-
-    let &splitright=savesplitright
-endfunction
-
-" FUNCTION: Opener._newVSplit() {{{1
-function! s:Opener._newVSplit()
-    let l:winwidth = winwidth('.')
-
-    let onlyOneWin = (winnr('$') ==# 1)
-    let savesplitright = &splitright
-    if onlyOneWin
-        let &splitright = (g:NERDTreeWinPos ==# 'left')
-        let l:winwidth = g:NERDTreeWinSize
-    endif
-
-    call nerdtree#exec('wincmd p', 1)
-    call nerdtree#exec('vsplit', 1)
-
-    let l:currentWindowNumber = winnr()
-
-    " Restore the NERDTree to its original width.
-    call g:NERDTree.CursorToTreeWin()
-    execute 'silent vertical resize ' . l:winwidth
-
-    call nerdtree#exec(l:currentWindowNumber . 'wincmd w', 0)
-    let &splitright=savesplitright
-endfunction
-
-" FUNCTION: Opener.open(target) {{{1
-function! s:Opener.open(target)
-    if self._path.isDirectory
-        call self._openDirectory(a:target)
-        return
-    endif
-
-    call self._openFile()
-endfunction
-
-" FUNCTION: Opener._openFile() {{{1
-function! s:Opener._openFile()
-    if !self._stay && !nerdtree#and(g:NERDTreeQuitOnOpen,1) && exists('b:NERDTreeZoomed') && b:NERDTreeZoomed
-        call b:NERDTree.ui.toggleZoom()
-    endif
-
-    if self._reuseWindow()
-        return
-    endif
-
-    call self._gotoTargetWin()
-
-    if self._stay
-        silent call self._path.edit()
-        call self._restoreCursorPos()
-        return
-    endif
-
-    call self._path.edit()
-endfunction
-
-" FUNCTION: Opener._openDirectory(node) {{{1
-function! s:Opener._openDirectory(node)
-    call self._gotoTargetWin()
-
-    if self._nerdtree.isWinTree()
-        call g:NERDTreeCreator.CreateWindowTree(a:node.path.str())
-    else
-        if empty(self._where)
-            call b:NERDTree.changeRoot(a:node)
-        elseif self._where ==# 't'
-            call g:NERDTreeCreator.CreateTabTree(a:node.path.str())
-        else
-            call g:NERDTreeCreator.CreateWindowTree(a:node.path.str())
-        endif
-    endif
-
-    if self._stay
-        call self._restoreCursorPos()
-    endif
-endfunction
-
-" FUNCTION: Opener._previousWindow() {{{1
-function! s:Opener._previousWindow()
-    if !self._isWindowUsable(winnr('#')) && self._firstUsableWindow() ==# -1
-        call self._newSplit()
-    else
-        try
-            if !self._isWindowUsable(winnr('#'))
-                call nerdtree#exec(self._firstUsableWindow() . 'wincmd w', 1)
-            else
-                call nerdtree#exec('wincmd p', 1)
-            endif
-        catch /^Vim\%((\a\+)\)\=:E37/
-            call g:NERDTree.CursorToTreeWin()
-            throw 'NERDTree.FileAlreadyOpenAndModifiedError: '. self._path.str() .' is already open and modified.'
-        catch /^Vim\%((\a\+)\)\=:/
-            echo v:exception
-        endtry
-    endif
-endfunction
-
-" FUNCTION: Opener._restoreCursorPos() {{{1
-function! s:Opener._restoreCursorPos()
-    call nerdtree#exec(self._tabnr . 'tabnext', 1)
-    call nerdtree#exec(bufwinnr(self._bufnr) . 'wincmd w', 1)
-endfunction
-
-" FUNCTION: Opener._reuseWindow() {{{1
-" put the cursor in the first window we find for this file
-"
-" return 1 if we were successful
-function! s:Opener._reuseWindow()
-    if empty(self._reuse)
-        return 0
-    endif
-
-    "check the current tab for the window
-    let winnr = bufwinnr('^' . self._path.str() . '$')
-    if winnr !=# -1
-        call nerdtree#exec(winnr . 'wincmd w', 0)
-        call self._checkToCloseTree(0)
-        return 1
-    endif
-
-    if self._reuse ==# 'currenttab'
-        return 0
-    endif
-
-    "check other tabs
-    let tabnr = self._path.tabnr()
-    if tabnr
-        call self._checkToCloseTree(1)
-        call nerdtree#exec(tabnr . 'tabnext', 1)
-        let winnr = bufwinnr('^' . self._path.str() . '$')
-        call nerdtree#exec(winnr . 'wincmd w', 0)
-        return 1
-    endif
-
-    return 0
-endfunction
-
-" FUNCTION: Opener._saveCursorPos() {{{1
-function! s:Opener._saveCursorPos()
-    let self._bufnr = bufnr('')
-    let self._tabnr = tabpagenr()
-endfunction
-
-" vim: set sw=4 sts=4 et fdm=marker:
diff --git a/sources_non_forked/nerdtree/lib/nerdtree/path.vim b/sources_non_forked/nerdtree/lib/nerdtree/path.vim
deleted file mode 100644
index d30dd51..0000000
--- a/sources_non_forked/nerdtree/lib/nerdtree/path.vim
+++ /dev/null
@@ -1,910 +0,0 @@
-" ============================================================================
-" CLASS: Path
-"
-" The Path class provides an abstracted representation of a file system
-" pathname.  Various operations on pathnames are provided and a number of
-" representations of a given path name can be accessed here.
-" ============================================================================
-
-
-let s:Path = {}
-let g:NERDTreePath = s:Path
-
-" FUNCTION: Path.AbsolutePathFor(pathStr) {{{1
-function! s:Path.AbsolutePathFor(pathStr)
-    let l:prependWorkingDir = 0
-
-    if nerdtree#runningWindows()
-        let l:prependWorkingDir = a:pathStr !~# '^.:\(\\\|\/\)\?' && a:pathStr !~# '^\(\\\\\|\/\/\)'
-    else
-        let l:prependWorkingDir = a:pathStr !~# '^/'
-    endif
-
-    let l:result = a:pathStr
-
-    if l:prependWorkingDir
-        let l:result = getcwd()
-
-        if l:result[-1:] ==# s:Path.Slash()
-            let l:result = l:result . a:pathStr
-        else
-            let l:result = l:result . s:Path.Slash() . a:pathStr
-        endif
-    endif
-
-    return l:result
-endfunction
-
-" FUNCTION: Path.bookmarkNames() {{{1
-function! s:Path.bookmarkNames()
-    if !exists('self._bookmarkNames')
-        call self.cacheDisplayString()
-    endif
-    return self._bookmarkNames
-endfunction
-
-" FUNCTION: Path.cacheDisplayString() {{{1
-function! s:Path.cacheDisplayString() abort
-    let self.cachedDisplayString = g:NERDTreeNodeDelimiter . self.getLastPathComponent(1)
-
-    if self.isExecutable
-        let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . '*'
-    endif
-
-    let self._bookmarkNames = []
-    for i in g:NERDTreeBookmark.Bookmarks()
-        if i.path.equals(self)
-            call add(self._bookmarkNames, i.name)
-        endif
-    endfor
-    if !empty(self._bookmarkNames) && g:NERDTreeMarkBookmarks ==# 1
-        let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . ' {' . join(self._bookmarkNames) . '}'
-    endif
-
-    if self.isSymLink
-        let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . ' -> ' . self.symLinkDest
-    endif
-
-    if self.isReadOnly
-        let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . ' ['.g:NERDTreeGlyphReadOnly.']'
-    endif
-endfunction
-
-" FUNCTION: Path.addDelimiter() {{{1
-function! s:Path.addDelimiter(line)
-    if a:line =~# '\(.*' . g:NERDTreeNodeDelimiter . '\)\{2}'
-        return a:line
-    else
-        return a:line . g:NERDTreeNodeDelimiter
-    endif
-endfunction
-
-" FUNCTION: Path.changeToDir() {{{1
-function! s:Path.changeToDir()
-    let dir = self.str({'format': 'Cd'})
-    if self.isDirectory ==# 0
-        let dir = self.getParent().str({'format': 'Cd'})
-    endif
-
-    try
-        if g:NERDTreeUseTCD && exists(':tcd') ==# 2
-            execute 'tcd ' . dir
-            call nerdtree#echo("Tab's CWD is now: " . getcwd())
-        else
-            execute 'cd ' . dir
-            call nerdtree#echo('CWD is now: ' . getcwd())
-        endif
-    catch
-        throw 'NERDTree.PathChangeError: cannot change CWD to ' . dir
-    endtry
-endfunction
-
-" FUNCTION: Path.compareTo() {{{1
-"
-" Compares this Path to the given path and returns 0 if they are equal, -1 if
-" this Path is 'less than' the given path, or 1 if it is 'greater'.
-"
-" Args:
-" path: the path object to compare this to
-"
-" Return:
-" 1, -1 or 0
-function! s:Path.compareTo(path)
-    let thisPath = self.getLastPathComponent(1)
-    let thatPath = a:path.getLastPathComponent(1)
-
-    "if the paths are the same then clearly we return 0
-    if thisPath ==# thatPath
-        return 0
-    endif
-
-    let thisSS = self.getSortOrderIndex()
-    let thatSS = a:path.getSortOrderIndex()
-
-    "compare the sort sequences, if they are different then the return
-    "value is easy
-    if thisSS < thatSS
-        return -1
-    elseif thisSS > thatSS
-        return 1
-    else
-        if !g:NERDTreeSortHiddenFirst
-            let thisPath = substitute(thisPath, '^[._]', '', '')
-            let thatPath = substitute(thatPath, '^[._]', '', '')
-        endif
-        "if the sort sequences are the same then compare the paths
-        "alphabetically
-        let pathCompare = g:NERDTreeCaseSensitiveSort ? thisPath <# thatPath : thisPath <? thatPath
-        if pathCompare
-            return -1
-        else
-            return 1
-        endif
-    endif
-endfunction
-
-" FUNCTION: Path.Create(fullpath) {{{1
-"
-" Factory method.
-"
-" Creates a path object with the given path. The path is also created on the
-" filesystem. If the path already exists, a NERDTree.Path.Exists exception is
-" thrown. If any other errors occur, a NERDTree.Path exception is thrown.
-"
-" Args:
-" fullpath: the full filesystem path to the file/dir to create
-function! s:Path.Create(fullpath)
-    "bail if the a:fullpath already exists
-    if isdirectory(a:fullpath) || filereadable(a:fullpath)
-        throw "NERDTree.CreatePathError: Directory Exists: '" . a:fullpath . "'"
-    endif
-
-    try
-
-        "if it ends with a slash, assume its a dir create it
-        if a:fullpath =~# '\(\\\|\/\)$'
-            "whack the trailing slash off the end if it exists
-            let fullpath = substitute(a:fullpath, '\(\\\|\/\)$', '', '')
-
-            call mkdir(fullpath, 'p')
-
-        "assume its a file and create
-        else
-            call s:Path.createParentDirectories(a:fullpath)
-            call writefile([], a:fullpath)
-        endif
-    catch
-        throw "NERDTree.CreatePathError: Could not create path: '" . a:fullpath . "'"
-    endtry
-
-    return s:Path.New(a:fullpath)
-endfunction
-
-" FUNCTION: Path.copy(dest) {{{1
-"
-" Copies the file/dir represented by this Path to the given location
-"
-" Args:
-" dest: the location to copy this dir/file to
-function! s:Path.copy(dest)
-    if !s:Path.CopyingSupported()
-        throw 'NERDTree.CopyingNotSupportedError: Copying is not supported on this OS'
-    endif
-
-    call s:Path.createParentDirectories(a:dest)
-
-    if exists('g:NERDTreeCopyCmd')
-        let cmd_prefix = g:NERDTreeCopyCmd
-    else
-        let cmd_prefix = (self.isDirectory ? g:NERDTreeCopyDirCmd : g:NERDTreeCopyFileCmd)
-    endif
-
-    let cmd = cmd_prefix . ' ' . shellescape(self.str()) . ' ' . shellescape(a:dest)
-    let success = system(cmd)
-    if v:shell_error !=# 0
-        throw "NERDTree.CopyError: Could not copy '". self.str() ."' to: '" . a:dest . "'"
-    endif
-endfunction
-
-" FUNCTION: Path.CopyingSupported() {{{1
-"
-" returns 1 if copying is supported for this OS
-function! s:Path.CopyingSupported()
-    return exists('g:NERDTreeCopyCmd') || (exists('g:NERDTreeCopyDirCmd') && exists('g:NERDTreeCopyFileCmd'))
-endfunction
-
-" FUNCTION: Path.copyingWillOverwrite(dest) {{{1
-"
-" returns 1 if copy this path to the given location will cause files to
-" overwritten
-"
-" Args:
-" dest: the location this path will be copied to
-function! s:Path.copyingWillOverwrite(dest)
-    if filereadable(a:dest)
-        return 1
-    endif
-
-    if isdirectory(a:dest)
-        let path = s:Path.JoinPathStrings(a:dest, self.getLastPathComponent(0))
-        if filereadable(path)
-            return 1
-        endif
-    endif
-endfunction
-
-" FUNCTION: Path.createParentDirectories(path) {{{1
-"
-" create parent directories for this path if needed
-" without throwing any errors if those directories already exist
-"
-" Args:
-" path: full path of the node whose parent directories may need to be created
-function! s:Path.createParentDirectories(path)
-    let dir_path = fnamemodify(a:path, ':h')
-    if !isdirectory(dir_path)
-        call mkdir(dir_path, 'p')
-    endif
-endfunction
-
-" FUNCTION: Path.delete() {{{1
-"
-" Deletes the file or directory represented by this path.
-"
-" Throws NERDTree.Path.Deletion exceptions
-function! s:Path.delete()
-    if self.isDirectory
-
-        let cmd = g:NERDTreeRemoveDirCmd . self.str({'escape': 1})
-        let success = system(cmd)
-
-        if v:shell_error !=# 0
-            throw "NERDTree.PathDeletionError: Could not delete directory: '" . self.str() . "'"
-        endif
-    else
-        if exists('g:NERDTreeRemoveFileCmd')
-            let cmd = g:NERDTreeRemoveFileCmd . self.str({'escape': 1})
-            let success = system(cmd)
-        else
-            let success = delete(self.str())
-        endif
-
-        if success !=# 0
-            throw "NERDTree.PathDeletionError: Could not delete file: '" . self.str() . "'"
-        endif
-    endif
-
-    "delete all bookmarks for this path
-    for i in self.bookmarkNames()
-        let bookmark = g:NERDTreeBookmark.BookmarkFor(i)
-        call bookmark.delete()
-    endfor
-endfunction
-
-" FUNCTION: Path.displayString() {{{1
-"
-" Returns a string that specifies how the path should be represented as a
-" string
-function! s:Path.displayString()
-    if self.cachedDisplayString ==# ''
-        call self.cacheDisplayString()
-    endif
-
-    return self.cachedDisplayString
-endfunction
-
-" FUNCTION: Path.edit() {{{1
-function! s:Path.edit()
-    let l:bufname = self.str({'format': 'Edit'})
-    if bufname('%') !=# l:bufname
-        exec 'edit ' . l:bufname
-    endif
-endfunction
-
-" FUNCTION: Path.extractDriveLetter(fullpath) {{{1
-"
-" If running windows, cache the drive letter for this path
-function! s:Path.extractDriveLetter(fullpath)
-    if nerdtree#runningWindows()
-        if a:fullpath =~# '^\(\\\\\|\/\/\)'
-            "For network shares, the 'drive' consists of the first two parts of the path, i.e. \\boxname\share
-            let self.drive = substitute(a:fullpath, '^\(\(\\\\\|\/\/\)[^\\\/]*\(\\\|\/\)[^\\\/]*\).*', '\1', '')
-            let self.drive = substitute(self.drive, '/', '\', 'g')
-        else
-            let self.drive = substitute(a:fullpath, '\(^[a-zA-Z]:\).*', '\1', '')
-        endif
-    else
-        let self.drive = ''
-    endif
-
-endfunction
-
-" FUNCTION: Path.exists() {{{1
-" return 1 if this path points to a location that is readable or is a directory
-function! s:Path.exists()
-    let p = self.str()
-    return filereadable(p) || isdirectory(p)
-endfunction
-
-" FUNCTION: Path._escChars() {{{1
-function! s:Path._escChars()
-    if nerdtree#runningWindows()
-        return " `\|\"#%&,?()\*^<>$"
-    endif
-
-    return " \\`\|\"#%&,?()\*^<>[]{}$"
-endfunction
-
-" FUNCTION: Path.getDir() {{{1
-"
-" Returns this path if it is a directory, else this paths parent.
-"
-" Return:
-" a Path object
-function! s:Path.getDir()
-    if self.isDirectory
-        return self
-    else
-        return self.getParent()
-    endif
-endfunction
-
-" FUNCTION: Path.getParent() {{{1
-"
-" Returns a new path object for this paths parent
-"
-" Return:
-" a new Path object
-function! s:Path.getParent()
-    if nerdtree#runningWindows()
-        let path = self.drive . '\' . join(self.pathSegments[0:-2], '\')
-    else
-        let path = '/'. join(self.pathSegments[0:-2], '/')
-    endif
-
-    return s:Path.New(path)
-endfunction
-
-" FUNCTION: Path.getLastPathComponent(dirSlash) {{{1
-"
-" Gets the last part of this path.
-"
-" Args:
-" dirSlash: if 1 then a trailing slash will be added to the returned value for
-" directory nodes.
-function! s:Path.getLastPathComponent(dirSlash)
-    if empty(self.pathSegments)
-        return ''
-    endif
-    let toReturn = self.pathSegments[-1]
-    if a:dirSlash && self.isDirectory
-        let toReturn = toReturn . '/'
-    endif
-    return toReturn
-endfunction
-
-" FUNCTION: Path.getSortOrderIndex() {{{1
-" returns the index of the pattern in g:NERDTreeSortOrder that this path matches
-function! s:Path.getSortOrderIndex()
-    let i = 0
-    while i < len(g:NERDTreeSortOrder)
-        if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' &&
-        \ self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
-            return i
-        endif
-        let i = i + 1
-    endwhile
-
-    return index(g:NERDTreeSortOrder, '*')
-endfunction
-
-" FUNCTION: Path._splitChunks(path) {{{1
-" returns a list of path chunks
-function! s:Path._splitChunks(path)
-    let chunks = split(a:path, '\(\D\+\|\d\+\)\zs')
-    let i = 0
-    while i < len(chunks)
-        "convert number literals to numbers
-        if match(chunks[i], '^\d\+$') ==# 0
-            let chunks[i] = str2nr(chunks[i])
-        endif
-        let i = i + 1
-    endwhile
-    return chunks
-endfunction
-
-" FUNCTION: Path.getSortKey() {{{1
-" returns a key used in compare function for sorting
-function! s:Path.getSortKey()
-    if !exists('self._sortKey') || g:NERDTreeSortOrder !=# g:NERDTreeOldSortOrder
-        " Look for file metadata tags: [[timestamp]], [[extension]], [[size]]
-        let metadata = []
-        for tag in g:NERDTreeSortOrder
-            if tag =~? '\[\[-\?timestamp\]\]'
-                let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~# '-' ? -1 : 1)]
-            elseif tag =~? '\[\[-\?size\]\]'
-                let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~# '-' ? -1 : 1)]
-            elseif tag =~? '\[\[extension\]\]'
-                let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
-                let metadata += [self.isDirectory ? '' : (extension ==# '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
-            endif
-        endfor
-
-        if g:NERDTreeSortOrder[0] =~# '\[\[.*\]\]'
-            " Apply tags' sorting first if specified first.
-            let self._sortKey = metadata + [self.getSortOrderIndex()]
-        else
-            " Otherwise, do regex grouping first.
-            let self._sortKey = [self.getSortOrderIndex()] + metadata
-        endif
-
-        let path = self.getLastPathComponent(1)
-        if !g:NERDTreeSortHiddenFirst
-            let path = substitute(path, '^[._]', '', '')
-        endif
-        if !g:NERDTreeCaseSensitiveSort
-            let path = tolower(path)
-        endif
-
-        call extend(self._sortKey, (g:NERDTreeNaturalSort ? self._splitChunks(path) : [path]))
-    endif
-    return self._sortKey
-endfunction
-
-" FUNCTION: Path.isHiddenUnder(path) {{{1
-function! s:Path.isHiddenUnder(path)
-
-    if !self.isUnder(a:path)
-        return 0
-    endif
-
-    let l:startIndex = len(a:path.pathSegments)
-    let l:segments = self.pathSegments[l:startIndex : ]
-
-    for l:segment in l:segments
-
-        if l:segment =~# '^\.'
-            return 1
-        endif
-    endfor
-
-    return 0
-endfunction
-
-" FUNCTION: Path.isUnixHiddenFile() {{{1
-" check for unix hidden files
-function! s:Path.isUnixHiddenFile()
-    return self.getLastPathComponent(0) =~# '^\.'
-endfunction
-
-" FUNCTION: Path.isUnixHiddenPath() {{{1
-" check for unix path with hidden components
-function! s:Path.isUnixHiddenPath()
-    if self.getLastPathComponent(0) =~# '^\.'
-        return 1
-    else
-        for segment in self.pathSegments
-            if segment =~# '^\.'
-                return 1
-            endif
-        endfor
-        return 0
-    endif
-endfunction
-
-" FUNCTION: Path.ignore(nerdtree) {{{1
-" returns true if this path should be ignored
-function! s:Path.ignore(nerdtree)
-    "filter out the user specified paths to ignore
-    if a:nerdtree.ui.isIgnoreFilterEnabled()
-        for i in g:NERDTreeIgnore
-            if self._ignorePatternMatches(i)
-                return 1
-            endif
-        endfor
-
-        for Callback in g:NERDTree.PathFilters()
-            let Callback = type(Callback) ==# type(function('tr')) ? Callback : function(Callback)
-            if Callback({'path': self, 'nerdtree': a:nerdtree})
-                return 1
-            endif
-        endfor
-    endif
-
-    "dont show hidden files unless instructed to
-    if !a:nerdtree.ui.getShowHidden() && self.isUnixHiddenFile()
-        return 1
-    endif
-
-    if a:nerdtree.ui.getShowFiles() ==# 0 && self.isDirectory ==# 0
-        return 1
-    endif
-
-    return 0
-endfunction
-
-" FUNCTION: Path._ignorePatternMatches(pattern) {{{1
-" returns true if this path matches the given ignore pattern
-function! s:Path._ignorePatternMatches(pattern)
-    let pat = a:pattern
-    if strpart(pat,len(pat)-7) ==# '[[dir]]'
-        if !self.isDirectory
-            return 0
-        endif
-        let pat = strpart(pat,0, len(pat)-7)
-    elseif strpart(pat,len(pat)-8) ==# '[[file]]'
-        if self.isDirectory
-            return 0
-        endif
-        let pat = strpart(pat,0, len(pat)-8)
-    endif
-
-    return self.getLastPathComponent(0) =~# pat
-endfunction
-
-" FUNCTION: Path.isAncestor(path) {{{1
-" return 1 if this path is somewhere above the given path in the filesystem.
-"
-" a:path should be a dir
-function! s:Path.isAncestor(child)
-    return a:child.isUnder(self)
-endfunction
-
-" FUNCTION: Path.isUnder(path) {{{1
-" return 1 if this path is somewhere under the given path in the filesystem.
-function! s:Path.isUnder(parent)
-    if a:parent.isDirectory ==# 0
-        return 0
-    endif
-    if nerdtree#runningWindows() && a:parent.drive !=# self.drive
-        return 0
-    endif
-    let l:this_count = len(self.pathSegments)
-    if l:this_count ==# 0
-        return 0
-    endif
-    let l:that_count = len(a:parent.pathSegments)
-    if l:that_count ==# 0
-        return 1
-    endif
-    if l:that_count >= l:this_count
-        return 0
-    endif
-    for i in range(0, l:that_count-1)
-        if self.pathSegments[i] !=# a:parent.pathSegments[i]
-            return 0
-        endif
-    endfor
-    return 1
-endfunction
-
-" FUNCTION: Path.JoinPathStrings(...) {{{1
-function! s:Path.JoinPathStrings(...)
-    let components = []
-    for i in a:000
-        let components = extend(components, split(i, '/'))
-    endfor
-    return '/' . join(components, '/')
-endfunction
-
-" FUNCTION: Path.equals() {{{1
-"
-" Determines whether 2 path objects are "equal".
-" They are equal if the paths they represent are the same
-"
-" Args:
-" path: the other path obj to compare this with
-function! s:Path.equals(path)
-    if nerdtree#runningWindows()
-        return self.str() ==? a:path.str()
-    else
-        return self.str() ==# a:path.str()
-    endif
-endfunction
-
-" FUNCTION: Path.New(pathStr) {{{1
-function! s:Path.New(pathStr)
-    let l:newPath = copy(self)
-
-    call l:newPath.readInfoFromDisk(s:Path.AbsolutePathFor(a:pathStr))
-
-    let l:newPath.cachedDisplayString = ''
-    let l:newPath.flagSet = g:NERDTreeFlagSet.New()
-
-    return l:newPath
-endfunction
-
-" FUNCTION: Path.Slash() {{{1
-" Return the path separator used by the underlying file system.  Special
-" consideration is taken for the use of the 'shellslash' option on Windows
-" systems.
-function! s:Path.Slash()
-
-    if nerdtree#runningWindows()
-        if exists('+shellslash') && &shellslash
-            return '/'
-        endif
-
-        return '\'
-    endif
-
-    return '/'
-endfunction
-
-" FUNCTION: Path.Resolve() {{{1
-" Invoke the vim resolve() function and return the result
-" This is necessary because in some versions of vim resolve() removes trailing
-" slashes while in other versions it doesn't.  This always removes the trailing
-" slash
-function! s:Path.Resolve(path)
-    let tmp = resolve(a:path)
-    return tmp =~# '.\+/$' ? substitute(tmp, '/$', '', '') : tmp
-endfunction
-
-" FUNCTION: Path.readInfoFromDisk(fullpath) {{{1
-"
-"
-" Throws NERDTree.Path.InvalidArguments exception.
-function! s:Path.readInfoFromDisk(fullpath)
-    call self.extractDriveLetter(a:fullpath)
-
-    let fullpath = s:Path.WinToUnixPath(a:fullpath)
-
-    if getftype(fullpath) ==# 'fifo'
-        throw 'NERDTree.InvalidFiletypeError: Cant handle FIFO files: ' . a:fullpath
-    endif
-
-    let self.pathSegments = filter(split(fullpath, '/'), '!empty(v:val)')
-
-    let self.isReadOnly = 0
-    if isdirectory(a:fullpath)
-        let self.isDirectory = 1
-    elseif filereadable(a:fullpath)
-        let self.isDirectory = 0
-        let self.isReadOnly = filewritable(a:fullpath) ==# 0
-    else
-        throw 'NERDTree.InvalidArgumentsError: Invalid path = ' . a:fullpath
-    endif
-
-    let self.isExecutable = 0
-    if !self.isDirectory
-        let self.isExecutable = getfperm(a:fullpath) =~# 'x'
-    endif
-
-    "grab the last part of the path (minus the trailing slash)
-    let lastPathComponent = self.getLastPathComponent(0)
-
-    "get the path to the new node with the parent dir fully resolved
-    let hardPath = s:Path.Resolve(self.strTrunk()) . '/' . lastPathComponent
-
-    "if  the last part of the path is a symlink then flag it as such
-    let self.isSymLink = (s:Path.Resolve(hardPath) !=# hardPath)
-    if self.isSymLink
-        let self.symLinkDest = s:Path.Resolve(fullpath)
-
-        "if the link is a dir then slap a / on the end of its dest
-        if isdirectory(self.symLinkDest)
-
-            "we always wanna treat MS windows shortcuts as files for
-            "simplicity
-            if hardPath !~# '\.lnk$'
-
-                let self.symLinkDest = self.symLinkDest . '/'
-            endif
-        endif
-    endif
-endfunction
-
-" FUNCTION: Path.refresh(nerdtree) {{{1
-function! s:Path.refresh(nerdtree)
-    call self.readInfoFromDisk(self.str())
-    call g:NERDTreePathNotifier.NotifyListeners('refresh', self, a:nerdtree, {})
-    call self.cacheDisplayString()
-endfunction
-
-" FUNCTION: Path.refreshFlags(nerdtree) {{{1
-function! s:Path.refreshFlags(nerdtree)
-    call g:NERDTreePathNotifier.NotifyListeners('refreshFlags', self, a:nerdtree, {})
-    call self.cacheDisplayString()
-endfunction
-
-" FUNCTION: Path.rename() {{{1
-"
-" Renames this node on the filesystem
-function! s:Path.rename(newPath)
-    if a:newPath ==# ''
-        throw 'NERDTree.InvalidArgumentsError: Invalid newPath for renaming = '. a:newPath
-    endif
-
-    call s:Path.createParentDirectories(a:newPath)
-
-    let success =  rename(self.str(), a:newPath)
-    if success !=# 0
-        throw "NERDTree.PathRenameError: Could not rename: '" . self.str() . "'" . 'to:' . a:newPath
-    endif
-    call self.readInfoFromDisk(a:newPath)
-
-    for i in self.bookmarkNames()
-        let b = g:NERDTreeBookmark.BookmarkFor(i)
-        call b.setPath(copy(self))
-    endfor
-    call g:NERDTreeBookmark.Write()
-endfunction
-
-" FUNCTION: Path.str() {{{1
-" Return a string representation of this Path object.
-"
-" Args:
-" This function takes a single dictionary (optional) with keys and values that
-" specify how the returned pathname should be formatted.
-"
-" The dictionary may have the following keys:
-"  'format'
-"  'escape'
-"  'truncateTo'
-"
-" The 'format' key may have a value of:
-"  'Cd' - a string to be used with ":cd" and similar commands
-"  'Edit' - a string to be used with ":edit" and similar commands
-"  'UI' - a string to be displayed in the NERDTree user interface
-"
-" The 'escape' key, if specified, will cause the output to be escaped with
-" Vim's internal "shellescape()" function.
-"
-" The 'truncateTo' key shortens the length of the path to that given by the
-" value associated with 'truncateTo'. A '<' is prepended.
-function! s:Path.str(...)
-    let options = a:0 ? a:1 : {}
-    let toReturn = ''
-
-    if has_key(options, 'format')
-        let format = options['format']
-        if has_key(self, '_strFor' . format)
-            exec 'let toReturn = self._strFor' . format . '()'
-        else
-            throw 'NERDTree.UnknownFormatError: unknown format "'. format .'"'
-        endif
-    else
-        let toReturn = self._str()
-    endif
-
-    if nerdtree#has_opt(options, 'escape')
-        let toReturn = shellescape(toReturn)
-    endif
-
-    if has_key(options, 'truncateTo')
-        let limit = options['truncateTo']
-        if strdisplaywidth(toReturn) > limit-1
-            while strdisplaywidth(toReturn) > limit-1 && strchars(toReturn) > 0
-                let toReturn = substitute(toReturn, '^.', '', '')
-            endwhile
-            if len(split(toReturn, '/')) > 1
-                let toReturn = '</' . join(split(toReturn, '/')[1:], '/') . '/'
-            else
-                let toReturn = '<' . toReturn
-            endif
-        endif
-    endif
-
-    return toReturn
-endfunction
-
-" FUNCTION: Path._strForUI() {{{1
-function! s:Path._strForUI()
-    let toReturn = '/' . join(self.pathSegments, '/')
-    if self.isDirectory && toReturn !=# '/'
-        let toReturn  = toReturn . '/'
-    endif
-    return toReturn
-endfunction
-
-" FUNCTION: Path._strForCd() {{{1
-" Return a string representation of this Path that is suitable for use as an
-" argument to Vim's internal ":cd" command.
-function! s:Path._strForCd()
-    return fnameescape(self.str())
-endfunction
-
-" FUNCTION: Path._strForEdit() {{{1
-" Return a string representation of this Path that is suitable for use as an
-" argument to Vim's internal ":edit" command.
-function! s:Path._strForEdit()
-
-    " Make the path relative to the current working directory, if possible.
-    let l:result = fnamemodify(self.str(), ':.')
-
-    " On Windows, the drive letter may be removed by "fnamemodify()".  Add it
-    " back, if necessary.
-    if nerdtree#runningWindows() && l:result[0] ==# s:Path.Slash()
-        let l:result = self.drive . l:result
-    endif
-
-    let l:result = fnameescape(l:result)
-
-    if empty(l:result)
-        let l:result = '.'
-    endif
-
-    return l:result
-endfunction
-
-" FUNCTION: Path._strForGlob() {{{1
-function! s:Path._strForGlob()
-    let lead = s:Path.Slash()
-
-    "if we are running windows then slap a drive letter on the front
-    if nerdtree#runningWindows()
-        let lead = self.drive . '\'
-    endif
-
-    let toReturn = lead . join(self.pathSegments, s:Path.Slash())
-
-    if !nerdtree#runningWindows()
-        let toReturn = escape(toReturn, self._escChars())
-    endif
-    return toReturn
-endfunction
-
-" FUNCTION: Path._str() {{{1
-" Return the absolute pathname associated with this Path object.  The pathname
-" returned is appropriate for the underlying file system.
-function! s:Path._str()
-    let l:separator = s:Path.Slash()
-    let l:leader = l:separator
-
-    if nerdtree#runningWindows()
-        let l:leader = self.drive . l:separator
-    endif
-
-    return l:leader . join(self.pathSegments, l:separator)
-endfunction
-
-" FUNCTION: Path.strTrunk() {{{1
-" Gets the path without the last segment on the end.
-function! s:Path.strTrunk()
-    return self.drive . '/' . join(self.pathSegments[0:-2], '/')
-endfunction
-
-" FUNCTION: Path.tabnr() {{{1
-" return the number of the first tab that is displaying this file
-"
-" return 0 if no tab was found
-function! s:Path.tabnr()
-    let str = self.str()
-    for t in range(tabpagenr('$'))
-        for b in tabpagebuflist(t+1)
-            if str ==# expand('#' . b . ':p')
-                return t+1
-            endif
-        endfor
-    endfor
-    return 0
-endfunction
-
-" FUNCTION: Path.WinToUnixPath(pathstr){{{1
-" Takes in a windows path and returns the unix equiv
-"
-" A class level method
-"
-" Args:
-" pathstr: the windows path to convert
-function! s:Path.WinToUnixPath(pathstr)
-    if !nerdtree#runningWindows()
-        return a:pathstr
-    endif
-
-    let toReturn = a:pathstr
-
-    "remove the x:\ of the front
-    let toReturn = substitute(toReturn, '^.*:\(\\\|/\)\?', '/', '')
-
-    "remove the \\ network share from the front
-    let toReturn = substitute(toReturn, '^\(\\\\\|\/\/\)[^\\\/]*\(\\\|\/\)[^\\\/]*\(\\\|\/\)\?', '/', '')
-
-    "convert all \ chars to /
-    let toReturn = substitute(toReturn, '\', '/', 'g')
-
-    return toReturn
-endfunction
-
-" vim: set sw=4 sts=4 et fdm=marker:
diff --git a/sources_non_forked/nerdtree/lib/nerdtree/tree_dir_node.vim b/sources_non_forked/nerdtree/lib/nerdtree/tree_dir_node.vim
deleted file mode 100644
index d2ad1cd..0000000
--- a/sources_non_forked/nerdtree/lib/nerdtree/tree_dir_node.vim
+++ /dev/null
@@ -1,706 +0,0 @@
-" ============================================================================
-" CLASS: TreeDirNode
-"
-" A subclass of NERDTreeFileNode.
-"
-" The 'composite' part of the file/dir composite.
-" ============================================================================
-
-
-let s:TreeDirNode = copy(g:NERDTreeFileNode)
-let g:NERDTreeDirNode = s:TreeDirNode
-
-" FUNCTION: TreeDirNode.AbsoluteTreeRoot(){{{1
-" Class method that returns the highest cached ancestor of the current root.
-function! s:TreeDirNode.AbsoluteTreeRoot()
-    let currentNode = b:NERDTree.root
-    while currentNode.parent !=# {}
-        let currentNode = currentNode.parent
-    endwhile
-    return currentNode
-endfunction
-
-" FUNCTION: TreeDirNode.activate([options]) {{{1
-function! s:TreeDirNode.activate(...)
-    let l:options = (a:0 > 0) ? a:1 : {}
-
-    call self.toggleOpen(l:options)
-
-    " Note that we only re-render the NERDTree for this node if we did NOT
-    " create a new node and render it in a new window or tab.  In the latter
-    " case, rendering the NERDTree for this node could overwrite the text of
-    " the new NERDTree!
-    if !has_key(l:options, 'where') || empty(l:options['where'])
-        call self.getNerdtree().render()
-        call self.putCursorHere(0, 0)
-    endif
-endfunction
-
-" FUNCTION: TreeDirNode.addChild(treenode, inOrder) {{{1
-" Adds the given treenode to the list of children for this node
-"
-" Args:
-" -treenode: the node to add
-" -inOrder: 1 if the new node should be inserted in sorted order
-function! s:TreeDirNode.addChild(treenode, inOrder)
-    call add(self.children, a:treenode)
-    let a:treenode.parent = self
-
-    if a:inOrder
-        call self.sortChildren()
-    endif
-endfunction
-
-" FUNCTION: TreeDirNode.close() {{{1
-" Mark this TreeDirNode as closed.
-function! s:TreeDirNode.close()
-
-    " Close all directories in this directory node's cascade. This is
-    " necessary to ensure consistency when cascades are rendered.
-    for l:dirNode in self.getCascade()
-        let l:dirNode.isOpen = 0
-    endfor
-endfunction
-
-" FUNCTION: TreeDirNode.closeChildren() {{{1
-" Recursively close any directory nodes that are descendants of this node.
-function! s:TreeDirNode.closeChildren()
-    for l:child in self.children
-        if l:child.path.isDirectory
-            call l:child.close()
-            call l:child.closeChildren()
-        endif
-    endfor
-endfunction
-
-" FUNCTION: TreeDirNode.createChild(path, inOrder) {{{1
-" Instantiates a new child node for this node with the given path. The new
-" nodes parent is set to this node.
-"
-" Args:
-" path: a Path object that this node will represent/contain
-" inOrder: 1 if the new node should be inserted in sorted order
-"
-" Returns:
-" the newly created node
-function! s:TreeDirNode.createChild(path, inOrder)
-    let newTreeNode = g:NERDTreeFileNode.New(a:path, self.getNerdtree())
-    call self.addChild(newTreeNode, a:inOrder)
-    return newTreeNode
-endfunction
-
-" FUNCTION: TreeDirNode.displayString() {{{1
-" Assemble and return a string that can represent this TreeDirNode object in
-" the NERDTree window.
-function! s:TreeDirNode.displayString()
-    let l:result = ''
-
-    " Build a label that identifies this TreeDirNode.
-    let l:label = ''
-    let l:cascade = self.getCascade()
-    for l:dirNode in l:cascade
-        let l:next = l:dirNode.path.displayString()
-        let l:label .= l:label ==# '' ? l:next : substitute(l:next,'^.','','')
-    endfor
-
-    " Select the appropriate open/closed status indicator symbol.
-    let l:symbol = (l:cascade[-1].isOpen ? g:NERDTreeDirArrowCollapsible : g:NERDTreeDirArrowExpandable )
-    let l:symbol .= (g:NERDTreeDirArrowExpandable ==# '' ? '' : ' ')
-    let l:flags = l:cascade[-1].path.flagSet.renderToString()
-
-    return l:symbol . l:flags . l:label
-endfunction
-
-" FUNCTION: TreeDirNode.findNode(path) {{{1
-" Will find one of the children (recursively) that has the given path
-"
-" Args:
-" path: a path object
-unlet s:TreeDirNode.findNode
-function! s:TreeDirNode.findNode(path)
-    if a:path.equals(self.path)
-        return self
-    endif
-    if stridx(a:path.str(), self.path.str(), 0) ==# -1
-        return {}
-    endif
-
-    if self.path.isDirectory
-        for i in self.children
-            let retVal = i.findNode(a:path)
-            if retVal !=# {}
-                return retVal
-            endif
-        endfor
-    endif
-    return {}
-endfunction
-
-" FUNCTION: TreeDirNode.getCascade() {{{1
-" Return an array of dir nodes (starting from self) that can be cascade opened.
-function! s:TreeDirNode.getCascade()
-    if !self.isCascadable()
-        return [self]
-    endif
-
-    let vc = self.getVisibleChildren()
-    let visChild = vc[0]
-
-    return [self] + visChild.getCascade()
-endfunction
-
-" FUNCTION: TreeDirNode.getCascadeRoot() {{{1
-" Return the first directory node in the cascade in which this directory node
-" is rendered.
-function! s:TreeDirNode.getCascadeRoot()
-
-    " Don't search above the current NERDTree root node.
-    if self.isRoot()
-        return self
-    endif
-
-    let l:cascadeRoot = self
-    let l:parent = self.parent
-
-    while !empty(l:parent) && !l:parent.isRoot()
-
-        if index(l:parent.getCascade(), self) ==# -1
-            break
-        endif
-
-        let l:cascadeRoot = l:parent
-        let l:parent = l:parent.parent
-    endwhile
-
-    return l:cascadeRoot
-endfunction
-
-" FUNCTION: TreeDirNode.getChildCount() {{{1
-" Returns the number of children this node has
-function! s:TreeDirNode.getChildCount()
-    return len(self.children)
-endfunction
-
-" FUNCTION: TreeDirNode.getChild(path) {{{1
-" Returns child node of this node that has the given path or {} if no such node
-" exists.
-"
-" This function doesnt not recurse into child dir nodes
-"
-" Args:
-" path: a path object
-function! s:TreeDirNode.getChild(path)
-    if stridx(a:path.str(), self.path.str(), 0) ==# -1
-        return {}
-    endif
-
-    let index = self.getChildIndex(a:path)
-    if index ==# -1
-        return {}
-    else
-        return self.children[index]
-    endif
-
-endfunction
-
-" FUNCTION: TreeDirNode.getChildByIndex(indx, visible) {{{1
-" returns the child at the given index
-"
-" Args:
-" indx: the index to get the child from
-" visible: 1 if only the visible children array should be used, 0 if all the
-" children should be searched.
-function! s:TreeDirNode.getChildByIndex(indx, visible)
-    let array_to_search = a:visible? self.getVisibleChildren() : self.children
-    if a:indx > len(array_to_search)
-        throw 'NERDTree.InvalidArgumentsError: Index is out of bounds.'
-    endif
-    return array_to_search[a:indx]
-endfunction
-
-" FUNCTION: TreeDirNode.getChildIndex(path) {{{1
-" Returns the index of the child node of this node that has the given path or
-" -1 if no such node exists.
-"
-" This function doesnt not recurse into child dir nodes
-"
-" Args:
-" path: a path object
-function! s:TreeDirNode.getChildIndex(path)
-    if stridx(a:path.str(), self.path.str(), 0) ==# -1
-        return -1
-    endif
-
-    "do a binary search for the child
-    let a = 0
-    let z = self.getChildCount()
-    while a < z
-        let mid = (a+z)/2
-        let diff = a:path.compareTo(self.children[mid].path)
-
-        if diff ==# -1
-            let z = mid
-        elseif diff ==# 1
-            let a = mid+1
-        else
-            return mid
-        endif
-    endwhile
-    return -1
-endfunction
-
-" FUNCTION: TreeDirNode.getDirChildren() {{{1
-" Return a list of all child nodes from 'self.children' that are of type
-" TreeDirNode. This function supports http://github.com/scrooloose/nerdtree-project-plugin.git.
-function! s:TreeDirNode.getDirChildren()
-    return filter(copy(self.children), 'v:val.path.isDirectory ==# 1')
-endfunction
-
-" FUNCTION: TreeDirNode._glob(pattern, all) {{{1
-" Return a list of strings naming the descendants of the directory in this
-" TreeDirNode object that match the specified glob pattern.
-"
-" Args:
-" pattern: (string) the glob pattern to apply
-" all: (0 or 1) if 1, include '.' and '..' if they match 'pattern'; if 0,
-"      always exclude them
-"
-" Note: If the pathnames in the result list are below the working directory,
-" they are returned as pathnames relative to that directory. This is because
-" this function, internally, attempts to obey 'wildignore' rules that use
-" relative paths.
-function! s:TreeDirNode._glob(pattern, all)
-
-    " Construct a path specification such that globpath() will return
-    " relative pathnames, if possible.
-    if self.path.str() ==# getcwd()
-        let l:pathSpec = ','
-    else
-        let l:pathSpec = escape(fnamemodify(self.path.str({'format': 'Glob'}), ':.'), ',')
-
-        " On Windows, the drive letter may be removed by fnamemodify().
-        if nerdtree#runningWindows() && l:pathSpec[0] ==# g:NERDTreePath.Slash()
-            let l:pathSpec = self.path.drive . l:pathSpec
-        endif
-    endif
-
-    let l:globList = []
-
-    " See ':h version7.txt' and ':h version8.txt' for details on the
-    " development of the glob() and globpath() functions.
-    if v:version > 704 || (v:version ==# 704 && has('patch654'))
-        let l:globList = globpath(l:pathSpec, a:pattern, !g:NERDTreeRespectWildIgnore, 1, 0)
-    elseif v:version ==# 704 && has('patch279')
-        let l:globList = globpath(l:pathSpec, a:pattern, !g:NERDTreeRespectWildIgnore, 1)
-    elseif v:version > 702 || (v:version ==# 702 && has('patch051'))
-        let l:globString = globpath(l:pathSpec, a:pattern, !g:NERDTreeRespectWildIgnore)
-        let l:globList = split(l:globString, "\n")
-    else
-        let l:globString = globpath(l:pathSpec, a:pattern)
-        let l:globList = split(l:globString, "\n")
-    endif
-
-    " If a:all is false, filter '.' and '..' from the output.
-    if !a:all
-        let l:toRemove = []
-
-        for l:file in l:globList
-            let l:tail = fnamemodify(l:file, ':t')
-
-            " If l:file has a trailing slash, then its :tail will be ''. Use
-            " :h to drop the slash and the empty string after it; then use :t
-            " to get the directory name.
-            if l:tail ==# ''
-                let l:tail = fnamemodify(l:file, ':h:t')
-            endif
-
-            if l:tail ==# '.' || l:tail ==# '..'
-                call add(l:toRemove, l:file)
-                if len(l:toRemove) ==# 2
-                    break
-                endif
-            endif
-        endfor
-
-        for l:file in l:toRemove
-            call remove(l:globList, index(l:globList, l:file))
-        endfor
-    endif
-
-    return l:globList
-endfunction
-
-" FUNCTION: TreeDirNode.GetSelected() {{{1
-" Returns the current node if it is a dir node, or else returns the current
-" nodes parent
-unlet s:TreeDirNode.GetSelected
-function! s:TreeDirNode.GetSelected()
-    let currentDir = g:NERDTreeFileNode.GetSelected()
-    if currentDir !=# {} && !currentDir.isRoot()
-        if currentDir.path.isDirectory ==# 0
-            let currentDir = currentDir.parent
-        endif
-    endif
-    return currentDir
-endfunction
-
-" FUNCTION: TreeDirNode.getVisibleChildCount() {{{1
-" Returns the number of visible children this node has
-function! s:TreeDirNode.getVisibleChildCount()
-    return len(self.getVisibleChildren())
-endfunction
-
-" FUNCTION: TreeDirNode.getVisibleChildren() {{{1
-" Returns a list of children to display for this node, in the correct order
-"
-" Return:
-" an array of treenodes
-function! s:TreeDirNode.getVisibleChildren()
-    let toReturn = []
-    for i in self.children
-        if i.path.ignore(self.getNerdtree()) ==# 0
-            call add(toReturn, i)
-        endif
-    endfor
-    return toReturn
-endfunction
-
-" FUNCTION: TreeDirNode.hasVisibleChildren() {{{1
-" returns 1 if this node has any childre, 0 otherwise..
-function! s:TreeDirNode.hasVisibleChildren()
-    return self.getVisibleChildCount() !=# 0
-endfunction
-
-" FUNCTION: TreeDirNode.isCascadable() {{{1
-" true if this dir has only one visible child that is also a dir
-" false if this dir is bookmarked or symlinked. Why? Two reasons:
-"  1. If cascaded, we don't know which dir is bookmarked or is a symlink.
-"  2. If the parent is a symlink or is bookmarked, you end up with unparsable
-"     text, and NERDTree cannot get the path of any child node.
-" Also, return false if this directory is the tree root, which should never be
-" part of a cascade.
-function! s:TreeDirNode.isCascadable()
-    if g:NERDTreeCascadeSingleChildDir ==# 0
-        return 0
-    endif
-
-    if self.isRoot()
-        return 0
-    endif
-
-    if self.path.isSymLink
-        return 0
-    endif
-
-    for i in g:NERDTreeBookmark.Bookmarks()
-        if i.path.equals(self.path)
-            return 0
-        endif
-    endfor
-
-    let c = self.getVisibleChildren()
-    return len(c) ==# 1 && c[0].path.isDirectory
-endfunction
-
-" FUNCTION: TreeDirNode._initChildren() {{{1
-" Removes all childen from this node and re-reads them
-"
-" Args:
-" silent: 1 if the function should not echo any 'please wait' messages for
-" large directories
-"
-" Return: the number of child nodes read
-function! s:TreeDirNode._initChildren(silent)
-    "remove all the current child nodes
-    let self.children = []
-
-    let files = self._glob('*', 1) + self._glob('.*', 0)
-
-    if !a:silent && len(files) > g:NERDTreeNotificationThreshold
-        call nerdtree#echo('Please wait, caching a large dir ...')
-    endif
-
-    let invalidFilesFound = 0
-    for i in files
-        try
-            let path = g:NERDTreePath.New(i)
-            call self.createChild(path, 0)
-            call g:NERDTreePathNotifier.NotifyListeners('init', path, self.getNerdtree(), {})
-        catch /^NERDTree.\(InvalidArguments\|InvalidFiletype\)Error/
-            let invalidFilesFound += 1
-        endtry
-    endfor
-
-    let g:NERDTreeOldSortOrder = g:NERDTreeSortOrder
-    call self.sortChildren()
-
-    call nerdtree#echo('')
-
-    if invalidFilesFound
-        call nerdtree#echoWarning(invalidFilesFound . ' file(s) could not be loaded into the NERD tree')
-    endif
-    return self.getChildCount()
-endfunction
-
-" FUNCTION: TreeDirNode.New(path, nerdtree) {{{1
-" Return a new TreeDirNode object with the given path and parent.
-"
-" Args:
-" path: dir that the node represents
-" nerdtree: the tree the node belongs to
-function! s:TreeDirNode.New(path, nerdtree)
-    if a:path.isDirectory !=# 1
-        throw 'NERDTree.InvalidArgumentsError: A TreeDirNode object must be instantiated with a directory Path object.'
-    endif
-
-    let newTreeNode = copy(self)
-    let newTreeNode.path = a:path
-
-    let newTreeNode.isOpen = 0
-    let newTreeNode.children = []
-
-    let newTreeNode.parent = {}
-    let newTreeNode._nerdtree = a:nerdtree
-
-    return newTreeNode
-endfunction
-
-" FUNCTION: TreeDirNode.open([options]) {{{1
-" Open this directory node in the current tree or elsewhere if special options
-" are provided. Return 0 if options were processed. Otherwise, return the
-" number of new cached nodes.
-function! s:TreeDirNode.open(...)
-    let l:options = a:0 ? a:1 : {}
-
-    " If special options were specified, process them and return.
-    if has_key(l:options, 'where') && !empty(l:options['where'])
-        let l:opener = g:NERDTreeOpener.New(self.path, l:options)
-        call l:opener.open(self)
-        return 0
-    endif
-
-    " Open any ancestors of this node that render within the same cascade.
-    let l:parent = self.parent
-    while !empty(l:parent) && !l:parent.isRoot()
-        if index(l:parent.getCascade(), self) >= 0
-            let l:parent.isOpen = 1
-            let l:parent = l:parent.parent
-        else
-            break
-        endif
-    endwhile
-
-    let self.isOpen = 1
-
-    let l:numChildrenCached = 0
-    if empty(self.children)
-        let l:numChildrenCached = self._initChildren(0)
-    endif
-
-    return l:numChildrenCached
-endfunction
-
-" FUNCTION: TreeDirNode.openAlong([opts]) {{{1
-" recursive open the dir if it has only one directory child.
-"
-" return the level of opened directories.
-function! s:TreeDirNode.openAlong(...)
-    let opts = a:0 ? a:1 : {}
-    let level = 0
-
-    let node = self
-    while node.path.isDirectory
-        call node.open(opts)
-        let level += 1
-        if node.getVisibleChildCount() ==# 1
-            let node = node.getChildByIndex(0, 1)
-        else
-            break
-        endif
-    endwhile
-    return level
-endfunction
-
-" FUNCTION: TreeDirNode.openExplorer() {{{1
-" Open an explorer window for this node in the previous window. The explorer
-" can be a NERDTree window or a netrw window.
-function! s:TreeDirNode.openExplorer()
-    execute 'wincmd p'
-    execute 'edit '.self.path.str({'format':'Edit'})
-endfunction
-
-" FUNCTION: TreeDirNode.openInNewTab(options) {{{1
-unlet s:TreeDirNode.openInNewTab
-function! s:TreeDirNode.openInNewTab(options)
-    call nerdtree#deprecated('TreeDirNode.openInNewTab', 'is deprecated, use open() instead')
-    call self.open({'where': 't'})
-endfunction
-
-" FUNCTION: TreeDirNode._openInNewTab() {{{1
-function! s:TreeDirNode._openInNewTab()
-    tabnew
-    call g:NERDTreeCreator.CreateTabTree(self.path.str())
-endfunction
-
-" FUNCTION: TreeDirNode.openRecursively() {{{1
-" Open this directory node and any descendant directory nodes whose pathnames
-" are not ignored.
-function! s:TreeDirNode.openRecursively()
-    silent call self.open()
-
-    for l:child in self.children
-        if l:child.path.isDirectory && !l:child.path.ignore(l:child.getNerdtree())
-            call l:child.openRecursively()
-        endif
-    endfor
-endfunction
-
-" FUNCTION: TreeDirNode.refresh() {{{1
-function! s:TreeDirNode.refresh()
-    call self.path.refresh(self.getNerdtree())
-
-    "if this node was ever opened, refresh its children
-    if self.isOpen || !empty(self.children)
-        let files = self._glob('*', 1) + self._glob('.*', 0)
-        let newChildNodes = []
-        let invalidFilesFound = 0
-        for i in files
-            try
-                "create a new path and see if it exists in this nodes children
-                let path = g:NERDTreePath.New(i)
-                let newNode = self.getChild(path)
-                if newNode !=# {}
-                    call newNode.refresh()
-                    call add(newChildNodes, newNode)
-
-                "the node doesnt exist so create it
-                else
-                    let newNode = g:NERDTreeFileNode.New(path, self.getNerdtree())
-                    let newNode.parent = self
-                    call add(newChildNodes, newNode)
-                endif
-            catch /^NERDTree.\(InvalidArguments\|InvalidFiletype\)Error/
-                let invalidFilesFound = 1
-            endtry
-        endfor
-
-        "swap this nodes children out for the children we just read/refreshed
-        let self.children = newChildNodes
-        call self.sortChildren()
-
-        if invalidFilesFound
-            call nerdtree#echoWarning('some files could not be loaded into the NERD tree')
-        endif
-    endif
-endfunction
-
-" FUNCTION: TreeDirNode.refreshFlags() {{{1
-unlet s:TreeDirNode.refreshFlags
-function! s:TreeDirNode.refreshFlags()
-    call self.path.refreshFlags(self.getNerdtree())
-    for i in self.children
-        call i.refreshFlags()
-    endfor
-endfunction
-
-" FUNCTION: TreeDirNode.refreshDirFlags() {{{1
-function! s:TreeDirNode.refreshDirFlags()
-    call self.path.refreshFlags(self.getNerdtree())
-endfunction
-
-" FUNCTION: TreeDirNode.reveal(path) {{{1
-" reveal the given path, i.e. cache and open all treenodes needed to display it
-" in the UI
-" Returns the revealed node
-function! s:TreeDirNode.reveal(path, ...)
-    let opts = a:0 ? a:1 : {}
-
-    if !a:path.isUnder(self.path)
-        throw 'NERDTree.InvalidArgumentsError: ' . a:path.str() . ' should be under ' . self.path.str()
-    endif
-
-    call self.open()
-
-    if self.path.equals(a:path.getParent())
-        let n = self.findNode(a:path)
-        " We may be looking for a newly-saved file that isn't in the tree yet.
-        if n ==# {}
-            call self.refresh()
-            let n = self.findNode(a:path)
-        endif
-        if has_key(opts, 'open')
-            call n.open()
-        endif
-        return n
-    endif
-
-    let p = a:path
-    while !p.getParent().equals(self.path)
-        let p = p.getParent()
-    endwhile
-
-    let n = self.findNode(p)
-    return n.reveal(a:path, opts)
-endfunction
-
-" FUNCTION: TreeDirNode.removeChild(treenode) {{{1
-" Remove the given treenode from self.children.
-" Throws NERDTree.ChildNotFoundError if the node is not found.
-"
-" Args:
-" treenode: the node object to remove
-function! s:TreeDirNode.removeChild(treenode)
-    for i in range(0, self.getChildCount()-1)
-        if self.children[i].equals(a:treenode)
-            call remove(self.children, i)
-            return
-        endif
-    endfor
-
-    throw 'NERDTree.ChildNotFoundError: child node was not found'
-endfunction
-
-" FUNCTION: TreeDirNode.sortChildren() {{{1
-" Sort self.children by alphabetical order and directory priority.
-function! s:TreeDirNode.sortChildren()
-    if count(g:NERDTreeSortOrder, '*') < 1
-        call add(g:NERDTreeSortOrder, '*')
-    endif
-    let CompareFunc = function('nerdtree#compareNodesBySortKey')
-    call sort(self.children, CompareFunc)
-    let g:NERDTreeOldSortOrder = g:NERDTreeSortOrder
-endfunction
-
-" FUNCTION: TreeDirNode.toggleOpen([options]) {{{1
-" Opens this directory if it is closed and vice versa
-function! s:TreeDirNode.toggleOpen(...)
-    let opts = a:0 ? a:1 : {}
-    if self.isOpen ==# 1
-        call self.close()
-    else
-        if g:NERDTreeCascadeOpenSingleChildDir ==# 0
-            call self.open(opts)
-        else
-            call self.openAlong(opts)
-        endif
-    endif
-endfunction
-
-" FUNCTION: TreeDirNode.transplantChild(newNode) {{{1
-" Replaces the child of this with the given node (where the child node's full
-" path matches a:newNode's fullpath). The search for the matching node is
-" non-recursive
-"
-" Arg:
-" newNode: the node to graft into the tree
-function! s:TreeDirNode.transplantChild(newNode)
-    for i in range(0, self.getChildCount()-1)
-        if self.children[i].equals(a:newNode)
-            let self.children[i] = a:newNode
-            let a:newNode.parent = self
-            break
-        endif
-    endfor
-endfunction
-
-" vim: set sw=4 sts=4 et fdm=marker:
diff --git a/sources_non_forked/nerdtree/lib/nerdtree/tree_file_node.vim b/sources_non_forked/nerdtree/lib/nerdtree/tree_file_node.vim
deleted file mode 100644
index 957b98a..0000000
--- a/sources_non_forked/nerdtree/lib/nerdtree/tree_file_node.vim
+++ /dev/null
@@ -1,349 +0,0 @@
-" ============================================================================
-" CLASS: TreeFileNode
-"
-" This class is the parent of the TreeDirNode class and is the 'Component'
-" part of the composite design pattern between the NERDTree node classes.
-" ============================================================================
-
-
-let s:TreeFileNode = {}
-let g:NERDTreeFileNode = s:TreeFileNode
-
-" FUNCTION: TreeFileNode.activate(...) {{{1
-function! s:TreeFileNode.activate(...)
-    call self.open(a:0 ? a:1 : {})
-endfunction
-
-" FUNCTION: TreeFileNode.bookmark(name) {{{1
-" bookmark this node with a:name
-function! s:TreeFileNode.bookmark(name)
-
-    " if a bookmark exists with the same name and the node is cached then save
-    " it so we can update its display string
-    let oldMarkedNode = {}
-    try
-        let oldMarkedNode = g:NERDTreeBookmark.GetNodeForName(a:name, 1, self.getNerdtree())
-    catch /^NERDTree.BookmarkNotFoundError/
-    catch /^NERDTree.BookmarkedNodeNotFoundError/
-    endtry
-
-    call g:NERDTreeBookmark.AddBookmark(a:name, self.path)
-    call self.path.cacheDisplayString()
-    call g:NERDTreeBookmark.Write()
-
-    if !empty(oldMarkedNode)
-        call oldMarkedNode.path.cacheDisplayString()
-    endif
-endfunction
-
-" FUNCTION: TreeFileNode.cacheParent() {{{1
-" initializes self.parent if it isnt already
-function! s:TreeFileNode.cacheParent()
-    if empty(self.parent)
-        let parentPath = self.path.getParent()
-        if parentPath.equals(self.path)
-            throw 'NERDTree.CannotCacheParentError: already at root'
-        endif
-        let self.parent = s:TreeFileNode.New(parentPath, self.getNerdtree())
-    endif
-endfunction
-
-" FUNCTION: TreeFileNode.clearBookmarks() {{{1
-function! s:TreeFileNode.clearBookmarks()
-    for i in g:NERDTreeBookmark.Bookmarks()
-        if i.path.equals(self.path)
-            call i.delete()
-        end
-    endfor
-    call self.path.cacheDisplayString()
-endfunction
-
-" FUNCTION: TreeFileNode.copy(dest) {{{1
-function! s:TreeFileNode.copy(dest)
-    call self.path.copy(a:dest)
-    let newPath = g:NERDTreePath.New(a:dest)
-    let parent = self.getNerdtree().root.findNode(newPath.getParent())
-    if !empty(parent)
-        call parent.refresh()
-        return parent.findNode(newPath)
-    else
-        return {}
-    endif
-endfunction
-
-" FUNCTION: TreeFileNode.delete {{{1
-" Removes this node from the tree and calls the Delete method for its path obj
-function! s:TreeFileNode.delete()
-    call self.path.delete()
-    call self.parent.removeChild(self)
-endfunction
-
-" FUNCTION: TreeFileNode.displayString() {{{1
-"
-" Returns a string that specifies how the node should be represented as a
-" string
-"
-" Return:
-" a string that can be used in the view to represent this node
-function! s:TreeFileNode.displayString()
-    return self.path.flagSet.renderToString() . self.path.displayString()
-endfunction
-
-" FUNCTION: TreeFileNode.equals(treenode) {{{1
-"
-" Compares this treenode to the input treenode and returns 1 if they are the
-" same node.
-"
-" Use this method instead of ==  because sometimes when the treenodes contain
-" many children, vim seg faults when doing ==
-"
-" Args:
-" treenode: the other treenode to compare to
-function! s:TreeFileNode.equals(treenode)
-    return self.path.str() ==# a:treenode.path.str()
-endfunction
-
-" FUNCTION: TreeFileNode.findNode(path) {{{1
-" Returns self if this node.path.Equals the given path.
-" Returns {} if not equal.
-"
-" Args:
-" path: the path object to compare against
-function! s:TreeFileNode.findNode(path)
-    if a:path.equals(self.path)
-        return self
-    endif
-    return {}
-endfunction
-
-" FUNCTION: TreeFileNode.findSibling(direction) {{{1
-" Find the next or previous sibling of this node.
-"
-" Args:
-" direction: 0 for previous, 1 for next
-"
-" Return:
-" The next/previous TreeFileNode object or an empty dictionary if not found.
-function! s:TreeFileNode.findSibling(direction)
-
-    " There can be no siblings if there is no parent.
-    if empty(self.parent)
-        return {}
-    endif
-
-    let l:nodeIndex = self.parent.getChildIndex(self.path)
-
-    if l:nodeIndex == -1
-        return {}
-    endif
-
-    " Get the next index to begin the search.
-    let l:nodeIndex += a:direction ? 1 : -1
-
-    while 0 <= l:nodeIndex && l:nodeIndex < self.parent.getChildCount()
-
-        " Return the next node if it is not ignored.
-        if !self.parent.children[l:nodeIndex].path.ignore(self.getNerdtree())
-            return self.parent.children[l:nodeIndex]
-        endif
-
-        let l:nodeIndex += a:direction ? 1 : -1
-    endwhile
-
-    return {}
-endfunction
-
-" FUNCTION: TreeFileNode.getNerdtree(){{{1
-function! s:TreeFileNode.getNerdtree()
-    return self._nerdtree
-endfunction
-
-" FUNCTION: TreeFileNode.GetRootForTab(){{{1
-" get the root node for this tab
-function! s:TreeFileNode.GetRootForTab()
-    if g:NERDTree.ExistsForTab()
-        return getbufvar(t:NERDTreeBufName, 'NERDTree').root
-    end
-    return {}
-endfunction
-
-" FUNCTION: TreeFileNode.GetSelected() {{{1
-" If the cursor is currently positioned on a tree node, return the node.
-" Otherwise, return the empty dictionary.
-function! s:TreeFileNode.GetSelected()
-
-    try
-        let l:path = b:NERDTree.ui.getPath(line('.'))
-
-        if empty(l:path)
-            return {}
-        endif
-
-        return b:NERDTree.root.findNode(l:path)
-    catch
-        return {}
-    endtry
-endfunction
-
-" FUNCTION: TreeFileNode.isVisible() {{{1
-" returns 1 if this node should be visible according to the tree filters and
-" hidden file filters (and their on/off status)
-function! s:TreeFileNode.isVisible()
-    return !self.path.ignore(self.getNerdtree())
-endfunction
-
-" FUNCTION: TreeFileNode.isRoot() {{{1
-function! s:TreeFileNode.isRoot()
-    if !g:NERDTree.ExistsForBuf()
-        throw 'NERDTree.NoTreeError: No tree exists for the current buffer'
-    endif
-
-    return self.equals(self.getNerdtree().root)
-endfunction
-
-" FUNCTION: TreeFileNode.New(path, nerdtree) {{{1
-" Returns a new TreeNode object with the given path and parent
-"
-" Args:
-" path: file/dir that the node represents
-" nerdtree: the tree the node belongs to
-function! s:TreeFileNode.New(path, nerdtree)
-    if a:path.isDirectory
-        return g:NERDTreeDirNode.New(a:path, a:nerdtree)
-    else
-        let newTreeNode = copy(self)
-        let newTreeNode.path = a:path
-        let newTreeNode.parent = {}
-        let newTreeNode._nerdtree = a:nerdtree
-        return newTreeNode
-    endif
-endfunction
-
-" FUNCTION: TreeFileNode.open() {{{1
-function! s:TreeFileNode.open(...)
-    let opts = a:0 ? a:1 : {}
-    let opener = g:NERDTreeOpener.New(self.path, opts)
-    call opener.open(self)
-endfunction
-
-" FUNCTION: TreeFileNode.openSplit() {{{1
-" Open this node in a new window
-function! s:TreeFileNode.openSplit()
-    call nerdtree#deprecated('TreeFileNode.openSplit', 'is deprecated, use .open() instead.')
-    call self.open({'where': 'h'})
-endfunction
-
-" FUNCTION: TreeFileNode.openVSplit() {{{1
-" Open this node in a new vertical window
-function! s:TreeFileNode.openVSplit()
-    call nerdtree#deprecated('TreeFileNode.openVSplit', 'is deprecated, use .open() instead.')
-    call self.open({'where': 'v'})
-endfunction
-
-" FUNCTION: TreeFileNode.openInNewTab(options) {{{1
-function! s:TreeFileNode.openInNewTab(options)
-    call nerdtree#deprecated('TreeFileNode.openinNewTab', 'is deprecated, use .open() instead.')
-    call self.open(extend({'where': 't'}, a:options))
-endfunction
-
-" FUNCTION: TreeFileNode.openExplorer()
-function! s:TreeFileNode.openExplorer()
-    execute 'wincmd p'
-    execute 'edit '.self.path.getParent().str({'format':'Edit'})
-endfunction
-
-" FUNCTION: TreeFileNode.putCursorHere(isJump, recurseUpward){{{1
-" Places the cursor on the line number this node is rendered on
-"
-" Args:
-" isJump: 1 if this cursor movement should be counted as a jump by vim
-" recurseUpward: try to put the cursor on the parent if the this node isnt
-" visible
-function! s:TreeFileNode.putCursorHere(isJump, recurseUpward)
-    let ln = self.getNerdtree().ui.getLineNum(self)
-    if ln != -1
-        if a:isJump
-            mark '
-        endif
-        call cursor(ln, col('.'))
-    else
-        if a:recurseUpward
-            let node = self
-            while node != {} && self.getNerdtree().ui.getLineNum(node) ==# -1
-                let node = node.parent
-                call node.open()
-            endwhile
-            call self._nerdtree.render()
-            call node.putCursorHere(a:isJump, 0)
-        endif
-    endif
-endfunction
-
-" FUNCTION: TreeFileNode.refresh() {{{1
-function! s:TreeFileNode.refresh()
-    call self.path.refresh(self.getNerdtree())
-endfunction
-
-" FUNCTION: TreeFileNode.refreshFlags() {{{1
-function! s:TreeFileNode.refreshFlags()
-    call self.path.refreshFlags(self.getNerdtree())
-endfunction
-
-" FUNCTION: TreeFileNode.rename() {{{1
-" Calls the rename method for this nodes path obj
-function! s:TreeFileNode.rename(newName)
-    let newName = substitute(a:newName, '\(\\\|\/\)$', '', '')
-    call self.path.rename(newName)
-    call self.parent.removeChild(self)
-
-    let parentPath = self.path.getParent()
-    let newParent = self.getNerdtree().root.findNode(parentPath)
-
-    if newParent != {}
-        call newParent.createChild(self.path, 1)
-        call newParent.refresh()
-    endif
-endfunction
-
-" FUNCTION: TreeFileNode.renderToString {{{1
-" returns a string representation for this tree to be rendered in the view
-function! s:TreeFileNode.renderToString()
-    return self._renderToString(0, 0)
-endfunction
-
-" Args:
-" depth: the current depth in the tree for this call
-" drawText: 1 if we should actually draw the line for this node (if 0 then the
-" child nodes are rendered only)
-" for each depth in the tree
-function! s:TreeFileNode._renderToString(depth, drawText)
-    let output = ''
-    if a:drawText ==# 1
-
-        let treeParts = repeat('  ', a:depth - 1)
-        let treeParts .= (self.path.isDirectory || g:NERDTreeDirArrowExpandable ==# '' ? '' : '  ')
-
-        let line = treeParts . self.displayString()
-        let output = output . line . "\n"
-    endif
-
-    " if the node is an open dir, draw its children
-    if self.path.isDirectory ==# 1 && self.isOpen ==# 1
-
-        let childNodesToDraw = self.getVisibleChildren()
-
-        if self.isCascadable() && a:depth > 0
-
-            let output = output . childNodesToDraw[0]._renderToString(a:depth, 0)
-
-        elseif len(childNodesToDraw) > 0
-            for i in childNodesToDraw
-                let output = output . i._renderToString(a:depth + 1, 1)
-            endfor
-        endif
-    endif
-
-    return output
-endfunction
-
-" vim: set sw=4 sts=4 et fdm=marker:
diff --git a/sources_non_forked/nerdtree/lib/nerdtree/ui.vim b/sources_non_forked/nerdtree/lib/nerdtree/ui.vim
deleted file mode 100644
index 9ffadf6..0000000
--- a/sources_non_forked/nerdtree/lib/nerdtree/ui.vim
+++ /dev/null
@@ -1,529 +0,0 @@
-" ============================================================================
-" CLASS: UI
-" ============================================================================
-
-
-let s:UI = {}
-let g:NERDTreeUI = s:UI
-
-" FUNCTION: s:UI.centerView() {{{1
-" centers the nerd tree window around the cursor (provided the nerd tree
-" options permit)
-function! s:UI.centerView()
-    if g:NERDTreeAutoCenter
-        let current_line = winline()
-        let lines_to_top = current_line
-        let lines_to_bottom = winheight(g:NERDTree.GetWinNum()) - current_line
-        if lines_to_top < g:NERDTreeAutoCenterThreshold || lines_to_bottom < g:NERDTreeAutoCenterThreshold
-            normal! zz
-        endif
-    endif
-endfunction
-
-" FUNCTION: s:UI._dumpHelp  {{{1
-" prints out the quick help
-function! s:UI._dumpHelp()
-    if self.getShowHelp()
-        let help  = "\" NERDTree (" . nerdtree#version() . ") quickhelp~\n"
-        let help .= "\" ============================\n"
-        let help .= "\" File node mappings~\n"
-        let help .= '" '. (g:NERDTreeMouseMode ==# 3 ? 'single' : 'double') ."-click,\n"
-        if self.nerdtree.isTabTree()
-            let help .= '" '. g:NERDTreeMapActivateNode .": open in prev window\n"
-        else
-            let help .= '" '. g:NERDTreeMapActivateNode .": open in current window\n"
-        endif
-        if self.nerdtree.isTabTree()
-            let help .= '" '. g:NERDTreeMapPreview .": preview\n"
-        endif
-        let help .= '" '. g:NERDTreeMapOpenInTab.": open in new tab\n"
-        let help .= '" '. g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
-        let help .= "\" middle-click,\n"
-        let help .= '" '. g:NERDTreeMapOpenSplit .": open split\n"
-        let help .= '" '. g:NERDTreeMapPreviewSplit .": preview split\n"
-        let help .= '" '. g:NERDTreeMapOpenVSplit .": open vsplit\n"
-        let help .= '" '. g:NERDTreeMapPreviewVSplit .": preview vsplit\n"
-        let help .= '" '. g:NERDTreeMapCustomOpen .": custom open\n"
-
-        let help .= "\"\n\" ----------------------------\n"
-        let help .= "\" Directory node mappings~\n"
-        let help .= '" '. (g:NERDTreeMouseMode ==# 1 ? 'double' : 'single') ."-click,\n"
-        let help .= '" '. g:NERDTreeMapActivateNode .": open & close node\n"
-        let help .= '" '. g:NERDTreeMapOpenRecursively .": recursively open node\n"
-        let help .= '" '. g:NERDTreeMapOpenInTab.": open in new tab\n"
-        let help .= '" '. g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
-        let help .= '" '. g:NERDTreeMapCustomOpen .": custom open\n"
-        let help .= '" '. g:NERDTreeMapCloseDir .": close parent of node\n"
-        let help .= '" '. g:NERDTreeMapCloseChildren .": close all child nodes of\n"
-        let help .= "\"    current node recursively\n"
-        let help .= "\" middle-click,\n"
-        let help .= '" '. g:NERDTreeMapOpenExpl.": explore selected dir\n"
-
-        let help .= "\"\n\" ----------------------------\n"
-        let help .= "\" Bookmark table mappings~\n"
-        let help .= "\" double-click,\n"
-        let help .= '" '. g:NERDTreeMapActivateNode .": open bookmark\n"
-        let help .= '" '. g:NERDTreeMapPreview .": preview file\n"
-        let help .= '" '. g:NERDTreeMapPreview .": find dir in tree\n"
-        let help .= '" '. g:NERDTreeMapOpenInTab.": open in new tab\n"
-        let help .= '" '. g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
-        let help .= '" '. g:NERDTreeMapCustomOpen .": custom open\n"
-        let help .= '" '. g:NERDTreeMapDeleteBookmark .": delete bookmark\n"
-
-        let help .= "\"\n\" ----------------------------\n"
-        let help .= "\" Tree navigation mappings~\n"
-        let help .= '" '. g:NERDTreeMapJumpRoot .": go to root\n"
-        let help .= '" '. g:NERDTreeMapJumpParent .": go to parent\n"
-        let help .= '" '. g:NERDTreeMapJumpFirstChild  .": go to first child\n"
-        let help .= '" '. g:NERDTreeMapJumpLastChild   .": go to last child\n"
-        let help .= '" '. g:NERDTreeMapJumpNextSibling .": go to next sibling\n"
-        let help .= '" '. g:NERDTreeMapJumpPrevSibling .": go to prev sibling\n"
-
-        let help .= "\"\n\" ----------------------------\n"
-        let help .= "\" Filesystem mappings~\n"
-        let help .= '" '. g:NERDTreeMapChangeRoot .": change tree root to the\n"
-        let help .= "\"    selected dir\n"
-        let help .= '" '. g:NERDTreeMapUpdir .": move tree root up a dir\n"
-        let help .= '" '. g:NERDTreeMapUpdirKeepOpen .": move tree root up a dir\n"
-        let help .= "\"    but leave old root open\n"
-        let help .= '" '. g:NERDTreeMapRefresh .": refresh cursor dir\n"
-        let help .= '" '. g:NERDTreeMapRefreshRoot .": refresh current root\n"
-        let help .= '" '. g:NERDTreeMapMenu .": Show menu\n"
-        let help .= '" '. g:NERDTreeMapChdir .":change the CWD to the\n"
-        let help .= "\"    selected dir\n"
-        let help .= '" '. g:NERDTreeMapCWD .":change tree root to CWD\n"
-
-        let help .= "\"\n\" ----------------------------\n"
-        let help .= "\" Tree filtering mappings~\n"
-        let help .= '" '. g:NERDTreeMapToggleHidden .': hidden files (' . (self.getShowHidden() ? 'on' : 'off') . ")\n"
-        let help .= '" '. g:NERDTreeMapToggleFilters .': file filters (' . (self.isIgnoreFilterEnabled() ? 'on' : 'off') . ")\n"
-        let help .= '" '. g:NERDTreeMapToggleFiles .': files (' . (self.getShowFiles() ? 'on' : 'off') . ")\n"
-        let help .= '" '. g:NERDTreeMapToggleBookmarks .': bookmarks (' . (self.getShowBookmarks() ? 'on' : 'off') . ")\n"
-
-        " add quickhelp entries for each custom key map
-        let help .= "\"\n\" ----------------------------\n"
-        let help .= "\" Custom mappings~\n"
-        for i in g:NERDTreeKeyMap.All()
-            if !empty(i.quickhelpText)
-                let help .= '" '. i.key .': '. i.quickhelpText ."\n"
-            endif
-        endfor
-
-        let help .= "\"\n\" ----------------------------\n"
-        let help .= "\" Other mappings~\n"
-        let help .= '" '. g:NERDTreeMapQuit .": Close the NERDTree window\n"
-        let help .= '" '. g:NERDTreeMapToggleZoom .": Zoom (maximize-minimize)\n"
-        let help .= "\"    the NERDTree window\n"
-        let help .= '" '. g:NERDTreeMapHelp .": toggle help\n"
-        let help .= "\"\n\" ----------------------------\n"
-        let help .= "\" Bookmark commands~\n"
-        let help .= "\" :Bookmark [<name>]\n"
-        let help .= "\" :BookmarkToRoot <name>\n"
-        let help .= "\" :RevealBookmark <name>\n"
-        let help .= "\" :OpenBookmark <name>\n"
-        let help .= "\" :ClearBookmarks [<names>]\n"
-        let help .= "\" :ClearAllBookmarks\n"
-        let help .= "\" :ReadBookmarks\n"
-        let help .= "\" :WriteBookmarks\n"
-        let help .= "\" :EditBookmarks\n"
-        silent! put =help
-    elseif !self.isMinimal()
-        let help ='" Press '. g:NERDTreeMapHelp ." for help\n"
-        silent! put =help
-    endif
-endfunction
-
-
-" FUNCTION: s:UI.new(nerdtree) {{{1
-function! s:UI.New(nerdtree)
-    let newObj = copy(self)
-    let newObj.nerdtree = a:nerdtree
-    let newObj._showHelp = 0
-    let newObj._ignoreEnabled = 1
-    let newObj._showFiles = g:NERDTreeShowFiles
-    let newObj._showHidden = g:NERDTreeShowHidden
-    let newObj._showBookmarks = g:NERDTreeShowBookmarks
-
-    return newObj
-endfunction
-
-" FUNCTION: s:UI.getPath(ln) {{{1
-" Return the Path object for the node that is rendered on the given line
-" number.  If the 'up a dir' line is selected, return the Path object for
-" the parent of the root.  Return the empty dictionary if the given line
-" does not reference a tree node.
-function! s:UI.getPath(ln)
-    let line = getline(a:ln)
-
-    let rootLine = self.getRootLineNum()
-
-    if a:ln ==# rootLine
-        return self.nerdtree.root.path
-    endif
-
-    if line ==# s:UI.UpDirLine()
-        return self.nerdtree.root.path.getParent()
-    endif
-
-    if a:ln < rootLine
-        return {}
-    endif
-
-    let indent = self._indentLevelFor(line)
-
-    " remove the tree parts and the leading space
-    let curFile = self._stripMarkup(line)
-
-    let dir = ''
-    let lnum = a:ln
-    while lnum > 0
-        let lnum = lnum - 1
-        let curLine = getline(lnum)
-        let curLineStripped = self._stripMarkup(curLine)
-
-        " have we reached the top of the tree?
-        if lnum ==# rootLine
-            let dir = self.nerdtree.root.path.str({'format': 'UI'}) . dir
-            break
-        endif
-        if curLineStripped =~# '/$'
-            let lpindent = self._indentLevelFor(curLine)
-            if lpindent < indent
-                let indent = indent - 1
-
-                let dir = substitute (curLineStripped,'^\\', '', '') . dir
-                continue
-            endif
-        endif
-    endwhile
-    let curFile = self.nerdtree.root.path.drive . dir . curFile
-    let toReturn = g:NERDTreePath.New(curFile)
-    return toReturn
-endfunction
-
-" FUNCTION: s:UI.getLineNum(node) {{{1
-" Return the line number where the given node is rendered.  Return -1 if the
-" given node is not visible.
-function! s:UI.getLineNum(node)
-
-    if a:node.isRoot()
-        return self.getRootLineNum()
-    endif
-
-    let l:pathComponents = [substitute(self.nerdtree.root.path.str({'format': 'UI'}), '/\s*$', '', '')]
-    let l:currentPathComponent = 1
-
-    let l:fullPath = a:node.path.str({'format': 'UI'})
-
-    for l:lineNumber in range(self.getRootLineNum() + 1, line('$'))
-        let l:currentLine = getline(l:lineNumber)
-        let l:indentLevel = self._indentLevelFor(l:currentLine)
-
-        if l:indentLevel !=# l:currentPathComponent
-            continue
-        endif
-
-        let l:currentLine = self._stripMarkup(l:currentLine)
-        let l:currentPath =  join(l:pathComponents, '/') . '/' . l:currentLine
-
-        " Directories: If the current path 'starts with' the full path, then
-        " either the paths are equal or the line is a cascade containing the
-        " full path.
-        if l:fullPath[-1:] ==# '/' && stridx(l:currentPath, l:fullPath) ==# 0
-            return l:lineNumber
-        endif
-
-        " Files: The paths must exactly match.
-        if l:fullPath ==# l:currentPath
-            return l:lineNumber
-        endif
-
-        " Otherwise: If the full path starts with the current path and the
-        " current path is a directory, we add a new path component.
-        if stridx(l:fullPath, l:currentPath) ==# 0 && l:currentPath[-1:] ==# '/'
-            let l:currentLine = substitute(l:currentLine, '/\s*$', '', '')
-            call add(l:pathComponents, l:currentLine)
-            let l:currentPathComponent += 1
-        endif
-    endfor
-
-    return -1
-endfunction
-
-" FUNCTION: s:UI.getRootLineNum(){{{1
-" gets the line number of the root node
-function! s:UI.getRootLineNum()
-    let rootLine = 1
-    while rootLine <= line('$') && getline(rootLine) !~# '^\(/\|<\)'
-        let rootLine = rootLine + 1
-    endwhile
-    return rootLine
-endfunction
-
-" FUNCTION: s:UI.getShowBookmarks() {{{1
-function! s:UI.getShowBookmarks()
-    return self._showBookmarks
-endfunction
-
-" FUNCTION: s:UI.getShowFiles() {{{1
-function! s:UI.getShowFiles()
-    return self._showFiles
-endfunction
-
-" FUNCTION: s:UI.getShowHelp() {{{1
-function! s:UI.getShowHelp()
-    return self._showHelp
-endfunction
-
-" FUNCTION: s:UI.getShowHidden() {{{1
-function! s:UI.getShowHidden()
-    return self._showHidden
-endfunction
-
-" FUNCTION: s:UI._indentLevelFor(line) {{{1
-function! s:UI._indentLevelFor(line)
-    " Replace multi-character DirArrows with a single space so the
-    " indentation calculation doesn't get messed up.
-    if g:NERDTreeDirArrowExpandable ==# ''
-        let l:line = '  '.a:line
-    else
-        let l:line = substitute(substitute(a:line, '\V'.g:NERDTreeDirArrowExpandable, ' ', ''), '\V'.g:NERDTreeDirArrowCollapsible, ' ', '')
-    endif
-    let leadChars = match(l:line, '\M\[^ ]')
-    return leadChars / s:UI.IndentWid()
-endfunction
-
-" FUNCTION: s:UI.IndentWid() {{{1
-function! s:UI.IndentWid()
-    return 2
-endfunction
-
-" FUNCTION: s:UI.isIgnoreFilterEnabled() {{{1
-function! s:UI.isIgnoreFilterEnabled()
-    return self._ignoreEnabled ==# 1
-endfunction
-
-" FUNCTION: s:UI.isMinimal() {{{1
-function! s:UI.isMinimal()
-    return g:NERDTreeMinimalUI
-endfunction
-
-" FUNCTION: s:UI.MarkupReg() {{{1
-function! s:UI.MarkupReg()
-    return '^ *['.g:NERDTreeDirArrowExpandable.g:NERDTreeDirArrowCollapsible.']\? '
-endfunction
-
-" FUNCTION: s:UI._renderBookmarks {{{1
-function! s:UI._renderBookmarks()
-
-    if !self.isMinimal()
-        call setline(line('.')+1, '>----------Bookmarks----------')
-        call cursor(line('.')+1, col('.'))
-    endif
-
-    if g:NERDTreeBookmarksSort ==# 1 || g:NERDTreeBookmarksSort ==# 2
-        call g:NERDTreeBookmark.SortBookmarksList()
-    endif
-
-    for i in g:NERDTreeBookmark.Bookmarks()
-        call setline(line('.')+1, i.str())
-        call cursor(line('.')+1, col('.'))
-    endfor
-
-    call setline(line('.')+1, '')
-    call cursor(line('.')+1, col('.'))
-endfunction
-
-" FUNCTION: s:UI.restoreScreenState() {{{1
-"
-" Sets the screen state back to what it was when nerdtree#saveScreenState was last
-" called.
-"
-" Assumes the cursor is in the NERDTree window
-function! s:UI.restoreScreenState()
-    if !has_key(self, '_screenState')
-        return
-    endif
-    call nerdtree#exec('silent vertical resize ' . self._screenState['oldWindowSize'], 1)
-
-    let old_scrolloff=&scrolloff
-    let &scrolloff=0
-    call cursor(self._screenState['oldTopLine'], 0)
-    normal! zt
-    call setpos('.', self._screenState['oldPos'])
-    let &scrolloff=old_scrolloff
-endfunction
-
-" FUNCTION: s:UI.saveScreenState() {{{1
-" Saves the current cursor position in the current buffer and the window
-" scroll position
-function! s:UI.saveScreenState()
-    let win = winnr()
-    let self._screenState = {}
-    try
-        call g:NERDTree.CursorToTreeWin()
-        let self._screenState['oldPos'] = getpos('.')
-        let self._screenState['oldTopLine'] = line('w0')
-        let self._screenState['oldWindowSize']= winwidth('')
-        call nerdtree#exec(win . 'wincmd w', 1)
-    catch
-    endtry
-endfunction
-
-" FUNCTION: s:UI.setShowHidden(val) {{{1
-function! s:UI.setShowHidden(val)
-    let self._showHidden = a:val
-endfunction
-
-" FUNCTION: s:UI._stripMarkup(line){{{1
-" find the filename in the given line, and return it.
-"
-" Args:
-" line: the subject line
-function! s:UI._stripMarkup(line)
-    let l:line = substitute(a:line, '^.\{-}' . g:NERDTreeNodeDelimiter, '', '')
-    return substitute(l:line, g:NERDTreeNodeDelimiter.'.*$', '', '')
-endfunction
-
-" FUNCTION: s:UI.render() {{{1
-function! s:UI.render()
-    setlocal noreadonly modifiable
-
-    " remember the top line of the buffer and the current line so we can
-    " restore the view exactly how it was
-    let curLine = line('.')
-    let curCol = col('.')
-    let topLine = line('w0')
-
-    " delete all lines in the buffer (being careful not to clobber a register)
-    silent 1,$delete _
-
-    call self._dumpHelp()
-
-    " delete the blank line before the help and add one after it
-    if !self.isMinimal()
-        call setline(line('.')+1, '')
-        call cursor(line('.')+1, col('.'))
-    endif
-
-    if self.getShowBookmarks()
-        call self._renderBookmarks()
-    endif
-
-    " add the 'up a dir' line
-    if !self.isMinimal()
-        call setline(line('.')+1, s:UI.UpDirLine())
-        call cursor(line('.')+1, col('.'))
-    endif
-
-    " draw the header line
-    let header = self.nerdtree.root.path.str({'format': 'UI', 'truncateTo': winwidth(0)})
-    call setline(line('.')+1, header)
-    call cursor(line('.')+1, col('.'))
-
-    " draw the tree
-    silent put =self.nerdtree.root.renderToString()
-
-    " delete the blank line at the top of the buffer
-    silent 1,1delete _
-
-    " restore the view
-    let old_scrolloff=&scrolloff
-    let &scrolloff=0
-    call cursor(topLine, 1)
-    normal! zt
-    call cursor(curLine, curCol)
-    let &scrolloff = old_scrolloff
-
-    setlocal readonly nomodifiable
-endfunction
-
-
-" FUNCTION: UI.renderViewSavingPosition {{{1
-" Renders the tree and ensures the cursor stays on the current node or the
-" current nodes parent if it is no longer available upon re-rendering
-function! s:UI.renderViewSavingPosition()
-    let currentNode = g:NERDTreeFileNode.GetSelected()
-
-    " go up the tree till we find a node that will be visible or till we run
-    " out of nodes
-    while currentNode !=# {} && !currentNode.isVisible() && !currentNode.isRoot()
-        let currentNode = currentNode.parent
-    endwhile
-
-    call self.render()
-
-    if currentNode !=# {}
-        call currentNode.putCursorHere(0, 0)
-    endif
-endfunction
-
-" FUNCTION: s:UI.toggleHelp() {{{1
-function! s:UI.toggleHelp()
-    let self._showHelp = !self._showHelp
-endfunction
-
-" FUNCTION: s:UI.toggleIgnoreFilter() {{{1
-" toggles the use of the NERDTreeIgnore option
-function! s:UI.toggleIgnoreFilter()
-    let self._ignoreEnabled = !self._ignoreEnabled
-    call self.renderViewSavingPosition()
-    call self.centerView()
-endfunction
-
-" FUNCTION: s:UI.toggleShowBookmarks() {{{1
-" Toggle the visibility of the Bookmark table.
-function! s:UI.toggleShowBookmarks()
-    let self._showBookmarks = !self._showBookmarks
-
-    if self.getShowBookmarks()
-        call self.nerdtree.render()
-        call g:NERDTree.CursorToBookmarkTable()
-    else
-
-        if empty(g:NERDTreeFileNode.GetSelected())
-            call b:NERDTree.root.putCursorHere(0, 0)
-            normal! 0
-        endif
-
-        call self.renderViewSavingPosition()
-    endif
-
-    call self.centerView()
-endfunction
-
-" FUNCTION: s:UI.toggleShowFiles() {{{1
-" toggles the display of hidden files
-function! s:UI.toggleShowFiles()
-    let self._showFiles = !self._showFiles
-    call self.renderViewSavingPosition()
-    call self.centerView()
-endfunction
-
-" FUNCTION: s:UI.toggleShowHidden() {{{1
-" toggles the display of hidden files
-function! s:UI.toggleShowHidden()
-    let self._showHidden = !self._showHidden
-    call self.renderViewSavingPosition()
-    call self.centerView()
-endfunction
-
-" FUNCTION: s:UI.toggleZoom() {{{1
-" zoom (maximize/minimize) the NERDTree window
-function! s:UI.toggleZoom()
-    if exists('b:NERDTreeZoomed') && b:NERDTreeZoomed
-        let size = exists('b:NERDTreeOldWindowSize') ? b:NERDTreeOldWindowSize : g:NERDTreeWinSize
-        call nerdtree#exec('silent vertical resize '. size, 1)
-        let b:NERDTreeZoomed = 0
-    else
-        call nerdtree#exec('vertical resize '. get(g:, 'NERDTreeWinSizeMax', ''), 1)
-        let b:NERDTreeZoomed = 1
-    endif
-endfunction
-
-" FUNCTION: s:UI.UpDirLine() {{{1
-function! s:UI.UpDirLine()
-    return '.. (up a dir)'
-endfunction
-
-" vim: set sw=4 sts=4 et fdm=marker:
diff --git a/sources_non_forked/nerdtree/nerdtree_plugin/exec_menuitem.vim b/sources_non_forked/nerdtree/nerdtree_plugin/exec_menuitem.vim
deleted file mode 100644
index fb6c486..0000000
--- a/sources_non_forked/nerdtree/nerdtree_plugin/exec_menuitem.vim
+++ /dev/null
@@ -1,40 +0,0 @@
-" ============================================================================
-" File:        exec_menuitem.vim
-" Description: plugin for NERD Tree that provides an execute file menu item
-" Maintainer:  Martin Grenfell <martin.grenfell at gmail dot com>
-" License:     This program is free software. It comes without any warranty,
-"              to the extent permitted by applicable law. You can redistribute
-"              it and/or modify it under the terms of the Do What The Fuck You
-"              Want To Public License, Version 2, as published by Sam Hocevar.
-"              See http://sam.zoy.org/wtfpl/COPYING for more details.
-"
-" ============================================================================
-if exists('g:loaded_nerdtree_exec_menuitem')
-    finish
-endif
-let g:loaded_nerdtree_exec_menuitem = 1
-
-call NERDTreeAddMenuItem({
-            \ 'text': '(!)Execute file',
-            \ 'shortcut': '!',
-            \ 'callback': 'NERDTreeExecFile',
-            \ 'isActiveCallback': 'NERDTreeExecFileActive' })
-
-function! NERDTreeExecFileActive()
-    let node = g:NERDTreeFileNode.GetSelected()
-    return !node.path.isDirectory && node.path.isExecutable
-endfunction
-
-function! NERDTreeExecFile()
-    let treenode = g:NERDTreeFileNode.GetSelected()
-    echo "==========================================================\n"
-    echo "Complete the command to execute (add arguments etc):\n"
-    let cmd = treenode.path.str({'escape': 1})
-    let cmd = input(':!', cmd . ' ')
-
-    if cmd !=# ''
-        exec ':!' . cmd
-    else
-        echo 'Aborted'
-    endif
-endfunction
diff --git a/sources_non_forked/nerdtree/nerdtree_plugin/fs_menu.vim b/sources_non_forked/nerdtree/nerdtree_plugin/fs_menu.vim
deleted file mode 100644
index 3073414..0000000
--- a/sources_non_forked/nerdtree/nerdtree_plugin/fs_menu.vim
+++ /dev/null
@@ -1,469 +0,0 @@
-" ============================================================================
-" File:        fs_menu.vim
-" Description: plugin for the NERD Tree that provides a file system menu
-" Maintainer:  Martin Grenfell <martin.grenfell at gmail dot com>
-" License:     This program is free software. It comes without any warranty,
-"              to the extent permitted by applicable law. You can redistribute
-"              it and/or modify it under the terms of the Do What The Fuck You
-"              Want To Public License, Version 2, as published by Sam Hocevar.
-"              See http://sam.zoy.org/wtfpl/COPYING for more details.
-"
-" ============================================================================
-if exists('g:loaded_nerdtree_fs_menu')
-    finish
-endif
-let g:loaded_nerdtree_fs_menu = 1
-
-"Automatically delete the buffer after deleting or renaming a file
-if !exists('g:NERDTreeAutoDeleteBuffer')
-    let g:NERDTreeAutoDeleteBuffer = 0
-endif
-
-call NERDTreeAddMenuItem({'text': '(a)dd a childnode', 'shortcut': 'a', 'callback': 'NERDTreeAddNode'})
-call NERDTreeAddMenuItem({'text': '(m)ove the current node', 'shortcut': 'm', 'callback': 'NERDTreeMoveNode'})
-call NERDTreeAddMenuItem({'text': '(d)elete the current node', 'shortcut': 'd', 'callback': 'NERDTreeDeleteNode'})
-
-if has('gui_mac') || has('gui_macvim') || has('mac')
-    call NERDTreeAddMenuItem({'text': '(r)eveal in Finder the current node', 'shortcut': 'r', 'callback': 'NERDTreeRevealInFinder'})
-    call NERDTreeAddMenuItem({'text': '(o)pen the current node with system editor', 'shortcut': 'o', 'callback': 'NERDTreeExecuteFile'})
-    call NERDTreeAddMenuItem({'text': '(q)uicklook the current node', 'shortcut': 'q', 'callback': 'NERDTreeQuickLook'})
-endif
-
-if executable('xdg-open')
-    call NERDTreeAddMenuItem({'text': '(r)eveal the current node in file manager', 'shortcut': 'r', 'callback': 'NERDTreeRevealFileLinux'})
-    call NERDTreeAddMenuItem({'text': '(o)pen the current node with system editor', 'shortcut': 'o', 'callback': 'NERDTreeExecuteFileLinux'})
-endif
-
-if nerdtree#runningWindows()
-    call NERDTreeAddMenuItem({'text': '(o)pen the current node with system editor', 'shortcut': 'o', 'callback': 'NERDTreeExecuteFileWindows'})
-endif
-
-if g:NERDTreePath.CopyingSupported()
-    call NERDTreeAddMenuItem({'text': '(c)opy the current node', 'shortcut': 'c', 'callback': 'NERDTreeCopyNode'})
-endif
-call NERDTreeAddMenuItem({'text': (has('clipboard')?'copy (p)ath to clipboard':'print (p)ath to screen'), 'shortcut': 'p', 'callback': 'NERDTreeCopyPath'})
-
-if has('unix') || has('osx')
-    call NERDTreeAddMenuItem({'text': '(l)ist the current node', 'shortcut': 'l', 'callback': 'NERDTreeListNode'})
-else
-    call NERDTreeAddMenuItem({'text': '(l)ist the current node', 'shortcut': 'l', 'callback': 'NERDTreeListNodeWin32'})
-endif
-
-"FUNCTION: s:inputPrompt(action){{{1
-"returns the string that should be prompted to the user for the given action
-"
-"Args:
-"action: the action that is being performed, e.g. 'delete'
-function! s:inputPrompt(action)
-    if a:action ==# 'add'
-        let title = 'Add a childnode'
-        let info = "Enter the dir/file name to be created. Dirs end with a '/'"
-        let minimal = 'Add node:'
-
-    elseif a:action ==# 'copy'
-        let title = 'Copy the current node'
-        let info = 'Enter the new path to copy the node to:'
-        let minimal = 'Copy to:'
-
-    elseif a:action ==# 'delete'
-        let title = 'Delete the current node'
-        let info = 'Are you sure you wish to delete the node:'
-        let minimal = 'Delete?'
-
-    elseif a:action ==# 'deleteNonEmpty'
-        let title = 'Delete the current node'
-        let info =  "STOP! Directory is not empty! To delete, type 'yes'"
-        let minimal = 'Delete directory?'
-
-    elseif a:action ==# 'move'
-        let title = 'Rename the current node'
-        let info = 'Enter the new path for the node:'
-        let minimal = 'Move to:'
-    endif
-
-    if g:NERDTreeMenuController.isMinimal()
-        redraw! " Clear the menu
-        return minimal . ' '
-    else
-        let divider = '=========================================================='
-        return title . "\n" . divider . "\n" . info . "\n"
-    end
-endfunction
-
-"FUNCTION: s:promptToDelBuffer(bufnum, msg){{{1
-"prints out the given msg and, if the user responds by pushing 'y' then the
-"buffer with the given bufnum is deleted
-"
-"Args:
-"bufnum: the buffer that may be deleted
-"msg: a message that will be echoed to the user asking them if they wish to
-"     del the buffer
-function! s:promptToDelBuffer(bufnum, msg)
-    echo a:msg
-    if g:NERDTreeAutoDeleteBuffer || nr2char(getchar()) ==# 'y'
-        " 1. ensure that all windows which display the just deleted filename
-        " now display an empty buffer (so a layout is preserved).
-        " Is not it better to close single tabs with this file only ?
-        let s:originalTabNumber = tabpagenr()
-        let s:originalWindowNumber = winnr()
-        " Go to the next buffer in buffer list if at least one extra buffer is listed
-        " Otherwise open a new empty buffer
-        if v:version >= 800
-            let l:listedBufferCount = len(getbufinfo({'buflisted':1}))
-        elseif v:version >= 702
-            let l:listedBufferCount = len(filter(range(1, bufnr('$')), 'buflisted(v:val)'))
-        else
-            " Ignore buffer count in this case to make sure we keep the old
-            " behavior
-            let l:listedBufferCount = 0
-        endif
-        if l:listedBufferCount > 1
-            call nerdtree#exec('tabdo windo if winbufnr(0) ==# ' . a:bufnum . " | exec ':bnext! ' | endif", 1)
-        else
-            call nerdtree#exec('tabdo windo if winbufnr(0) ==# ' . a:bufnum . " | exec ':enew! ' | endif", 1)
-        endif
-        call nerdtree#exec('tabnext ' . s:originalTabNumber, 1)
-        call nerdtree#exec(s:originalWindowNumber . 'wincmd w', 1)
-        " 3. We don't need a previous buffer anymore
-        call nerdtree#exec('bwipeout! ' . a:bufnum, 0)
-    endif
-endfunction
-
-"FUNCTION: s:renameBuffer(bufNum, newNodeName, isDirectory){{{1
-"The buffer with the given bufNum is replaced with a new one
-"
-"Args:
-"bufNum: the buffer that may be deleted
-"newNodeName: the name given to the renamed node
-"isDirectory: determines how to do the create the new filenames
-function! s:renameBuffer(bufNum, newNodeName, isDirectory)
-    if a:isDirectory
-        let quotedFileName = fnameescape(a:newNodeName . '/' . fnamemodify(bufname(a:bufNum),':t'))
-        let editStr = g:NERDTreePath.New(a:newNodeName . '/' . fnamemodify(bufname(a:bufNum),':t')).str({'format': 'Edit'})
-    else
-        let quotedFileName = fnameescape(a:newNodeName)
-        let editStr = g:NERDTreePath.New(a:newNodeName).str({'format': 'Edit'})
-    endif
-    " 1. ensure that a new buffer is loaded
-    call nerdtree#exec('badd ' . quotedFileName, 0)
-    " 2. ensure that all windows which display the just deleted filename
-    " display a buffer for a new filename.
-    let s:originalTabNumber = tabpagenr()
-    let s:originalWindowNumber = winnr()
-    call nerdtree#exec('tabdo windo if winbufnr(0) ==# ' . a:bufNum . " | exec ':e! " . editStr . "' | endif", 0)
-    call nerdtree#exec('tabnext ' . s:originalTabNumber, 1)
-    call nerdtree#exec(s:originalWindowNumber . 'wincmd w', 1)
-    " 3. We don't need a previous buffer anymore
-    try
-        call nerdtree#exec('confirm bwipeout ' . a:bufNum, 0)
-    catch
-        " This happens when answering Cancel if confirmation is needed. Do nothing.
-    endtry
-endfunction
-
-"FUNCTION: NERDTreeAddNode(){{{1
-function! NERDTreeAddNode()
-    let curDirNode = g:NERDTreeDirNode.GetSelected()
-    let prompt = s:inputPrompt('add')
-    let newNodeName = input(prompt, curDirNode.path.str() . g:NERDTreePath.Slash(), 'file')
-
-    if newNodeName ==# ''
-        call nerdtree#echo('Node Creation Aborted.')
-        return
-    endif
-
-    try
-        let newPath = g:NERDTreePath.Create(newNodeName)
-        let parentNode = b:NERDTree.root.findNode(newPath.getParent())
-
-        let newTreeNode = g:NERDTreeFileNode.New(newPath, b:NERDTree)
-        " Emptying g:NERDTreeOldSortOrder forces the sort to
-        " recalculate the cached sortKey so nodes sort correctly.
-        let g:NERDTreeOldSortOrder = []
-        if empty(parentNode)
-            call b:NERDTree.root.refresh()
-            call b:NERDTree.render()
-        elseif parentNode.isOpen || !empty(parentNode.children)
-            call parentNode.addChild(newTreeNode, 1)
-            call NERDTreeRender()
-            call newTreeNode.putCursorHere(1, 0)
-        endif
-
-        redraw!
-    catch /^NERDTree/
-        call nerdtree#echoWarning('Node Not Created.')
-    endtry
-endfunction
-
-"FUNCTION: NERDTreeMoveNode(){{{1
-function! NERDTreeMoveNode()
-    let curNode = g:NERDTreeFileNode.GetSelected()
-    let prompt = s:inputPrompt('move')
-    let newNodePath = input(prompt, curNode.path.str(), 'file')
-    while filereadable(newNodePath)
-        call nerdtree#echoWarning('This destination already exists. Try again.')
-        let newNodePath = input(prompt, curNode.path.str(), 'file')
-    endwhile
-
-
-    if newNodePath ==# ''
-        call nerdtree#echo('Node Renaming Aborted.')
-        return
-    endif
-
-    try
-        if curNode.path.isDirectory
-            let l:curPath = escape(curNode.path.str(),'\') . (nerdtree#runningWindows()?'\\':'/') . '.*'
-            let l:openBuffers = filter(range(1,bufnr('$')),'bufexists(v:val) && fnamemodify(bufname(v:val),":p") =~# "'.escape(l:curPath,'\').'"')
-        else
-            let l:openBuffers = filter(range(1,bufnr('$')),'bufexists(v:val) && fnamemodify(bufname(v:val),":p") ==# curNode.path.str()')
-        endif
-
-        call curNode.rename(newNodePath)
-        " Emptying g:NERDTreeOldSortOrder forces the sort to
-        " recalculate the cached sortKey so nodes sort correctly.
-        let g:NERDTreeOldSortOrder = []
-        call b:NERDTree.root.refresh()
-        call NERDTreeRender()
-
-        " If the file node is open, or files under the directory node are
-        " open, ask the user if they want to replace the file(s) with the
-        " renamed files.
-        if !empty(l:openBuffers)
-            if curNode.path.isDirectory
-                echo "\nDirectory renamed.\n\nFiles with the old directory name are open in buffers " . join(l:openBuffers, ', ') . '. Replace these buffers with the new files? (yN)'
-            else
-                echo "\nFile renamed.\n\nThe old file is open in buffer " . l:openBuffers[0] . '. Replace this buffer with the new file? (yN)'
-            endif
-            if g:NERDTreeAutoDeleteBuffer || nr2char(getchar()) ==# 'y'
-                for bufNum in l:openBuffers
-                    call s:renameBuffer(bufNum, newNodePath, curNode.path.isDirectory)
-                endfor
-            endif
-        endif
-
-        call curNode.putCursorHere(1, 0)
-
-        redraw!
-    catch /^NERDTree/
-        call nerdtree#echoWarning('Node Not Renamed.')
-    endtry
-endfunction
-
-" FUNCTION: NERDTreeDeleteNode() {{{1
-function! NERDTreeDeleteNode()
-    let l:shellslash = &shellslash
-    let &shellslash = 0
-    let currentNode = g:NERDTreeFileNode.GetSelected()
-    let confirmed = 0
-
-    if currentNode.path.isDirectory && ((currentNode.isOpen && currentNode.getChildCount() > 0) ||
-                                      \ (len(currentNode._glob('*', 1)) > 0))
-        let prompt = s:inputPrompt('deleteNonEmpty') . currentNode.path.str() . ': '
-        let choice = input(prompt)
-        let confirmed = choice ==# 'yes'
-    else
-        let prompt = s:inputPrompt('delete') . currentNode.path.str() . ' (yN): '
-        echo prompt
-        let choice = nr2char(getchar())
-        let confirmed = choice ==# 'y'
-    endif
-
-    if confirmed
-        try
-            call currentNode.delete()
-            call NERDTreeRender()
-
-            "if the node is open in a buffer, ask the user if they want to
-            "close that buffer
-            let bufnum = bufnr('^'.currentNode.path.str().'$')
-            if buflisted(bufnum)
-                let prompt = "\nNode deleted.\n\nThe file is open in buffer ". bufnum . (bufwinnr(bufnum) ==# -1 ? ' (hidden)' : '') .'. Delete this buffer? (yN)'
-                call s:promptToDelBuffer(bufnum, prompt)
-            endif
-
-            redraw!
-        catch /^NERDTree/
-            call nerdtree#echoWarning('Could not remove node')
-        endtry
-    else
-        call nerdtree#echo('delete aborted')
-    endif
-    let &shellslash = l:shellslash
-endfunction
-
-" FUNCTION: NERDTreeListNode() {{{1
-function! NERDTreeListNode()
-    let treenode = g:NERDTreeFileNode.GetSelected()
-    if !empty(treenode)
-        let s:uname = system('uname')
-        let stat_cmd = 'stat -c "%s" '
-
-        if s:uname =~? 'Darwin'
-            let stat_cmd = 'stat -f "%z" '
-        endif
-
-        let cmd = 'size=$(' . stat_cmd . shellescape(treenode.path.str()) . ') && ' .
-        \         'size_with_commas=$(echo $size | sed -e :a -e "s/\(.*[0-9]\)\([0-9]\{3\}\)/\1,\2/;ta") && ' .
-        \         'ls -ld ' . shellescape(treenode.path.str()) . ' | sed -e "s/ $size / $size_with_commas /"'
-
-        let metadata = split(system(cmd),'\n')
-        call nerdtree#echo(metadata[0])
-    else
-        call nerdtree#echo('No information available')
-    endif
-endfunction
-
-" FUNCTION: NERDTreeListNodeWin32() {{{1
-function! NERDTreeListNodeWin32()
-    let l:node = g:NERDTreeFileNode.GetSelected()
-
-    if !empty(l:node)
-        let l:path = l:node.path.str()
-        call nerdtree#echo(printf('%s:%s  MOD:%s  BYTES:%d  PERMISSIONS:%s',
-                    \ toupper(getftype(l:path)),
-                    \ fnamemodify(l:path, ':t'),
-                    \ strftime('%c', getftime(l:path)),
-                    \ getfsize(l:path),
-                    \ getfperm(l:path)))
-        return
-    endif
-
-    call nerdtree#echo('node not recognized')
-endfunction
-
-" FUNCTION: NERDTreeCopyNode() {{{1
-function! NERDTreeCopyNode()
-    let l:shellslash = &shellslash
-    let &shellslash = 0
-    let currentNode = g:NERDTreeFileNode.GetSelected()
-    let prompt = s:inputPrompt('copy')
-    let newNodePath = input(prompt, currentNode.path.str(), 'file')
-
-    if newNodePath !=# ''
-        "strip trailing slash
-        let newNodePath = substitute(newNodePath, '\/$', '', '')
-
-        let confirmed = 1
-        if currentNode.path.copyingWillOverwrite(newNodePath)
-            call nerdtree#echo('Warning: copying may overwrite files! Continue? (yN)')
-            let choice = nr2char(getchar())
-            let confirmed = choice ==# 'y'
-        endif
-
-        if confirmed
-            try
-                let newNode = currentNode.copy(newNodePath)
-                " Emptying g:NERDTreeOldSortOrder forces the sort to
-                " recalculate the cached sortKey so nodes sort correctly.
-                let g:NERDTreeOldSortOrder = []
-                if empty(newNode)
-                    call b:NERDTree.root.refresh()
-                    call b:NERDTree.render()
-                else
-                    call NERDTreeRender()
-                    call newNode.putCursorHere(0, 0)
-                endif
-            catch /^NERDTree/
-                call nerdtree#echoWarning('Could not copy node')
-            endtry
-        endif
-    else
-        call nerdtree#echo('Copy aborted.')
-    endif
-    let &shellslash = l:shellslash
-    redraw!
-endfunction
-
-" FUNCTION: NERDTreeCopyPath() {{{1
-function! NERDTreeCopyPath()
-    let l:nodePath = g:NERDTreeFileNode.GetSelected().path.str()
-    if has('clipboard')
-        if &clipboard ==# 'unnamedplus'
-            let @+ = l:nodePath
-        else
-            let @* = l:nodePath
-        endif
-        call nerdtree#echo('The path [' . l:nodePath . '] was copied to your clipboard.')
-    else
-        call nerdtree#echo('The full path is: ' . l:nodePath)
-    endif
-endfunction
-
-" FUNCTION: NERDTreeQuickLook() {{{1
-function! NERDTreeQuickLook()
-    let l:node = g:NERDTreeFileNode.GetSelected()
-
-    if empty(l:node)
-        return
-    endif
-
-    call system('qlmanage -p 2>/dev/null ' . shellescape(l:node.path.str()))
-endfunction
-
-" FUNCTION: NERDTreeRevealInFinder() {{{1
-function! NERDTreeRevealInFinder()
-    let l:node = g:NERDTreeFileNode.GetSelected()
-
-    if empty(l:node)
-        return
-    endif
-
-    call system('open -R ' . shellescape(l:node.path.str()))
-endfunction
-
-" FUNCTION: NERDTreeExecuteFile() {{{1
-function! NERDTreeExecuteFile()
-    let l:node = g:NERDTreeFileNode.GetSelected()
-
-    if empty(l:node)
-        return
-    endif
-
-    call system('open ' . shellescape(l:node.path.str()))
-endfunction
-
-" FUNCTION: NERDTreeRevealFileLinux() {{{1
-function! NERDTreeRevealFileLinux()
-    let l:node = g:NERDTreeFileNode.GetSelected()
-
-    if empty(l:node)
-        return
-    endif
-
-    " Handle the edge case of "/", which has no parent.
-    if l:node.path.str() ==# '/'
-        call system('xdg-open /')
-        return
-    endif
-
-    if empty(l:node.parent)
-        return
-    endif
-
-    call system('xdg-open ' . shellescape(l:node.parent.path.str()))
-endfunction
-
-" FUNCTION: NERDTreeExecuteFileLinux() {{{1
-function! NERDTreeExecuteFileLinux()
-    let l:node = g:NERDTreeFileNode.GetSelected()
-
-    if empty(l:node)
-        return
-    endif
-
-    call system('xdg-open ' . shellescape(l:node.path.str()))
-endfunction
-
-" FUNCTION: NERDTreeExecuteFileWindows() {{{1
-function! NERDTreeExecuteFileWindows()
-    let l:node = g:NERDTreeFileNode.GetSelected()
-
-    if empty(l:node)
-        return
-    endif
-
-    call system('cmd.exe /c start "" ' . shellescape(l:node.path.str()))
-endfunction
-
-" vim: set sw=4 sts=4 et fdm=marker:
diff --git a/sources_non_forked/nerdtree/nerdtree_plugin/vcs.vim b/sources_non_forked/nerdtree/nerdtree_plugin/vcs.vim
deleted file mode 100644
index d20e35e..0000000
--- a/sources_non_forked/nerdtree/nerdtree_plugin/vcs.vim
+++ /dev/null
@@ -1,47 +0,0 @@
-" ============================================================================
-" File:        vcs.vim
-" Description: NERDTree plugin that provides a command to open on the root of
-"              a version control system repository.
-" Maintainer:  Phil Runninger
-" License:     This program is free software. It comes without any warranty,
-"              to the extent permitted by applicable law. You can redistribute
-"              it and/or modify it under the terms of the Do What The Fuck You
-"              Want To Public License, Version 2, as published by Sam Hocevar.
-"              See http://sam.zoy.org/wtfpl/COPYING for more details.
-"
-" ============================================================================
-command! -n=? -complete=dir -bar NERDTreeVCS :call <SID>CreateTabTreeVCS('<args>')
-command! -n=? -complete=dir -bar NERDTreeToggleVCS :call <SID>ToggleTabTreeVCS('<args>')
-
-" FUNCTION: s:CreateTabTreeVCS(a:name) {{{1
-function! s:CreateTabTreeVCS(name)
-    let l:path = g:NERDTreeCreator._pathForString(a:name)
-    let l:path = s:FindParentVCSRoot(l:path)
-    call g:NERDTreeCreator.createTabTree(empty(l:path) ? '' : l:path._str())
-endfunction
-
-" FUNCTION: s:ToggleTabTreeVCS(a:name) {{{1
-" Behaves the same as ToggleTabTree except roots directory at VCS root
-function! s:ToggleTabTreeVCS(name)
-    let l:path = g:NERDTreeCreator._pathForString(a:name)
-    let l:path = s:FindParentVCSRoot(l:path)
-    call g:NERDTreeCreator.toggleTabTree(empty(l:path) ? '' : l:path._str())
-endfunction
-
-" FUNCTION: s:FindParentVCSRoot(a:path) {{{1
-" Finds the root version control system folder of the given path. If a:path is
-" not part of a repository, return the original path.
-function! s:FindParentVCSRoot(path)
-    let l:path = a:path
-    while !empty(l:path) &&
-        \ l:path._str() !~# '^\(\a:[\\\/]\|\/\)$' &&
-        \ !isdirectory(l:path._str() . '/.git') &&
-        \ !isdirectory(l:path._str() . '/.svn') &&
-        \ !isdirectory(l:path._str() . '/.hg') &&
-        \ !isdirectory(l:path._str() . '/.bzr') &&
-        \ !isdirectory(l:path._str() . '/_darcs')
-        let l:path = l:path.getParent()
-    endwhile
-    return (empty(l:path) || l:path._str() =~# '^\(\a:[\\\/]\|\/\)$') ? a:path : l:path
-endfunction
-
diff --git a/sources_non_forked/nerdtree/plugin/NERD_tree.vim b/sources_non_forked/nerdtree/plugin/NERD_tree.vim
deleted file mode 100644
index ca8070d..0000000
--- a/sources_non_forked/nerdtree/plugin/NERD_tree.vim
+++ /dev/null
@@ -1,261 +0,0 @@
-" ============================================================================
-" File:        NERD_tree.vim
-" Maintainer:  Martin Grenfell <martin.grenfell at gmail dot com>
-" License:     This program is free software. It comes without any warranty,
-"              to the extent permitted by applicable law. You can redistribute
-"              it and/or modify it under the terms of the Do What The Fuck You
-"              Want To Public License, Version 2, as published by Sam Hocevar.
-"              See http://sam.zoy.org/wtfpl/COPYING for more details.
-"
-" ============================================================================
-"
-" SECTION: Script init stuff {{{1
-"============================================================
-scriptencoding utf-8
-
-if exists('loaded_nerd_tree')
-    finish
-endif
-if v:version < 703
-    echoerr "NERDTree: this plugin requires vim >= 7.3. DOWNLOAD IT! You'll thank me later!"
-    finish
-endif
-let loaded_nerd_tree = 1
-
-"for line continuation - i.e dont want C in &cpoptions
-let s:old_cpo = &cpoptions
-set cpoptions&vim
-
-"Function: s:initVariable() function {{{2
-"This function is used to initialise a given variable to a given value. The
-"variable is only initialised if it does not exist prior
-"
-"Args:
-"var: the name of the var to be initialised
-"value: the value to initialise var to
-"
-"Returns:
-"1 if the var is set, 0 otherwise
-function! s:initVariable(var, value)
-    if !exists(a:var)
-        exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", 'g') . "'"
-        return 1
-    endif
-    return 0
-endfunction
-
-"SECTION: Init variable calls and other random constants {{{2
-call s:initVariable('g:NERDTreeAutoCenter', 1)
-call s:initVariable('g:NERDTreeAutoCenterThreshold', 3)
-call s:initVariable('g:NERDTreeCaseSensitiveSort', 0)
-call s:initVariable('g:NERDTreeNaturalSort', 0)
-call s:initVariable('g:NERDTreeSortHiddenFirst', 1)
-call s:initVariable('g:NERDTreeUseTCD', 0)
-call s:initVariable('g:NERDTreeChDirMode', 0)
-call s:initVariable('g:NERDTreeCreatePrefix', 'silent')
-call s:initVariable('g:NERDTreeMinimalUI', 0)
-call s:initVariable('g:NERDTreeMinimalMenu', 0)
-if !exists('g:NERDTreeIgnore')
-    let g:NERDTreeIgnore = ['\~$']
-endif
-call s:initVariable('g:NERDTreeBookmarksFile', expand('$HOME') . '/.NERDTreeBookmarks')
-call s:initVariable('g:NERDTreeBookmarksSort', 1)
-call s:initVariable('g:NERDTreeHighlightCursorline', 1)
-call s:initVariable('g:NERDTreeHijackNetrw', 1)
-call s:initVariable('g:NERDTreeMarkBookmarks', 1)
-call s:initVariable('g:NERDTreeMouseMode', 1)
-call s:initVariable('g:NERDTreeNotificationThreshold', 100)
-call s:initVariable('g:NERDTreeQuitOnOpen', 0)
-call s:initVariable('g:NERDTreeRespectWildIgnore', 0)
-call s:initVariable('g:NERDTreeShowBookmarks', 0)
-call s:initVariable('g:NERDTreeShowFiles', 1)
-call s:initVariable('g:NERDTreeShowHidden', 0)
-call s:initVariable('g:NERDTreeShowLineNumbers', 0)
-call s:initVariable('g:NERDTreeSortDirs', 1)
-
-if !nerdtree#runningWindows() && !nerdtree#runningCygwin()
-    call s:initVariable('g:NERDTreeDirArrowExpandable', '')
-    call s:initVariable('g:NERDTreeDirArrowCollapsible', '')
-else
-    call s:initVariable('g:NERDTreeDirArrowExpandable', '+')
-    call s:initVariable('g:NERDTreeDirArrowCollapsible', '~')
-endif
-
-call s:initVariable('g:NERDTreeCascadeOpenSingleChildDir', 1)
-call s:initVariable('g:NERDTreeCascadeSingleChildDir', 1)
-
-if !exists('g:NERDTreeSortOrder')
-    let g:NERDTreeSortOrder = ['\/$', '*', '\.swp$',  '\.bak$', '\~$']
-endif
-let g:NERDTreeOldSortOrder = []
-
-call s:initVariable('g:NERDTreeGlyphReadOnly', 'RO')
-
-if has('conceal')
-    call s:initVariable('g:NERDTreeNodeDelimiter', "\x07")
-elseif (g:NERDTreeDirArrowExpandable ==# "\u00a0" || g:NERDTreeDirArrowCollapsible ==# "\u00a0")
-    call s:initVariable('g:NERDTreeNodeDelimiter', "\u00b7")
-else
-    call s:initVariable('g:NERDTreeNodeDelimiter', "\u00a0")
-endif
-
-if !exists('g:NERDTreeStatusline')
-
-    "the exists() crap here is a hack to stop vim spazzing out when
-    "loading a session that was created with an open nerd tree. It spazzes
-    "because it doesnt store b:NERDTree(its a b: var, and its a hash)
-    let g:NERDTreeStatusline = "%{exists('b:NERDTree')?b:NERDTree.root.path.str():''}"
-
-endif
-call s:initVariable('g:NERDTreeWinPos', 'left')
-call s:initVariable('g:NERDTreeWinSize', 31)
-
-"init the shell commands that will be used to copy nodes, and remove dir trees
-"
-"Note: the space after the command is important
-if nerdtree#runningWindows()
-    call s:initVariable('g:NERDTreeRemoveDirCmd', 'rmdir /s /q ')
-    call s:initVariable('g:NERDTreeCopyDirCmd', 'xcopy /s /e /i /y /q ')
-    call s:initVariable('g:NERDTreeCopyFileCmd', 'copy /y ')
-else
-    call s:initVariable('g:NERDTreeRemoveDirCmd', 'rm -rf ')
-    call s:initVariable('g:NERDTreeCopyCmd', 'cp -r ')
-endif
-
-
-"SECTION: Init variable calls for key mappings {{{2
-call s:initVariable('g:NERDTreeMapCustomOpen', '<CR>')
-call s:initVariable('g:NERDTreeMapActivateNode', 'o')
-call s:initVariable('g:NERDTreeMapChangeRoot', 'C')
-call s:initVariable('g:NERDTreeMapChdir', 'cd')
-call s:initVariable('g:NERDTreeMapCloseChildren', 'X')
-call s:initVariable('g:NERDTreeMapCloseDir', 'x')
-call s:initVariable('g:NERDTreeMapDeleteBookmark', 'D')
-call s:initVariable('g:NERDTreeMapMenu', 'm')
-call s:initVariable('g:NERDTreeMapHelp', '?')
-call s:initVariable('g:NERDTreeMapJumpFirstChild', 'K')
-call s:initVariable('g:NERDTreeMapJumpLastChild', 'J')
-call s:initVariable('g:NERDTreeMapJumpNextSibling', '<C-j>')
-call s:initVariable('g:NERDTreeMapJumpParent', 'p')
-call s:initVariable('g:NERDTreeMapJumpPrevSibling', '<C-k>')
-call s:initVariable('g:NERDTreeMapJumpRoot', 'P')
-call s:initVariable('g:NERDTreeMapOpenExpl', 'e')
-call s:initVariable('g:NERDTreeMapOpenInTab', 't')
-call s:initVariable('g:NERDTreeMapOpenInTabSilent', 'T')
-call s:initVariable('g:NERDTreeMapOpenRecursively', 'O')
-call s:initVariable('g:NERDTreeMapOpenSplit', 'i')
-call s:initVariable('g:NERDTreeMapOpenVSplit', 's')
-call s:initVariable('g:NERDTreeMapPreview', 'g' . NERDTreeMapActivateNode)
-call s:initVariable('g:NERDTreeMapPreviewSplit', 'g' . NERDTreeMapOpenSplit)
-call s:initVariable('g:NERDTreeMapPreviewVSplit', 'g' . NERDTreeMapOpenVSplit)
-call s:initVariable('g:NERDTreeMapQuit', 'q')
-call s:initVariable('g:NERDTreeMapRefresh', 'r')
-call s:initVariable('g:NERDTreeMapRefreshRoot', 'R')
-call s:initVariable('g:NERDTreeMapToggleBookmarks', 'B')
-call s:initVariable('g:NERDTreeMapToggleFiles', 'F')
-call s:initVariable('g:NERDTreeMapToggleFilters', 'f')
-call s:initVariable('g:NERDTreeMapToggleHidden', 'I')
-call s:initVariable('g:NERDTreeMapToggleZoom', 'A')
-call s:initVariable('g:NERDTreeMapUpdir', 'u')
-call s:initVariable('g:NERDTreeMapUpdirKeepOpen', 'U')
-call s:initVariable('g:NERDTreeMapCWD', 'CD')
-call s:initVariable('g:NERDTreeMenuDown', 'j')
-call s:initVariable('g:NERDTreeMenuUp', 'k')
-
-"SECTION: Load class files{{{2
-call nerdtree#loadClassFiles()
-
-" SECTION: Commands {{{1
-"============================================================
-call nerdtree#ui_glue#setupCommands()
-
-" SECTION: Auto commands {{{1
-"============================================================
-augroup NERDTree
-    "Save the cursor position whenever we close the nerd tree
-    exec 'autocmd BufLeave,WinLeave '. g:NERDTreeCreator.BufNamePrefix() .'* if g:NERDTree.IsOpen() | call b:NERDTree.ui.saveScreenState() | endif'
-
-    "disallow insert mode in the NERDTree
-    exec 'autocmd BufEnter,WinEnter '. g:NERDTreeCreator.BufNamePrefix() .'* stopinsert'
-augroup END
-
-if g:NERDTreeHijackNetrw
-    augroup NERDTreeHijackNetrw
-        autocmd VimEnter * silent! autocmd! FileExplorer
-        au BufEnter,VimEnter * call nerdtree#checkForBrowse(expand('<amatch>'))
-    augroup END
-endif
-
-if g:NERDTreeChDirMode ==# 3
-    augroup NERDTreeChDirOnTabSwitch
-        autocmd TabEnter * if g:NERDTree.ExistsForTab()|call g:NERDTree.ForCurrentTab().getRoot().path.changeToDir()|endif
-    augroup END
-endif
-
-" SECTION: Public API {{{1
-"============================================================
-function! NERDTreeAddMenuItem(options)
-    call g:NERDTreeMenuItem.Create(a:options)
-endfunction
-
-function! NERDTreeAddMenuSeparator(...)
-    let opts = a:0 ? a:1 : {}
-    call g:NERDTreeMenuItem.CreateSeparator(opts)
-endfunction
-
-function! NERDTreeAddSubmenu(options)
-    return g:NERDTreeMenuItem.Create(a:options)
-endfunction
-
-function! NERDTreeAddKeyMap(options)
-    call g:NERDTreeKeyMap.Create(a:options)
-endfunction
-
-function! NERDTreeRender()
-    call nerdtree#renderView()
-endfunction
-
-function! NERDTreeFocus()
-    if g:NERDTree.IsOpen()
-        call g:NERDTree.CursorToTreeWin(0)
-    else
-        call g:NERDTreeCreator.ToggleTabTree('')
-    endif
-endfunction
-
-function! NERDTreeCWD()
-
-    if empty(getcwd())
-        call nerdtree#echoWarning('current directory does not exist')
-        return
-    endif
-
-    try
-        let l:cwdPath = g:NERDTreePath.New(getcwd())
-    catch /^NERDTree.InvalidArgumentsError/
-        call nerdtree#echoWarning('current directory does not exist')
-        return
-    endtry
-
-    call NERDTreeFocus()
-
-    if b:NERDTree.root.path.equals(l:cwdPath)
-        return
-    endif
-
-    let l:newRoot = g:NERDTreeFileNode.New(l:cwdPath, b:NERDTree)
-    call b:NERDTree.changeRoot(l:newRoot)
-    normal! ^
-endfunction
-
-function! NERDTreeAddPathFilter(callback)
-    call g:NERDTree.AddPathFilter(a:callback)
-endfunction
-
-" SECTION: Post Source Actions {{{1
-call nerdtree#postSourceActions()
-
-"reset &cpoptions back to users setting
-let &cpoptions = s:old_cpo
-
-" vim: set sw=4 sts=4 et fdm=marker:
diff --git a/sources_non_forked/nerdtree/screenshot.png b/sources_non_forked/nerdtree/screenshot.png
deleted file mode 100644
index c410c5d..0000000
Binary files a/sources_non_forked/nerdtree/screenshot.png and /dev/null differ
diff --git a/sources_non_forked/nerdtree/syntax/nerdtree.vim b/sources_non_forked/nerdtree/syntax/nerdtree.vim
deleted file mode 100644
index fc7269e..0000000
--- a/sources_non_forked/nerdtree/syntax/nerdtree.vim
+++ /dev/null
@@ -1,95 +0,0 @@
-let s:tree_up_dir_line = '.. (up a dir)'
-syn match NERDTreeIgnore #\~#
-exec 'syn match NERDTreeIgnore #\['.g:NERDTreeGlyphReadOnly.'\]#'
-
-"highlighting for the .. (up dir) line at the top of the tree
-execute "syn match NERDTreeUp #\\V". s:tree_up_dir_line .'#'
-
-"quickhelp syntax elements
-syn match NERDTreeHelpKey #" \{1,2\}[^ ]*:#ms=s+2,me=e-1
-syn match NERDTreeHelpKey #" \{1,2\}[^ ]*,#ms=s+2,me=e-1
-syn match NERDTreeHelpTitle #" .*\~$#ms=s+2,me=e-1
-syn match NERDTreeToggleOn #(on)#ms=s+1,he=e-1
-syn match NERDTreeToggleOff #(off)#ms=e-3,me=e-1
-syn match NERDTreeHelpCommand #" :.\{-}\>#hs=s+3
-syn match NERDTreeHelp  #^".*# contains=NERDTreeHelpKey,NERDTreeHelpTitle,NERDTreeIgnore,NERDTreeToggleOff,NERDTreeToggleOn,NERDTreeHelpCommand
-
-"highlighting for sym links
-syn match NERDTreeLinkTarget #->.*# containedin=NERDTreeDir,NERDTreeFile
-syn match NERDTreeLinkFile #.* ->#me=e-3 containedin=NERDTreeFile
-syn match NERDTreeLinkDir #.*/ ->#me=e-3 containedin=NERDTreeDir
-
-"highlighting to conceal the delimiter around the file/dir name
-if has('conceal')
-    exec 'syn match NERDTreeNodeDelimiters #\%d' . char2nr(g:NERDTreeNodeDelimiter) . '# conceal containedin=ALL'
-    setlocal conceallevel=2 concealcursor=nvic
-else
-    exec 'syn match NERDTreeNodeDelimiters #\%d' . char2nr(g:NERDTreeNodeDelimiter) . '# containedin=ALL'
-    hi! link NERDTreeNodeDelimiters Ignore
-endif
-
-"highlighing for directory nodes and file nodes
-syn match NERDTreeDirSlash #/# containedin=NERDTreeDir
-
-if g:NERDTreeDirArrowExpandable !=# ''
-    exec 'syn match NERDTreeClosable #' . escape(g:NERDTreeDirArrowCollapsible, '~') . '\ze .*/# containedin=NERDTreeDir,NERDTreeFile'
-    exec 'syn match NERDTreeOpenable #' . escape(g:NERDTreeDirArrowExpandable, '~') . '\ze .*/# containedin=NERDTreeDir,NERDTreeFile'
-    let s:dirArrows = escape(g:NERDTreeDirArrowCollapsible, '~]\-').escape(g:NERDTreeDirArrowExpandable, '~]\-')
-    exec 'syn match NERDTreeDir #[^'.s:dirArrows.' ].*/#'
-    exec 'syn match NERDTreeExecFile #^.*'.g:NERDTreeNodeDelimiter.'\*\($\| \)# contains=NERDTreeRO,NERDTreeBookmark'
-    exec 'syn match NERDTreeFile  #^[^"\.'.s:dirArrows.'] *[^'.s:dirArrows.']*# contains=NERDTreeLink,NERDTreeRO,NERDTreeBookmark,NERDTreeExecFile'
-else
-    exec 'syn match NERDTreeDir #[^'.g:NERDTreeNodeDelimiter.']\{-}/\ze\($\|'.g:NERDTreeNodeDelimiter.'\)#'
-    exec 'syn match NERDTreeExecFile #[^'.g:NERDTreeNodeDelimiter.']\{-}'.g:NERDTreeNodeDelimiter.'\*\($\| \)# contains=NERDTreeRO,NERDTreeBookmark'
-    exec 'syn match NERDTreeFile     #^.*'.g:NERDTreeNodeDelimiter.'.*[^\/]\($\|'.g:NERDTreeNodeDelimiter.'.*\)# contains=NERDTreeLink,NERDTreeRO,NERDTreeBookmark,NERDTreeExecFile'
-endif
-
-"highlighting for readonly files
-exec 'syn match NERDTreeRO #.*'.g:NERDTreeNodeDelimiter.'\zs.*\ze'.g:NERDTreeNodeDelimiter.'.*\['.g:NERDTreeGlyphReadOnly.'\]# contains=NERDTreeIgnore,NERDTreeBookmark,NERDTreeFile'
-
-exec 'syn match NERDTreeFlags #\[[^\]]*\]\ze'.g:NERDTreeNodeDelimiter.'# containedin=NERDTreeFile,NERDTreeExecFile,NERDTreeDir'
-
-syn match NERDTreeCWD #^[</].*$#
-
-"highlighting for bookmarks
-syn match NERDTreeBookmark # {.*}#hs=s+1
-
-"highlighting for the bookmarks table
-syn match NERDTreeBookmarksLeader #^>#
-syn match NERDTreeBookmarksHeader #^>-\+Bookmarks-\+$# contains=NERDTreeBookmarksLeader
-syn match NERDTreeBookmarkName #^>.\{-} #he=e-1 contains=NERDTreeBookmarksLeader
-syn match NERDTreeBookmark #^>.*$# contains=NERDTreeBookmarksLeader,NERDTreeBookmarkName,NERDTreeBookmarksHeader
-
-hi def link NERDTreePart Special
-hi def link NERDTreePartFile Type
-hi def link NERDTreeExecFile Title
-hi def link NERDTreeDirSlash Identifier
-
-hi def link NERDTreeBookmarksHeader statement
-hi def link NERDTreeBookmarksLeader ignore
-hi def link NERDTreeBookmarkName Identifier
-hi def link NERDTreeBookmark normal
-
-hi def link NERDTreeHelp String
-hi def link NERDTreeHelpKey Identifier
-hi def link NERDTreeHelpCommand Identifier
-hi def link NERDTreeHelpTitle Macro
-hi def link NERDTreeToggleOn Question
-hi def link NERDTreeToggleOff WarningMsg
-
-hi def link NERDTreeLinkTarget Type
-hi def link NERDTreeLinkFile Macro
-hi def link NERDTreeLinkDir Macro
-
-hi def link NERDTreeDir Directory
-hi def link NERDTreeUp Directory
-hi def link NERDTreeFile Normal
-hi def link NERDTreeCWD Statement
-hi def link NERDTreeOpenable Directory
-hi def link NERDTreeClosable Directory
-hi def link NERDTreeIgnore ignore
-hi def link NERDTreeRO WarningMsg
-hi def link NERDTreeBookmark Statement
-hi def link NERDTreeFlags Number
-
-hi def link NERDTreeCurrentNode Search
diff --git a/sources_non_forked/nginx.vim/README.md b/sources_non_forked/nginx.vim/README.md
index 669159a..6a2bafa 100644
--- a/sources_non_forked/nginx.vim/README.md
+++ b/sources_non_forked/nginx.vim/README.md
@@ -51,8 +51,17 @@ For help with secure cipher selection, visit [Mozillas SSL Configuration Generat
 
 ## Installation
 
-Install using any vim plugin manager. If you're not familiar with any, go with Plug ([``vim-plug``](https://github.com/junegunn/vim-plug)).
-Then install this plugin using the your vim's plugin manager as follows:
+If your Vim is at version 8 or later, the first method below is the quickest. Otherwise, install this plugin with any Vim plugin manager ([``vim-plug``](https://github.com/junegunn/vim-plug) is recommended).
+
+### Native plugin management (Vim 8+)
+
+Clone or submodule this repo into your Vim packages location. Example:
+
+```
+mkdir -p ~/.vim/pack/plugins/start
+cd ~/.vim/pack/plugins/start
+git clone https://github.com/chr4/nginx.vim.git
+```
 
 ### Plug
 ```
diff --git a/sources_non_forked/nginx.vim/syntax/nginx.vim b/sources_non_forked/nginx.vim/syntax/nginx.vim
index 9d3b92e..18dd50c 100644
--- a/sources_non_forked/nginx.vim/syntax/nginx.vim
+++ b/sources_non_forked/nginx.vim/syntax/nginx.vim
@@ -2276,7 +2276,6 @@ hi link ngxComment Comment
 hi link ngxVariable Identifier
 hi link ngxVariableBlock Identifier
 hi link ngxVariableString PreProc
-hi link ngxBlock Normal
 hi link ngxString String
 hi link ngxIPaddr Delimiter
 hi link ngxBoolean Boolean
diff --git a/sources_non_forked/rust.vim/.gitignore b/sources_non_forked/rust.vim/.gitignore
deleted file mode 100644
index 0a56e3f..0000000
--- a/sources_non_forked/rust.vim/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-/doc/tags
diff --git a/sources_non_forked/rust.vim/.travis.yml b/sources_non_forked/rust.vim/.travis.yml
deleted file mode 100644
index fa69300..0000000
--- a/sources_non_forked/rust.vim/.travis.yml
+++ /dev/null
@@ -1,7 +0,0 @@
----
-sudo: required
-services:
-    - docker
-language: generic
-script: |
-    cd test && ./run-tests
diff --git a/sources_non_forked/rust.vim/.vintrc.yml b/sources_non_forked/rust.vim/.vintrc.yml
deleted file mode 100644
index 0914f1b..0000000
--- a/sources_non_forked/rust.vim/.vintrc.yml
+++ /dev/null
@@ -1,10 +0,0 @@
-cmdargs:
-    # Checking more strictly
-    severity: style_problem
-
-policies:
-    # Disable a violation
-    ProhibitUnnecessaryDoubleQuote:
-        enabled: false
-    ProhibitImplicitScopeVariable:
-        enabled: false
diff --git a/sources_non_forked/rust.vim/ISSUE_TEMPLATE.md b/sources_non_forked/rust.vim/ISSUE_TEMPLATE.md
deleted file mode 100644
index 10afd15..0000000
--- a/sources_non_forked/rust.vim/ISSUE_TEMPLATE.md
+++ /dev/null
@@ -1,27 +0,0 @@
-<!--
-
-Hi, and thanks for reporting an issue with rust.vim. 
-
-Details about your environment will help us assist you.
-
-Please edit this template!
-
--->
-
-* rust.vim version: <!-- Describe if you use a Vim plugin manager, and you
-can use it to tell which version of rust.vim you are running. -->
-
-Steps to reproduce:
-
-<!-- It's best to try to reproduce the issue with the master version of
-rust.vim. The issue may already be fixed! -->
-_?_
-
-Expected vs. actual behavior:
-
-_?_
-
-Paste debugging info from the Rust Vim plugin via _one_ of the following
-commands: `:RustInfo`,  `:RustInfoToClipboard`, or `:RustInfoToFile <filename>`.
-
-_?_
diff --git a/sources_non_forked/rust.vim/LICENSE-APACHE b/sources_non_forked/rust.vim/LICENSE-APACHE
deleted file mode 100644
index 16fe87b..0000000
--- a/sources_non_forked/rust.vim/LICENSE-APACHE
+++ /dev/null
@@ -1,201 +0,0 @@
-                              Apache License
-                        Version 2.0, January 2004
-                     http://www.apache.org/licenses/
-
-TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
-
-1. Definitions.
-
-   "License" shall mean the terms and conditions for use, reproduction,
-   and distribution as defined by Sections 1 through 9 of this document.
-
-   "Licensor" shall mean the copyright owner or entity authorized by
-   the copyright owner that is granting the License.
-
-   "Legal Entity" shall mean the union of the acting entity and all
-   other entities that control, are controlled by, or are under common
-   control with that entity. For the purposes of this definition,
-   "control" means (i) the power, direct or indirect, to cause the
-   direction or management of such entity, whether by contract or
-   otherwise, or (ii) ownership of fifty percent (50%) or more of the
-   outstanding shares, or (iii) beneficial ownership of such entity.
-
-   "You" (or "Your") shall mean an individual or Legal Entity
-   exercising permissions granted by this License.
-
-   "Source" form shall mean the preferred form for making modifications,
-   including but not limited to software source code, documentation
-   source, and configuration files.
-
-   "Object" form shall mean any form resulting from mechanical
-   transformation or translation of a Source form, including but
-   not limited to compiled object code, generated documentation,
-   and conversions to other media types.
-
-   "Work" shall mean the work of authorship, whether in Source or
-   Object form, made available under the License, as indicated by a
-   copyright notice that is included in or attached to the work
-   (an example is provided in the Appendix below).
-
-   "Derivative Works" shall mean any work, whether in Source or Object
-   form, that is based on (or derived from) the Work and for which the
-   editorial revisions, annotations, elaborations, or other modifications
-   represent, as a whole, an original work of authorship. For the purposes
-   of this License, Derivative Works shall not include works that remain
-   separable from, or merely link (or bind by name) to the interfaces of,
-   the Work and Derivative Works thereof.
-
-   "Contribution" shall mean any work of authorship, including
-   the original version of the Work and any modifications or additions
-   to that Work or Derivative Works thereof, that is intentionally
-   submitted to Licensor for inclusion in the Work by the copyright owner
-   or by an individual or Legal Entity authorized to submit on behalf of
-   the copyright owner. For the purposes of this definition, "submitted"
-   means any form of electronic, verbal, or written communication sent
-   to the Licensor or its representatives, including but not limited to
-   communication on electronic mailing lists, source code control systems,
-   and issue tracking systems that are managed by, or on behalf of, the
-   Licensor for the purpose of discussing and improving the Work, but
-   excluding communication that is conspicuously marked or otherwise
-   designated in writing by the copyright owner as "Not a Contribution."
-
-   "Contributor" shall mean Licensor and any individual or Legal Entity
-   on behalf of whom a Contribution has been received by Licensor and
-   subsequently incorporated within the Work.
-
-2. Grant of Copyright License. Subject to the terms and conditions of
-   this License, each Contributor hereby grants to You a perpetual,
-   worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-   copyright license to reproduce, prepare Derivative Works of,
-   publicly display, publicly perform, sublicense, and distribute the
-   Work and such Derivative Works in Source or Object form.
-
-3. Grant of Patent License. Subject to the terms and conditions of
-   this License, each Contributor hereby grants to You a perpetual,
-   worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-   (except as stated in this section) patent license to make, have made,
-   use, offer to sell, sell, import, and otherwise transfer the Work,
-   where such license applies only to those patent claims licensable
-   by such Contributor that are necessarily infringed by their
-   Contribution(s) alone or by combination of their Contribution(s)
-   with the Work to which such Contribution(s) was submitted. If You
-   institute patent litigation against any entity (including a
-   cross-claim or counterclaim in a lawsuit) alleging that the Work
-   or a Contribution incorporated within the Work constitutes direct
-   or contributory patent infringement, then any patent licenses
-   granted to You under this License for that Work shall terminate
-   as of the date such litigation is filed.
-
-4. Redistribution. You may reproduce and distribute copies of the
-   Work or Derivative Works thereof in any medium, with or without
-   modifications, and in Source or Object form, provided that You
-   meet the following conditions:
-
-   (a) You must give any other recipients of the Work or
-       Derivative Works a copy of this License; and
-
-   (b) You must cause any modified files to carry prominent notices
-       stating that You changed the files; and
-
-   (c) You must retain, in the Source form of any Derivative Works
-       that You distribute, all copyright, patent, trademark, and
-       attribution notices from the Source form of the Work,
-       excluding those notices that do not pertain to any part of
-       the Derivative Works; and
-
-   (d) If the Work includes a "NOTICE" text file as part of its
-       distribution, then any Derivative Works that You distribute must
-       include a readable copy of the attribution notices contained
-       within such NOTICE file, excluding those notices that do not
-       pertain to any part of the Derivative Works, in at least one
-       of the following places: within a NOTICE text file distributed
-       as part of the Derivative Works; within the Source form or
-       documentation, if provided along with the Derivative Works; or,
-       within a display generated by the Derivative Works, if and
-       wherever such third-party notices normally appear. The contents
-       of the NOTICE file are for informational purposes only and
-       do not modify the License. You may add Your own attribution
-       notices within Derivative Works that You distribute, alongside
-       or as an addendum to the NOTICE text from the Work, provided
-       that such additional attribution notices cannot be construed
-       as modifying the License.
-
-   You may add Your own copyright statement to Your modifications and
-   may provide additional or different license terms and conditions
-   for use, reproduction, or distribution of Your modifications, or
-   for any such Derivative Works as a whole, provided Your use,
-   reproduction, and distribution of the Work otherwise complies with
-   the conditions stated in this License.
-
-5. Submission of Contributions. Unless You explicitly state otherwise,
-   any Contribution intentionally submitted for inclusion in the Work
-   by You to the Licensor shall be under the terms and conditions of
-   this License, without any additional terms or conditions.
-   Notwithstanding the above, nothing herein shall supersede or modify
-   the terms of any separate license agreement you may have executed
-   with Licensor regarding such Contributions.
-
-6. Trademarks. This License does not grant permission to use the trade
-   names, trademarks, service marks, or product names of the Licensor,
-   except as required for reasonable and customary use in describing the
-   origin of the Work and reproducing the content of the NOTICE file.
-
-7. Disclaimer of Warranty. Unless required by applicable law or
-   agreed to in writing, Licensor provides the Work (and each
-   Contributor provides its Contributions) on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
-   implied, including, without limitation, any warranties or conditions
-   of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
-   PARTICULAR PURPOSE. You are solely responsible for determining the
-   appropriateness of using or redistributing the Work and assume any
-   risks associated with Your exercise of permissions under this License.
-
-8. Limitation of Liability. In no event and under no legal theory,
-   whether in tort (including negligence), contract, or otherwise,
-   unless required by applicable law (such as deliberate and grossly
-   negligent acts) or agreed to in writing, shall any Contributor be
-   liable to You for damages, including any direct, indirect, special,
-   incidental, or consequential damages of any character arising as a
-   result of this License or out of the use or inability to use the
-   Work (including but not limited to damages for loss of goodwill,
-   work stoppage, computer failure or malfunction, or any and all
-   other commercial damages or losses), even if such Contributor
-   has been advised of the possibility of such damages.
-
-9. Accepting Warranty or Additional Liability. While redistributing
-   the Work or Derivative Works thereof, You may choose to offer,
-   and charge a fee for, acceptance of support, warranty, indemnity,
-   or other liability obligations and/or rights consistent with this
-   License. However, in accepting such obligations, You may act only
-   on Your own behalf and on Your sole responsibility, not on behalf
-   of any other Contributor, and only if You agree to indemnify,
-   defend, and hold each Contributor harmless for any liability
-   incurred by, or claims asserted against, such Contributor by reason
-   of your accepting any such warranty or additional liability.
-
-END OF TERMS AND CONDITIONS
-
-APPENDIX: How to apply the Apache License to your work.
-
-   To apply the Apache License to your work, attach the following
-   boilerplate notice, with the fields enclosed by brackets "[]"
-   replaced with your own identifying information. (Don't include
-   the brackets!)  The text should be enclosed in the appropriate
-   comment syntax for the file format. We also recommend that a
-   file or class name and description of purpose be included on the
-   same "printed page" as the copyright notice for easier
-   identification within third-party archives.
-
-Copyright [yyyy] [name of copyright owner]
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-	http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
diff --git a/sources_non_forked/rust.vim/LICENSE-MIT b/sources_non_forked/rust.vim/LICENSE-MIT
deleted file mode 100644
index e69282e..0000000
--- a/sources_non_forked/rust.vim/LICENSE-MIT
+++ /dev/null
@@ -1,25 +0,0 @@
-Copyright (c) 2015 The Rust Project Developers
-
-Permission is hereby granted, free of charge, to any
-person obtaining a copy of this software and associated
-documentation files (the "Software"), to deal in the
-Software without restriction, including without
-limitation the rights to use, copy, modify, merge,
-publish, distribute, sublicense, and/or sell copies of
-the Software, and to permit persons to whom the Software
-is furnished to do so, subject to the following
-conditions:
-
-The above copyright notice and this permission notice
-shall be included in all copies or substantial portions
-of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF
-ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
-TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
-PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT
-SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
-OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
-IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-DEALINGS IN THE SOFTWARE.
diff --git a/sources_non_forked/rust.vim/README.md b/sources_non_forked/rust.vim/README.md
deleted file mode 100644
index fa1e7b6..0000000
--- a/sources_non_forked/rust.vim/README.md
+++ /dev/null
@@ -1,109 +0,0 @@
-# rust.vim
-
-## Description
-
-This is a Vim plugin that provides [Rust][r] file detection, syntax highlighting, formatting,
-[Syntastic][syn] integration, and more. It requires Vim 8 or higher for full functionality.
-Some things may not work on earlier versions. 
-
-## Installation
-
-Use one of the following package managers:
-
-* [Vim8 packages][vim8pack]:
-  * `git clone https://github.com/rust-lang/rust.vim ~/.vim/pack/plugins/start/rust.vim`
-* [Vundle][v]:
-  * Add `Plugin 'rust-lang/rust.vim'` to `~/.vimrc`
-  * `:PluginInstall` or `$ vim +PluginInstall +qall`
-  * *Note:* Vundle will not automatically detect Rust files properly if `filetype
-on` is executed before Vundle. Please check the [quickstart][vqs] for more
-details. Errors such as `Not an editor command: RustFmt` may occur if Vundle
-is misconfigured with this plugin.
-* [Pathogen][p]:
-  * `git clone --depth=1 https://github.com/rust-lang/rust.vim.git ~/.vim/bundle/rust.vim`
-* [vim-plug][vp]:
-  * Add `Plug 'rust-lang/rust.vim'` to `~/.vimrc`
-  * `:PlugInstall` or `$ vim +PlugInstall +qall`
-* [dein.vim][d]:
-  * Add `call dein#add('rust-lang/rust.vim')` to `~/.vimrc`
-  * `:call dein#install()`
-* [NeoBundle][nb]:
-  * Add `NeoBundle 'rust-lang/rust.vim'` to `~/.vimrc`
-  * Re-open vim or execute `:source ~/.vimrc`
-
-## Features
-
-### Error checking with [Syntastic][syn]
-
-`rust.vim` automatically registers `cargo` as a syntax checker with
-[Syntastic][syn], if nothing else is specified. See `:help rust-syntastic`
-for more details.
-
-### Source browsing with [Tagbar][tgbr]
-
-The installation of Tagbar along with [Universal Ctags][uctags] is recommended
-for a good Tagbar experience. For other kinds of setups, `rust.vim` tries to
-configure Tagbar to some degree.
-
-### Formatting with [rustfmt][rfmt]
-
-The `:RustFmt` command will format your code with
-[rustfmt][rfmt] if installed.
-
-Placing `let g:rustfmt_autosave = 1` in your `~/.vimrc` will
-enable automatic running of `:RustFmt` when you save a buffer.
-
-Do `:help :RustFmt` for further formatting help and customization
-options.
-
-### [Playpen][pp] integration
-
-*Note:* This feature requires [webapi-vim][wav] to be installed.
-
-The `:RustPlay` command will send the current selection, or if
-nothing is selected the current buffer, to the [Rust playpen][pp].
-
-If you set g:rust_clip_command RustPlay will copy the url to the clipboard.
-
-- Mac:
-
-        let g:rust_clip_command = 'pbcopy'
-
-- Linux:
-
-        let g:rust_clip_command = 'xclip -selection clipboard'
-
-### Running a test under cursor
-
-In cargo project, the `:RustTest` command will run a test under the cursor.
-This is useful when your project is bigger and running all tests take longer time.
-
-## Help
-
-Further help can be found in the documentation with `:Helptags` then `:help rust`.
-
-Detailed help can be found in the documentation with `:help rust`.
-Helptags (`:help helptags`) need to be generated for this plugin
-in order to navigate the help. Most plugin managers will do this
-automatically, but check their documentation if that is not the case.
-
-## License
-
-Like Rust, rust.vim is primarily distributed under the terms of both the MIT
-license and the Apache License (Version 2.0). See LICENSE-APACHE and
-LICENSE-MIT for details.
-
-[r]: https://www.rust-lang.org
-[v]: https://github.com/gmarik/vundle
-[vqs]: https://github.com/gmarik/vundle#quick-start
-[p]: https://github.com/tpope/vim-pathogen
-[nb]: https://github.com/Shougo/neobundle.vim
-[vp]: https://github.com/junegunn/vim-plug
-[d]: https://github.com/Shougo/dein.vim
-[rfmt]: https://github.com/rust-lang-nursery/rustfmt
-[syn]: https://github.com/scrooloose/syntastic
-[tgbr]: https://github.com/majutsushi/tagbar
-[uctags]: https://ctags.io
-[wav]: https://github.com/mattn/webapi-vim
-[pp]: https://play.rust-lang.org/
-[vim8pack]: http://vimhelp.appspot.com/repeat.txt.html#packages
diff --git a/sources_non_forked/rust.vim/after/syntax/rust.vim b/sources_non_forked/rust.vim/after/syntax/rust.vim
deleted file mode 100644
index 62bfc65..0000000
--- a/sources_non_forked/rust.vim/after/syntax/rust.vim
+++ /dev/null
@@ -1,41 +0,0 @@
-scriptencoding utf-8
-
-if !get(g:, 'rust_conceal', 0) || !has('conceal') || &encoding !=# 'utf-8'
-    finish
-endif
-
-" For those who don't want to see `::`...
-if get(g:, 'rust_conceal_mod_path', 0)
-    syn match rustNiceOperator "::" conceal cchar=
-endif
-
-syn match rustRightArrowHead contained ">" conceal cchar=
-syn match rustRightArrowTail contained "-" conceal cchar=
-syn match rustNiceOperator "->" contains=rustRightArrowHead,rustRightArrowTail
-
-syn match rustFatRightArrowHead contained ">" conceal cchar=
-syn match rustFatRightArrowTail contained "=" conceal cchar=
-syn match rustNiceOperator "=>" contains=rustFatRightArrowHead,rustFatRightArrowTail
-
-syn match rustNiceOperator /\<\@!_\(_*\>\)\@=/ conceal cchar=
-
-" For those who don't want to see `pub`...
-if get(g:, 'rust_conceal_pub', 0)
-    syn match rustPublicSigil contained "pu" conceal cchar=
-    syn match rustPublicRest contained "b" conceal cchar=
-    syn match rustNiceOperator "pub " contains=rustPublicSigil,rustPublicRest
-endif
-
-hi link rustNiceOperator Operator
-
-if !get(g:, 'rust_conceal_mod_path', 0)
-    hi! link Conceal Operator
-
-    augroup rust.vim.after
-        autocmd!
-        " And keep it after a colorscheme change
-        autocmd ColorScheme <buffer> hi! link Conceal Operator
-    augroup END
-endif
-
-" vim: set et sw=4 sts=4 ts=8:
diff --git a/sources_non_forked/rust.vim/autoload/cargo.vim b/sources_non_forked/rust.vim/autoload/cargo.vim
deleted file mode 100644
index a95a57f..0000000
--- a/sources_non_forked/rust.vim/autoload/cargo.vim
+++ /dev/null
@@ -1,147 +0,0 @@
-function! cargo#Load()
-    " Utility call to get this script loaded, for debugging
-endfunction
-
-function! cargo#cmd(args) abort
-    " Trim trailing spaces. This is necessary since :terminal command parses
-    " trailing spaces as an empty argument.
-    let args = substitute(a:args, '\s\+$', '', '')
-    if exists('g:cargo_shell_command_runner')
-        let cmd = g:cargo_shell_command_runner
-    elseif has('terminal')
-        let cmd = 'terminal'
-    elseif has('nvim')
-        let cmd = 'noautocmd new | terminal'
-    else
-        let cmd = '!'
-    endif
-    execute cmd 'cargo' args
-endfunction
-
-function! s:nearest_cargo(...) abort
-    " If the second argument is not specified, the first argument determines
-    " whether we will start from the current directory or the directory of the
-    " current buffer, otherwise, we start with the provided path on the 
-    " second argument.
-
-    let l:is_getcwd = get(a:, 1, 0)
-    if l:is_getcwd 
-        let l:starting_path = get(a:, 2, getcwd())
-    else
-        let l:starting_path = get(a:, 2, expand('%:p:h'))
-    endif
-
-    return findfile('Cargo.toml', l:starting_path . ';')
-endfunction
-
-function! cargo#nearestCargo(is_getcwd) abort
-    return s:nearest_cargo(a:is_getcwd)
-endfunction
-
-function! cargo#nearestWorkspaceCargo(is_getcwd) abort
-    let l:nearest = s:nearest_cargo(a:is_getcwd)
-    while l:nearest !=# ''
-        for l:line in readfile(l:nearest, '', 0x100)
-            if l:line =~# '\V[workspace]'
-                return l:nearest
-            endif
-        endfor
-        let l:next = fnamemodify(l:nearest, ':p:h:h')
-        let l:nearest = s:nearest_cargo(0, l:next)
-    endwhile
-    return ''
-endfunction
-
-function! cargo#nearestRootCargo(is_getcwd) abort
-    " Try to find a workspace Cargo.toml, and if not found, take the nearest
-    " regular Cargo.toml
-    let l:workspace_cargo = cargo#nearestWorkspaceCargo(a:is_getcwd)
-    if l:workspace_cargo !=# ''
-        return l:workspace_cargo
-    endif
-    return s:nearest_cargo(a:is_getcwd)
-endfunction
-
-
-function! cargo#build(args)
-    call cargo#cmd("build " . a:args)
-endfunction
-
-function! cargo#check(args)
-    call cargo#cmd("check " . a:args)
-endfunction
-
-function! cargo#clean(args)
-    call cargo#cmd("clean " . a:args)
-endfunction
-
-function! cargo#doc(args)
-    call cargo#cmd("doc " . a:args)
-endfunction
-
-function! cargo#new(args)
-    call cargo#cmd("new " . a:args)
-    cd `=a:args`
-endfunction
-
-function! cargo#init(args)
-    call cargo#cmd("init " . a:args)
-endfunction
-
-function! cargo#run(args)
-    call cargo#cmd("run " . a:args)
-endfunction
-
-function! cargo#test(args)
-    call cargo#cmd("test " . a:args)
-endfunction
-
-function! cargo#bench(args)
-    call cargo#cmd("bench " . a:args)
-endfunction
-
-function! cargo#update(args)
-    call cargo#cmd("update " . a:args)
-endfunction
-
-function! cargo#search(args)
-    call cargo#cmd("search " . a:args)
-endfunction
-
-function! cargo#publish(args)
-    call cargo#cmd("publish " . a:args)
-endfunction
-
-function! cargo#install(args)
-    call cargo#cmd("install " . a:args)
-endfunction
-
-function! cargo#runtarget(args)
-    let l:filename = expand('%:p')
-    let l:read_manifest = system('cargo read-manifest')
-    let l:metadata = json_decode(l:read_manifest)
-    let l:targets = get(l:metadata, 'targets', [])
-    let l:did_run = 0
-    for l:target in l:targets
-        let l:src_path = get(l:target, 'src_path', '')
-        let l:kinds = get(l:target, 'kind', [])
-        let l:name = get(l:target, 'name', '')
-        if l:src_path == l:filename
-        if index(l:kinds, 'example') != -1
-            let l:did_run = 1
-            call cargo#run("--example " . shellescape(l:name) . " " . a:args)
-            return
-        elseif index(l:kinds, 'bin') != -1
-            let l:did_run = 1
-            call cargo#run("--bin " . shellescape(l:name) . " " . a:args)
-            return
-        endif
-        endif
-    endfor
-    if l:did_run != 1
-        call cargo#run(a:args)
-        return
-    endif
-endfunction
-
-" vim: set et sw=4 sts=4 ts=8:
diff --git a/sources_non_forked/rust.vim/autoload/cargo/quickfix.vim b/sources_non_forked/rust.vim/autoload/cargo/quickfix.vim
deleted file mode 100644
index fb16fc7..0000000
--- a/sources_non_forked/rust.vim/autoload/cargo/quickfix.vim
+++ /dev/null
@@ -1,26 +0,0 @@
-function! cargo#quickfix#CmdPre() abort
-    if &filetype ==# 'rust' && get(b:, 'current_compiler', '') ==# 'cargo'
-        " Preserve the current directory, and 'lcd' to the nearest Cargo file.
-        let b:rust_compiler_cargo_qf_has_lcd = haslocaldir()
-        let b:rust_compiler_cargo_qf_prev_cd = getcwd()
-        let b:rust_compiler_cargo_qf_prev_cd_saved = 1
-        let l:nearest = fnamemodify(cargo#nearestRootCargo(0), ':h')
-        execute 'lchdir! '.l:nearest
-    else
-        let b:rust_compiler_cargo_qf_prev_cd_saved = 0
-    endif
-endfunction
-
-function! cargo#quickfix#CmdPost() abort
-    if exists("b:rust_compiler_cargo_qf_prev_cd_saved") && b:rust_compiler_cargo_qf_prev_cd_saved
-        " Restore the current directory.
-        if b:rust_compiler_cargo_qf_has_lcd
-            execute 'lchdir! '.b:rust_compiler_cargo_qf_prev_cd
-        else
-            execute 'chdir! '.b:rust_compiler_cargo_qf_prev_cd
-        endif
-        let b:rust_compiler_cargo_qf_prev_cd_saved = 0
-    endif
-endfunction
-
-" vim: set et sw=4 sts=4 ts=8:
diff --git a/sources_non_forked/rust.vim/autoload/rust.vim b/sources_non_forked/rust.vim/autoload/rust.vim
deleted file mode 100644
index 025949c..0000000
--- a/sources_non_forked/rust.vim/autoload/rust.vim
+++ /dev/null
@@ -1,570 +0,0 @@
-" Description: Helper functions for Rust commands/mappings
-" Last Modified: May 27, 2014
-" For bugs, patches and license go to https://github.com/rust-lang/rust.vim
-
-function! rust#Load()
-    " Utility call to get this script loaded, for debugging
-endfunction
-
-function! rust#GetConfigVar(name, default)
-    " Local buffer variable with same name takes predeence over global
-    if has_key(b:, a:name)
-        return get(b:, a:name)
-    endif
-    if has_key(g:, a:name)
-        return get(g:, a:name)
-    endif
-    return a:default
-endfunction
-
-" Include expression {{{1
-
-function! rust#IncludeExpr(fname) abort
-    " Remove leading 'crate::' to deal with 2018 edition style 'use'
-    " statements
-    let l:fname = substitute(a:fname, '^crate::', '', '')
-
-    " Remove trailing colons arising from lines like
-    "
-    "     use foo::{Bar, Baz};
-    let l:fname = substitute(l:fname, ':\+$', '', '')
-
-    " Replace '::' with '/'
-    let l:fname = substitute(l:fname, '::', '/', 'g')
-
-    " When we have
-    "
-    "    use foo::bar::baz;
-    "
-    " we can't tell whether baz is a module or a function; and we can't tell
-    " which modules correspond to files.
-    "
-    " So we work our way up, trying
-    "
-    "     foo/bar/baz.rs
-    "     foo/bar.rs
-    "     foo.rs
-    while l:fname !=# '.'
-        let l:path = findfile(l:fname)
-        if !empty(l:path)
-            return l:fname
-        endif
-        let l:fname = fnamemodify(l:fname, ':h')
-    endwhile
-    return l:fname
-endfunction
-
-" Jump {{{1
-
-function! rust#Jump(mode, function) range
-    let cnt = v:count1
-    normal! m'
-    if a:mode ==# 'v'
-        norm! gv
-    endif
-    let foldenable = &foldenable
-    set nofoldenable
-    while cnt > 0
-        execute "call <SID>Jump_" . a:function . "()"
-        let cnt = cnt - 1
-    endwhile
-    let &foldenable = foldenable
-endfunction
-
-function! s:Jump_Back()
-    call search('{', 'b')
-    keepjumps normal! w99[{
-endfunction
-
-function! s:Jump_Forward()
-    normal! j0
-    call search('{', 'b')
-    keepjumps normal! w99[{%
-    call search('{')
-endfunction
-
-" Run {{{1
-
-function! rust#Run(bang, args)
-    let args = s:ShellTokenize(a:args)
-    if a:bang
-        let idx = index(l:args, '--')
-        if idx != -1
-            let rustc_args = idx == 0 ? [] : l:args[:idx-1]
-            let args = l:args[idx+1:]
-        else
-            let rustc_args = l:args
-            let args = []
-        endif
-    else
-        let rustc_args = []
-    endif
-
-    let b:rust_last_rustc_args = l:rustc_args
-    let b:rust_last_args = l:args
-
-    call s:WithPath(function("s:Run"), rustc_args, args)
-endfunction
-
-function! s:Run(dict, rustc_args, args)
-    let exepath = a:dict.tmpdir.'/'.fnamemodify(a:dict.path, ':t:r')
-    if has('win32')
-        let exepath .= '.exe'
-    endif
-
-    let relpath = get(a:dict, 'tmpdir_relpath', a:dict.path)
-    let rustc_args = [relpath, '-o', exepath] + a:rustc_args
-
-    let rustc = exists("g:rustc_path") ? g:rustc_path : "rustc"
-
-    let pwd = a:dict.istemp ? a:dict.tmpdir : ''
-    let output = s:system(pwd, shellescape(rustc) . " " . join(map(rustc_args, 'shellescape(v:val)')))
-    if output !=# ''
-        echohl WarningMsg
-        echo output
-        echohl None
-    endif
-    if !v:shell_error
-        exe '!' . shellescape(exepath) . " " . join(map(a:args, 'shellescape(v:val)'))
-    endif
-endfunction
-
-" Expand {{{1
-
-function! rust#Expand(bang, args)
-    let args = s:ShellTokenize(a:args)
-    if a:bang && !empty(l:args)
-        let pretty = remove(l:args, 0)
-    else
-        let pretty = "expanded"
-    endif
-    call s:WithPath(function("s:Expand"), pretty, args)
-endfunction
-
-function! s:Expand(dict, pretty, args)
-    try
-        let rustc = exists("g:rustc_path") ? g:rustc_path : "rustc"
-
-        if a:pretty =~? '^\%(everybody_loops$\|flowgraph=\)'
-            let flag = '--xpretty'
-        else
-            let flag = '--pretty'
-        endif
-        let relpath = get(a:dict, 'tmpdir_relpath', a:dict.path)
-        let args = [relpath, '-Z', 'unstable-options', l:flag, a:pretty] + a:args
-        let pwd = a:dict.istemp ? a:dict.tmpdir : ''
-        let output = s:system(pwd, shellescape(rustc) . " " . join(map(args, 'shellescape(v:val)')))
-        if v:shell_error
-            echohl WarningMsg
-            echo output
-            echohl None
-        else
-            new
-            silent put =output
-            1
-            d
-            setl filetype=rust
-            setl buftype=nofile
-            setl bufhidden=hide
-            setl noswapfile
-            " give the buffer a nice name
-            let suffix = 1
-            let basename = fnamemodify(a:dict.path, ':t:r')
-            while 1
-                let bufname = basename
-                if suffix > 1 | let bufname .= ' ('.suffix.')' | endif
-                let bufname .= '.pretty.rs'
-                if bufexists(bufname)
-                    let suffix += 1
-                    continue
-                endif
-                exe 'silent noautocmd keepalt file' fnameescape(bufname)
-                break
-            endwhile
-        endif
-    endtry
-endfunction
-
-function! rust#CompleteExpand(lead, line, pos)
-    if a:line[: a:pos-1] =~# '^RustExpand!\s*\S*$'
-        " first argument and it has a !
-        let list = ["normal", "expanded", "typed", "expanded,identified", "flowgraph=", "everybody_loops"]
-        if !empty(a:lead)
-            call filter(list, "v:val[:len(a:lead)-1] == a:lead")
-        endif
-        return list
-    endif
-
-    return glob(escape(a:lead, "*?[") . '*', 0, 1)
-endfunction
-
-" Emit {{{1
-
-function! rust#Emit(type, args)
-    let args = s:ShellTokenize(a:args)
-    call s:WithPath(function("s:Emit"), a:type, args)
-endfunction
-
-function! s:Emit(dict, type, args)
-    try
-        let output_path = a:dict.tmpdir.'/output'
-
-        let rustc = exists("g:rustc_path") ? g:rustc_path : "rustc"
-
-        let relpath = get(a:dict, 'tmpdir_relpath', a:dict.path)
-        let args = [relpath, '--emit', a:type, '-o', output_path] + a:args
-        let pwd = a:dict.istemp ? a:dict.tmpdir : ''
-        let output = s:system(pwd, shellescape(rustc) . " " . join(map(args, 'shellescape(v:val)')))
-        if output !=# ''
-            echohl WarningMsg
-            echo output
-            echohl None
-        endif
-        if !v:shell_error
-            new
-            exe 'silent keepalt read' fnameescape(output_path)
-            1
-            d
-            if a:type ==# "llvm-ir"
-                setl filetype=llvm
-                let extension = 'll'
-            elseif a:type ==# "asm"
-                setl filetype=asm
-                let extension = 's'
-            endif
-            setl buftype=nofile
-            setl bufhidden=hide
-            setl noswapfile
-            if exists('l:extension')
-                " give the buffer a nice name
-                let suffix = 1
-                let basename = fnamemodify(a:dict.path, ':t:r')
-                while 1
-                    let bufname = basename
-                    if suffix > 1 | let bufname .= ' ('.suffix.')' | endif
-                    let bufname .= '.'.extension
-                    if bufexists(bufname)
-                        let suffix += 1
-                        continue
-                    endif
-                    exe 'silent noautocmd keepalt file' fnameescape(bufname)
-                    break
-                endwhile
-            endif
-        endif
-    endtry
-endfunction
-
-" Utility functions {{{1
-
-" Invokes func(dict, ...)
-" Where {dict} is a dictionary with the following keys:
-"   'path' - The path to the file
-"   'tmpdir' - The path to a temporary directory that will be deleted when the
-"              function returns.
-"   'istemp' - 1 if the path is a file inside of {dict.tmpdir} or 0 otherwise.
-" If {istemp} is 1 then an additional key is provided:
-"   'tmpdir_relpath' - The {path} relative to the {tmpdir}.
-"
-" {dict.path} may be a path to a file inside of {dict.tmpdir} or it may be the
-" existing path of the current buffer. If the path is inside of {dict.tmpdir}
-" then it is guaranteed to have a '.rs' extension.
-function! s:WithPath(func, ...)
-    let buf = bufnr('')
-    let saved = {}
-    let dict = {}
-    try
-        let saved.write = &write
-        set write
-        let dict.path = expand('%')
-        let pathisempty = empty(dict.path)
-
-        " Always create a tmpdir in case the wrapped command wants it
-        let dict.tmpdir = tempname()
-        call mkdir(dict.tmpdir)
-
-        if pathisempty || !saved.write
-            let dict.istemp = 1
-            " if we're doing this because of nowrite, preserve the filename
-            if !pathisempty
-                let filename = expand('%:t:r').".rs"
-            else
-                let filename = 'unnamed.rs'
-            endif
-            let dict.tmpdir_relpath = filename
-            let dict.path = dict.tmpdir.'/'.filename
-
-            let saved.mod = &modified
-            set nomodified
-
-            silent exe 'keepalt write! ' . fnameescape(dict.path)
-            if pathisempty
-                silent keepalt 0file
-            endif
-        else
-            let dict.istemp = 0
-            update
-        endif
-
-        call call(a:func, [dict] + a:000)
-    finally
-        if bufexists(buf)
-            for [opt, value] in items(saved)
-                silent call setbufvar(buf, '&'.opt, value)
-                unlet value " avoid variable type mismatches
-            endfor
-        endif
-        if has_key(dict, 'tmpdir') | silent call s:RmDir(dict.tmpdir) | endif
-    endtry
-endfunction
-
-function! rust#AppendCmdLine(text)
-    call setcmdpos(getcmdpos())
-    let cmd = getcmdline() . a:text
-    return cmd
-endfunction
-
-" Tokenize the string according to sh parsing rules
-function! s:ShellTokenize(text)
-    " states:
-    " 0: start of word
-    " 1: unquoted
-    " 2: unquoted backslash
-    " 3: double-quote
-    " 4: double-quoted backslash
-    " 5: single-quote
-    let l:state = 0
-    let l:current = ''
-    let l:args = []
-    for c in split(a:text, '\zs')
-        if l:state == 0 || l:state == 1 " unquoted
-            if l:c ==# ' '
-                if l:state == 0 | continue | endif
-                call add(l:args, l:current)
-                let l:current = ''
-                let l:state = 0
-            elseif l:c ==# '\'
-                let l:state = 2
-            elseif l:c ==# '"'
-                let l:state = 3
-            elseif l:c ==# "'"
-                let l:state = 5
-            else
-                let l:current .= l:c
-                let l:state = 1
-            endif
-        elseif l:state == 2 " unquoted backslash
-            if l:c !=# "\n" " can it even be \n?
-                let l:current .= l:c
-            endif
-            let l:state = 1
-        elseif l:state == 3 " double-quote
-            if l:c ==# '\'
-                let l:state = 4
-            elseif l:c ==# '"'
-                let l:state = 1
-            else
-                let l:current .= l:c
-            endif
-        elseif l:state == 4 " double-quoted backslash
-            if stridx('$`"\', l:c) >= 0
-                let l:current .= l:c
-            elseif l:c ==# "\n" " is this even possible?
-                " skip it
-            else
-                let l:current .= '\'.l:c
-            endif
-            let l:state = 3
-        elseif l:state == 5 " single-quoted
-            if l:c ==# "'"
-                let l:state = 1
-            else
-                let l:current .= l:c
-            endif
-        endif
-    endfor
-    if l:state != 0
-        call add(l:args, l:current)
-    endif
-    return l:args
-endfunction
-
-function! s:RmDir(path)
-    " sanity check; make sure it's not empty, /, or $HOME
-    if empty(a:path)
-        echoerr 'Attempted to delete empty path'
-        return 0
-    elseif a:path ==# '/' || a:path ==# $HOME
-        let l:path = expand(a:path)
-        if l:path ==# '/' || l:path ==# $HOME
-            echoerr 'Attempted to delete protected path: ' . a:path
-            return 0
-        endif
-    endif
-
-    if !isdirectory(a:path)
-        return 0
-    endif
-
-    " delete() returns 0 when removing file successfully
-    return delete(a:path, 'rf') == 0
-endfunction
-
-" Executes {cmd} with the cwd set to {pwd}, without changing Vim's cwd.
-" If {pwd} is the empty string then it doesn't change the cwd.
-function! s:system(pwd, cmd)
-    let cmd = a:cmd
-    if !empty(a:pwd)
-        let cmd = 'cd ' . shellescape(a:pwd) . ' && ' . cmd
-    endif
-    return system(cmd)
-endfunction
-
-" Playpen Support {{{1
-" Parts of gist.vim by Yasuhiro Matsumoto <mattn.jp@gmail.com> reused
-" gist.vim available under the BSD license, available at
-" http://github.com/mattn/gist-vim
-function! s:has_webapi()
-    if !exists("*webapi#http#post")
-        try
-            call webapi#http#post()
-        catch
-        endtry
-    endif
-    return exists("*webapi#http#post")
-endfunction
-
-function! rust#Play(count, line1, line2, ...) abort
-    redraw
-
-    let l:rust_playpen_url = get(g:, 'rust_playpen_url', 'https://play.rust-lang.org/')
-    let l:rust_shortener_url = get(g:, 'rust_shortener_url', 'https://is.gd/')
-
-    if !s:has_webapi()
-        echohl ErrorMsg | echomsg ':RustPlay depends on webapi.vim (https://github.com/mattn/webapi-vim)' | echohl None
-        return
-    endif
-
-    let bufname = bufname('%')
-    if a:count < 1
-        let content = join(getline(a:line1, a:line2), "\n")
-    else
-        let save_regcont = @"
-        let save_regtype = getregtype('"')
-        silent! normal! gvy
-        let content = @"
-        call setreg('"', save_regcont, save_regtype)
-    endif
-
-    let url = l:rust_playpen_url."?code=".webapi#http#encodeURI(content)
-
-    if strlen(url) > 5000
-        echohl ErrorMsg | echomsg 'Buffer too large, max 5000 encoded characters ('.strlen(url).')' | echohl None
-        return
-    endif
-
-    let payload = "format=simple&url=".webapi#http#encodeURI(url)
-    let res = webapi#http#post(l:rust_shortener_url.'create.php', payload, {})
-    if res.status[0] ==# '2'
-        let url = res.content
-    endif
-
-    let footer = ''
-    if exists('g:rust_clip_command')
-        call system(g:rust_clip_command, url)
-        if !v:shell_error
-            let footer = ' (copied to clipboard)'
-        endif
-    endif
-    redraw | echomsg 'Done: '.url.footer
-endfunction
-
-" Run a test under the cursor or all tests {{{1
-
-" Finds a test function name under the cursor. Returns empty string when a
-" test function is not found.
-function! s:SearchTestFunctionNameUnderCursor() abort
-    let cursor_line = line('.')
-
-    " Find #[test] attribute
-    if search('\m\C#\[test\]', 'bcW') is 0
-        return ''
-    endif
-
-    " Move to an opening brace of the test function
-    let test_func_line = search('\m\C^\s*fn\s\+\h\w*\s*(.\+{$', 'eW')
-    if test_func_line is 0
-        return ''
-    endif
-
-    " Search the end of test function (closing brace) to ensure that the
-    " cursor position is within function definition
-    if maparg('<Plug>(MatchitNormalForward)') ==# ''
-        keepjumps normal! %
-    else
-        " Prefer matchit.vim official plugin to native % since the plugin
-        " provides better behavior than original % (#391)
-        " To load the plugin, run:
-        "   :packadd matchit
-        execute 'keepjumps' 'normal' "\<Plug>(MatchitNormalForward)"
-    endif
-    if line('.') < cursor_line
-        return ''
-    endif
-
-    return matchstr(getline(test_func_line), '\m\C^\s*fn\s\+\zs\h\w*')
-endfunction
-
-function! rust#Test(mods, winsize, all, options) abort
-    let manifest = findfile('Cargo.toml', expand('%:p:h') . ';')
-    if manifest ==# ''
-        return rust#Run(1, '--test ' . a:options)
-    endif
-
-    " <count> defaults to 0, but we prefer an empty string
-    let winsize = a:winsize ? a:winsize : ''
-
-    if has('terminal')
-        if has('patch-8.0.910')
-            let cmd = printf('%s noautocmd %snew | terminal ++curwin ', a:mods, winsize)
-        else
-            let cmd = printf('%s terminal ', a:mods)
-        endif
-    elseif has('nvim')
-        let cmd = printf('%s noautocmd %snew | terminal ', a:mods, winsize)
-    else
-        let cmd = '!'
-        let manifest = shellescape(manifest)
-    endif
-
-    if a:all
-        if a:options ==# ''
-            execute cmd . 'cargo test --manifest-path' manifest
-        else
-            execute cmd . 'cargo test --manifest-path' manifest a:options
-        endif
-        return
-    endif
-
-    let saved = getpos('.')
-    try
-        let func_name = s:SearchTestFunctionNameUnderCursor()
-    finally
-        call setpos('.', saved)
-    endtry
-    if func_name ==# ''
-        echohl ErrorMsg
-        echomsg 'No test function was found under the cursor. Please add ! to command if you want to run all tests'
-        echohl None
-        return
-    endif
-    if a:options ==# ''
-        execute cmd . 'cargo test --manifest-path' manifest func_name
-    else
-        execute cmd . 'cargo test --manifest-path' manifest func_name a:options
-    endif
-endfunction
-
-" }}}1
-
-" vim: set et sw=4 sts=4 ts=8:
diff --git a/sources_non_forked/rust.vim/autoload/rust/debugging.vim b/sources_non_forked/rust.vim/autoload/rust/debugging.vim
deleted file mode 100644
index b39f687..0000000
--- a/sources_non_forked/rust.vim/autoload/rust/debugging.vim
+++ /dev/null
@@ -1,103 +0,0 @@
-" For debugging, inspired by https://github.com/w0rp/rust/blob/master/autoload/rust/debugging.vim
-
-let s:global_variable_list = [
-            \ '_rustfmt_autosave_because_of_config',
-            \ 'ftplugin_rust_source_path',
-            \ 'loaded_syntastic_rust_cargo_checker',
-            \ 'loaded_syntastic_rust_filetype',
-            \ 'loaded_syntastic_rust_rustc_checker',
-            \ 'rust_bang_comment_leader',
-            \ 'rust_cargo_avoid_whole_workspace',
-            \ 'rust_clip_command',
-            \ 'rust_conceal',
-            \ 'rust_conceal_mod_path',
-            \ 'rust_conceal_pub',
-            \ 'rust_fold',
-            \ 'rust_last_args',
-            \ 'rust_last_rustc_args',
-            \ 'rust_original_delimitMate_excluded_regions',
-            \ 'rust_playpen_url',
-            \ 'rust_prev_delimitMate_quotes',
-            \ 'rust_recent_nearest_cargo_tol',
-            \ 'rust_recent_root_cargo_toml',
-            \ 'rust_recommended_style',
-            \ 'rust_set_conceallevel',
-            \ 'rust_set_conceallevel=1',
-            \ 'rust_set_foldmethod',
-            \ 'rust_set_foldmethod=1',
-            \ 'rust_shortener_url',
-            \ 'rustc_makeprg_no_percent',
-            \ 'rustc_path',
-            \ 'rustfmt_autosave',
-            \ 'rustfmt_autosave_if_config_present',
-            \ 'rustfmt_command',
-            \ 'rustfmt_emit_files',
-            \ 'rustfmt_fail_silently',
-            \ 'rustfmt_options',
-            \ 'syntastic_extra_filetypes',
-            \ 'syntastic_rust_cargo_fname',
-            \]
-
-function! s:Echo(message) abort
-    execute 'echo a:message'
-endfunction
-
-function! s:EchoGlobalVariables() abort
-    for l:key in s:global_variable_list
-        if l:key !~# '^_'
-            call s:Echo('let g:' . l:key . ' = ' . string(get(g:, l:key, v:null)))
-        endif
-
-        if has_key(b:, l:key)
-            call s:Echo('let b:' . l:key . ' = ' . string(b:[l:key]))
-        endif
-    endfor
-endfunction
-
-function! rust#debugging#Info() abort
-    call cargo#Load()
-    call rust#Load()
-    call rustfmt#Load()
-    call s:Echo('rust.vim Global Variables:')
-    call s:Echo('')
-    call s:EchoGlobalVariables()
-
-    silent let l:output = system(g:rustfmt_command . ' --version')
-    echo l:output
-
-    let l:rustc = exists("g:rustc_path") ? g:rustc_path : "rustc"
-    silent let l:output = system(l:rustc . ' --version')
-    echo l:output
-
-    silent let l:output = system('cargo --version')
-    echo l:output
-
-    version
-
-    if exists(":SyntasticInfo")
-        echo "----"
-        echo "Info from Syntastic:"
-        execute "SyntasticInfo"
-    endif
-endfunction
-
-function! rust#debugging#InfoToClipboard() abort
-    redir @"
-    silent call rust#debugging#Info()
-    redir END
-
-    call s:Echo('RustInfo copied to your clipboard')
-endfunction
-
-function! rust#debugging#InfoToFile(filename) abort
-    let l:expanded_filename = expand(a:filename)
-
-    redir => l:output
-    silent call rust#debugging#Info()
-    redir END
-
-    call writefile(split(l:output, "\n"), l:expanded_filename)
-    call s:Echo('RustInfo written to ' . l:expanded_filename)
-endfunction
-
-" vim: set et sw=4 sts=4 ts=8:
diff --git a/sources_non_forked/rust.vim/autoload/rust/delimitmate.vim b/sources_non_forked/rust.vim/autoload/rust/delimitmate.vim
deleted file mode 100644
index 7056d53..0000000
--- a/sources_non_forked/rust.vim/autoload/rust/delimitmate.vim
+++ /dev/null
@@ -1,44 +0,0 @@
-let s:delimitMate_extra_excluded_regions = ',rustLifetimeCandidate,rustGenericLifetimeCandidate'
-
-" For this buffer, when delimitMate issues the `User delimitMate_map`
-" event in the autocommand system, add the above-defined extra excluded
-" regions to delimitMate's state, if they have not already been added.
-function! rust#delimitmate#onMap() abort
-    if &filetype !=# 'rust'
-        return
-    endif
-
-    if get(b:, "delimitMate_quotes")
-        let b:rust_prev_delimitMate_quotes = b:delimitMate_quotes
-    endif
-    let b:delimitMate_quotes = "\" `"
-
-    if match(delimitMate#Get("excluded_regions"),
-                \ s:delimitMate_extra_excluded_regions) == -1
-        call delimitMate#Set("excluded_regions",
-                    \delimitMate#Get("excluded_regions").s:delimitMate_extra_excluded_regions)
-    endif
-endfunction
-
-" For this buffer, when delimitMate issues the `User delimitMate_unmap`
-" event in the autocommand system, delete the above-defined extra excluded
-" regions from delimitMate's state (the deletion being idempotent and
-" having no effect if the extra excluded regions are not present in the
-" targeted part of delimitMate's state).
-function! rust#delimitmate#onUnmap() abort
-    if &filetype !=# 'rust'
-        return
-    endif
-
-    if get(b:, "rust_prev_delimitMate_quotes")
-        let b:delimitMate_quotes = b:rust_prev_delimitMate_quotes
-    endif
-
-    call delimitMate#Set("excluded_regions", substitute(
-               \ delimitMate#Get("excluded_regions"),
-               \ '\C\V' . s:delimitMate_extra_excluded_regions,
-               \ '', 'g'))
-endfunction
-
-" vim: set et sw=4 sts=4 ts=8:
-
diff --git a/sources_non_forked/rust.vim/autoload/rust/tags.vim b/sources_non_forked/rust.vim/autoload/rust/tags.vim
deleted file mode 100644
index 0a4cc20..0000000
--- a/sources_non_forked/rust.vim/autoload/rust/tags.vim
+++ /dev/null
@@ -1,18 +0,0 @@
-" Tagbar support code, for the sake of not automatically overriding its
-" configuration in case Universal Ctags is detected.
-
-let s:ctags_is_uctags = 0
-let s:checked_ctags = 0
-
-function! rust#tags#IsUCtags() abort
-    if s:checked_ctags == 0
-        let l:ctags_bin = get(g:, 'tagbar_ctags_bin', 'ctags')
-        if system(l:ctags_bin.' --version') =~? 'universal ctags'
-            let s:ctags_is_uctags = 1
-        endif
-        let s:checked_ctags = 1
-    endif
-    return s:ctags_is_uctags
-endfunction
-
-" vim: set et sw=4 sts=4 ts=8:
diff --git a/sources_non_forked/rust.vim/autoload/rustfmt.vim b/sources_non_forked/rust.vim/autoload/rustfmt.vim
deleted file mode 100644
index 4a5f86c..0000000
--- a/sources_non_forked/rust.vim/autoload/rustfmt.vim
+++ /dev/null
@@ -1,260 +0,0 @@
-" Author: Stephen Sugden <stephen@stephensugden.com>
-"
-" Adapted from https://github.com/fatih/vim-go
-" For bugs, patches and license go to https://github.com/rust-lang/rust.vim
-
-if !exists("g:rustfmt_autosave")
-    let g:rustfmt_autosave = 0
-endif
-
-if !exists("g:rustfmt_command")
-    let g:rustfmt_command = "rustfmt"
-endif
-
-if !exists("g:rustfmt_options")
-    let g:rustfmt_options = ""
-endif
-
-if !exists("g:rustfmt_fail_silently")
-    let g:rustfmt_fail_silently = 0
-endif
-
-function! rustfmt#DetectVersion()
-    " Save rustfmt '--help' for feature inspection
-    silent let s:rustfmt_help = system(g:rustfmt_command . " --help")
-    let s:rustfmt_unstable_features = s:rustfmt_help =~# "--unstable-features"
-
-    " Build a comparable rustfmt version varible out of its `--version` output:
-    silent let l:rustfmt_version_full = system(g:rustfmt_command . " --version")
-    let l:rustfmt_version_list = matchlist(l:rustfmt_version_full,
-        \    '\vrustfmt ([0-9]+[.][0-9]+[.][0-9]+)')
-    if len(l:rustfmt_version_list) < 3
-        let s:rustfmt_version = "0"
-    else
-        let s:rustfmt_version = l:rustfmt_version_list[1]
-    endif
-    return s:rustfmt_version
-endfunction
-
-call rustfmt#DetectVersion()
-
-if !exists("g:rustfmt_emit_files")
-    let g:rustfmt_emit_files = s:rustfmt_version >= "0.8.2"
-endif
-
-if !exists("g:rustfmt_file_lines")
-    let g:rustfmt_file_lines = s:rustfmt_help =~# "--file-lines JSON"
-endif
-
-let s:got_fmt_error = 0
-
-function! rustfmt#Load()
-    " Utility call to get this script loaded, for debugging
-endfunction
-
-function! s:RustfmtWriteMode()
-    if g:rustfmt_emit_files
-        return "--emit=files"
-    else
-        return "--write-mode=overwrite"
-    endif
-endfunction
-
-function! s:RustfmtConfigOptions()
-    let l:rustfmt_toml = findfile('rustfmt.toml', expand('%:p:h') . ';')
-    if l:rustfmt_toml !=# ''
-        return '--config-path '.fnamemodify(l:rustfmt_toml, ":p")
-    endif
-
-    let l:_rustfmt_toml = findfile('.rustfmt.toml', expand('%:p:h') . ';')
-    if l:_rustfmt_toml !=# ''
-        return '--config-path '.fnamemodify(l:_rustfmt_toml, ":p")
-    endif
-
-    " Default to edition 2018 in case no rustfmt.toml was found.
-    return '--edition 2018'
-endfunction
-
-function! s:RustfmtCommandRange(filename, line1, line2)
-    if g:rustfmt_file_lines == 0
-        echo "--file-lines is not supported in the installed `rustfmt` executable"
-        return
-    endif
-
-    let l:arg = {"file": shellescape(a:filename), "range": [a:line1, a:line2]}
-    let l:write_mode = s:RustfmtWriteMode()
-    let l:rustfmt_config = s:RustfmtConfigOptions()
-
-    " FIXME: When --file-lines gets to be stable, add version range checking
-    " accordingly.
-    let l:unstable_features = s:rustfmt_unstable_features ? '--unstable-features' : ''
-
-    let l:cmd = printf("%s %s %s %s %s --file-lines '[%s]' %s", g:rustfmt_command,
-                \ l:write_mode, g:rustfmt_options,
-                \ l:unstable_features, l:rustfmt_config,
-                \ json_encode(l:arg), shellescape(a:filename))
-    return l:cmd
-endfunction
-
-function! s:RustfmtCommand()
-    let write_mode = g:rustfmt_emit_files ? '--emit=stdout' : '--write-mode=display'
-    let config = s:RustfmtConfigOptions()
-    return join([g:rustfmt_command, write_mode, config, g:rustfmt_options])
-endfunction
-
-function! s:DeleteLines(start, end) abort
-    silent! execute a:start . ',' . a:end . 'delete _'
-endfunction
-
-function! s:RunRustfmt(command, tmpname, from_writepre)
-    mkview!
-
-    let l:stderr_tmpname = tempname()
-    call writefile([], l:stderr_tmpname)
-
-    let l:command = a:command . ' 2> ' . l:stderr_tmpname
-
-    if a:tmpname ==# ''
-        " Rustfmt in stdin/stdout mode
-
-        " chdir to the directory of the file
-        let l:has_lcd = haslocaldir()
-        let l:prev_cd = getcwd()
-        execute 'lchdir! '.expand('%:h')
-
-        let l:buffer = getline(1, '$')
-        if exists("*systemlist")
-            silent let out = systemlist(l:command, l:buffer)
-        else
-            silent let out = split(system(l:command,
-                        \ join(l:buffer, "\n")), '\r\?\n')
-        endif
-    else
-        if exists("*systemlist")
-            silent let out = systemlist(l:command)
-        else
-            silent let out = split(system(l:command), '\r\?\n')
-        endif
-    endif
-
-    let l:stderr = readfile(l:stderr_tmpname)
-
-    call delete(l:stderr_tmpname)
-
-    let l:open_lwindow = 0
-    if v:shell_error == 0
-        if a:from_writepre
-            " remove undo point caused via BufWritePre
-            try | silent undojoin | catch | endtry
-        endif
-
-        if a:tmpname ==# ''
-            let l:content = l:out
-        else
-            " take the tmpfile's content, this is better than rename
-            " because it preserves file modes.
-            let l:content = readfile(a:tmpname)
-        endif
-
-        call s:DeleteLines(len(l:content), line('$'))
-        call setline(1, l:content)
-
-        " only clear location list if it was previously filled to prevent
-        " clobbering other additions
-        if s:got_fmt_error
-            let s:got_fmt_error = 0
-            call setloclist(0, [])
-            let l:open_lwindow = 1
-        endif
-    elseif g:rustfmt_fail_silently == 0 && !a:from_writepre
-        " otherwise get the errors and put them in the location list
-        let l:errors = []
-
-        let l:prev_line = ""
-        for l:line in l:stderr
-            " error: expected one of `;` or `as`, found `extern`
-            "  --> src/main.rs:2:1
-            let tokens = matchlist(l:line, '^\s\+-->\s\(.\{-}\):\(\d\+\):\(\d\+\)$')
-            if !empty(tokens)
-                call add(l:errors, {"filename": @%,
-                            \"lnum":	tokens[2],
-                            \"col":	tokens[3],
-                            \"text":	l:prev_line})
-            endif
-            let l:prev_line = l:line
-        endfor
-
-        if !empty(l:errors)
-            call setloclist(0, l:errors, 'r')
-            echohl Error | echomsg "rustfmt returned error" | echohl None
-        else
-            echo "rust.vim: was not able to parse rustfmt messages. Here is the raw output:"
-            echo "\n"
-            for l:line in l:stderr
-                echo l:line
-            endfor
-        endif
-
-        let s:got_fmt_error = 1
-        let l:open_lwindow = 1
-    endif
-
-    " Restore the current directory if needed
-    if a:tmpname ==# ''
-        if l:has_lcd
-            execute 'lchdir! '.l:prev_cd
-        else
-            execute 'chdir! '.l:prev_cd
-        endif
-    endif
-
-    " Open lwindow after we have changed back to the previous directory
-    if l:open_lwindow == 1
-        lwindow
-    endif
-
-    silent! loadview
-endfunction
-
-function! rustfmt#FormatRange(line1, line2)
-    let l:tmpname = tempname()
-    call writefile(getline(1, '$'), l:tmpname)
-    let command = s:RustfmtCommandRange(l:tmpname, a:line1, a:line2)
-    call s:RunRustfmt(command, l:tmpname, v:false)
-    call delete(l:tmpname)
-endfunction
-
-function! rustfmt#Format()
-    call s:RunRustfmt(s:RustfmtCommand(), '', v:false)
-endfunction
-
-function! rustfmt#Cmd()
-    " Mainly for debugging
-    return s:RustfmtCommand()
-endfunction
-
-function! rustfmt#PreWrite()
-    if !filereadable(expand("%@"))
-        return
-    endif
-    if rust#GetConfigVar('rustfmt_autosave_if_config_present', 0)
-        if findfile('rustfmt.toml', '.;') !=# '' || findfile('.rustfmt.toml', '.;') !=# ''
-            let b:rustfmt_autosave = 1
-            let b:_rustfmt_autosave_because_of_config = 1
-        endif
-    else
-        if has_key(b:, '_rustfmt_autosave_because_of_config')
-            unlet b:_rustfmt_autosave_because_of_config
-            unlet b:rustfmt_autosave
-        endif
-    endif
-
-    if !rust#GetConfigVar("rustfmt_autosave", 0)
-        return
-    endif
-
-    call s:RunRustfmt(s:RustfmtCommand(), '', v:true)
-endfunction
-
-
-" vim: set et sw=4 sts=4 ts=8:
diff --git a/sources_non_forked/rust.vim/compiler/cargo.vim b/sources_non_forked/rust.vim/compiler/cargo.vim
deleted file mode 100644
index 87de609..0000000
--- a/sources_non_forked/rust.vim/compiler/cargo.vim
+++ /dev/null
@@ -1,49 +0,0 @@
-" Vim compiler file
-" Compiler:         Cargo Compiler
-" Maintainer:       Damien Radtke <damienradtke@gmail.com>
-" Latest Revision:  2014 Sep 24
-" For bugs, patches and license go to https://github.com/rust-lang/rust.vim
-
-if exists('current_compiler')
-    finish
-endif
-runtime compiler/rustc.vim
-let current_compiler = "cargo"
-
-" vint: -ProhibitAbbreviationOption
-let s:save_cpo = &cpo
-set cpo&vim
-" vint: +ProhibitAbbreviationOption
-
-if exists(':CompilerSet') != 2
-    command -nargs=* CompilerSet setlocal <args>
-endif
-
-if exists('g:cargo_makeprg_params')
-    execute 'CompilerSet makeprg=cargo\ '.escape(g:cargo_makeprg_params, ' \|"').'\ $*'
-else
-    CompilerSet makeprg=cargo\ $*
-endif
-
-augroup RustCargoQuickFixHooks
-    autocmd!
-    autocmd QuickFixCmdPre make call cargo#quickfix#CmdPre()
-    autocmd QuickFixCmdPost make call cargo#quickfix#CmdPost()
-augroup END
-
-" Ignore general cargo progress messages
-CompilerSet errorformat+=
-            \%-G%\\s%#Downloading%.%#,
-            \%-G%\\s%#Compiling%.%#,
-            \%-G%\\s%#Finished%.%#,
-            \%-G%\\s%#error:\ Could\ not\ compile\ %.%#,
-            \%-G%\\s%#To\ learn\ more\\,%.%#,
-            \%-Gnote:\ Run\ with\ \`RUST_BACKTRACE=%.%#,
-            \%.%#panicked\ at\ \\'%m\\'\\,\ %f:%l:%c
-
-" vint: -ProhibitAbbreviationOption
-let &cpo = s:save_cpo
-unlet s:save_cpo
-" vint: +ProhibitAbbreviationOption
-
-" vim: set et sw=4 sts=4 ts=8:
diff --git a/sources_non_forked/rust.vim/compiler/rustc.vim b/sources_non_forked/rust.vim/compiler/rustc.vim
deleted file mode 100644
index 9b70732..0000000
--- a/sources_non_forked/rust.vim/compiler/rustc.vim
+++ /dev/null
@@ -1,57 +0,0 @@
-" Vim compiler file
-" Compiler:         Rust Compiler
-" Maintainer:       Chris Morgan <me@chrismorgan.info>
-" Latest Revision:  2013 Jul 12
-" For bugs, patches and license go to https://github.com/rust-lang/rust.vim
-
-if exists("current_compiler")
-    finish
-endif
-let current_compiler = "rustc"
-
-" vint: -ProhibitAbbreviationOption
-let s:save_cpo = &cpo
-set cpo&vim
-" vint: +ProhibitAbbreviationOption
-
-if exists(":CompilerSet") != 2
-    command -nargs=* CompilerSet setlocal <args>
-endif
-
-if get(g:, 'rustc_makeprg_no_percent', 0)
-    CompilerSet makeprg=rustc
-else
-    if has('patch-7.4.191')
-      CompilerSet makeprg=rustc\ \%:S
-    else
-      CompilerSet makeprg=rustc\ \"%\"
-    endif
-endif
-
-" New errorformat (after nightly 2016/08/10)
-CompilerSet errorformat=
-            \%-G,
-            \%-Gerror:\ aborting\ %.%#,
-            \%-Gerror:\ Could\ not\ compile\ %.%#,
-            \%Eerror:\ %m,
-            \%Eerror[E%n]:\ %m,
-            \%Wwarning:\ %m,
-            \%Inote:\ %m,
-            \%C\ %#-->\ %f:%l:%c,
-            \%E\ \ left:%m,%C\ right:%m\ %f:%l:%c,%Z
-
-" Old errorformat (before nightly 2016/08/10)
-CompilerSet errorformat+=
-            \%f:%l:%c:\ %t%*[^:]:\ %m,
-            \%f:%l:%c:\ %*\\d:%*\\d\ %t%*[^:]:\ %m,
-            \%-G%f:%l\ %s,
-            \%-G%*[\ ]^,
-            \%-G%*[\ ]^%*[~],
-            \%-G%*[\ ]...
-
-" vint: -ProhibitAbbreviationOption
-let &cpo = s:save_cpo
-unlet s:save_cpo
-" vint: +ProhibitAbbreviationOption
-
-" vim: set et sw=4 sts=4 ts=8:
diff --git a/sources_non_forked/rust.vim/ctags/rust.ctags b/sources_non_forked/rust.vim/ctags/rust.ctags
deleted file mode 100644
index d4f474e..0000000
--- a/sources_non_forked/rust.vim/ctags/rust.ctags
+++ /dev/null
@@ -1,11 +0,0 @@
---langdef=Rust
---langmap=Rust:.rs
---regex-Rust=/^[ \t]*(#\[[^\]]\][ \t]*)*(pub[ \t]+)?(extern[ \t]+)?("[^"]+"[ \t]+)?(unsafe[ \t]+)?fn[ \t]+([a-zA-Z0-9_]+)/\6/f,functions,function definitions/
---regex-Rust=/^[ \t]*(pub[ \t]+)?type[ \t]+([a-zA-Z0-9_]+)/\2/T,types,type definitions/
---regex-Rust=/^[ \t]*(pub[ \t]+)?enum[ \t]+([a-zA-Z0-9_]+)/\2/g,enum,enumeration names/
---regex-Rust=/^[ \t]*(pub[ \t]+)?struct[ \t]+([a-zA-Z0-9_]+)/\2/s,structure names/
---regex-Rust=/^[ \t]*(pub[ \t]+)?mod[ \t]+([a-zA-Z0-9_]+)/\2/m,modules,module names/
---regex-Rust=/^[ \t]*(pub[ \t]+)?(static|const)[ \t]+([a-zA-Z0-9_]+)/\3/c,consts,static constants/
---regex-Rust=/^[ \t]*(pub[ \t]+)?trait[ \t]+([a-zA-Z0-9_]+)/\2/t,traits,traits/
---regex-Rust=/^[ \t]*(pub[ \t]+)?impl([ \t\n]*<[^>]*>)?[ \t]+(([a-zA-Z0-9_:]+)[ \t]*(<[^>]*>)?[ \t]+(for)[ \t]+)?([a-zA-Z0-9_]+)/\4 \6 \7/i,impls,trait implementations/
---regex-Rust=/^[ \t]*macro_rules![ \t]+([a-zA-Z0-9_]+)/\1/d,macros,macro definitions/
diff --git a/sources_non_forked/rust.vim/doc/rust.txt b/sources_non_forked/rust.vim/doc/rust.txt
deleted file mode 100644
index 9d5eb8c..0000000
--- a/sources_non_forked/rust.vim/doc/rust.txt
+++ /dev/null
@@ -1,486 +0,0 @@
-*ft_rust.txt*      Filetype plugin for Rust
-
-==============================================================================
-CONTENTS                                                      *rust*
-
-1. Introduction                                                   |rust-intro|
-2. Settings                                                    |rust-settings|
-3. Commands                                                    |rust-commands|
-4. Mappings                                                    |rust-mappings|
-
-==============================================================================
-INTRODUCTION                                                      *rust-intro*
-
-This plugin provides syntax and supporting functionality for the Rust
-filetype. It requires Vim 8 or higher for full functionality. Some commands
-will not work on earlier versions.
-
-==============================================================================
-SETTINGS                                                       *rust-settings*
-
-This plugin has a few variables you can define in your vimrc that change the
-behavior of the plugin.
-
-Some variables can be set buffer local (`:b` prefix), and the buffer local
-will take precedence over the global `g:` counterpart.
-
-                                                                *g:rustc_path*
-g:rustc_path~
-	Set this option to the path to rustc for use in the |:RustRun| and
-	|:RustExpand| commands. If unset, "rustc" will be located in $PATH: >
-	    let g:rustc_path = $HOME."/bin/rustc"
-<
-
-                                                  *g:rustc_makeprg_no_percent*
-g:rustc_makeprg_no_percent~
-	Set this option to 1 to have 'makeprg' default to "rustc" instead of
-	"rustc %": >
-	    let g:rustc_makeprg_no_percent = 1
-<
-
-                                                              *g:rust_conceal*
-g:rust_conceal~
-	Set this option to turn on the basic |conceal| support: >
-	    let g:rust_conceal = 1
-<
-
-                                                     *g:rust_conceal_mod_path*
-g:rust_conceal_mod_path~
-	Set this option to turn on |conceal| for the path connecting token
-	"::": >
-	    let g:rust_conceal_mod_path = 1
-<
-
-                                                          *g:rust_conceal_pub*
-g:rust_conceal_pub~
-	Set this option to turn on |conceal| for the "pub" token: >
-	    let g:rust_conceal_pub = 1
-<
-
-                                                     *g:rust_recommended_style*
-g:rust_recommended_style~
-        Set this option to enable vim indentation and textwidth settings to
-        conform to style conventions of the rust standard library (i.e. use 4
-        spaces for indents and sets 'textwidth' to 99). This option is enabled
-	by default. To disable it: >
-	    let g:rust_recommended_style = 0
-<
-
-                                                                 *g:rust_fold*
-g:rust_fold~
-	Set this option to turn on |folding|: >
-	    let g:rust_fold = 1
-<
-	Value		Effect ~
-	0		No folding
-	1		Braced blocks are folded. All folds are open by
-			default.
-	2		Braced blocks are folded. 'foldlevel' is left at the
-			global value (all folds are closed by default).
-
-                                                  *g:rust_bang_comment_leader*
-g:rust_bang_comment_leader~
-	Set this option to 1 to preserve the leader on multi-line doc comments
-	using the /*! syntax: >
-	    let g:rust_bang_comment_leader = 1
-<
-
-                                                *g:rust_use_custom_ctags_defs*
-g:rust_use_custom_ctags_defs~
-	Set this option to 1 if you have customized ctags definitions for Rust
-	and do not wish for those included with rust.vim to be used: >
-	    let g:rust_use_custom_ctags_defs = 1
-<
-
-	NOTE: rust.vim's built-in definitions are only used for the Tagbar Vim
-	plugin, if you have it installed, AND if Universal Ctags is not
-	detected. This is because Universal Ctags already has built-in
-	support for Rust when used with Tagbar.
-
-	Also, note that when using ctags other than Universal Ctags, it is not
-	automatically used when generating |tags| files that Vim can use to
-	navigate to definitions across different source files. Feel free to
-	copy `rust.vim/ctags/rust.ctags` into your own `~/.ctags` if you wish
-	to generate |tags| files.
-
-
-                                                 *g:ftplugin_rust_source_path*
-g:ftplugin_rust_source_path~
-	Set this option to a path that should be prepended to 'path' for Rust
-	source files: >
-	    let g:ftplugin_rust_source_path = $HOME.'/dev/rust'
-<
-
-                                                       *g:rustfmt_command*
-g:rustfmt_command~
-	Set this option to the name of the 'rustfmt' executable in your $PATH. If
-	not specified it defaults to 'rustfmt' : >
-	    let g:rustfmt_command = 'rustfmt'
-<
-                                                       *g:rustfmt_autosave*
-g:rustfmt_autosave~
-	Set this option to 1 to run |:RustFmt| automatically when saving a
-	buffer. If not specified it defaults to 0 : >
-	    let g:rustfmt_autosave = 0
-<
-	There is also a buffer-local b:rustfmt_autosave that can be set for
-	the same purpose, and can override the global setting.
-
-                                        *g:rustfmt_autosave_if_config_present*
-g:rustfmt_autosave_if_config_present~
-	Set this option to 1 to have *b:rustfmt_autosave* be set automatically
-	if a `rustfmt.toml` file is present in any parent directly leading to
-	the file being edited. If not set, default to 0: >
-	    let g:rustfmt_autosave_if_config_present = 0
-<
-	This is useful to have `rustfmt` only execute on save, on projects
-	that have `rustfmt.toml` configuration.
-
-	There is also a buffer-local b:rustfmt_autosave_if_config_present
-	that can be set for the same purpose, which can overrides the global
-	setting.
-                                                       *g:rustfmt_fail_silently*
-g:rustfmt_fail_silently~
-	Set this option to 1 to prevent 'rustfmt' from populating the
-	|location-list| with errors. If not specified it defaults to 0: >
-	    let g:rustfmt_fail_silently = 0
-<
-                                                       *g:rustfmt_options*
-g:rustfmt_options~
-	Set this option to a string of options to pass to 'rustfmt'. The
-	write-mode is already set to 'overwrite'. If not specified it
-	defaults to '' : >
-	    let g:rustfmt_options = ''
-<
-                                                       *g:rustfmt_emit_files*
-g:rustfmt_emit_files~
-	If not specified rust.vim tries to detect the right parameter to
-	pass to rustfmt based on its reported version. Otherwise, it
-	determines whether to run rustfmt with '--emit=files' (when 1 is
-	provided) instead of '--write-mode=overwrite'. >
-	    let g:rustfmt_emit_files = 0
-
-
-                                                          *g:rust_playpen_url*
-g:rust_playpen_url~
-	Set this option to override the url for the playpen to use: >
-	    let g:rust_playpen_url = 'https://play.rust-lang.org/'
-<
-
-                                                        *g:rust_shortener_url*
-g:rust_shortener_url~
-	Set this option to override the url for the url shortener: >
-	    let g:rust_shortener_url = 'https://is.gd/'
-<
-
-                                                        *g:rust_clip_command*
-g:rust_clip_command~
-	Set this option to the command used in your OS to copy the Rust Play
-	url to the clipboard: >
-	    let g:rust_clip_command = 'xclip -selection clipboard'
-<
-
-                                                       *g:cargo_makeprg_params*
-g:cargo_makeprg_params~
-	Set this option to the string of parameters to pass to cargo. If not
-	specified it defaults to '$*' : >
-	    let g:cargo_makeprg_params = 'build'
-<
-
-                                                  *g:cargo_shell_command_runner*
-g:cargo_shell_command_runner~
-	Set this option to change how to run shell commands for cargo commands
-	|:Cargo|, |:Cbuild|, |:Crun|, ...
-	By default, |:terminal| is used to run shell command in terminal window
-	asynchronously. But if you prefer |:!| for running the commands, it can
-	be specified: >
-	    let g:cargo_shell_command_runner = '!'
-<
-
-
-Integration with Syntastic                                    *rust-syntastic*
---------------------------
-
-This plugin automatically integrates with the Syntastic checker. There are two
-checkers provided: 'rustc', and 'cargo'. The latter invokes 'Cargo' in order to
-build code, and the former delivers a single edited '.rs' file as a compilation
-target directly to the Rust compiler, `rustc`.
-
-Because Cargo is almost exclusively being used for building Rust code these
-days, 'cargo' is the default checker. >
-
-    let g:syntastic_rust_checkers = ['cargo']
-<
-If you would like to change it, you can set `g:syntastic_rust_checkers` to a
-different value.
-                                          *g:rust_cargo_avoid_whole_workspace*
-                                          *b:rust_cargo_avoid_whole_workspace*
-g:rust_cargo_avoid_whole_workspace~
-	When editing a crate that is part of a Cargo workspace, and this
-	option is set to 1 (the default), then 'cargo' will be executed
-	directly in that crate directory instead of in the workspace
-	directory. Setting 0 prevents this behavior - however be aware that if
-	you are working in large workspace, Cargo commands may take more time,
-	plus the Syntastic error list may include all the crates in the
-	workspace. >
-            let g:rust_cargo_avoid_whole_workspace = 0
-<
-                                              *g:rust_cargo_check_all_targets*
-                                              *b:rust_cargo_check_all_targets*
-g:rust_cargo_check_all_targets~
-	When set to 1, the `--all-targets` option will be passed to cargo when
-	Syntastic executes it, allowing the linting of all targets under the
-	package.
-	The default is 0.
-
-                                              *g:rust_cargo_check_all_features*
-                                              *b:rust_cargo_check_all_features*
-g:rust_cargo_check_all_features~
-	When set to 1, the `--all-features` option will be passed to cargo when
-	Syntastic executes it, allowing the linting of all features of the
-	package.
-	The default is 0.
-
-                                                 *g:rust_cargo_check_examples*
-                                                 *b:rust_cargo_check_examples*
-g:rust_cargo_check_examples~
-	When set to 1, the `--examples` option will be passed to cargo when
-	Syntastic executes it, to prevent the exclusion of examples from
-	linting. The examples are normally under the `examples/` directory of
-	the crate.
-	The default is 0.
-
-                                                    *g:rust_cargo_check_tests*
-                                                    *b:rust_cargo_check_tests*
-g:rust_cargo_check_tests~
-	When set to 1, the `--tests` option will be passed to cargo when
-	Syntastic executes it, to prevent the exclusion of tests from linting.
-	The tests are normally under the `tests/` directory of the crate.
-	The default is 0.
-
-                                                  *g:rust_cargo_check_benches*
-                                                  *b:rust_cargo_check_benches*
-g:rust_cargo_check_benches~
-	When set to 1, the `--benches` option will be passed to cargo when
-	Syntastic executes it.  The benches are normally under the `benches/`
-	directory of the crate.
-	The default is 0.
-
-Integration with auto-pairs                                    *rust-auto-pairs*
----------------------------
-
-This plugin automatically configures the auto-pairs plugin not to duplicate
-single quotes, which are used more often for lifetime annotations than for
-single character literals.
-
-                                                  *g:rust_keep_autopairs_default*
-g:rust_keep_autopairs_default~
-
-	Don't override auto-pairs default for the Rust filetype. The default
-	is 0.
-
-==============================================================================
-COMMANDS                                                       *rust-commands*
-
-Invoking Cargo
---------------
-
-This plug defines very simple shortcuts for invoking Cargo from with Vim.
-
-:Cargo <args>                                                       *:Cargo*
-                Runs 'cargo' with the provided arguments.
-
-:Cbuild <args>                                                     *:Cbuild*
-                Shortcut for 'cargo build`.
-
-:Cclean <args>                                                     *:Cclean*
-                Shortcut for 'cargo clean`.
-
-:Cdoc <args>                                                         *:Cdoc*
-                Shortcut for 'cargo doc`.
-
-:Cinit <args>                                                       *:Cinit*
-                Shortcut for 'cargo init`.
-
-:Crun <args>                                                         *:Crun*
-                Shortcut for 'cargo run`.
-
-:Ctest <args>                                                       *:Ctest*
-                Shortcut for 'cargo test`.
-
-:Cupdate <args>                                                   *:Cupdate*
-                Shortcut for 'cargo update`.
-
-:Cbench <args>                                                     *:Cbench*
-                Shortcut for 'cargo bench`.
-
-:Csearch <args>                                                   *:Csearch*
-                Shortcut for 'cargo search`.
-
-:Cpublish <args>                                                 *:Cpublish*
-                Shortcut for 'cargo publish`.
-
-:Cinstall <args>                                                 *:Cinstall*
-                Shortcut for 'cargo install`.
-
-:Cruntarget <args>                                                 *:Cruntarget*
-                Shortcut for 'cargo run --bin' or 'cargo run --example',
-                depending on the currently open buffer.
-
-Formatting
-----------
-
-:RustFmt                                                       *:RustFmt*
-		Runs |g:rustfmt_command| on the current buffer. If
-		|g:rustfmt_options| is set then those will be passed to the
-		executable.
-
-		If |g:rustfmt_fail_silently| is 0 (the default) then it
-		will populate the |location-list| with the errors from
-		|g:rustfmt_command|. If |g:rustfmt_fail_silently| is set to 1
-		then it will not populate the |location-list|.
-
-:RustFmtRange                                                  *:RustFmtRange*
-		Runs |g:rustfmt_command| with selected range. See
-		|:RustFmt| for any other information.
-
-
-Playpen integration
--------------------
-
-:RustPlay                                                          *:RustPlay*
-		This command will only work if you have web-api.vim installed
-		(available at https://github.com/mattn/webapi-vim).  It sends the
-		current selection, or if nothing is selected, the entirety of the
-		current buffer to the Rust playpen, and emits a message with the
-		shortened URL to the playpen.
-
-		|g:rust_playpen_url| is the base URL to the playpen, by default
-		"https://play.rust-lang.org/".
-
-		|g:rust_shortener_url| is the base url for the shorterner, by
-		default "https://is.gd/"
-
-		|g:rust_clip_command| is the command to run to copy the
-		playpen url to the clipboard of your system.
-
-
-Evaluation of a single Rust file
---------------------------------
-
-NOTE: These commands are useful only when working with standalone Rust files,
-which is usually not the case for common Rust development. If you wish to
-building Rust crates from with Vim can should use Vim's make, Syntastic, or
-functionality from other plugins.
-
-
-:RustRun  [args]                                                    *:RustRun*
-:RustRun! [rustc-args] [--] [args]
-		Compiles and runs the current file. If it has unsaved changes,
-		it will be saved first using |:update|. If the current file is
-		an unnamed buffer, it will be written to a temporary file
-		first. The compiled binary is always placed in a temporary
-		directory, but is run from the current directory.
-
-		The arguments given to |:RustRun| will be passed to the
-		compiled binary.
-
-		If ! is specified, the arguments are passed to rustc instead.
-		A "--" argument will separate the rustc arguments from the
-		arguments passed to the binary.
-
-		If |g:rustc_path| is defined, it is used as the path to rustc.
-		Otherwise it is assumed rustc can be found in $PATH.
-
-:RustExpand  [args]                                              *:RustExpand*
-:RustExpand! [TYPE] [args]
-		Expands the current file using --pretty and displays the
-		results in a new split. If the current file has unsaved
-		changes, it will be saved first using |:update|. If the
-		current file is an unnamed buffer, it will be written to a
-		temporary file first.
-
-		The arguments given to |:RustExpand| will be passed to rustc.
-		This is largely intended for specifying various --cfg
-		configurations.
-
-		If ! is specified, the first argument is the expansion type to
-		pass to rustc --pretty. Otherwise it will default to
-		"expanded".
-
-		If |g:rustc_path| is defined, it is used as the path to rustc.
-		Otherwise it is assumed rustc can be found in $PATH.
-
-:RustEmitIr [args]                                               *:RustEmitIr*
-		Compiles the current file to LLVM IR and displays the results
-		in a new split. If the current file has unsaved changes, it
-		will be saved first using |:update|. If the current file is an
-		unnamed buffer, it will be written to a temporary file first.
-
-		The arguments given to |:RustEmitIr| will be passed to rustc.
-
-		If |g:rustc_path| is defined, it is used as the path to rustc.
-		Otherwise it is assumed rustc can be found in $PATH.
-
-:RustEmitAsm [args]                                             *:RustEmitAsm*
-		Compiles the current file to assembly and displays the results
-		in a new split. If the current file has unsaved changes, it
-		will be saved first using |:update|. If the current file is an
-		unnamed buffer, it will be written to a temporary file first.
-
-		The arguments given to |:RustEmitAsm| will be passed to rustc.
-
-		If |g:rustc_path| is defined, it is used as the path to rustc.
-		Otherwise it is assumed rustc can be found in $PATH.
-
-
-Running test(s)
----------------
-
-:[N]RustTest[!] [options]                                       *:RustTest*
-		Runs a test under the cursor when the current buffer is in a
-		cargo project with "cargo test" command. If the command did
-		not find any test function under the cursor, it stops with an
-		error message.
-
-		When N is given, adjust the size of the new window to N lines
-		or columns.
-
-		When ! is given, runs all tests regardless of current cursor
-		position.
-
-		When [options] is given, it is passed to "cargo" command
-		arguments.
-
-		When the current buffer is outside cargo project, the command
-		runs "rustc --test" command instead of "cargo test" as
-		fallback. All tests are run regardless of adding ! since there
-		is no way to run specific test function with rustc. [options]
-		is passed to "rustc" command arguments in the case.
-
-		Takes optional modifiers (see |<mods>|):  >
-		    :tab RustTest
-		    :belowright 16RustTest
-		    :leftabove vert 80RustTest
-<
-rust.vim Debugging
-------------------
-
-:RustInfo                                                          *:RustInfo*
-		Emits debugging info of the Vim Rust plugin.
-
-:RustInfoToClipboard                                      *:RustInfoClipboard*
-		Saves debugging info of the Vim Rust plugin to the default
-		register.
-
-:RustInfoToFile [filename]                                   *:RustInfoToFile*
-		Saves debugging info of the Vim Rust plugin to the the given
-		file, overwritting it.
-
-==============================================================================
-MAPPINGS                                                       *rust-mappings*
-
-This plugin defines mappings for |[[| and |]]| to support hanging indents.
-
-==============================================================================
- vim:tw=78:sw=4:noet:ts=8:ft=help:norl:
diff --git a/sources_non_forked/rust.vim/ftdetect/rust.vim b/sources_non_forked/rust.vim/ftdetect/rust.vim
deleted file mode 100644
index e095093..0000000
--- a/sources_non_forked/rust.vim/ftdetect/rust.vim
+++ /dev/null
@@ -1,15 +0,0 @@
-" vint: -ProhibitAutocmdWithNoGroup
-
-autocmd BufRead,BufNewFile *.rs call s:set_rust_filetype()
-
-if has('patch-8.0.613')
-    autocmd BufRead,BufNewFile Cargo.toml setf FALLBACK cfg
-endif
-
-function! s:set_rust_filetype() abort
-    if &filetype !=# 'rust'
-        set filetype=rust
-    endif
-endfunction
-
-" vim: set et sw=4 sts=4 ts=8:
diff --git a/sources_non_forked/rust.vim/ftplugin/rust.vim b/sources_non_forked/rust.vim/ftplugin/rust.vim
deleted file mode 100644
index ce48116..0000000
--- a/sources_non_forked/rust.vim/ftplugin/rust.vim
+++ /dev/null
@@ -1,200 +0,0 @@
-" Language:     Rust
-" Description:  Vim ftplugin for Rust
-" Maintainer:   Chris Morgan <me@chrismorgan.info>
-" Last Change:  June 08, 2016
-" For bugs, patches and license go to https://github.com/rust-lang/rust.vim
-
-if exists("b:did_ftplugin")
-    finish
-endif
-let b:did_ftplugin = 1
-
-" vint: -ProhibitAbbreviationOption
-let s:save_cpo = &cpo
-set cpo&vim
-" vint: +ProhibitAbbreviationOption
-
-if get(b:, 'current_compiler', '') ==# ''
-    if strlen(findfile('Cargo.toml', '.;')) > 0
-        compiler cargo
-    else
-        compiler rustc
-    endif
-endif
-
-" Variables {{{1
-
-" The rust source code at present seems to typically omit a leader on /*!
-" comments, so we'll use that as our default, but make it easy to switch.
-" This does not affect indentation at all (I tested it with and without
-" leader), merely whether a leader is inserted by default or not.
-if get(g:, 'rust_bang_comment_leader', 0)
-    " Why is the `,s0:/*,mb:\ ,ex:*/` there, you ask? I don't understand why,
-    " but without it, */ gets indented one space even if there were no
-    " leaders. I'm fairly sure that's a Vim bug.
-    setlocal comments=s1:/*,mb:*,ex:*/,s0:/*,mb:\ ,ex:*/,:///,://!,://
-else
-    setlocal comments=s0:/*!,ex:*/,s1:/*,mb:*,ex:*/,:///,://!,://
-endif
-setlocal commentstring=//%s
-setlocal formatoptions-=t formatoptions+=croqnl
-" j was only added in 7.3.541, so stop complaints about its nonexistence
-silent! setlocal formatoptions+=j
-
-" smartindent will be overridden by indentexpr if filetype indent is on, but
-" otherwise it's better than nothing.
-setlocal smartindent nocindent
-
-if get(g:, 'rust_recommended_style', 1)
-    let b:rust_set_style = 1
-    setlocal tabstop=8 shiftwidth=4 softtabstop=4 expandtab
-    setlocal textwidth=99
-endif
-
-setlocal include=\\v^\\s*(pub\\s+)?use\\s+\\zs(\\f\|:)+
-setlocal includeexpr=rust#IncludeExpr(v:fname)
-
-setlocal suffixesadd=.rs
-
-if exists("g:ftplugin_rust_source_path")
-    let &l:path=g:ftplugin_rust_source_path . ',' . &l:path
-endif
-
-if exists("g:loaded_delimitMate")
-    if exists("b:delimitMate_excluded_regions")
-        let b:rust_original_delimitMate_excluded_regions = b:delimitMate_excluded_regions
-    endif
-
-    augroup rust.vim.DelimitMate
-        autocmd!
-
-        autocmd User delimitMate_map   :call rust#delimitmate#onMap()
-        autocmd User delimitMate_unmap :call rust#delimitmate#onUnmap()
-    augroup END
-endif
-
-" Integration with auto-pairs (https://github.com/jiangmiao/auto-pairs)
-if exists("g:AutoPairsLoaded") && !get(g:, 'rust_keep_autopairs_default', 0)
-    let b:AutoPairs = {'(':')', '[':']', '{':'}','"':'"', '`':'`'}
-endif
-
-if has("folding") && get(g:, 'rust_fold', 0)
-    let b:rust_set_foldmethod=1
-    setlocal foldmethod=syntax
-    if g:rust_fold == 2
-        setlocal foldlevel<
-    else
-        setlocal foldlevel=99
-    endif
-endif
-
-if has('conceal') && get(g:, 'rust_conceal', 0)
-    let b:rust_set_conceallevel=1
-    setlocal conceallevel=2
-endif
-
-" Motion Commands {{{1
-
-" Bind motion commands to support hanging indents
-nnoremap <silent> <buffer> [[ :call rust#Jump('n', 'Back')<CR>
-nnoremap <silent> <buffer> ]] :call rust#Jump('n', 'Forward')<CR>
-xnoremap <silent> <buffer> [[ :call rust#Jump('v', 'Back')<CR>
-xnoremap <silent> <buffer> ]] :call rust#Jump('v', 'Forward')<CR>
-onoremap <silent> <buffer> [[ :call rust#Jump('o', 'Back')<CR>
-onoremap <silent> <buffer> ]] :call rust#Jump('o', 'Forward')<CR>
-
-" Commands {{{1
-
-" See |:RustRun| for docs
-command! -nargs=* -complete=file -bang -buffer RustRun call rust#Run(<bang>0, <q-args>)
-
-" See |:RustExpand| for docs
-command! -nargs=* -complete=customlist,rust#CompleteExpand -bang -buffer RustExpand call rust#Expand(<bang>0, <q-args>)
-
-" See |:RustEmitIr| for docs
-command! -nargs=* -buffer RustEmitIr call rust#Emit("llvm-ir", <q-args>)
-
-" See |:RustEmitAsm| for docs
-command! -nargs=* -buffer RustEmitAsm call rust#Emit("asm", <q-args>)
-
-" See |:RustPlay| for docs
-command! -range=% RustPlay :call rust#Play(<count>, <line1>, <line2>, <f-args>)
-
-" See |:RustFmt| for docs
-command! -bar -buffer RustFmt call rustfmt#Format()
-
-" See |:RustFmtRange| for docs
-command! -range -buffer RustFmtRange call rustfmt#FormatRange(<line1>, <line2>)
-
-" See |:RustInfo| for docs
-command! -bar RustInfo call rust#debugging#Info()
-
-" See |:RustInfoToClipboard| for docs
-command! -bar RustInfoToClipboard call rust#debugging#InfoToClipboard()
-
-" See |:RustInfoToFile| for docs
-command! -bar -nargs=1 RustInfoToFile call rust#debugging#InfoToFile(<f-args>)
-
-" See |:RustTest| for docs
-command! -buffer -nargs=* -count -bang RustTest call rust#Test(<q-mods>, <count>, <bang>0, <q-args>)
-
-if !exists("b:rust_last_rustc_args") || !exists("b:rust_last_args")
-    let b:rust_last_rustc_args = []
-    let b:rust_last_args = []
-endif
-
-" Cleanup {{{1
-
-let b:undo_ftplugin = "
-            \ setlocal formatoptions< comments< commentstring< include< includeexpr< suffixesadd<
-            \|if exists('b:rust_set_style')
-                \|setlocal tabstop< shiftwidth< softtabstop< expandtab< textwidth<
-                \|endif
-                \|if exists('b:rust_original_delimitMate_excluded_regions')
-                    \|let b:delimitMate_excluded_regions = b:rust_original_delimitMate_excluded_regions
-                    \|unlet b:rust_original_delimitMate_excluded_regions
-                    \|else
-                        \|unlet! b:delimitMate_excluded_regions
-                        \|endif
-                        \|if exists('b:rust_set_foldmethod')
-                            \|setlocal foldmethod< foldlevel<
-                            \|unlet b:rust_set_foldmethod
-                            \|endif
-                            \|if exists('b:rust_set_conceallevel')
-                                \|setlocal conceallevel<
-                                \|unlet b:rust_set_conceallevel
-                                \|endif
-                                \|unlet! b:rust_last_rustc_args b:rust_last_args
-                                \|delcommand RustRun
-                                \|delcommand RustExpand
-                                \|delcommand RustEmitIr
-                                \|delcommand RustEmitAsm
-                                \|delcommand RustPlay
-                                \|nunmap <buffer> [[
-                                \|nunmap <buffer> ]]
-                                \|xunmap <buffer> [[
-                                \|xunmap <buffer> ]]
-                                \|ounmap <buffer> [[
-                                \|ounmap <buffer> ]]
-                                \|setlocal matchpairs-=<:>
-                                \|unlet b:match_skip
-                                \"
-
-" }}}1
-
-" Code formatting on save
-augroup rust.vim.PreWrite
-    autocmd!
-    autocmd BufWritePre *.rs silent! call rustfmt#PreWrite()
-augroup END
-
-setlocal matchpairs+=<:>
-" For matchit.vim (rustArrow stops `Fn() -> X` messing things up)
-let b:match_skip = 's:comment\|string\|rustCharacter\|rustArrow'
-
-" vint: -ProhibitAbbreviationOption
-let &cpo = s:save_cpo
-unlet s:save_cpo
-" vint: +ProhibitAbbreviationOption
-
-" vim: set et sw=4 sts=4 ts=8:
diff --git a/sources_non_forked/rust.vim/ftplugin/rust/tagbar.vim b/sources_non_forked/rust.vim/ftplugin/rust/tagbar.vim
deleted file mode 100644
index de8a094..0000000
--- a/sources_non_forked/rust.vim/ftplugin/rust/tagbar.vim
+++ /dev/null
@@ -1,40 +0,0 @@
-"
-" Support for Tagbar -- https://github.com/majutsushi/tagbar
-"
-if !exists(':Tagbar') || rust#tags#IsUCtags()
-    finish
-endif
-
-" vint: -ProhibitAbbreviationOption
-let s:save_cpo = &cpo
-set cpo&vim
-" vint: +ProhibitAbbreviationOption
-
-if !exists('g:tagbar_type_rust')
-    let g:tagbar_type_rust = {
-                \ 'ctagstype' : 'rust',
-                \ 'kinds' : [
-                \'T:types',
-                \'f:functions',
-                \'g:enumerations',
-                \'s:structures',
-                \'m:modules',
-                \'c:constants',
-                \'t:traits',
-                \'i:trait implementations',
-                \ ]
-                \ }
-endif
-
-" In case you've updated/customized your ~/.ctags and prefer to use it.
-if !get(g:, 'rust_use_custom_ctags_defs', 0)
-    let g:tagbar_type_rust.deffile = expand('<sfile>:p:h:h:h') . '/ctags/rust.ctags'
-endif
-
-" vint: -ProhibitAbbreviationOption
-let &cpo = s:save_cpo
-unlet s:save_cpo
-" vint: +ProhibitAbbreviationOption
-
-
-" vim: set et sw=4 sts=4 ts=8:
diff --git a/sources_non_forked/rust.vim/indent/rust.vim b/sources_non_forked/rust.vim/indent/rust.vim
deleted file mode 100644
index 6edce73..0000000
--- a/sources_non_forked/rust.vim/indent/rust.vim
+++ /dev/null
@@ -1,284 +0,0 @@
-" Vim indent file
-" Language:         Rust
-" Author:           Chris Morgan <me@chrismorgan.info>
-" Last Change:      2018 Jan 10
-" For bugs, patches and license go to https://github.com/rust-lang/rust.vim
-
-" Only load this indent file when no other was loaded.
-if exists("b:did_indent")
-    finish
-endif
-let b:did_indent = 1
-
-setlocal cindent
-setlocal cinoptions=L0,(s,Ws,J1,j1,m1
-setlocal cinkeys=0{,0},!^F,o,O,0[,0],0(,0)
-" Don't think cinwords will actually do anything at all... never mind
-setlocal cinwords=for,if,else,while,loop,impl,mod,unsafe,trait,struct,enum,fn,extern,macro
-
-" Some preliminary settings
-setlocal nolisp		" Make sure lisp indenting doesn't supersede us
-setlocal autoindent	" indentexpr isn't much help otherwise
-" Also do indentkeys, otherwise # gets shoved to column 0 :-/
-setlocal indentkeys=0{,0},!^F,o,O,0[,0],0(,0)
-
-setlocal indentexpr=GetRustIndent(v:lnum)
-
-" Only define the function once.
-if exists("*GetRustIndent")
-    finish
-endif
-
-" vint: -ProhibitAbbreviationOption
-let s:save_cpo = &cpo
-set cpo&vim
-" vint: +ProhibitAbbreviationOption
-
-" Come here when loading the script the first time.
-
-function! s:get_line_trimmed(lnum)
-    " Get the line and remove a trailing comment.
-    " Use syntax highlighting attributes when possible.
-    " NOTE: this is not accurate; /* */ or a line continuation could trick it
-    let line = getline(a:lnum)
-    let line_len = strlen(line)
-    if has('syntax_items')
-        " If the last character in the line is a comment, do a binary search for
-        " the start of the comment.  synID() is slow, a linear search would take
-        " too long on a long line.
-        if synIDattr(synID(a:lnum, line_len, 1), "name") =~? 'Comment\|Todo'
-            let min = 1
-            let max = line_len
-            while min < max
-                let col = (min + max) / 2
-                if synIDattr(synID(a:lnum, col, 1), "name") =~? 'Comment\|Todo'
-                    let max = col
-                else
-                    let min = col + 1
-                endif
-            endwhile
-            let line = strpart(line, 0, min - 1)
-        endif
-        return substitute(line, "\s*$", "", "")
-    else
-        " Sorry, this is not complete, nor fully correct (e.g. string "//").
-        " Such is life.
-        return substitute(line, "\s*//.*$", "", "")
-    endif
-endfunction
-
-function! s:is_string_comment(lnum, col)
-    if has('syntax_items')
-        for id in synstack(a:lnum, a:col)
-            let synname = synIDattr(id, "name")
-            if synname ==# "rustString" || synname =~# "^rustComment"
-                return 1
-            endif
-        endfor
-    else
-        " without syntax, let's not even try
-        return 0
-    endif
-endfunction
-
-if exists('*shiftwidth')
-    function! s:shiftwidth()
-        return shiftwidth()
-    endfunc
-else
-    function! s:shiftwidth()
-        return &shiftwidth
-    endfunc
-endif
-
-function GetRustIndent(lnum)
-    " Starting assumption: cindent (called at the end) will do it right
-    " normally. We just want to fix up a few cases.
-
-    let line = getline(a:lnum)
-
-    if has('syntax_items')
-        let synname = synIDattr(synID(a:lnum, 1, 1), "name")
-        if synname ==# "rustString"
-            " If the start of the line is in a string, don't change the indent
-            return -1
-        elseif synname =~? '\(Comment\|Todo\)'
-                    \ && line !~# '^\s*/\*'  " not /* opening line
-            if synname =~? "CommentML" " multi-line
-                if line !~# '^\s*\*' && getline(a:lnum - 1) =~# '^\s*/\*'
-                    " This is (hopefully) the line after a /*, and it has no
-                    " leader, so the correct indentation is that of the
-                    " previous line.
-                    return GetRustIndent(a:lnum - 1)
-                endif
-            endif
-            " If it's in a comment, let cindent take care of it now. This is
-            " for cases like "/*" where the next line should start " * ", not
-            " "* " as the code below would otherwise cause for module scope
-            " Fun fact: "  /*\n*\n*/" takes two calls to get right!
-            return cindent(a:lnum)
-        endif
-    endif
-
-    " cindent gets second and subsequent match patterns/struct members wrong,
-    " as it treats the comma as indicating an unfinished statement::
-    "
-    " match a {
-    "     b => c,
-    "         d => e,
-    "         f => g,
-    " };
-
-    " Search backwards for the previous non-empty line.
-    let prevlinenum = prevnonblank(a:lnum - 1)
-    let prevline = s:get_line_trimmed(prevlinenum)
-    while prevlinenum > 1 && prevline !~# '[^[:blank:]]'
-        let prevlinenum = prevnonblank(prevlinenum - 1)
-        let prevline = s:get_line_trimmed(prevlinenum)
-    endwhile
-
-    " A standalone '{', '}', or 'where'
-    let l:standalone_open = line =~# '\V\^\s\*{\s\*\$'
-    let l:standalone_close = line =~# '\V\^\s\*}\s\*\$'
-    let l:standalone_where = line =~# '\V\^\s\*where\s\*\$'
-    if l:standalone_open || l:standalone_close || l:standalone_where
-        " ToDo: we can search for more items than 'fn' and 'if'.
-        let [l:found_line, l:col, l:submatch] =
-                    \ searchpos('\<\(fn\)\|\(if\)\>', 'bnWp')
-        if l:found_line !=# 0
-            " Now we count the number of '{' and '}' in between the match
-            " locations and the current line (there is probably a better
-            " way to compute this).
-            let l:i = l:found_line
-            let l:search_line = strpart(getline(l:i), l:col - 1)
-            let l:opens = 0
-            let l:closes = 0
-            while l:i < a:lnum
-                let l:search_line2 = substitute(l:search_line, '\V{', '', 'g')
-                let l:opens += strlen(l:search_line) - strlen(l:search_line2)
-                let l:search_line3 = substitute(l:search_line2, '\V}', '', 'g')
-                let l:closes += strlen(l:search_line2) - strlen(l:search_line3)
-                let l:i += 1
-                let l:search_line = getline(l:i)
-            endwhile
-            if l:standalone_open || l:standalone_where
-                if l:opens ==# l:closes
-                    return indent(l:found_line)
-                endif
-            else
-                " Expect to find just one more close than an open
-                if l:opens ==# l:closes + 1
-                    return indent(l:found_line)
-                endif
-            endif
-        endif
-    endif
-
-    " A standalone 'where' adds a shift.
-    let l:standalone_prevline_where = prevline =~# '\V\^\s\*where\s\*\$'
-    if l:standalone_prevline_where
-        return indent(prevlinenum) + 4
-    endif
-
-    " Handle where clauses nicely: subsequent values should line up nicely.
-    if prevline[len(prevline) - 1] ==# ","
-                \ && prevline =~# '^\s*where\s'
-        return indent(prevlinenum) + 6
-    endif
-
-    let l:last_prevline_character = prevline[len(prevline) - 1]
-
-    " A line that ends with '.<expr>;' is probably an end of a long list
-    " of method operations.
-    if prevline =~# '\V\^\s\*.' && l:last_prevline_character ==# ';'
-        call cursor(a:lnum - 1, 1)
-        let l:scope_start = searchpair('{\|(', '', '}\|)', 'nbW',
-                    \ 's:is_string_comment(line("."), col("."))')
-        if l:scope_start != 0 && l:scope_start < a:lnum
-            return indent(l:scope_start) + 4
-        endif
-    endif
-
-    if l:last_prevline_character ==# ","
-                \ && s:get_line_trimmed(a:lnum) !~# '^\s*[\[\]{})]'
-                \ && prevline !~# '^\s*fn\s'
-                \ && prevline !~# '([^()]\+,$'
-                \ && s:get_line_trimmed(a:lnum) !~# '^\s*\S\+\s*=>'
-        " Oh ho! The previous line ended in a comma! I bet cindent will try to
-        " take this too far... For now, let's normally use the previous line's
-        " indent.
-
-        " One case where this doesn't work out is where *this* line contains
-        " square or curly brackets; then we normally *do* want to be indenting
-        " further.
-        "
-        " Another case where we don't want to is one like a function
-        " definition with arguments spread over multiple lines:
-        "
-        " fn foo(baz: Baz,
-        "        baz: Baz) // <-- cindent gets this right by itself
-        "
-        " Another case is similar to the previous, except calling a function
-        " instead of defining it, or any conditional expression that leaves
-        " an open paren:
-        "
-        " foo(baz,
-        "     baz);
-        "
-        " if baz && (foo ||
-        "            bar) {
-        "
-        " Another case is when the current line is a new match arm.
-        "
-        " There are probably other cases where we don't want to do this as
-        " well. Add them as needed.
-        return indent(prevlinenum)
-    endif
-
-    if !has("patch-7.4.355")
-        " cindent before 7.4.355 doesn't do the module scope well at all; e.g.::
-        "
-        " static FOO : &'static [bool] = [
-        " true,
-        "	 false,
-        "	 false,
-        "	 true,
-        "	 ];
-        "
-        "	 uh oh, next statement is indented further!
-
-        " Note that this does *not* apply the line continuation pattern properly;
-        " that's too hard to do correctly for my liking at present, so I'll just
-        " start with these two main cases (square brackets and not returning to
-        " column zero)
-
-        call cursor(a:lnum, 1)
-        if searchpair('{\|(', '', '}\|)', 'nbW',
-                    \ 's:is_string_comment(line("."), col("."))') == 0
-            if searchpair('\[', '', '\]', 'nbW',
-                        \ 's:is_string_comment(line("."), col("."))') == 0
-                " Global scope, should be zero
-                return 0
-            else
-                " At the module scope, inside square brackets only
-                "if getline(a:lnum)[0] == ']' || search('\[', '', '\]', 'nW') == a:lnum
-                if line =~# "^\\s*]"
-                    " It's the closing line, dedent it
-                    return 0
-                else
-                    return &shiftwidth
-                endif
-            endif
-        endif
-    endif
-
-    " Fall back on cindent, which does it mostly right
-    return cindent(a:lnum)
-endfunction
-
-" vint: -ProhibitAbbreviationOption
-let &cpo = s:save_cpo
-unlet s:save_cpo
-" vint: +ProhibitAbbreviationOption
-
-" vim: set et sw=4 sts=4 ts=8:
diff --git a/sources_non_forked/rust.vim/plugin/cargo.vim b/sources_non_forked/rust.vim/plugin/cargo.vim
deleted file mode 100644
index efc3876..0000000
--- a/sources_non_forked/rust.vim/plugin/cargo.vim
+++ /dev/null
@@ -1,27 +0,0 @@
-if exists('g:loaded_rust_vim_plugin_cargo')
-    finish
-endif
-let g:loaded_rust_vim_plugin_cargo = 1
-let s:save_cpo = &cpoptions
-set cpoptions&vim
-
-command! -nargs=+ Cargo call cargo#cmd(<q-args>)
-command! -nargs=* Cbuild call cargo#build(<q-args>)
-command! -nargs=* Ccheck call cargo#check(<q-args>)
-command! -nargs=* Cclean call cargo#clean(<q-args>)
-command! -nargs=* Cdoc call cargo#doc(<q-args>)
-command! -nargs=+ Cnew call cargo#new(<q-args>)
-command! -nargs=* Cinit call cargo#init(<q-args>)
-command! -nargs=* Crun call cargo#run(<q-args>)
-command! -nargs=* Ctest call cargo#test(<q-args>)
-command! -nargs=* Cbench call cargo#bench(<q-args>)
-command! -nargs=* Cupdate call cargo#update(<q-args>)
-command! -nargs=* Csearch  call cargo#search(<q-args>)
-command! -nargs=* Cpublish call cargo#publish(<q-args>)
-command! -nargs=* Cinstall call cargo#install(<q-args>)
-command! -nargs=* Cruntarget call cargo#runtarget(<q-args>)
-
-let &cpoptions = s:save_cpo
-unlet s:save_cpo
-
-" vim: set et sw=4 sts=4 ts=8:
diff --git a/sources_non_forked/rust.vim/plugin/rust.vim b/sources_non_forked/rust.vim/plugin/rust.vim
deleted file mode 100644
index 5fe77cc..0000000
--- a/sources_non_forked/rust.vim/plugin/rust.vim
+++ /dev/null
@@ -1,28 +0,0 @@
-" Vim syntastic plugin helper
-" Language:     Rust
-" Maintainer:   Andrew Gallant <jamslam@gmail.com>
-
-if exists('g:loaded_rust_vim')
-    finish
-endif
-let g:loaded_rust_vim = 1
-let s:save_cpo = &cpoptions
-set cpoptions&vim
-
-" This is to let Syntastic know about the Rust filetype.
-" It enables tab completion for the 'SyntasticInfo' command.
-" (This does not actually register the syntax checker.)
-if exists('g:syntastic_extra_filetypes')
-    call add(g:syntastic_extra_filetypes, 'rust')
-else
-    let g:syntastic_extra_filetypes = ['rust']
-endif
-
-if !exists('g:syntastic_rust_checkers')
-    let g:syntastic_rust_checkers = ['cargo']
-endif
-
-let &cpoptions = s:save_cpo
-unlet s:save_cpo
-
-" vim: set et sw=4 sts=4 ts=8:
diff --git a/sources_non_forked/rust.vim/syntax/rust.vim b/sources_non_forked/rust.vim/syntax/rust.vim
deleted file mode 100644
index 4677e21..0000000
--- a/sources_non_forked/rust.vim/syntax/rust.vim
+++ /dev/null
@@ -1,386 +0,0 @@
-" Vim syntax file
-" Language:     Rust
-" Maintainer:   Patrick Walton <pcwalton@mozilla.com>
-" Maintainer:   Ben Blum <bblum@cs.cmu.edu>
-" Maintainer:   Chris Morgan <me@chrismorgan.info>
-" Last Change:  Feb 24, 2016
-" For bugs, patches and license go to https://github.com/rust-lang/rust.vim
-
-if version < 600
-    syntax clear
-elseif exists("b:current_syntax")
-    finish
-endif
-
-" Syntax definitions {{{1
-" Basic keywords {{{2
-syn keyword   rustConditional match if else
-syn keyword   rustRepeat loop while
-" `:syn match` must be used to prioritize highlighting `for` keyword.
-syn match     rustRepeat /\<for\>/
-" Highlight `for` keyword in `impl ... for ... {}` statement. This line must
-" be put after previous `syn match` line to overwrite it.
-syn match     rustKeyword /\%(\<impl\>.\+\)\@<=\<for\>/
-syn keyword   rustRepeat in
-syn keyword   rustTypedef type nextgroup=rustIdentifier skipwhite skipempty
-syn keyword   rustStructure struct enum nextgroup=rustIdentifier skipwhite skipempty
-syn keyword   rustUnion union nextgroup=rustIdentifier skipwhite skipempty contained
-syn match rustUnionContextual /\<union\_s\+\%([^[:cntrl:][:space:][:punct:][:digit:]]\|_\)\%([^[:cntrl:][:punct:][:space:]]\|_\)*/ transparent contains=rustUnion
-syn keyword   rustOperator    as
-syn keyword   rustExistential existential nextgroup=rustTypedef skipwhite skipempty contained
-syn match rustExistentialContextual /\<existential\_s\+type/ transparent contains=rustExistential,rustTypedef
-
-syn match     rustAssert      "\<assert\(\w\)*!" contained
-syn match     rustPanic       "\<panic\(\w\)*!" contained
-syn match     rustAsync       "\<async\%(\s\|\n\)\@="
-syn keyword   rustKeyword     break
-syn keyword   rustKeyword     box
-syn keyword   rustKeyword     continue
-syn keyword   rustKeyword     crate
-syn keyword   rustKeyword     extern nextgroup=rustExternCrate,rustObsoleteExternMod skipwhite skipempty
-syn keyword   rustKeyword     fn nextgroup=rustFuncName skipwhite skipempty
-syn keyword   rustKeyword     impl let
-syn keyword   rustKeyword     macro
-syn keyword   rustKeyword     pub nextgroup=rustPubScope skipwhite skipempty
-syn keyword   rustKeyword     return
-syn keyword   rustKeyword     yield
-syn keyword   rustSuper       super
-syn keyword   rustKeyword     where
-syn keyword   rustUnsafeKeyword unsafe
-syn keyword   rustKeyword     use nextgroup=rustModPath skipwhite skipempty
-" FIXME: Scoped impl's name is also fallen in this category
-syn keyword   rustKeyword     mod trait nextgroup=rustIdentifier skipwhite skipempty
-syn keyword   rustStorage     move mut ref static const
-syn match     rustDefault     /\<default\ze\_s\+\(impl\|fn\|type\|const\)\>/
-syn keyword   rustAwait       await
-syn match     rustKeyword     /\<try\>!\@!/ display
-
-syn keyword rustPubScopeCrate crate contained
-syn match rustPubScopeDelim /[()]/ contained
-syn match rustPubScope /([^()]*)/ contained contains=rustPubScopeDelim,rustPubScopeCrate,rustSuper,rustModPath,rustModPathSep,rustSelf transparent
-
-syn keyword   rustExternCrate crate contained nextgroup=rustIdentifier,rustExternCrateString skipwhite skipempty
-" This is to get the `bar` part of `extern crate "foo" as bar;` highlighting.
-syn match   rustExternCrateString /".*"\_s*as/ contained nextgroup=rustIdentifier skipwhite transparent skipempty contains=rustString,rustOperator
-syn keyword   rustObsoleteExternMod mod contained nextgroup=rustIdentifier skipwhite skipempty
-
-syn match     rustIdentifier  contains=rustIdentifierPrime "\%([^[:cntrl:][:space:][:punct:][:digit:]]\|_\)\%([^[:cntrl:][:punct:][:space:]]\|_\)*" display contained
-syn match     rustFuncName    "\%([^[:cntrl:][:space:][:punct:][:digit:]]\|_\)\%([^[:cntrl:][:punct:][:space:]]\|_\)*" display contained
-
-syn region rustMacroRepeat matchgroup=rustMacroRepeatDelimiters start="$(" end="),\=[*+]" contains=TOP
-syn match rustMacroVariable "$\w\+"
-
-" Reserved (but not yet used) keywords {{{2
-syn keyword   rustReservedKeyword become do priv typeof unsized abstract virtual final override
-
-" Built-in types {{{2
-syn keyword   rustType        isize usize char bool u8 u16 u32 u64 u128 f32
-syn keyword   rustType        f64 i8 i16 i32 i64 i128 str Self
-
-" Things from the libstd v1 prelude (src/libstd/prelude/v1.rs) {{{2
-" This section is just straight transformation of the contents of the prelude,
-" to make it easy to update.
-
-" Reexported core operators {{{3
-syn keyword   rustTrait       Copy Send Sized Sync
-syn keyword   rustTrait       Drop Fn FnMut FnOnce
-
-" Reexported functions {{{3
-" Theres no point in highlighting these; when one writes drop( or drop::< it
-" gets the same highlighting anyway, and if someone writes `let drop = ;` we
-" dont really want *that* drop to be highlighted.
-"syn keyword rustFunction drop
-
-" Reexported types and traits {{{3
-syn keyword rustTrait Box
-syn keyword rustTrait ToOwned
-syn keyword rustTrait Clone
-syn keyword rustTrait PartialEq PartialOrd Eq Ord
-syn keyword rustTrait AsRef AsMut Into From
-syn keyword rustTrait Default
-syn keyword rustTrait Iterator Extend IntoIterator
-syn keyword rustTrait DoubleEndedIterator ExactSizeIterator
-syn keyword rustEnum Option
-syn keyword rustEnumVariant Some None
-syn keyword rustEnum Result
-syn keyword rustEnumVariant Ok Err
-syn keyword rustTrait SliceConcatExt
-syn keyword rustTrait String ToString
-syn keyword rustTrait Vec
-
-" Other syntax {{{2
-syn keyword   rustSelf        self
-syn keyword   rustBoolean     true false
-
-" If foo::bar changes to foo.bar, change this ("::" to "\.").
-" If foo::bar changes to Foo::bar, change this (first "\w" to "\u").
-syn match     rustModPath     "\w\(\w\)*::[^<]"he=e-3,me=e-3
-syn match     rustModPathSep  "::"
-
-syn match     rustFuncCall    "\w\(\w\)*("he=e-1,me=e-1
-syn match     rustFuncCall    "\w\(\w\)*::<"he=e-3,me=e-3 " foo::<T>();
-
-" This is merely a convention; note also the use of [A-Z], restricting it to
-" latin identifiers rather than the full Unicode uppercase. I have not used
-" [:upper:] as it depends upon 'noignorecase'
-"syn match     rustCapsIdent    display "[A-Z]\w\(\w\)*"
-
-syn match     rustOperator     display "\%(+\|-\|/\|*\|=\|\^\|&\||\|!\|>\|<\|%\)=\?"
-" This one isn't *quite* right, as we could have binary-& with a reference
-syn match     rustSigil        display /&\s\+[&~@*][^)= \t\r\n]/he=e-1,me=e-1
-syn match     rustSigil        display /[&~@*][^)= \t\r\n]/he=e-1,me=e-1
-" This isn't actually correct; a closure with no arguments can be `|| { }`.
-" Last, because the & in && isn't a sigil
-syn match     rustOperator     display "&&\|||"
-" This is rustArrowCharacter rather than rustArrow for the sake of matchparen,
-" so it skips the ->; see http://stackoverflow.com/a/30309949 for details.
-syn match     rustArrowCharacter display "->"
-syn match     rustQuestionMark display "?\([a-zA-Z]\+\)\@!"
-
-syn match     rustMacro       '\w\(\w\)*!' contains=rustAssert,rustPanic
-syn match     rustMacro       '#\w\(\w\)*' contains=rustAssert,rustPanic
-
-syn match     rustEscapeError   display contained /\\./
-syn match     rustEscape        display contained /\\\([nrt0\\'"]\|x\x\{2}\)/
-syn match     rustEscapeUnicode display contained /\\u{\%(\x_*\)\{1,6}}/
-syn match     rustStringContinuation display contained /\\\n\s*/
-syn region    rustString      matchgroup=rustStringDelimiter start=+b"+ skip=+\\\\\|\\"+ end=+"+ contains=rustEscape,rustEscapeError,rustStringContinuation
-syn region    rustString      matchgroup=rustStringDelimiter start=+"+ skip=+\\\\\|\\"+ end=+"+ contains=rustEscape,rustEscapeUnicode,rustEscapeError,rustStringContinuation,@Spell
-syn region    rustString      matchgroup=rustStringDelimiter start='b\?r\z(#*\)"' end='"\z1' contains=@Spell
-
-" Match attributes with either arbitrary syntax or special highlighting for
-" derives. We still highlight strings and comments inside of the attribute.
-syn region    rustAttribute   start="#!\?\[" end="\]" contains=@rustAttributeContents,rustAttributeParenthesizedParens,rustAttributeParenthesizedCurly,rustAttributeParenthesizedBrackets,rustDerive
-syn region    rustAttributeParenthesizedParens matchgroup=rustAttribute start="\w\%(\w\)*("rs=e end=")"re=s transparent contained contains=rustAttributeBalancedParens,@rustAttributeContents
-syn region    rustAttributeParenthesizedCurly matchgroup=rustAttribute start="\w\%(\w\)*{"rs=e end="}"re=s transparent contained contains=rustAttributeBalancedCurly,@rustAttributeContents
-syn region    rustAttributeParenthesizedBrackets matchgroup=rustAttribute start="\w\%(\w\)*\["rs=e end="\]"re=s transparent contained contains=rustAttributeBalancedBrackets,@rustAttributeContents
-syn region    rustAttributeBalancedParens matchgroup=rustAttribute start="("rs=e end=")"re=s transparent contained contains=rustAttributeBalancedParens,@rustAttributeContents
-syn region    rustAttributeBalancedCurly matchgroup=rustAttribute start="{"rs=e end="}"re=s transparent contained contains=rustAttributeBalancedCurly,@rustAttributeContents
-syn region    rustAttributeBalancedBrackets matchgroup=rustAttribute start="\["rs=e end="\]"re=s transparent contained contains=rustAttributeBalancedBrackets,@rustAttributeContents
-syn cluster   rustAttributeContents contains=rustString,rustCommentLine,rustCommentBlock,rustCommentLineDocError,rustCommentBlockDocError
-syn region    rustDerive      start="derive(" end=")" contained contains=rustDeriveTrait
-" This list comes from src/libsyntax/ext/deriving/mod.rs
-" Some are deprecated (Encodable, Decodable) or to be removed after a new snapshot (Show).
-syn keyword   rustDeriveTrait contained Clone Hash RustcEncodable RustcDecodable Encodable Decodable PartialEq Eq PartialOrd Ord Rand Show Debug Default FromPrimitive Send Sync Copy
-
-" dyn keyword: It's only a keyword when used inside a type expression, so
-" we make effort here to highlight it only when Rust identifiers follow it
-" (not minding the case of pre-2018 Rust where a path starting with :: can
-" follow).
-"
-" This is so that uses of dyn variable names such as in 'let &dyn = &2'
-" and 'let dyn = 2' will not get highlighted as a keyword.
-syn match     rustKeyword "\<dyn\ze\_s\+\%([^[:cntrl:][:space:][:punct:][:digit:]]\|_\)" contains=rustDynKeyword
-syn keyword   rustDynKeyword  dyn contained
-
-" Number literals
-syn match     rustDecNumber   display "\<[0-9][0-9_]*\%([iu]\%(size\|8\|16\|32\|64\|128\)\)\="
-syn match     rustHexNumber   display "\<0x[a-fA-F0-9_]\+\%([iu]\%(size\|8\|16\|32\|64\|128\)\)\="
-syn match     rustOctNumber   display "\<0o[0-7_]\+\%([iu]\%(size\|8\|16\|32\|64\|128\)\)\="
-syn match     rustBinNumber   display "\<0b[01_]\+\%([iu]\%(size\|8\|16\|32\|64\|128\)\)\="
-
-" Special case for numbers of the form "1." which are float literals, unless followed by
-" an identifier, which makes them integer literals with a method call or field access,
-" or by another ".", which makes them integer literals followed by the ".." token.
-" (This must go first so the others take precedence.)
-syn match     rustFloat       display "\<[0-9][0-9_]*\.\%([^[:cntrl:][:space:][:punct:][:digit:]]\|_\|\.\)\@!"
-" To mark a number as a normal float, it must have at least one of the three things integral values don't have:
-" a decimal point and more numbers; an exponent; and a type suffix.
-syn match     rustFloat       display "\<[0-9][0-9_]*\%(\.[0-9][0-9_]*\)\%([eE][+-]\=[0-9_]\+\)\=\(f32\|f64\)\="
-syn match     rustFloat       display "\<[0-9][0-9_]*\%(\.[0-9][0-9_]*\)\=\%([eE][+-]\=[0-9_]\+\)\(f32\|f64\)\="
-syn match     rustFloat       display "\<[0-9][0-9_]*\%(\.[0-9][0-9_]*\)\=\%([eE][+-]\=[0-9_]\+\)\=\(f32\|f64\)"
-
-" For the benefit of delimitMate
-syn region rustLifetimeCandidate display start=/&'\%(\([^'\\]\|\\\(['nrt0\\\"]\|x\x\{2}\|u{\%(\x_*\)\{1,6}}\)\)'\)\@!/ end=/[[:cntrl:][:space:][:punct:]]\@=\|$/ contains=rustSigil,rustLifetime
-syn region rustGenericRegion display start=/<\%('\|[^[:cntrl:][:space:][:punct:]]\)\@=')\S\@=/ end=/>/ contains=rustGenericLifetimeCandidate
-syn region rustGenericLifetimeCandidate display start=/\%(<\|,\s*\)\@<='/ end=/[[:cntrl:][:space:][:punct:]]\@=\|$/ contains=rustSigil,rustLifetime
-
-"rustLifetime must appear before rustCharacter, or chars will get the lifetime highlighting
-syn match     rustLifetime    display "\'\%([^[:cntrl:][:space:][:punct:][:digit:]]\|_\)\%([^[:cntrl:][:punct:][:space:]]\|_\)*"
-syn match     rustLabel       display "\'\%([^[:cntrl:][:space:][:punct:][:digit:]]\|_\)\%([^[:cntrl:][:punct:][:space:]]\|_\)*:"
-syn match     rustLabel       display "\%(\<\%(break\|continue\)\s*\)\@<=\'\%([^[:cntrl:][:space:][:punct:][:digit:]]\|_\)\%([^[:cntrl:][:punct:][:space:]]\|_\)*"
-syn match   rustCharacterInvalid   display contained /b\?'\zs[\n\r\t']\ze'/
-" The groups negated here add up to 0-255 but nothing else (they do not seem to go beyond ASCII).
-syn match   rustCharacterInvalidUnicode   display contained /b'\zs[^[:cntrl:][:graph:][:alnum:][:space:]]\ze'/
-syn match   rustCharacter   /b'\([^\\]\|\\\(.\|x\x\{2}\)\)'/ contains=rustEscape,rustEscapeError,rustCharacterInvalid,rustCharacterInvalidUnicode
-syn match   rustCharacter   /'\([^\\]\|\\\(.\|x\x\{2}\|u{\%(\x_*\)\{1,6}}\)\)'/ contains=rustEscape,rustEscapeUnicode,rustEscapeError,rustCharacterInvalid
-
-syn match rustShebang /\%^#![^[].*/
-syn region rustCommentLine                                                  start="//"                      end="$"   contains=rustTodo,@Spell
-syn region rustCommentLineDoc                                               start="//\%(//\@!\|!\)"         end="$"   contains=rustTodo,@Spell
-syn region rustCommentLineDocError                                          start="//\%(//\@!\|!\)"         end="$"   contains=rustTodo,@Spell contained
-syn region rustCommentBlock             matchgroup=rustCommentBlock         start="/\*\%(!\|\*[*/]\@!\)\@!" end="\*/" contains=rustTodo,rustCommentBlockNest,@Spell
-syn region rustCommentBlockDoc          matchgroup=rustCommentBlockDoc      start="/\*\%(!\|\*[*/]\@!\)"    end="\*/" contains=rustTodo,rustCommentBlockDocNest,rustCommentBlockDocRustCode,@Spell
-syn region rustCommentBlockDocError     matchgroup=rustCommentBlockDocError start="/\*\%(!\|\*[*/]\@!\)"    end="\*/" contains=rustTodo,rustCommentBlockDocNestError,@Spell contained
-syn region rustCommentBlockNest         matchgroup=rustCommentBlock         start="/\*"                     end="\*/" contains=rustTodo,rustCommentBlockNest,@Spell contained transparent
-syn region rustCommentBlockDocNest      matchgroup=rustCommentBlockDoc      start="/\*"                     end="\*/" contains=rustTodo,rustCommentBlockDocNest,@Spell contained transparent
-syn region rustCommentBlockDocNestError matchgroup=rustCommentBlockDocError start="/\*"                     end="\*/" contains=rustTodo,rustCommentBlockDocNestError,@Spell contained transparent
-
-" FIXME: this is a really ugly and not fully correct implementation. Most
-" importantly, a case like ``/* */*`` should have the final ``*`` not being in
-" a comment, but in practice at present it leaves comments open two levels
-" deep. But as long as you stay away from that particular case, I *believe*
-" the highlighting is correct. Due to the way Vim's syntax engine works
-" (greedy for start matches, unlike Rust's tokeniser which is searching for
-" the earliest-starting match, start or end), I believe this cannot be solved.
-" Oh you who would fix it, don't bother with things like duplicating the Block
-" rules and putting ``\*\@<!`` at the start of them; it makes it worse, as
-" then you must deal with cases like ``/*/**/*/``. And don't try making it
-" worse with ``\%(/\@<!\*\)\@<!``, either...
-
-syn keyword rustTodo contained TODO FIXME XXX NB NOTE
-
-" asm! macro {{{2
-syn region rustAsmMacro matchgroup=rustMacro start="\<asm!\s*(" end=")" contains=rustAsmDirSpec,rustAsmSym,rustAsmConst,rustAsmOptionsGroup,rustComment.*,rustString.*
-
-" Clobbered registers
-syn keyword rustAsmDirSpec in out lateout inout inlateout contained nextgroup=rustAsmReg skipwhite skipempty
-syn region  rustAsmReg start="(" end=")" contained contains=rustString
-
-" Symbol operands
-syn keyword rustAsmSym sym contained nextgroup=rustAsmSymPath skipwhite skipempty
-syn region  rustAsmSymPath start="\S" end=",\|)"me=s-1 contained contains=rustComment.*,rustIdentifier
-
-" Const
-syn region  rustAsmConstBalancedParens start="("ms=s+1 end=")" contained contains=@rustAsmConstExpr
-syn cluster rustAsmConstExpr contains=rustComment.*,rust.*Number,rustString,rustAsmConstBalancedParens
-syn region  rustAsmConst start="const" end=",\|)"me=s-1 contained contains=rustStorage,@rustAsmConstExpr
-
-" Options
-syn region  rustAsmOptionsGroup start="options\s*(" end=")" contained contains=rustAsmOptions,rustAsmOptionsKey
-syn keyword rustAsmOptionsKey options contained
-syn keyword rustAsmOptions pure nomem readonly preserves_flags noreturn nostack att_syntax contained
-
-" Folding rules {{{2
-" Trivial folding rules to begin with.
-" FIXME: use the AST to make really good folding
-syn region rustFoldBraces start="{" end="}" transparent fold
-
-if !exists("b:current_syntax_embed")
-    let b:current_syntax_embed = 1
-    syntax include @RustCodeInComment <sfile>:p:h/rust.vim
-    unlet b:current_syntax_embed
-
-    " Currently regions marked as ```<some-other-syntax> will not get
-    " highlighted at all. In the future, we can do as vim-markdown does and
-    " highlight with the other syntax. But for now, let's make sure we find
-    " the closing block marker, because the rules below won't catch it.
-    syn region rustCommentLinesDocNonRustCode matchgroup=rustCommentDocCodeFence start='^\z(\s*//[!/]\s*```\).\+$' end='^\z1$' keepend contains=rustCommentLineDoc
-
-    " We borrow the rules from rusts src/librustdoc/html/markdown.rs, so that
-    " we only highlight as Rust what it would perceive as Rust (almost; its
-    " possible to trick it if you try hard, and indented code blocks arent
-    " supported because Markdown is a menace to parse and only mad dogs and
-    " Englishmen would try to handle that case correctly in this syntax file).
-    syn region rustCommentLinesDocRustCode matchgroup=rustCommentDocCodeFence start='^\z(\s*//[!/]\s*```\)[^A-Za-z0-9_-]*\%(\%(should_panic\|no_run\|ignore\|allow_fail\|rust\|test_harness\|compile_fail\|E\d\{4}\|edition201[58]\)\%([^A-Za-z0-9_-]\+\|$\)\)*$' end='^\z1$' keepend contains=@RustCodeInComment,rustCommentLineDocLeader
-    syn region rustCommentBlockDocRustCode matchgroup=rustCommentDocCodeFence start='^\z(\%(\s*\*\)\?\s*```\)[^A-Za-z0-9_-]*\%(\%(should_panic\|no_run\|ignore\|allow_fail\|rust\|test_harness\|compile_fail\|E\d\{4}\|edition201[58]\)\%([^A-Za-z0-9_-]\+\|$\)\)*$' end='^\z1$' keepend contains=@RustCodeInComment,rustCommentBlockDocStar
-    " Strictly, this may or may not be correct; this code, for example, would
-    " mishighlight:
-    "
-    "     /**
-    "     ```rust
-    "     println!("{}", 1
-    "     * 1);
-    "     ```
-    "     */
-    "
-    "  but I dont care. Balance of probability, and all that.
-    syn match rustCommentBlockDocStar /^\s*\*\s\?/ contained
-    syn match rustCommentLineDocLeader "^\s*//\%(//\@!\|!\)" contained
-endif
-
-" Default highlighting {{{1
-hi def link rustDecNumber       rustNumber
-hi def link rustHexNumber       rustNumber
-hi def link rustOctNumber       rustNumber
-hi def link rustBinNumber       rustNumber
-hi def link rustIdentifierPrime rustIdentifier
-hi def link rustTrait           rustType
-hi def link rustDeriveTrait     rustTrait
-
-hi def link rustMacroRepeatDelimiters   Macro
-hi def link rustMacroVariable Define
-hi def link rustSigil         StorageClass
-hi def link rustEscape        Special
-hi def link rustEscapeUnicode rustEscape
-hi def link rustEscapeError   Error
-hi def link rustStringContinuation Special
-hi def link rustString        String
-hi def link rustStringDelimiter String
-hi def link rustCharacterInvalid Error
-hi def link rustCharacterInvalidUnicode rustCharacterInvalid
-hi def link rustCharacter     Character
-hi def link rustNumber        Number
-hi def link rustBoolean       Boolean
-hi def link rustEnum          rustType
-hi def link rustEnumVariant   rustConstant
-hi def link rustConstant      Constant
-hi def link rustSelf          Constant
-hi def link rustFloat         Float
-hi def link rustArrowCharacter rustOperator
-hi def link rustOperator      Operator
-hi def link rustKeyword       Keyword
-hi def link rustDynKeyword    rustKeyword
-hi def link rustTypedef       Keyword " More precise is Typedef, but it doesn't feel right for Rust
-hi def link rustStructure     Keyword " More precise is Structure
-hi def link rustUnion         rustStructure
-hi def link rustExistential   rustKeyword
-hi def link rustPubScopeDelim Delimiter
-hi def link rustPubScopeCrate rustKeyword
-hi def link rustSuper         rustKeyword
-hi def link rustUnsafeKeyword Exception
-hi def link rustReservedKeyword Error
-hi def link rustRepeat        Conditional
-hi def link rustConditional   Conditional
-hi def link rustIdentifier    Identifier
-hi def link rustCapsIdent     rustIdentifier
-hi def link rustModPath       Include
-hi def link rustModPathSep    Delimiter
-hi def link rustFunction      Function
-hi def link rustFuncName      Function
-hi def link rustFuncCall      Function
-hi def link rustShebang       Comment
-hi def link rustCommentLine   Comment
-hi def link rustCommentLineDoc SpecialComment
-hi def link rustCommentLineDocLeader rustCommentLineDoc
-hi def link rustCommentLineDocError Error
-hi def link rustCommentBlock  rustCommentLine
-hi def link rustCommentBlockDoc rustCommentLineDoc
-hi def link rustCommentBlockDocStar rustCommentBlockDoc
-hi def link rustCommentBlockDocError Error
-hi def link rustCommentDocCodeFence rustCommentLineDoc
-hi def link rustAssert        PreCondit
-hi def link rustPanic         PreCondit
-hi def link rustMacro         Macro
-hi def link rustType          Type
-hi def link rustTodo          Todo
-hi def link rustAttribute     PreProc
-hi def link rustDerive        PreProc
-hi def link rustDefault       StorageClass
-hi def link rustStorage       StorageClass
-hi def link rustObsoleteStorage Error
-hi def link rustLifetime      Special
-hi def link rustLabel         Label
-hi def link rustExternCrate   rustKeyword
-hi def link rustObsoleteExternMod Error
-hi def link rustQuestionMark  Special
-hi def link rustAsync         rustKeyword
-hi def link rustAwait         rustKeyword
-hi def link rustAsmDirSpec    rustKeyword
-hi def link rustAsmSym        rustKeyword
-hi def link rustAsmOptions    rustKeyword
-hi def link rustAsmOptionsKey rustAttribute
-
-" Other Suggestions:
-" hi rustAttribute ctermfg=cyan
-" hi rustDerive ctermfg=cyan
-" hi rustAssert ctermfg=yellow
-" hi rustPanic ctermfg=red
-" hi rustMacro ctermfg=magenta
-
-syn sync minlines=200
-syn sync maxlines=500
-
-let b:current_syntax = "rust"
-
-" vim: set et sw=4 sts=4 ts=8:
diff --git a/sources_non_forked/rust.vim/syntax_checkers/rust/cargo.vim b/sources_non_forked/rust.vim/syntax_checkers/rust/cargo.vim
deleted file mode 100644
index f7b6953..0000000
--- a/sources_non_forked/rust.vim/syntax_checkers/rust/cargo.vim
+++ /dev/null
@@ -1,93 +0,0 @@
-" Vim syntastic plugin
-" Language:     Rust
-" Maintainer:   Julien Levesy <jlevesy@gmail.com>
-"
-" See for details on how to add an external Syntastic checker:
-" https://github.com/scrooloose/syntastic/wiki/Syntax-Checker-Guide#external
-
-if exists("g:loaded_syntastic_rust_cargo_checker")
-    finish
-endif
-
-let g:loaded_syntastic_rust_cargo_checker = 1
-
-" Force syntastic to call cargo without a specific file name
-let g:syntastic_rust_cargo_fname = ""
-
-let s:save_cpo = &cpo
-set cpo&vim
-
-function! SyntaxCheckers_rust_cargo_IsAvailable() dict
-    if exists("*syntastic#util#getVersion")
-        echom "rust.vim: version of Syntastic is too old. Needs to be at least 3.7.0."
-        return v:false
-    endif
-
-    return executable(self.getExec()) &&
-                \ syntastic#util#versionIsAtLeast(self.getVersion(), [0, 16, 0])
-endfunction
-
-function! SyntaxCheckers_rust_cargo_GetLocList() dict
-    let makeprg = self.makeprgBuild({ "args": "check" })
-    let l:root_cargo_toml = cargo#nearestRootCargo(0)
-    let l:nearest_cargo_toml = cargo#nearestCargo(0)
-    let b:rust_recent_root_cargo_toml = l:root_cargo_toml
-    let b:rust_recent_nearest_cargo_toml = l:nearest_cargo_toml
-
-    " All pathname prints are relative to the Cargo.toml of the workspace, if
-    " there is a workspace, otherwise they are relative to the Cargo.toml of
-    " the single crate. Where to actually execute under these varying
-    " circumtances 'cargo' is determined here, and controlled by
-    " configuration.
-
-    if rust#GetConfigVar('rust_cargo_avoid_whole_workspace', 1)
-        if l:root_cargo_toml !=# l:nearest_cargo_toml
-            let makeprg = "cd " . fnamemodify(l:nearest_cargo_toml, ":p:h")
-                        \ . " && " . makeprg
-        endif
-    else
-        let makeprg = "cd " . fnamemodify(l:root_cargo_toml, ":p:h")
-                    \ . " && " . makeprg
-    endif
-
-    let l:check_all_targets = rust#GetConfigVar('rust_cargo_check_all_targets', 0)
-    let l:check_all_features = rust#GetConfigVar('rust_cargo_check_all_features', 0)
-    let l:check_examples = rust#GetConfigVar('rust_cargo_check_examples', 0)
-    let l:check_tests = rust#GetConfigVar('rust_cargo_check_tests', 0)
-    let l:check_benches = rust#GetConfigVar('rust_cargo_check_benches', 0)
-
-    let makeprg = makeprg. ' '
-                \  . (l:check_all_targets ? ' --all-targets' : '')
-                \  . (l:check_all_features ? ' --all-features' : '')
-                \  . (l:check_benches ? ' --benches' : '')
-                \  . (l:check_examples ? ' --examples' : '')
-                \  . (l:check_tests ? ' --tests' : '')
-
-    " Ignored patterns, and blank lines
-    let errorformat  =
-                \ '%-G,' .
-                \ '%-Gerror: aborting %.%#,' .
-                \ '%-Gerror: Could not compile %.%#,'
-
-    " Meaningful lines (errors, notes, warnings, contextual information)
-    let errorformat .=
-                \ '%Eerror: %m,' .
-                \ '%Eerror[E%n]: %m,' .
-                \ '%Wwarning: %m,' .
-                \ '%Inote: %m,' .
-                \ '%C %#--> %f:%l:%c'
-
-    return SyntasticMake({
-                \ 'makeprg': makeprg,
-                \ 'cwd': fnamemodify(l:root_cargo_toml, ":p:h:."),
-                \ 'errorformat': errorformat })
-endfunction
-
-call g:SyntasticRegistry.CreateAndRegisterChecker({
-            \ 'filetype': 'rust',
-            \ 'name': 'cargo'})
-
-let &cpo = s:save_cpo
-unlet s:save_cpo
-
-" vim: set et sw=4 sts=4 ts=8:
diff --git a/sources_non_forked/rust.vim/syntax_checkers/rust/rustc.vim b/sources_non_forked/rust.vim/syntax_checkers/rust/rustc.vim
deleted file mode 100644
index d60a3d3..0000000
--- a/sources_non_forked/rust.vim/syntax_checkers/rust/rustc.vim
+++ /dev/null
@@ -1,54 +0,0 @@
-" Vim syntastic plugin
-" Language:     Rust
-" Maintainer:   Andrew Gallant <jamslam@gmail.com>
-"
-" See for details on how to add an external Syntastic checker:
-" https://github.com/scrooloose/syntastic/wiki/Syntax-Checker-Guide#external
-
-if exists("g:loaded_syntastic_rust_rustc_checker")
-    finish
-endif
-let g:loaded_syntastic_rust_rustc_checker = 1
-
-" vint: -ProhibitAbbreviationOption
-let s:save_cpo = &cpo
-set cpo&vim
-" vint: +ProhibitAbbreviationOption
-
-function! SyntaxCheckers_rust_rustc_GetLocList() dict
-    let makeprg = self.makeprgBuild({})
-
-    " Old errorformat (before nightly 2016/08/10)
-    let errorformat  =
-                \ '%E%f:%l:%c: %\d%#:%\d%# %.%\{-}error:%.%\{-} %m,'   .
-                \ '%W%f:%l:%c: %\d%#:%\d%# %.%\{-}warning:%.%\{-} %m,' .
-                \ '%C%f:%l %m'
-
-    " New errorformat (after nightly 2016/08/10)
-    let errorformat  .=
-                \ ',' .
-                \ '%-G,' .
-                \ '%-Gerror: aborting %.%#,' .
-                \ '%-Gerror: Could not compile %.%#,' .
-                \ '%Eerror: %m,' .
-                \ '%Eerror[E%n]: %m,' .
-                \ '%-Gwarning: the option `Z` is unstable %.%#,' .
-                \ '%Wwarning: %m,' .
-                \ '%Inote: %m,' .
-                \ '%C %#--> %f:%l:%c'
-
-    return SyntasticMake({
-                \ 'makeprg': makeprg,
-                \ 'errorformat': errorformat })
-endfunction
-
-call g:SyntasticRegistry.CreateAndRegisterChecker({
-            \ 'filetype': 'rust',
-            \ 'name': 'rustc'})
-
-" vint: -ProhibitAbbreviationOption
-let &cpo = s:save_cpo
-unlet s:save_cpo
-" vint: +ProhibitAbbreviationOption
-
-" vim: set et sw=4 sts=4 ts=8:
diff --git a/sources_non_forked/rust.vim/test/.gitignore b/sources_non_forked/rust.vim/test/.gitignore
deleted file mode 100644
index e69de29..0000000
diff --git a/sources_non_forked/rust.vim/test/Dockerfile b/sources_non_forked/rust.vim/test/Dockerfile
deleted file mode 100644
index c84c49e..0000000
--- a/sources_non_forked/rust.vim/test/Dockerfile
+++ /dev/null
@@ -1,34 +0,0 @@
-# This is brought as reference, to be able to reproduce a new image
-
-FROM alonid/vim-testbed:10
-
-RUN install_vim -tag v7.4.052 -name vim74-trusty -build \
-                -tag v8.0.1850 -name vim80 -build \
-                -tag v8.1.0105 -name vim81 -build \
-                -tag neovim:v0.1.7 -build \
-                -tag neovim:v0.2.2 -build
-
-ENV PACKAGES="\
-    bash \
-    git \
-    python \
-    python2-pip \
-    curl \
-"
-
-RUN dnf install -y $PACKAGES
-
-RUN pip install vim-vint==0.3.19
-
-RUN export HOME=/rust ; mkdir $HOME ; curl https://sh.rustup.rs -sSf | sh -s -- -y
-
-RUN chown vimtest.vimtest -R /rust
-
-RUN (dnf remove -y gcc \*-devel ; \
-     dnf install -y gpm msgpack libvterm libtermkey unibilium ) || true
-RUN dnf clean all
-
-RUN echo "export PATH=~/.cargo/bin:$PATH" >> ~/.bashrc
-
-RUN git clone https://github.com/da-x/vader.vim vader && \
-    cd vader && git checkout v2017-12-26
diff --git a/sources_non_forked/rust.vim/test/coverage.vader b/sources_non_forked/rust.vim/test/coverage.vader
deleted file mode 100644
index 84734e7..0000000
--- a/sources_non_forked/rust.vim/test/coverage.vader
+++ /dev/null
@@ -1,24 +0,0 @@
-Given rust (Some Rust code):
-  fn main() {
-      println!("Hello World\n")
-  }
-
-Execute (RustInfo - call it to see that it works):
-  redir => m
-  silent RustInfo
-  redir END
-  Log m
-
-Execute (RustEmitAsm - see that we actually get assembly output):
-  silent! w test.rs
-  silent! e! test.rs
-  redir => m
-  silent! RustEmitAsm
-  redir END
-  AssertEqual 'asm', &filetype
-  normal! ggVGy:q<CR>
-  AssertEqual 1,(@" =~# '\V.section')
-  bd
-  call delete('test.rs')
-
-# TODO: a lot more tests
diff --git a/sources_non_forked/rust.vim/test/indent.vader b/sources_non_forked/rust.vim/test/indent.vader
deleted file mode 100644
index 91f6580..0000000
--- a/sources_non_forked/rust.vim/test/indent.vader
+++ /dev/null
@@ -1,292 +0,0 @@
-Given rust:
-  fn main() {
-        let a = 2;
-      println!("Hello World\n")
-  }
-
-Do:
-  vip=
-
-Expect rust (very basic indentation result):
-  fn main() {
-      let a = 2;
-      println!("Hello World\n")
-  }
-
-############################################
-# Issue #195
-
-Given rust:
-  fn main() {
-      let paths: Vec<_> = ({
-              fs::read_dir("test_data")
-                  .unwrap()
-                  .cloned()
-          })
-          .collect();
-
-      println!("Hello World\n");
-  }
-
-Do:
-  /collect\<cr>
-  ostatement();\<ESC>\<ESC>
-
-Expect rust (issue #195):
-  fn main() {
-      let paths: Vec<_> = ({
-              fs::read_dir("test_data")
-                  .unwrap()
-                  .cloned()
-          })
-          .collect();
-      statement();
-
-      println!("Hello World\n");
-  }
-
-############################################
-# Issue #189
-
-Given rust:
-  impl X for {
-      pub fn get<Q>(&self, key: &Q) -> Option<Entry<K, V>>
-      where
-          K: Borrow<Q>,
-          Q: Ord + ?Sized,
-      {
-          self.inner.get(key).map(Entry::new)
-      }
-  }
-
-Do:
-  vip=
-
-Expect rust (issue #189):
-  impl X for {
-      pub fn get<Q>(&self, key: &Q) -> Option<Entry<K, V>>
-      where
-          K: Borrow<Q>,
-          Q: Ord + ?Sized,
-      {
-          self.inner.get(key).map(Entry::new)
-      }
-  }
-
-############################################
-# Issue #189b
-
-Given rust:
-  impl X for {
-      pub fn get<Q>(&self, key: &Q) -> Option<Entry<K, V>>
-      where
-          K: Borrow<Q>,
-          Q: Ord + ?Sized
-      {
-          self.inner.get(key).map(Entry::new)
-      }
-  }
-
-Do:
-  vip=
-
-Expect rust (issue #189b):
-  impl X for {
-      pub fn get<Q>(&self, key: &Q) -> Option<Entry<K, V>>
-      where
-          K: Borrow<Q>,
-          Q: Ord + ?Sized
-      {
-          self.inner.get(key).map(Entry::new)
-      }
-  }
-
-############################################
-# Issue #189c
-
-Given rust:
-  impl X for {
-      pub fn get<Q>(&self, key: &Q) -> Option<Entry<K, V>>
-          where K: Borrow<Q>, Q: Ord + ?Sized
-      {
-          self.inner.get(key).map(Entry::new)
-      }
-  }
-
-Do:
-  vip=
-
-Expect rust (issue #189b):
-  impl X for {
-      pub fn get<Q>(&self, key: &Q) -> Option<Entry<K, V>>
-          where K: Borrow<Q>, Q: Ord + ?Sized
-      {
-          self.inner.get(key).map(Entry::new)
-      }
-  }
-
-
-############################################
-# Issue #149
-
-Given rust:
-  fn test() {
-      let t = "a
-      wah";
-  }
-
-Do:
-  /wah\<cr>
-  i#\<ESC>\<ESC>
-  /;\<cr>o
-  statement();\<ESC>\<ESC>
-
-# Disabled
-# Expect rust (issue #149):
-  fn test() {
-      let t = "a
-      #wah";
-      statement();
-  }
-
-
-############################################
-# Issue #77
-
-Given rust:
-  fn test() {
-  }
-
-Do:
-  of(x, y,\<CR>z);\<CR>
-  f((x, y),\<CR>z);\<CR>
-
-# Disabled
-# Expect rust (issue #77):
-  fn test() {
-      f(x, y,
-        z);
-      f((x, y),
-        z);
-
-  }
-
-############################################
-# Issue #44
-
-Given rust:
-  fn main() {
-      a
-
-      let philosophers = vec![
-          Philosopher::new("Judith Butler"),
-          Philosopher::new("Gilles Deleuze"),
-          Philosopher::new("Karl Marx"),
-          Philosopher::new("Emma Goldman"),
-          Philosopher::new("Michel Foucault"),
-      ];
-  }
-
-Do:
-  /let\<CR>
-  vip=
-
-# Disabled
-# Expect rust (issue #44):
-  fn main() {
-      a
-
-      let philosophers = vec![
-          Philosopher::new("Judith Butler"),
-          Philosopher::new("Gilles Deleuze"),
-          Philosopher::new("Karl Marx"),
-          Philosopher::new("Emma Goldman"),
-          Philosopher::new("Michel Foucault"),
-      ];
-  }
-
-############################################
-# Issue #5
-
-Given rust:
-  fn f() {
-      if x &&
-          y {
-      }
-  }
-
-Do:
-  vip=
-
-Expect rust (issue #5):
-  fn f() {
-      if x &&
-          y {
-      }
-  }
-
-############################################
-# Issue #366
-
-Given rust:
-  fn f() {
-      g(|_| {
-          h();
-      })
-      .unwrap();
-      h();
-  }
-
-Do:
-  vip=
-
-Expect rust (issue #366):
-  fn f() {
-      g(|_| {
-          h();
-      })
-      .unwrap();
-      h();
-  }
-
-Given rust:
-  fn f() {
-      let a = g(|_| {
-              h();
-          })
-          .unwrap();
-      h();
-  }
-
-Do:
-  vip=
-
-Expect rust (issue #366, variation #2):
-  fn f() {
-      let a = g(|_| {
-          h();
-      })
-      .unwrap();
-      h();
-  }
-
-############################################
-
-Given rust:
-  fn f() {
-      let mut state = State::new(
-          backend,
-          header.clone(),
-      ).expect("Something");
-  }
-
-Do:
-  vip=
-
-Expect rust (Trailing comma in call):
-  fn f() {
-      let mut state = State::new(
-          backend,
-          header.clone(),
-      ).expect("Something");
-  }
diff --git a/sources_non_forked/rust.vim/test/run-tests b/sources_non_forked/rust.vim/test/run-tests
deleted file mode 100644
index a8c63b6..0000000
--- a/sources_non_forked/rust.vim/test/run-tests
+++ /dev/null
@@ -1,105 +0,0 @@
-#!/usr/bin/env python
-
-import os
-import sys
-
-REPO = "alonid/vim-testbed"
-TAG = "10-rust.vim"
-IMAGE = "%s:%s" % (REPO, TAG)
-
-class Error(Exception):
-    pass
-
-def system(cmd, capture=False, ok_fail=False):
-    if capture:
-        f = os.popen(cmd)
-        d = f.read()
-        return d
-
-    res = os.system(cmd)
-    if res != 0:
-        if ok_fail:
-            return res
-
-        raise Error("Error executing: %s" % (cmd, ))
-    return 0
-
-def root():
-    return os.path.dirname(os.path.dirname(os.path.realpath(__file__)))
-
-def prep():
-    d = os.path.join(root(), "test")
-    for i in [".cargo", ".rustup", ".multirust"]:
-        l = os.path.join(d, i)
-        if not os.path.lexists(l):
-            os.symlink("/rust/" + i, l)
-
-    l = os.path.join(root(), "test/.vimrc")
-    if not os.path.lexists(l):
-        os.symlink("vimrc", l)
-
-    if not os.path.exists(os.path.join(d, ".profile")):
-        f = open(os.path.join(d, ".profile"), "w")
-        f.write('export PATH="$HOME/.cargo/bin:$PATH"\n')
-        f.close()
-
-def docker_run(cmd, interactive=False, ok_fail=False):
-    prep()
-    d = root()
-    params = "-v %s:/testplugin -v %s/test:/home/vimtest" % (d, d)
-    params += " -e HOME=/home/vimtest"
-    if not interactive:
-        params += " -a stderr"
-    params += " -e VADER_OUTPUT_FILE=/dev/stderr"
-    params += " -u %s" % (os.getuid(), )
-    params += " -w /testplugin"
-    if interactive:
-        interactive_str = "-it"
-    else:
-        interactive_str = ""
-    return system("docker run %s --rm %s %s %s" % (interactive_str, params, IMAGE, cmd),
-            ok_fail=ok_fail)
-
-def image_exists():
-    r = system("docker images -q %s" % (IMAGE, ), capture=True)
-    return len(r.strip().splitlines()) >= 1
-
-def tests_on_docker():
-    res = docker_run("bash -lc 'python /home/vimtest/run-tests inside-docker'", ok_fail=True)
-    if res == 0:
-        print "Tests OK"
-    else:
-        print "Tests Failed"
-        sys.exit(1)
-
-def inside_docker():
-    res = system("/vim-build/bin/vim80 --not-a-term '+Vader! test/*.vader'", ok_fail=True)
-    if res != 0:
-        sys.exit(1)
-
-def run_with_vimrc(vimrc):
-    res = system("vim -u %s --not-a-term '+Vader! test/*.vader'" % (vimrc, ), ok_fail=True)
-    if res != 0:
-        sys.exit(1)
-
-def main():
-    if sys.argv[1:] == ["inside-docker"]:
-        inside_docker()
-        return
-
-    if sys.argv[1:2] == ["run-with-vimrc"]:
-        run_with_vimrc(sys.argv[2])
-        return
-
-    if not image_exists():
-        print "Need to take image from remote"
-        system("docker pull %s" % (IMAGE, ))
-
-    if "-i" in sys.argv[1:]:
-        docker_run("bash -l", interactive=True)
-        return
-
-    tests_on_docker()
-
-if __name__ == "__main__":
-    main()
diff --git a/sources_non_forked/rust.vim/test/sample.rs b/sources_non_forked/rust.vim/test/sample.rs
deleted file mode 100644
index e69de29..0000000
diff --git a/sources_non_forked/rust.vim/test/vimrc b/sources_non_forked/rust.vim/test/vimrc
deleted file mode 100644
index f7f1533..0000000
--- a/sources_non_forked/rust.vim/test/vimrc
+++ /dev/null
@@ -1,30 +0,0 @@
-" vint: -ProhibitSetNoCompatible
-"
-
-set nocompatible
-filetype off
-
-" This script is currently designed to be run from within Docker, the
-" following paths are intrinsic to the container:
-source /rtp.vim
-
-" Paths need prepending (instead of what is originally done
-" in vim-testbed) in order to supersede the rust.vim that is
-" supplied with Vim.
-exec 'set runtimepath=/vader,/testplugin,' . &runtimepath
-cd /testplugin
-
-filetype plugin indent on
-syntax on
-
-set nocompatible
-set tabstop=8
-set softtabstop=4
-set shiftwidth=4
-set expandtab
-set backspace=2
-set nofoldenable
-set foldmethod=syntax
-set foldlevelstart=10
-set foldnestmax=10
-set ttimeoutlen=0
diff --git a/sources_non_forked/rust.vim/triagebot.toml b/sources_non_forked/rust.vim/triagebot.toml
deleted file mode 100644
index fa0824a..0000000
--- a/sources_non_forked/rust.vim/triagebot.toml
+++ /dev/null
@@ -1 +0,0 @@
-[assign]
diff --git a/sources_non_forked/tabular/.gitignore b/sources_non_forked/tabular/.gitignore
deleted file mode 100644
index 0a56e3f..0000000
--- a/sources_non_forked/tabular/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-/doc/tags
diff --git a/sources_non_forked/tabular/LICENSE.md b/sources_non_forked/tabular/LICENSE.md
deleted file mode 100644
index 2cc76e9..0000000
--- a/sources_non_forked/tabular/LICENSE.md
+++ /dev/null
@@ -1,24 +0,0 @@
-Copyright (c) 2016, Matthew J. Wozniski
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright notice,
-      this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * The names of the contributors may not be used to endorse or promote
-      products derived from this software without specific prior written
-      permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER ``AS IS'' AND ANY EXPRESS
-OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
-NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY DIRECT, INDIRECT,
-INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
-OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
-EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff --git a/sources_non_forked/tabular/README.md b/sources_non_forked/tabular/README.md
deleted file mode 100644
index adbfeb0..0000000
--- a/sources_non_forked/tabular/README.md
+++ /dev/null
@@ -1,29 +0,0 @@
-Tabular
-==============
-Sometimes, it's useful to line up text.  Naturally, it's nicer to have the
-computer do this for you, since aligning things by hand quickly becomes
-unpleasant.  While there are other plugins for aligning text, the ones I've
-tried are either impossibly difficult to understand and use, or too simplistic
-to handle complicated tasks.  This plugin aims to make the easy things easy
-and the hard things possible, without providing an unnecessarily obtuse
-interface.  It's still a work in progress, and criticisms are welcome.
-
-See [Aligning Text with Tabular.vim](http://vimcasts.org/episodes/aligning-text-with-tabular-vim/)
-for a screencast that shows how Tabular.vim works.
-
-See [doc/Tabular.txt](http://raw.github.com/godlygeek/tabular/master/doc/Tabular.txt)
-for detailed documentation.
-
-Installation
-==============
-If you don't have a preferred installation method, I recommend installing
-[pathogen.vim](https://github.com/tpope/vim-pathogen), and then simply
-copy and paste:
-
-    mkdir -p ~/.vim/bundle
-    cd ~/.vim/bundle
-    git clone git://github.com/godlygeek/tabular.git
-
-Once help tags have been generated (either using Pathogen's `:Helptags`
-command, or by pointing vim's `:helptags` command at the directory where you
-installed Tabular), you can view the manual with `:help tabular`.
diff --git a/sources_non_forked/tabular/after/plugin/TabularMaps.vim b/sources_non_forked/tabular/after/plugin/TabularMaps.vim
deleted file mode 100644
index 998346f..0000000
--- a/sources_non_forked/tabular/after/plugin/TabularMaps.vim
+++ /dev/null
@@ -1,73 +0,0 @@
-" Copyright (c) 2016, Matthew J. Wozniski
-" All rights reserved.
-"
-" Redistribution and use in source and binary forms, with or without
-" modification, are permitted provided that the following conditions are met:
-"     * Redistributions of source code must retain the above copyright notice,
-"       this list of conditions and the following disclaimer.
-"     * Redistributions in binary form must reproduce the above copyright
-"       notice, this list of conditions and the following disclaimer in the
-"       documentation and/or other materials provided with the distribution.
-"     * The names of the contributors may not be used to endorse or promote
-"       products derived from this software without specific prior written
-"       permission.
-"
-" THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER ``AS IS'' AND ANY EXPRESS
-" OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-" OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
-" NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY DIRECT, INDIRECT,
-" INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-" LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
-" OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-" LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-" NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
-" EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-if !exists(':Tabularize') || get(g:, 'no_default_tabular_maps', 0)
-  finish " Tabular.vim wasn't loaded or the default maps are unwanted
-endif
-
-let s:save_cpo = &cpo
-set cpo&vim
-
-AddTabularPattern!  assignment      /[|&+*/%<>=!~-]\@<!\([<>!=]=\|=\~\)\@![|&+*/%<>=!~-]*=/l1r1
-AddTabularPattern!  two_spaces      /  /l0
-
-AddTabularPipeline! multiple_spaces /  / map(a:lines, "substitute(v:val, '   *', '  ', 'g')") | tabular#TabularizeStrings(a:lines, '  ', 'l0')
-
-AddTabularPipeline! argument_list   /(.*)/ map(a:lines, 'substitute(v:val, ''\s*\([(,)]\)\s*'', ''\1'', ''g'')')
-                                       \ | tabular#TabularizeStrings(a:lines, '[(,)]', 'l0')
-                                       \ | map(a:lines, 'substitute(v:val, ''\(\s*\),'', '',\1 '', "g")')
-                                       \ | map(a:lines, 'substitute(v:val, ''\s*)'', ")", "g")')
-
-function! SplitCDeclarations(lines)
-  let rv = []
-  for line in a:lines
-    " split the line into declaractions
-    let split = split(line, '\s*[,;]\s*')
-    " separate the type from the first declaration
-    let type = substitute(split[0], '\%(\%([&*]\s*\)*\)\=\k\+$', '', '')
-    " add the ; back on every declaration
-    call map(split, 'v:val . ";"')
-    " add the first element to the return as-is, and remove it from the list
-    let rv += [ remove(split, 0) ]
-    " transform the other elements by adding the type on at the beginning
-    call map(split, 'type . v:val')
-    " and add them all to the return
-    let rv += split
-  endfor
-  return rv
-endfunction
-
-AddTabularPipeline! split_declarations /,.*;/ SplitCDeclarations(a:lines)
-
-AddTabularPattern! ternary_operator /^.\{-}\zs?\|:/l1
-
-AddTabularPattern! cpp_io /<<\|>>/l1
-
-AddTabularPattern! pascal_assign /:=/l1
-
-AddTabularPattern! trailing_c_comments /\/\*\|\*\/\|\/\//l1
-
-let &cpo = s:save_cpo
-unlet s:save_cpo
diff --git a/sources_non_forked/tabular/autoload/tabular.vim b/sources_non_forked/tabular/autoload/tabular.vim
deleted file mode 100644
index f60a73c..0000000
--- a/sources_non_forked/tabular/autoload/tabular.vim
+++ /dev/null
@@ -1,409 +0,0 @@
-" Tabular:     Align columnar data using regex-designated column boundaries
-" Maintainer:  Matthew Wozniski (godlygeek@gmail.com)
-" Date:        Thu, 03 May 2012 20:49:32 -0400
-" Version:     1.0
-"
-" Long Description:
-" Sometimes, it's useful to line up text.  Naturally, it's nicer to have the
-" computer do this for you, since aligning things by hand quickly becomes
-" unpleasant.  While there are other plugins for aligning text, the ones I've
-" tried are either impossibly difficult to understand and use, or too simplistic
-" to handle complicated tasks.  This plugin aims to make the easy things easy
-" and the hard things possible, without providing an unnecessarily obtuse
-" interface.  It's still a work in progress, and criticisms are welcome.
-"
-" License:
-" Copyright (c) 2012, Matthew J. Wozniski
-" All rights reserved.
-"
-" Redistribution and use in source and binary forms, with or without
-" modification, are permitted provided that the following conditions are met:
-"     * Redistributions of source code must retain the above copyright notice,
-"       this list of conditions and the following disclaimer.
-"     * Redistributions in binary form must reproduce the above copyright
-"       notice, this list of conditions and the following disclaimer in the
-"       documentation and/or other materials provided with the distribution.
-"     * The names of the contributors may not be used to endorse or promote
-"       products derived from this software without specific prior written
-"       permission.
-"
-" THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER ``AS IS'' AND ANY EXPRESS
-" OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-" OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
-" NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY DIRECT, INDIRECT,
-" INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-" LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
-" OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-" LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-" NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
-" EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-" Stupid vimscript crap                                                   {{{1
-let s:savecpo = &cpo
-set cpo&vim
-
-" Private Functions                                                       {{{1
-
-" Return the number of bytes in a string after expanding tabs to spaces.  {{{2
-" This expansion is done based on the current value of 'tabstop'
-if exists('*strdisplaywidth')
-  " Needs vim 7.3
-  let s:Strlen = function("strdisplaywidth")
-else
-  function! s:Strlen(string)
-    " Implement the tab handling part of strdisplaywidth for vim 7.2 and
-    " earlier - not much that can be done about handling doublewidth
-    " characters.
-    let rv = 0
-    let i = 0
-
-    for char in split(a:string, '\zs')
-      if char == "\t"
-        let rv += &ts - i
-        let i = 0
-      else
-        let rv += 1
-        let i = (i + 1) % &ts
-      endif
-    endfor
-
-    return rv
-  endfunction
-endif
-
-" Align a string within a field                                           {{{2
-" These functions do not trim leading and trailing spaces.
-
-" Right align 'string' in a field of size 'fieldwidth'
-function! s:Right(string, fieldwidth)
-  let spaces = a:fieldwidth - s:Strlen(a:string)
-  return matchstr(a:string, '^\s*') . repeat(" ", spaces) . substitute(a:string, '^\s*', '', '')
-endfunction
-
-" Left align 'string' in a field of size 'fieldwidth'
-function! s:Left(string, fieldwidth)
-  let spaces = a:fieldwidth - s:Strlen(a:string)
-  return a:string . repeat(" ", spaces)
-endfunction
-
-" Center align 'string' in a field of size 'fieldwidth'
-function! s:Center(string, fieldwidth)
-  let spaces = a:fieldwidth - s:Strlen(a:string)
-  let right = spaces / 2
-  let left = right + (right * 2 != spaces)
-  return repeat(" ", left) . a:string . repeat(" ", right)
-endfunction
-
-" Remove spaces around a string                                           {{{2
-
-" Remove all trailing spaces from a string.
-function! s:StripTrailingSpaces(string)
-  return matchstr(a:string, '^.\{-}\ze\s*$')
-endfunction
-
-" Remove all leading spaces from a string.
-function! s:StripLeadingSpaces(string)
-  return matchstr(a:string, '^\s*\zs.*$')
-endfunction
-
-" Split a string into fields and delimiters                               {{{2
-" Like split(), but include the delimiters as elements
-" All odd numbered elements are delimiters
-" All even numbered elements are non-delimiters (including zero)
-function! s:SplitDelim(string, delim)
-  let rv = []
-  let beg = 0
-
-  let len = len(a:string)
-  let searchoff = 0
-
-  while 1
-    let mid = match(a:string, a:delim, beg + searchoff, 1)
-    if mid == -1 || mid == len
-      break
-    endif
-
-    let matchstr = matchstr(a:string, a:delim, beg + searchoff, 1)
-    let length = strlen(matchstr)
-
-    if length == 0 && beg == mid
-      " Zero-length match for a zero-length delimiter - advance past it
-      let searchoff += 1
-      continue
-    endif
-
-    if beg == mid
-      let rv += [ "" ]
-    else
-      let rv += [ a:string[beg : mid-1] ]
-    endif
-
-    let rv += [ matchstr ]
-
-    let beg = mid + length
-    let searchoff = 0
-  endwhile
-
-  let rv += [ strpart(a:string, beg) ]
-
-  return rv
-endfunction
-
-" Replace lines from `start' to `start + len - 1' with the given strings. {{{2
-" If more lines are needed to show all strings, they will be added.
-" If there are too few strings to fill all lines, lines will be removed.
-function! s:SetLines(start, len, strings)
-  if a:start > line('$') + 1 || a:start < 1
-    throw "Invalid start line!"
-  endif
-
-  if len(a:strings) > a:len
-    let fensave = &fen
-    let view = winsaveview()
-    call append(a:start + a:len - 1, repeat([''], len(a:strings) - a:len))
-    call winrestview(view)
-    let &fen = fensave
-  elseif len(a:strings) < a:len
-    let fensave = &fen
-    let view = winsaveview()
-    sil exe (a:start + len(a:strings)) . ',' .  (a:start + a:len - 1) . 'd_'
-    call winrestview(view)
-    let &fen = fensave
-  endif
-
-  call setline(a:start, a:strings)
-endfunction
-
-" Runs the given commandstring argument as an expression.                 {{{2
-" The commandstring expression is expected to reference the a:lines argument.
-" If the commandstring expression returns a list the items of that list will
-" replace the items in a:lines, otherwise the expression is assumed to have
-" modified a:lines itself.
-function! s:FilterString(lines, commandstring)
-  exe 'let rv = ' . a:commandstring
-
-  if type(rv) == type(a:lines) && rv isnot a:lines
-    call filter(a:lines, 0)
-    call extend(a:lines, rv)
-  endif
-endfunction
-
-" Public API                                                              {{{1
-
-if !exists("g:tabular_default_format")
-  let g:tabular_default_format = "l1"
-endif
-
-let s:formatelempat = '\%([lrc]\d\+\)'
-
-function! tabular#ElementFormatPattern()
-  return s:formatelempat
-endfunction
-
-" Given a list of strings and a delimiter, split each string on every
-" occurrence of the delimiter pattern, format each element according to either
-" the provided format (optional) or the default format, and join them back
-" together with enough space padding to guarantee that the nth delimiter of
-" each string is aligned.
-function! tabular#TabularizeStrings(strings, delim, ...)
-  if a:0 > 1
-    echoerr "TabularizeStrings accepts only 2 or 3 arguments (got ".(a:0+2).")"
-    return 1
-  endif
-
-  let formatstr = (a:0 ? a:1 : g:tabular_default_format)
-
-  if formatstr !~? s:formatelempat . '\+'
-    echoerr "Tabular: Invalid format \"" . formatstr . "\" specified!"
-    return 1
-  endif
-
-  let format = split(formatstr, s:formatelempat . '\zs')
-
-  let lines = map(a:strings, 's:SplitDelim(v:val, a:delim)')
-
-  " Strip spaces
-  "   - Only from non-delimiters; spaces in delimiters must have been matched
-  "     intentionally
-  "   - Don't strip leading spaces from the first element; we like indenting.
-  for line in lines
-    if len(line) == 1 && s:do_gtabularize
-      continue " Leave non-matching lines unchanged for GTabularize
-    endif
-
-    if line[0] !~ '^\s*$'
-      let line[0] = s:StripTrailingSpaces(line[0])
-    endif
-    if len(line) >= 3
-      for i in range(2, len(line)-1, 2)
-        let line[i] = s:StripLeadingSpaces(s:StripTrailingSpaces(line[i]))
-      endfor
-    endif
-  endfor
-
-  " Find the max length of each field
-  let maxes = []
-  for line in lines
-    if len(line) == 1 && s:do_gtabularize
-      continue " non-matching lines don't affect field widths for GTabularize
-    endif
-
-    for i in range(len(line))
-      if i == len(maxes)
-        let maxes += [ s:Strlen(line[i]) ]
-      else
-        let maxes[i] = max( [ maxes[i], s:Strlen(line[i]) ] )
-      endif
-    endfor
-  endfor
-
-  let lead_blank = empty(filter(copy(lines), 'v:val[0] =~ "\\S"'))
-
-  " Concatenate the fields, according to the format pattern.
-  for idx in range(len(lines))
-    let line = lines[idx]
-
-    if len(line) == 1 && s:do_gtabularize
-      let lines[idx] = line[0] " GTabularize doesn't change non-matching lines
-      continue
-    endif
-
-    for i in range(len(line))
-      let how = format[i % len(format)][0]
-      let pad = format[i % len(format)][1:-1]
-
-      if how =~? 'l'
-        let field = s:Left(line[i], maxes[i])
-      elseif how =~? 'r'
-        let field = s:Right(line[i], maxes[i])
-      elseif how =~? 'c'
-        let field = s:Center(line[i], maxes[i])
-      endif
-
-      let line[i] = field . (lead_blank && i == 0 ? '' : repeat(" ", pad))
-    endfor
-
-    let lines[idx] = s:StripTrailingSpaces(join(line, ''))
-  endfor
-endfunction
-
-" Apply 0 or more filters, in sequence, to selected text in the buffer    {{{2
-" The lines to be filtered are determined as follows:
-"   If the function is called with a range containing multiple lines, then
-"     those lines will be used as the range.
-"   If the function is called with no range or with a range of 1 line, then
-"     if GTabularize mode is being used,
-"       the range will not be adjusted
-"     if "includepat" is not specified,
-"       that 1 line will be filtered,
-"     if "includepat" is specified and that line does not match it,
-"       no lines will be filtered
-"     if "includepat" is specified and that line does match it,
-"       all contiguous lines above and below the specified line matching the
-"       pattern will be filtered.
-"
-" The remaining arguments must each be a filter to apply to the text.
-" Each filter must either be a String evaluating to a function to be called.
-function! tabular#PipeRange(includepat, ...) range
-  exe a:firstline . ',' . a:lastline
-      \ . 'call tabular#PipeRangeWithOptions(a:includepat, a:000, {})'
-endfunction
-
-" Extended version of tabular#PipeRange, which
-" 1) Takes the list of filters as an explicit list rather than as varargs
-" 2) Supports passing a dictionary of options to control the routine.
-"    Currently, the only supported option is 'mode', which determines whether
-"    to behave as :Tabularize or as :GTabularize
-" This allows me to add new features here without breaking API compatibility
-" in the future.
-function! tabular#PipeRangeWithOptions(includepat, filterlist, options) range
-  let top = a:firstline
-  let bot = a:lastline
-
-  let s:do_gtabularize = (get(a:options, 'mode', '') ==# 'GTabularize')
-
-  if !s:do_gtabularize
-    " In the default mode, apply range extension logic
-    if a:includepat != '' && top == bot
-      if top < 0 || top > line('$') || getline(top) !~ a:includepat
-        return
-      endif
-      while top > 1 && getline(top-1) =~ a:includepat
-        let top -= 1
-      endwhile
-      while bot < line('$') && getline(bot+1) =~ a:includepat
-        let bot += 1
-      endwhile
-    endif
-  endif
-
-  let lines = map(range(top, bot), 'getline(v:val)')
-
-  for filter in a:filterlist
-    if type(filter) != type("")
-      echoerr "PipeRange: Bad filter: " . string(filter)
-    endif
-
-    call s:FilterString(lines, filter)
-
-    unlet filter
-  endfor
-
-  call s:SetLines(top, bot - top + 1, lines)
-endfunction
-
-" Part of the public interface so interested pipelines can query this and
-" adjust their behavior appropriately.
-function! tabular#DoGTabularize()
-  return s:do_gtabularize
-endfunction
-
-function! s:SplitDelimTest(string, delim, expected)
-  let result = s:SplitDelim(a:string, a:delim)
-
-  if result !=# a:expected
-    echomsg 'Test failed!'
-    echomsg '  string=' . string(a:string) . '  delim=' . string(a:delim)
-    echomsg '  Returned=' . string(result)
-    echomsg '  Expected=' . string(a:expected)
-  endif
-endfunction
-
-function! tabular#SplitDelimUnitTest()
-  let assignment = '[|&+*/%<>=!~-]\@<!\([<>!=]=\|=\~\)\@![|&+*/%<>=!~-]*='
-  let two_spaces = '  '
-  let ternary_operator = '^.\{-}\zs?\|:'
-  let cpp_io = '<<\|>>'
-  let pascal_assign = ':='
-  let trailing_c_comments = '\/\*\|\*\/\|\/\/'
-
-  call s:SplitDelimTest('a+=b',    assignment, ['a', '+=', 'b'])
-  call s:SplitDelimTest('a-=b',    assignment, ['a', '-=', 'b'])
-  call s:SplitDelimTest('a!=b',    assignment, ['a!=b'])
-  call s:SplitDelimTest('a==b',    assignment, ['a==b'])
-  call s:SplitDelimTest('a&=b',    assignment, ['a', '&=', 'b'])
-  call s:SplitDelimTest('a|=b',    assignment, ['a', '|=', 'b'])
-  call s:SplitDelimTest('a=b=c',   assignment, ['a', '=', 'b', '=', 'c'])
-
-  call s:SplitDelimTest('a  b  c', two_spaces, ['a', '  ', 'b', '  ', 'c'])
-  call s:SplitDelimTest('a b   c', two_spaces, ['a b', '  ', ' c'])
-  call s:SplitDelimTest('ab    c', two_spaces, ['ab', '  ', '', '  ', 'c'])
-
-  call s:SplitDelimTest('a?b:c',   ternary_operator, ['a', '?', 'b', ':', 'c'])
-
-  call s:SplitDelimTest('a<<b<<c', cpp_io, ['a', '<<', 'b', '<<', 'c'])
-
-  call s:SplitDelimTest('a:=b=c',  pascal_assign, ['a', ':=', 'b=c'])
-
-  call s:SplitDelimTest('x//foo',  trailing_c_comments, ['x', '//', 'foo'])
-  call s:SplitDelimTest('x/*foo*/',trailing_c_comments, ['x', '/*', 'foo', '*/', ''])
-
-  call s:SplitDelimTest('#ab#cd#ef', '[^#]*', ['#', 'ab', '#', 'cd', '#', 'ef', ''])
-  call s:SplitDelimTest('#ab#cd#ef', '#\zs',  ['#', '', 'ab#', '', 'cd#', '', 'ef'])
-endfunction
-
-" Stupid vimscript crap, part 2                                           {{{1
-let &cpo = s:savecpo
-unlet s:savecpo
-
-" vim:set sw=2 sts=2 fdm=marker:
diff --git a/sources_non_forked/tabular/doc/Tabular.txt b/sources_non_forked/tabular/doc/Tabular.txt
deleted file mode 100644
index a4192ad..0000000
--- a/sources_non_forked/tabular/doc/Tabular.txt
+++ /dev/null
@@ -1,260 +0,0 @@
-*Tabular.txt*   Configurable, flexible, intuitive text aligning
-
-                                                       *tabular* *tabular.vim*
-
-       #|#|#|#|#|          #|                  #|                     ~
-           #|      #|#|#|  #|#|#|    #|    #|  #|    #|#|#|  #|  #|#| ~
-           #|    #|    #|  #|    #|  #|    #|  #|  #|    #|  #|#|     ~
-           #|    #|    #|  #|    #|  #|    #|  #|  #|    #|  #|       ~
-           #|      #|#|#|  #|#|#|      #|#|#|  #|    #|#|#|  #|       ~
-
-                                                  For Vim version 7.0 or newer
-
-                               By Matt Wozniski
-                                mjw@drexel.edu
-
-                               Reference Manual ~
-
-                                                                 *tabular-toc*
-
-1. Description                                           |tabular-intro|
-2. Walkthrough                                           |tabular-walkthrough|
-3. Scripting                                             |tabular-scripting|
-
-The functionality mentioned here is a plugin, see |add-plugin|.
-You can avoid loading this plugin by setting the "Tabular_loaded" global
-variable in your |vimrc| file: >
-    :let g:tabular_loaded = 1
-
-==============================================================================
-1. Description                                                 *tabular-intro*
-
-Sometimes, it's useful to line up text.  Naturally, it's nicer to have the
-computer do this for you, since aligning things by hand quickly becomes
-unpleasant.  While there are other plugins for aligning text, the ones I've
-tried are either impossibly difficult to understand and use, or too simplistic
-to handle complicated tasks.  This plugin aims to make the easy things easy
-and the hard things possible, without providing an unnecessarily obtuse
-interface.  It's still a work in progress, and criticisms are welcome.
-
-==============================================================================
-2. Walkthrough                             *tabular-walkthrough* *:Tabularize*
-
-Tabular's commands are based largely on regular expressions.  The basic
-technique used by Tabular is taking some regex to match field delimiters,
-splitting the input lines at those delimiters, trimming unnecessary spaces
-from the non-delimiter parts, padding the non-delimiter parts of the lines
-with spaces to make them the same length, and joining things back together
-again.
-
-For instance, consider starting with the following lines:
->
-    Some short phrase,some other phrase
-    A much longer phrase here,and another long phrase
-<
-Let's say we want to line these lines up at the commas.  We can tell
-Tabularize to do this by passing a pattern matching , to the Tabularize
-command:
->
-  :Tabularize /,
-
-    Some short phrase         , some other phrase
-    A much longer phrase here , and another long phrase
-<
-I encourage you to try copying those lines to another buffer and trying to
-call :Tabularize.  You'll want to take notice of two things quickly: First,
-instead of requiring a range, Tabularize tries to figure out what you want to
-happen.  Since it knows that you want to act on lines matching a comma, it
-will look upwards and downwards for lines around the current line that match a
-comma, and consider all contiguous lines matching the pattern to be the range
-to be acted upon.  You can always override this by specifying a range, though.
-
-The second thing you should notice is that you'll almost certainly be able to
-abbreviate :Tabularize to :Tab - using this form in mappings and scripts is
-discouraged as it will make conflicts with other scripts more likely, but for
-interactive use it's a nice timesaver.  Another convenience feature is that
-running :Tabularize without providing a new pattern will cause it to reuse the
-last pattern it was called with.
-
-So, anyway, now the commas line up.  Splitting the lines on commas, Tabular
-realized that 'Some short phrase' would need to be padded with spaces to match
-the length of 'A much longer phrase here', and it did that before joining the
-lines back together.  You'll also notice that, in addition to the spaces
-inserting for padding, extra spaces were inserted between fields.  That's
-because by default, Tabular prints things left-aligned with one space between
-fields.  If you wanted to print things right-aligned with no spaces between
-fields, you would provide a different format to the Tabularize command:
->
-  :Tabularize /,/r0
-
-            Some short phrase,      some other phrase
-    A much longer phrase here,and another long phrase
-<
-A format specifier is either l, r, or c, followed by one or more digits.  If
-the letter is l, the field will be left aligned, similarly for r and right
-aligning and c and center aligning.  The number following the letter is the
-number of spaces padding to insert before the start of the next field.
-Multiple format specifiers can be added to the same command - each field will
-be printed with the next format specifier in the list; when they all have been
-used the first will be used again, and so on.  So, the last command right
-aligned every field, then inserted 0 spaces of padding before the next field.
-What if we wanted to right align the text before the comma, and left align the
-text after the comma?  The command would look like this:
->
-  :Tabularize /,/r1c1l0
-
-            Some short phrase , some other phrase
-    A much longer phrase here , and another long phrase
-<
-That command would be read as "Align the matching text, splitting fields on
-commas.  Print everything before the first comma right aligned, then 1 space,
-then the comma center aligned, then 1 space, then everything after the comma
-left aligned."  Notice that the alignment of the field the comma is in is
-irrelevant - since it's only 1 cell wide, it looks the same whether it's right,
-left, or center aligned.  Also notice that the 0 padding spaces specified for
-the 3rd field are unused - but they would be used if there were enough fields
-to require looping through the fields again.  For instance:
->
-    abc,def,ghi
-    a,b
-    a,b,c
-
-  :Tabularize /,/r1c1l0
-
-    abc , def, ghi
-      a , b
-      a , b  ,  c
-<
-Notice that now, the format pattern has been reused; field 4 (the second comma)
-is right aligned, field 5 is center aligned.  No spaces were inserted between
-the 3rd field (containing "def") and the 4th field (the second comma) because
-the format specified 'l0'.
-
-But, what if you only wanted to act on the first comma on the line, rather than
-all of the commas on the line?  Let's say we want everything before the first
-comma right aligned, then the comma, then everything after the comma left
-aligned:
->
-    abc,def,ghi
-    a,b
-    a,b,c
-
-  :Tabularize /^[^,]*\zs,/r0c0l0
-
-    abc,def,ghi
-      a,b
-      a,b,c
-<
-Here, we used a Vim regex that would only match the first comma on the line.
-It matches the beginning of the line, followed by all the non-comma characters
-up to the first comma, and then forgets about what it matched so far and
-pretends that the match starts exactly at the comma.
-
-But, now that this command does exactly what we want it to, it's become pretty
-unwieldy.  It would be unpleasant to need to type that more than once or
-twice.  The solution is to assign a name to it.
->
-  :AddTabularPattern first_comma /^[^,]*\zs,/r0c0l0
-<
-Now, typing ":Tabularize first_comma" will do the same thing as typing the
-whole pattern out each time.  Of course this is more useful if you store the
-name in a file to be used later.
-
-NOTE: In order to make these new commands available every time vim starts,
-you'll need to put those new commands into a .vim file in a plugin directory
-somewhere in your 'runtimepath'.  In order to make sure that Tabular.vim has
-already been loaded before your file tries to use :AddTabularPattern or
-:AddTabularPipeline, the new file should be installed in an after/plugin
-directory in 'runtimepath'.  In general, it will be safe to find out where the
-TabularMaps.vim plugin was installed, and place other files extending
-Tabular.vim in the same directory as TabularMaps.vim.  For more information,
-and some suggested best practices, check out the |tabular-scripting| section.
-
-Lastly, we'll approach the case where tabular cannot achieve your desired goal
-just by splitting lines appart, trimming whitespace, padding with whitespace,
-and rejoining the lines.  As an example, consider the multiple_spaces command
-from TabularMaps.vim.  The goal is to split using two or more spaces as a
-field delimiter, and join fields back together, properly lined up, with only
-two spaces between the end of each field and the beginning of the next.
-Unfortunately, Tabular can't do this with only the commands we know so far:
->
-  :Tabularize /  /
-<
-The above function won't work, because it will consider "a    b" as 5 fields
-delimited by two pairs of 2 spaces ( 'a', '  ', '', '  ', 'b' ) instead of as
-3 fields delimited by one set of 2 or more spaces ( 'a', '    ', 'b' ).
->
-  :Tabularize /  \+/
-<
-The above function won't work either, because it will leave the delimiter as 4
-spaces when used against "a    b", meaning that we would fail at our goal of
-collapsing everything down to two spaces between fields.  So, we need a new
-command to get around this:
->
-  :AddTabularPipeline multiple_spaces / \{2,}/
-    \ map(a:lines, "substitute(v:val, ' \{2,}', '  ', 'g')")
-    \   | tabular#TabularizeStrings(a:lines, '  ', 'l0')
-<
-Yeah.  I know it looks complicated.  Bear with me.  I probably will try to add
-in some shortcuts for this syntax, but this verbose will be guaranteed to
-always work.
-
-You should already recognize the name being assigned.  The next thing to
-happen is / \{2,}/ which is a pattern specifying which lines should
-automatically be included in the range when no range is given.  Without this,
-there would be no pattern to use for extending the range.  Everything after
-that is a | separated list of expressions to be evaluated.  In the context in
-which they will be evaluated, a:lines will be set to a List of Strings
-containing the text of the lines being filtered as they procede through the
-pipeline you've set up.  The \ at the start of the lines are just vim's line
-continuation marker; you needn't worry much about them.  So, the first
-expression in the pipeline transforms each line by replacing every instance of
-2 or more spaces with exactly two spaces.  The second command in the pipeline
-performs the equivalent of ":Tabularize /  /l0"; the only difference is that
-it is operating on a List of Strings rather than text in the buffer.  At the
-end of the pipeline, the Strings in the modified a:lines (or the return value
-of the last expression in the pipeline, if it returns a List) will replace the
-chosen range.
-
-==============================================================================
-3. Extending                                               *tabular-scripting*
-
-As mentioned above, the most important consideration when extending Tabular
-with new maps or commands is that your plugin must be loaded after Tabular.vim
-has finished loading, and only if Tabular.vim has loaded successfully.  The
-easiest approach to making sure it loads after Tabular.vim is simply putting
-the new file (we'll call it "tabular_extra.vim" as an example) into an
-"after/plugin/" directory in 'runtimepath', for instance:
->
-  ~/.vim/after/plugin/tabular_extra.vim
-<
-The default set of mappings, found in "TabularMaps.vim", is installed in
-the after/plugin/ subdirectory of whatever directory Tabular was installed to.
-
-The other important consideration is making sure that your commands are only
-called if Tabular.vim was actually loaded.  The easiest way to do this is by
-checking for the existence of the :Tabularize command at the start of your
-plugin.  A short example plugin would look like this:
->
-  " after/plugin/my_tabular_commands.vim
-  " Provides extra :Tabularize commands
-
-  if !exists(':Tabularize')
-    finish " Give up here; the Tabular plugin musn't have been loaded
-  endif
-
-  " Make line wrapping possible by resetting the 'cpo' option, first saving it
-  let s:save_cpo = &cpo
-  set cpo&vim
-
-  AddTabularPattern! asterisk /*/l1
-
-  AddTabularPipeline! remove_leading_spaces /^ /
-                  \ map(a:lines, "substitute(v:val, '^ *', '', '')")
-
-  " Restore the saved value of 'cpo'
-  let &cpo = s:save_cpo
-  unlet s:save_cpo
-<
-==============================================================================
-vim:tw=78:fo=tcq2:isk=!-~,^*,^\|,^\":ts=8:ft=help:norl:
diff --git a/sources_non_forked/tabular/plugin/Tabular.vim b/sources_non_forked/tabular/plugin/Tabular.vim
deleted file mode 100644
index e73329a..0000000
--- a/sources_non_forked/tabular/plugin/Tabular.vim
+++ /dev/null
@@ -1,346 +0,0 @@
-" Tabular:     Align columnar data using regex-designated column boundaries
-" Maintainer:  Matthew Wozniski (godlygeek@gmail.com)
-" Date:        Thu, 03 May 2012 20:49:32 -0400
-" Version:     1.0
-"
-" Long Description:
-" Sometimes, it's useful to line up text.  Naturally, it's nicer to have the
-" computer do this for you, since aligning things by hand quickly becomes
-" unpleasant.  While there are other plugins for aligning text, the ones I've
-" tried are either impossibly difficult to understand and use, or too simplistic
-" to handle complicated tasks.  This plugin aims to make the easy things easy
-" and the hard things possible, without providing an unnecessarily obtuse
-" interface.  It's still a work in progress, and criticisms are welcome.
-"
-" License:
-" Copyright (c) 2012, Matthew J. Wozniski
-" All rights reserved.
-"
-" Redistribution and use in source and binary forms, with or without
-" modification, are permitted provided that the following conditions are met:
-"     * Redistributions of source code must retain the above copyright notice,
-"       this list of conditions and the following disclaimer.
-"     * Redistributions in binary form must reproduce the above copyright
-"       notice, this list of conditions and the following disclaimer in the
-"       documentation and/or other materials provided with the distribution.
-"     * The names of the contributors may not be used to endorse or promote
-"       products derived from this software without specific prior written
-"       permission.
-"
-" THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER ``AS IS'' AND ANY EXPRESS
-" OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-" OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
-" NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY DIRECT, INDIRECT,
-" INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-" LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
-" OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-" LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-" NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
-" EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-" Abort if running in vi-compatible mode or the user doesn't want us.
-if &cp || exists('g:tabular_loaded')
-  if &cp && &verbose
-    echo "Not loading Tabular in compatible mode."
-  endif
-  finish
-endif
-
-let g:tabular_loaded = 1
-
-" Stupid vimscript crap                                                   {{{1
-let s:savecpo = &cpo
-set cpo&vim
-
-" Private Things                                                          {{{1
-
-" Dictionary of command name to command
-let s:TabularCommands = {}
-
-" Generate tab completion list for :Tabularize                            {{{2
-" Return a list of commands that match the command line typed so far.
-" NOTE: Tries to handle commands with spaces in the name, but Vim doesn't seem
-"       to handle that terribly well... maybe I should give up on that.
-function! s:CompleteTabularizeCommand(argstart, cmdline, cursorpos)
-  let names = keys(s:TabularCommands)
-  if exists("b:TabularCommands")
-    let names += keys(b:TabularCommands)
-  endif
-
-  let cmdstart = substitute(a:cmdline, '^\s*\S\+\s*', '', '')
-
-  return filter(names, 'v:val =~# ''^\V'' . escape(cmdstart, ''\'')')
-endfunction
-
-" Choose the proper command map from the given command line               {{{2
-" Returns [ command map, command line with leading <buffer> removed ]
-function! s:ChooseCommandMap(commandline)
-  let map = s:TabularCommands
-  let cmd = a:commandline
-
-  if cmd =~# '^<buffer>\s\+'
-    if !exists('b:TabularCommands')
-      let b:TabularCommands = {}
-    endif
-    let map = b:TabularCommands
-    let cmd = substitute(cmd, '^<buffer>\s\+', '', '')
-  endif
-
-  return [ map, cmd ]
-endfunction
-
-" Parse '/pattern/format' into separate pattern and format parts.         {{{2
-" If parsing fails, return [ '', '' ]
-function! s:ParsePattern(string)
-  if a:string[0] != '/'
-    return ['','']
-  endif
-
-  let pat = '\\\@<!\%(\\\\\)\{-}\zs/' . tabular#ElementFormatPattern() . '*$'
-  let format = matchstr(a:string[1:-1], pat)
-  if !empty(format)
-    let format = format[1 : -1]
-    let pattern = a:string[1 : -len(format) - 2]
-  else
-    let pattern = a:string[1 : -1]
-  endif
-
-  return [pattern, format]
-endfunction
-
-" Split apart a list of | separated expressions.                          {{{2
-function! s:SplitCommands(string)
-  if a:string =~ '^\s*$'
-    return []
-  endif
-
-  let end = match(a:string, "[\"'|]")
-
-  " Loop until we find a delimiting | or end-of-string
-  while end != -1 && (a:string[end] != '|' || a:string[end+1] == '|')
-    if a:string[end] == "'"
-      let end = match(a:string, "'", end+1) + 1
-      if end == 0
-        throw "No matching end single quote"
-      endif
-    elseif a:string[end] == '"'
-      " Find a " preceded by an even number of \ (or 0)
-      let pattern = '\%(\\\@<!\%(\\\\\)*\)\@<="'
-      let end = matchend(a:string, pattern, end+1) + 1
-      if end == 0
-        throw "No matching end double quote"
-      endif
-    else " Found ||
-      let end += 2
-    endif
-
-    let end = match(a:string, "[\"'|]", end)
-  endwhile
-
-  if end == 0 || a:string[0 : end - (end > 0)] =~ '^\s*$'
-    throw "Empty element"
-  endif
-
-  if end == -1
-    let rv = [ a:string ]
-  else
-    let rv = [ a:string[0 : end-1] ] + s:SplitCommands(a:string[end+1 : -1])
-  endif
-
-  return rv
-endfunction
-
-" Public Things                                                           {{{1
-
-" Command associating a command name with a simple pattern command        {{{2
-" AddTabularPattern[!] [<buffer>] name /pattern[/format]
-"
-" If <buffer> is provided, the command will only be available in the current
-" buffer, and will be used instead of any global command with the same name.
-"
-" If a command with the same name and scope already exists, it is an error,
-" unless the ! is provided, in which case the existing command will be
-" replaced.
-"
-" pattern is a regex describing the delimiter to be used.
-"
-" format describes the format pattern to be used.  The default will be used if
-" none is provided.
-com! -nargs=+ -bang AddTabularPattern
-   \ call AddTabularPattern(<q-args>, <bang>0)
-
-function! AddTabularPattern(command, force)
-  try
-    let [ commandmap, rest ] = s:ChooseCommandMap(a:command)
-
-    let name = matchstr(rest, '.\{-}\ze\s*/')
-    let pattern = substitute(rest, '.\{-}\s*\ze/', '', '')
-
-    let [ pattern, format ] = s:ParsePattern(pattern)
-
-    if empty(name) || empty(pattern)
-      throw "Invalid arguments!"
-    endif
-
-    if !a:force && has_key(commandmap, name)
-      throw string(name) . " is already defined, use ! to overwrite."
-    endif
-
-    let command = "tabular#TabularizeStrings(a:lines, " . string(pattern)
-
-    if !empty(format)
-      let command .=  ", " . string(format)
-    endif
-
-    let command .= ")"
-
-    let commandmap[name] = { 'pattern' : pattern, 'commands' : [ command ] }
-  catch
-    echohl ErrorMsg
-    echomsg "AddTabularPattern: " . v:exception
-    echohl None
-  endtry
-endfunction
-
-" Command associating a command name with a pipeline of functions         {{{2
-" AddTabularPipeline[!] [<buffer>] name /pattern/ func [ | func2 [ | func3 ] ]
-"
-" If <buffer> is provided, the command will only be available in the current
-" buffer, and will be used instead of any global command with the same name.
-"
-" If a command with the same name and scope already exists, it is an error,
-" unless the ! is provided, in which case the existing command will be
-" replaced.
-"
-" pattern is a regex that will be used to determine which lines will be
-" filtered.  If the cursor line doesn't match the pattern, using the command
-" will be a no-op, otherwise the cursor and all contiguous lines matching the
-" pattern will be filtered.
-"
-" Each 'func' argument represents a function to be called.  This function
-" will have access to a:lines, a List containing one String per line being
-" filtered.
-com! -nargs=+ -bang AddTabularPipeline
-   \ call AddTabularPipeline(<q-args>, <bang>0)
-
-function! AddTabularPipeline(command, force)
-  try
-    let [ commandmap, rest ] = s:ChooseCommandMap(a:command)
-
-    let name = matchstr(rest, '.\{-}\ze\s*/')
-    let pattern = substitute(rest, '.\{-}\s*\ze/', '', '')
-
-    let commands = matchstr(pattern, '^/.\{-}\\\@<!\%(\\\\\)\{-}/\zs.*')
-    let pattern = matchstr(pattern, '/\zs.\{-}\\\@<!\%(\\\\\)\{-}\ze/')
-
-    if empty(name) || empty(pattern)
-      throw "Invalid arguments!"
-    endif
-
-    if !a:force && has_key(commandmap, name)
-      throw string(name) . " is already defined, use ! to overwrite."
-    endif
-
-    let commandlist = s:SplitCommands(commands)
-
-    if empty(commandlist)
-      throw "Must provide a list of functions!"
-    endif
-
-    let commandmap[name] = { 'pattern' : pattern, 'commands' : commandlist }
-  catch
-    echohl ErrorMsg
-    echomsg "AddTabularPipeline: " . v:exception
-    echohl None
-  endtry
-endfunction
-
-" Tabularize /pattern[/format]                                            {{{2
-" Tabularize name
-"
-" Align text, either using the given pattern, or the command associated with
-" the given name.
-com! -nargs=* -range -complete=customlist,<SID>CompleteTabularizeCommand
-   \ Tabularize <line1>,<line2>call Tabularize(<q-args>)
-
-function! Tabularize(command, ...) range
-  let piperange_opt = {}
-  if a:0
-    let piperange_opt = a:1
-  endif
-
-  if empty(a:command)
-    if !exists("s:last_tabularize_command")
-      echohl ErrorMsg
-      echomsg "Tabularize hasn't been called yet; no pattern/command to reuse!"
-      echohl None
-      return
-    endif
-  else
-    let s:last_tabularize_command = a:command
-  endif
-
-  let command = s:last_tabularize_command
-
-  let range = a:firstline . ',' . a:lastline
-
-  try
-    let [ pattern, format ] = s:ParsePattern(command)
-
-    if !empty(pattern)
-      let cmd  = "tabular#TabularizeStrings(a:lines, " . string(pattern)
-
-      if !empty(format)
-        let cmd .= "," . string(format)
-      endif
-
-      let cmd .= ")"
-
-      exe range . 'call tabular#PipeRangeWithOptions(pattern, [ cmd ], '
-                      \ . 'piperange_opt)'
-    else
-      if exists('b:TabularCommands') && has_key(b:TabularCommands, command)
-        let usercmd = b:TabularCommands[command]
-      elseif has_key(s:TabularCommands, command)
-        let usercmd = s:TabularCommands[command]
-      else
-        throw "Unrecognized command " . string(command)
-      endif
-
-      exe range . 'call tabular#PipeRangeWithOptions(usercmd["pattern"], '
-                      \ . 'usercmd["commands"], piperange_opt)'
-    endif
-  catch
-    echohl ErrorMsg
-    echomsg "Tabularize: " . v:exception
-    echohl None
-    return
-  endtry
-endfunction
-
-" GTabularize /pattern[/format]                                           {{{2
-" GTabularize name
-"
-" Align text on only matching lines, either using the given pattern, or the
-" command associated with the given name.  Mnemonically, this is similar to
-" the :global command, which takes some action on all rows matching a pattern
-" in a range.  This command is different from normal :Tabularize in 3 ways:
-"   1) If a line in the range does not match the pattern, it will be left
-"      unchanged, and not in any way affect the outcome of other lines in the
-"      range (at least, normally - but Pipelines can and will still look at
-"      non-matching rows unless they are specifically written to be aware of
-"      tabular#DoGTabularize() and handle it appropriately).
-"   2) No automatic range determination - :Tabularize automatically expands
-"      a single-line range (or a call with no range) to include all adjacent
-"      matching lines.  That behavior does not make sense for this command.
-"   3) If called without a range, it will act on all lines in the buffer (like
-"      :global) rather than only a single line
-com! -nargs=* -range=% -complete=customlist,<SID>CompleteTabularizeCommand
-   \ GTabularize <line1>,<line2>
-   \ call Tabularize(<q-args>, { 'mode': 'GTabularize' } )
-
-" Stupid vimscript crap, part 2                                           {{{1
-let &cpo = s:savecpo
-unlet s:savecpo
-
-" vim:set sw=2 sts=2 fdm=marker:
diff --git a/sources_non_forked/typescript-vim/README.md b/sources_non_forked/typescript-vim/README.md
index c487381..a880998 100644
--- a/sources_non_forked/typescript-vim/README.md
+++ b/sources_non_forked/typescript-vim/README.md
@@ -3,7 +3,7 @@ Typescript Syntax for Vim
 
 Syntax file and other settings for [TypeScript](http://typescriptlang.org). The
 syntax file is taken from this [blog
-post](http://blogs.msdn.com/b/interoperability/archive/2012/10/01/sublime-text-vi-emacs-typescript-enabled.aspx).
+post](https://docs.microsoft.com/en-us/archive/blogs/interoperability/sublime-text-vi-emacs-typescript-enabled).
 
 Checkout [Tsuquyomi](https://github.com/Quramy/tsuquyomi) for omni-completion
 and other features for TypeScript editing.
diff --git a/sources_non_forked/typescript-vim/compiler/typescriptreact.vim b/sources_non_forked/typescript-vim/compiler/typescriptreact.vim
new file mode 100644
index 0000000..0f73409
--- /dev/null
+++ b/sources_non_forked/typescript-vim/compiler/typescriptreact.vim
@@ -0,0 +1 @@
+runtime! compiler/typescript.vim
diff --git a/sources_non_forked/typescript-vim/ftplugin/typescriptreact.vim b/sources_non_forked/typescript-vim/ftplugin/typescriptreact.vim
new file mode 100644
index 0000000..c23ec13
--- /dev/null
+++ b/sources_non_forked/typescript-vim/ftplugin/typescriptreact.vim
@@ -0,0 +1 @@
+runtime! ftplugin/typescript.vim
diff --git a/sources_non_forked/typescript-vim/indent/typescriptreact.vim b/sources_non_forked/typescript-vim/indent/typescriptreact.vim
new file mode 100644
index 0000000..36f89ae
--- /dev/null
+++ b/sources_non_forked/typescript-vim/indent/typescriptreact.vim
@@ -0,0 +1 @@
+runtime! indent/typescript.vim
diff --git a/sources_non_forked/typescript-vim/syntax/typescript.vim b/sources_non_forked/typescript-vim/syntax/typescript.vim
index 8c6ecf2..474e228 100644
--- a/sources_non_forked/typescript-vim/syntax/typescript.vim
+++ b/sources_non_forked/typescript-vim/syntax/typescript.vim
@@ -69,11 +69,11 @@ syn match typescriptNumber "-\=\<\d[0-9_]*L\=\>" display
 syn match typescriptNumber "-\=\<0[xX][0-9a-fA-F][0-9a-fA-F_]*\>" display
 syn match typescriptNumber "-\=\<0[bB][01][01_]*\>" display
 syn match typescriptNumber "-\=\<0[oO]\o[0-7_]*\>" display
-syn region typescriptRegexpString start=+/[^/*]+me=e-1 skip=+\\\\\|\\/+ end=+/[gi]\{0,2\}\s*$+ end=+/[gi]\{0,2\}\s*[;.,)\]}]+me=e-1 contains=@htmlPreproc oneline
+syn region typescriptRegexpString start=+/[^/*]+me=e-1 skip=+\\\\\|\\/+ end=+/[gimsuy]\{0,2\}\s*$+ end=+/[gimsuy]\{0,2\}\s*[;.,)\]}]+me=e-1 contains=@htmlPreproc oneline
 " syntax match typescriptSpecial "\\\d\d\d\|\\x\x\{2\}\|\\u\x\{4\}\|\\."
 " syntax region typescriptStringD start=+"+ skip=+\\\\\|\\$"+ end=+"+ contains=typescriptSpecial,@htmlPreproc
 " syntax region typescriptStringS start=+'+ skip=+\\\\\|\\$'+ end=+'+ contains=typescriptSpecial,@htmlPreproc
-" syntax region typescriptRegexpString start=+/\(\*\|/\)\@!+ skip=+\\\\\|\\/+ end=+/[gim]\{,3}+ contains=typescriptSpecial,@htmlPreproc oneline
+" syntax region typescriptRegexpString start=+/\(\*\|/\)\@!+ skip=+\\\\\|\\/+ end=+/[gimsuy]\{,3}+ contains=typescriptSpecial,@htmlPreproc oneline
 " syntax match typescriptNumber /\<-\=\d\+L\=\>\|\<0[xX]\x\+\>/
 syntax match typescriptFloat /\<-\=\%(\d[0-9_]*\.\d[0-9_]*\|\d[0-9_]*\.\|\.\d[0-9]*\)\%([eE][+-]\=\d[0-9_]*\)\=\>/
 " syntax match typescriptLabel /\(?\s*\)\@<!\<\w\+\(\s*:\)\@=/
@@ -124,7 +124,8 @@ syntax keyword typescriptBranch break continue yield await
 syntax keyword typescriptLabel case default async readonly
 syntax keyword typescriptStatement return with
 
-syntax keyword typescriptGlobalObjects Array Boolean Date Function Infinity JSON Math Number NaN Object Packages RegExp String Symbol netscape
+syntax keyword typescriptGlobalObjects Array Boolean Date Function Infinity JSON Math Number NaN Object Packages RegExp String Symbol netscape ArrayBuffer BigInt64Array BigUint64Array Float32Array Float64Array Int16Array Int32Array Int8Array Uint16Array Uint32Array Uint8Array Uint8ClampedArray Buffer Collator DataView DateTimeFormat Intl Iterator Map Set WeakMap WeakSet NumberFormat ParallelArray Promise Proxy Reflect Uint8ClampedArray WebAssembly console document fetch window
+syntax keyword typescriptGlobalNodeObjects  module exports global process __dirname __filename
 
 syntax keyword typescriptExceptions try catch throw finally Error EvalError RangeError ReferenceError SyntaxError TypeError URIError
 
@@ -188,7 +189,7 @@ syntax match typescriptDotNotation "\.style\." nextgroup=typescriptCssStyles
 
 
 "" Code blocks
-syntax cluster typescriptAll contains=typescriptComment,typescriptLineComment,typescriptDocComment,typescriptStringD,typescriptStringS,typescriptStringB,typescriptRegexpString,typescriptNumber,typescriptFloat,typescriptDecorators,typescriptLabel,typescriptSource,typescriptType,typescriptOperator,typescriptBoolean,typescriptNull,typescriptFuncKeyword,typescriptConditional,typescriptGlobal,typescriptRepeat,typescriptBranch,typescriptStatement,typescriptGlobalObjects,typescriptMessage,typescriptIdentifier,typescriptStorageClass,typescriptExceptions,typescriptReserved,typescriptDeprecated,typescriptDomErrNo,typescriptDomNodeConsts,typescriptHtmlEvents,typescriptDotNotation,typescriptBrowserObjects,typescriptDOMObjects,typescriptAjaxObjects,typescriptPropietaryObjects,typescriptDOMMethods,typescriptHtmlElemProperties,typescriptDOMProperties,typescriptEventListenerKeywords,typescriptEventListenerMethods,typescriptAjaxProperties,typescriptAjaxMethods,typescriptFuncArg
+syntax cluster typescriptAll contains=typescriptComment,typescriptLineComment,typescriptDocComment,typescriptStringD,typescriptStringS,typescriptStringB,typescriptRegexpString,typescriptNumber,typescriptFloat,typescriptDecorators,typescriptLabel,typescriptSource,typescriptType,typescriptOperator,typescriptBoolean,typescriptNull,typescriptFuncKeyword,typescriptConditional,typescriptGlobal,typescriptRepeat,typescriptBranch,typescriptStatement,typescriptGlobalObjects,typescriptMessage,typescriptIdentifier,typescriptStorageClass,typescriptExceptions,typescriptReserved,typescriptDeprecated,typescriptDomErrNo,typescriptDomNodeConsts,typescriptHtmlEvents,typescriptDotNotation,typescriptBrowserObjects,typescriptDOMObjects,typescriptAjaxObjects,typescriptPropietaryObjects,typescriptDOMMethods,typescriptHtmlElemProperties,typescriptDOMProperties,typescriptEventListenerKeywords,typescriptEventListenerMethods,typescriptAjaxProperties,typescriptAjaxMethods,typescriptFuncArg,typescriptGlobalNodeObjects
 
 if main_syntax == "typescript"
   syntax sync clear
@@ -204,9 +205,9 @@ syntax keyword typescriptFuncKeyword function
 
 syn match typescriptBraces "[{}\[\]]"
 syn match typescriptParens "[()]"
-syn match typescriptOpSymbols "=\{1,3}\|!==\|!=\|<\|>\|>=\|<=\|++\|+=\|--\|-="
 syn match typescriptEndColons "[;,]"
 syn match typescriptLogicSymbols "\(&&\)\|\(||\)\|\(!\)"
+syn match typescriptOpSymbols "=\{1,3}\|!==\|!=\|<\|>\|>=\|<=\|++\|+=\|--\|-="
 
 " typescriptFold Function {{{
 
@@ -288,6 +289,7 @@ if version >= 508 || !exists("did_typescript_syn_inits")
   HiLink typescriptSpecial Special
   HiLink typescriptSource Special
   HiLink typescriptGlobalObjects Special
+  HiLink typescriptGlobalNodeObjects Special
   HiLink typescriptExceptions Special
 
   HiLink typescriptDomErrNo Constant
diff --git a/sources_non_forked/typescript-vim/syntax/typescriptreact.vim b/sources_non_forked/typescript-vim/syntax/typescriptreact.vim
new file mode 100644
index 0000000..8fc4480
--- /dev/null
+++ b/sources_non_forked/typescript-vim/syntax/typescriptreact.vim
@@ -0,0 +1 @@
+runtime! syntax/typescript.vim
diff --git a/sources_non_forked/vim-abolish/plugin/abolish.vim b/sources_non_forked/vim-abolish/plugin/abolish.vim
index 3b71f94..6fd332d 100644
--- a/sources_non_forked/vim-abolish/plugin/abolish.vim
+++ b/sources_non_forked/vim-abolish/plugin/abolish.vim
@@ -588,6 +588,7 @@ function! s:coerce(type) abort
     let regbody = getreg('"')
     let regtype = getregtype('"')
     let c = v:count1
+    let begin = getcurpos()
     while c > 0
       let c -= 1
       if a:type ==# 'line'
@@ -600,9 +601,6 @@ function! s:coerce(type) abort
       silent exe 'normal!' move.'y'
       let word = @@
       let @@ = s:send(g:Abolish.Coercions,s:transformation,word)
-      if !exists('begin')
-        let begin = getpos("'[")
-      endif
       if word !=# @@
         let changed = 1
         exe 'normal!' move.'p'
@@ -618,7 +616,7 @@ function! s:coerce(type) abort
 endfunction
 
 nnoremap <expr> <Plug>(abolish-coerce) <SID>coerce(nr2char(getchar()))
-nnoremap <expr> <Plug>(abolish-coerce) <SID>coerce(nr2char(getchar()))
+vnoremap <expr> <Plug>(abolish-coerce) <SID>coerce(nr2char(getchar()))
 nnoremap <expr> <plug>(abolish-coerce-word) <SID>coerce(nr2char(getchar())).'iw'
 
 " }}}1
diff --git a/sources_non_forked/vim-coffee-script/ftdetect/coffee.vim b/sources_non_forked/vim-coffee-script/ftdetect/coffee.vim
index e6c4d69..4e5285d 100644
--- a/sources_non_forked/vim-coffee-script/ftdetect/coffee.vim
+++ b/sources_non_forked/vim-coffee-script/ftdetect/coffee.vim
@@ -7,6 +7,7 @@ autocmd BufNewFile,BufRead *.coffee set filetype=coffee
 autocmd BufNewFile,BufRead *Cakefile set filetype=coffee
 autocmd BufNewFile,BufRead *.coffeekup,*.ck set filetype=coffee
 autocmd BufNewFile,BufRead *._coffee set filetype=coffee
+autocmd BufNewFile,BufRead *.cson set filetype=coffee
 
 function! s:DetectCoffee()
     if getline(1) =~ '^#!.*\<coffee\>'
diff --git a/sources_non_forked/vim-colors-solarized/README.mkd b/sources_non_forked/vim-colors-solarized/README.mkd
deleted file mode 100644
index a163b02..0000000
--- a/sources_non_forked/vim-colors-solarized/README.mkd
+++ /dev/null
@@ -1,267 +0,0 @@
----
-Title: Solarized Colorscheme for Vim
-Description: Precision colors for machines and people
-Author: Ethan Schoonover
-Colors: light yellow
-Created:  2011 Mar 15
-Modified: 2011 Apr 16
-
----
-
-Solarized Colorscheme for Vim
-=============================
-
-Developed by Ethan Schoonover <es@ethanschoonover.com>
-
-Visit the [Solarized homepage]
-------------------------------
-
-See the [Solarized homepage] for screenshots, 
-details and colorscheme versions for Vim, Mutt, popular terminal emulators and 
-other applications.
-
-Screenshots
------------
-
-![solarized dark](https://github.com/altercation/solarized/raw/master/img/solarized-vim.png)
-
-Downloads
----------
-
-If you have come across this colorscheme via the [Vim-only repository] on 
-github, or the [vim.org script] page see the link above to the Solarized 
-homepage or visit the main [Solarized repository].
-
-The [Vim-only repository] is kept in sync with the main [Solarized repository] 
-and is for installation convenience only (with [Pathogen] or [Vundle], for 
-instance).  Issues, bug reports, changelogs are centralized at the main 
-[Solarized repository].
-
-[Solarized homepage]:   http://ethanschoonover.com/solarized
-[Solarized repository]: https://github.com/altercation/solarized
-[Vim-only repository]:  https://github.com/altercation/vim-colors-solarized
-[vimorg-script]:        http://vim.org/script
-[Pathogen]:             https://github.com/tpope/vim-pathogen
-[Vundle]:               https://github.com/gmarik/vundle
-
-Installation
-------------
-
-### Option 1: Manual installation
-
-1.  Move `solarized.vim` to your `.vim/colors` directory. After downloading the 
-    vim script or package:
-
-        $ cd vim-colors-solarized/colors
-        $ mv solarized.vim ~/.vim/colors/
-
-### Option 2: Pathogen installation ***(recommended)***
-
-1.  Download and install Tim Pope's [Pathogen].
-
-2.  Next, move or clone the `vim-colors-solarized` directory so that it is 
-    a subdirectory of the `.vim/bundle` directory.
-
-    a. **Clone:** 
-
-            $ cd ~/.vim/bundle
-            $ git clone git://github.com/altercation/vim-colors-solarized.git
-
-    b. **Move:**
-
-        In the parent directory of vim-colors-solarized:
-        
-            $ mv vim-colors-solarized ~/.vim/bundle/
-
-### Modify .vimrc
-
-After either Option 1 or Option 2 above, put the following two lines in your 
-.vimrc:
-
-    syntax enable
-    set background=dark
-    colorscheme solarized
-
-or, for the light background mode of Solarized:
-
-    syntax enable
-    set background=light
-    colorscheme solarized
-
-I like to have a different background in GUI and terminal modes, so I can use 
-the following if-then. However, I find vim's background autodetection to be 
-pretty good and, at least with MacVim, I can leave this background value 
-assignment out entirely and get the same results.
-
-    if has('gui_running')
-        set background=light
-    else
-        set background=dark
-    endif
-
-See the [Solarized homepage] for screenshots which will help you 
-select either the light or dark background.
-
-### IMPORTANT NOTE FOR TERMINAL USERS:
-
-If you are going to use Solarized in Terminal mode (i.e. not in a GUI version 
-like gvim or macvim), **please please please** consider setting your terminal 
-emulator's colorscheme to used the Solarized palette. I've included palettes 
-for some popular terminal emulator as well as Xdefaults in the official 
-Solarized download available from [Solarized homepage]. If you use 
-Solarized *without* these colors, Solarized will need to be told to degrade its
-colorscheme to a set compatible with the limited 256 terminal palette (whereas 
-by using the terminal's 16 ansi color values, you can set the correct, specific 
-values for the Solarized palette).
-
-If you do use the custom terminal colors, solarized.vim should work out of the
-box for you. If you are using a terminal emulator that supports 256 colors and 
-don't want to use the custom Solarized terminal colors, you will need to use 
-the degraded 256 colorscheme. To do so, simply add the following line *before* 
-the `colorschem solarized` line:
-
-    let g:solarized_termcolors=256
-
-Again, I recommend just changing your terminal colors to Solarized values 
-either manually or via one of the many terminal schemes available for import.
-
-Advanced Configuration
-----------------------
-
-Solarized will work out of the box with just the two lines specified above but 
-does include several other options that can be set in your .vimrc file.
-
-Set these in your vimrc file prior to calling the colorscheme.
-"
-    option name               default     optional
-    ------------------------------------------------
-    g:solarized_termcolors=   16      |   256
-    g:solarized_termtrans =   0       |   1
-    g:solarized_degrade   =   0       |   1
-    g:solarized_bold      =   1       |   0
-    g:solarized_underline =   1       |   0
-    g:solarized_italic    =   1       |   0
-    g:solarized_contrast  =   "normal"|   "high" or "low"
-    g:solarized_visibility=   "normal"|   "high" or "low"
-    ------------------------------------------------
-
-### Option Details
-
-*   g:solarized_termcolors
-
-    This is set to *16* by default, meaning that Solarized will attempt to use 
-    the standard 16 colors of your terminal emulator. You will need to set 
-    those colors to the correct Solarized values either manually or by 
-    importing one of the many colorscheme available for popular terminal 
-    emulators and Xdefaults.
-
-*   g:solarized_termtrans
-
-    If you use a terminal emulator with a transparent background and Solarized 
-    isn't displaying the background color transparently, set this to 1 and 
-    Solarized will use the default (transparent) background of the terminal 
-    emulator. *urxvt* required this in my testing; iTerm2 did not.
-
-    Note that on Mac OS X Terminal.app, solarized_termtrans is set to 1 by 
-    default as this is almost always the best option. The only exception to 
-    this is if the working terminfo file supports 256 colors (xterm-256color).
-
-*   g:solarized_degrade
-
-    For test purposes only; forces Solarized to use the 256 degraded color mode 
-    to test the approximate color values for accuracy.
-
-*   g:solarized_bold | g:solarized_underline | g:solarized_italic
-
-    If you wish to stop Solarized from displaying bold, underlined or 
-    italicized typefaces, simply assign a zero value to the appropriate 
-    variable, for example: `let g:solarized_italic=0`
-
-*   g:solarized_contrast
-
-    Stick with normal! It's been carefully tested. Setting this option to high 
-    or low does use the same Solarized palette but simply shifts some values up 
-    or down in order to expand or compress the tonal range displayed.
-
-*   g:solarized_visibility
-
-    Special characters such as trailing whitespace, tabs, newlines, when
-    displayed using `:set list` can be set to one of three levels depending on 
-    your needs. Default value is `normal` with `high` and `low` options.
-
-Toggle Background Function
---------------------------
-
-Solarized comes with a Toggle Background plugin that by default will map to 
-<F5> if that mapping is available. If it is not available you will need to 
-either map the function manually or change your current <F5> mapping to 
-something else.
-
-To set your own mapping in your .vimrc file, simply add the following line to 
-support normal, insert and visual mode usage, changing the "<F5>" value to the 
-key or key combination you wish to use:
-
-    call togglebg#map("<F5>")
-
-Note that you'll want to use a single function key or equivalent if you want 
-the plugin to work in all modes (normal, insert, visual).
-
-Code Notes
-----------
-
-Use folding to view the `solarized.vim` script with `foldmethod=marker` turned 
-on.
-
-I have attempted to modularize the creation of Vim colorschemes in this script 
-and, while it could be refactored further, it should be a good foundation for 
-the creation of any color scheme. By simply changing the sixteen values in the 
-GUI section and testing in gvim (or mvim) you can rapidly prototype new 
-colorschemes without diving into the weeds of line-item editing each syntax 
-highlight declaration.
-
-The Values
-----------
-
-L\*a\*b values are canonical (White D65, Reference D50), other values are 
-matched in sRGB space.
-
-    SOLARIZED HEX     16/8 TERMCOL  XTERM/HEX   L*A*B      sRGB        HSB
-    --------- ------- ---- -------  ----------- ---------- ----------- -----------
-    base03    #002b36  8/4 brblack  234 #1c1c1c 15 -12 -12   0  43  54 193 100  21
-    base02    #073642  0/4 black    235 #262626 20 -12 -12   7  54  66 192  90  26
-    base01    #586e75 10/7 brgreen  240 #4e4e4e 45 -07 -07  88 110 117 194  25  46
-    base00    #657b83 11/7 bryellow 241 #585858 50 -07 -07 101 123 131 195  23  51
-    base0     #839496 12/6 brblue   244 #808080 60 -06 -03 131 148 150 186  13  59
-    base1     #93a1a1 14/4 brcyan   245 #8a8a8a 65 -05 -02 147 161 161 180   9  63
-    base2     #eee8d5  7/7 white    254 #d7d7af 92 -00  10 238 232 213  44  11  93
-    base3     #fdf6e3 15/7 brwhite  230 #ffffd7 97  00  10 253 246 227  44  10  99
-    yellow    #b58900  3/3 yellow   136 #af8700 60  10  65 181 137   0  45 100  71
-    orange    #cb4b16  9/3 brred    166 #d75f00 50  50  55 203  75  22  18  89  80
-    red       #dc322f  1/1 red      160 #d70000 50  65  45 220  50  47   1  79  86
-    magenta   #d33682  5/5 magenta  125 #af005f 50  65 -05 211  54 130 331  74  83
-    violet    #6c71c4 13/5 brmagenta 61 #5f5faf 50  15 -45 108 113 196 237  45  77
-    blue      #268bd2  4/4 blue      33 #0087ff 55 -10 -45  38 139 210 205  82  82
-    cyan      #2aa198  6/6 cyan      37 #00afaf 60 -35 -05  42 161 152 175  74  63
-    green     #859900  2/2 green     64 #5f8700 60 -20  65 133 153   0  68 100  60
-
-License
--------
-Copyright (c) 2011 Ethan Schoonover
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-THE SOFTWARE.
diff --git a/sources_non_forked/vim-colors-solarized/autoload/togglebg.vim b/sources_non_forked/vim-colors-solarized/autoload/togglebg.vim
deleted file mode 100644
index 108511f..0000000
--- a/sources_non_forked/vim-colors-solarized/autoload/togglebg.vim
+++ /dev/null
@@ -1,55 +0,0 @@
-" Toggle Background
-" Modified:     2011 Apr 29
-" Maintainer:   Ethan Schoonover
-" License:      OSI approved MIT license
-
-if exists("g:loaded_togglebg")
-    finish
-endif
-let g:loaded_togglebg = 1
-
-" noremap is a bit misleading here if you are unused to vim mapping.
-" in fact, there is remapping, but only of script locally defined remaps, in 
-" this case <SID>TogBG. The <script> argument modifies the noremap scope in 
-" this regard (and the noremenu below).
-nnoremap <unique> <script> <Plug>ToggleBackground <SID>TogBG
-inoremap <unique> <script> <Plug>ToggleBackground <ESC><SID>TogBG<ESC>a
-vnoremap <unique> <script> <Plug>ToggleBackground <ESC><SID>TogBG<ESC>gv
-nnoremenu <script> Window.Toggle\ Background <SID>TogBG
-inoremenu <script> Window.Toggle\ Background <ESC><SID>TogBG<ESC>a
-vnoremenu <script> Window.Toggle\ Background <ESC><SID>TogBG<ESC>gv
-tmenu Window.Toggle\ Background Toggle light and dark background modes
-nnoremenu <script> ToolBar.togglebg <SID>TogBG
-inoremenu <script> ToolBar.togglebg <ESC><SID>TogBG<ESC>a
-vnoremenu <script> ToolBar.togglebg <ESC><SID>TogBG<ESC>gv
-tmenu ToolBar.togglebg Toggle light and dark background modes
-noremap <SID>TogBG  :call <SID>TogBG()<CR>
-
-function! s:TogBG()
-    let &background = ( &background == "dark"? "light" : "dark" )
-    if exists("g:colors_name")
-        exe "colorscheme " . g:colors_name
-    endif
-endfunction
-
-if !exists(":ToggleBG")
-    command ToggleBG :call s:TogBG()
-endif
-
-function! ToggleBackground()
-    echo "Please update your ToggleBackground mapping. ':help togglebg' for information."
-endfunction
-
-function! togglebg#map(mapActivation)
-    try
-        exe "silent! nmap <unique> ".a:mapActivation." <Plug>ToggleBackground"
-        exe "silent! imap <unique> ".a:mapActivation." <Plug>ToggleBackground"
-        exe "silent! vmap <unique> ".a:mapActivation." <Plug>ToggleBackground"
-    finally
-        return 0
-    endtry
-endfunction
-
-if !exists("no_plugin_maps") && !hasmapto('<Plug>ToggleBackground')
-    call togglebg#map("<F5>")
-endif
diff --git a/sources_non_forked/vim-colors-solarized/bitmaps/togglebg.png b/sources_non_forked/vim-colors-solarized/bitmaps/togglebg.png
deleted file mode 100644
index 4c7dfef..0000000
Binary files a/sources_non_forked/vim-colors-solarized/bitmaps/togglebg.png and /dev/null differ
diff --git a/sources_non_forked/vim-colors-solarized/colors/solarized.vim b/sources_non_forked/vim-colors-solarized/colors/solarized.vim
deleted file mode 100644
index 70f5223..0000000
--- a/sources_non_forked/vim-colors-solarized/colors/solarized.vim
+++ /dev/null
@@ -1,1117 +0,0 @@
-" Name:     Solarized vim colorscheme
-" Author:   Ethan Schoonover <es@ethanschoonover.com>
-" URL:      http://ethanschoonover.com/solarized
-"           (see this url for latest release & screenshots)
-" License:  OSI approved MIT license (see end of this file)
-" Created:  In the middle of the night
-" Modified: 2011 May 05
-"
-" Usage "{{{
-"
-" ---------------------------------------------------------------------
-" ABOUT:
-" ---------------------------------------------------------------------
-" Solarized is a carefully designed selective contrast colorscheme with dual
-" light and dark modes that runs in both GUI, 256 and 16 color modes.
-"
-" See the homepage above for screenshots and details.
-"
-" ---------------------------------------------------------------------
-" OPTIONS:
-" ---------------------------------------------------------------------
-" See the "solarized.txt" help file included with this colorscheme (in the 
-" "doc" subdirectory) for information on options, usage, the Toggle Background 
-" function and more. If you have already installed Solarized, this is available 
-" from the Solarized menu and command line as ":help solarized"
-"
-" ---------------------------------------------------------------------
-" INSTALLATION:
-" ---------------------------------------------------------------------
-" Two options for installation: manual or pathogen
-"
-" MANUAL INSTALLATION OPTION:
-" ---------------------------------------------------------------------
-"
-" 1.  Download the solarized distribution (available on the homepage above)
-"     and unarchive the file.
-" 2.  Move `solarized.vim` to your `.vim/colors` directory.
-" 3.  Move each of the files in each subdirectories to the corresponding .vim
-"     subdirectory (e.g. autoload/togglebg.vim goes into your .vim/autoload 
-"     directory as .vim/autoload/togglebg.vim).
-"
-" RECOMMENDED PATHOGEN INSTALLATION OPTION:
-" ---------------------------------------------------------------------
-"
-" 1.  Download and install Tim Pope's Pathogen from:
-"     https://github.com/tpope/vim-pathogen
-"
-" 2.  Next, move or clone the `vim-colors-solarized` directory so that it is
-"     a subdirectory of the `.vim/bundle` directory.
-"
-"     a. **clone with git:**
-"
-"       $ cd ~/.vim/bundle
-"       $ git clone git://github.com/altercation/vim-colors-solarized.git
-"
-"     b. **or move manually into the pathogen bundle directory:**
-"         In the parent directory of vim-colors-solarized:
-"
-"         $ mv vim-colors-solarized ~/.vim/bundle/
-"
-" MODIFY VIMRC:
-"
-" After either Option 1 or Option 2 above, put the following two lines in your
-" .vimrc:
-"
-"     syntax enable
-"     set background=dark
-"     colorscheme solarized
-"
-" or, for the light background mode of Solarized:
-"
-"     syntax enable
-"     set background=light
-"     colorscheme solarized
-"
-" I like to have a different background in GUI and terminal modes, so I can use
-" the following if-then. However, I find vim's background autodetection to be
-" pretty good and, at least with MacVim, I can leave this background value
-" assignment out entirely and get the same results.
-"
-"     if has('gui_running')
-"       set background=light
-"     else
-"       set background=dark
-"     endif
-"
-" See the Solarized homepage at http://ethanschoonover.com/solarized for
-" screenshots which will help you select either the light or dark background.
-"
-" ---------------------------------------------------------------------
-" COLOR VALUES
-" ---------------------------------------------------------------------
-" Download palettes and files from: http://ethanschoonover.com/solarized
-"
-" L\*a\*b values are canonical (White D65, Reference D50), other values are
-" matched in sRGB space.
-"
-" SOLARIZED HEX     16/8 TERMCOL  XTERM/HEX   L*A*B      sRGB        HSB
-" --------- ------- ---- -------  ----------- ---------- ----------- -----------
-" base03    #002b36  8/4 brblack  234 #1c1c1c 15 -12 -12   0  43  54 193 100  21
-" base02    #073642  0/4 black    235 #262626 20 -12 -12   7  54  66 192  90  26
-" base01    #586e75 10/7 brgreen  240 #4e4e4e 45 -07 -07  88 110 117 194  25  46
-" base00    #657b83 11/7 bryellow 241 #585858 50 -07 -07 101 123 131 195  23  51
-" base0     #839496 12/6 brblue   244 #808080 60 -06 -03 131 148 150 186  13  59
-" base1     #93a1a1 14/4 brcyan   245 #8a8a8a 65 -05 -02 147 161 161 180   9  63
-" base2     #eee8d5  7/7 white    254 #d7d7af 92 -00  10 238 232 213  44  11  93
-" base3     #fdf6e3 15/7 brwhite  230 #ffffd7 97  00  10 253 246 227  44  10  99
-" yellow    #b58900  3/3 yellow   136 #af8700 60  10  65 181 137   0  45 100  71
-" orange    #cb4b16  9/3 brred    166 #d75f00 50  50  55 203  75  22  18  89  80
-" red       #dc322f  1/1 red      160 #d70000 50  65  45 220  50  47   1  79  86
-" magenta   #d33682  5/5 magenta  125 #af005f 50  65 -05 211  54 130 331  74  83
-" violet    #6c71c4 13/5 brmagenta 61 #5f5faf 50  15 -45 108 113 196 237  45  77
-" blue      #268bd2  4/4 blue      33 #0087ff 55 -10 -45  38 139 210 205  82  82
-" cyan      #2aa198  6/6 cyan      37 #00afaf 60 -35 -05  42 161 152 175  74  63
-" green     #859900  2/2 green     64 #5f8700 60 -20  65 133 153   0  68 100  60
-"
-" ---------------------------------------------------------------------
-" COLORSCHEME HACKING
-" ---------------------------------------------------------------------
-"
-" Useful commands for testing colorschemes:
-" :source $VIMRUNTIME/syntax/hitest.vim
-" :help highlight-groups
-" :help cterm-colors
-" :help group-name
-"
-" Useful links for developing colorschemes:
-" http://www.vim.org/scripts/script.php?script_id=2937
-" http://vimcasts.org/episodes/creating-colorschemes-for-vim/
-" http://www.frexx.de/xterm-256-notes/"
-"
-" }}}
-" Environment Specific Overrides "{{{
-" Allow or disallow certain features based on current terminal emulator or 
-" environment.
-
-" Terminals that support italics
-let s:terms_italic=[
-            \"rxvt",
-            \"gnome-terminal"
-            \]
-" For reference only, terminals are known to be incomptible.
-" Terminals that are in neither list need to be tested.
-let s:terms_noitalic=[
-            \"iTerm.app",
-            \"Apple_Terminal"
-            \]
-if has("gui_running")
-    let s:terminal_italic=1 " TODO: could refactor to not require this at all
-else
-    let s:terminal_italic=0 " terminals will be guilty until proven compatible
-    for term in s:terms_italic
-        if $TERM_PROGRAM =~ term
-            let s:terminal_italic=1
-        endif
-    endfor
-endif
-
-" }}}
-" Default option values"{{{
-" ---------------------------------------------------------------------
-" s:options_list is used to autogenerate a list of all non-default options 
-" using "call SolarizedOptions()" or with the "Generate .vimrc commands" 
-" Solarized menu option. See the "Menus" section below for the function itself.
-let s:options_list=[
-            \'" this block of commands has been autogenerated by solarized.vim and',
-            \'" includes the current, non-default Solarized option values.',
-            \'" To use, place these commands in your .vimrc file (replacing any',
-            \'" existing colorscheme commands). See also ":help solarized"',
-            \'',
-            \'" ------------------------------------------------------------------',
-            \'" Solarized Colorscheme Config',
-            \'" ------------------------------------------------------------------',
-            \]
-let s:colorscheme_list=[
-            \'syntax enable',
-            \'set background='.&background,
-            \'colorscheme solarized',
-            \]
-let s:defaults_list=[
-            \'" ------------------------------------------------------------------',
-            \'',
-            \'" The following items are available options, but do not need to be',
-            \'" included in your .vimrc as they are currently set to their defaults.',
-            \''
-            \]
-let s:lazycat_list=[
-            \'" lazy method of appending this onto your .vimrc ":w! >> ~/.vimrc"',
-            \'" ------------------------------------------------------------------',
-            \]
-
-function! s:SetOption(name,default)
-    if type(a:default) == type(0)
-        let l:wrap=''
-        let l:ewrap=''
-    else
-        let l:wrap='"'
-        let l:ewrap='\"'
-    endif
-    if !exists("g:solarized_".a:name) || g:solarized_{a:name}==a:default
-        exe 'let g:solarized_'.a:name.'='.l:wrap.a:default.l:wrap.'"'
-        exe 'call add(s:defaults_list, "\" let g:solarized_'.a:name.'='.l:ewrap.g:solarized_{a:name}.l:ewrap.'")'
-    else
-        exe 'call add(s:options_list,  "let g:solarized_'.a:name.'='.l:ewrap.g:solarized_{a:name}.l:ewrap.'    \"default value is '.a:default.'")'
-    endif
-endfunction
-
-if ($TERM_PROGRAM ==? "apple_terminal" && &t_Co < 256)
-    let s:solarized_termtrans_default = 1
-else
-    let s:solarized_termtrans_default = 0
-endif
-call s:SetOption("termtrans",s:solarized_termtrans_default)
-call s:SetOption("degrade",0)
-call s:SetOption("bold",1)
-call s:SetOption("underline",1)
-call s:SetOption("italic",1) " note that we need to override this later if the terminal doesn't support
-call s:SetOption("termcolors",16)
-call s:SetOption("contrast","normal")
-call s:SetOption("visibility","normal")
-call s:SetOption("diffmode","normal")
-call s:SetOption("hitrail",0)
-call s:SetOption("menu",1)
-
-"}}}
-" Colorscheme initialization "{{{
-" ---------------------------------------------------------------------
-hi clear
-if exists("syntax_on")
-  syntax reset
-endif
-let colors_name = "solarized"
-
-"}}}
-" GUI & CSApprox hexadecimal palettes"{{{
-" ---------------------------------------------------------------------
-"
-" Set both gui and terminal color values in separate conditional statements
-" Due to possibility that CSApprox is running (though I suppose we could just
-" leave the hex values out entirely in that case and include only cterm colors)
-" We also check to see if user has set solarized (force use of the
-" neutral gray monotone palette component)
-if (has("gui_running") && g:solarized_degrade == 0)
-    let s:vmode       = "gui"
-    let s:base03      = "#002b36"
-    let s:base02      = "#073642"
-    let s:base01      = "#586e75"
-    let s:base00      = "#657b83"
-    let s:base0       = "#839496"
-    let s:base1       = "#93a1a1"
-    let s:base2       = "#eee8d5"
-    let s:base3       = "#fdf6e3"
-    let s:yellow      = "#b58900"
-    let s:orange      = "#cb4b16"
-    let s:red         = "#dc322f"
-    let s:magenta     = "#d33682"
-    let s:violet      = "#6c71c4"
-    let s:blue        = "#268bd2"
-    let s:cyan        = "#2aa198"
-    "let s:green       = "#859900" "original
-    let s:green       = "#719e07" "experimental
-elseif (has("gui_running") && g:solarized_degrade == 1)
-    " These colors are identical to the 256 color mode. They may be viewed
-    " while in gui mode via "let g:solarized_degrade=1", though this is not
-    " recommened and is for testing only.
-    let s:vmode       = "gui"
-    let s:base03      = "#1c1c1c"
-    let s:base02      = "#262626"
-    let s:base01      = "#4e4e4e"
-    let s:base00      = "#585858"
-    let s:base0       = "#808080"
-    let s:base1       = "#8a8a8a"
-    let s:base2       = "#d7d7af"
-    let s:base3       = "#ffffd7"
-    let s:yellow      = "#af8700"
-    let s:orange      = "#d75f00"
-    let s:red         = "#af0000"
-    let s:magenta     = "#af005f"
-    let s:violet      = "#5f5faf"
-    let s:blue        = "#0087ff"
-    let s:cyan        = "#00afaf"
-    let s:green       = "#5f8700"
-elseif g:solarized_termcolors != 256 && &t_Co >= 16
-    let s:vmode       = "cterm"
-    let s:base03      = "8"
-    let s:base02      = "0"
-    let s:base01      = "10"
-    let s:base00      = "11"
-    let s:base0       = "12"
-    let s:base1       = "14"
-    let s:base2       = "7"
-    let s:base3       = "15"
-    let s:yellow      = "3"
-    let s:orange      = "9"
-    let s:red         = "1"
-    let s:magenta     = "5"
-    let s:violet      = "13"
-    let s:blue        = "4"
-    let s:cyan        = "6"
-    let s:green       = "2"
-elseif g:solarized_termcolors == 256
-    let s:vmode       = "cterm"
-    let s:base03      = "234"
-    let s:base02      = "235"
-    let s:base01      = "239"
-    let s:base00      = "240"
-    let s:base0       = "244"
-    let s:base1       = "245"
-    let s:base2       = "187"
-    let s:base3       = "230"
-    let s:yellow      = "136"
-    let s:orange      = "166"
-    let s:red         = "124"
-    let s:magenta     = "125"
-    let s:violet      = "61"
-    let s:blue        = "33"
-    let s:cyan        = "37"
-    let s:green       = "64"
-else
-    let s:vmode       = "cterm"
-    let s:bright      = "* term=bold cterm=bold"
-"   let s:base03      = "0".s:bright
-"   let s:base02      = "0"
-"   let s:base01      = "2".s:bright
-"   let s:base00      = "3".s:bright
-"   let s:base0       = "4".s:bright
-"   let s:base1       = "6".s:bright
-"   let s:base2       = "7"
-"   let s:base3       = "7".s:bright
-"   let s:yellow      = "3"
-"   let s:orange      = "1".s:bright
-"   let s:red         = "1"
-"   let s:magenta     = "5"
-"   let s:violet      = "5".s:bright
-"   let s:blue        = "4"
-"   let s:cyan        = "6"
-"   let s:green       = "2"
-    let s:base03      = "DarkGray"      " 0*
-    let s:base02      = "Black"         " 0
-    let s:base01      = "LightGreen"    " 2*
-    let s:base00      = "LightYellow"   " 3*
-    let s:base0       = "LightBlue"     " 4*
-    let s:base1       = "LightCyan"     " 6*
-    let s:base2       = "LightGray"     " 7
-    let s:base3       = "White"         " 7*
-    let s:yellow      = "DarkYellow"    " 3
-    let s:orange      = "LightRed"      " 1*
-    let s:red         = "DarkRed"       " 1
-    let s:magenta     = "DarkMagenta"   " 5
-    let s:violet      = "LightMagenta"  " 5*
-    let s:blue        = "DarkBlue"      " 4
-    let s:cyan        = "DarkCyan"      " 6
-    let s:green       = "DarkGreen"     " 2
-
-endif
-"}}}
-" Formatting options and null values for passthrough effect "{{{
-" ---------------------------------------------------------------------
-    let s:none            = "NONE"
-    let s:none            = "NONE"
-    let s:t_none          = "NONE"
-    let s:n               = "NONE"
-    let s:c               = ",undercurl"
-    let s:r               = ",reverse"
-    let s:s               = ",standout"
-    let s:ou              = ""
-    let s:ob              = ""
-"}}}
-" Background value based on termtrans setting "{{{
-" ---------------------------------------------------------------------
-if (has("gui_running") || g:solarized_termtrans == 0)
-    let s:back        = s:base03
-else
-    let s:back        = "NONE"
-endif
-"}}}
-" Alternate light scheme "{{{
-" ---------------------------------------------------------------------
-if &background == "light"
-    let s:temp03      = s:base03
-    let s:temp02      = s:base02
-    let s:temp01      = s:base01
-    let s:temp00      = s:base00
-    let s:base03      = s:base3
-    let s:base02      = s:base2
-    let s:base01      = s:base1
-    let s:base00      = s:base0
-    let s:base0       = s:temp00
-    let s:base1       = s:temp01
-    let s:base2       = s:temp02
-    let s:base3       = s:temp03
-    if (s:back != "NONE")
-        let s:back    = s:base03
-    endif
-endif
-"}}}
-" Optional contrast schemes "{{{
-" ---------------------------------------------------------------------
-if g:solarized_contrast == "high"
-    let s:base01      = s:base00
-    let s:base00      = s:base0
-    let s:base0       = s:base1
-    let s:base1       = s:base2
-    let s:base2       = s:base3
-    let s:back        = s:back
-endif
-if g:solarized_contrast == "low"
-    let s:back        = s:base02
-    let s:ou          = ",underline"
-endif
-"}}}
-" Overrides dependent on user specified values and environment "{{{
-" ---------------------------------------------------------------------
-if (g:solarized_bold == 0 || &t_Co == 8 )
-    let s:b           = ""
-    let s:bb          = ",bold"
-else
-    let s:b           = ",bold"
-    let s:bb          = ""
-endif
-
-if g:solarized_underline == 0
-    let s:u           = ""
-else
-    let s:u           = ",underline"
-endif
-
-if g:solarized_italic == 0 || s:terminal_italic == 0
-    let s:i           = ""
-else
-    let s:i           = ",italic"
-endif
-"}}}
-" Highlighting primitives"{{{
-" ---------------------------------------------------------------------
-
-exe "let s:bg_none      = ' ".s:vmode."bg=".s:none   ."'"
-exe "let s:bg_back      = ' ".s:vmode."bg=".s:back   ."'"
-exe "let s:bg_base03    = ' ".s:vmode."bg=".s:base03 ."'"
-exe "let s:bg_base02    = ' ".s:vmode."bg=".s:base02 ."'"
-exe "let s:bg_base01    = ' ".s:vmode."bg=".s:base01 ."'"
-exe "let s:bg_base00    = ' ".s:vmode."bg=".s:base00 ."'"
-exe "let s:bg_base0     = ' ".s:vmode."bg=".s:base0  ."'"
-exe "let s:bg_base1     = ' ".s:vmode."bg=".s:base1  ."'"
-exe "let s:bg_base2     = ' ".s:vmode."bg=".s:base2  ."'"
-exe "let s:bg_base3     = ' ".s:vmode."bg=".s:base3  ."'"
-exe "let s:bg_green     = ' ".s:vmode."bg=".s:green  ."'"
-exe "let s:bg_yellow    = ' ".s:vmode."bg=".s:yellow ."'"
-exe "let s:bg_orange    = ' ".s:vmode."bg=".s:orange ."'"
-exe "let s:bg_red       = ' ".s:vmode."bg=".s:red    ."'"
-exe "let s:bg_magenta   = ' ".s:vmode."bg=".s:magenta."'"
-exe "let s:bg_violet    = ' ".s:vmode."bg=".s:violet ."'"
-exe "let s:bg_blue      = ' ".s:vmode."bg=".s:blue   ."'"
-exe "let s:bg_cyan      = ' ".s:vmode."bg=".s:cyan   ."'"
-
-exe "let s:fg_none      = ' ".s:vmode."fg=".s:none   ."'"
-exe "let s:fg_back      = ' ".s:vmode."fg=".s:back   ."'"
-exe "let s:fg_base03    = ' ".s:vmode."fg=".s:base03 ."'"
-exe "let s:fg_base02    = ' ".s:vmode."fg=".s:base02 ."'"
-exe "let s:fg_base01    = ' ".s:vmode."fg=".s:base01 ."'"
-exe "let s:fg_base00    = ' ".s:vmode."fg=".s:base00 ."'"
-exe "let s:fg_base0     = ' ".s:vmode."fg=".s:base0  ."'"
-exe "let s:fg_base1     = ' ".s:vmode."fg=".s:base1  ."'"
-exe "let s:fg_base2     = ' ".s:vmode."fg=".s:base2  ."'"
-exe "let s:fg_base3     = ' ".s:vmode."fg=".s:base3  ."'"
-exe "let s:fg_green     = ' ".s:vmode."fg=".s:green  ."'"
-exe "let s:fg_yellow    = ' ".s:vmode."fg=".s:yellow ."'"
-exe "let s:fg_orange    = ' ".s:vmode."fg=".s:orange ."'"
-exe "let s:fg_red       = ' ".s:vmode."fg=".s:red    ."'"
-exe "let s:fg_magenta   = ' ".s:vmode."fg=".s:magenta."'"
-exe "let s:fg_violet    = ' ".s:vmode."fg=".s:violet ."'"
-exe "let s:fg_blue      = ' ".s:vmode."fg=".s:blue   ."'"
-exe "let s:fg_cyan      = ' ".s:vmode."fg=".s:cyan   ."'"
-
-exe "let s:fmt_none     = ' ".s:vmode."=NONE".          " term=NONE".    "'"
-exe "let s:fmt_bold     = ' ".s:vmode."=NONE".s:b.      " term=NONE".s:b."'"
-exe "let s:fmt_bldi     = ' ".s:vmode."=NONE".s:b.      " term=NONE".s:b."'"
-exe "let s:fmt_undr     = ' ".s:vmode."=NONE".s:u.      " term=NONE".s:u."'"
-exe "let s:fmt_undb     = ' ".s:vmode."=NONE".s:u.s:b.  " term=NONE".s:u.s:b."'"
-exe "let s:fmt_undi     = ' ".s:vmode."=NONE".s:u.      " term=NONE".s:u."'"
-exe "let s:fmt_uopt     = ' ".s:vmode."=NONE".s:ou.     " term=NONE".s:ou."'"
-exe "let s:fmt_curl     = ' ".s:vmode."=NONE".s:c.      " term=NONE".s:c."'"
-exe "let s:fmt_ital     = ' ".s:vmode."=NONE".s:i.      " term=NONE".s:i."'"
-exe "let s:fmt_stnd     = ' ".s:vmode."=NONE".s:s.      " term=NONE".s:s."'"
-exe "let s:fmt_revr     = ' ".s:vmode."=NONE".s:r.      " term=NONE".s:r."'"
-exe "let s:fmt_revb     = ' ".s:vmode."=NONE".s:r.s:b.  " term=NONE".s:r.s:b."'"
-" revbb (reverse bold for bright colors) is only set to actual bold in low 
-" color terminals (t_co=8, such as OS X Terminal.app) and should only be used 
-" with colors 8-15.
-exe "let s:fmt_revbb    = ' ".s:vmode."=NONE".s:r.s:bb.   " term=NONE".s:r.s:bb."'"
-exe "let s:fmt_revbbu   = ' ".s:vmode."=NONE".s:r.s:bb.s:u." term=NONE".s:r.s:bb.s:u."'"
-
-if has("gui_running")
-    exe "let s:sp_none      = ' guisp=".s:none   ."'"
-    exe "let s:sp_back      = ' guisp=".s:back   ."'"
-    exe "let s:sp_base03    = ' guisp=".s:base03 ."'"
-    exe "let s:sp_base02    = ' guisp=".s:base02 ."'"
-    exe "let s:sp_base01    = ' guisp=".s:base01 ."'"
-    exe "let s:sp_base00    = ' guisp=".s:base00 ."'"
-    exe "let s:sp_base0     = ' guisp=".s:base0  ."'"
-    exe "let s:sp_base1     = ' guisp=".s:base1  ."'"
-    exe "let s:sp_base2     = ' guisp=".s:base2  ."'"
-    exe "let s:sp_base3     = ' guisp=".s:base3  ."'"
-    exe "let s:sp_green     = ' guisp=".s:green  ."'"
-    exe "let s:sp_yellow    = ' guisp=".s:yellow ."'"
-    exe "let s:sp_orange    = ' guisp=".s:orange ."'"
-    exe "let s:sp_red       = ' guisp=".s:red    ."'"
-    exe "let s:sp_magenta   = ' guisp=".s:magenta."'"
-    exe "let s:sp_violet    = ' guisp=".s:violet ."'"
-    exe "let s:sp_blue      = ' guisp=".s:blue   ."'"
-    exe "let s:sp_cyan      = ' guisp=".s:cyan   ."'"
-else
-    let s:sp_none      = ""
-    let s:sp_back      = ""
-    let s:sp_base03    = ""
-    let s:sp_base02    = ""
-    let s:sp_base01    = ""
-    let s:sp_base00    = ""
-    let s:sp_base0     = ""
-    let s:sp_base1     = ""
-    let s:sp_base2     = ""
-    let s:sp_base3     = ""
-    let s:sp_green     = ""
-    let s:sp_yellow    = ""
-    let s:sp_orange    = ""
-    let s:sp_red       = ""
-    let s:sp_magenta   = ""
-    let s:sp_violet    = ""
-    let s:sp_blue      = ""
-    let s:sp_cyan      = ""
-endif
-
-"}}}
-" Basic highlighting"{{{
-" ---------------------------------------------------------------------
-" note that link syntax to avoid duplicate configuration doesn't work with the
-" exe compiled formats
-
-exe "hi! Normal"         .s:fmt_none   .s:fg_base0  .s:bg_back
-
-exe "hi! Comment"        .s:fmt_ital   .s:fg_base01 .s:bg_none
-"       *Comment         any comment
-
-exe "hi! Constant"       .s:fmt_none   .s:fg_cyan   .s:bg_none
-"       *Constant        any constant
-"        String          a string constant: "this is a string"
-"        Character       a character constant: 'c', '\n'
-"        Number          a number constant: 234, 0xff
-"        Boolean         a boolean constant: TRUE, false
-"        Float           a floating point constant: 2.3e10
-
-exe "hi! Identifier"     .s:fmt_none   .s:fg_blue   .s:bg_none
-"       *Identifier      any variable name
-"        Function        function name (also: methods for classes)
-"
-exe "hi! Statement"      .s:fmt_none   .s:fg_green  .s:bg_none
-"       *Statement       any statement
-"        Conditional     if, then, else, endif, switch, etc.
-"        Repeat          for, do, while, etc.
-"        Label           case, default, etc.
-"        Operator        "sizeof", "+", "*", etc.
-"        Keyword         any other keyword
-"        Exception       try, catch, throw
-
-exe "hi! PreProc"        .s:fmt_none   .s:fg_orange .s:bg_none
-"       *PreProc         generic Preprocessor
-"        Include         preprocessor #include
-"        Define          preprocessor #define
-"        Macro           same as Define
-"        PreCondit       preprocessor #if, #else, #endif, etc.
-
-exe "hi! Type"           .s:fmt_none   .s:fg_yellow .s:bg_none
-"       *Type            int, long, char, etc.
-"        StorageClass    static, register, volatile, etc.
-"        Structure       struct, union, enum, etc.
-"        Typedef         A typedef
-
-exe "hi! Special"        .s:fmt_none   .s:fg_red    .s:bg_none
-"       *Special         any special symbol
-"        SpecialChar     special character in a constant
-"        Tag             you can use CTRL-] on this
-"        Delimiter       character that needs attention
-"        SpecialComment  special things inside a comment
-"        Debug           debugging statements
-
-exe "hi! Underlined"     .s:fmt_none   .s:fg_violet .s:bg_none
-"       *Underlined      text that stands out, HTML links
-
-exe "hi! Ignore"         .s:fmt_none   .s:fg_none   .s:bg_none
-"       *Ignore          left blank, hidden  |hl-Ignore|
-
-exe "hi! Error"          .s:fmt_bold   .s:fg_red    .s:bg_none
-"       *Error           any erroneous construct
-
-exe "hi! Todo"           .s:fmt_bold   .s:fg_magenta.s:bg_none
-"       *Todo            anything that needs extra attention; mostly the
-"                        keywords TODO FIXME and XXX
-"
-"}}}
-" Extended highlighting "{{{
-" ---------------------------------------------------------------------
-if      (g:solarized_visibility=="high")
-    exe "hi! SpecialKey" .s:fmt_revr   .s:fg_red    .s:bg_none
-    exe "hi! NonText"    .s:fmt_bold   .s:fg_red    .s:bg_none
-elseif  (g:solarized_visibility=="low")
-    exe "hi! SpecialKey" .s:fmt_bold   .s:fg_base02 .s:bg_none
-    exe "hi! NonText"    .s:fmt_bold   .s:fg_base02 .s:bg_none
-else
-    exe "hi! SpecialKey" .s:fmt_bold   .s:fg_base00 .s:bg_base02
-    exe "hi! NonText"    .s:fmt_bold   .s:fg_base00 .s:bg_none
-endif
-exe "hi! StatusLine"     .s:fmt_none   .s:fg_base1  .s:bg_base02 .s:fmt_revbb
-exe "hi! StatusLineNC"   .s:fmt_none   .s:fg_base00 .s:bg_base02 .s:fmt_revbb
-exe "hi! Visual"         .s:fmt_none   .s:fg_base01 .s:bg_base03 .s:fmt_revbb
-exe "hi! Directory"      .s:fmt_none   .s:fg_blue   .s:bg_none
-exe "hi! ErrorMsg"       .s:fmt_revr   .s:fg_red    .s:bg_none
-exe "hi! IncSearch"      .s:fmt_stnd   .s:fg_orange .s:bg_none
-exe "hi! Search"         .s:fmt_revr   .s:fg_yellow .s:bg_none
-exe "hi! MoreMsg"        .s:fmt_none   .s:fg_blue   .s:bg_none
-exe "hi! ModeMsg"        .s:fmt_none   .s:fg_blue   .s:bg_none
-exe "hi! LineNr"         .s:fmt_none   .s:fg_base01 .s:bg_base02
-exe "hi! Question"       .s:fmt_bold   .s:fg_cyan   .s:bg_none
-if ( has("gui_running") || &t_Co > 8 )
-    exe "hi! VertSplit"  .s:fmt_none   .s:fg_base00 .s:bg_base00
-else
-    exe "hi! VertSplit"  .s:fmt_revbb  .s:fg_base00 .s:bg_base02
-endif
-exe "hi! Title"          .s:fmt_bold   .s:fg_orange .s:bg_none
-exe "hi! VisualNOS"      .s:fmt_stnd   .s:fg_none   .s:bg_base02 .s:fmt_revbb
-exe "hi! WarningMsg"     .s:fmt_bold   .s:fg_red    .s:bg_none
-exe "hi! WildMenu"       .s:fmt_none   .s:fg_base2  .s:bg_base02 .s:fmt_revbb
-exe "hi! Folded"         .s:fmt_undb   .s:fg_base0  .s:bg_base02  .s:sp_base03
-exe "hi! FoldColumn"     .s:fmt_none   .s:fg_base0  .s:bg_base02
-if      (g:solarized_diffmode=="high")
-exe "hi! DiffAdd"        .s:fmt_revr   .s:fg_green  .s:bg_none
-exe "hi! DiffChange"     .s:fmt_revr   .s:fg_yellow .s:bg_none
-exe "hi! DiffDelete"     .s:fmt_revr   .s:fg_red    .s:bg_none
-exe "hi! DiffText"       .s:fmt_revr   .s:fg_blue   .s:bg_none
-elseif  (g:solarized_diffmode=="low")
-exe "hi! DiffAdd"        .s:fmt_undr   .s:fg_green  .s:bg_none   .s:sp_green
-exe "hi! DiffChange"     .s:fmt_undr   .s:fg_yellow .s:bg_none   .s:sp_yellow
-exe "hi! DiffDelete"     .s:fmt_bold   .s:fg_red    .s:bg_none
-exe "hi! DiffText"       .s:fmt_undr   .s:fg_blue   .s:bg_none   .s:sp_blue
-else " normal
-    if has("gui_running")
-exe "hi! DiffAdd"        .s:fmt_bold   .s:fg_green  .s:bg_base02 .s:sp_green
-exe "hi! DiffChange"     .s:fmt_bold   .s:fg_yellow .s:bg_base02 .s:sp_yellow
-exe "hi! DiffDelete"     .s:fmt_bold   .s:fg_red    .s:bg_base02
-exe "hi! DiffText"       .s:fmt_bold   .s:fg_blue   .s:bg_base02 .s:sp_blue
-    else
-exe "hi! DiffAdd"        .s:fmt_none   .s:fg_green  .s:bg_base02 .s:sp_green
-exe "hi! DiffChange"     .s:fmt_none   .s:fg_yellow .s:bg_base02 .s:sp_yellow
-exe "hi! DiffDelete"     .s:fmt_none   .s:fg_red    .s:bg_base02
-exe "hi! DiffText"       .s:fmt_none   .s:fg_blue   .s:bg_base02 .s:sp_blue
-    endif
-endif
-exe "hi! SignColumn"     .s:fmt_none   .s:fg_base0
-exe "hi! Conceal"        .s:fmt_none   .s:fg_blue   .s:bg_none
-exe "hi! SpellBad"       .s:fmt_curl   .s:fg_none   .s:bg_none    .s:sp_red
-exe "hi! SpellCap"       .s:fmt_curl   .s:fg_none   .s:bg_none    .s:sp_violet
-exe "hi! SpellRare"      .s:fmt_curl   .s:fg_none   .s:bg_none    .s:sp_cyan
-exe "hi! SpellLocal"     .s:fmt_curl   .s:fg_none   .s:bg_none    .s:sp_yellow
-exe "hi! Pmenu"          .s:fmt_none   .s:fg_base0  .s:bg_base02  .s:fmt_revbb
-exe "hi! PmenuSel"       .s:fmt_none   .s:fg_base01 .s:bg_base2   .s:fmt_revbb
-exe "hi! PmenuSbar"      .s:fmt_none   .s:fg_base2  .s:bg_base0   .s:fmt_revbb
-exe "hi! PmenuThumb"     .s:fmt_none   .s:fg_base0  .s:bg_base03  .s:fmt_revbb
-exe "hi! TabLine"        .s:fmt_undr   .s:fg_base0  .s:bg_base02  .s:sp_base0
-exe "hi! TabLineFill"    .s:fmt_undr   .s:fg_base0  .s:bg_base02  .s:sp_base0
-exe "hi! TabLineSel"     .s:fmt_undr   .s:fg_base01 .s:bg_base2   .s:sp_base0  .s:fmt_revbbu
-exe "hi! CursorColumn"   .s:fmt_none   .s:fg_none   .s:bg_base02
-exe "hi! CursorLine"     .s:fmt_uopt   .s:fg_none   .s:bg_base02  .s:sp_base1
-exe "hi! ColorColumn"    .s:fmt_none   .s:fg_none   .s:bg_base02
-exe "hi! Cursor"         .s:fmt_none   .s:fg_base03 .s:bg_base0
-hi! link lCursor Cursor
-exe "hi! MatchParen"     .s:fmt_bold   .s:fg_red    .s:bg_base01
-
-"}}}
-" vim syntax highlighting "{{{
-" ---------------------------------------------------------------------
-"exe "hi! vimLineComment" . s:fg_base01 .s:bg_none   .s:fmt_ital
-"hi! link vimComment Comment
-"hi! link vimLineComment Comment
-hi! link vimVar Identifier
-hi! link vimFunc Function
-hi! link vimUserFunc Function
-hi! link helpSpecial Special
-hi! link vimSet Normal
-hi! link vimSetEqual Normal
-exe "hi! vimCommentString"  .s:fmt_none    .s:fg_violet .s:bg_none
-exe "hi! vimCommand"        .s:fmt_none    .s:fg_yellow .s:bg_none
-exe "hi! vimCmdSep"         .s:fmt_bold    .s:fg_blue   .s:bg_none
-exe "hi! helpExample"       .s:fmt_none    .s:fg_base1  .s:bg_none
-exe "hi! helpOption"        .s:fmt_none    .s:fg_cyan   .s:bg_none
-exe "hi! helpNote"          .s:fmt_none    .s:fg_magenta.s:bg_none
-exe "hi! helpVim"           .s:fmt_none    .s:fg_magenta.s:bg_none
-exe "hi! helpHyperTextJump" .s:fmt_undr    .s:fg_blue   .s:bg_none
-exe "hi! helpHyperTextEntry".s:fmt_none    .s:fg_green  .s:bg_none
-exe "hi! vimIsCommand"      .s:fmt_none    .s:fg_base00 .s:bg_none
-exe "hi! vimSynMtchOpt"     .s:fmt_none    .s:fg_yellow .s:bg_none
-exe "hi! vimSynType"        .s:fmt_none    .s:fg_cyan   .s:bg_none
-exe "hi! vimHiLink"         .s:fmt_none    .s:fg_blue   .s:bg_none
-exe "hi! vimHiGroup"        .s:fmt_none    .s:fg_blue   .s:bg_none
-exe "hi! vimGroup"          .s:fmt_undb    .s:fg_blue   .s:bg_none
-"}}}
-" diff highlighting "{{{
-" ---------------------------------------------------------------------
-hi! link diffAdded Statement
-hi! link diffLine Identifier
-"}}}
-" git & gitcommit highlighting "{{{
-"git
-"exe "hi! gitDateHeader"
-"exe "hi! gitIdentityHeader"
-"exe "hi! gitIdentityKeyword"
-"exe "hi! gitNotesHeader"
-"exe "hi! gitReflogHeader"
-"exe "hi! gitKeyword"
-"exe "hi! gitIdentity"
-"exe "hi! gitEmailDelimiter"
-"exe "hi! gitEmail"
-"exe "hi! gitDate"
-"exe "hi! gitMode"
-"exe "hi! gitHashAbbrev"
-"exe "hi! gitHash"
-"exe "hi! gitReflogMiddle"
-"exe "hi! gitReference"
-"exe "hi! gitStage"
-"exe "hi! gitType"
-"exe "hi! gitDiffAdded"
-"exe "hi! gitDiffRemoved"
-"gitcommit
-"exe "hi! gitcommitSummary"      
-exe "hi! gitcommitComment"      .s:fmt_ital     .s:fg_base01    .s:bg_none
-hi! link gitcommitUntracked gitcommitComment
-hi! link gitcommitDiscarded gitcommitComment
-hi! link gitcommitSelected  gitcommitComment
-exe "hi! gitcommitUnmerged"     .s:fmt_bold     .s:fg_green     .s:bg_none
-exe "hi! gitcommitOnBranch"     .s:fmt_bold     .s:fg_base01    .s:bg_none
-exe "hi! gitcommitBranch"       .s:fmt_bold     .s:fg_magenta   .s:bg_none
-hi! link gitcommitNoBranch gitcommitBranch
-exe "hi! gitcommitDiscardedType".s:fmt_none     .s:fg_red       .s:bg_none
-exe "hi! gitcommitSelectedType" .s:fmt_none     .s:fg_green     .s:bg_none
-"exe "hi! gitcommitUnmergedType"
-"exe "hi! gitcommitType"
-"exe "hi! gitcommitNoChanges"
-"exe "hi! gitcommitHeader"
-exe "hi! gitcommitHeader"       .s:fmt_none     .s:fg_base01    .s:bg_none
-exe "hi! gitcommitUntrackedFile".s:fmt_bold     .s:fg_cyan      .s:bg_none
-exe "hi! gitcommitDiscardedFile".s:fmt_bold     .s:fg_red       .s:bg_none
-exe "hi! gitcommitSelectedFile" .s:fmt_bold     .s:fg_green     .s:bg_none
-exe "hi! gitcommitUnmergedFile" .s:fmt_bold     .s:fg_yellow    .s:bg_none
-exe "hi! gitcommitFile"         .s:fmt_bold     .s:fg_base0     .s:bg_none
-hi! link gitcommitDiscardedArrow gitcommitDiscardedFile
-hi! link gitcommitSelectedArrow  gitcommitSelectedFile
-hi! link gitcommitUnmergedArrow  gitcommitUnmergedFile
-"exe "hi! gitcommitArrow"
-"exe "hi! gitcommitOverflow"
-"exe "hi! gitcommitBlank"
-" }}}
-" html highlighting "{{{
-" ---------------------------------------------------------------------
-exe "hi! htmlTag"           .s:fmt_none .s:fg_base01 .s:bg_none
-exe "hi! htmlEndTag"        .s:fmt_none .s:fg_base01 .s:bg_none
-exe "hi! htmlTagN"          .s:fmt_bold .s:fg_base1  .s:bg_none
-exe "hi! htmlTagName"       .s:fmt_bold .s:fg_blue   .s:bg_none
-exe "hi! htmlSpecialTagName".s:fmt_ital .s:fg_blue   .s:bg_none
-exe "hi! htmlArg"           .s:fmt_none .s:fg_base00 .s:bg_none
-exe "hi! javaScript"        .s:fmt_none .s:fg_yellow .s:bg_none
-"}}}
-" perl highlighting "{{{
-" ---------------------------------------------------------------------
-exe "hi! perlHereDoc"    . s:fg_base1  .s:bg_back   .s:fmt_none
-exe "hi! perlVarPlain"   . s:fg_yellow .s:bg_back   .s:fmt_none
-exe "hi! perlStatementFileDesc". s:fg_cyan.s:bg_back.s:fmt_none
-
-"}}}
-" tex highlighting "{{{
-" ---------------------------------------------------------------------
-exe "hi! texStatement"   . s:fg_cyan   .s:bg_back   .s:fmt_none
-exe "hi! texMathZoneX"   . s:fg_yellow .s:bg_back   .s:fmt_none
-exe "hi! texMathMatcher" . s:fg_yellow .s:bg_back   .s:fmt_none
-exe "hi! texMathMatcher" . s:fg_yellow .s:bg_back   .s:fmt_none
-exe "hi! texRefLabel"    . s:fg_yellow .s:bg_back   .s:fmt_none
-"}}}
-" ruby highlighting "{{{
-" ---------------------------------------------------------------------
-exe "hi! rubyDefine"     . s:fg_base1  .s:bg_back   .s:fmt_bold
-"rubyInclude
-"rubySharpBang
-"rubyAccess
-"rubyPredefinedVariable
-"rubyBoolean
-"rubyClassVariable
-"rubyBeginEnd
-"rubyRepeatModifier
-"hi! link rubyArrayDelimiter    Special  " [ , , ]
-"rubyCurlyBlock  { , , }
-
-"hi! link rubyClass             Keyword
-"hi! link rubyModule            Keyword
-"hi! link rubyKeyword           Keyword
-"hi! link rubyOperator          Operator
-"hi! link rubyIdentifier        Identifier
-"hi! link rubyInstanceVariable  Identifier
-"hi! link rubyGlobalVariable    Identifier
-"hi! link rubyClassVariable     Identifier
-"hi! link rubyConstant          Type
-"}}}
-" haskell syntax highlighting"{{{
-" ---------------------------------------------------------------------
-" For use with syntax/haskell.vim : Haskell Syntax File
-" http://www.vim.org/scripts/script.php?script_id=3034
-" See also Steffen Siering's github repository:
-" http://github.com/urso/dotrc/blob/master/vim/syntax/haskell.vim
-" ---------------------------------------------------------------------
-"
-" Treat True and False specially, see the plugin referenced above
-let hs_highlight_boolean=1
-" highlight delims, see the plugin referenced above
-let hs_highlight_delimiters=1
-
-exe "hi! cPreCondit". s:fg_orange.s:bg_none   .s:fmt_none
-
-exe "hi! VarId"    . s:fg_blue   .s:bg_none   .s:fmt_none
-exe "hi! ConId"    . s:fg_yellow .s:bg_none   .s:fmt_none
-exe "hi! hsImport" . s:fg_magenta.s:bg_none   .s:fmt_none
-exe "hi! hsString" . s:fg_base00 .s:bg_none   .s:fmt_none
-
-exe "hi! hsStructure"        . s:fg_cyan   .s:bg_none   .s:fmt_none
-exe "hi! hs_hlFunctionName"  . s:fg_blue   .s:bg_none
-exe "hi! hsStatement"        . s:fg_cyan   .s:bg_none   .s:fmt_none
-exe "hi! hsImportLabel"      . s:fg_cyan   .s:bg_none   .s:fmt_none
-exe "hi! hs_OpFunctionName"  . s:fg_yellow .s:bg_none   .s:fmt_none
-exe "hi! hs_DeclareFunction" . s:fg_orange .s:bg_none   .s:fmt_none
-exe "hi! hsVarSym"           . s:fg_cyan   .s:bg_none   .s:fmt_none
-exe "hi! hsType"             . s:fg_yellow .s:bg_none   .s:fmt_none
-exe "hi! hsTypedef"          . s:fg_cyan   .s:bg_none   .s:fmt_none
-exe "hi! hsModuleName"       . s:fg_green  .s:bg_none   .s:fmt_undr
-exe "hi! hsModuleStartLabel" . s:fg_magenta.s:bg_none   .s:fmt_none
-hi! link hsImportParams      Delimiter
-hi! link hsDelimTypeExport   Delimiter
-hi! link hsModuleStartLabel  hsStructure
-hi! link hsModuleWhereLabel  hsModuleStartLabel
-
-" following is for the haskell-conceal plugin
-" the first two items don't have an impact, but better safe
-exe "hi! hsNiceOperator"     . s:fg_cyan   .s:bg_none   .s:fmt_none
-exe "hi! hsniceoperator"     . s:fg_cyan   .s:bg_none   .s:fmt_none
-
-"}}}
-" pandoc markdown syntax highlighting "{{{
-" ---------------------------------------------------------------------
-
-"PandocHiLink pandocNormalBlock
-exe "hi! pandocTitleBlock"               .s:fg_blue   .s:bg_none   .s:fmt_none
-exe "hi! pandocTitleBlockTitle"          .s:fg_blue   .s:bg_none   .s:fmt_bold
-exe "hi! pandocTitleComment"             .s:fg_blue   .s:bg_none   .s:fmt_bold
-exe "hi! pandocComment"                  .s:fg_base01 .s:bg_none   .s:fmt_ital
-exe "hi! pandocVerbatimBlock"            .s:fg_yellow .s:bg_none   .s:fmt_none
-hi! link pandocVerbatimBlockDeep         pandocVerbatimBlock
-hi! link pandocCodeBlock                 pandocVerbatimBlock
-hi! link pandocCodeBlockDelim            pandocVerbatimBlock
-exe "hi! pandocBlockQuote"               .s:fg_blue   .s:bg_none   .s:fmt_none
-exe "hi! pandocBlockQuoteLeader1"        .s:fg_blue   .s:bg_none   .s:fmt_none
-exe "hi! pandocBlockQuoteLeader2"        .s:fg_cyan   .s:bg_none   .s:fmt_none
-exe "hi! pandocBlockQuoteLeader3"        .s:fg_yellow .s:bg_none   .s:fmt_none
-exe "hi! pandocBlockQuoteLeader4"        .s:fg_red    .s:bg_none   .s:fmt_none
-exe "hi! pandocBlockQuoteLeader5"        .s:fg_base0  .s:bg_none   .s:fmt_none
-exe "hi! pandocBlockQuoteLeader6"        .s:fg_base01 .s:bg_none   .s:fmt_none
-exe "hi! pandocListMarker"               .s:fg_magenta.s:bg_none   .s:fmt_none
-exe "hi! pandocListReference"            .s:fg_magenta.s:bg_none   .s:fmt_undr
-
-" Definitions
-" ---------------------------------------------------------------------
-let s:fg_pdef = s:fg_violet
-exe "hi! pandocDefinitionBlock"              .s:fg_pdef  .s:bg_none  .s:fmt_none
-exe "hi! pandocDefinitionTerm"               .s:fg_pdef  .s:bg_none  .s:fmt_stnd
-exe "hi! pandocDefinitionIndctr"             .s:fg_pdef  .s:bg_none  .s:fmt_bold
-exe "hi! pandocEmphasisDefinition"           .s:fg_pdef  .s:bg_none  .s:fmt_ital
-exe "hi! pandocEmphasisNestedDefinition"     .s:fg_pdef  .s:bg_none  .s:fmt_bldi
-exe "hi! pandocStrongEmphasisDefinition"     .s:fg_pdef  .s:bg_none  .s:fmt_bold
-exe "hi! pandocStrongEmphasisNestedDefinition"   .s:fg_pdef.s:bg_none.s:fmt_bldi
-exe "hi! pandocStrongEmphasisEmphasisDefinition" .s:fg_pdef.s:bg_none.s:fmt_bldi
-exe "hi! pandocStrikeoutDefinition"          .s:fg_pdef  .s:bg_none  .s:fmt_revr
-exe "hi! pandocVerbatimInlineDefinition"     .s:fg_pdef  .s:bg_none  .s:fmt_none
-exe "hi! pandocSuperscriptDefinition"        .s:fg_pdef  .s:bg_none  .s:fmt_none
-exe "hi! pandocSubscriptDefinition"          .s:fg_pdef  .s:bg_none  .s:fmt_none
-
-" Tables
-" ---------------------------------------------------------------------
-let s:fg_ptable = s:fg_blue
-exe "hi! pandocTable"                        .s:fg_ptable.s:bg_none  .s:fmt_none
-exe "hi! pandocTableStructure"               .s:fg_ptable.s:bg_none  .s:fmt_none
-hi! link pandocTableStructureTop             pandocTableStructre
-hi! link pandocTableStructureEnd             pandocTableStructre
-exe "hi! pandocTableZebraLight"              .s:fg_ptable.s:bg_base03.s:fmt_none
-exe "hi! pandocTableZebraDark"               .s:fg_ptable.s:bg_base02.s:fmt_none
-exe "hi! pandocEmphasisTable"                .s:fg_ptable.s:bg_none  .s:fmt_ital
-exe "hi! pandocEmphasisNestedTable"          .s:fg_ptable.s:bg_none  .s:fmt_bldi
-exe "hi! pandocStrongEmphasisTable"          .s:fg_ptable.s:bg_none  .s:fmt_bold
-exe "hi! pandocStrongEmphasisNestedTable"    .s:fg_ptable.s:bg_none  .s:fmt_bldi
-exe "hi! pandocStrongEmphasisEmphasisTable"  .s:fg_ptable.s:bg_none  .s:fmt_bldi
-exe "hi! pandocStrikeoutTable"               .s:fg_ptable.s:bg_none  .s:fmt_revr
-exe "hi! pandocVerbatimInlineTable"          .s:fg_ptable.s:bg_none  .s:fmt_none
-exe "hi! pandocSuperscriptTable"             .s:fg_ptable.s:bg_none  .s:fmt_none
-exe "hi! pandocSubscriptTable"               .s:fg_ptable.s:bg_none  .s:fmt_none
-
-" Headings
-" ---------------------------------------------------------------------
-let s:fg_phead = s:fg_orange
-exe "hi! pandocHeading"                      .s:fg_phead .s:bg_none.s:fmt_bold
-exe "hi! pandocHeadingMarker"                .s:fg_yellow.s:bg_none.s:fmt_bold
-exe "hi! pandocEmphasisHeading"              .s:fg_phead .s:bg_none.s:fmt_bldi
-exe "hi! pandocEmphasisNestedHeading"        .s:fg_phead .s:bg_none.s:fmt_bldi
-exe "hi! pandocStrongEmphasisHeading"        .s:fg_phead .s:bg_none.s:fmt_bold
-exe "hi! pandocStrongEmphasisNestedHeading"  .s:fg_phead .s:bg_none.s:fmt_bldi
-exe "hi! pandocStrongEmphasisEmphasisHeading".s:fg_phead .s:bg_none.s:fmt_bldi
-exe "hi! pandocStrikeoutHeading"             .s:fg_phead .s:bg_none.s:fmt_revr
-exe "hi! pandocVerbatimInlineHeading"        .s:fg_phead .s:bg_none.s:fmt_bold
-exe "hi! pandocSuperscriptHeading"           .s:fg_phead .s:bg_none.s:fmt_bold
-exe "hi! pandocSubscriptHeading"             .s:fg_phead .s:bg_none.s:fmt_bold
-
-" Links
-" ---------------------------------------------------------------------
-exe "hi! pandocLinkDelim"                .s:fg_base01 .s:bg_none   .s:fmt_none
-exe "hi! pandocLinkLabel"                .s:fg_blue   .s:bg_none   .s:fmt_undr
-exe "hi! pandocLinkText"                 .s:fg_blue   .s:bg_none   .s:fmt_undb
-exe "hi! pandocLinkURL"                  .s:fg_base00 .s:bg_none   .s:fmt_undr
-exe "hi! pandocLinkTitle"                .s:fg_base00 .s:bg_none   .s:fmt_undi
-exe "hi! pandocLinkTitleDelim"           .s:fg_base01 .s:bg_none   .s:fmt_undi   .s:sp_base00
-exe "hi! pandocLinkDefinition"           .s:fg_cyan   .s:bg_none   .s:fmt_undr   .s:sp_base00
-exe "hi! pandocLinkDefinitionID"         .s:fg_blue   .s:bg_none   .s:fmt_bold
-exe "hi! pandocImageCaption"             .s:fg_violet .s:bg_none   .s:fmt_undb
-exe "hi! pandocFootnoteLink"             .s:fg_green  .s:bg_none   .s:fmt_undr
-exe "hi! pandocFootnoteDefLink"          .s:fg_green  .s:bg_none   .s:fmt_bold
-exe "hi! pandocFootnoteInline"           .s:fg_green  .s:bg_none   .s:fmt_undb
-exe "hi! pandocFootnote"                 .s:fg_green  .s:bg_none   .s:fmt_none
-exe "hi! pandocCitationDelim"            .s:fg_magenta.s:bg_none   .s:fmt_none
-exe "hi! pandocCitation"                 .s:fg_magenta.s:bg_none   .s:fmt_none
-exe "hi! pandocCitationID"               .s:fg_magenta.s:bg_none   .s:fmt_undr
-exe "hi! pandocCitationRef"              .s:fg_magenta.s:bg_none   .s:fmt_none
-
-" Main Styles
-" ---------------------------------------------------------------------
-exe "hi! pandocStyleDelim"               .s:fg_base01 .s:bg_none  .s:fmt_none
-exe "hi! pandocEmphasis"                 .s:fg_base0  .s:bg_none  .s:fmt_ital
-exe "hi! pandocEmphasisNested"           .s:fg_base0  .s:bg_none  .s:fmt_bldi
-exe "hi! pandocStrongEmphasis"           .s:fg_base0  .s:bg_none  .s:fmt_bold
-exe "hi! pandocStrongEmphasisNested"     .s:fg_base0  .s:bg_none  .s:fmt_bldi
-exe "hi! pandocStrongEmphasisEmphasis"   .s:fg_base0  .s:bg_none  .s:fmt_bldi
-exe "hi! pandocStrikeout"                .s:fg_base01 .s:bg_none  .s:fmt_revr
-exe "hi! pandocVerbatimInline"           .s:fg_yellow .s:bg_none  .s:fmt_none
-exe "hi! pandocSuperscript"              .s:fg_violet .s:bg_none  .s:fmt_none
-exe "hi! pandocSubscript"                .s:fg_violet .s:bg_none  .s:fmt_none
-
-exe "hi! pandocRule"                     .s:fg_blue   .s:bg_none  .s:fmt_bold
-exe "hi! pandocRuleLine"                 .s:fg_blue   .s:bg_none  .s:fmt_bold
-exe "hi! pandocEscapePair"               .s:fg_red    .s:bg_none  .s:fmt_bold
-exe "hi! pandocCitationRef"              .s:fg_magenta.s:bg_none   .s:fmt_none
-exe "hi! pandocNonBreakingSpace"         . s:fg_red   .s:bg_none  .s:fmt_revr
-hi! link pandocEscapedCharacter          pandocEscapePair
-hi! link pandocLineBreak                 pandocEscapePair
-
-" Embedded Code
-" ---------------------------------------------------------------------
-exe "hi! pandocMetadataDelim"            .s:fg_base01 .s:bg_none   .s:fmt_none
-exe "hi! pandocMetadata"                 .s:fg_blue   .s:bg_none   .s:fmt_none
-exe "hi! pandocMetadataKey"              .s:fg_blue   .s:bg_none   .s:fmt_none
-exe "hi! pandocMetadata"                 .s:fg_blue   .s:bg_none   .s:fmt_bold
-hi! link pandocMetadataTitle             pandocMetadata
-
-"}}}
-" Utility autocommand "{{{
-" ---------------------------------------------------------------------
-" In cases where Solarized is initialized inside a terminal vim session and 
-" then transferred to a gui session via the command `:gui`, the gui vim process 
-" does not re-read the colorscheme (or .vimrc for that matter) so any `has_gui` 
-" related code that sets gui specific values isn't executed.
-"
-" Currently, Solarized sets only the cterm or gui values for the colorscheme 
-" depending on gui or terminal mode. It's possible that, if the following 
-" autocommand method is deemed excessively poor form, that approach will be 
-" used again and the autocommand below will be dropped.
-"
-" However it seems relatively benign in this case to include the autocommand 
-" here. It fires only in cases where vim is transferring from terminal to gui 
-" mode (detected with the script scope s:vmode variable). It also allows for 
-" other potential terminal customizations that might make gui mode suboptimal.
-"
-autocmd GUIEnter * if (s:vmode != "gui") | exe "colorscheme " . g:colors_name | endif
-"}}}
-" Highlight Trailing Space {{{
-" Experimental: Different highlight when on cursorline
-function! s:SolarizedHiTrail()
-    if g:solarized_hitrail==0
-        hi! clear solarizedTrailingSpace
-    else
-        syn match solarizedTrailingSpace "\s*$"
-        exe "hi! solarizedTrailingSpace " .s:fmt_undr .s:fg_red .s:bg_none .s:sp_red
-    endif
-endfunction  
-augroup SolarizedHiTrail
-    autocmd!
-    if g:solarized_hitrail==1
-        autocmd! Syntax * call s:SolarizedHiTrail()
-        autocmd! ColorScheme * if g:colors_name == "solarized" | call s:SolarizedHiTrail() | else | augroup! s:SolarizedHiTrail | endif
-    endif
-augroup END
-" }}}
-" Menus "{{{
-" ---------------------------------------------------------------------
-" Turn off Solarized menu by including the following assignment in your .vimrc:
-"
-"    let g:solarized_menu=0
-
-function! s:SolarizedOptions()
-    new "new buffer
-    setf vim "vim filetype
-    let failed = append(0, s:defaults_list)
-    let failed = append(0, s:colorscheme_list)
-    let failed = append(0, s:options_list)
-    let failed = append(0, s:lazycat_list)
-    0 "jump back to the top
-endfunction
-if !exists(":SolarizedOptions")
-    command SolarizedOptions :call s:SolarizedOptions()
-endif
-
-function! SolarizedMenu()
-    if exists("g:loaded_solarized_menu")
-        try
-            silent! aunmenu Solarized
-        endtry
-    endif
-    let g:loaded_solarized_menu = 1
-
-    if g:colors_name == "solarized" && g:solarized_menu != 0
-
-        amenu &Solarized.&Contrast.&Low\ Contrast        :let g:solarized_contrast="low"       \| colorscheme solarized<CR>
-        amenu &Solarized.&Contrast.&Normal\ Contrast     :let g:solarized_contrast="normal"    \| colorscheme solarized<CR>
-        amenu &Solarized.&Contrast.&High\ Contrast       :let g:solarized_contrast="high"      \| colorscheme solarized<CR>
-        an    &Solarized.&Contrast.-sep-                 <Nop>
-        amenu &Solarized.&Contrast.&Help:\ Contrast      :help 'solarized_contrast'<CR>
-
-        amenu &Solarized.&Visibility.&Low\ Visibility    :let g:solarized_visibility="low"     \| colorscheme solarized<CR>
-        amenu &Solarized.&Visibility.&Normal\ Visibility :let g:solarized_visibility="normal"  \| colorscheme solarized<CR>
-        amenu &Solarized.&Visibility.&High\ Visibility   :let g:solarized_visibility="high"    \| colorscheme solarized<CR>
-        an    &Solarized.&Visibility.-sep-                 <Nop>
-        amenu &Solarized.&Visibility.&Help:\ Visibility    :help 'solarized_visibility'<CR>
-
-        amenu &Solarized.&Background.&Toggle\ Background :ToggleBG<CR>
-        amenu &Solarized.&Background.&Dark\ Background   :set background=dark  \| colorscheme solarized<CR>
-        amenu &Solarized.&Background.&Light\ Background  :set background=light \| colorscheme solarized<CR>
-        an    &Solarized.&Background.-sep-               <Nop>
-        amenu &Solarized.&Background.&Help:\ ToggleBG     :help togglebg<CR>
-
-        if g:solarized_bold==0 | let l:boldswitch="On" | else | let l:boldswitch="Off" | endif
-        exe "amenu &Solarized.&Styling.&Turn\\ Bold\\ ".l:boldswitch." :let g:solarized_bold=(abs(g:solarized_bold-1)) \\| colorscheme solarized<CR>"
-        if g:solarized_italic==0 | let l:italicswitch="On" | else | let l:italicswitch="Off" | endif
-        exe "amenu &Solarized.&Styling.&Turn\\ Italic\\ ".l:italicswitch." :let g:solarized_italic=(abs(g:solarized_italic-1)) \\| colorscheme solarized<CR>"
-        if g:solarized_underline==0 | let l:underlineswitch="On" | else | let l:underlineswitch="Off" | endif
-        exe "amenu &Solarized.&Styling.&Turn\\ Underline\\ ".l:underlineswitch." :let g:solarized_underline=(abs(g:solarized_underline-1)) \\| colorscheme solarized<CR>"
-
-        amenu &Solarized.&Diff\ Mode.&Low\ Diff\ Mode    :let g:solarized_diffmode="low"     \| colorscheme solarized<CR>
-        amenu &Solarized.&Diff\ Mode.&Normal\ Diff\ Mode :let g:solarized_diffmode="normal"  \| colorscheme solarized<CR>
-        amenu &Solarized.&Diff\ Mode.&High\ Diff\ Mode   :let g:solarized_diffmode="high"    \| colorscheme solarized<CR>
-
-        if g:solarized_hitrail==0 | let l:hitrailswitch="On" | else | let l:hitrailswitch="Off" | endif
-        exe "amenu &Solarized.&Experimental.&Turn\\ Highlight\\ Trailing\\ Spaces\\ ".l:hitrailswitch." :let g:solarized_hitrail=(abs(g:solarized_hitrail-1)) \\| colorscheme solarized<CR>"
-        an    &Solarized.&Experimental.-sep-               <Nop>
-        amenu &Solarized.&Experimental.&Help:\ HiTrail    :help 'solarized_hitrail'<CR>
-
-        an    &Solarized.-sep1-                          <Nop>
-
-        amenu &Solarized.&Autogenerate\ options          :SolarizedOptions<CR>
-
-        an    &Solarized.-sep2-                          <Nop>
-
-        amenu &Solarized.&Help.&Solarized\ Help          :help solarized<CR>
-        amenu &Solarized.&Help.&Toggle\ Background\ Help :help togglebg<CR>
-        amenu &Solarized.&Help.&Removing\ This\ Menu     :help solarized-menu<CR>
-
-        an 9999.77 &Help.&Solarized\ Colorscheme         :help solarized<CR>
-        an 9999.78 &Help.&Toggle\ Background             :help togglebg<CR>
-        an 9999.79 &Help.-sep3-                          <Nop>
-
-    endif
-endfunction
-
-autocmd ColorScheme * if g:colors_name != "solarized" | silent! aunmenu Solarized | else | call SolarizedMenu() | endif
-
-"}}}
-" License "{{{
-" ---------------------------------------------------------------------
-"
-" Copyright (c) 2011 Ethan Schoonover
-"
-" Permission is hereby granted, free of charge, to any person obtaining a copy
-" of this software and associated documentation files (the "Software"), to deal
-" in the Software without restriction, including without limitation the rights
-" to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-" copies of the Software, and to permit persons to whom the Software is
-" furnished to do so, subject to the following conditions:
-"
-" The above copyright notice and this permission notice shall be included in
-" all copies or substantial portions of the Software.
-"
-" THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-" IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-" FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-" AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-" LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-" OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-" THE SOFTWARE.
-"
-" vim:foldmethod=marker:foldlevel=0
-"}}}
diff --git a/sources_non_forked/vim-colors-solarized/doc/solarized.txt b/sources_non_forked/vim-colors-solarized/doc/solarized.txt
deleted file mode 100644
index 93ebd68..0000000
--- a/sources_non_forked/vim-colors-solarized/doc/solarized.txt
+++ /dev/null
@@ -1,254 +0,0 @@
-*solarized.vim* for Vim version 7.3 or newer. Modified: 2011 May 05
-
-
-		Solarized Vim Colorscheme by Ethan Schoonover ~
-
-Solarized Colorscheme					   *solarized*
-							   *solarized-help*
-							   *solarized-colors*
-							   *solarized-colorscheme*
-							   *vim-colors-solarized*
-
-Solarized is a carefully designed selective contrast colorscheme with dual
-light and dark modes that runs in both GUI, 256 and 16 color modes.
-
-See the homepage at http://ethanschoonover.com/solarized for screenshots and 
-details.
-
-0. Install				|solarized-install|
-1. Solarized Menu			|solarized-menu|
-2. Options				|solarized-options|
-3. Toggle Background			|solarized-togglebg|
-4. Terminal Issues			|solarized-term|
-
-==============================================================================
-0. Install						*solarized-install*
-
-Note: I recommend using Tim Pope's pathogen plugin to install this 
-colorscheme. See https://github.com/tpope/vim-pathogen . If you've installed 
-pathogen properly you can install Solarized with the following commands, 
-followed by the .vimrc configuration below.
-
-	$ cd ~/.vim/bundle
-	$ git clone https://github.com/altercation/vim-colors-solarized.git
-
-If you aren't using pathogen, you can use the following three steps to install 
-Solarized:
-
-1.  Download the solarized distribution (available on the homepage above)
-    and unarchive the file.
-
-2.  Move `solarized.vim` to your `.vim/colors` directory.
-
-3.  Move each of the files in each subdirectories to the corresponding .vim
-    subdirectory (e.g. autoload/togglebg.vim goes into your .vim/autoload
-    directory as .vim/autoload/togglebg.vim).
-
-
-After installation, place the following lines in your .vimrc:
-
-	syntax enable
-	set background=dark
-	colorscheme solarized
-
-or, for the light background mode of Solarized:
-
-	syntax enable
-	set background=light
-	colorscheme solarized
-
-==============================================================================
-1. Solarized Menu					*solarized-menu*
-
-Solarized makes available a menu when used in Vim GUI mode (gvim, macvim).  
-This menu includes many of the options detailed below so that you can test out 
-different values quickly without modifying your .vimrc file. If you wish to 
-turn off this menu permanently, simply place the following line in your .vimrc 
-above the "colorscheme solarized" line.
-
-	let g:solarized_menu=0
-
-==============================================================================
-2. Toggle Background					*solarized-togglebg*
-							*toggle-bg* *togglebg*
-							*toggle-background*
-
-Solarized comes with Toggle Background, a simple plugin to switch between 
-light and dark background modes and reset the colorscheme. This is most useful 
-for colorschemes that support both light and dark modes and in terminals or 
-gui vim windows where the background will be properly set.
-
-Toggle Background can be accessed by:
-
-    * the Solarized menu (in Vim gui mode)
-    * the Window menu (in Vim gui mode, even if the Solarized menu is off)
-    * the "yin/yang" toolbar button (in Vim gui mode)
-    * the default mapping of <F5>
-    * custom key mapping you set in your .vimrc (see below)
-    * command line via ":ToggleBG" (no quotes)
-
-Toggle Background starts with a default mapping to function key <F5>. If you 
-are already using this in a mapping, Toggle Background will not map itself to 
-a default and you will have to map it manually in your .vimrc file, or 
-remove/change your existing <F5> mapping to another value. To customize the 
-keyboard mapping in your .vimrc file, use the following line, changing the 
-"<F5>" value to the key or key combination you wish to use:
-
-	call togglebg#map("<F5>")
-
-Note that you'll want to use a single function key or equivalent if you want 
-the plugin to work in all modes (normal, insert, visual).
-
-When using the plugin during normal, visual, or insert mode, there should be 
-no interruption in workflow. However, if you activate the plugin during 
-REPLACE mode, you will switch to standard insert mode (you will leave the 
-overwrite replace mode).
-
-==============================================================================
-3. Solarized Terminal Issues				*solarized-term*
-
-If you are going to use Solarized in Terminal mode (i.e. not in a GUI version 
-like gvim or macvim), **please please please** consider setting your terminal 
-emulator's colorscheme to used the Solarized palette. I've included palettes 
-for some popular terminal emulator as well as Xdefaults in the official 
-Solarized download available from the Solarized homepage listed at the top of 
-this help document. If you use Solarized *without* these colors, Solarized 
-will need to be told to degrade its colorscheme to a set compatible with the 
-limited 256 terminal palette (whereas by using the terminal's 16 ansi color 
-values, you can set the correct, specific values for the Solarized palette).
-
-If you do use the custom terminal colors, solarized.vim should work out of 
-the box for you. If you are using a terminal emulator that supports 256 
-colors and don't want to use the custom Solarized terminal colors, you will 
-need to use the degraded 256 colorscheme. To do so, simply add the following 
-line *before* the `colorschem solarized` line:
-
-    let g:solarized_termcolors=256
-
-Again, I recommend just changing your terminal colors to Solarized values 
-either manually or via one of the many terminal schemes available for import.
-
-==============================================================================
-4. Solarized Options					*solarized-options*
-
-
-AUTOGENERATE OPTIONS
-
-You can easily modify and experiment with Solarized display options using the 
-Solarized menu when using Vim in gui mode. Once you have things set to your 
-liking, you can autogenerate the current option list in a format ready for 
-insertion into your .vimrc file using the Solarized menu "Autogenerate 
-Options" command or at the command line with:
-
-    :SolarizedOptions
-
-
-OPTION LIST
-
-Set these in your vimrc file prior to calling the colorscheme.
-
-option name               default     optional
-------------------------------------------------
-g:solarized_termcolors=   16      |   256
-g:solarized_termtrans =   0       |   1
-g:solarized_degrade   =   0       |   1
-g:solarized_bold      =   1       |   0
-g:solarized_underline =   1       |   0
-g:solarized_italic    =   1       |   0
-g:solarized_contrast  =   "normal"|   "high" or "low"
-g:solarized_visibility=   "normal"|   "high" or "low"
-g:solarized_hitrail   =   0       |   1
-g:solarized_menu      =   1       |   0
-------------------------------------------------
-
-
-OPTION DETAILS
-
-------------------------------------------------
-g:solarized_termcolors=   256     |   16		*'solarized_termcolors'*
-------------------------------------------------
-The most important option if you are using vim in terminal (non gui) mode!
-This tells Solarized to use the 256 degraded color mode if running in a 256
-color capable terminal.  Otherwise, if set to `16` it will use the terminal
-emulators colorscheme (best option as long as you've set the emulators colors
-to the Solarized palette).
-
-If you are going to use Solarized in Terminal mode (i.e. not in a GUI
-version like gvim or macvim), **please please please** consider setting your
-terminal emulator's colorscheme to used the Solarized palette. I've included
-palettes for some popular terminal emulator as well as Xdefaults in the
-official Solarized download available from:
-http://ethanschoonover.com/solarized . If you use Solarized without these
-colors, Solarized will by default use an approximate set of 256 colors.  It
-isn't bad looking and has been extensively tweaked, but it's still not quite
-the real thing.
-
-------------------------------------------------
-g:solarized_termtrans =   0       |   1			*'solarized_termtrans'*
-------------------------------------------------
-If you use a terminal emulator with a transparent background and Solarized
-isn't displaying the background color transparently, set this to 1 and
-Solarized will use the default (transparent) background of the terminal
-emulator. *urxvt* required this in my testing; iTerm2 did not.
-
-Note that on Mac OS X Terminal.app, solarized_termtrans is set to 1 by 
-default as this is almost always the best option. The only exception to this 
-is if the working terminfo file supports 256 colors (xterm-256color).
-
-------------------------------------------------
-g:solarized_degrade   =   0       |   1			*'solarized_degrade'*
-------------------------------------------------
-For test purposes only; forces Solarized to use the 256 degraded color mode
-to test the approximate color values for accuracy.
-
-------------------------------------------------
-g:solarized_bold      =   1       |   0			*'solarized_bold'*
-------------------------------------------------
-------------------------------------------------
-g:solarized_underline =   1       |   0			*'solarized_underline'*
-------------------------------------------------
-------------------------------------------------
-g:solarized_italic    =   1       |   0			*'solarized_italic'*
-------------------------------------------------
-If you wish to stop Solarized from displaying bold, underlined or
-italicized typefaces, simply assign a zero value to the appropriate
-variable, for example: `let g:solarized_italic=0`
-
-------------------------------------------------
-g:solarized_contrast  =   "normal"|   "high" or "low"	*'solarized_contrast'*
-------------------------------------------------
-Stick with normal! It's been carefully tested. Setting this option to high
-or low does use the same Solarized palette but simply shifts some values up
-or down in order to expand or compress the tonal range displayed.
-
-------------------------------------------------
-g:solarized_visibility =  "normal"|   "high" or "low" *'solarized_visibility'*
-------------------------------------------------
-Special characters such as trailing whitespace, tabs, newlines, when 
-displayed using ":set list" can be set to one of three levels depending on 
-your needs.
-
-------------------------------------------------
-g:solarized_hitrail   =   0       |   1			*'solarized_hitrail'*
-------------------------------------------------
-Visibility can make listchar entities more visible, but if one has set 
-cursorline on, these same listchar values standout somewhat less due to the 
-background color of the cursorline. g:solarized_hitrail enables highlighting 
-of trailing spaces (only one of the listchar types, but a particularly 
-important one) while in the cursoline in a different manner in order to make 
-them more visible. This may not work consistently as Solarized is using 
-a pattern match than can be overridden by a more encompassing syntax-native 
-match such as a comment line.
-
-
-------------------------------------------------
-g:solarized_menu       =  1       |   0			*'solarized_menu'*
-------------------------------------------------
-Solarized includes a menu providing access to several of the above
-display related options, including contrast and visibility. This allows
-for an easy method of testing different values quickly before settling
-on a final assignment for your .vimrc. If you wish to turn off this menu,
-assign g:solarized_menu a value of 0.
-
-
- vim:tw=78:noet:ts=8:ft=help:norl:
diff --git a/sources_non_forked/vim-colors-solarized/doc/tags b/sources_non_forked/vim-colors-solarized/doc/tags
deleted file mode 100644
index 3785a09..0000000
--- a/sources_non_forked/vim-colors-solarized/doc/tags
+++ /dev/null
@@ -1,27 +0,0 @@
-'solarized_bold'	solarized.txt	/*'solarized_bold'*
-'solarized_contrast'	solarized.txt	/*'solarized_contrast'*
-'solarized_degrade'	solarized.txt	/*'solarized_degrade'*
-'solarized_hitrail'	solarized.txt	/*'solarized_hitrail'*
-'solarized_italic'	solarized.txt	/*'solarized_italic'*
-'solarized_menu'	solarized.txt	/*'solarized_menu'*
-'solarized_termcolors'	solarized.txt	/*'solarized_termcolors'*
-'solarized_termtrans'	solarized.txt	/*'solarized_termtrans'*
-'solarized_underline'	solarized.txt	/*'solarized_underline'*
-'solarized_visibility'	solarized.txt	/*'solarized_visibility'*
-before	solarized.txt	/*before*
-solarized	solarized.txt	/*solarized*
-solarized-colors	solarized.txt	/*solarized-colors*
-solarized-colorscheme	solarized.txt	/*solarized-colorscheme*
-solarized-help	solarized.txt	/*solarized-help*
-solarized-install	solarized.txt	/*solarized-install*
-solarized-menu	solarized.txt	/*solarized-menu*
-solarized-options	solarized.txt	/*solarized-options*
-solarized-term	solarized.txt	/*solarized-term*
-solarized-togglebg	solarized.txt	/*solarized-togglebg*
-solarized.vim	solarized.txt	/*solarized.vim*
-toggle-background	solarized.txt	/*toggle-background*
-toggle-bg	solarized.txt	/*toggle-bg*
-togglebg	solarized.txt	/*togglebg*
-urxvt	solarized.txt	/*urxvt*
-vim-colors-solarized	solarized.txt	/*vim-colors-solarized*
-without	solarized.txt	/*without*
diff --git a/sources_non_forked/vim-fugitive/autoload/fugitive.vim b/sources_non_forked/vim-fugitive/autoload/fugitive.vim
index 1106aea..14e24d0 100644
--- a/sources_non_forked/vim-fugitive/autoload/fugitive.vim
+++ b/sources_non_forked/vim-fugitive/autoload/fugitive.vim
@@ -146,11 +146,13 @@ endif
 function! s:TempScript(...) abort
   let body = join(a:000, "\n")
   if !has_key(s:temp_scripts, body)
-    let temp = tempname() . '.sh'
+    let s:temp_scripts[body] = tempname() . '.sh'
+  endif
+  let temp = s:temp_scripts[body]
+  if !filereadable(temp)
     call writefile(['#!/bin/sh'] + a:000, temp)
-    let s:temp_scripts[body] = temp
   endif
-  return FugitiveGitPath(s:temp_scripts[body])
+  return FugitiveGitPath(temp)
 endfunction
 
 function! s:DoAutocmd(cmd) abort
@@ -551,9 +553,9 @@ function! fugitive#Config(...) abort
     let dir = a:1
   endif
   let name = substitute(name, '^[^.]\+\|[^.]\+$', '\L&', 'g')
-  let key = len(dir) ? dir : '_'
-  if has_key(s:config, key) && s:config[key][0] ==# s:ConfigTimestamps(dir, s:config[key][1])
-    let dict = s:config[key][1]
+  let dir_key = len(dir) ? dir : '_'
+  if has_key(s:config, dir_key) && s:config[dir_key][0] ==# s:ConfigTimestamps(dir, s:config[dir_key][1])
+    let dict = s:config[dir_key][1]
   else
     let dict = {}
     let [lines, message, exec_error] = s:NullError([dir, 'config', '--list', '-z'])
@@ -571,7 +573,7 @@ function! fugitive#Config(...) abort
         call add(dict[key], strpart(line, len(key) + 1))
       endif
     endfor
-    let s:config[dir] = [s:ConfigTimestamps(dir, dict), dict]
+    let s:config[dir_key] = [s:ConfigTimestamps(dir, dict), dict]
     lockvar! dict
   endif
   return len(name) ? get(get(dict, name, []), 0, '') : dict
@@ -624,7 +626,8 @@ function! s:QuickfixCreate(nr, opts) abort
   endif
 endfunction
 
-function! s:QuickfixStream(nr, event, title, cmd, first, callback, ...) abort
+function! s:QuickfixStream(nr, event, title, cmd, first, mods, callback, ...) abort
+  let mods = s:Mods(a:mods)
   let opts = {'title': a:title, 'context': {'items': []}}
   call s:QuickfixCreate(a:nr, opts)
   let event = (a:nr < 0 ? 'c' : 'l') . 'fugitive-' . a:event
@@ -645,7 +648,9 @@ function! s:QuickfixStream(nr, event, title, cmd, first, callback, ...) abort
       call extend(opts.context.items, contexts)
       unlet contexts
       call s:QuickfixSet(a:nr, remove(buffer, 0, -1), 'a')
-      redraw
+      if mods !~# '\<silent\>'
+        redraw
+      endif
     endif
   endfor
   call extend(buffer, call(a:callback, a:000 + [0]))
@@ -656,20 +661,12 @@ function! s:QuickfixStream(nr, event, title, cmd, first, callback, ...) abort
   silent exe s:DoAutocmd('QuickFixCmdPost ' . event)
   if a:first && len(s:QuickfixGet(a:nr))
     call s:BlurStatus()
-    return a:nr < 0 ? 'cfirst' : 'lfirst'
+    return mods . (a:nr < 0 ? 'cfirst' : 'lfirst')
   else
     return 'exe'
   endif
 endfunction
 
-let s:common_efm = ''
-      \ . '%+Egit:%.%#,'
-      \ . '%+Eusage:%.%#,'
-      \ . '%+Eerror:%.%#,'
-      \ . '%+Efatal:%.%#,'
-      \ . '%-G%.%#%\e[K%.%#,'
-      \ . '%-G%.%#%\r%.%\+'
-
 function! fugitive#Cwindow() abort
   if &buftype == 'quickfix'
     cwindow
@@ -1016,6 +1013,9 @@ function! fugitive#Find(object, ...) abort
       endif
       if commit !~# '^[0-9a-f]\{40,\}$'
         let commit = matchstr(s:ChompDefault('', [dir, 'rev-parse', '--verify', commit . (len(file) ? '^{}' : ''), '--']), '\<[0-9a-f]\{40,\}\>')
+        if empty(commit) && len(file)
+          let commit = repeat('0', 40)
+        endif
       endif
       if len(commit)
         let f = 'fugitive://' . dir . '//' . commit . file
@@ -1491,11 +1491,11 @@ function! s:FilterEscape(items, ...) abort
   return items
 endfunction
 
-function! s:GlobComplete(lead, pattern) abort
+function! s:GlobComplete(lead, pattern, ...) abort
   if a:lead ==# '/'
     return []
   elseif v:version >= 704
-    let results = glob(a:lead . a:pattern, 0, 1)
+    let results = glob(a:lead . a:pattern, a:0 ? a:1 : 0, 1)
   else
     let results = split(glob(a:lead . a:pattern), "\n")
   endif
@@ -1622,7 +1622,7 @@ endfunction
 
 function! s:CompleteRemote(A, L, P, ...) abort
   let dir = a:0 ? a:1 : s:Dir()
-  let remote = matchstr(a:L, '\u\w*[! ] *\zs\S\+\ze ')
+  let remote = matchstr(a:L, '\u\w*[! ] *.\{-\}\s\@<=\zs[^-[:space:]]\S*\ze ')
   if !empty(remote)
     let matches = s:LinesError([dir, 'ls-remote', remote])[0]
     call filter(matches, 'v:val =~# "\t" && v:val !~# "{"')
@@ -1639,8 +1639,9 @@ function! s:ReplaceCmd(cmd) abort
   let temp = tempname()
   let [err, exec_error] = s:TempCmd(temp, a:cmd)
   if exec_error
-    call s:throw((len(err) ? err : filereadable(temp) ? join(readfile(temp), ' ') : 'unknown error running ' . a:cmd))
+    call s:throw((len(err) ? err : 'unknown error running ' . a:cmd))
   endif
+  setlocal noswapfile
   silent exe 'lockmarks keepalt 0read ++edit' s:fnameescape(temp)
   if &foldenable && foldlevel('$') > 0
     set nofoldenable
@@ -1938,6 +1939,10 @@ function! fugitive#BufReadStatus() abort
     if empty(s:Tree())
       call s:AddHeader('Bare', 'yes')
     endif
+    if get(FugitiveConfigGetAll('advice.statusHints', config), 0, 'true') !~# '^\%(false\|no|off\|0\|\)$'
+      call s:AddHeader('Help', 'g?')
+    endif
+
     call s:AddSection('Rebasing ' . rebasing_head, rebasing)
     call s:AddSection('Untracked', untracked)
     call s:AddSection('Unstaged', unstaged)
@@ -1964,7 +1969,7 @@ function! fugitive#BufReadStatus() abort
     if &bufhidden ==# ''
       setlocal bufhidden=delete
     endif
-    let b:dispatch = ':Git fetch --all'
+    let b:dispatch = '-dir=' . fnameescape(len(s:Tree()) ? s:Tree() : s:Dir()) . ' ' . g:fugitive_git_executable . ' fetch --all'
     call fugitive#MapJumps()
     call s:Map('n', '-', ":<C-U>execute <SID>Do('Toggle',0)<CR>", '<silent>')
     call s:Map('x', '-', ":<C-U>execute <SID>Do('Toggle',1)<CR>", '<silent>')
@@ -2152,17 +2157,17 @@ function! fugitive#BufReadCmd(...) abort
         if b:fugitive_display_format
           call s:ReplaceCmd([dir, 'cat-file', b:fugitive_type, rev])
         else
-          call s:ReplaceCmd([dir, 'show', '--no-color', '-m', '--first-parent', '--pretty=format:tree%x20%T%nparent%x20%P%nauthor%x20%an%x20<%ae>%x20%ad%ncommitter%x20%cn%x20<%ce>%x20%cd%nencoding%x20%e%n%n%s%n%n%b', rev])
+          call s:ReplaceCmd([dir, '-c', 'diff.noprefix=false', 'show', '--no-color', '-m', '--first-parent', '--pretty=format:tree%x20%T%nparent%x20%P%nauthor%x20%an%x20<%ae>%x20%ad%ncommitter%x20%cn%x20<%ce>%x20%cd%nencoding%x20%e%n%n%s%n%n%b', rev])
           keepjumps 1
           keepjumps call search('^parent ')
           if getline('.') ==# 'parent '
-            silent keepjumps delete_
+            silent lockmarks keepjumps delete_
           else
             silent exe (exists(':keeppatterns') ? 'keeppatterns' : '') 'keepjumps s/\m\C\%(^parent\)\@<! /\rparent /e' . (&gdefault ? '' : 'g')
           endif
           keepjumps let lnum = search('^encoding \%(<unknown>\)\=$','W',line('.')+3)
           if lnum
-            silent keepjumps delete_
+            silent lockmarks keepjumps delete_
           end
           silent exe (exists(':keeppatterns') ? 'keeppatterns' : '') 'keepjumps 1,/^diff --git\|\%$/s/\r$//e'
           keepjumps 1
@@ -2299,21 +2304,21 @@ function! s:RunEdit(state, job) abort
   endif
 endfunction
 
-function! s:RunReceive(state, job, data, ...) abort
+function! s:RunReceive(state, type, job, data, ...) abort
   call add(a:state.log, a:data)
   let data = type(a:data) == type([]) ? join(a:data, "\n") : a:data
-  if has_key(a:state, 'buffer')
-    let data = remove(a:state, 'buffer') . data
-  endif
-  let escape = "\033]51;[^\007]*"
-  let a:state.escape_buffer = matchstr(data, escape . '$')
-  if len(a:state.escape_buffer)
-    let data = strpart(data, 0, len(data) - len(a:state.escape_buffer))
-  endif
-  let cmd = matchstr(data, escape . "\007")[5:-2]
-  let data = substitute(data, escape . "\007", '', 'g')
-  if cmd =~# '^fugitive:'
-    let a:state.request = strpart(cmd, 9)
+  if a:type ==# 'err' || a:state.pty
+    let data = a:state.escape_buffer . data
+    let escape = "\033]51;[^\007]*"
+    let a:state.escape_buffer = matchstr(data, escape . '$')
+    if len(a:state.escape_buffer)
+      let data = strpart(data, 0, len(data) - len(a:state.escape_buffer))
+    endif
+    let cmd = matchstr(data, escape . "\007")[5:-2]
+    let data = substitute(data, escape . "\007", '', 'g')
+    if cmd =~# '^fugitive:'
+      let a:state.request = strpart(cmd, 9)
+    endif
   endif
   let data = a:state.echo_buffer . data
   let a:state.echo_buffer = matchstr(data, "[\r\n]\\+$")
@@ -2420,6 +2425,30 @@ augroup fugitive_job
         \ endfor
 augroup END
 
+function! s:OpenExec(cmd, mods, env, args, ...) abort
+  let options = a:0 ? a:1 : {'dir': s:Dir()}
+  let temp = tempname()
+  let columns = get(g:, 'fugitive_columns', 80)
+  let env = s:BuildEnvPrefix(extend({'COLUMNS': columns}, a:env))
+  silent! execute '!' . escape(env . s:UserCommand(options, ['--no-pager'] + a:args), '!#%') .
+        \ (&shell =~# 'csh' ? ' >& ' . temp : ' > ' . temp . ' 2>&1')
+  redraw!
+  let temp = s:Resolve(temp)
+  let first = join(readfile(temp, '', 2), "\n")
+  if first =~# '\<\([[:upper:][:digit:]_-]\+(\d\+)\).*\1'
+    let filetype = 'man'
+  else
+    let filetype = 'git'
+  endif
+  let s:temp_files[s:cpath(temp)] = { 'dir': options.dir, 'filetype': filetype }
+  if a:cmd ==# 'edit'
+    call s:BlurStatus()
+  endif
+  silent execute s:Mods(a:mods) . a:cmd temp
+  call fugitive#ReloadStatus(options.dir, 1)
+  return 'echo ' . string(':!' . s:UserCommand(options, a:args))
+endfunction
+
 function! fugitive#PagerFor(argv, ...) abort
   let args = a:argv
   if empty(args)
@@ -2539,16 +2568,9 @@ function! fugitive#Command(line1, line2, range, bang, mods, arg) abort
       return 'echoerr ' .  string('fugitive: :Git! for temp buffer output has been replaced by :Git --paginate')
     endif
   endif
-  if pager is# 1
-    if editcmd ==# 'read'
-      return s:ReadExec(a:line1, a:line2, a:range, a:mods, env, args, options) . after
-    else
-      return s:OpenExec(editcmd, a:mods, env, args, options) . after
-    endif
-  endif
-  if s:HasOpt(args, ['add', 'checkout', 'commit', 'stage', 'stash', 'reset'], '-p', '--patch') ||
+  if (s:HasOpt(args, ['add', 'checkout', 'commit', 'stage', 'stash', 'reset'], '-p', '--patch') ||
         \ s:HasOpt(args, ['add', 'clean', 'stage'], '-i', '--interactive') ||
-        \ type(pager) == type('')
+        \ type(pager) == type('')) && pager isnot# 1
     let mods = substitute(s:Mods(a:mods), '\<tab\>', '-tab', 'g')
     let assign = len(dir) ? '|let b:git_dir = ' . string(dir) : ''
     if has('nvim')
@@ -2559,6 +2581,13 @@ function! fugitive#Command(line1, line2, range, bang, mods, arg) abort
       return 'exe ' . string(mods . 'terminal ' . (a:line2 ? '' : '++curwin ') . join(map(s:UserCommandList(options) + args, 's:fnameescape(v:val)'))) . assign . after
     endif
   endif
+  if pager is# 1
+    if editcmd ==# 'read'
+      return s:ReadExec(a:line1, a:line2, a:range, a:mods, env, args, options) . after
+    else
+      return s:OpenExec(editcmd, a:mods, env, args, options) . after
+    endif
+  endif
   if s:RunJobs()
     let state = {
           \ 'dir': dir,
@@ -2567,17 +2596,18 @@ function! fugitive#Command(line1, line2, range, bang, mods, arg) abort
           \ 'echo_buffer': '',
           \ 'escape_buffer': '',
           \ 'log': [],
-          \ 'temp': tempname()}
+          \ 'temp': s:Resolve(tempname())}
     let state.pty = get(g:, 'fugitive_pty', has('unix') && (has('patch-8.0.0744') || has('nvim')))
     if !state.pty
       let args = s:AskPassArgs(dir) + args
     endif
     let env.FUGITIVE_TEMP = state.temp
+    let env.FUGITIVE = state.temp
     let editor = 'sh ' . s:TempScript(
-          \ '[ -f "$FUGITIVE_TEMP.exit" ] && exit 1',
-          \ 'echo "$1" > "$FUGITIVE_TEMP.edit"',
-          \ 'printf "\033]51;fugitive:edit\007"',
-          \ 'while [ -f "$FUGITIVE_TEMP.edit" -a ! -f "$FUGITIVE_TEMP.exit" ]; do sleep 0.05 2>/dev/null || sleep 1; done',
+          \ '[ -f "$FUGITIVE.exit" ] && exit 1',
+          \ 'echo "$1" > "$FUGITIVE.edit"',
+          \ 'printf "\033]51;fugitive:edit\007" >&2',
+          \ 'while [ -f "$FUGITIVE.edit" -a ! -f "$FUGITIVE.exit" ]; do sleep 0.05 2>/dev/null || sleep 1; done',
           \ 'exit 0')
     call extend(env, {
           \ 'NO_COLOR': '1',
@@ -2595,7 +2625,8 @@ function! fugitive#Command(line1, line2, range, bang, mods, arg) abort
     if exists('*job_start')
       call extend(jobopts, {
             \ 'mode': 'raw',
-            \ 'callback': function('s:RunReceive', [state]),
+            \ 'out_cb': function('s:RunReceive', [state, 'out']),
+            \ 'err_cb': function('s:RunReceive', [state, 'err']),
             \ })
       if state.pty
         let jobopts.pty = 1
@@ -2605,8 +2636,8 @@ function! fugitive#Command(line1, line2, range, bang, mods, arg) abort
       let job = jobstart(argv, extend(jobopts, {
             \ 'pty': state.pty,
             \ 'TERM': 'dumb',
-            \ 'on_stdout': function('s:RunReceive', [state]),
-            \ 'on_stderr': function('s:RunReceive', [state]),
+            \ 'on_stdout': function('s:RunReceive', [state, 'out']),
+            \ 'on_stderr': function('s:RunReceive', [state, 'err']),
             \ }))
     endif
     let state.job = job
@@ -2634,19 +2665,20 @@ endfunction
 
 function! s:Subcommands() abort
   let exec_path = s:ExecPath()
-  return map(split(glob(exec_path.'/git-*'),"\n"),'s:sub(v:val[strlen(exec_path)+5 : -1],"\\.exe$","")')
+  return map(s:GlobComplete(exec_path.'/git-', '*', 1),'substitute(v:val,"\\.exe$","","")')
 endfunction
 
 let s:aliases = {}
 function! s:Aliases(dir) abort
-  if !has_key(s:aliases, a:dir)
-    let s:aliases[a:dir] = {}
+  let dir_key = len(a:dir) ? a:dir : '_'
+  if !has_key(s:aliases, dir_key)
+    let s:aliases[dir_key] = {}
     let lines = s:NullError([a:dir, 'config', '-z', '--get-regexp', '^alias[.]'])[0]
     for line in lines
-      let s:aliases[a:dir][matchstr(line, '\.\zs.\{-}\ze\n')] = matchstr(line, '\n\zs.*')
+      let s:aliases[dir_key][matchstr(line, '\.\zs.\{-}\ze\n')] = matchstr(line, '\n\zs.*')
     endfor
   endif
-  return s:aliases[a:dir]
+  return s:aliases[dir_key]
 endfunction
 
 function! fugitive#Complete(lead, ...) abort
@@ -2886,7 +2918,8 @@ endfunction
 function! s:ReloadTabStatus(...) abort
   let mytab = tabpagenr()
   let tab = a:0 ? a:1 : mytab
-  for winnr in range(1, tabpagewinnr(tab, '$'))
+  let winnr = 1
+  while winnr <= tabpagewinnr(tab, '$')
     if getbufvar(tabpagebuflist(tab)[winnr-1], 'fugitive_type') ==# 'index'
       execute 'tabnext '.tab
       if winnr != winnr()
@@ -2903,7 +2936,8 @@ function! s:ReloadTabStatus(...) abort
         execute 'tabnext '.mytab
       endtry
     endif
-  endfor
+    let winnr += 1
+  endwhile
   unlet! t:fugitive_reload_status
 endfunction
 
@@ -3521,7 +3555,12 @@ function! s:StageApply(info, reverse, extra) abort
   let i = b:fugitive_expanded[info.section][info.filename][0]
   let head = []
   while get(b:fugitive_diff[info.section], i, '@') !~# '^@'
-    call add(head, b:fugitive_diff[info.section][i])
+    let line = b:fugitive_diff[info.section][i]
+    if line ==# '--- /dev/null'
+      call add(head, '--- ' . get(b:fugitive_diff[info.section], i + 1, '')[4:-1])
+    elseif line !~# '^new file '
+      call add(head, line)
+    endif
     let i += 1
   endwhile
   call extend(lines, head, 'keep')
@@ -3731,7 +3770,7 @@ function! s:DoUnstageStaged(record) abort
 endfunction
 
 function! s:DoToggleUnstaged(record) abort
-  if a:record.patch && a:record.status !=# 'A'
+  if a:record.patch
     return s:StageApply(a:record, 0, ['--cached'])
   else
     call s:TreeChomp(['add', '-A', '--'] + a:record.paths)
@@ -4017,7 +4056,7 @@ function! s:ToolStream(line1, line2, range, bang, mods, options, args, state) ab
   let exec += a:options.flags + ['--no-pager', 'diff', '--no-ext-diff', '--no-color', '--no-prefix'] + argv
   if prompt
     let title = ':Git ' . s:fnameescape(a:options.flags + [a:options.command] + a:options.args)
-    return s:QuickfixStream(a:line2, 'difftool', title, exec, !a:bang, s:function('s:ToolParse'), a:state)
+    return s:QuickfixStream(a:line2, 'difftool', title, exec, !a:bang, a:mods, s:function('s:ToolParse'), a:state)
   else
     let filename = ''
     let cmd = []
@@ -4400,7 +4439,7 @@ function! fugitive#LogCommand(line1, count, range, bang, mods, args, type) abort
   if empty(paths + extra_paths) && empty(a:type) && a:count < 0 && len(s:Relative('/'))
     let after = '|echohl WarningMsg|echo ' . string('Use :0Glog or :0Gclog for old behavior of targeting current file') . '|echohl NONE' . after
   endif
-  return s:QuickfixStream(listnr, 'log', title, s:UserCommandList(dir) + cmd, !a:bang, s:function('s:LogParse'), state, dir) . after
+  return s:QuickfixStream(listnr, 'log', title, s:UserCommandList(dir) + cmd, !a:bang, a:mods, s:function('s:LogParse'), state, dir) . after
 endfunction
 
 " Section: :Gedit, :Gpedit, :Gsplit, :Gvsplit, :Gtabedit, :Gread
@@ -4484,7 +4523,7 @@ function! s:OpenParse(args, wants_cmd) abort
   return [url, pre]
 endfunction
 
-function! s:DiffClose() abort
+function! fugitive#DiffClose() abort
   let mywinnr = winnr()
   for winnr in [winnr('#')] + range(winnr('$'),1,-1)
     if winnr != mywinnr && getwinvar(winnr,'&diff')
@@ -4507,38 +4546,15 @@ function! s:BlurStatus() abort
       belowright new
     endif
     if &diff
-      call s:DiffClose()
+      call fugitive#DiffClose()
     endif
   endif
 endfunction
 
-function! s:OpenExec(cmd, mods, env, args, ...) abort
-  let options = a:0 ? a:1 : {'dir': s:Dir()}
-  let temp = tempname()
-  let columns = get(g:, 'fugitive_columns', 80)
-  let env = s:BuildEnvPrefix(extend({'COLUMNS': columns}, a:env))
-  silent! execute '!' . escape(env . s:UserCommand(options, ['--no-pager'] + a:args), '!#%') .
-        \ (&shell =~# 'csh' ? ' >& ' . temp : ' > ' . temp . ' 2>&1')
-  redraw!
-  let temp = s:Resolve(temp)
-  let first = join(readfile(temp, '', 2), "\n")
-  if first =~# '\<\([[:upper:][:digit:]_-]\+(\d\+)\).*\1'
-    let filetype = 'man'
-  else
-    let filetype = 'git'
-  endif
-  let s:temp_files[s:cpath(temp)] = { 'dir': options.dir, 'filetype': filetype }
-  if a:cmd ==# 'edit'
-    call s:BlurStatus()
-  endif
-  silent execute s:Mods(a:mods) . a:cmd temp
-  call fugitive#ReloadStatus(options.dir, 1)
-  return 'echo ' . string(':!' . s:UserCommand(options, a:args))
-endfunction
-
+let s:bang_edits = {'split': 'Git', 'vsplit': 'vert Git', 'tabedit': 'tab Git', 'pedit': 'Git!'}
 function! fugitive#Open(cmd, bang, mods, arg, args) abort
   if a:bang
-    return s:OpenExec(a:cmd, a:mods, {}, s:SplitExpand(a:arg, s:Tree()))
+    return 'echoerr ' . string(':G' . a:cmd . '! for temp buffer output has been replaced by :' . get(s:bang_edits, a:cmd, 'Git') . ' --paginate')
   endif
 
   let mods = s:Mods(a:mods)
@@ -4586,9 +4602,7 @@ endfunction
 
 function! fugitive#ReadCommand(line1, count, range, bang, mods, arg, args) abort
   if a:bang
-    let dir = s:Dir()
-    let args = s:SplitExpand(a:arg, s:Tree(dir))
-    return s:ReadExec(a:line1, a:count, a:range, a:mods, {}, args, {'dir': dir})
+    return 'echoerr ' . string(':Gread! for temp buffer output has been replaced by :{range}Git! --paginate')
   endif
   let [read, post] = s:ReadPrepare(a:line1, a:count, a:range, a:mods)
   try
@@ -4621,10 +4635,8 @@ endfunction
 " Section: :Gwrite, :Gwq
 
 function! fugitive#WriteCommand(line1, line2, range, bang, mods, arg, args) abort
-  if exists('b:fugitive_commit_arguments')
-    return 'write|bdelete'
-  elseif expand('%:t') == 'COMMIT_EDITMSG' && $GIT_INDEX_FILE != ''
-    return 'wq'
+  if s:cpath(expand('%:p'), fugitive#Find('.git/COMMIT_EDITMSG'))
+    return (empty($GIT_INDEX_FILE) ? 'write|bdelete' : 'wq') . (a:bang ? '!' : '')
   elseif get(b:, 'fugitive_type', '') ==# 'index'
     return 'Git commit'
   elseif &buftype ==# 'nowrite' && getline(4) =~# '^[+-]\{3\} '
@@ -4753,7 +4765,7 @@ endfunction
 
 function! fugitive#WqCommand(...) abort
   let bang = a:4 ? '!' : ''
-  if exists('b:fugitive_commit_arguments')
+  if s:cpath(expand('%:p'), fugitive#Find('.git/COMMIT_EDITMSG'))
     return 'wq'.bang
   endif
   let result = call('fugitive#WriteCommand', a:000)
@@ -4774,45 +4786,6 @@ function! fugitive#FetchComplete(A, L, P, ...) abort
   return s:CompleteSub('fetch', a:A, a:L, a:P, function('s:CompleteRemote'), a:000)
 endfunction
 
-function! s:Dispatch(bang, options) abort
-  let dir = a:options.dir
-  exe s:DirCheck(dir)
-  let [mp, efm, cc] = [&l:mp, &l:efm, get(b:, 'current_compiler', '')]
-  try
-    let b:current_compiler = 'git'
-    let &l:errorformat = s:common_efm .
-          \ ',%\&git_dir=' . escape(substitute(dir, '%', '%%', 'g'), '\,')
-    let &l:makeprg = s:UserCommand({'git': a:options.git, 'dir': dir}, s:AskPassArgs(dir) + a:options.flags + [a:options.command] + a:options.args)
-    if exists(':Make') == 2
-      Make
-      return ''
-    else
-      if !has('patch-8.1.0334') && has('terminal') && &autowrite
-        let autowrite_was_set = 1
-        set noautowrite
-        silent! wall
-      endif
-      silent noautocmd make!
-      redraw!
-      return 'call fugitive#Cwindow()|silent ' . s:DoAutocmd('ShellCmdPost')
-    endif
-  finally
-    let [&l:mp, &l:efm, b:current_compiler] = [mp, efm, cc]
-    if empty(cc) | unlet! b:current_compiler | endif
-    if exists('autowrite_was_set')
-      set autowrite
-    endif
-  endtry
-endfunction
-
-function! s:PushSubcommand(line1, line2, range, bang, mods, options) abort
-  return s:Dispatch(a:bang ? '!' : '', a:options)
-endfunction
-
-function! s:FetchSubcommand(line1, line2, range, bang, mods, options) abort
-  return s:Dispatch(a:bang ? '!' : '', a:options)
-endfunction
-
 " Section: :Gdiff
 
 augroup fugitive_diff
@@ -4880,25 +4853,30 @@ function! s:diffthis() abort
 endfunction
 
 function! s:diffoff() abort
-  if exists('w:fugitive_diff_restore')
+  if exists('w:fugitive_diff_restore') && v:version < 704
     execute w:fugitive_diff_restore
-    unlet w:fugitive_diff_restore
-  else
-    diffoff
   endif
+  unlet! w:fugitive_diff_restore
+  diffoff
 endfunction
 
 function! s:diffoff_all(dir) abort
   let curwin = winnr()
   for nr in range(1,winnr('$'))
     if getwinvar(nr, '&diff') && !empty(getwinvar(nr, 'fugitive_diff_restore'))
-      if nr != winnr()
-        execute nr.'wincmd w'
+      if v:version < 704
+        if nr != winnr()
+          execute nr.'wincmd w'
+        endif
+        execute w:fugitive_diff_restore
       endif
-      call s:diffoff()
+      call setwinvar(nr, 'fugitive_diff_restore', '')
     endif
   endfor
-  execute curwin.'wincmd w'
+  if curwin != winnr()
+    execute curwin.'wincmd w'
+  endif
+  diffoff!
 endfunction
 
 function! s:CompareAge(mine, theirs) abort
@@ -5180,7 +5158,7 @@ endfunction
 function! s:BlameCommitFileLnum(...) abort
   let line = a:0 ? a:1 : getline('.')
   let state = a:0 ? a:2 : s:TempState()
-  let commit = matchstr(line, '^\^\=\zs\x\+')
+  let commit = matchstr(line, '^\^\=[?*]*\zs\x\+')
   if commit =~# '^0\+$'
     let commit = ''
   elseif has_key(state, 'blame_reverse_end')
@@ -5418,7 +5396,7 @@ function! s:BlameSubcommand(line1, count, range, bang, mods, options) abort
         if exists('+signcolumn')
           setlocal signcolumn=no
         endif
-        execute "vertical resize ".(s:linechars('.\{-\}\ze\s\+\d\+)')+1)
+        execute "vertical resize ".(s:linechars('.\{-\}\s\+\d\+\ze)')+1)
         call s:Map('n', 'A', ":<C-u>exe 'vertical resize '.(<SID>linechars('.\\{-\\}\\ze [0-9:/+-][0-9:/+ -]* \\d\\+)')+1+v:count)<CR>", '<silent>')
         call s:Map('n', 'C', ":<C-u>exe 'vertical resize '.(<SID>linechars('^\\S\\+')+1+v:count)<CR>", '<silent>')
         call s:Map('n', 'D', ":<C-u>exe 'vertical resize '.(<SID>linechars('.\\{-\\}\\ze\\d\\ze\\s\\+\\d\\+)')+1-v:count)<CR>", '<silent>')
@@ -5548,6 +5526,7 @@ let s:hash_colors = {}
 function! fugitive#BlameSyntax() abort
   let conceal = has('conceal') ? ' conceal' : ''
   let flags = get(s:TempState(), 'blame_flags', [])
+  syn spell notoplevel
   syn match FugitiveblameBlank                      "^\s\+\s\@=" nextgroup=FugitiveblameAnnotation,FugitiveblameScoreDebug,FugitiveblameOriginalFile,FugitiveblameOriginalLineNumber skipwhite
   syn match FugitiveblameHash       "\%(^\^\=[?*]*\)\@<=\<\x\{7,\}\>" nextgroup=FugitiveblameAnnotation,FugitiveblameScoreDebug,FugitiveblameOriginalLineNumber,FugitiveblameOriginalFile skipwhite
   syn match FugitiveblameUncommitted "\%(^\^\=\)\@<=\<0\{7,\}\>" nextgroup=FugitiveblameAnnotation,FugitiveblameScoreDebug,FugitiveblameOriginalLineNumber,FugitiveblameOriginalFile skipwhite
@@ -5558,8 +5537,8 @@ function! fugitive#BlameSyntax() abort
   endif
   syn match FugitiveblameScoreDebug        " *\d\+\s\+\d\+\s\@=" nextgroup=FugitiveblameAnnotation,FugitiveblameOriginalLineNumber,fugitiveblameOriginalFile contained skipwhite
   syn region FugitiveblameAnnotation matchgroup=FugitiveblameDelimiter start="(" end="\%(\s\d\+\)\@<=)" contained keepend oneline
-  syn match FugitiveblameTime "[0-9:/+-][0-9:/+ -]*[0-9:/+-]\%(\s\+\d\+)\)\@=" contained containedin=FugitiveblameAnnotation
-  exec 'syn match FugitiveblameLineNumber         "\s*\d\+)\@=" contained containedin=FugitiveblameAnnotation' conceal
+  syn match FugitiveblameTime "\<[0-9:/+-][0-9:/+ -]*[0-9:/+-]\%(\s\+\d\+)\)\@=" contained containedin=FugitiveblameAnnotation
+  exec 'syn match FugitiveblameLineNumber         "\s[[:digit:][:space:]]\{0,' . (len(line('$'))-1). '\}\d)\@=" contained containedin=FugitiveblameAnnotation' conceal
   exec 'syn match FugitiveblameOriginalFile       "\s\%(\f\+\D\@<=\|\D\@=\f\+\)\%(\%(\s\+\d\+\)\=\s\%((\|\s*\d\+)\)\)\@=" contained nextgroup=FugitiveblameOriginalLineNumber,FugitiveblameAnnotation skipwhite' (s:HasOpt(flags, '--show-name', '-f') ? '' : conceal)
   exec 'syn match FugitiveblameOriginalLineNumber "\s*\d\+\%(\s(\)\@=" contained nextgroup=FugitiveblameAnnotation skipwhite' (s:HasOpt(flags, '--show-number', '-n') ? '' : conceal)
   exec 'syn match FugitiveblameOriginalLineNumber "\s*\d\+\%(\s\+\d\+)\)\@=" contained nextgroup=FugitiveblameShort skipwhite' (s:HasOpt(flags, '--show-number', '-n') ? '' : conceal)
@@ -5651,7 +5630,7 @@ augroup fugitive_blame
   autocmd BufWinLeave * execute getwinvar(+bufwinnr(+expand('<abuf>')), 'fugitive_leave')
 augroup END
 
-" Section: :Gbrowse
+" Section: :GBrowse
 
 let s:redirects = {}
 
@@ -5664,7 +5643,7 @@ function! fugitive#BrowseCommand(line1, count, range, bang, mods, arg, args) abo
       if a:count >= 0
         return 'echoerr ' . string('fugitive: ''-'' no longer required to get persistent URL if range given')
       else
-        return 'echoerr ' . string('fugitive: use :0Gbrowse instead of :Gbrowse -')
+        return 'echoerr ' . string('fugitive: use :0GBrowse instead of :GBrowse -')
       endif
     elseif len(a:args)
       let remote = matchstr(join(a:args, ' '),'@\zs\%('.validremote.'\)$')
@@ -5855,7 +5834,7 @@ function! fugitive#BrowseCommand(line1, count, range, bang, mods, arg, args) abo
     endif
 
     if empty(url)
-      call s:throw("No Gbrowse handler installed for '".raw."'")
+      call s:throw("No GBrowse handler installed for '".raw."'")
     endif
 
     let url = s:gsub(url, '[ <>]', '\="%".printf("%02X",char2nr(submatch(0)))')
@@ -5866,14 +5845,18 @@ function! fugitive#BrowseCommand(line1, count, range, bang, mods, arg, args) abo
       return 'echomsg '.string(url)
     elseif exists(':Browse') == 2
       return 'echomsg '.string(url).'|Browse '.url
+    elseif exists(':OpenBrowser') == 2
+      return 'echomsg '.string(url).'|OpenBrowser '.url
     else
       if !exists('g:loaded_netrw')
         runtime! autoload/netrw.vim
       endif
       if exists('*netrw#BrowseX')
         return 'echomsg '.string(url).'|call netrw#BrowseX('.string(url).', 0)'
-      else
+      elseif exists('*netrw#NetrwBrowseX')
         return 'echomsg '.string(url).'|call netrw#NetrwBrowseX('.string(url).', 0)'
+      else
+        return 'echoerr ' . string('Netrw not found. Define your own :Browse to use :GBrowse')
       endif
     endif
   catch /^fugitive:/
@@ -5955,11 +5938,11 @@ function! fugitive#MapJumps(...) abort
       call s:Map('n', 'gO',   ':<C-U>0,4' . blame_map, '<silent>')
       call s:Map('n', 'O',    ':<C-U>0,5' . blame_map, '<silent>')
 
-      call s:Map('n', 'D',  ":<C-U>call <SID>DiffClose()<Bar>Gdiffsplit!<Bar>redraw<Bar>echohl WarningMsg<Bar> echo ':Gstatus D is deprecated in favor of dd'<Bar>echohl NONE<CR>", '<silent>')
-      call s:Map('n', 'dd', ":<C-U>call <SID>DiffClose()<Bar>Gdiffsplit!<CR>", '<silent>')
-      call s:Map('n', 'dh', ":<C-U>call <SID>DiffClose()<Bar>Ghdiffsplit!<CR>", '<silent>')
-      call s:Map('n', 'ds', ":<C-U>call <SID>DiffClose()<Bar>Ghdiffsplit!<CR>", '<silent>')
-      call s:Map('n', 'dv', ":<C-U>call <SID>DiffClose()<Bar>Gvdiffsplit!<CR>", '<silent>')
+      call s:Map('n', 'D',  ":<C-U>call fugitive#DiffClose()<Bar>Gdiffsplit!<Bar>redraw<Bar>echohl WarningMsg<Bar> echo ':Gstatus D is deprecated in favor of dd'<Bar>echohl NONE<CR>", '<silent>')
+      call s:Map('n', 'dd', ":<C-U>call fugitive#DiffClose()<Bar>Gdiffsplit!<CR>", '<silent>')
+      call s:Map('n', 'dh', ":<C-U>call fugitive#DiffClose()<Bar>Ghdiffsplit!<CR>", '<silent>')
+      call s:Map('n', 'ds', ":<C-U>call fugitive#DiffClose()<Bar>Ghdiffsplit!<CR>", '<silent>')
+      call s:Map('n', 'dv', ":<C-U>call fugitive#DiffClose()<Bar>Gvdiffsplit!<CR>", '<silent>')
       call s:Map('n', 'd?', ":<C-U>help fugitive_d<CR>", '<silent>')
 
     else
@@ -5996,7 +5979,7 @@ function! fugitive#MapJumps(...) abort
       call s:Map('nxo', '#', '<SID>PatchSearchExpr(1)', '<expr>')
     endif
     call s:Map('n', 'S',    ':<C-U>echoerr "Use gO"<CR>', '<silent>')
-    call s:Map('n', 'dq', ":<C-U>call <SID>DiffClose()<CR>", '<silent>')
+    call s:Map('n', 'dq', ":<C-U>call fugitive#DiffClose()<CR>", '<silent>')
     call s:Map('n', '-', ":<C-U>exe 'Gedit ' . <SID>fnameescape(<SID>NavigateUp(v:count1))<Bar> if getline(1) =~# '^tree \x\{40,\}$' && empty(getline(2))<Bar>call search('^'.escape(expand('#:t'),'.*[]~\').'/\=$','wc')<Bar>endif<CR>", '<silent>')
     call s:Map('n', 'P',     ":<C-U>exe 'Gedit ' . <SID>fnameescape(<SID>ContainingCommit().'^'.v:count1.<SID>Relative(':'))<CR>", '<silent>')
     call s:Map('n', '~',     ":<C-U>exe 'Gedit ' . <SID>fnameescape(<SID>ContainingCommit().'~'.v:count1.<SID>Relative(':'))<CR>", '<silent>')
diff --git a/sources_non_forked/vim-fugitive/doc/fugitive.txt b/sources_non_forked/vim-fugitive/doc/fugitive.txt
index e950a31..556b36f 100644
--- a/sources_non_forked/vim-fugitive/doc/fugitive.txt
+++ b/sources_non_forked/vim-fugitive/doc/fugitive.txt
@@ -78,15 +78,6 @@ that are part of Git repositories).
                                                 *:Git_mergetool*
 :Git mergetool [args]   Like |:Git_difftool|, but target merge conflicts.
 
-                                                *:Git_push*
-:Git push [args]        Invoke git-push, load the results into the |quickfix|
-                        list, and invoke |:cwindow| to reveal any errors.
-                        |:Dispatch| is used if available for asynchronous
-                        invocation.
-
-                                                *:Git_fetch*
-:Git fetch [args]       Like |:Git_push|, but for git-fetch.
-
                                                 *:Ggrep* *:Gcgrep* *:Git_grep*
 :Ggrep[!] [args]        |:grep|[!] with git-grep as 'grepprg'.
 :Git[!] grep [args]
@@ -100,6 +91,10 @@ that are part of Git repositories).
                         |quickfix| list.  Jumps to the first commit unless [!]
                         is given.
 
+                        The quickfix list can be awkward for many use cases
+                        and exhibits extremely poor performance with larger
+                        data sets.  Consider using |:Git| log instead.
+
 :{range}Gclog[!] [args] Use git-log -L to load previous revisions of the given
                         range of the current file into the |quickfix| list.
                         The cursor is positioned on the first line of the
@@ -261,7 +256,7 @@ X                       Discard the change under the cursor.  This uses
                         `checkout` or `clean` under the hood.  A command is
                         echoed that shows how to undo the change.  Consult
                         `:messages` to see it again.  You can use this during
-                        a merge conflict do discard "our" changes (--theirs)
+                        a merge conflict to discard "our" changes (--theirs)
                         in the "Unstaged" section or discard "their" changes
                         (--ours) in the "Staged" section.
 
@@ -629,8 +624,8 @@ just one space character longer than the legacy version.
 *:Gpull*        Superseded by |:Git| pull.
 *:Grebase*      Superseded by |:Git| rebase.
 *:Grevert*      Superseded by |:Git| revert.
-*:Gpush*        Superseded by |:Git_push|.
-*:Gfetch*       Superseded by |:Git_fetch|.
+*:Gpush*        Superseded by |:Git| push.
+*:Gfetch*       Superseded by |:Git| fetch.
 *:Glog*         Superseded by |:Gclog|.
 *:Gstatus*      Superseded by |:Git| (with no arguments).
 *:Git!*         Superseded by |:Git_--paginate|.
diff --git a/sources_non_forked/vim-fugitive/plugin/fugitive.vim b/sources_non_forked/vim-fugitive/plugin/fugitive.vim
index 2b9e4d9..4fc5906 100644
--- a/sources_non_forked/vim-fugitive/plugin/fugitive.vim
+++ b/sources_non_forked/vim-fugitive/plugin/fugitive.vim
@@ -420,7 +420,9 @@ let s:addr_other = has('patch-8.1.560') ? '-addr=other' : ''
 let s:addr_tabs  = has('patch-7.4.542') ? '-addr=tabs' : ''
 let s:addr_wins  = has('patch-7.4.542') ? '-addr=windows' : ''
 
-command! -bang -nargs=? -range=-1 -complete=customlist,fugitive#Complete G   exe fugitive#Command(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)
+if exists(':G') != 2
+  command! -bang -nargs=? -range=-1 -complete=customlist,fugitive#Complete G   exe fugitive#Command(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)
+endif
 command! -bang -nargs=? -range=-1 -complete=customlist,fugitive#Complete Git exe fugitive#Command(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)
 
 if exists(':Gstatus') !=# 2
@@ -429,7 +431,9 @@ endif
 
 for s:cmd in ['Commit', 'Revert', 'Merge', 'Rebase', 'Pull', 'Push', 'Fetch', 'Blame']
   if exists(':G' . tolower(s:cmd)) != 2
-    exe 'command! -bang -nargs=? -range=-1 -complete=customlist,fugitive#' . s:cmd . 'Complete G' . tolower(s:cmd) 'exe fugitive#Command(<line1>, <count>, +"<range>", <bang>0, "<mods>", "' . tolower(s:cmd) . ' " . <q-args>)'
+    exe 'command! -bang -nargs=? -range=-1 -complete=customlist,fugitive#' . s:cmd . 'Complete G' . tolower(s:cmd)
+          \ 'echohl WarningMSG|echo ":G' . tolower(s:cmd) . ' is deprecated in favor of :Git ' . tolower(s:cmd) . '\n"|echohl NONE|'
+          \ 'exe fugitive#Command(<line1>, <count>, +"<range>", <bang>0, "<mods>", "' . tolower(s:cmd) . ' " . <q-args>)'
   endif
 endfor
 unlet s:cmd
diff --git a/sources_non_forked/vim-gist/autoload/gist.vim b/sources_non_forked/vim-gist/autoload/gist.vim
index 7f803c6..bfe84a0 100644
--- a/sources_non_forked/vim-gist/autoload/gist.vim
+++ b/sources_non_forked/vim-gist/autoload/gist.vim
@@ -134,7 +134,7 @@ function! s:truncate(str, num)
     let str = substitute(str, mx_first, '\2', '')
   endwhile
   while width + 1 <= a:num
-    let ret .= " "
+    let ret .= ' '
     let width = width + 1
   endwhile
   return ret
@@ -160,7 +160,7 @@ function! s:format_gist(gist) abort
   let desc = substitute(desc, '  ', ' ', 'g')
   " Display a nice formatted (and truncated if needed) table of gists on screen
   " Calculate field lengths for gist-listing formatting on screen
-  redir =>a |exe "sil sign place buffer=".bufnr('')|redir end
+  redir =>a |exe 'sil sign place buffer='.bufnr('')|redir end
   let signlist = split(a, '\n')
   let width = winwidth(0) - ((&number||&relativenumber) ? &numberwidth : 0) - &foldcolumn - (len(signlist) > 2 ? 2 : 0)
   let idlen = 33
@@ -214,7 +214,7 @@ function! s:GistList(gistls, page) abort
     echohl ErrorMsg | echomsg v:errmsg | echohl None
     return
   endif
-  let res = webapi#http#get(url, '', { "Authorization": auth })
+  let res = webapi#http#get(url, '', { 'Authorization': auth })
   if v:shell_error != 0
     bw!
     redraw
@@ -330,7 +330,7 @@ function! gist#list(user, ...) abort
   if len(auth) == 0
     return []
   endif
-  let res = webapi#http#get(url, '', { "Authorization": auth })
+  let res = webapi#http#get(url, '', { 'Authorization': auth })
   return webapi#json#decode(res.content)
 endfunction
 
@@ -339,7 +339,7 @@ function! s:GistGetFileName(gistid) abort
   if len(auth) == 0
     return ''
   endif
-  let res = webapi#http#get(g:gist_api_url.'gists/'.a:gistid, '', { "Authorization": auth })
+  let res = webapi#http#get(g:gist_api_url.'gists/'.a:gistid, '', { 'Authorization': auth })
   let gist = webapi#json#decode(res.content)
   if has_key(gist, 'files')
     return sort(keys(gist.files))[0]
@@ -352,7 +352,7 @@ function! s:GistDetectFiletype(gistid) abort
   if len(auth) == 0
     return ''
   endif
-  let res = webapi#http#get(g:gist_api_url.'gists/'.a:gistid, '', { "Authorization": auth })
+  let res = webapi#http#get(g:gist_api_url.'gists/'.a:gistid, '', { 'Authorization': auth })
   let gist = webapi#json#decode(res.content)
   let filename = sort(keys(gist.files))[0]
   let ext = fnamemodify(filename, ':e')
@@ -380,7 +380,7 @@ endfunction
 
 function! s:GistGet(gistid, clipboard) abort
   redraw | echon 'Getting gist... '
-  let res = webapi#http#get(g:gist_api_url.'gists/'.a:gistid, '', { "Authorization": s:GistGetAuthHeader() })
+  let res = webapi#http#get(g:gist_api_url.'gists/'.a:gistid, '', { 'Authorization': s:GistGetAuthHeader() })
   if res.status =~# '^2'
     try
       let gist = webapi#json#decode(res.content)
@@ -459,10 +459,10 @@ function! s:GistGet(gistid, clipboard) abort
         let content = gist.files[filename].content
         call setline(1, split(content, "\n"))
         let b:gist = {
-        \ "filename": filename,
-        \ "id": gist.id,
-        \ "description": gist.description,
-        \ "private": gist.public =~ 'true',
+        \ 'filename': filename,
+        \ 'id': gist.id,
+        \ 'description': gist.description,
+        \ 'private': gist.public =~# 'true',
         \}
       catch
         let &undolevels = old_undolevels
@@ -533,10 +533,10 @@ function! s:GistListAction(mode) abort
 endfunction
 
 function! s:GistUpdate(content, gistid, gistnm, desc) abort
-  let gist = { "id": a:gistid, "files" : {}, "description": "","public": function('webapi#json#true') }
+  let gist = { 'id': a:gistid, 'files' : {}, 'description': '','public': function('webapi#json#true') }
   if exists('b:gist')
     if has_key(b:gist, 'filename') && len(a:gistnm) > 0
-      let gist.files[b:gist.filename] = { "content": '', "filename": b:gist.filename }
+      let gist.files[b:gist.filename] = { 'content': '', 'filename': b:gist.filename }
       let b:gist.filename = a:gistnm
     endif
     if has_key(b:gist, 'private') && b:gist.private | let gist['public'] = function('webapi#json#false') | endif
@@ -560,25 +560,25 @@ function! s:GistUpdate(content, gistid, gistnm, desc) abort
   if a:desc !=# ' '
     let gist['description'] = a:desc
   else
-    let res = webapi#http#get(g:gist_api_url.'gists/'.a:gistid, '', { "Authorization": auth })
+    let res = webapi#http#get(g:gist_api_url.'gists/'.a:gistid, '', { 'Authorization': auth })
     if res.status =~# '^2'
       let old_gist = webapi#json#decode(res.content)
       let gist['description'] = old_gist.description
     endif
   endif
 
-  let gist.files[filename] = { "content": a:content, "filename": filename }
+  let gist.files[filename] = { 'content': a:content, 'filename': filename }
 
   redraw | echon 'Updating gist... '
   let res = webapi#http#post(g:gist_api_url.'gists/' . a:gistid,
   \ webapi#json#encode(gist), {
-  \   "Authorization": auth,
-  \   "Content-Type": "application/json",
+  \   'Authorization': auth,
+  \   'Content-Type': 'application/json',
   \})
   if res.status =~# '^2'
     let obj = webapi#json#decode(res.content)
     let loc = obj['html_url']
-    let b:gist = {"id": a:gistid, "filename": filename}
+    let b:gist = {'id': a:gistid, 'filename': filename}
     setlocal nomodified
     redraw | echomsg 'Done: '.loc
   else
@@ -598,8 +598,8 @@ function! s:GistDelete(gistid) abort
 
   redraw | echon 'Deleting gist... '
   let res = webapi#http#post(g:gist_api_url.'gists/'.a:gistid, '', {
-  \   "Authorization": auth,
-  \   "Content-Type": "application/json",
+  \   'Authorization': auth,
+  \   'Content-Type': 'application/json',
   \}, 'DELETE')
   if res.status =~# '^2'
     if exists('b:gist')
@@ -651,13 +651,13 @@ endfunction
 "       GistID: 123123
 "
 function! s:GistPost(content, private, desc, anonymous) abort
-  let gist = { "files" : {}, "description": "","public": function('webapi#json#true') }
+  let gist = { 'files' : {}, 'description': '','public': function('webapi#json#true') }
   if a:desc !=# ' ' | let gist['description'] = a:desc | endif
   if a:private | let gist['public'] = function('webapi#json#false') | endif
   let filename = s:get_current_filename(1)
-  let gist.files[filename] = { "content": a:content, "filename": filename }
+  let gist.files[filename] = { 'content': a:content, 'filename': filename }
 
-  let header = {"Content-Type": "application/json"}
+  let header = {'Content-Type': 'application/json'}
   if !a:anonymous
     let auth = s:GistGetAuthHeader()
     if len(auth) == 0
@@ -674,10 +674,10 @@ function! s:GistPost(content, private, desc, anonymous) abort
     let obj = webapi#json#decode(res.content)
     let loc = obj['html_url']
     let b:gist = {
-    \ "filename": filename,
-    \ "id": matchstr(loc, '[^/]\+$'),
-    \ "description": gist['description'],
-    \ "private": a:private,
+    \ 'filename': filename,
+    \ 'id': matchstr(loc, '[^/]\+$'),
+    \ 'description': gist['description'],
+    \ 'private': a:private,
     \}
     if s:update_GistID(b:gist['id'])
       Gist -e
@@ -695,7 +695,7 @@ function! s:GistPostBuffers(private, desc, anonymous) abort
   let bn = bufnr('%')
   let query = []
 
-  let gist = { "files" : {}, "description": "","public": function('webapi#json#true') }
+  let gist = { 'files' : {}, 'description': '','public': function('webapi#json#true') }
   if a:desc !=# ' ' | let gist['description'] = a:desc | endif
   if a:private | let gist['public'] = function('webapi#json#false') | endif
 
@@ -708,12 +708,12 @@ function! s:GistPostBuffers(private, desc, anonymous) abort
     silent! exec 'buffer!' bufnr
     let content = join(getline(1, line('$')), "\n")
     let filename = s:get_current_filename(index)
-    let gist.files[filename] = { "content": content, "filename": filename }
+    let gist.files[filename] = { 'content': content, 'filename': filename }
     let index = index + 1
   endfor
   silent! exec 'buffer!' bn
 
-  let header = {"Content-Type": "application/json"}
+  let header = {'Content-Type': 'application/json'}
   if !a:anonymous
     let auth = s:GistGetAuthHeader()
     if len(auth) == 0
@@ -730,10 +730,10 @@ function! s:GistPostBuffers(private, desc, anonymous) abort
     let obj = webapi#json#decode(res.content)
     let loc = obj['html_url']
     let b:gist = {
-    \ "filename": filename,
-    \ "id": matchstr(loc, '[^/]\+$'),
-    \ "description": gist['description'],
-    \ "private": a:private,
+    \ 'filename': filename,
+    \ 'id': matchstr(loc, '[^/]\+$'),
+    \ 'description': gist['description'],
+    \ 'private': a:private,
     \}
     if s:update_GistID(b:gist['id'])
       Gist -e
@@ -828,7 +828,7 @@ function! gist#Gist(count, bang, line1, line2, ...) abort
         echohl ErrorMsg | echomsg v:errmsg | echohl None
       else
         let gistid = gistidbuf
-        let res = webapi#http#post(g:gist_api_url.'gists/'.gistid.'/star', '', { "Authorization": auth }, 'PUT')
+        let res = webapi#http#post(g:gist_api_url.'gists/'.gistid.'/star', '', { 'Authorization': auth }, 'PUT')
         if res.status =~# '^2'
           echomsg 'Starred' gistid
         else
@@ -842,7 +842,7 @@ function! gist#Gist(count, bang, line1, line2, ...) abort
         echohl ErrorMsg | echomsg v:errmsg | echohl None
       else
         let gistid = gistidbuf
-        let res = webapi#http#post(g:gist_api_url.'gists/'.gistid.'/star', '', { "Authorization": auth }, 'DELETE')
+        let res = webapi#http#post(g:gist_api_url.'gists/'.gistid.'/star', '', { 'Authorization': auth }, 'DELETE')
         if res.status =~# '^2'
           echomsg 'Unstarred' gistid
         else
@@ -857,7 +857,7 @@ function! gist#Gist(count, bang, line1, line2, ...) abort
         return
       else
         let gistid = gistidbuf
-        let res = webapi#http#post(g:gist_api_url.'gists/'.gistid.'/fork', '', { "Authorization": auth })
+        let res = webapi#http#post(g:gist_api_url.'gists/'.gistid.'/fork', '', { 'Authorization': auth })
         if res.status =~# '^2'
           let obj = webapi#json#decode(res.content)
           let gistid = obj['id']
@@ -986,12 +986,12 @@ function! s:GistGetAuthHeader() abort
   let note_url = 'http://www.vim.org/scripts/script.php?script_id=2423'
   let insecureSecret = printf('basic %s', webapi#base64#b64encode(g:github_user.':'.password))
   let res = webapi#http#post(g:gist_api_url.'authorizations', webapi#json#encode({
-              \  "scopes"   : ["gist"],
-              \  "note"     : note,
-              \  "note_url" : note_url,
+              \  'scopes'   : ['gist'],
+              \  'note'     : note,
+              \  'note_url' : note_url,
               \}), {
-              \  "Content-Type"  : "application/json",
-              \  "Authorization" : insecureSecret,
+              \  'Content-Type'  : 'application/json',
+              \  'Authorization' : insecureSecret,
               \})
   let h = filter(res.header, 'stridx(v:val, "X-GitHub-OTP:") == 0')
   if len(h)
@@ -1001,13 +1001,13 @@ function! s:GistGetAuthHeader() abort
       return ''
     endif
     let res = webapi#http#post(g:gist_api_url.'authorizations', webapi#json#encode({
-                \  "scopes"   : ["gist"],
-                \  "note"     : note,
-                \  "note_url" : note_url,
+                \  'scopes'   : ['gist'],
+                \  'note'     : note,
+                \  'note_url' : note_url,
                 \}), {
-                \  "Content-Type"  : "application/json",
-                \  "Authorization" : insecureSecret,
-                \  "X-GitHub-OTP"  : otp,
+                \  'Content-Type'  : 'application/json',
+                \  'Authorization' : insecureSecret,
+                \  'X-GitHub-OTP'  : otp,
                 \})
   endif
   let authorization = webapi#json#decode(res.content)
@@ -1025,138 +1025,138 @@ function! s:GistGetAuthHeader() abort
 endfunction
 
 let s:extmap = extend({
-\".adb": "ada",
-\".ahk": "ahk",
-\".arc": "arc",
-\".as": "actionscript",
-\".asm": "asm",
-\".asp": "asp",
-\".aw": "php",
-\".b": "b",
-\".bat": "bat",
-\".befunge": "befunge",
-\".bmx": "bmx",
-\".boo": "boo",
-\".c-objdump": "c-objdump",
-\".c": "c",
-\".cfg": "cfg",
-\".cfm": "cfm",
-\".ck": "ck",
-\".cl": "cl",
-\".clj": "clj",
-\".cmake": "cmake",
-\".coffee": "coffee",
-\".cpp": "cpp",
-\".cppobjdump": "cppobjdump",
-\".cs": "csharp",
-\".css": "css",
-\".cw": "cw",
-\".d-objdump": "d-objdump",
-\".d": "d",
-\".darcspatch": "darcspatch",
-\".diff": "diff",
-\".duby": "duby",
-\".dylan": "dylan",
-\".e": "e",
-\".ebuild": "ebuild",
-\".eclass": "eclass",
-\".el": "lisp",
-\".erb": "erb",
-\".erl": "erlang",
-\".f90": "f90",
-\".factor": "factor",
-\".feature": "feature",
-\".fs": "fs",
-\".fy": "fy",
-\".go": "go",
-\".groovy": "groovy",
-\".gs": "gs",
-\".gsp": "gsp",
-\".haml": "haml",
-\".hs": "haskell",
-\".html": "html",
-\".hx": "hx",
-\".ik": "ik",
-\".ino": "ino",
-\".io": "io",
-\".j": "j",
-\".java": "java",
-\".js": "javascript",
-\".json": "json",
-\".jsp": "jsp",
-\".kid": "kid",
-\".lhs": "lhs",
-\".lisp": "lisp",
-\".ll": "ll",
-\".lua": "lua",
-\".ly": "ly",
-\".m": "objc",
-\".mak": "mak",
-\".man": "man",
-\".mao": "mao",
-\".matlab": "matlab",
-\".md": "markdown",
-\".minid": "minid",
-\".ml": "ml",
-\".moo": "moo",
-\".mu": "mu",
-\".mustache": "mustache",
-\".mxt": "mxt",
-\".myt": "myt",
-\".n": "n",
-\".nim": "nim",
-\".nu": "nu",
-\".numpy": "numpy",
-\".objdump": "objdump",
-\".ooc": "ooc",
-\".parrot": "parrot",
-\".pas": "pas",
-\".pasm": "pasm",
-\".pd": "pd",
-\".phtml": "phtml",
-\".pir": "pir",
-\".pl": "perl",
-\".po": "po",
-\".py": "python",
-\".pytb": "pytb",
-\".pyx": "pyx",
-\".r": "r",
-\".raw": "raw",
-\".rb": "ruby",
-\".rhtml": "rhtml",
-\".rkt": "rkt",
-\".rs": "rs",
-\".rst": "rst",
-\".s": "s",
-\".sass": "sass",
-\".sc": "sc",
-\".scala": "scala",
-\".scm": "scheme",
-\".scpt": "scpt",
-\".scss": "scss",
-\".self": "self",
-\".sh": "sh",
-\".sml": "sml",
-\".sql": "sql",
-\".st": "smalltalk",
-\".swift": "swift",
-\".tcl": "tcl",
-\".tcsh": "tcsh",
-\".tex": "tex",
-\".textile": "textile",
-\".tpl": "smarty",
-\".twig": "twig",
-\".txt" : "text",
-\".v": "verilog",
-\".vala": "vala",
-\".vb": "vbnet",
-\".vhd": "vhdl",
-\".vim": "vim",
-\".weechatlog": "weechatlog",
-\".xml": "xml",
-\".xq": "xquery",
-\".xs": "xs",
-\".yml": "yaml",
+\'.adb': 'ada',
+\'.ahk': 'ahk',
+\'.arc': 'arc',
+\'.as': 'actionscript',
+\'.asm': 'asm',
+\'.asp': 'asp',
+\'.aw': 'php',
+\'.b': 'b',
+\'.bat': 'bat',
+\'.befunge': 'befunge',
+\'.bmx': 'bmx',
+\'.boo': 'boo',
+\'.c-objdump': 'c-objdump',
+\'.c': 'c',
+\'.cfg': 'cfg',
+\'.cfm': 'cfm',
+\'.ck': 'ck',
+\'.cl': 'cl',
+\'.clj': 'clj',
+\'.cmake': 'cmake',
+\'.coffee': 'coffee',
+\'.cpp': 'cpp',
+\'.cppobjdump': 'cppobjdump',
+\'.cs': 'csharp',
+\'.css': 'css',
+\'.cw': 'cw',
+\'.d-objdump': 'd-objdump',
+\'.d': 'd',
+\'.darcspatch': 'darcspatch',
+\'.diff': 'diff',
+\'.duby': 'duby',
+\'.dylan': 'dylan',
+\'.e': 'e',
+\'.ebuild': 'ebuild',
+\'.eclass': 'eclass',
+\'.el': 'lisp',
+\'.erb': 'erb',
+\'.erl': 'erlang',
+\'.f90': 'f90',
+\'.factor': 'factor',
+\'.feature': 'feature',
+\'.fs': 'fs',
+\'.fy': 'fy',
+\'.go': 'go',
+\'.groovy': 'groovy',
+\'.gs': 'gs',
+\'.gsp': 'gsp',
+\'.haml': 'haml',
+\'.hs': 'haskell',
+\'.html': 'html',
+\'.hx': 'hx',
+\'.ik': 'ik',
+\'.ino': 'ino',
+\'.io': 'io',
+\'.j': 'j',
+\'.java': 'java',
+\'.js': 'javascript',
+\'.json': 'json',
+\'.jsp': 'jsp',
+\'.kid': 'kid',
+\'.lhs': 'lhs',
+\'.lisp': 'lisp',
+\'.ll': 'll',
+\'.lua': 'lua',
+\'.ly': 'ly',
+\'.m': 'objc',
+\'.mak': 'mak',
+\'.man': 'man',
+\'.mao': 'mao',
+\'.matlab': 'matlab',
+\'.md': 'markdown',
+\'.minid': 'minid',
+\'.ml': 'ml',
+\'.moo': 'moo',
+\'.mu': 'mu',
+\'.mustache': 'mustache',
+\'.mxt': 'mxt',
+\'.myt': 'myt',
+\'.n': 'n',
+\'.nim': 'nim',
+\'.nu': 'nu',
+\'.numpy': 'numpy',
+\'.objdump': 'objdump',
+\'.ooc': 'ooc',
+\'.parrot': 'parrot',
+\'.pas': 'pas',
+\'.pasm': 'pasm',
+\'.pd': 'pd',
+\'.phtml': 'phtml',
+\'.pir': 'pir',
+\'.pl': 'perl',
+\'.po': 'po',
+\'.py': 'python',
+\'.pytb': 'pytb',
+\'.pyx': 'pyx',
+\'.r': 'r',
+\'.raw': 'raw',
+\'.rb': 'ruby',
+\'.rhtml': 'rhtml',
+\'.rkt': 'rkt',
+\'.rs': 'rs',
+\'.rst': 'rst',
+\'.s': 's',
+\'.sass': 'sass',
+\'.sc': 'sc',
+\'.scala': 'scala',
+\'.scm': 'scheme',
+\'.scpt': 'scpt',
+\'.scss': 'scss',
+\'.self': 'self',
+\'.sh': 'sh',
+\'.sml': 'sml',
+\'.sql': 'sql',
+\'.st': 'smalltalk',
+\'.swift': 'swift',
+\'.tcl': 'tcl',
+\'.tcsh': 'tcsh',
+\'.tex': 'tex',
+\'.textile': 'textile',
+\'.tpl': 'smarty',
+\'.twig': 'twig',
+\'.txt' : 'text',
+\'.v': 'verilog',
+\'.vala': 'vala',
+\'.vb': 'vbnet',
+\'.vhd': 'vhdl',
+\'.vim': 'vim',
+\'.weechatlog': 'weechatlog',
+\'.xml': 'xml',
+\'.xq': 'xquery',
+\'.xs': 'xs',
+\'.yml': 'yaml',
 \}, get(g:, 'gist_extmap', {}))
 
 let &cpo = s:save_cpo
diff --git a/sources_non_forked/vim-gitgutter/.github/issue_template.md b/sources_non_forked/vim-gitgutter/.github/issue_template.md
deleted file mode 100644
index d700ce9..0000000
--- a/sources_non_forked/vim-gitgutter/.github/issue_template.md
+++ /dev/null
@@ -1,4 +0,0 @@
-> What is the latest commit SHA in your installed vim-gitgutter?
-
-> What vim/nvim version are you on?
-
diff --git a/sources_non_forked/vim-gitgutter/.gitignore b/sources_non_forked/vim-gitgutter/.gitignore
deleted file mode 100644
index 82fb253..0000000
--- a/sources_non_forked/vim-gitgutter/.gitignore
+++ /dev/null
@@ -1,5 +0,0 @@
-/doc/tags
-/misc
-/test/*.actual
-*.log
-
diff --git a/sources_non_forked/vim-gitgutter/LICENCE b/sources_non_forked/vim-gitgutter/LICENCE
deleted file mode 100644
index 38e2dc2..0000000
--- a/sources_non_forked/vim-gitgutter/LICENCE
+++ /dev/null
@@ -1,22 +0,0 @@
-MIT License
-
-Copyright (c) Andrew Stewart
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in all
-copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-SOFTWARE.
-
diff --git a/sources_non_forked/vim-gitgutter/README.mkd b/sources_non_forked/vim-gitgutter/README.mkd
deleted file mode 100644
index 350cebe..0000000
--- a/sources_non_forked/vim-gitgutter/README.mkd
+++ /dev/null
@@ -1,685 +0,0 @@
-## vim-gitgutter
-
-A Vim plugin which shows a git diff in the sign column.  It shows which lines have been added, modified, or removed.  You can also preview, stage, and undo individual hunks; and stage partial hunks.  The plugin also provides a hunk text object.
-
-The signs are always up to date and the plugin never saves your buffer.
-
-The name "gitgutter" comes from the Sublime Text 3 plugin which inspired this in 2013.
-
-Features:
-
-* Shows signs for added, modified, and removed lines.
-* Runs the diffs asynchronously where possible.
-* Ensures signs are always up to date.
-* Never saves the buffer.
-* Quick jumping between blocks of changed lines ("hunks").
-* Stage/undo/preview individual hunks.
-* Previews highlight intra-line changes.
-* Stage partial hunks.
-* Provides a hunk text object.
-* Diffs against index (default) or any commit.
-* Allows folding all unchanged text.
-* Provides fold text showing whether folded lines have been changed.
-* Can load all hunk locations into quickfix list or the current window's location list.
-* Handles line endings correctly, even with repos that do CRLF conversion.
-* Optional line highlighting.
-* Optional line number highlighting. (Only available in Neovim 0.3.2 or higher)
-* Fully customisable (signs, sign column, line (number) highlights, mappings, extra git-diff arguments, etc).
-* Can be toggled on/off, globally or per buffer.
-* Preserves signs from other plugins.
-* Easy to integrate diff stats into status line; built-in integration with [vim-airline](https://github.com/bling/vim-airline/).
-* Works with fish shell (in addition to the usual shells).
-
-Constraints:
-
-* Supports git only.  If you work with other version control systems, I recommend [vim-signify](https://github.com/mhinz/vim-signify).
-* Relies on the `FocusGained` event.  If your terminal doesn't report focus events, either use something like [Terminus][] or set `let g:gitgutter_terminal_reports_focus=0`.  For tmux, `set -g focus-events on` in your tmux.conf.
-
-Compatibility:
-
-Compatible back to Vim 7.4, and probably 7.3.
-
-
-### Screenshot
-
-![screenshot](./screenshot.png?raw=true)
-
-In the screenshot above you can see:
-
-* Lines 183-184 are new.
-* Lines 186-187 have been modified.
-* The preview for the modified lines highlights changed regions within the line.
-
-
-### Installation
-
-Install using your favourite package manager, or use Vim's built-in package support.
-
-Vim:
-
-```
-mkdir -p ~/.vim/pack/airblade/start
-cd ~/.vim/pack/airblade/start
-git clone https://github.com/airblade/vim-gitgutter.git
-vim -u NONE -c "helptags vim-gitgutter/doc" -c q
-```
-
-Neovim:
-
-
-```
-mkdir -p ~/.config/nvim/pack/airblade/start
-cd ~/.config/nvim/pack/airblade/start
-git clone https://github.com/airblade/vim-gitgutter.git
-nvim -u NONE -c "helptags vim-gitgutter/doc" -c q
-```
-
-
-### Windows
-
-I recommend configuring vim-gitgutter with the full path to your git executable.  For example:
-
-```viml
-let g:gitgutter_git_executable = 'C:\Program Files\Git\bin\git.exe'
-```
-
-This is to avoid a problem which occurs if you have file named `git.*` (i.e. with any extension in `PATHEXT`) in your current folder.  `cmd.exe` prioritises the current folder over folders in `PATH` and will try to execute your file instead of the `git` binary.
-
-
-### Getting started
-
-When you make a change to a file tracked by git, the diff markers should appear automatically.  The delay is governed by vim's `updatetime` option; the default value is `4000`, i.e. 4 seconds, but I suggest reducing it to around 100ms (add `set updatetime=100` to your vimrc).  Note `updatetime` also controls the delay before vim writes its swap file (see `:help updatetime`).
-
-You can jump between hunks with `[c` and `]c`.  You can preview, stage, and undo hunks with `<leader>hp`, `<leader>hs`, and `<leader>hu` respectively.
-
-You cannot unstage a staged hunk.
-
-After updating the signs, the plugin fires the `GitGutter` User autocommand.
-
-After staging a hunk or part of a hunk, the plugin fires the `GitGutterStage` User autocommand.
-
-
-#### Activation
-
-You can explicitly turn vim-gitgutter off and on (defaults to on):
-
-* turn off with `:GitGutterDisable`
-* turn on with `:GitGutterEnable`
-* toggle with `:GitGutterToggle`.
-
-To toggle vim-gitgutter per buffer:
-
-* turn off with `:GitGutterBufferDisable`
-* turn on with `:GitGutterBufferEnable`
-* toggle with `:GitGutterBufferToggle`
-
-You can turn the signs on and off (defaults to on):
-
-* turn on with `:GitGutterSignsEnable`
-* turn off with `:GitGutterSignsDisable`
-* toggle with `:GitGutterSignsToggle`.
-
-And you can turn line highlighting on and off (defaults to off):
-
-* turn on with `:GitGutterLineHighlightsEnable`
-* turn off with `:GitGutterLineHighlightsDisable`
-* toggle with `:GitGutterLineHighlightsToggle`.
-
-Note that if you have line highlighting on and signs off, you will have an empty sign column  more accurately, a sign column with invisible signs.  This is because line highlighting requires signs and Vim/NeoVim always shows the sign column when there are signs even if the signs are invisible.
-
-With Neovim 0.3.2 or higher, you can turn line number highlighting on and off (defaults to off):
-
-* turn on with `:GitGutterLineNrHighlightsEnable`
-* turn off with `:GitGutterLineNrHighlightsDisable`
-* toggle with `:GitGutterLineNrHighlightsToggle`.
-
-The same caveat applies to line number highlighting as to line highlighting just above.
-
-If you switch off both line highlighting and signs, you won't see the sign column.
-
-In older Vims (pre 8.1.0614 / Neovim 0.4.0) vim-gitgutter will suppress the signs when a file has more than 500 changes, to avoid slowing down the UI.  As soon as the number of changes falls below the limit vim-gitgutter will show the signs again.  You can configure the threshold with:
-
-```viml
-let g:gitgutter_max_signs = 500  " default value (Vim < 8.1.0614, Neovim < 0.4.0)
-let g:gitgutter_max_signs = -1   " default value (otherwise)
-```
-
-You can also remove the limit by setting `g:gitgutter_max_signs = -1`.
-
-#### Hunks
-
-You can jump between hunks:
-
-* jump to next hunk (change): `]c`
-* jump to previous hunk (change): `[c`.
-
-Both of those take a preceding count.
-
-To set your own mappings for these, for example `]h` and `[h`:
-
-```viml
-nmap ]h <Plug>(GitGutterNextHunk)
-nmap [h <Plug>(GitGutterPrevHunk)
-```
-
-You can load all your hunks into the quickfix list with `:GitGutterQuickFix`.  Note this ignores any unsaved changes in your buffers. If the option `g:gitgutter_use_location_list` is set, this command will load hunks into the current window's location list instead.
-
-You can stage or undo an individual hunk when your cursor is in it:
-
-* stage the hunk with `<Leader>hs` or
-* undo it with `<Leader>hu`.
-
-To stage part of an additions-only hunk by:
-
-* either visually selecting the part you want and staging with your mapping, e.g. `<Leader>hs`;
-* or using a range with the `GitGutterStageHunk` command, e.g. `:42,45GitGutterStageHunk`.
-
-To stage part of any hunk:
-
-* preview the hunk, e.g. `<Leader>hp`;
-* move to the preview window, e.g. `:wincmd P`;
-* delete the lines you do not want to stage;
-* stage the remaining lines: either write (`:w`) the window or stage via `<Leader>hs` or `:GitGutterStageHunk`.
-
-Note the above workflow is not possible if you have opted in to preview hunks with Vim's popup windows.
-
-See the FAQ if you want to unstage staged changes.
-
-The `.` command will work with both these if you install [repeat.vim](https://github.com/tpope/vim-repeat).
-
-To set your own mappings for these, for example if you prefer `g`-based maps:
-
-```viml
-nmap ghs <Plug>(GitGutterStageHunk)
-nmap ghu <Plug>(GitGutterUndoHunk)
-```
-
-And you can preview a hunk's changes with `<Leader>hp`.  The location of the preview window is configured with `g:gitgutter_preview_win_location` (default `'bo'`).  You can of course change this mapping, e.g:
-
-```viml
-nmap ghp <Plug>(GitGutterPreviewHunk)
-```
-
-A hunk text object is provided which works in visual and operator-pending modes.
-
-- `ic` operates on all lines in the current hunk.
-- `ac` operates on all lines in the current hunk and any trailing empty lines.
-
-To re-map these, for example to `ih` and `ah`:
-
-```viml
-omap ih <Plug>(GitGutterTextObjectInnerPending)
-omap ah <Plug>(GitGutterTextObjectOuterPending)
-xmap ih <Plug>(GitGutterTextObjectInnerVisual)
-xmap ah <Plug>(GitGutterTextObjectOuterVisual)
-```
-
-If you don't want vim-gitgutter to set up any mappings at all, use this:
-
-```viml
-let g:gitgutter_map_keys = 0
-```
-
-Finally, you can force vim-gitgutter to update its signs across all visible buffers with `:GitGutterAll`.
-
-See the customisation section below for how to change the defaults.
-
-
-### Folding
-
-Use the `GitGutterFold` command to fold all unchanged lines, leaving just the hunks visible.  Use `zr` to unfold 3 lines of context above and below a hunk.
-
-Execute `GitGutterFold` a second time to restore the previous view.
-
-Use `gitgutter#fold#foldtext()` to augment the default `foldtext()` with an indicator of whether the folded lines have been changed.
-
-```viml
-set foldtext=gitgutter#fold#foldtext()
-```
-
-For a closed fold with changed lines:
-
-```
-Default foldtext():         +-- 45 lines: abcdef
-gitgutter#fold#foldtext():  +-- 45 lines (*): abcdef
-```
-
-You can use `gitgutter#fold#is_changed()` in your own `foldtext` expression to find out whether the folded lines have been changed.
-
-
-### Status line
-
-Call the `GitGutterGetHunkSummary()` function from your status line to get a list of counts of added, modified, and removed lines in the current buffer.  For example:
-
-```viml
-" Your vimrc
-function! GitStatus()
-  let [a,m,r] = GitGutterGetHunkSummary()
-  return printf('+%d ~%d -%d', a, m, r)
-endfunction
-set statusline+=%{GitStatus()}
-```
-
-
-### Customisation
-
-You can customise:
-
-* The sign column's colours
-* Whether or not the sign column is shown when there aren't any signs (defaults to no)
-* How to handle non-gitgutter signs
-* The signs' colours and symbols
-* Line highlights
-* Whether the diff is relative to the index (default) or working tree.
-* The base of the diff
-* Extra arguments for `git` when running `git diff`
-* Extra arguments for `git diff`
-* Key mappings
-* Whether vim-gitgutter is on initially (defaults to on)
-* Whether signs are shown (defaults to yes)
-* Whether line highlighting is on initially (defaults to off)
-* Whether line number highlighting is on initially (defaults to off)
-* Whether vim-gitgutter runs asynchronously (defaults to yes)
-* Whether to clobber or preserve non-gitgutter signs
-* The priority of gitgutter's signs.
-* Whether to use a floating/popup window for hunk previews
-* Whether to populate the quickfix list or a location list with all hunks
-
-Please note that vim-gitgutter won't override any colours or highlights you've set in your colorscheme.
-
-
-#### Sign column
-
-Set the `SignColumn` highlight group to change the sign column's colour.  For example:
-
-```viml
-" vim-gitgutter used to do this by default:
-highlight! link SignColumn LineNr
-
-" or you could do this:
-highlight SignColumn guibg=whatever ctermbg=whatever
-```
-
-By default the sign column will appear when there are signs to show and disappear when there aren't.  To always have the sign column, add to your vimrc:
-
-```viml
-" Vim 7.4.2201
-set signcolumn=yes
-```
-
-GitGutter can preserve or ignore non-gitgutter signs.  For Vim v8.1.0614 and later you can set gitgutter's signs' priorities with `g:gitgutter_sign_priority`, so gitgutter defaults to clobbering other signs.  For Neovim v0.4.0 and later you can set an expanding sign column so gitgutter again defaults to clobbering other signs.  Otherwise, gitgutter defaults to preserving other signs.  You can configure this with:
-
-```viml
-let g:gitgutter_sign_allow_clobber = 1
-```
-
-
-#### Signs' colours and symbols
-
-If you or your colourscheme has defined `GitGutter*` highlight groups, the plugin will use them for the signs' colours.
-
-If you want the background colours to match the sign column, but don't want to update the `GitGutter*` groups yourself, you can get the plugin to do it:
-
-```viml
-let g:gitgutter_set_sign_backgrounds = 1
-```
-
-If no `GitGutter*` highlight groups exist, the plugin will check the `Diff*` highlight groups.  If their foreground colours differ the plugin will use them; if not, these colours will be used:
-
-```viml
-highlight GitGutterAdd    guifg=#009900 ctermfg=2
-highlight GitGutterChange guifg=#bbbb00 ctermfg=3
-highlight GitGutterDelete guifg=#ff2222 ctermfg=1
-```
-
-To customise the symbols, add the following to your `~/.vimrc`:
-
-```viml
-let g:gitgutter_sign_added = 'xx'
-let g:gitgutter_sign_modified = 'yy'
-let g:gitgutter_sign_removed = 'zz'
-let g:gitgutter_sign_removed_first_line = '^^'
-let g:gitgutter_sign_modified_removed = 'ww'
-```
-
-
-#### Line highlights
-
-Similarly to the signs' colours, set up the following highlight groups in your colorscheme or `~/.vimrc`:
-
-```viml
-GitGutterAddLine          " default: links to DiffAdd
-GitGutterChangeLine       " default: links to DiffChange
-GitGutterDeleteLine       " default: links to DiffDelete
-GitGutterChangeDeleteLine " default: links to GitGutterChangeLineDefault, i.e. DiffChange
-```
-
-For example, in some colorschemes the `DiffText` highlight group is easier to read than `DiffChange`.  You could use it like this:
-
-```viml
-highlight link GitGutterChangeLine DiffText
-```
-
-
-#### Line number highlights
-
-NOTE: This feature requires Neovim 0.3.2 or higher.
-
-Similarly to the signs' colours, set up the following highlight groups in your colorscheme or `~/.vimrc`:
-
-```viml
-GitGutterAddLineNr          " default: links to CursorLineNr
-GitGutterChangeLineNr       " default: links to CursorLineNr
-GitGutterDeleteLineNr       " default: links to CursorLineNr
-GitGutterChangeDeleteLineNr " default: links to CursorLineNr
-```
-
-Maybe you think `CursorLineNr` is a bit annoying.  For example, you could use `Underlined` for this:
-
-```viml
-highlight link GitGutterChangeLineNr Underlined
-```
-
-
-#### Whether the diff is relative to the index or working tree
-
-By default diffs are relative to the index.  How you can make them relative to the working tree:
-
-```viml
-let g:gitgutter_diff_relative_to = 'working_tree'
-```
-
-
-#### The base of the diff
-
-By default buffers are diffed against the index.  However you can diff against any commit by setting:
-
-```viml
-let g:gitgutter_diff_base = '<commit SHA>'
-```
-
-If you are looking at a previous version of a file with Fugitive (e.g. via `:0Gclog`), gitgutter sets the diff base to the parent of the current revision.
-
-This setting is ignored when the diffs are relative to the working tree.
-
-
-#### Extra arguments for `git` when running `git diff`
-
-If you want to pass extra arguments to `git` when running `git diff`, do so like this:
-
-```viml
-let g:gitgutter_git_args = '--git-dir-""'
-```
-
-#### Extra arguments for `git diff`
-
-If you want to pass extra arguments to `git diff`, for example to ignore whitespace, do so like this:
-
-```viml
-let g:gitgutter_diff_args = '-w'
-```
-
-#### Key mappings
-
-To disable all key mappings:
-
-```viml
-let g:gitgutter_map_keys = 0
-```
-
-See above for configuring maps for hunk-jumping and staging/undoing.
-
-
-#### Use a custom `grep` command
-
-If you use an alternative to grep, you can tell vim-gitgutter to use it here.
-
-```viml
-" Default:
-let g:gitgutter_grep = 'grep'
-```
-
-#### To turn off vim-gitgutter by default
-
-Add `let g:gitgutter_enabled = 0` to your `~/.vimrc`.
-
-
-#### To turn off signs by default
-
-Add `let g:gitgutter_signs = 0` to your `~/.vimrc`.
-
-
-#### To turn on line highlighting by default
-
-Add `let g:gitgutter_highlight_lines = 1` to your `~/.vimrc`.
-
-
-#### To turn on line number highlighting by default
-
-Add `let g:gitgutter_highlight_linenrs = 1` to your `~/.vimrc`.
-
-
-#### To turn off asynchronous updates
-
-By default diffs are run asynchronously.  To run diffs synchronously instead:
-
-```viml
-let g:gitgutter_async = 0
-```
-
-
-#### To use floating/popup windows for hunk previews
-
-Add `let g:gitgutter_preview_win_floating = 1` to your `~/.vimrc`.  Note that on Vim this prevents you staging (partial) hunks via the preview window.
-
-
-#### To load all hunks into the current window's location list instead of the quickfix list
-
-Add `let g:gitgutter_use_location_list = 1` to your `~/.vimrc`.
-
-
-### Extensions
-
-#### Operate on every line in a hunk
-
-You can map an operator to do whatever you want to every line in a hunk.
-
-Let's say, for example, you want to remove trailing whitespace.
-
-```viml
-function! CleanUp(...)
-  if a:0  " opfunc
-    let [first, last] = [line("'["), line("']")]
-  else
-    let [first, last] = [line("'<"), line("'>")]
-  endif
-  for lnum in range(first, last)
-    let line = getline(lnum)
-
-    " clean up the text, e.g.:
-    let line = substitute(line, '\s\+$', '', '')
-
-    call setline(lnum, line)
-  endfor
-endfunction
-
-nmap <silent> <Leader>x :set opfunc=CleanUp<CR>g@
-```
-
-Then place your cursor in a hunk and type `\xic` (assuming a leader of `\`).
-
-Alternatively you could place your cursor in a hunk, type `vic` to select it, then `:call CleanUp()`.
-
-
-#### Operate on every changed line in a file
-
-You can write a command to do whatever you want to every changed line in a file.
-
-```viml
-function! GlobalChangedLines(ex_cmd)
-  for hunk in GitGutterGetHunks()
-    for lnum in range(hunk[2], hunk[2]+hunk[3]-1)
-      let cursor = getcurpos()
-      silent! execute lnum.a:ex_cmd
-      call setpos('.', cursor)
-    endfor
-  endfor
-endfunction
-
-command -nargs=1 Glines call GlobalChangedLines(<q-args>)
-```
-
-Let's say, for example, you want to remove trailing whitespace from all changed lines:
-
-```viml
-:Glines s/\s\+$//
-```
-
-
-#### Cycle through hunks in current buffer
-
-This is like `:GitGutterNextHunk` but when it gets to the last hunk in the buffer it cycles around to the first.
-
-```viml
-function! GitGutterNextHunkCycle()
-  let line = line('.')
-  silent! GitGutterNextHunk
-  if line('.') == line
-    1
-    GitGutterNextHunk
-  endif
-endfunction
-```
-
-
-#### Cycle through hunks in all buffers
-
-You can use `:GitGutterQuickFix` to load all hunks into the quickfix list or the current window's location list.
-
-Alternatively, given that`]c` and `[c` jump from one hunk to the next in the current buffer, you can use this code to jump to the next hunk no matter which buffer it's in.
-
-```viml
-function! NextHunkAllBuffers()
-  let line = line('.')
-  GitGutterNextHunk
-  if line('.') != line
-    return
-  endif
-
-  let bufnr = bufnr('')
-  while 1
-    bnext
-    if bufnr('') == bufnr
-      return
-    endif
-    if !empty(GitGutterGetHunks())
-      1
-      GitGutterNextHunk
-      return
-    endif
-  endwhile
-endfunction
-
-function! PrevHunkAllBuffers()
-  let line = line('.')
-  GitGutterPrevHunk
-  if line('.') != line
-    return
-  endif
-
-  let bufnr = bufnr('')
-  while 1
-    bprevious
-    if bufnr('') == bufnr
-      return
-    endif
-    if !empty(GitGutterGetHunks())
-      normal! G
-      GitGutterPrevHunk
-      return
-    endif
-  endwhile
-endfunction
-
-nmap <silent> ]c :call NextHunkAllBuffers()<CR>
-nmap <silent> [c :call PrevHunkAllBuffers()<CR>
-```
-
-
-### FAQ
-
-> How can I turn off realtime updates?
-
-Add this to your vim configuration (in an `/after/plugin` directory):
-
-```viml
-" .vim/after/plugin/gitgutter.vim
-autocmd! gitgutter CursorHold,CursorHoldI
-```
-
-> I turned off realtime updates, how can I have signs updated when I save a file?
-
-If you really want to update the signs when you save a file, add this to your vimrc:
-
-```viml
-autocmd BufWritePost * GitGutter
-```
-
-> Why can't I unstage staged changes?
-
-This plugin is for showing changes between the buffer and the index (and staging/undoing those changes).  Unstaging a staged hunk would require showing changes between the index and HEAD, which is out of scope.
-
-> Why are the colours in the sign column weird?
-
-Your colorscheme is configuring the `SignColumn` highlight group weirdly.  Please see the section above on customising the sign column.
-
-> What happens if I also use another plugin which uses signs (e.g. Syntastic)?
-
-You can configure whether GitGutter preserves or clobbers other signs using `g:gitgutter_sign_allow_clobber`.  Set to `1` to clobber other signs (default on Vim >= 8.1.0614 and NeoVim >= 0.4.0) or `0` to preserve them.
-
-
-### Troubleshooting
-
-#### When no signs are showing at all
-
-Here are some things you can check:
-
-* Try adding `let g:gitgutter_grep=''` to your vimrc.  If it works, the problem is grep producing non-plain output; e.g. ANSI escape codes or colours.
-* Verify `:echo system("git --version")` succeeds.
-* Verify your git config is compatible with the version of git returned by the command above.
-* Verify your Vim supports signs (`:echo has('signs')` should give `1`).
-* Verify your file is being tracked by git and has unstaged changes.
-
-#### When the whole file is marked as added
-
-* If you use zsh, and you set `CDPATH`, make sure `CDPATH` doesn't include the current directory.
-
-#### When signs take a few seconds to appear
-
-* Try reducing `updatetime`, e.g. `set updatetime=100`.  Note this also controls the delay before vim writes its swap file.
-
-#### When signs don't update after focusing Vim
-
-* Your terminal probably isn't reporting focus events.  Either try installing [Terminus][] or set `let g:gitgutter_terminal_reports_focus=0`.  For tmux, try `set -g focus-events on` in your tmux.conf.
-
-
-### Shameless Plug
-
-If this plugin has helped you, or you'd like to learn more about Vim, why not check out this screencast I wrote for PeepCode:
-
-* [Smash Into Vim][siv]
-
-This was one of PeepCode's all-time top three bestsellers and is now available at Pluralsight.
-
-You can read reviews on my [website][airblade].
-
-
-### Intellectual Property
-
-Copyright Andrew Stewart, AirBlade Software Ltd.  Released under the MIT licence.
-
-
-  [pathogen]: https://github.com/tpope/vim-pathogen
-  [siv]: http://pluralsight.com/training/Courses/TableOfContents/smash-into-vim
-  [airblade]: http://airbladesoftware.com/peepcode-vim
-  [terminus]: https://github.com/wincent/terminus
diff --git a/sources_non_forked/vim-gitgutter/autoload/gitgutter.vim b/sources_non_forked/vim-gitgutter/autoload/gitgutter.vim
deleted file mode 100644
index d56a8d9..0000000
--- a/sources_non_forked/vim-gitgutter/autoload/gitgutter.vim
+++ /dev/null
@@ -1,209 +0,0 @@
-" Primary functions {{{
-
-function! gitgutter#all(force) abort
-  let visible = tabpagebuflist()
-
-  for bufnr in range(1, bufnr('$') + 1)
-    if buflisted(bufnr)
-      let file = expand('#'.bufnr.':p')
-      if !empty(file)
-        if index(visible, bufnr) != -1
-          call gitgutter#process_buffer(bufnr, a:force)
-        elseif a:force
-          call s:reset_tick(bufnr)
-        endif
-      endif
-    endif
-  endfor
-endfunction
-
-
-function! gitgutter#process_buffer(bufnr, force) abort
-  " NOTE a:bufnr is not necessarily the current buffer.
-
-  if gitgutter#utility#is_active(a:bufnr)
-
-    if has('patch-7.4.1559')
-      let l:Callback = function('gitgutter#process_buffer', [a:bufnr, a:force])
-    else
-      let l:Callback = {'function': 'gitgutter#process_buffer', 'arguments': [a:bufnr, a:force]}
-    endif
-    let how = s:setup_path(a:bufnr, l:Callback)
-    if [how] == ['async']  " avoid string-to-number conversion if how is a number
-      return
-    endif
-
-    if a:force || s:has_fresh_changes(a:bufnr)
-
-      let diff = 'NOT SET'
-      try
-        let diff = gitgutter#diff#run_diff(a:bufnr, g:gitgutter_diff_relative_to, 0)
-      catch /gitgutter not tracked/
-        call gitgutter#debug#log('Not tracked: '.gitgutter#utility#file(a:bufnr))
-      catch /gitgutter diff failed/
-        call gitgutter#debug#log('Diff failed: '.gitgutter#utility#file(a:bufnr))
-        call gitgutter#hunk#reset(a:bufnr)
-      endtry
-
-      if diff != 'async' && diff != 'NOT SET'
-        call gitgutter#diff#handler(a:bufnr, diff)
-      endif
-
-    endif
-  endif
-endfunction
-
-
-function! gitgutter#disable() abort
-  " get list of all buffers (across all tabs)
-  for bufnr in range(1, bufnr('$') + 1)
-    if buflisted(bufnr)
-      let file = expand('#'.bufnr.':p')
-      if !empty(file)
-        call s:clear(bufnr)
-      endif
-    endif
-  endfor
-
-  let g:gitgutter_enabled = 0
-endfunction
-
-function! gitgutter#enable() abort
-  let g:gitgutter_enabled = 1
-  call gitgutter#all(1)
-endfunction
-
-function! gitgutter#toggle() abort
-  if g:gitgutter_enabled
-    call gitgutter#disable()
-  else
-    call gitgutter#enable()
-  endif
-endfunction
-
-
-function! gitgutter#buffer_disable() abort
-  let bufnr = bufnr('')
-  call gitgutter#utility#setbufvar(bufnr, 'enabled', 0)
-  call s:clear(bufnr)
-endfunction
-
-function! gitgutter#buffer_enable() abort
-  let bufnr = bufnr('')
-  call gitgutter#utility#setbufvar(bufnr, 'enabled', 1)
-  call gitgutter#process_buffer(bufnr, 1)
-endfunction
-
-function! gitgutter#buffer_toggle() abort
-  if gitgutter#utility#getbufvar(bufnr(''), 'enabled', 1)
-    call gitgutter#buffer_disable()
-  else
-    call gitgutter#buffer_enable()
-  endif
-endfunction
-
-" }}}
-
-function! gitgutter#setup_maps()
-  if !g:gitgutter_map_keys
-    return
-  endif
-
-  " Note hasmapto() and maparg() operate on the current buffer.
-
-  let bufnr = bufnr('')
-
-  if gitgutter#utility#getbufvar(bufnr, 'mapped', 0)
-    return
-  endif
-
-  if !hasmapto('<Plug>(GitGutterPrevHunk)') && maparg('[c', 'n') ==# ''
-    nmap <buffer> [c <Plug>(GitGutterPrevHunk)
-  endif
-  if !hasmapto('<Plug>(GitGutterNextHunk)') && maparg(']c', 'n') ==# ''
-    nmap <buffer> ]c <Plug>(GitGutterNextHunk)
-  endif
-
-  if !hasmapto('<Plug>(GitGutterStageHunk)', 'v') && maparg('<Leader>hs', 'x') ==# ''
-    xmap <buffer> <Leader>hs <Plug>(GitGutterStageHunk)
-  endif
-  if !hasmapto('<Plug>(GitGutterStageHunk)', 'n') && maparg('<Leader>hs', 'n') ==# ''
-    nmap <buffer> <Leader>hs <Plug>(GitGutterStageHunk)
-  endif
-  if !hasmapto('<Plug>(GitGutterUndoHunk)') && maparg('<Leader>hu', 'n') ==# ''
-    nmap <buffer> <Leader>hu <Plug>(GitGutterUndoHunk)
-  endif
-  if !hasmapto('<Plug>(GitGutterPreviewHunk)') && maparg('<Leader>hp', 'n') ==# ''
-    nmap <buffer> <Leader>hp <Plug>(GitGutterPreviewHunk)
-  endif
-
-  if !hasmapto('<Plug>(GitGutterTextObjectInnerPending)') && maparg('ic', 'o') ==# ''
-    omap <buffer> ic <Plug>(GitGutterTextObjectInnerPending)
-  endif
-  if !hasmapto('<Plug>(GitGutterTextObjectOuterPending)') && maparg('ac', 'o') ==# ''
-    omap <buffer> ac <Plug>(GitGutterTextObjectOuterPending)
-  endif
-  if !hasmapto('<Plug>(GitGutterTextObjectInnerVisual)') && maparg('ic', 'x') ==# ''
-    xmap <buffer> ic <Plug>(GitGutterTextObjectInnerVisual)
-  endif
-  if !hasmapto('<Plug>(GitGutterTextObjectOuterVisual)') && maparg('ac', 'x') ==# ''
-    xmap <buffer> ac <Plug>(GitGutterTextObjectOuterVisual)
-  endif
-
-  call gitgutter#utility#setbufvar(bufnr, 'mapped', 1)
-endfunction
-
-function! s:setup_path(bufnr, continuation)
-  if gitgutter#utility#has_repo_path(a:bufnr) | return | endif
-
-  return gitgutter#utility#set_repo_path(a:bufnr, a:continuation)
-endfunction
-
-function! s:has_fresh_changes(bufnr) abort
-  return getbufvar(a:bufnr, 'changedtick') != gitgutter#utility#getbufvar(a:bufnr, 'tick')
-endfunction
-
-function! s:reset_tick(bufnr) abort
-  call gitgutter#utility#setbufvar(a:bufnr, 'tick', 0)
-endfunction
-
-function! s:clear(bufnr)
-  call gitgutter#sign#clear_signs(a:bufnr)
-  call gitgutter#hunk#reset(a:bufnr)
-  call s:reset_tick(a:bufnr)
-  call gitgutter#utility#setbufvar(a:bufnr, 'path', '')
-endfunction
-
-
-" Note:
-" - this runs synchronously
-" - it ignores unsaved changes in buffers
-" - it does not change to the repo root
-function! gitgutter#quickfix()
-  let locations = []
-  let cmd = g:gitgutter_git_executable.' '.g:gitgutter_git_args.' --no-pager '.g:gitgutter_git_args.
-        \ ' diff --no-ext-diff --no-color -U0 '.g:gitgutter_diff_args. ' '. g:gitgutter_diff_base
-  let diff = systemlist(cmd)
-  let lnum = 0
-  for line in diff
-    if line =~ '^diff --git [^"]'
-      let paths = line[11:]
-      let mid = (len(paths) - 1) / 2
-      let [fnamel, fnamer] = [paths[:mid-1], paths[mid+1:]]
-      let fname = fnamel ==# fnamer ? fnamel : fnamel[2:]
-    elseif line =~ '^diff --git "'
-      let [_, fnamel, _, fnamer] = split(line, '"')
-      let fname = fnamel ==# fnamer ? fnamel : fnamel[2:]
-    elseif line =~ '^@@'
-      let lnum = matchlist(line, '+\(\d\+\)')[1]
-    elseif lnum > 0
-      call add(locations, {'filename': fname, 'lnum': lnum, 'text': line})
-      let lnum = 0
-    endif
-  endfor
-  if !g:gitgutter_use_location_list
-    call setqflist(locations)
-  else
-    call setloclist(0, locations)
-  endif
-endfunction
diff --git a/sources_non_forked/vim-gitgutter/autoload/gitgutter/async.vim b/sources_non_forked/vim-gitgutter/autoload/gitgutter/async.vim
deleted file mode 100644
index 1cc2b16..0000000
--- a/sources_non_forked/vim-gitgutter/autoload/gitgutter/async.vim
+++ /dev/null
@@ -1,97 +0,0 @@
-let s:available = has('nvim') || (
-      \   has('job') && (
-      \     (has('patch-7-4-1826') && !has('gui_running')) ||
-      \     (has('patch-7-4-1850') &&  has('gui_running')) ||
-      \     (has('patch-7-4-1832') &&  has('gui_macvim'))
-      \   )
-      \ )
-
-function! gitgutter#async#available()
-  return s:available
-endfunction
-
-
-function! gitgutter#async#execute(cmd, bufnr, handler) abort
-  call gitgutter#debug#log('[async] '.a:cmd)
-
-  let options = {
-        \   'stdoutbuffer': [],
-        \   'buffer': a:bufnr,
-        \   'handler': a:handler
-        \ }
-  let command = s:build_command(a:cmd)
-
-  if has('nvim')
-    call jobstart(command, extend(options, {
-          \   'on_stdout': function('s:on_stdout_nvim'),
-          \   'on_stderr': function('s:on_stderr_nvim'),
-          \   'on_exit':   function('s:on_exit_nvim')
-          \ }))
-  else
-    call job_start(command, {
-          \   'out_cb':   function('s:on_stdout_vim', options),
-          \   'err_cb':   function('s:on_stderr_vim', options),
-          \   'close_cb': function('s:on_exit_vim', options)
-          \ })
-  endif
-endfunction
-
-
-function! s:build_command(cmd)
-  if has('unix')
-    return ['sh', '-c', a:cmd]
-  endif
-
-  if has('win32')
-    return has('nvim') ? ['cmd.exe', '/c', a:cmd] : 'cmd.exe /c '.a:cmd
-  endif
-
-  throw 'unknown os'
-endfunction
-
-
-function! s:on_stdout_nvim(_job_id, data, _event) dict abort
-  if empty(self.stdoutbuffer)
-    let self.stdoutbuffer = a:data
-  else
-    let self.stdoutbuffer = self.stdoutbuffer[:-2] +
-          \ [self.stdoutbuffer[-1] . a:data[0]] +
-          \ a:data[1:]
-  endif
-endfunction
-
-function! s:on_stderr_nvim(_job_id, data, _event) dict abort
-  if a:data != ['']  " With Neovim there is always [''] reported on stderr.
-    call self.handler.err(self.buffer)
-  endif
-endfunction
-
-function! s:on_exit_nvim(_job_id, exit_code, _event) dict abort
-  if !a:exit_code
-    call self.handler.out(self.buffer, join(self.stdoutbuffer, "\n"))
-  endif
-endfunction
-
-
-function! s:on_stdout_vim(_channel, data) dict abort
-  call add(self.stdoutbuffer, a:data)
-endfunction
-
-function! s:on_stderr_vim(channel, _data) dict abort
-  call self.handler.err(self.buffer)
-endfunction
-
-function! s:on_exit_vim(channel) dict abort
-  let job = ch_getjob(a:channel)
-  while 1
-    if job_status(job) == 'dead'
-      let exit_code = job_info(job).exitval
-      break
-    endif
-    sleep 5m
-  endwhile
-
-  if !exit_code
-    call self.handler.out(self.buffer, join(self.stdoutbuffer, "\n"))
-  endif
-endfunction
diff --git a/sources_non_forked/vim-gitgutter/autoload/gitgutter/debug.vim b/sources_non_forked/vim-gitgutter/autoload/gitgutter/debug.vim
deleted file mode 100644
index 79d197e..0000000
--- a/sources_non_forked/vim-gitgutter/autoload/gitgutter/debug.vim
+++ /dev/null
@@ -1,119 +0,0 @@
-let s:plugin_dir  = expand('<sfile>:p:h:h:h').'/'
-let s:log_file    = s:plugin_dir.'gitgutter.log'
-let s:channel_log = s:plugin_dir.'channel.log'
-let s:new_log_session = 1
-
-
-function! gitgutter#debug#debug()
-  " Open a scratch buffer
-  vsplit __GitGutter_Debug__
-  normal! ggdG
-  setlocal buftype=nofile
-  setlocal bufhidden=delete
-  setlocal noswapfile
-
-  call s:vim_version()
-  call s:separator()
-
-  call s:git_version()
-  call s:separator()
-
-  call s:grep_version()
-  call s:separator()
-
-  call s:option('updatetime')
-  call s:option('shell')
-  call s:option('shellcmdflag')
-  call s:option('shellpipe')
-  call s:option('shellquote')
-  call s:option('shellredir')
-  call s:option('shellslash')
-  call s:option('shelltemp')
-  call s:option('shelltype')
-  call s:option('shellxescape')
-  call s:option('shellxquote')
-endfunction
-
-
-function! s:separator()
-  call s:output('')
-endfunction
-
-function! s:vim_version()
-  redir => version_info
-    silent execute 'version'
-  redir END
-  call s:output(split(version_info, '\n')[0:2])
-endfunction
-
-function! s:git_version()
-  let v = system(g:gitgutter_git_executable.' --version')
-  call s:output( substitute(v, '\n$', '', '') )
-endfunction
-
-function! s:grep_version()
-  let v = system('grep --version')
-  call s:output( substitute(v, '\n$', '', '') )
-
-  let v = system('grep --help')
-  call s:output( substitute(v, '\%x00', '', 'g') )
-endfunction
-
-function! s:option(name)
-  if exists('+' . a:name)
-    let v = eval('&' . a:name)
-    call s:output(a:name . '=' . v)
-    " redir => output
-    "   silent execute "verbose set " . a:name . "?"
-    " redir END
-    " call s:output(a:name . '=' . output)
-  else
-    call s:output(a:name . ' [n/a]')
-  end
-endfunction
-
-function! s:output(text)
-  call append(line('$'), a:text)
-endfunction
-
-" assumes optional args are calling function's optional args
-function! gitgutter#debug#log(message, ...) abort
-  if g:gitgutter_log
-    if s:new_log_session && gitgutter#async#available()
-      if exists('*ch_logfile')
-        call ch_logfile(s:channel_log, 'w')
-      endif
-    endif
-
-    execute 'redir >> '.s:log_file
-      if s:new_log_session
-        let s:start = reltime()
-        silent echo "\n==== start log session ===="
-      endif
-
-      let elapsed = reltimestr(reltime(s:start)).' '
-      silent echo ''
-      " callers excluding this function
-      silent echo elapsed.expand('<sfile>')[:-22].':'
-      silent echo elapsed.s:format_for_log(a:message)
-      if a:0 && !empty(a:1)
-        for msg in a:000
-          silent echo elapsed.s:format_for_log(msg)
-        endfor
-      endif
-    redir END
-
-    let s:new_log_session = 0
-  endif
-endfunction
-
-function! s:format_for_log(data) abort
-  if type(a:data) == 1
-    return join(split(a:data,'\n'),"\n")
-  elseif type(a:data) == 3
-    return '['.join(a:data,"\n").']'
-  else
-    return a:data
-  endif
-endfunction
-
diff --git a/sources_non_forked/vim-gitgutter/autoload/gitgutter/diff.vim b/sources_non_forked/vim-gitgutter/autoload/gitgutter/diff.vim
deleted file mode 100644
index 5567009..0000000
--- a/sources_non_forked/vim-gitgutter/autoload/gitgutter/diff.vim
+++ /dev/null
@@ -1,409 +0,0 @@
-scriptencoding utf8
-
-let s:nomodeline = (v:version > 703 || (v:version == 703 && has('patch442'))) ? '<nomodeline>' : ''
-
-let s:hunk_re = '^@@ -\(\d\+\),\?\(\d*\) +\(\d\+\),\?\(\d*\) @@'
-
-" True for git v1.7.2+.
-function! s:git_supports_command_line_config_override() abort
-  call gitgutter#utility#system(g:gitgutter_git_executable.' '.g:gitgutter_git_args.' -c foo.bar=baz --version')
-  return !v:shell_error
-endfunction
-
-let s:c_flag = s:git_supports_command_line_config_override()
-
-let s:counter = 0
-
-" Returns a diff of the buffer against the index or the working tree.
-"
-" After running the diff we pass it through grep where available to reduce
-" subsequent processing by the plugin.  If grep is not available the plugin
-" does the filtering instead.
-"
-" When diffing against the index:
-"
-" The buffer contents is not the same as the file on disk so we need to pass
-" two instances of the file to git-diff:
-"
-"     git diff myfileA myfileB
-"
-" where myfileA comes from
-"
-"     git show :myfile > myfileA
-"
-" and myfileB is the buffer contents.
-"
-" Regarding line endings:
-"
-" git-show does not convert line endings.
-" git-diff FILE FILE does convert line endings for the given files.
-"
-" If a file has CRLF line endings and git's core.autocrlf is true,
-" the file in git's object store will have LF line endings.  Writing
-" it out via git-show will produce a file with LF line endings.
-"
-" If this last file is one of the files passed to git-diff, git-diff will
-" convert its line endings to CRLF before diffing -- which is what we want --
-" but also by default output a warning on stderr.
-"
-"   warning: LF will be replace by CRLF in <temp file>.
-"   The file will have its original line endings in your working directory.
-"
-" When running the diff asynchronously, the warning message triggers the stderr
-" callbacks which assume the overall command has failed and reset all the
-" signs.  As this is not what we want, and we can safely ignore the warning,
-" we turn it off by passing the '-c "core.safecrlf=false"' argument to
-" git-diff.
-"
-" When writing the temporary files we preserve the original file's extension
-" so that repos using .gitattributes to control EOL conversion continue to
-" convert correctly.
-"
-" Arguments:
-"
-" bufnr              - the number of the buffer to be diffed
-" from               - 'index' or 'working_tree'; what the buffer is diffed against
-" preserve_full_diff - truthy to return the full diff or falsey to return only
-"                      the hunk headers (@@ -x,y +m,n @@); only possible if
-"                      grep is available.
-function! gitgutter#diff#run_diff(bufnr, from, preserve_full_diff) abort
-  if gitgutter#utility#repo_path(a:bufnr, 0) == -1
-    throw 'gitgutter author fail'
-  endif
-
-  if gitgutter#utility#repo_path(a:bufnr, 0) == -2
-    throw 'gitgutter not tracked'
-  endif
-
-  let temp_from = tempname()
-  let temp_buffer = tempname()
-
-  " Wrap compound commands in parentheses to make Windows happy.
-  " bash doesn't mind the parentheses.
-  let cmd = '('
-
-  " Append buffer number to temp filenames to avoid race conditions between
-  " writing and reading the files when asynchronously processing multiple
-  " buffers.
-
-  " Without the buffer number, buff_file would have a race between the
-  " second gitgutter#process_buffer() writing the file (synchronously, below)
-  " and the first gitgutter#process_buffer()'s async job reading it (with
-  " git-diff).
-  let buff_file = temp_buffer.'.'.a:bufnr
-
-  " Add a counter to avoid a similar race with two quick writes of the same buffer.
-  " Use a modulus greater than a maximum reasonable number of visible buffers.
-  let s:counter = (s:counter + 1) % 20
-  let buff_file .= '.'.s:counter
-
-  let extension = gitgutter#utility#extension(a:bufnr)
-  if !empty(extension)
-    let buff_file .= '.'.extension
-  endif
-
-  " Write buffer to temporary file.
-  " Note: this is synchronous.
-  call s:write_buffer(a:bufnr, buff_file)
-
-  if a:from ==# 'index'
-    " Without the buffer number, from_file would have a race in the shell
-    " between the second process writing it (with git-show) and the first
-    " reading it (with git-diff).
-    let from_file = temp_from.'.'.a:bufnr
-
-    " Add a counter to avoid a similar race with two quick writes of the same buffer.
-    let from_file .= '.'.s:counter
-
-    if !empty(extension)
-      let from_file .= '.'.extension
-    endif
-
-    " Write file from index to temporary file.
-    let index_name = gitgutter#utility#get_diff_base(a:bufnr).':'.gitgutter#utility#repo_path(a:bufnr, 1)
-    let cmd .= g:gitgutter_git_executable.' '.g:gitgutter_git_args.' --no-pager show '.index_name.' > '.from_file.' && '
-
-  elseif a:from ==# 'working_tree'
-    let from_file = gitgutter#utility#repo_path(a:bufnr, 1)
-  endif
-
-  " Call git-diff.
-  let cmd .= g:gitgutter_git_executable.' '.g:gitgutter_git_args.' --no-pager '.g:gitgutter_git_args
-  if s:c_flag
-    let cmd .= ' -c "diff.autorefreshindex=0"'
-    let cmd .= ' -c "diff.noprefix=false"'
-    let cmd .= ' -c "core.safecrlf=false"'
-  endif
-  let cmd .= ' diff --no-ext-diff --no-color -U0 '.g:gitgutter_diff_args.' -- '.from_file.' '.buff_file
-
-  " Pipe git-diff output into grep.
-  if !a:preserve_full_diff && !empty(g:gitgutter_grep)
-    let cmd .= ' | '.g:gitgutter_grep.' '.gitgutter#utility#shellescape('^@@ ')
-  endif
-
-  " grep exits with 1 when no matches are found; git-diff exits with 1 when
-  " differences are found.  However we want to treat non-matches and
-  " differences as non-erroneous behaviour; so we OR the command with one
-  " which always exits with success (0).
-  let cmd .= ' || exit 0'
-
-  let cmd .= ')'
-
-  let cmd = gitgutter#utility#cd_cmd(a:bufnr, cmd)
-
-  if g:gitgutter_async && gitgutter#async#available()
-    call gitgutter#async#execute(cmd, a:bufnr, {
-          \   'out': function('gitgutter#diff#handler'),
-          \   'err': function('gitgutter#hunk#reset'),
-          \ })
-    return 'async'
-
-  else
-    let diff = gitgutter#utility#system(cmd)
-
-    if v:shell_error
-      call gitgutter#debug#log(diff)
-      throw 'gitgutter diff failed'
-    endif
-
-    return diff
-  endif
-endfunction
-
-
-function! gitgutter#diff#handler(bufnr, diff) abort
-  call gitgutter#debug#log(a:diff)
-
-  if !bufexists(a:bufnr)
-    return
-  endif
-
-  call gitgutter#hunk#set_hunks(a:bufnr, gitgutter#diff#parse_diff(a:diff))
-  let modified_lines = gitgutter#diff#process_hunks(a:bufnr, gitgutter#hunk#hunks(a:bufnr))
-
-  let signs_count = len(modified_lines)
-  if g:gitgutter_max_signs != -1 && signs_count > g:gitgutter_max_signs
-    call gitgutter#utility#warn_once(a:bufnr, printf(
-          \ 'exceeded maximum number of signs (%d > %d, configured by g:gitgutter_max_signs).',
-          \ signs_count, g:gitgutter_max_signs), 'max_signs')
-    call gitgutter#sign#clear_signs(a:bufnr)
-
-  else
-    if g:gitgutter_signs || g:gitgutter_highlight_lines || g:gitgutter_highlight_linenrs
-      call gitgutter#sign#update_signs(a:bufnr, modified_lines)
-    endif
-  endif
-
-  call s:save_last_seen_change(a:bufnr)
-  if exists('#User#GitGutter')
-    let g:gitgutter_hook_context = {'bufnr': a:bufnr}
-    execute 'doautocmd' s:nomodeline 'User GitGutter'
-    unlet g:gitgutter_hook_context
-  endif
-endfunction
-
-
-function! gitgutter#diff#parse_diff(diff) abort
-  let hunks = []
-  for line in split(a:diff, '\n')
-    let hunk_info = gitgutter#diff#parse_hunk(line)
-    if len(hunk_info) == 4
-      call add(hunks, hunk_info)
-    endif
-  endfor
-  return hunks
-endfunction
-
-function! gitgutter#diff#parse_hunk(line) abort
-  let matches = matchlist(a:line, s:hunk_re)
-  if len(matches) > 0
-    let from_line  = str2nr(matches[1])
-    let from_count = (matches[2] == '') ? 1 : str2nr(matches[2])
-    let to_line    = str2nr(matches[3])
-    let to_count   = (matches[4] == '') ? 1 : str2nr(matches[4])
-    return [from_line, from_count, to_line, to_count]
-  else
-    return []
-  end
-endfunction
-
-" This function is public so it may be used by other plugins
-" e.g. vim-signature.
-function! gitgutter#diff#process_hunks(bufnr, hunks) abort
-  let modified_lines = []
-  for hunk in a:hunks
-    call extend(modified_lines, s:process_hunk(a:bufnr, hunk))
-  endfor
-  return modified_lines
-endfunction
-
-" Returns [ [<line_number (number)>, <name (string)>], ...]
-function! s:process_hunk(bufnr, hunk) abort
-  let modifications = []
-  let from_line  = a:hunk[0]
-  let from_count = a:hunk[1]
-  let to_line    = a:hunk[2]
-  let to_count   = a:hunk[3]
-
-  if s:is_added(from_count, to_count)
-    call s:process_added(modifications, from_count, to_count, to_line)
-    call gitgutter#hunk#increment_lines_added(a:bufnr, to_count)
-
-  elseif s:is_removed(from_count, to_count)
-    call s:process_removed(modifications, from_count, to_count, to_line)
-    call gitgutter#hunk#increment_lines_removed(a:bufnr, from_count)
-
-  elseif s:is_modified(from_count, to_count)
-    call s:process_modified(modifications, from_count, to_count, to_line)
-    call gitgutter#hunk#increment_lines_modified(a:bufnr, to_count)
-
-  elseif s:is_modified_and_added(from_count, to_count)
-    call s:process_modified_and_added(modifications, from_count, to_count, to_line)
-    call gitgutter#hunk#increment_lines_added(a:bufnr, to_count - from_count)
-    call gitgutter#hunk#increment_lines_modified(a:bufnr, from_count)
-
-  elseif s:is_modified_and_removed(from_count, to_count)
-    call s:process_modified_and_removed(modifications, from_count, to_count, to_line)
-    call gitgutter#hunk#increment_lines_modified(a:bufnr, to_count)
-    call gitgutter#hunk#increment_lines_removed(a:bufnr, from_count - to_count)
-
-  endif
-  return modifications
-endfunction
-
-function! s:is_added(from_count, to_count) abort
-  return a:from_count == 0 && a:to_count > 0
-endfunction
-
-function! s:is_removed(from_count, to_count) abort
-  return a:from_count > 0 && a:to_count == 0
-endfunction
-
-function! s:is_modified(from_count, to_count) abort
-  return a:from_count > 0 && a:to_count > 0 && a:from_count == a:to_count
-endfunction
-
-function! s:is_modified_and_added(from_count, to_count) abort
-  return a:from_count > 0 && a:to_count > 0 && a:from_count < a:to_count
-endfunction
-
-function! s:is_modified_and_removed(from_count, to_count) abort
-  return a:from_count > 0 && a:to_count > 0 && a:from_count > a:to_count
-endfunction
-
-function! s:process_added(modifications, from_count, to_count, to_line) abort
-  let offset = 0
-  while offset < a:to_count
-    let line_number = a:to_line + offset
-    call add(a:modifications, [line_number, 'added'])
-    let offset += 1
-  endwhile
-endfunction
-
-function! s:process_removed(modifications, from_count, to_count, to_line) abort
-  if a:to_line == 0
-    call add(a:modifications, [1, 'removed_first_line'])
-  else
-    call add(a:modifications, [a:to_line, 'removed'])
-  endif
-endfunction
-
-function! s:process_modified(modifications, from_count, to_count, to_line) abort
-  let offset = 0
-  while offset < a:to_count
-    let line_number = a:to_line + offset
-    call add(a:modifications, [line_number, 'modified'])
-    let offset += 1
-  endwhile
-endfunction
-
-function! s:process_modified_and_added(modifications, from_count, to_count, to_line) abort
-  let offset = 0
-  while offset < a:from_count
-    let line_number = a:to_line + offset
-    call add(a:modifications, [line_number, 'modified'])
-    let offset += 1
-  endwhile
-  while offset < a:to_count
-    let line_number = a:to_line + offset
-    call add(a:modifications, [line_number, 'added'])
-    let offset += 1
-  endwhile
-endfunction
-
-function! s:process_modified_and_removed(modifications, from_count, to_count, to_line) abort
-  let offset = 0
-  while offset < a:to_count
-    let line_number = a:to_line + offset
-    call add(a:modifications, [line_number, 'modified'])
-    let offset += 1
-  endwhile
-  let a:modifications[-1] = [a:to_line + offset - 1, 'modified_removed']
-endfunction
-
-
-" Returns a diff for the current hunk.
-" Assumes there is only 1 current hunk unless the optional argument is given,
-" in which case the cursor is in two hunks and the argument specifies the one
-" to choose.
-"
-" Optional argument: 0 (to use the first hunk) or 1 (to use the second).
-function! gitgutter#diff#hunk_diff(bufnr, full_diff, ...)
-  let modified_diff = []
-  let hunk_index = 0
-  let keep_line = 1
-  " Don't keepempty when splitting because the diff we want may not be the
-  " final one.  Instead add trailing NL at end of function.
-  for line in split(a:full_diff, '\n')
-    let hunk_info = gitgutter#diff#parse_hunk(line)
-    if len(hunk_info) == 4  " start of new hunk
-      let keep_line = gitgutter#hunk#cursor_in_hunk(hunk_info)
-
-      if a:0 && hunk_index != a:1
-        let keep_line = 0
-      endif
-
-      let hunk_index += 1
-    endif
-    if keep_line
-      call add(modified_diff, line)
-    endif
-  endfor
-  return join(modified_diff, "\n")."\n"
-endfunction
-
-
-function! s:write_buffer(bufnr, file)
-  let bufcontents = getbufline(a:bufnr, 1, '$')
-
-  if bufcontents == [''] && line2byte(1) == -1
-    " Special case: completely empty buffer.
-    " A nearly empty buffer of only a newline has line2byte(1) == 1.
-    call writefile([], a:file)
-    return
-  endif
-
-  if getbufvar(a:bufnr, '&fileformat') ==# 'dos'
-    call map(bufcontents, 'v:val."\r"')
-  endif
-
-  if getbufvar(a:bufnr, '&endofline')
-    call add(bufcontents, '')
-  endif
-
-  let fenc = getbufvar(a:bufnr, '&fileencoding')
-  if fenc !=# &encoding
-    call map(bufcontents, 'iconv(v:val, &encoding, "'.fenc.'")')
-  endif
-
-  if getbufvar(a:bufnr, '&bomb')
-    let bufcontents[0]=''.bufcontents[0]
-  endif
-
-  call writefile(bufcontents, a:file, 'b')
-endfunction
-
-
-function! s:save_last_seen_change(bufnr) abort
-  call gitgutter#utility#setbufvar(a:bufnr, 'tick', getbufvar(a:bufnr, 'changedtick'))
-endfunction
diff --git a/sources_non_forked/vim-gitgutter/autoload/gitgutter/diff_highlight.vim b/sources_non_forked/vim-gitgutter/autoload/gitgutter/diff_highlight.vim
deleted file mode 100644
index ec21b44..0000000
--- a/sources_non_forked/vim-gitgutter/autoload/gitgutter/diff_highlight.vim
+++ /dev/null
@@ -1,225 +0,0 @@
-" This is the minimum number of characters required between regions of change
-" in a line.  It's somewhat arbitrary: higher values mean less visual busyness;
-" lower values mean more detail.
-let s:gap_between_regions = 5
-
-
-" Calculates the changed portions of lines.
-"
-" Based on:
-"
-" - diff-highlight (included with git)
-"   https://github.com/git/git/blob/master/contrib/diff-highlight/DiffHighlight.pm
-"
-" - Diff Strategies, Neil Fraser
-"   https://neil.fraser.name/writing/diff/
-
-
-" Returns a list of intra-line changed regions.
-" Each element is a list:
-"
-"   [
-"     line number (1-based),
-"     type ('+' or '-'),
-"     start column (1-based, inclusive),
-"     stop column (1-based, inclusive),
-"   ]
-"
-" Args:
-"   hunk_body - list of lines
-function! gitgutter#diff_highlight#process(hunk_body)
-  " Check whether we have the same number of lines added as removed.
-  let [removed, added] = [0, 0]
-  for line in a:hunk_body
-    if line[0] == '-'
-      let removed += 1
-    elseif line[0] == '+'
-      let added += 1
-    endif
-  endfor
-  if removed != added
-    return []
-  endif
-
-  let regions = []
-
-  for i in range(removed)
-    " pair lines by position
-    let rline = a:hunk_body[i]
-    let aline = a:hunk_body[i + removed]
-
-    call s:diff(rline, aline, i, i+removed, 0, 0, regions, 1)
-  endfor
-
-  return regions
-endfunction
-
-
-function! s:diff(rline, aline, rlinenr, alinenr, rprefix, aprefix, regions, whole_line)
-  " diff marker does not count as a difference in prefix
-  let start = a:whole_line ? 1 : 0
-  let prefix = s:common_prefix(a:rline[start:], a:aline[start:])
-  if a:whole_line
-    let prefix += 1
-  endif
-  let [rsuffix, asuffix] = s:common_suffix(a:rline, a:aline, prefix+1)
-
-  " region of change (common prefix and suffix removed)
-  let rtext = a:rline[prefix+1:rsuffix-1]
-  let atext = a:aline[prefix+1:asuffix-1]
-
-  " singular insertion
-  if empty(rtext)
-    if !a:whole_line || len(atext) != len(a:aline)  " not whole line
-      call add(a:regions, [a:alinenr+1, '+', a:aprefix+prefix+1+1, a:aprefix+asuffix+1-1])
-    endif
-    return
-  endif
-
-  " singular deletion
-  if empty(atext)
-    if !a:whole_line || len(rtext) != len(a:rline)  " not whole line
-      call add(a:regions, [a:rlinenr+1, '-', a:rprefix+prefix+1+1, a:rprefix+rsuffix+1-1])
-    endif
-    return
-  endif
-
-  " two insertions
-  let j = stridx(atext, rtext)
-  if j != -1
-    call add(a:regions, [a:alinenr+1, '+', a:aprefix+prefix+1+1, a:aprefix+prefix+j+1])
-    call add(a:regions, [a:alinenr+1, '+', a:aprefix+prefix+1+1+j+len(rtext), a:aprefix+asuffix+1-1])
-    return
-  endif
-
-  " two deletions
-  let j = stridx(rtext, atext)
-  if j != -1
-    call add(a:regions, [a:rlinenr+1, '-', a:rprefix+prefix+1+1, a:rprefix+prefix+j+1])
-    call add(a:regions, [a:rlinenr+1, '-', a:rprefix+prefix+1+1+j+len(atext), a:rprefix+rsuffix+1-1])
-    return
-  endif
-
-  " two edits
-  let lcs = s:lcs(rtext, atext)
-  " TODO do we need to ensure we don't get more than 2 elements when splitting?
-  if len(lcs) > s:gap_between_regions
-    let redits = s:split(rtext, lcs)
-    let aedits = s:split(atext, lcs)
-    call s:diff(redits[0], aedits[0], a:rlinenr, a:alinenr, a:rprefix+prefix+1,                         a:aprefix+prefix+1,                         a:regions, 0)
-    call s:diff(redits[1], aedits[1], a:rlinenr, a:alinenr, a:rprefix+prefix+1+len(redits[0])+len(lcs), a:aprefix+prefix+1+len(aedits[0])+len(lcs), a:regions, 0)
-    return
-  endif
-
-  " fall back to highlighting entire changed area
-
-  " if a change (but not the whole line)
-  if !a:whole_line || ((prefix != 0 || rsuffix != len(a:rline)) && prefix+1 < rsuffix)
-    call add(a:regions, [a:rlinenr+1, '-', a:rprefix+prefix+1+1, a:rprefix+rsuffix+1-1])
-  endif
-
-  " if a change (but not the whole line)
-  if !a:whole_line || ((prefix != 0 || asuffix != len(a:aline)) && prefix+1 < asuffix)
-    call add(a:regions, [a:alinenr+1, '+', a:aprefix+prefix+1+1, a:aprefix+asuffix+1-1])
-  endif
-endfunction
-
-
-function! s:lcs(s1, s2)
-  if empty(a:s1) || empty(a:s2)
-    return ''
-  endif
-
-  let matrix = map(repeat([repeat([0], len(a:s2)+1)], len(a:s1)+1), 'copy(v:val)')
-
-  let maxlength = 0
-  let endindex = len(a:s1)
-
-  for i in range(1, len(a:s1))
-    for j in range(1, len(a:s2))
-      if a:s1[i-1] ==# a:s2[j-1]
-        let matrix[i][j] = 1 + matrix[i-1][j-1]
-        if matrix[i][j] > maxlength
-          let maxlength = matrix[i][j]
-          let endindex = i - 1
-        endif
-      endif
-    endfor
-  endfor
-
-  return a:s1[endindex - maxlength + 1 : endindex]
-endfunction
-
-if $VIM_GITGUTTER_TEST
-  function! gitgutter#diff_highlight#lcs(s1, s2)
-    return s:lcs(a:s1, a:s2)
-  endfunction
-endif
-
-
-" Returns 0-based index of last character of common prefix
-" If there is no common prefix, returns -1.
-"
-" a, b - strings
-"
-function! s:common_prefix(a, b)
-  let len = min([len(a:a), len(a:b)])
-  if len == 0
-    return -1
-  endif
-  for i in range(len)
-    if a:a[i:i] != a:b[i:i]
-      return i - 1
-    endif
-  endfor
-  return i
-endfunction
-
-if $VIM_GITGUTTER_TEST
-  function! gitgutter#diff_highlight#common_prefix(a, b)
-    return s:common_prefix(a:a, a:b)
-  endfunction
-endif
-
-
-" Returns 0-based indices of start of common suffix
-"
-" a, b - strings
-" start - 0-based index to start from
-function! s:common_suffix(a, b, start)
-  let [sa, sb] = [len(a:a), len(a:b)]
-  while sa >= a:start && sb >= a:start
-    if a:a[sa] ==# a:b[sb]
-      let sa -= 1
-      let sb -= 1
-    else
-      break
-    endif
-  endwhile
-  return [sa+1, sb+1]
-endfunction
-
-if $VIM_GITGUTTER_TEST
-  function! gitgutter#diff_highlight#common_suffix(a, b, start)
-    return s:common_suffix(a:a, a:b, a:start)
-  endfunction
-endif
-
-
-" Split a string on another string.
-" Assumes 1 occurrence of the delimiter.
-function! s:split(str, delimiter)
-  let i = stridx(a:str, a:delimiter)
-
-  if i == 0
-    return ['', a:str[len(a:delimiter):]]
-  endif
-
-  return [a:str[:i-1], a:str[i+len(a:delimiter):]]
-endfunction
-
-if $VIM_GITGUTTER_TEST
-  function! gitgutter#diff_highlight#split(str, delimiter)
-    return s:split(a:str, a:delimiter)
-  endfunction
-endif
diff --git a/sources_non_forked/vim-gitgutter/autoload/gitgutter/fold.vim b/sources_non_forked/vim-gitgutter/autoload/gitgutter/fold.vim
deleted file mode 100644
index 4c1e30e..0000000
--- a/sources_non_forked/vim-gitgutter/autoload/gitgutter/fold.vim
+++ /dev/null
@@ -1,115 +0,0 @@
-function! gitgutter#fold#enable()
-  call s:save_fold_state()
-
-  call s:set_fold_levels()
-  setlocal foldexpr=gitgutter#fold#level(v:lnum)
-  setlocal foldmethod=expr
-  setlocal foldlevel=0
-  setlocal foldenable
-
-  call gitgutter#utility#setbufvar(bufnr(''), 'folded', 1)
-endfunction
-
-
-function! gitgutter#fold#disable()
-  call s:restore_fold_state()
-  call gitgutter#utility#setbufvar(bufnr(''), 'folded', 0)
-endfunction
-
-
-function! gitgutter#fold#toggle()
-  if s:folded()
-    call gitgutter#fold#disable()
-  else
-    call gitgutter#fold#enable()
-  endif
-endfunction
-
-
-function! gitgutter#fold#level(lnum)
-  return gitgutter#utility#getbufvar(bufnr(''), 'fold_levels')[a:lnum]
-endfunction
-
-
-function! gitgutter#fold#foldtext()
-  if !gitgutter#fold#is_changed()
-    return foldtext()
-  endif
-
-  return substitute(foldtext(), ':', ' (*):', '')
-endfunction
-
-
-" Returns 1 if any of the folded lines have been changed
-" (added, removed, or modified), 0 otherwise.
-function! gitgutter#fold#is_changed()
-  for hunk in gitgutter#hunk#hunks(bufnr(''))
-    let hunk_begin = hunk[2]
-    let hunk_end   = hunk[2] + (hunk[3] == 0 ? 1 : hunk[3])
-
-    if hunk_end < v:foldstart
-      continue
-    endif
-
-    if hunk_begin > v:foldend
-      break
-    endif
-
-    return 1
-  endfor
-
-  return 0
-endfunction
-
-
-" A line in a hunk has a fold level of 0.
-" A line within 3 lines of a hunk has a fold level of 1.
-" All other lines have a fold level of 2.
-function! s:set_fold_levels()
-  let fold_levels = ['']
-
-  for lnum in range(1, line('$'))
-    let in_hunk = gitgutter#hunk#in_hunk(lnum)
-    call add(fold_levels, (in_hunk ? 0 : 2))
-  endfor
-
-  let lines_of_context = 3
-
-  for lnum in range(1, line('$'))
-    if fold_levels[lnum] == 2
-      let pre = lnum >= 3 ? lnum - lines_of_context : 0
-      let post = lnum + lines_of_context
-      if index(fold_levels[pre:post], 0) != -1
-        let fold_levels[lnum] = 1
-      endif
-    endif
-  endfor
-
-  call gitgutter#utility#setbufvar(bufnr(''), 'fold_levels', fold_levels)
-endfunction
-
-
-function! s:save_fold_state()
-  let bufnr = bufnr('')
-  call gitgutter#utility#setbufvar(bufnr, 'foldlevel', &foldlevel)
-  call gitgutter#utility#setbufvar(bufnr, 'foldmethod', &foldmethod)
-  if &foldmethod ==# 'manual'
-    mkview
-  endif
-endfunction
-
-function! s:restore_fold_state()
-  let bufnr = bufnr('')
-  let &foldlevel = gitgutter#utility#getbufvar(bufnr, 'foldlevel')
-  let &foldmethod = gitgutter#utility#getbufvar(bufnr, 'foldmethod')
-  if &foldmethod ==# 'manual'
-    loadview
-  else
-    normal! zx
-  endif
-endfunction
-
-function! s:folded()
-  return gitgutter#utility#getbufvar(bufnr(''), 'folded')
-endfunction
-
diff --git a/sources_non_forked/vim-gitgutter/autoload/gitgutter/highlight.vim b/sources_non_forked/vim-gitgutter/autoload/gitgutter/highlight.vim
deleted file mode 100644
index 1439b72..0000000
--- a/sources_non_forked/vim-gitgutter/autoload/gitgutter/highlight.vim
+++ /dev/null
@@ -1,245 +0,0 @@
-function! gitgutter#highlight#line_disable() abort
-  let g:gitgutter_highlight_lines = 0
-  call s:define_sign_line_highlights()
-
-  if !g:gitgutter_signs
-    call gitgutter#sign#clear_signs(bufnr(''))
-  endif
-
-  redraw!
-endfunction
-
-function! gitgutter#highlight#line_enable() abort
-  let old_highlight_lines = g:gitgutter_highlight_lines
-
-  let g:gitgutter_highlight_lines = 1
-  call s:define_sign_line_highlights()
-
-  if !old_highlight_lines && !g:gitgutter_signs
-    call gitgutter#all(1)
-  endif
-
-  redraw!
-endfunction
-
-function! gitgutter#highlight#line_toggle() abort
-  if g:gitgutter_highlight_lines
-    call gitgutter#highlight#line_disable()
-  else
-    call gitgutter#highlight#line_enable()
-  endif
-endfunction
-
-
-function! gitgutter#highlight#linenr_disable() abort
-  let g:gitgutter_highlight_linenrs = 0
-  call s:define_sign_linenr_highlights()
-
-  if !g:gitgutter_signs
-    call gitgutter#sign#clear_signs(bufnr(''))
-  endif
-
-  redraw!
-endfunction
-
-function! gitgutter#highlight#linenr_enable() abort
-  let old_highlight_linenrs = g:gitgutter_highlight_linenrs
-
-  let g:gitgutter_highlight_linenrs = 1
-  call s:define_sign_linenr_highlights()
-
-  if !old_highlight_linenrs && !g:gitgutter_signs
-    call gitgutter#all(1)
-  endif
-
-  redraw!
-endfunction
-
-function! gitgutter#highlight#linenr_toggle() abort
-  if g:gitgutter_highlight_linenrs
-    call gitgutter#highlight#linenr_disable()
-  else
-    call gitgutter#highlight#linenr_enable()
-  endif
-endfunction
-
-
-function! gitgutter#highlight#define_highlights() abort
-  let [guibg, ctermbg] = s:get_background_colors('SignColumn')
-
-  " Highlights used by the signs.
-
-  " When they are invisible.
-  execute "highlight GitGutterAddInvisible    guifg=bg guibg=" . guibg . " ctermfg=" . ctermbg . " ctermbg=" . ctermbg
-  execute "highlight GitGutterChangeInvisible guifg=bg guibg=" . guibg . " ctermfg=" . ctermbg . " ctermbg=" . ctermbg
-  execute "highlight GitGutterDeleteInvisible guifg=bg guibg=" . guibg . " ctermfg=" . ctermbg . " ctermbg=" . ctermbg
-  highlight default link GitGutterChangeDeleteInvisible GitGutterChangeInvisible
-
-  " When they are visible.
-  for type in ["Add", "Change", "Delete"]
-    if hlexists("GitGutter".type)
-      if g:gitgutter_set_sign_backgrounds
-        execute "highlight GitGutter".type." guibg=".guibg." ctermbg=".ctermbg
-      endif
-      continue
-    elseif s:useful_diff_colours()
-      let [guifg, ctermfg] = s:get_foreground_colors('Diff'.type)
-    else
-      let [guifg, ctermfg] = s:get_foreground_fallback_colors(type)
-    endif
-    execute "highlight GitGutter".type." guifg=".guifg." guibg=".guibg." ctermfg=".ctermfg." ctermbg=".ctermbg
-  endfor
-
-  if hlexists("GitGutterChangeDelete") && g:gitgutter_set_sign_backgrounds
-    execute "highlight GitGutterChangeDelete guibg=".guibg." ctermbg=".ctermbg
-  endif
-
-  highlight default link GitGutterChangeDelete GitGutterChange
-
-  " Highlights used for the whole line.
-
-  highlight default link GitGutterAddLine          DiffAdd
-  highlight default link GitGutterChangeLine       DiffChange
-  highlight default link GitGutterDeleteLine       DiffDelete
-  highlight default link GitGutterChangeDeleteLine GitGutterChangeLine
-
-  highlight default link GitGutterAddLineNr          CursorLineNr
-  highlight default link GitGutterChangeLineNr       CursorLineNr
-  highlight default link GitGutterDeleteLineNr       CursorLineNr
-  highlight default link GitGutterChangeDeleteLineNr CursorLineNr
-
-  " Highlights used intra line.
-  highlight GitGutterAddIntraLine    gui=reverse cterm=reverse
-  highlight GitGutterDeleteIntraLine gui=reverse cterm=reverse
-  " Set diff syntax colours (used in the preview window) - diffAdded,diffChanged,diffRemoved -
-  " to match the signs, if not set aleady.
-  for [dtype,type] in [['Added','Add'], ['Changed','Change'], ['Removed','Delete']]
-    if !hlexists('diff'.dtype)
-      let [guifg, ctermfg] = s:get_foreground_colors('GitGutter'.type)
-      execute "highlight diff".dtype." guifg=".guifg." ctermfg=".ctermfg." guibg=NONE ctermbg=NONE"
-    endif
-  endfor
-endfunction
-
-function! gitgutter#highlight#define_signs() abort
-  sign define GitGutterLineAdded
-  sign define GitGutterLineModified
-  sign define GitGutterLineRemoved
-  sign define GitGutterLineRemovedFirstLine
-  sign define GitGutterLineRemovedAboveAndBelow
-  sign define GitGutterLineModifiedRemoved
-
-  call s:define_sign_text()
-  call gitgutter#highlight#define_sign_text_highlights()
-  call s:define_sign_line_highlights()
-  call s:define_sign_linenr_highlights()
-endfunction
-
-function! s:define_sign_text() abort
-  execute "sign define GitGutterLineAdded                 text=" . g:gitgutter_sign_added
-  execute "sign define GitGutterLineModified              text=" . g:gitgutter_sign_modified
-  execute "sign define GitGutterLineRemoved               text=" . g:gitgutter_sign_removed
-  execute "sign define GitGutterLineRemovedFirstLine      text=" . g:gitgutter_sign_removed_first_line
-  execute "sign define GitGutterLineRemovedAboveAndBelow  text=" . g:gitgutter_sign_removed_above_and_below
-  execute "sign define GitGutterLineModifiedRemoved       text=" . g:gitgutter_sign_modified_removed
-endfunction
-
-function! gitgutter#highlight#define_sign_text_highlights() abort
-  " Once a sign's text attribute has been defined, it cannot be undefined or
-  " set to an empty value.  So to make signs' text disappear (when toggling
-  " off or disabling) we make them invisible by setting their foreground colours
-  " to the background's.
-  if g:gitgutter_signs
-    sign define GitGutterLineAdded                 texthl=GitGutterAdd
-    sign define GitGutterLineModified              texthl=GitGutterChange
-    sign define GitGutterLineRemoved               texthl=GitGutterDelete
-    sign define GitGutterLineRemovedFirstLine      texthl=GitGutterDelete
-    sign define GitGutterLineRemovedAboveAndBelow  texthl=GitGutterDelete
-    sign define GitGutterLineModifiedRemoved       texthl=GitGutterChangeDelete
-  else
-    sign define GitGutterLineAdded                 texthl=GitGutterAddInvisible
-    sign define GitGutterLineModified              texthl=GitGutterChangeInvisible
-    sign define GitGutterLineRemoved               texthl=GitGutterDeleteInvisible
-    sign define GitGutterLineRemovedFirstLine      texthl=GitGutterDeleteInvisible
-    sign define GitGutterLineRemovedAboveAndBelow  texthl=GitGutterDeleteInvisible
-    sign define GitGutterLineModifiedRemoved       texthl=GitGutterChangeDeleteInvisible
-  endif
-endfunction
-
-function! s:define_sign_line_highlights() abort
-  if g:gitgutter_highlight_lines
-    sign define GitGutterLineAdded                 linehl=GitGutterAddLine
-    sign define GitGutterLineModified              linehl=GitGutterChangeLine
-    sign define GitGutterLineRemoved               linehl=GitGutterDeleteLine
-    sign define GitGutterLineRemovedFirstLine      linehl=GitGutterDeleteLine
-    sign define GitGutterLineRemovedAboveAndBelow  linehl=GitGutterDeleteLine
-    sign define GitGutterLineModifiedRemoved       linehl=GitGutterChangeDeleteLine
-  else
-    sign define GitGutterLineAdded                 linehl=
-    sign define GitGutterLineModified              linehl=
-    sign define GitGutterLineRemoved               linehl=
-    sign define GitGutterLineRemovedFirstLine      linehl=
-    sign define GitGutterLineRemovedAboveAndBelow  linehl=
-    sign define GitGutterLineModifiedRemoved       linehl=
-  endif
-endfunction
-
-function! s:define_sign_linenr_highlights() abort
-  if has('nvim-0.3.2')
-    try
-      if g:gitgutter_highlight_linenrs
-        sign define GitGutterLineAdded                 numhl=GitGutterAddLineNr
-        sign define GitGutterLineModified              numhl=GitGutterChangeLineNr
-        sign define GitGutterLineRemoved               numhl=GitGutterDeleteLineNr
-        sign define GitGutterLineRemovedFirstLine      numhl=GitGutterDeleteLineNr
-        sign define GitGutterLineRemovedAboveAndBelow  numhl=GitGutterDeleteLineNr
-        sign define GitGutterLineModifiedRemoved       numhl=GitGutterChangeDeleteLineNr
-      else
-        sign define GitGutterLineAdded                 numhl=
-        sign define GitGutterLineModified              numhl=
-        sign define GitGutterLineRemoved               numhl=
-        sign define GitGutterLineRemovedFirstLine      numhl=
-        sign define GitGutterLineRemovedAboveAndBelow  numhl=
-        sign define GitGutterLineModifiedRemoved       numhl=
-      endif
-    catch /E475/
-    endtry
-  endif
-endfunction
-
-function! s:get_hl(group, what, mode) abort
-  let r = synIDattr(synIDtrans(hlID(a:group)), a:what, a:mode)
-  if empty(r) || r == -1
-    return 'NONE'
-  endif
-  return r
-endfunction
-
-function! s:get_foreground_colors(group) abort
-  let ctermfg = s:get_hl(a:group, 'fg', 'cterm')
-  let guifg = s:get_hl(a:group, 'fg', 'gui')
-  return [guifg, ctermfg]
-endfunction
-
-function! s:get_background_colors(group) abort
-  let ctermbg = s:get_hl(a:group, 'bg', 'cterm')
-  let guibg = s:get_hl(a:group, 'bg', 'gui')
-  return [guibg, ctermbg]
-endfunction
-
-function! s:useful_diff_colours()
-  let [guifg_add, ctermfg_add] = s:get_foreground_colors('DiffAdd')
-  let [guifg_del, ctermfg_del] = s:get_foreground_colors('DiffDelete')
-
-  return guifg_add != guifg_del && ctermfg_add != ctermfg_del
-endfunction
-
-function! s:get_foreground_fallback_colors(type)
-  if a:type == 'Add'
-    return ['#009900', '2']
-  elseif a:type == 'Change'
-    return ['#bbbb00', '3']
-  elseif a:type == 'Delete'
-    return ['#ff2222', '1']
-  endif
-endfunction
diff --git a/sources_non_forked/vim-gitgutter/autoload/gitgutter/hunk.vim b/sources_non_forked/vim-gitgutter/autoload/gitgutter/hunk.vim
deleted file mode 100644
index f80e93a..0000000
--- a/sources_non_forked/vim-gitgutter/autoload/gitgutter/hunk.vim
+++ /dev/null
@@ -1,556 +0,0 @@
-let s:winid = 0
-let s:preview_bufnr = 0
-let s:nomodeline = (v:version > 703 || (v:version == 703 && has('patch442'))) ? '<nomodeline>' : ''
-
-function! gitgutter#hunk#set_hunks(bufnr, hunks) abort
-  call gitgutter#utility#setbufvar(a:bufnr, 'hunks', a:hunks)
-  call s:reset_summary(a:bufnr)
-endfunction
-
-function! gitgutter#hunk#hunks(bufnr) abort
-  return gitgutter#utility#getbufvar(a:bufnr, 'hunks', [])
-endfunction
-
-function! gitgutter#hunk#reset(bufnr) abort
-  call gitgutter#utility#setbufvar(a:bufnr, 'hunks', [])
-  call s:reset_summary(a:bufnr)
-endfunction
-
-
-function! gitgutter#hunk#summary(bufnr) abort
-  return gitgutter#utility#getbufvar(a:bufnr, 'summary', [0,0,0])
-endfunction
-
-function! s:reset_summary(bufnr) abort
-  call gitgutter#utility#setbufvar(a:bufnr, 'summary', [0,0,0])
-endfunction
-
-function! gitgutter#hunk#increment_lines_added(bufnr, count) abort
-  let summary = gitgutter#hunk#summary(a:bufnr)
-  let summary[0] += a:count
-  call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)
-endfunction
-
-function! gitgutter#hunk#increment_lines_modified(bufnr, count) abort
-  let summary = gitgutter#hunk#summary(a:bufnr)
-  let summary[1] += a:count
-  call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)
-endfunction
-
-function! gitgutter#hunk#increment_lines_removed(bufnr, count) abort
-  let summary = gitgutter#hunk#summary(a:bufnr)
-  let summary[2] += a:count
-  call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)
-endfunction
-
-
-function! gitgutter#hunk#next_hunk(count) abort
-  let bufnr = bufnr('')
-  if gitgutter#utility#is_active(bufnr)
-    let current_line = line('.')
-    let hunk_count = 0
-    for hunk in gitgutter#hunk#hunks(bufnr)
-      if hunk[2] > current_line
-        let hunk_count += 1
-        if hunk_count == a:count
-          execute 'normal!' hunk[2] . 'Gzv'
-          return
-        endif
-      endif
-    endfor
-    call gitgutter#utility#warn('No more hunks')
-  endif
-endfunction
-
-function! gitgutter#hunk#prev_hunk(count) abort
-  let bufnr = bufnr('')
-  if gitgutter#utility#is_active(bufnr)
-    let current_line = line('.')
-    let hunk_count = 0
-    for hunk in reverse(copy(gitgutter#hunk#hunks(bufnr)))
-      if hunk[2] < current_line
-        let hunk_count += 1
-        if hunk_count == a:count
-          let target = hunk[2] == 0 ? 1 : hunk[2]
-          execute 'normal!' target . 'Gzv'
-          return
-        endif
-      endif
-    endfor
-    call gitgutter#utility#warn('No previous hunks')
-  endif
-endfunction
-
-" Returns the hunk the cursor is currently in or an empty list if the cursor
-" isn't in a hunk.
-function! s:current_hunk() abort
-  let bufnr = bufnr('')
-  let current_hunk = []
-
-  for hunk in gitgutter#hunk#hunks(bufnr)
-    if gitgutter#hunk#cursor_in_hunk(hunk)
-      let current_hunk = hunk
-      break
-    endif
-  endfor
-
-  return current_hunk
-endfunction
-
-" Returns truthy if the cursor is in two hunks (which can only happen if the
-" cursor is on the first line and lines above have been deleted and lines
-" immediately below have been deleted) or falsey otherwise.
-function! s:cursor_in_two_hunks()
-  let hunks = gitgutter#hunk#hunks(bufnr(''))
-
-  if line('.') == 1 && len(hunks) > 1 && hunks[0][2:3] == [0, 0] && hunks[1][2:3] == [1, 0]
-    return 1
-  endif
-
-  return 0
-endfunction
-
-" A line can be in 0 or 1 hunks, with the following exception: when the first
-" line(s) of a file has been deleted, and the new second line (and
-" optionally below) has been deleted, the new first line is in two hunks.
-function! gitgutter#hunk#cursor_in_hunk(hunk) abort
-  let current_line = line('.')
-
-  if current_line == 1 && a:hunk[2] == 0
-    return 1
-  endif
-
-  if current_line >= a:hunk[2] && current_line < a:hunk[2] + (a:hunk[3] == 0 ? 1 : a:hunk[3])
-    return 1
-  endif
-
-  return 0
-endfunction
-
-
-function! gitgutter#hunk#in_hunk(lnum)
-  " Hunks are sorted in the order they appear in the buffer.
-  for hunk in gitgutter#hunk#hunks(bufnr(''))
-    " if in a hunk on first line of buffer
-    if a:lnum == 1 && hunk[2] == 0
-      return 1
-    endif
-
-    " if in a hunk generally
-    if a:lnum >= hunk[2] && a:lnum < hunk[2] + (hunk[3] == 0 ? 1 : hunk[3])
-      return 1
-    endif
-
-    " if hunk starts after the given line
-    if a:lnum < hunk[2]
-      return 0
-    endif
-  endfor
-
-  return 0
-endfunction
-
-
-function! gitgutter#hunk#text_object(inner) abort
-  let hunk = s:current_hunk()
-
-  if empty(hunk)
-    return
-  endif
-
-  let [first_line, last_line] = [hunk[2], hunk[2] + hunk[3] - 1]
-
-  if ! a:inner
-    let lnum = last_line
-    let eof = line('$')
-    while lnum < eof && empty(getline(lnum + 1))
-      let lnum +=1
-    endwhile
-    let last_line = lnum
-  endif
-
-  execute 'normal! 'first_line.'GV'.last_line.'G'
-endfunction
-
-
-function! gitgutter#hunk#stage(...) abort
-  if !s:in_hunk_preview_window() && !gitgutter#utility#has_repo_path(bufnr('')) | return | endif
-
-  if a:0 && (a:1 != 1 || a:2 != line('$'))
-    call s:hunk_op(function('s:stage'), a:1, a:2)
-  else
-    call s:hunk_op(function('s:stage'))
-  endif
-  silent! call repeat#set("\<Plug>(GitGutterStageHunk)", -1)
-endfunction
-
-function! gitgutter#hunk#undo() abort
-  if !gitgutter#utility#has_repo_path(bufnr('')) | return | endif
-
-  call s:hunk_op(function('s:undo'))
-  silent! call repeat#set("\<Plug>(GitGutterUndoHunk)", -1)
-endfunction
-
-function! gitgutter#hunk#preview() abort
-  if !gitgutter#utility#has_repo_path(bufnr('')) | return | endif
-
-  call s:hunk_op(function('s:preview'))
-  silent! call repeat#set("\<Plug>(GitGutterPreviewHunk)", -1)
-endfunction
-
-
-function! s:hunk_op(op, ...)
-  let bufnr = bufnr('')
-
-  if s:in_hunk_preview_window()
-    if string(a:op) =~ '_stage'
-      " combine hunk-body in preview window with updated hunk-header
-      let hunk_body = getline(1, '$')
-
-      let [removed, added] = [0, 0]
-      for line in hunk_body
-        if line[0] == '-'
-          let removed += 1
-        elseif line[0] == '+'
-          let added += 1
-        endif
-      endfor
-
-      let hunk_header = b:hunk_header
-      " from count
-      let hunk_header[4] = substitute(hunk_header[4], '\(-\d\+\)\(,\d\+\)\?', '\=submatch(1).",".removed', '')
-      " to count
-      let hunk_header[4] = substitute(hunk_header[4], '\(+\d\+\)\(,\d\+\)\?', '\=submatch(1).",".added', '')
-
-      let hunk_diff = join(hunk_header + hunk_body, "\n")."\n"
-
-      call s:goto_original_window()
-      call s:close_hunk_preview_window()
-      call s:stage(hunk_diff)
-    endif
-
-    return
-  endif
-
-  if gitgutter#utility#is_active(bufnr)
-    " Get a (synchronous) diff.
-    let [async, g:gitgutter_async] = [g:gitgutter_async, 0]
-    let diff = gitgutter#diff#run_diff(bufnr, g:gitgutter_diff_relative_to, 1)
-    let g:gitgutter_async = async
-
-    call gitgutter#hunk#set_hunks(bufnr, gitgutter#diff#parse_diff(diff))
-
-    if empty(s:current_hunk())
-      call gitgutter#utility#warn('cursor is not in a hunk')
-    elseif s:cursor_in_two_hunks()
-      let choice = input('Choose hunk: upper or lower (u/l)? ')
-      " Clear input
-      normal! :<ESC>
-      if choice =~ 'u'
-        call a:op(gitgutter#diff#hunk_diff(bufnr, diff, 0))
-      elseif choice =~ 'l'
-        call a:op(gitgutter#diff#hunk_diff(bufnr, diff, 1))
-      else
-        call gitgutter#utility#warn('did not recognise your choice')
-      endif
-    else
-      let hunk_diff = gitgutter#diff#hunk_diff(bufnr, diff)
-
-      if a:0
-        let hunk_first_line = s:current_hunk()[2]
-        let hunk_diff = s:part_of_diff(hunk_diff, a:1-hunk_first_line, a:2-hunk_first_line)
-      endif
-
-      call a:op(hunk_diff)
-    endif
-  endif
-endfunction
-
-
-function! s:stage(hunk_diff)
-  let bufnr = bufnr('')
-  let diff = s:adjust_header(bufnr, a:hunk_diff)
-  " Apply patch to index.
-  call gitgutter#utility#system(
-        \ gitgutter#utility#cd_cmd(bufnr, g:gitgutter_git_executable.' '.g:gitgutter_git_args.' apply --cached --unidiff-zero - '),
-        \ diff)
-  if v:shell_error
-    call gitgutter#utility#warn('patch does not apply')
-  else
-    if exists('#User#GitGutterStage')
-      execute 'doautocmd' s:nomodeline 'User GitGutterStage'
-    endif
-  endif
-
-  " Refresh gitgutter's view of buffer.
-  call gitgutter#process_buffer(bufnr, 1)
-endfunction
-
-
-function! s:undo(hunk_diff)
-  " Apply reverse patch to buffer.
-  let hunk  = gitgutter#diff#parse_hunk(split(a:hunk_diff, '\n')[4])
-  let lines = map(split(a:hunk_diff, '\r\?\n')[5:], 'v:val[1:]')
-  let lnum  = hunk[2]
-  let added_only   = hunk[1] == 0 && hunk[3]  > 0
-  let removed_only = hunk[1]  > 0 && hunk[3] == 0
-
-  if removed_only
-    call append(lnum, lines)
-  elseif added_only
-    execute lnum .','. (lnum+len(lines)-1) .'d _'
-  else
-    call append(lnum-1, lines[0:hunk[1]])
-    execute (lnum+hunk[1]) .','. (lnum+hunk[1]+hunk[3]) .'d _'
-  endif
-endfunction
-
-
-function! s:preview(hunk_diff)
-  let lines = split(a:hunk_diff, '\r\?\n')
-  let header = lines[0:4]
-  let body = lines[5:]
-
-  call s:open_hunk_preview_window()
-  call s:populate_hunk_preview_window(header, body)
-  call s:enable_staging_from_hunk_preview_window()
-  if &previewwindow
-    call s:goto_original_window()
-  endif
-endfunction
-
-
-" Returns a new hunk diff using the specified lines from the given one.
-" Assumes all lines are additions.
-" a:first, a:last - 0-based indexes into the body of the hunk.
-function! s:part_of_diff(hunk_diff, first, last)
-  let diff_lines = split(a:hunk_diff, '\n', 1)
-
-  " adjust 'to' line count in header
-  let diff_lines[4] = substitute(diff_lines[4], '\(+\d\+\)\(,\d\+\)\?', '\=submatch(1).",".(a:last-a:first+1)', '')
-
-  return join(diff_lines[0:4] + diff_lines[5+a:first:5+a:last], "\n")."\n"
-endfunction
-
-
-function! s:adjust_header(bufnr, hunk_diff)
-  let filepath = gitgutter#utility#repo_path(a:bufnr, 0)
-  return s:adjust_hunk_summary(s:fix_file_references(filepath, a:hunk_diff))
-endfunction
-
-
-" Replaces references to temp files with the actual file.
-function! s:fix_file_references(filepath, hunk_diff)
-  let lines = split(a:hunk_diff, '\n')
-
-  let left_prefix  = matchstr(lines[2], '[abciow12]').'/'
-  let right_prefix = matchstr(lines[3], '[abciow12]').'/'
-  let quote        = lines[0][11] == '"' ? '"' : ''
-
-  let left_file  = quote.left_prefix.a:filepath.quote
-  let right_file = quote.right_prefix.a:filepath.quote
-
-  let lines[0] = 'diff --git '.left_file.' '.right_file
-  let lines[2] = '--- '.left_file
-  let lines[3] = '+++ '.right_file
-
-  return join(lines, "\n")."\n"
-endfunction
-
-if $VIM_GITGUTTER_TEST
-  function! gitgutter#hunk#fix_file_references(filepath, hunk_diff)
-    return s:fix_file_references(a:filepath, a:hunk_diff)
-  endfunction
-endif
-
-
-function! s:adjust_hunk_summary(hunk_diff) abort
-  let line_adjustment = s:line_adjustment_for_current_hunk()
-  let diff = split(a:hunk_diff, '\n', 1)
-  let diff[4] = substitute(diff[4], '+\zs\(\d\+\)', '\=submatch(1)+line_adjustment', '')
-  return join(diff, "\n")
-endfunction
-
-
-" Returns the number of lines the current hunk is offset from where it would
-" be if any changes above it in the file didn't exist.
-function! s:line_adjustment_for_current_hunk() abort
-  let bufnr = bufnr('')
-  let adj = 0
-  for hunk in gitgutter#hunk#hunks(bufnr)
-    if gitgutter#hunk#cursor_in_hunk(hunk)
-      break
-    else
-      let adj += hunk[1] - hunk[3]
-    endif
-  endfor
-  return adj
-endfunction
-
-
-function! s:in_hunk_preview_window()
-  if g:gitgutter_preview_win_floating
-    return win_id2win(s:winid) == winnr()
-  else
-    return &previewwindow
-  endif
-endfunction
-
-
-" Floating window: does not move cursor to floating window.
-" Preview window: moves cursor to preview window.
-function! s:open_hunk_preview_window()
-  if g:gitgutter_preview_win_floating
-    if exists('*nvim_open_win')
-      call s:close_hunk_preview_window()
-
-      let buf = nvim_create_buf(v:false, v:false)
-      " Set default width and height for now.
-      let s:winid = nvim_open_win(buf, v:false, {
-            \ 'relative': 'cursor',
-            \ 'row': 1,
-            \ 'col': 0,
-            \ 'width': 42,
-            \ 'height': &previewheight,
-            \ 'style': 'minimal'
-            \ })
-      call nvim_buf_set_option(buf, 'filetype',  'diff')
-      call nvim_buf_set_option(buf, 'buftype',   'acwrite')
-      call nvim_buf_set_option(buf, 'bufhidden', 'delete')
-      call nvim_buf_set_option(buf, 'swapfile',  v:false)
-      call nvim_buf_set_name(buf, 'gitgutter://hunk-preview')
-
-      " Assumes cursor is in original window.
-      autocmd CursorMoved <buffer> ++once call s:close_hunk_preview_window()
-
-      return
-    endif
-
-    if exists('*popup_create')
-      let s:winid = popup_create('', {
-            \ 'line': 'cursor+1',
-            \ 'col': 'cursor',
-            \ 'moved': 'any',
-            \ })
-
-      call setbufvar(winbufnr(s:winid), '&filetype', 'diff')
-
-      return
-    endif
-  endif
-
-  silent! wincmd P
-  if &previewwindow
-    file gitgutter://hunk-preview
-  else
-    noautocmd execute g:gitgutter_preview_win_location &previewheight 'new gitgutter://hunk-preview'
-    doautocmd WinEnter
-    set previewwindow
-  endif
-  if exists('*win_getid')
-    let s:winid = win_getid()
-  else
-    let s:preview_bufnr = bufnr('')
-  endif
-  setlocal filetype=diff buftype=acwrite bufhidden=delete
-  " Reset some defaults in case someone else has changed them.
-  setlocal noreadonly modifiable noswapfile
-endfunction
-
-
-" Floating window: does not care where cursor is.
-" Preview window: assumes cursor is in preview window.
-function! s:populate_hunk_preview_window(header, body)
-  let body_length = len(a:body)
-
-  if g:gitgutter_preview_win_floating
-    if exists('*nvim_open_win')
-      let height = min([body_length, &previewheight])
-
-      " Assumes cursor is not in previewing window.
-      call nvim_buf_set_var(winbufnr(s:winid), 'hunk_header', a:header)
-
-      let [_scrolloff, &scrolloff] = [&scrolloff, 0]
-
-      let width = max(map(copy(a:body), 'strdisplaywidth(v:val)'))
-      call nvim_win_set_width(s:winid, width)
-      call nvim_win_set_height(s:winid, height)
-
-      let &scrolloff=_scrolloff
-
-      call nvim_buf_set_lines(winbufnr(s:winid), 0, -1, v:false, [])
-      call nvim_buf_set_lines(winbufnr(s:winid), 0, -1, v:false, a:body)
-      call nvim_buf_set_option(winbufnr(s:winid), 'modified', v:false)
-
-      let ns_id = nvim_create_namespace('GitGutter')
-      call nvim_buf_clear_namespace(winbufnr(s:winid), ns_id, 0, -1)
-      for region in gitgutter#diff_highlight#process(a:body)
-        let group = region[1] == '+' ? 'GitGutterAddIntraLine' : 'GitGutterDeleteIntraLine'
-        call nvim_buf_add_highlight(winbufnr(s:winid), ns_id, group, region[0]-1, region[2]-1, region[3])
-      endfor
-
-      call nvim_win_set_cursor(s:winid, [1,0])
-    endif
-
-    if exists('*popup_create')
-      call popup_settext(s:winid, a:body)
-
-      for region in gitgutter#diff_highlight#process(a:body)
-        let group = region[1] == '+' ? 'GitGutterAddIntraLine' : 'GitGutterDeleteIntraLine'
-        call win_execute(s:winid, "call matchaddpos('".group."', [[".region[0].", ".region[2].", ".(region[3]-region[2]+1)."]])")
-      endfor
-    endif
-
-  else
-    let b:hunk_header = a:header
-
-    %delete _
-    call setline(1, a:body)
-    setlocal nomodified
-
-    normal! G$
-    let height = min([winline(), &previewheight])
-    execute 'resize' height
-    1
-
-    call clearmatches()
-    for region in gitgutter#diff_highlight#process(a:body)
-      let group = region[1] == '+' ? 'GitGutterAddIntraLine' : 'GitGutterDeleteIntraLine'
-      call matchaddpos(group, [[region[0], region[2], region[3]-region[2]+1]])
-    endfor
-
-    1
-  endif
-endfunction
-
-
-function! s:enable_staging_from_hunk_preview_window()
-  augroup gitgutter_hunk_preview
-    autocmd!
-    let bufnr = s:winid != 0 ? winbufnr(s:winid) : s:preview_bufnr
-    execute 'autocmd BufWriteCmd <buffer='.bufnr.'> GitGutterStageHunk'
-  augroup END
-endfunction
-
-
-function! s:goto_original_window()
-  noautocmd wincmd p
-  doautocmd WinEnter
-endfunction
-
-
-function! s:close_hunk_preview_window()
-  let bufnr = s:winid != 0 ? winbufnr(s:winid) : s:preview_bufnr
-  call setbufvar(bufnr, '&modified', 0)
-
-  if g:gitgutter_preview_win_floating
-    if win_id2win(s:winid) > 0
-      execute win_id2win(s:winid).'wincmd c'
-    endif
-  else
-    pclose
-  endif
-
-  let s:winid = 0
-  let s:preview_bufnr = 0
-endfunction
diff --git a/sources_non_forked/vim-gitgutter/autoload/gitgutter/sign.vim b/sources_non_forked/vim-gitgutter/autoload/gitgutter/sign.vim
deleted file mode 100644
index 4fc0296..0000000
--- a/sources_non_forked/vim-gitgutter/autoload/gitgutter/sign.vim
+++ /dev/null
@@ -1,250 +0,0 @@
-" For older Vims without sign_place() the plugin has to manaage the sign ids.
-let s:first_sign_id = 3000
-let s:next_sign_id  = s:first_sign_id
-" Remove-all-signs optimisation requires Vim 7.3.596+.
-let s:supports_star = v:version > 703 || (v:version == 703 && has("patch596"))
-
-
-function! gitgutter#sign#enable() abort
-  let old_signs = g:gitgutter_signs
-
-  let g:gitgutter_signs = 1
-  call gitgutter#highlight#define_sign_text_highlights()
-
-  if !old_signs && !g:gitgutter_highlight_lines && !g:gitgutter_highlight_linenrs
-    call gitgutter#all(1)
-  endif
-endfunction
-
-function! gitgutter#sign#disable() abort
-  let g:gitgutter_signs = 0
-  call gitgutter#highlight#define_sign_text_highlights()
-
-  if !g:gitgutter_highlight_lines && !g:gitgutter_highlight_linenrs
-    call gitgutter#sign#clear_signs(bufnr(''))
-  endif
-endfunction
-
-function! gitgutter#sign#toggle() abort
-  if g:gitgutter_signs
-    call gitgutter#sign#disable()
-  else
-    call gitgutter#sign#enable()
-  endif
-endfunction
-
-
-" Removes gitgutter's signs from the buffer being processed.
-function! gitgutter#sign#clear_signs(bufnr) abort
-  if exists('*sign_unplace')
-    call sign_unplace('gitgutter', {'buffer': a:bufnr})
-    return
-  endif
-
-
-  call s:find_current_signs(a:bufnr)
-
-  let sign_ids = map(values(gitgutter#utility#getbufvar(a:bufnr, 'gitgutter_signs')), 'v:val.id')
-  call s:remove_signs(a:bufnr, sign_ids, 1)
-  call gitgutter#utility#setbufvar(a:bufnr, 'gitgutter_signs', {})
-endfunction
-
-
-" Updates gitgutter's signs in the buffer being processed.
-"
-" modified_lines: list of [<line_number (number)>, <name (string)>]
-" where name = 'added|removed|modified|modified_removed'
-function! gitgutter#sign#update_signs(bufnr, modified_lines) abort
-  if exists('*sign_unplace')
-    " Vim is (hopefully) now quick enough to remove all signs then place new ones.
-    call sign_unplace('gitgutter', {'buffer': a:bufnr})
-
-    let modified_lines = s:handle_double_hunk(a:modified_lines)
-    let signs = map(copy(modified_lines), '{'.
-          \ '"buffer":   a:bufnr,'.
-          \ '"group":    "gitgutter",'.
-          \ '"name":     s:highlight_name_for_change(v:val[1]),'.
-          \ '"lnum":     v:val[0],'.
-          \ '"priority": g:gitgutter_sign_priority'.
-          \ '}')
-
-    if exists('*sign_placelist')
-      call sign_placelist(signs)
-      return
-    endif
-
-    for sign in signs
-      call sign_place(0, sign.group, sign.name, sign.buffer, {'lnum': sign.lnum, 'priority': sign.priority})
-    endfor
-    return
-  endif
-
-
-  " Derive a delta between the current signs and the ones we want.
-  " Remove signs from lines that no longer need a sign.
-  " Upsert the remaining signs.
-
-  call s:find_current_signs(a:bufnr)
-
-  let new_gitgutter_signs_line_numbers = map(copy(a:modified_lines), 'v:val[0]')
-  let obsolete_signs = s:obsolete_gitgutter_signs_to_remove(a:bufnr, new_gitgutter_signs_line_numbers)
-
-  call s:remove_signs(a:bufnr, obsolete_signs, s:remove_all_old_signs)
-  call s:upsert_new_gitgutter_signs(a:bufnr, a:modified_lines)
-endfunction
-
-
-"
-" Internal functions
-"
-
-
-function! s:find_current_signs(bufnr) abort
-  let gitgutter_signs = {}  " <line_number (string)>: {'id': <id (number)>, 'name': <name (string)>}
-  if !g:gitgutter_sign_allow_clobber
-    let other_signs = []      " [<line_number (number),...]
-  endif
-
-  if exists('*getbufinfo')
-    let bufinfo = getbufinfo(a:bufnr)[0]
-    let signs = has_key(bufinfo, 'signs') ? bufinfo.signs : []
-  else
-    let signs = []
-
-    redir => signlines
-      silent execute "sign place buffer=" . a:bufnr
-    redir END
-
-    for signline in filter(split(signlines, '\n')[2:], 'v:val =~# "="')
-      " Typical sign line before v8.1.0614:  line=88 id=1234 name=GitGutterLineAdded
-      " We assume splitting is faster than a regexp.
-      let components = split(signline)
-      call add(signs, {
-            \ 'lnum': str2nr(split(components[0], '=')[1]),
-            \ 'id':   str2nr(split(components[1], '=')[1]),
-            \ 'name':        split(components[2], '=')[1]
-            \ })
-    endfor
-  endif
-
-  for sign in signs
-    if sign.name =~# 'GitGutter'
-      " Remove orphaned signs (signs placed on lines which have been deleted).
-      " (When a line is deleted its sign lingers.  Subsequent lines' signs'
-      " line numbers are decremented appropriately.)
-      if has_key(gitgutter_signs, sign.lnum)
-        execute "sign unplace" gitgutter_signs[sign.lnum].id
-      endif
-      let gitgutter_signs[sign.lnum] = {'id': sign.id, 'name': sign.name}
-    else
-      if !g:gitgutter_sign_allow_clobber
-        call add(other_signs, sign.lnum)
-      endif
-    endif
-  endfor
-
-  call gitgutter#utility#setbufvar(a:bufnr, 'gitgutter_signs', gitgutter_signs)
-  if !g:gitgutter_sign_allow_clobber
-    call gitgutter#utility#setbufvar(a:bufnr, 'other_signs', other_signs)
-  endif
-endfunction
-
-
-" Returns a list of [<id (number)>, ...]
-" Sets `s:remove_all_old_signs` as a side-effect.
-function! s:obsolete_gitgutter_signs_to_remove(bufnr, new_gitgutter_signs_line_numbers) abort
-  let signs_to_remove = []  " list of [<id (number)>, ...]
-  let remove_all_signs = 1
-  let old_gitgutter_signs = gitgutter#utility#getbufvar(a:bufnr, 'gitgutter_signs')
-  for line_number in keys(old_gitgutter_signs)
-    if index(a:new_gitgutter_signs_line_numbers, str2nr(line_number)) == -1
-      call add(signs_to_remove, old_gitgutter_signs[line_number].id)
-    else
-      let remove_all_signs = 0
-    endif
-  endfor
-  let s:remove_all_old_signs = remove_all_signs
-  return signs_to_remove
-endfunction
-
-
-function! s:remove_signs(bufnr, sign_ids, all_signs) abort
-  if a:all_signs && s:supports_star && (g:gitgutter_sign_allow_clobber || empty(gitgutter#utility#getbufvar(a:bufnr, 'other_signs')))
-    execute "sign unplace * buffer=" . a:bufnr
-  else
-    for id in a:sign_ids
-      execute "sign unplace" id
-    endfor
-  endif
-endfunction
-
-
-function! s:upsert_new_gitgutter_signs(bufnr, modified_lines) abort
-  if !g:gitgutter_sign_allow_clobber
-    let other_signs = gitgutter#utility#getbufvar(a:bufnr, 'other_signs')
-  endif
-  let old_gitgutter_signs = gitgutter#utility#getbufvar(a:bufnr, 'gitgutter_signs')
-
-  let modified_lines = s:handle_double_hunk(a:modified_lines)
-
-  for line in modified_lines
-    let line_number = line[0]  " <number>
-    if g:gitgutter_sign_allow_clobber || index(other_signs, line_number) == -1  " don't clobber others' signs
-      let name = s:highlight_name_for_change(line[1])
-      if !has_key(old_gitgutter_signs, line_number)  " insert
-        let id = s:next_sign_id()
-        execute "sign place" id "line=" . line_number "name=" . name "buffer=" . a:bufnr
-      else  " update if sign has changed
-        let old_sign = old_gitgutter_signs[line_number]
-        if old_sign.name !=# name
-          execute "sign place" old_sign.id "name=" . name "buffer=" . a:bufnr
-        end
-      endif
-    endif
-  endfor
-  " At this point b:gitgutter_gitgutter_signs is out of date.
-endfunction
-
-
-" Handle special case where the first line is the site of two hunks:
-" lines deleted above at the start of the file, and lines deleted
-" immediately below.
-function! s:handle_double_hunk(modified_lines)
-  if a:modified_lines[0:1] == [[1, 'removed_first_line'], [1, 'removed']]
-    return [[1, 'removed_above_and_below']] + a:modified_lines[2:]
-  endif
-
-  return a:modified_lines
-endfunction
-
-
-function! s:next_sign_id() abort
-  let next_id = s:next_sign_id
-  let s:next_sign_id += 1
-  return next_id
-endfunction
-
-
-" Only for testing.
-function! gitgutter#sign#reset()
-  let s:next_sign_id  = s:first_sign_id
-endfunction
-
-
-function! s:highlight_name_for_change(text) abort
-  if a:text ==# 'added'
-    return 'GitGutterLineAdded'
-  elseif a:text ==# 'removed'
-    return 'GitGutterLineRemoved'
-  elseif a:text ==# 'removed_first_line'
-    return 'GitGutterLineRemovedFirstLine'
-  elseif a:text ==# 'modified'
-    return 'GitGutterLineModified'
-  elseif a:text ==# 'modified_removed'
-    return 'GitGutterLineModifiedRemoved'
-  elseif a:text ==# 'removed_above_and_below'
-    return 'GitGutterLineRemovedAboveAndBelow'
-  endif
-endfunction
-
-
diff --git a/sources_non_forked/vim-gitgutter/autoload/gitgutter/utility.vim b/sources_non_forked/vim-gitgutter/autoload/gitgutter/utility.vim
deleted file mode 100644
index 4a02c2f..0000000
--- a/sources_non_forked/vim-gitgutter/autoload/gitgutter/utility.vim
+++ /dev/null
@@ -1,233 +0,0 @@
-function! gitgutter#utility#supports_overscore_sign()
-  if gitgutter#utility#windows()
-    return &encoding ==? 'utf-8'
-  else
-    return &termencoding ==? &encoding || &termencoding == ''
-  endif
-endfunction
-
-function! gitgutter#utility#setbufvar(buffer, varname, val)
-  let buffer = +a:buffer
-  " Default value for getbufvar() was introduced in Vim 7.3.831.
-  let ggvars = getbufvar(buffer, 'gitgutter')
-  if type(ggvars) == type('')
-    unlet ggvars
-    let ggvars = {}
-    call setbufvar(buffer, 'gitgutter', ggvars)
-  endif
-  let ggvars[a:varname] = a:val
-endfunction
-
-function! gitgutter#utility#getbufvar(buffer, varname, ...)
-  let ggvars = getbufvar(a:buffer, 'gitgutter')
-  if type(ggvars) == type({}) && has_key(ggvars, a:varname)
-    return ggvars[a:varname]
-  endif
-  if a:0
-    return a:1
-  endif
-endfunction
-
-function! gitgutter#utility#warn(message) abort
-  echohl WarningMsg
-  echo 'vim-gitgutter: ' . a:message
-  echohl None
-  let v:warningmsg = a:message
-endfunction
-
-function! gitgutter#utility#warn_once(bufnr, message, key) abort
-  if empty(gitgutter#utility#getbufvar(a:bufnr, a:key))
-    call gitgutter#utility#setbufvar(a:bufnr, a:key, '1')
-    echohl WarningMsg
-    redraw | echom 'vim-gitgutter: ' . a:message
-    echohl None
-    let v:warningmsg = a:message
-  endif
-endfunction
-
-" Returns truthy when the buffer's file should be processed; and falsey when it shouldn't.
-" This function does not and should not make any system calls.
-function! gitgutter#utility#is_active(bufnr) abort
-  return g:gitgutter_enabled &&
-        \ gitgutter#utility#getbufvar(a:bufnr, 'enabled', 1) &&
-        \ !pumvisible() &&
-        \ s:is_file_buffer(a:bufnr) &&
-        \ s:exists_file(a:bufnr) &&
-        \ s:not_git_dir(a:bufnr)
-endfunction
-
-function! s:not_git_dir(bufnr) abort
-  return s:dir(a:bufnr) !~ '[/\\]\.git\($\|[/\\]\)'
-endfunction
-
-function! s:is_file_buffer(bufnr) abort
-  return empty(getbufvar(a:bufnr, '&buftype'))
-endfunction
-
-" From tpope/vim-fugitive
-function! s:winshell()
-  return &shell =~? 'cmd' || exists('+shellslash') && !&shellslash
-endfunction
-
-" From tpope/vim-fugitive
-function! gitgutter#utility#shellescape(arg) abort
-  if a:arg =~ '^[A-Za-z0-9_/.-]\+$'
-    return a:arg
-  elseif s:winshell()
-    return '"' . substitute(substitute(a:arg, '"', '""', 'g'), '%', '"%"', 'g') . '"'
-  else
-    return shellescape(a:arg)
-  endif
-endfunction
-
-function! gitgutter#utility#file(bufnr)
-  return s:abs_path(a:bufnr, 1)
-endfunction
-
-" Not shellescaped
-function! gitgutter#utility#extension(bufnr) abort
-  return fnamemodify(s:abs_path(a:bufnr, 0), ':e')
-endfunction
-
-function! gitgutter#utility#system(cmd, ...) abort
-  call gitgutter#debug#log(a:cmd, a:000)
-
-  call s:use_known_shell()
-  silent let output = (a:0 == 0) ? system(a:cmd) : system(a:cmd, a:1)
-  call s:restore_shell()
-
-  return output
-endfunction
-
-function! gitgutter#utility#has_repo_path(bufnr)
-  return index(['', -1, -2], gitgutter#utility#repo_path(a:bufnr, 0)) == -1
-endfunction
-
-" Path of file relative to repo root.
-"
-" *     empty string - not set
-" * non-empty string - path
-" *               -1 - pending
-" *               -2 - not tracked by git
-function! gitgutter#utility#repo_path(bufnr, shellesc) abort
-  let p = gitgutter#utility#getbufvar(a:bufnr, 'path', '')
-  return a:shellesc ? gitgutter#utility#shellescape(p) : p
-endfunction
-
-
-let s:set_path_handler = {}
-
-function! s:set_path_handler.out(buffer, path) abort
-  let path = s:strip_trailing_new_line(a:path)
-  call gitgutter#utility#setbufvar(a:buffer, 'path', path)
-
-  if type(self.continuation) == type(function('tr'))
-    call self.continuation()
-  else
-    call call(self.continuation.function, self.continuation.arguments)
-  endif
-endfunction
-
-function! s:set_path_handler.err(buffer) abort
-  call gitgutter#utility#setbufvar(a:buffer, 'path', -2)
-endfunction
-
-
-" continuation - a funcref or hash to call after setting the repo path asynchronously.
-"
-" Returns 'async' if the the path is set asynchronously, 0 otherwise.
-function! gitgutter#utility#set_repo_path(bufnr, continuation) abort
-  " Values of path:
-  " * non-empty string - path
-  " *               -1 - pending
-  " *               -2 - not tracked by git
-
-  call gitgutter#utility#setbufvar(a:bufnr, 'path', -1)
-  let cmd = gitgutter#utility#cd_cmd(a:bufnr, g:gitgutter_git_executable.' '.g:gitgutter_git_args.' ls-files --error-unmatch --full-name -z -- '.gitgutter#utility#shellescape(s:filename(a:bufnr)))
-
-  if g:gitgutter_async && gitgutter#async#available() && !has('vim_starting')
-    let handler = copy(s:set_path_handler)
-    let handler.continuation = a:continuation
-    call gitgutter#async#execute(cmd, a:bufnr, handler)
-    return 'async'
-  endif
-
-  let path = gitgutter#utility#system(cmd)
-  if v:shell_error
-    call gitgutter#utility#setbufvar(a:bufnr, 'path', -2)
-  else
-    call gitgutter#utility#setbufvar(a:bufnr, 'path', s:strip_trailing_new_line(path))
-  endif
-endfunction
-
-
-function! gitgutter#utility#cd_cmd(bufnr, cmd) abort
-  let cd = s:unc_path(a:bufnr) ? 'pushd' : (gitgutter#utility#windows() && s:dos_shell() ? 'cd /d' : 'cd')
-  return cd.' '.s:dir(a:bufnr).' && '.a:cmd
-endfunction
-
-function! s:unc_path(bufnr)
-  return s:abs_path(a:bufnr, 0) =~ '^\\\\'
-endfunction
-
-function! s:dos_shell()
-  return &shell == 'cmd.exe' || &shell == 'command.com'
-endfunction
-
-function! s:use_known_shell() abort
-  if has('unix') && &shell !=# 'sh'
-    let [s:shell, s:shellcmdflag, s:shellredir] = [&shell, &shellcmdflag, &shellredir]
-    let &shell = 'sh'
-    set shellcmdflag=-c shellredir=>%s\ 2>&1
-  endif
-endfunction
-
-function! s:restore_shell() abort
-  if has('unix') && exists('s:shell')
-    let [&shell, &shellcmdflag, &shellredir] = [s:shell, s:shellcmdflag, s:shellredir]
-  endif
-endfunction
-
-function! gitgutter#utility#get_diff_base(bufnr)
-  let p = resolve(expand('#'.a:bufnr.':p'))
-  let ml = matchlist(p, '\v^fugitive:/.*/(\x{40,})/')
-  if !empty(ml) && !empty(ml[1])
-    return ml[1].'^'
-  endif
-  return g:gitgutter_diff_base
-endfunction
-
-function! s:abs_path(bufnr, shellesc)
-  let p = resolve(expand('#'.a:bufnr.':p'))
-
-  " Remove extra parts from fugitive's filepaths
-  let p = substitute(substitute(p, '^fugitive:', '', ''), '\v\.git/\x{40,}/', '', '')
-
-  return a:shellesc ? gitgutter#utility#shellescape(p) : p
-endfunction
-
-function! s:dir(bufnr) abort
-  return gitgutter#utility#shellescape(fnamemodify(s:abs_path(a:bufnr, 0), ':h'))
-endfunction
-
-" Not shellescaped.
-function! s:filename(bufnr) abort
-  return fnamemodify(s:abs_path(a:bufnr, 0), ':t')
-endfunction
-
-function! s:exists_file(bufnr) abort
-  return filereadable(s:abs_path(a:bufnr, 0))
-endfunction
-
-" Get rid of any trailing new line or SOH character.
-"
-" git ls-files -z produces output with null line termination.
-" Vim's system() replaces any null characters in the output
-" with SOH (start of header), i.e. ^A.
-function! s:strip_trailing_new_line(line) abort
-  return substitute(a:line, '[[:cntrl:]]$', '', '')
-endfunction
-
-function! gitgutter#utility#windows()
-  return has('win64') || has('win32') || has('win16')
-endfunction
diff --git a/sources_non_forked/vim-gitgutter/doc/gitgutter.txt b/sources_non_forked/vim-gitgutter/doc/gitgutter.txt
deleted file mode 100644
index 2d744a8..0000000
--- a/sources_non_forked/vim-gitgutter/doc/gitgutter.txt
+++ /dev/null
@@ -1,658 +0,0 @@
-*gitgutter.txt*              A Vim plugin which shows a git diff in the gutter.
-
-
-                           Vim GitGutter
-
-
-Author:            Andy Stewart <https://airbladesoftware.com/>
-Plugin Homepage:   <https://github.com/airblade/vim-gitgutter>
-
-
-===============================================================================
-CONTENTS                                                            *gitgutter*
-
-  Introduction ................. |gitgutter-introduction|
-  Installation ................. |gitgutter-installation|
-  Windows      ................. |gitgutter-windows|
-  Commands ..................... |gitgutter-commands|
-  Mappings ..................... |gitgutter-mappings|
-  Autocommand .................. |gitgutter-autocommand|
-  Status line .................. |gitgutter-statusline|
-  Options ...................... |gitgutter-options|
-  Highlights ................... |gitgutter-highlights|
-  FAQ .......................... |gitgutter-faq|
-  TROUBLESHOOTING .............. |gitgutter-troubleshooting|
-
-
-===============================================================================
-INTRODUCTION                                           *gitgutter-introduction*
-
-GitGutter is a Vim plugin which shows a git diff in the sign column.
-It shows which lines have been added, modified, or removed.  You can also
-preview, stage, and undo individual hunks.  The plugin also provides a hunk
-text object.
-
-The signs are always up to date and the plugin never saves your buffer.
-
-The name "gitgutter" comes from the Sublime Text 3 plugin which inspired this
-one in 2013.
-
-
-===============================================================================
-INSTALLATION                                           *gitgutter-installation*
-
-Use your favourite package manager, or use Vim's built-in package support.
-
-Vim:~
->
-  mkdir -p ~/.vim/pack/airblade/start
-  cd ~/.vim/pack/airblade/start
-  git clone https://github.com/airblade/vim-gitgutter.git
-  vim -u NONE -c "helptags vim-gitgutter/doc" -c q
-<
-
-Neovim:~
->
-  mkdir -p ~/.config/nvim/pack/airblade/start
-  cd ~/.config/nvim/pack/airblade/start
-  git clone https://github.com/airblade/vim-gitgutter.git
-  nvim -u NONE -c "helptags vim-gitgutter/doc" -c q
-<
-
-
-===============================================================================
-WINDOWS                                                     *gitgutter-windows*
-
-I recommend configuring vim-gitgutter with the full path to your git executable.
-For example:
->
-    let g:gitgutter_git_executable = 'C:\Program Files\Git\bin\git.exe'
-<
-This is to avoid a problem which occurs if you have file named "git.*" (i.e.
-with any extension in "PATHEXT") in your current folder.  "cmd.exe" prioritises
-the current folder over folders in 'PATH' and will try to execute your file
-instead of the "git" binary.
-
-
-===============================================================================
-COMMANDS                                                   *gitgutter-commands*
-
-Commands for turning vim-gitgutter on and off:~
-
-                                                  *gitgutter-:GitGutterDisable*
-:GitGutterDisable       Turn vim-gitgutter off for all buffers.
-
-                                                   *gitgutter-:GitGutterEnable*
-:GitGutterEnable        Turn vim-gitgutter on for all buffers.
-
-                                                   *gitgutter-:GitGutterToggle*
-:GitGutterToggle        Toggle vim-gitgutter on or off for all buffers.
-
-                                                         *gitgutter-:GitGutter*
-:GitGutter              Update signs for the current buffer.  You shouldn't
-                        need to run this.
-
-                                                      *gitgutter-:GitGutterAll*
-:GitGutterAll           Update signs for all buffers.  You shouldn't need to
-                        run this.
-
-
-Commands for turning signs on and off (defaults to on):~
-
-                                              *gitgutter-:GitGutterSignsEnable*
-:GitGutterSignsEnable   Show signs for the diff.
-
-                                             *gitgutter-:GitGutterSignsDisable*
-:GitGutterSignsDisable  Do not show signs for the diff.
-
-                                              *gitgutter-:GitGutterSignsToggle*
-:GitGutterSignsToggle   Toggle signs on or off.
-
-
-Commands for turning line highlighting on and off (defaults to off):~
-
-                                     *gitgutter-:GitGutterLineHighlightsEnable*
-:GitGutterLineHighlightsEnable  Turn on line highlighting.
-
-                                    *gitgutter-:GitGutterLineHighlightsDisable*
-:GitGutterLineHighlightsDisable Turn off line highlighting.
-
-                                     *gitgutter-:GitGutterLineHighlightsToggle*
-:GitGutterLineHighlightsToggle  Turn line highlighting on or off.
-
-
-Commands for turning line number highlighting on and off (defaults to off):~
-NOTE: This feature requires Neovim 0.3.2 or higher.
-
-                                   *gitgutter-:GitGutterLineNrHighlightsEnable*
-:GitGutterLineNrHighlightsEnable  Turn on line highlighting.
-
-                                  *gitgutter-:GitGutterLineNrHighlightsDisable*
-:GitGutterLineNrHighlightsDisable Turn off line highlighting.
-
-                                   *gitgutter-:GitGutterLineNrHighlightsToggle*
-:GitGutterLineNrHighlightsToggle  Turn line highlighting on or off.
-
-
-Commands for jumping between hunks:~
-
-                                                 *gitgutter-:GitGutterNextHunk*
-:GitGutterNextHunk      Jump to the next [count] hunk.
-
-                                                 *gitgutter-:GitGutterPrevHunk*
-:GitGutterPrevHunk      Jump to the previous [count] hunk.
-
-                                                 *gitgutter-:GitGutterQuickFix*
-:GitGutterQuickFix      Load all hunks into the |quickfix| list.  Note this
-                        ignores any unsaved changes in your buffers. The
-                        |g:gitgutter_use_location_list| option can be set to
-                        populate the location list of the current window instead
-
-
-Commands for operating on a hunk:~
-
-                                                *gitgutter-:GitGutterStageHunk*
-:GitGutterStageHunk     Stage the hunk the cursor is in.  Use a visual selection
-                        to stage part of an (additions-only) hunk; or use a
-                        range.
-
-                        To stage part of any hunk, first |GitGutterPreviewHunk|
-                        it, then move to the preview window, delete the lines
-                        you do not want to stage, and |write| or
-                        |GitGutterStageHunk|.
-
-                                                 *gitgutter-:GitGutterUndoHunk*
-:GitGutterUndoHunk      Undo the hunk the cursor is in.
-
-                                              *gitgutter-:GitGutterPreviewHunk*
-:GitGutterPreviewHunk   Preview the hunk the cursor is in.
-                        Use |:pclose| or |CTRL-W_CTRL-Z| to close the preview
-                        window.
-
-                        To stage part of the hunk, move to the preview window,
-                        delete any lines you do not want to stage, and
-                        |GitGutterStageHunk|.
-
-Commands for folds:~
-
-                                                     *gitgutter-:GitGutterFold*
-:GitGutterFold          Fold all unchanged lines.  Execute again to undo.
-
-
-===============================================================================
-AUTOCOMMANDS                                           *gitgutter-autocommands*
-
-User GitGutter~
-
-After updating a buffer's signs vim-gitgutter fires a |User| |autocmd| with the
-event GitGutter.  You can listen for this event, for example:
->
-  autocmd User GitGutter call updateMyStatusLine()
-<
-A dictionary `g:gitgutter_hook_context` is made available during its execution,
-which contains an entry `bufnr` that contains the buffer number being updated.
-
-User GitGutterStage~
-
-After staging a hunk or part of a hunk vim-gitgutter fires a |User| |autocmd|
-with the event GitGutterStage.  Staging always happens in the current buffer.
-
-===============================================================================
-MAPPINGS                                                   *gitgutter-mappings*
-
-You can disable all these mappings with:
->
-    let g:gitgutter_map_keys = 0
-<
-
-Hunk operations:~
-
-These can be repeated with `.` if you have vim-repeat installed.
-
-                                                         *gitgutter-<Leader>hp*
-<Leader>hp              Preview the hunk under the cursor.
-
-                                                         *gitgutter-<Leader>hs*
-<Leader>hs              Stage the hunk under the cursor.
-
-                                                         *gitgutter-<Leader>hu*
-<Leader>hu              Undo the hunk under the cursor.
-
-You can change these mappings like this:
->
-    nmap ghp <Plug>(GitGutterPreviewHunk)
-    nmap ghs <Plug>(GitGutterStageHunk)
-    nmap ghu <Plug>(GitGutterUndoHunk)
-<
-
-Hunk jumping:~
-
-                                                                 *gitgutter-]c*
-]c                      Jump to the next [count] hunk.
-
-                                                                 *gitgutter-[c*
-[c                      Jump to the previous [count] hunk.
-
-You can change these mappings like this:
->
-    nmap [c <Plug>(GitGutterPrevHunk)
-    nmap ]c <Plug>(GitGutterNextHunk)
-<
-
-Hunk text object:~
-
-                          *gitgutter-ic* *gitgutter-ac* *gitgutter-text-object*
-"ic" operates on the current hunk's lines.  "ac" does the same but also includes
-trailing empty lines.
->
-    omap ic <Plug>(GitGutterTextObjectInnerPending)
-    omap ac <Plug>(GitGutterTextObjectOuterPending)
-    xmap ic <Plug>(GitGutterTextObjectInnerVisual)
-    xmap ac <Plug>(GitGutterTextObjectOuterVisual)
-<
-
-
-===============================================================================
-STATUS LINE                                              *gitgutter-statusline*
-
-
-Call the `GitGutterGetHunkSummary()` function from your status line to get a
-list of counts of added, modified, and removed lines in the current buffer.
-For example:
->
-    " Your vimrc
-    function! GitStatus()
-      let [a,m,r] = GitGutterGetHunkSummary()
-      return printf('+%d ~%d -%d', a, m, r)
-    endfunction
-    set statusline+=%{GitStatus()}
-<
-
-
-===============================================================================
-OPTIONS                                                     *gitgutter-options*
-
-The most important option is 'updatetime' which determines how long (in
-milliseconds) the plugin will wait after you stop typing before it updates the
-signs.  Vim's default is 4000.  I recommend 100.  Note this also controls how
-long vim waits before writing its swap file.
-
-Most important option:~
-
-    'updatetime'
-
-Git:~
-
-    |g:gitgutter_git_executable|
-    |g:gitgutter_git_args|
-    |g:gitgutter_diff_args|
-    |g:gitgutter_diff_relative_to|
-    |g:gitgutter_diff_base|
-
-Grep:~
-
-    |g:gitgutter_grep|
-
-Signs:~
-
-    |g:gitgutter_signs|
-    |g:gitgutter_highlight_lines|
-    |g:gitgutter_highlight_linenrs|
-    |g:gitgutter_max_signs|
-    |g:gitgutter_sign_priority|
-    |g:gitgutter_sign_allow_clobber|
-    |g:gitgutter_sign_added|
-    |g:gitgutter_sign_modified|
-    |g:gitgutter_sign_removed|
-    |g:gitgutter_sign_removed_first_line|
-    |g:gitgutter_sign_modified_removed|
-    |g:gitgutter_set_sign_backgrounds|
-
-Hunk previews:~
-
-    |g:gitgutter_preview_win_floating|
-
-Terminal:~
-
-    |g:gitgutter_terminal_reports_focus|
-
-General:~
-
-    |g:gitgutter_enabled|
-    |g:gitgutter_map_keys|
-    |g:gitgutter_async|
-    |g:gitgutter_log|
-    |g:gitgutter_use_location_list|
-
-
-                                             *g:gitgutter_preview_win_location*
-Default: 'bo'
-
-This option determines where the preview window pops up as a result of the
-:GitGutterPreviewHunk command. Other plausible values are 'to', 'bel', 'abo'.
-See the end of the |opening-window| docs.
-
-                                                   *g:gitgutter_git_executable*
-Default: 'git'
-
-This option determines what git binary to use.  Set this if git is not on your
-path.
-
-                                                         *g:gitgutter_git_args*
-Default: empty
-
-Use this option to pass any extra arguments to git when running git-diff.
-For example:
->
-    let g:gitgutter_git_args = '--git-dir=""'
-<
-
-                                                        *g:gitgutter_diff_args*
-Default: empty
-
-Use this option to pass any extra arguments to git-diff.  For example:
->
-    let g:gitgutter_diff_args = '-w'
-<
-
-                                                 *g:gitgutter_diff_relative_to*
-Default: empty
-
-By default buffers are diffed against the index.  Use this option to diff against
-the working tree.  For example:
->
-    let g:gitgutter_diff_relative_to = 'working_tree'
-<
-
-                                                        *g:gitgutter_diff_base*
-Default: empty
-
-By default buffers are diffed against the index.  Use this option to diff against
-a revision instead.  For example:
->
-    let g:gitgutter_diff_base = '<some commit SHA>'
-<
-
-If you are looking at a previous version of a file with Fugitive (e.g.
-via :0Gclog), gitgutter sets the diff base to the parent of the current revision.
-
-This setting is ignore when the diff is relative to the working tree
-(|g:gitgutter_diff_relative_to|).
-
-                                                             *g:gitgutter_grep*
-Default: 'grep'
-
-The plugin pipes the output of git-diff into grep to minimise the amount of data
-vim has to process.  Set this option if grep is not on your path.
-
-grep must produce plain-text output without any ANSI escape codes or colours.
-Use this option to turn off colours if necessary.
->
-    let g:gitgutter_grep = 'grep --color=never'
-<
-If you do not want to use grep at all (perhaps to debug why signs are not
-showing), set this option to an empty string:
->
-    let g:gitgutter_grep = ''
-<
-
-                                                            *g:gitgutter_signs*
-Default: 1
-
-Determines whether or not to show signs.
-
-                                                  *g:gitgutter_highlight_lines*
-Default: 0
-
-Determines whether or not to show line highlights.
-
-                                                *g:gitgutter_highlight_linenrs*
-Default: 0
-
-Determines whether or not to show line number highlights.
-
-                                                        *g:gitgutter_max_signs*
-Default: 500 (Vim < 8.1.0614, Neovim < 0.4.0)
-          -1 (otherwise)
-
-Sets the maximum number of signs to show in a buffer.  Vim is slow at updating
-signs, so to avoid slowing down the GUI the number of signs is capped.  When
-the number of changed lines exceeds this value, the plugin removes all signs
-and displays a warning message.
-
-When set to -1 the limit is not applied.
-
-                                                   *g:gitgutter_sign_priority*
-Default: 10
-
-Sets the |sign-priority| gitgutter assigns to its signs.
-
-                                               *g:gitgutter_sign_allow_clobber*
-Default: 0 (Vim < 8.1.0614, Neovim < 0.4.0)
-         1 (otherwise)
-
-Determines whether gitgutter preserves non-gitgutter signs. When 1, gitgutter
-will not preserve non-gitgutter signs.
-
-                                          *g:gitgutter_sign_added*
-                                          *g:gitgutter_sign_modified*
-                                          *g:gitgutter_sign_removed*
-                                          *g:gitgutter_sign_removed_first_line*
-                                          *g:gitgutter_sign_modified_removed*
-Defaults:
->
-    let g:gitgutter_sign_added              = '+'
-    let g:gitgutter_sign_modified           = '~'
-    let g:gitgutter_sign_removed            = '_'
-    let g:gitgutter_sign_removed_first_line = ''
-    let g:gitgutter_sign_modified_removed   = '~_'
-<
-You can use unicode characters but not images.  Signs must not take up more than
-2 columns.
-
-                                              *g:gitgutter_set_sign_backgrounds*
-Default: 0
-
-Only applies to existing GitGutter* highlight groups.  See
-|gitgutter-highlights|.
-
-Controls whether to override the signs' background colours to match the
-|hl-SignColumn|.
-
-                                             *g:gitgutter_preview_win_floating*
-Default: 0 (Vim)
-         0 (NeoVim which does not support floating windows)
-         1 (NeoVim which does support floating windows)
-
-Whether to use floating/popup windows for hunk previews.  Note that if you use
-popup windows on Vim you will not be able to stage partial hunks via the
-preview window.
-
-                                           *g:gitgutter_terminal_reports_focus*
-Default: 1
-
-Normally the plugin uses |FocusGained| to force-update all buffers when Vim
-receives focus.  However some terminals do not report focus events and so the
-|FocusGained| autocommand never fires.
-
-If this applies to you, either install something like Terminus
-(https://github.com/wincent/terminus) to make |FocusGained| work or set this
-option to 0.
-
-If you use tmux, try this in your tmux.conf:
->
-    set -g focus-events on
-<
-
-When this option is 0, the plugin force-updates the buffer on |BufEnter|
-(instead of only updating if the buffer's contents has changed since the last
-update).
-
-                                                          *g:gitgutter_enabled*
-Default: 1
-
-Controls whether or not the plugin is on at startup.
-
-                                                         *g:gitgutter_map_keys*
-Default: 1
-
-Controls whether or not the plugin provides mappings.  See |gitgutter-mappings|.
-
-                                                            *g:gitgutter_async*
-Default: 1
-
-Controls whether or not diffs are run in the background.  This has no effect if
-your Vim does not support background jobs.
-
-                                                              *g:gitgutter_log*
-Default: 0
-
-When switched on, the plugin logs to gitgutter.log in the directory where it is
-installed.  Additionally it logs channel activity to channel.log.
-
-                                                *g:gitgutter_use_location_list*
-Default: 0
-
-When switched on, the :GitGutterQuickFix command populates the location list
-of the current window instead of the global quickfix list.
-
-
-===============================================================================
-HIGHLIGHTS                                               *gitgutter-highlights*
-
-To change the signs' colours, specify these highlight groups in your |vimrc|:
->
-    highlight GitGutterAdd    guifg=#009900 ctermfg=2
-    highlight GitGutterChange guifg=#bbbb00 ctermfg=3
-    highlight GitGutterDelete guifg=#ff2222 ctermfg=1
-<
-
-See |highlight-guifg| and |highlight-ctermfg| for the values you can use.
-
-If you do not like the signs' background colours and you do not want to update
-the GitGutter* highlight groups yourself, you can get the plugin to do it
-|g:gitgutter_set_sign_backgrounds|.
-
-To change the line highlights, set up the following highlight groups in your
-colorscheme or |vimrc|:
->
-    GitGutterAddLine          " default: links to DiffAdd
-    GitGutterChangeLine       " default: links to DiffChange
-    GitGutterDeleteLine       " default: links to DiffDelete
-    GitGutterChangeDeleteLine " default: links to GitGutterChangeLineDefault
-<
-
-For example, to use |hl-DiffText| instead of |hl-DiffChange|:
->
-    highlight link GitGutterChangeLine DiffText
-<
-To change the line number highlights, set up the following highlight groups in
-your colorscheme or |vimrc|:
->
-    GitGutterAddLineNr          " default: links to CursorLineNr
-    GitGutterChangeLineNr       " default: links to CursorLineNr
-    GitGutterDeleteLineNr       " default: links to CursorLineNr
-    GitGutterChangeDeleteLineNr " default: links to CursorLineNr
-<
-For example, to use |hl-Underlined| instead of |hl-CursorLineNr|:
->
-    highlight link GitGutterChangeLineNr Underlined
-<
-
-
-===============================================================================
-FAQ                                                             *gitgutter-faq*
-
-a. How do I turn off realtime updates?
-
-  Add this to your vim configuration in an |after-directory|:
->
-    autocmd! gitgutter CursorHold,CursorHoldI
-<
-
-b. I turned off realtime updates, how can I have signs updated when I save a
-   file?
-
-  If you really want to update the signs when you save a file, add this to your
-  |vimrc|:
->
-    autocmd BufWritePost * GitGutter
-<
-
-c. Why can't I unstage staged changes?
-
-  This plugin is for showing changes between the working tree and the index
-  (and staging/undoing those changes). Unstaging a staged hunk would require
-  showing changes between the index and HEAD, which is out of scope.
-
-d. Why are the colours in the sign column weird?
-
-  Your colorscheme is configuring the |hl-SignColumn| highlight group weirdly.
-  Here are two ways you could change the colours:
->
-    highlight! link SignColumn LineNr
-    highlight SignColumn guibg=whatever ctermbg=whatever
-<
-
-e. What happens if I also use another plugin which uses signs (e.g. Syntastic)?
-
-  Vim only allows one sign per line.  Vim-gitgutter will not interfere with
-  signs it did not add.
-
-
-===============================================================================
-TROUBLESHOOTING                                     *gitgutter-troubleshooting*
-
-When no signs are showing at all:~
-
-1. Try bypassing grep with:
->
-    let g:gitgutter_grep = ''
-<
-  If it works, the problem is grep outputting ANSI escape codes.  Use this
-  option to pass arguments to grep to turn off the escape codes.
-
-2. Verify git is on your path:
->
-    :echo system('git --version')
-<
-
-3. Verify your git config is compatible with the version of git return by the
-   command above.
-
-4. Verify your Vim supports signs.  The following should give 1:
->
-    :echo has('signs')
-<
-
-5. Check whether the plugin thinks git knows about your file:
->
-    :echo getbufvar('','gitgutter').path
-<
-  If the result is -2, the plugin thinks your file is not tracked by git.
-
-
-When the whole file is marked as added:~
-
-If you use zsh, and you set "CDPATH", make sure "CDPATH" does not include the
-current directory.
-
-
-When signs take a few seconds to appear:~
-
-Try reducing 'updatetime':
->
-    set updatetime=100
-<
-
-Note this also controls how long vim waits before writing its swap file.
-
-
-When signs don't update after focusing Vim:~
-
-Your terminal probably isn't reporting focus events.  Either try installing
-Terminus (https://github.com/wincent/terminus) or set:
->
-    let g:gitgutter_terminal_reports_focus = 0
-<
-
diff --git a/sources_non_forked/vim-gitgutter/plugin/gitgutter.vim b/sources_non_forked/vim-gitgutter/plugin/gitgutter.vim
deleted file mode 100644
index 1b62403..0000000
--- a/sources_non_forked/vim-gitgutter/plugin/gitgutter.vim
+++ /dev/null
@@ -1,285 +0,0 @@
-scriptencoding utf-8
-
-if exists('g:loaded_gitgutter') || !has('signs') || &cp
-  finish
-endif
-let g:loaded_gitgutter = 1
-
-" Initialisation {{{
-
-if v:version < 703 || (v:version == 703 && !has("patch105"))
-  call gitgutter#utility#warn('requires Vim 7.3.105')
-  finish
-endif
-
-function! s:set(var, default) abort
-  if !exists(a:var)
-    if type(a:default)
-      execute 'let' a:var '=' string(a:default)
-    else
-      execute 'let' a:var '=' a:default
-    endif
-  endif
-endfunction
-
-function! s:obsolete(var)
-  if exists(a:var)
-    call gitgutter#utility#warn(a:var.' is obsolete and has no effect.')
-  endif
-endfunction
-
-
-call s:set('g:gitgutter_preview_win_location',     'bo')
-if exists('*nvim_open_win')
-  call s:set('g:gitgutter_preview_win_floating', 1)
-else
-  call s:set('g:gitgutter_preview_win_floating', 0)
-endif
-call s:set('g:gitgutter_enabled',                     1)
-if exists('*sign_unplace')
-  call s:set('g:gitgutter_max_signs', -1)
-else
-  call s:set('g:gitgutter_max_signs', 500)
-endif
-call s:set('g:gitgutter_signs',                       1)
-call s:set('g:gitgutter_highlight_lines',             0)
-call s:set('g:gitgutter_highlight_linenrs',           0)
-call s:set('g:gitgutter_sign_priority',              10)
-" Nvim 0.4.0 has an expanding sign column
-" The sign_place() function supports sign priority.
-if (has('nvim-0.4.0') || exists('*sign_place')) && !exists('g:gitgutter_sign_allow_clobber')
-  let g:gitgutter_sign_allow_clobber = 1
-endif
-call s:set('g:gitgutter_sign_allow_clobber',          0)
-call s:set('g:gitgutter_set_sign_backgrounds',           0)
-call s:set('g:gitgutter_sign_added',                   '+')
-call s:set('g:gitgutter_sign_modified',                '~')
-call s:set('g:gitgutter_sign_removed',                 '_')
-
-if gitgutter#utility#supports_overscore_sign()
-  call s:set('g:gitgutter_sign_removed_first_line', '')
-else
-  call s:set('g:gitgutter_sign_removed_first_line', '_^')
-endif
-
-call s:set('g:gitgutter_sign_removed_above_and_below', '[')
-call s:set('g:gitgutter_sign_modified_removed',       '~_')
-call s:set('g:gitgutter_git_args',                      '')
-call s:set('g:gitgutter_diff_relative_to',         'index')
-call s:set('g:gitgutter_diff_args',                     '')
-call s:set('g:gitgutter_diff_base',                     '')
-call s:set('g:gitgutter_map_keys',                       1)
-call s:set('g:gitgutter_terminal_reports_focus',         1)
-call s:set('g:gitgutter_async',                          1)
-call s:set('g:gitgutter_log',                            0)
-call s:set('g:gitgutter_use_location_list',              0)
-
-call s:set('g:gitgutter_git_executable', 'git')
-if !executable(g:gitgutter_git_executable)
-  if g:gitgutter_enabled
-    call gitgutter#utility#warn('cannot find git. Please set g:gitgutter_git_executable.')
-  endif
-  finish
-endif
-
-let default_grep = 'grep'
-call s:set('g:gitgutter_grep', default_grep)
-if !empty(g:gitgutter_grep)
-  if executable(split(g:gitgutter_grep)[0])
-    if $GREP_OPTIONS =~# '--color=always'
-      let g:gitgutter_grep .= ' --color=never'
-    endif
-  else
-    if g:gitgutter_grep !=# default_grep
-      call gitgutter#utility#warn('cannot find '.g:gitgutter_grep.'. Please check g:gitgutter_grep.')
-    endif
-    let g:gitgutter_grep = ''
-  endif
-endif
-
-call gitgutter#highlight#define_highlights()
-call gitgutter#highlight#define_signs()
-
-" Prevent infinite loop where:
-" - executing a job in the foreground launches a new window which takes the focus;
-" - when the job finishes, focus returns to gvim;
-" - the FocusGained event triggers a new job (see below).
-if gitgutter#utility#windows() && !(g:gitgutter_async && gitgutter#async#available())
-  set noshelltemp
-endif
-
-" }}}
-
-" Primary functions {{{
-
-command! -bar GitGutterAll call gitgutter#all(1)
-command! -bar GitGutter    call gitgutter#process_buffer(bufnr(''), 1)
-
-command! -bar GitGutterDisable call gitgutter#disable()
-command! -bar GitGutterEnable  call gitgutter#enable()
-command! -bar GitGutterToggle  call gitgutter#toggle()
-
-command! -bar GitGutterBufferDisable call gitgutter#buffer_disable()
-command! -bar GitGutterBufferEnable  call gitgutter#buffer_enable()
-command! -bar GitGutterBufferToggle  call gitgutter#buffer_toggle()
-
-command! -bar GitGutterQuickFix call gitgutter#quickfix()
-
-" }}}
-
-" Line highlights {{{
-
-command! -bar GitGutterLineHighlightsDisable call gitgutter#highlight#line_disable()
-command! -bar GitGutterLineHighlightsEnable  call gitgutter#highlight#line_enable()
-command! -bar GitGutterLineHighlightsToggle  call gitgutter#highlight#line_toggle()
-
-" }}}
-
-" 'number' column highlights {{{
-command! -bar GitGutterLineNrHighlightsDisable call gitgutter#highlight#linenr_disable()
-command! -bar GitGutterLineNrHighlightsEnable  call gitgutter#highlight#linenr_enable()
-command! -bar GitGutterLineNrHighlightsToggle  call gitgutter#highlight#linenr_toggle()
-" }}}
-
-" Signs {{{
-
-command! -bar GitGutterSignsEnable  call gitgutter#sign#enable()
-command! -bar GitGutterSignsDisable call gitgutter#sign#disable()
-command! -bar GitGutterSignsToggle  call gitgutter#sign#toggle()
-
-" }}}
-
-" Hunks {{{
-
-command! -bar -count=1 GitGutterNextHunk call gitgutter#hunk#next_hunk(<count>)
-command! -bar -count=1 GitGutterPrevHunk call gitgutter#hunk#prev_hunk(<count>)
-
-command! -bar -range=% GitGutterStageHunk call gitgutter#hunk#stage(<line1>,<line2>)
-command! -bar GitGutterUndoHunk    call gitgutter#hunk#undo()
-command! -bar GitGutterPreviewHunk call gitgutter#hunk#preview()
-
-" Hunk text object
-onoremap <silent> <Plug>(GitGutterTextObjectInnerPending) :<C-U>call gitgutter#hunk#text_object(1)<CR>
-onoremap <silent> <Plug>(GitGutterTextObjectOuterPending) :<C-U>call gitgutter#hunk#text_object(0)<CR>
-xnoremap <silent> <Plug>(GitGutterTextObjectInnerVisual)  :<C-U>call gitgutter#hunk#text_object(1)<CR>
-xnoremap <silent> <Plug>(GitGutterTextObjectOuterVisual)  :<C-U>call gitgutter#hunk#text_object(0)<CR>
-
-
-" Returns the git-diff hunks for the file or an empty list if there
-" aren't any hunks.
-"
-" The return value is a list of lists.  There is one inner list per hunk.
-"
-"   [
-"     [from_line, from_count, to_line, to_count],
-"     [from_line, from_count, to_line, to_count],
-"     ...
-"   ]
-"
-" where:
-"
-" `from`  - refers to the staged file
-" `to`    - refers to the working tree's file
-" `line`  - refers to the line number where the change starts
-" `count` - refers to the number of lines the change covers
-function! GitGutterGetHunks()
-  let bufnr = bufnr('')
-  return gitgutter#utility#is_active(bufnr) ? gitgutter#hunk#hunks(bufnr) : []
-endfunction
-
-" Returns an array that contains a summary of the hunk status for the current
-" window.  The format is [ added, modified, removed ], where each value
-" represents the number of lines added/modified/removed respectively.
-function! GitGutterGetHunkSummary()
-  return gitgutter#hunk#summary(winbufnr(0))
-endfunction
-
-" }}}
-
-" Folds {{{
-
-command! -bar GitGutterFold call gitgutter#fold#toggle()
-
-" }}}
-
-command! -bar GitGutterDebug call gitgutter#debug#debug()
-
-" Maps {{{
-
-nnoremap <silent> <expr> <Plug>(GitGutterNextHunk) &diff ? ']c' : ":\<C-U>execute v:count1 . 'GitGutterNextHunk'\<CR>"
-nnoremap <silent> <expr> <Plug>GitGutterNextHunk   &diff ? ']c' : ":\<C-U>call gitgutter#utility#warn('please change your map \<lt>Plug>GitGutterNextHunk to \<lt>Plug>(GitGutterNextHunk)')\<CR>"
-nnoremap <silent> <expr> <Plug>(GitGutterPrevHunk) &diff ? '[c' : ":\<C-U>execute v:count1 . 'GitGutterPrevHunk'\<CR>"
-nnoremap <silent> <expr> <Plug>GitGutterPrevHunk   &diff ? '[c' : ":\<C-U>call gitgutter#utility#warn('please change your map \<lt>Plug>GitGutterPrevHunk to \<lt>Plug>(GitGutterPrevHunk)')\<CR>"
-
-xnoremap <silent> <Plug>(GitGutterStageHunk)   :GitGutterStageHunk<CR>
-xnoremap <silent> <Plug>GitGutterStageHunk     :call gitgutter#utility#warn('please change your map <lt>Plug>GitGutterStageHunk to <lt>Plug>(GitGutterStageHunk)')<CR>
-nnoremap <silent> <Plug>(GitGutterStageHunk)   :GitGutterStageHunk<CR>
-nnoremap <silent> <Plug>GitGutterStageHunk     :call gitgutter#utility#warn('please change your map <lt>Plug>GitGutterStageHunk to <lt>Plug>(GitGutterStageHunk)')<CR>
-nnoremap <silent> <Plug>(GitGutterUndoHunk)    :GitGutterUndoHunk<CR>
-nnoremap <silent> <Plug>GitGutterUndoHunk      :call gitgutter#utility#warn('please change your map <lt>Plug>GitGutterUndoHunk to <lt>Plug>(GitGutterUndoHunk)')<CR>
-nnoremap <silent> <Plug>(GitGutterPreviewHunk) :GitGutterPreviewHunk<CR>
-nnoremap <silent> <Plug>GitGutterPreviewHunk   :call gitgutter#utility#warn('please change your map <lt>Plug>GitGutterPreviewHunk to <lt>Plug>(GitGutterPreviewHunk)')<CR>
-
-" }}}
-
-function! s:on_bufenter()
-  call gitgutter#setup_maps()
-
-  if exists('t:gitgutter_didtabenter') && t:gitgutter_didtabenter
-    let t:gitgutter_didtabenter = 0
-    call gitgutter#all(!g:gitgutter_terminal_reports_focus)
-  else
-    call gitgutter#process_buffer(bufnr(''), !g:gitgutter_terminal_reports_focus)
-  endif
-endfunction
-
-" Autocommands {{{
-
-augroup gitgutter
-  autocmd!
-
-  autocmd TabEnter * let t:gitgutter_didtabenter = 1
-
-  autocmd BufEnter * call s:on_bufenter()
-
-  autocmd CursorHold,CursorHoldI * call gitgutter#process_buffer(bufnr(''), 0)
-  if exists('*timer_start') && has('lambda')
-    autocmd FileChangedShellPost * call timer_start(1, {-> gitgutter#process_buffer(bufnr(''), 1)})
-  else
-    autocmd FileChangedShellPost * call gitgutter#process_buffer(bufnr(''), 1)
-  endif
-
-  " Ensure that all buffers are processed when opening vim with multiple files, e.g.:
-  "
-  "   vim -o file1 file2
-  autocmd VimEnter * if winnr() != winnr('$') | call gitgutter#all(0) | endif
-
-  autocmd ShellCmdPost * call gitgutter#all(1)
-  autocmd BufLeave term://* call gitgutter#all(1)
-
-  autocmd User FugitiveChanged call gitgutter#all(1)
-
-  autocmd BufFilePre  * GitGutterBufferDisable
-  autocmd BufFilePost * GitGutterBufferEnable
-
-  " Handle all buffers when focus is gained, but only after it was lost.
-  " FocusGained gets triggered on startup with Neovim at least already.
-  " Therefore this tracks also if it was lost before.
-  let s:focus_was_lost = 0
-  autocmd FocusGained * if s:focus_was_lost | let focus_was_lost = 0 | call gitgutter#all(1) | endif
-  autocmd FocusLost * let s:focus_was_lost = 1
-
-  if exists('##VimResume')
-    autocmd VimResume * call gitgutter#all(1)
-  endif
-
-  autocmd ColorScheme * call gitgutter#highlight#define_highlights()
-
-  " Disable during :vimgrep
-  autocmd QuickFixCmdPre  *vimgrep* let g:gitgutter_enabled = 0
-  autocmd QuickFixCmdPost *vimgrep* let g:gitgutter_enabled = 1
-augroup END
-
-" }}}
-
-" vim:set et sw=2 fdm=marker:
diff --git a/sources_non_forked/vim-gitgutter/screenshot.png b/sources_non_forked/vim-gitgutter/screenshot.png
deleted file mode 100644
index 8a0d66b..0000000
Binary files a/sources_non_forked/vim-gitgutter/screenshot.png and /dev/null differ
diff --git a/sources_non_forked/vim-gitgutter/test/cp932.txt b/sources_non_forked/vim-gitgutter/test/cp932.txt
deleted file mode 100644
index 80cb10b..0000000
--- a/sources_non_forked/vim-gitgutter/test/cp932.txt
+++ /dev/null
@@ -1,8 +0,0 @@
-The quick brown fox jumps
-over the lazy dog
-
-
-
-
-
-
diff --git a/sources_non_forked/vim-gitgutter/test/fixture.txt b/sources_non_forked/vim-gitgutter/test/fixture.txt
deleted file mode 100644
index f5c6aff..0000000
--- a/sources_non_forked/vim-gitgutter/test/fixture.txt
+++ /dev/null
@@ -1,11 +0,0 @@
-a
-b
-c
-d
-e
-f
-g
-h
-i
-j
-
diff --git a/sources_non_forked/vim-gitgutter/test/fixture_dos.txt b/sources_non_forked/vim-gitgutter/test/fixture_dos.txt
deleted file mode 100644
index 0cabc2b..0000000
--- a/sources_non_forked/vim-gitgutter/test/fixture_dos.txt
+++ /dev/null
@@ -1,11 +0,0 @@
-a
-b
-c
-d
-e
-f
-g
-h
-i
-j
-
diff --git a/sources_non_forked/vim-gitgutter/test/runner.vim b/sources_non_forked/vim-gitgutter/test/runner.vim
deleted file mode 100644
index 630693c..0000000
--- a/sources_non_forked/vim-gitgutter/test/runner.vim
+++ /dev/null
@@ -1,162 +0,0 @@
-"
-" Adapted from https://github.com/vim/vim/blob/master/src/testdir/runtest.vim
-"
-" When debugging tests it can help to write debug output:
-"    call Log('oh noes')
-"
-
-function RunTest(test)
-  if exists("*SetUp")
-    call SetUp()
-  endif
-
-  try
-    execute 'call '.a:test
-  catch
-    call Exception()
-    let s:errored = 1
-  endtry
-
-  if exists("*TearDown")
-    call TearDown()
-  endif
-endfunction
-
-function Log(msg)
-  if type(a:msg) == type('')
-    call add(s:messages, a:msg)
-  elseif type(a:msg) == type([])
-    call extend(s:messages, a:msg)
-  else
-    call add(v:errors, 'Exception: unsupported type: '.type(a:msg))
-  endif
-endfunction
-
-function Exception()
-  call add(v:errors, v:throwpoint.'..'.'Exception: '.v:exception)
-endfunction
-
-" Shuffles list in place.
-function Shuffle(list)
-  " Fisher-Yates-Durstenfeld-Knuth
-  let n = len(a:list)
-  if n < 2
-    return a:list
-  endif
-  for i in range(0, n-2)
-    let j = Random(0, n-i-1)
-    let e = a:list[i]
-    let a:list[i] = a:list[i+j]
-    let a:list[i+j] = e
-  endfor
-  return a:list
-endfunction
-
-" Returns a pseudorandom integer i such that 0 <= i <= max
-function Random(min, max)
-  if has('unix')
-    let i = system('echo $RANDOM')  " 0 <= i <= 32767
-  else
-    let i = system('echo %RANDOM%')  " 0 <= i <= 32767
-  endif
-  return i * (a:max - a:min + 1) / 32768 + a:min
-endfunction
-
-function FriendlyName(test_name)
-  return substitute(a:test_name[5:-3], '_', ' ', 'g')
-endfunction
-
-function Align(left, right)
-  if type(a:right) == type([])
-    let result = []
-    for s in a:right
-      if empty(result)
-        call add(result, printf('%-'.s:indent.'S', a:left).s)
-      else
-        call add(result, printf('%-'.s:indent.'S',     '').s)
-      endif
-    endfor
-    return result
-  endif
-
-  return printf('%-'.s:indent.'S', a:left).a:right
-endfunction
-
-let g:testname = expand('%')
-let s:errored = 0
-let s:done = 0
-let s:fail = 0
-let s:errors = 0
-let s:messages = []
-let s:indent = ''
-
-call Log(g:testname.':')
-
-" Source the test script.
-try
-  source %
-catch
-  let s:errors += 1
-  call Exception()
-endtry
-
-" Locate the test functions.
-set nomore
-redir @q
-silent function /^Test_
-redir END
-let s:tests = split(substitute(@q, 'function \(\k*()\)', '\1', 'g'))
-
-" If there is another argument, filter test-functions' names against it.
-if argc() > 1
-  let s:tests = filter(s:tests, 'v:val =~ argv(1)')
-endif
-
-let s:indent = max(map(copy(s:tests), {_, val -> len(FriendlyName(val))}))
-
-" Run the tests in random order.
-for test in Shuffle(s:tests)
-  call RunTest(test)
-  let s:done += 1
-
-  let friendly_name = FriendlyName(test)
-  if len(v:errors) == 0
-    call Log(Align(friendly_name, ' - ok'))
-  else
-    if s:errored
-      let s:errors += 1
-      let s:errored = 0
-    else
-      let s:fail += 1
-    endif
-    call Log(Align(friendly_name, ' - not ok'))
-
-    let i = 0
-    for error in v:errors
-      if i != 0
-        call Log(Align('','   ! ----'))
-      endif
-      for trace in reverse(split(error, '\.\.'))
-        call Log(Align('', '   ! '.trace))
-      endfor
-      let i += 1
-    endfor
-
-    let v:errors = []
-  endif
-endfor
-
-let summary = [
-      \ s:done.(  s:done   == 1 ? ' test'    : ' tests'),
-      \ s:errors.(s:errors == 1 ? ' error'   : ' errors'),
-      \ s:fail.(  s:fail   == 1 ? ' failure' : ' failures'),
-      \ ]
-call Log('')
-call Log(join(summary, ', '))
-
-split messages.log
-call append(line('$'), s:messages)
-write
-
-qall!
-
diff --git a/sources_non_forked/vim-gitgutter/test/test b/sources_non_forked/vim-gitgutter/test/test
deleted file mode 100644
index cffe927..0000000
--- a/sources_non_forked/vim-gitgutter/test/test
+++ /dev/null
@@ -1,21 +0,0 @@
-#!/usr/bin/env bash
-
-VIM="/Applications/MacVim.app/Contents/MacOS/Vim -v"
-
-export VIM_GITGUTTER_TEST=1
-
-$VIM -u NONE -U NONE -N                      \
-  --cmd 'set rtp+=../'                       \
-  --cmd 'let g:gitgutter_async=0'            \
-  --cmd 'source ../plugin/gitgutter.vim'     \
-  -S runner.vim                              \
-  test_*.vim                                 \
-  "$@"
-
-cat messages.log
-
-grep -q "0 errors, 0 failures" messages.log
-status=$?
-rm messages.log
-exit $status
-
diff --git a/sources_non_forked/vim-gitgutter/test/test_gitgutter.vim b/sources_non_forked/vim-gitgutter/test/test_gitgutter.vim
deleted file mode 100644
index e75f21b..0000000
--- a/sources_non_forked/vim-gitgutter/test/test_gitgutter.vim
+++ /dev/null
@@ -1,1113 +0,0 @@
-let s:current_dir = expand('%:p:h')
-let s:test_repo   = s:current_dir.'/test-repo'
-let s:bufnr       = bufnr('')
-
-"
-" Helpers
-"
-
-" Ignores unexpected keys in actual.
-function s:assert_list_of_dicts(expected, actual)
-  if empty(a:expected)
-    call assert_equal([], a:actual)
-    return
-  endif
-
-  let expected_keys = keys(a:expected[0])
-
-  for dict in a:actual
-    for k in keys(dict)
-      if index(expected_keys, k) == -1
-        call remove(dict, k)
-      endif
-    endfor
-  endfor
-
-  call assert_equal(a:expected, a:actual)
-endfunction
-
-" Ignores unexpected keys.
-"
-" expected - list of signs
-function s:assert_signs(expected, filename)
-  let actual = sign_getplaced(a:filename, {'group': 'gitgutter'})[0].signs
-  call s:assert_list_of_dicts(a:expected, actual)
-endfunction
-
-function s:git_diff(...)
-  return split(system('git diff -U0 '.(a:0 ? a:1 : 'fixture.txt')), '\n')
-endfunction
-
-function s:git_diff_staged(...)
-  return split(system('git diff -U0 --staged '.(a:0 ? a:1 : 'fixture.txt')), '\n')
-endfunction
-
-function s:trigger_gitgutter()
-  doautocmd CursorHold
-endfunction
-
-
-"
-" SetUp / TearDown
-"
-
-function SetUp()
-  call system("git init ".s:test_repo.
-        \ " && cd ".s:test_repo.
-        \ " && cp ../fixture.txt .".
-        \ " && cp ../fixture_dos.txt .".
-        \ " && git add . && git commit -m 'initial'".
-        \ " && git config diff.mnemonicPrefix false")
-  execute ':cd' s:test_repo
-  edit! fixture.txt
-  call gitgutter#sign#reset()
-
-  " FIXME why won't vim autoload the file?
-  execute 'source' '../../autoload/gitgutter/diff_highlight.vim'
-  execute 'source' '../../autoload/gitgutter/fold.vim'
-endfunction
-
-function TearDown()
-  " delete all buffers except this one
-  " TODO: move to runner.vim, accounting for multiple test files
-  if s:bufnr > 1
-    silent! execute '1,'.s:bufnr-1.'bdelete!'
-  endif
-  silent! execute s:bufnr+1.',$bdelete!'
-
-  execute ':cd' s:current_dir
-  call system("rm -rf ".s:test_repo)
-endfunction
-
-"
-" The tests
-"
-
-function Test_add_lines()
-  normal ggo*
-  call s:trigger_gitgutter()
-
-  let expected = [{'lnum': 2, 'name': 'GitGutterLineAdded', 'group': 'gitgutter', 'priority': 10}]
-  call s:assert_signs(expected, 'fixture.txt')
-endfunction
-
-
-function Test_add_lines_fish()
-  let _shell = &shell
-  set shell=/usr/local/bin/fish
-
-  normal ggo*
-  call s:trigger_gitgutter()
-
-  let expected = [{'lnum': 2, 'name': 'GitGutterLineAdded'}]
-  call s:assert_signs(expected, 'fixture.txt')
-
-  let &shell = _shell
-endfunction
-
-
-function Test_modify_lines()
-  normal ggi*
-  call s:trigger_gitgutter()
-
-  let expected = [{'lnum': 1, 'name': 'GitGutterLineModified'}]
-  call s:assert_signs(expected, 'fixture.txt')
-endfunction
-
-
-function Test_remove_lines()
-  execute '5d'
-  call s:trigger_gitgutter()
-
-  let expected = [{'lnum': 4, 'name': 'GitGutterLineRemoved'}]
-  call s:assert_signs(expected, 'fixture.txt')
-endfunction
-
-
-function Test_remove_first_lines()
-  execute '1d'
-  call s:trigger_gitgutter()
-
-  let expected = [{'lnum': 1, 'name': 'GitGutterLineRemovedFirstLine'}]
-  call s:assert_signs(expected, 'fixture.txt')
-endfunction
-
-
-function Test_priority()
-  let g:gitgutter_sign_priority = 5
-
-  execute '1d'
-  call s:trigger_gitgutter()
-
-  call s:assert_signs([{'priority': 5}], 'fixture.txt')
-
-  let g:gitgutter_sign_priority = 10
-endfunction
-
-
-function Test_overlapping_hunks()
-  execute '3d'
-  execute '1d'
-  call s:trigger_gitgutter()
-
-  let expected = [{'lnum': 1, 'name': 'GitGutterLineRemovedAboveAndBelow'}]
-  call s:assert_signs(expected, 'fixture.txt')
-endfunction
-
-
-function Test_edit_file_with_same_name_as_a_branch()
-  normal 5Gi*
-  call system('git checkout -b fixture.txt')
-  call s:trigger_gitgutter()
-
-  let expected = [{'lnum': 5, 'name': 'GitGutterLineModified'}]
-  call s:assert_signs(expected, 'fixture.txt')
-endfunction
-
-
-function Test_file_added_to_git()
-  let tmpfile = 'fileAddedToGit.tmp'
-  call system('touch '.tmpfile.' && git add '.tmpfile)
-  execute 'edit '.tmpfile
-  normal ihello
-  call s:trigger_gitgutter()
-
-  let expected = [{'lnum': 1, 'name': 'GitGutterLineAdded'}]
-  call s:assert_signs(expected, 'fileAddedToGit.tmp')
-endfunction
-
-
-function Test_filename_with_equals()
-  call system('touch =fixture=.txt && git add =fixture=.txt')
-  edit =fixture=.txt
-  normal ggo*
-  call s:trigger_gitgutter()
-
-  let expected = [
-        \ {'lnum': 1, 'name': 'GitGutterLineAdded'},
-        \ {'lnum': 2, 'name': 'GitGutterLineAdded'}
-        \ ]
-  call s:assert_signs(expected, '=fixture=.txt')
-endfunction
-
-
-function Test_filename_with_square_brackets()
-  call system('touch fix[tu]re.txt && git add fix[tu]re.txt')
-  edit fix[tu]re.txt
-  normal ggo*
-  call s:trigger_gitgutter()
-
-  let expected = [
-        \ {'lnum': 1, 'name': 'GitGutterLineAdded'},
-        \ {'lnum': 2, 'name': 'GitGutterLineAdded'}
-        \ ]
-  call s:assert_signs(expected, 'fix[tu]re.txt')
-endfunction
-
-
-function Test_filename_leading_dash()
-  call system('touch -- -fixture.txt && git add -- -fixture.txt')
-  edit -fixture.txt
-  normal ggo*
-  call s:trigger_gitgutter()
-
-  let expected = [
-        \ {'lnum': 1, 'name': 'GitGutterLineAdded'},
-        \ {'lnum': 2, 'name': 'GitGutterLineAdded'}
-        \ ]
-  call s:assert_signs(expected, '-fixture.txt')
-endfunction
-
-
-function Test_filename_umlaut()
-  call system('touch -- fixtre.txt && git add -- fixtre.txt')
-  edit fixtre.txt
-  normal ggo*
-  call s:trigger_gitgutter()
-
-  let expected = [
-        \ {'lnum': 1, 'name': 'GitGutterLineAdded'},
-        \ {'lnum': 2, 'name': 'GitGutterLineAdded'}
-        \ ]
-  call s:assert_signs(expected, 'fixtre.txt')
-endfunction
-
-
-" FIXME: this test fails when it is the first (or only) test to be run
-function Test_follow_symlink()
-  let tmp = 'symlink'
-  call system('ln -nfs fixture.txt '.tmp)
-  execute 'edit '.tmp
-  6d
-  call s:trigger_gitgutter()
-
-  let expected = [{'lnum': 5, 'name': 'GitGutterLineRemoved'}]
-  call s:assert_signs(expected, 'symlink')
-endfunction
-
-
-function Test_keep_alt()
-  enew
-  execute "normal! \<C-^>"
-
-  call assert_equal('fixture.txt', bufname(''))
-  call assert_equal('',            bufname('#'))
-
-  normal ggx
-  call s:trigger_gitgutter()
-
-  call assert_equal('', bufname('#'))
-endfunction
-
-
-function Test_keep_modified()
-  normal 5Go*
-  call assert_equal(1, getbufvar('', '&modified'))
-
-  call s:trigger_gitgutter()
-
-  call assert_equal(1, getbufvar('', '&modified'))
-endfunction
-
-
-function Test_keep_op_marks()
-  normal 5Go*
-  call assert_equal([0,6,1,0], getpos("'["))
-  call assert_equal([0,6,2,0], getpos("']"))
-
-  call s:trigger_gitgutter()
-
-  call assert_equal([0,6,1,0], getpos("'["))
-  call assert_equal([0,6,2,0], getpos("']"))
-endfunction
-
-
-function Test_no_modifications()
-  call s:assert_signs([], 'fixture.txt')
-endfunction
-
-
-function Test_orphaned_signs()
-  execute "normal 5GoX\<CR>Y"
-  call s:trigger_gitgutter()
-  6d
-  call s:trigger_gitgutter()
-
-  let expected = [{'lnum': 6, 'name': 'GitGutterLineAdded'}]
-  call s:assert_signs(expected, 'fixture.txt')
-endfunction
-
-
-function Test_untracked_file_outside_repo()
-  let tmp = tempname()
-  call system('touch '.tmp)
-  execute 'edit '.tmp
-
-  call s:assert_signs([], tmp)
-endfunction
-
-
-function Test_untracked_file_within_repo()
-  let tmp = 'untrackedFileWithinRepo.tmp'
-  call system('touch '.tmp)
-  execute 'edit '.tmp
-  normal ggo*
-  call s:trigger_gitgutter()
-
-  call s:assert_signs([], tmp)
-  call assert_equal(-2, b:gitgutter.path)
-
-  call system('rm '.tmp)
-endfunction
-
-
-function Test_untracked_file_square_brackets_within_repo()
-  let tmp = '[un]trackedFileWithinRepo.tmp'
-  call system('touch '.tmp)
-  execute 'edit '.tmp
-  normal ggo*
-  call s:trigger_gitgutter()
-
-  call s:assert_signs([], tmp)
-
-  call system('rm '.tmp)
-endfunction
-
-
-function Test_hunk_outside_noop()
-  5
-  GitGutterStageHunk
-
-  call s:assert_signs([], 'fixture.txt')
-  call assert_equal([], s:git_diff())
-  call assert_equal([], s:git_diff_staged())
-
-  GitGutterUndoHunk
-
-  call s:assert_signs([], 'fixture.txt')
-  call assert_equal([], s:git_diff())
-  call assert_equal([], s:git_diff_staged())
-endfunction
-
-
-function Test_preview()
-  normal 5Gi*
-  GitGutterPreviewHunk
-
-  wincmd P
-  call assert_equal(2, line('$'))
-  call assert_equal('-e', getline(1))
-  call assert_equal('+*e', getline(2))
-  wincmd p
-endfunction
-
-
-function Test_preview_dos()
-  edit! fixture_dos.txt
-
-  normal 5Gi*
-  GitGutterPreviewHunk
-
-  wincmd P
-  call assert_equal(2, line('$'))
-  call assert_equal('-e', getline(1))
-  call assert_equal('+*e', getline(2))
-  wincmd p
-endfunction
-
-
-
-
-function Test_hunk_stage()
-  let _shell = &shell
-  set shell=foo
-
-  normal 5Gi*
-  GitGutterStageHunk
-
-  call assert_equal('foo', &shell)
-  let &shell = _shell
-
-  call s:assert_signs([], 'fixture.txt')
-
-  " Buffer is unsaved
-  let expected = [
-        \ 'diff --git a/fixture.txt b/fixture.txt',
-        \ 'index ae8e546..f5c6aff 100644',
-        \ '--- a/fixture.txt',
-        \ '+++ b/fixture.txt',
-        \ '@@ -5 +5 @@ d',
-        \ '-*e',
-        \ '+e'
-        \ ]
-  call assert_equal(expected, s:git_diff())
-
-  " Index has been updated
-  let expected = [
-        \ 'diff --git a/fixture.txt b/fixture.txt',
-        \ 'index f5c6aff..ae8e546 100644',
-        \ '--- a/fixture.txt',
-        \ '+++ b/fixture.txt',
-        \ '@@ -5 +5 @@ d',
-        \ '-e',
-        \ '+*e'
-        \ ]
-  call assert_equal(expected, s:git_diff_staged())
-
-  " Save the buffer
-  write
-
-  call assert_equal([], s:git_diff())
-endfunction
-
-
-function Test_hunk_stage_nearby_hunk()
-  execute "normal! 2Gox\<CR>y\<CR>z"
-  normal 2jdd
-  normal k
-  GitGutterStageHunk
-
-  let expected = [
-        \ {'lnum': 3, 'name': 'GitGutterLineAdded'},
-        \ {'lnum': 4, 'name': 'GitGutterLineAdded'},
-        \ {'lnum': 5, 'name': 'GitGutterLineAdded'}
-        \ ]
-  call s:assert_signs(expected, 'fixture.txt')
-
-  " Buffer is unsaved
-  let expected = [
-        \ 'diff --git a/fixture.txt b/fixture.txt',
-        \ 'index 53b13df..f5c6aff 100644',
-        \ '--- a/fixture.txt',
-        \ '+++ b/fixture.txt',
-        \ '@@ -3,0 +4 @@ c',
-        \ '+d',
-        \ ]
-  call assert_equal(expected, s:git_diff())
-
-  " Index has been updated
-  let expected = [
-        \ 'diff --git a/fixture.txt b/fixture.txt',
-        \ 'index f5c6aff..53b13df 100644',
-        \ '--- a/fixture.txt',
-        \ '+++ b/fixture.txt',
-        \ '@@ -4 +3,0 @@ c',
-        \ '-d',
-        \ ]
-  call assert_equal(expected, s:git_diff_staged())
-
-  " Save the buffer
-  write
-
-  let expected = [
-        \ 'diff --git a/fixture.txt b/fixture.txt',
-        \ 'index 53b13df..8fdfda7 100644',
-        \ '--- a/fixture.txt',
-        \ '+++ b/fixture.txt',
-        \ '@@ -2,0 +3,3 @@ b',
-        \ '+x',
-        \ '+y',
-        \ '+z',
-        \ ]
-  call assert_equal(expected, s:git_diff())
-endfunction
-
-
-function Test_hunk_stage_partial_visual_added()
-  call append(5, ['A','B','C','D'])
-  execute "normal 7GVj:GitGutterStageHunk\<CR>"
-
-  let expected = [
-        \ {'lnum': 6, 'name': 'GitGutterLineAdded'},
-        \ {'lnum': 9, 'name': 'GitGutterLineAdded'},
-        \ ]
-  call s:assert_signs(expected, 'fixture.txt')
-
-  let expected = [
-        \ 'diff --git a/fixture.txt b/fixture.txt',
-        \ 'index 8a7026e..f5c6aff 100644',
-        \ '--- a/fixture.txt',
-        \ '+++ b/fixture.txt',
-        \ '@@ -6,2 +5,0 @@ e',
-        \ '-B',
-        \ '-C',
-        \ ]
-  call assert_equal(expected, s:git_diff())
-
-  let expected = [
-        \ 'diff --git a/fixture.txt b/fixture.txt',
-        \ 'index f5c6aff..8a7026e 100644',
-        \ '--- a/fixture.txt',
-        \ '+++ b/fixture.txt',
-        \ '@@ -5,0 +6,2 @@ e',
-        \ '+B',
-        \ '+C',
-        \ ]
-  call assert_equal(expected, s:git_diff_staged())
-endfunction
-
-
-function Test_hunk_stage_partial_cmd_added()
-  call append(5, ['A','B','C','D'])
-  6
-  7,8GitGutterStageHunk
-
-  let expected = [
-        \ {'lnum': 6, 'name': 'GitGutterLineAdded'},
-        \ {'lnum': 9, 'name': 'GitGutterLineAdded'},
-        \ ]
-  call s:assert_signs(expected, 'fixture.txt')
-
-  let expected = [
-        \ 'diff --git a/fixture.txt b/fixture.txt',
-        \ 'index 8a7026e..f5c6aff 100644',
-        \ '--- a/fixture.txt',
-        \ '+++ b/fixture.txt',
-        \ '@@ -6,2 +5,0 @@ e',
-        \ '-B',
-        \ '-C',
-        \ ]
-  call assert_equal(expected, s:git_diff())
-
-  let expected = [
-        \ 'diff --git a/fixture.txt b/fixture.txt',
-        \ 'index f5c6aff..8a7026e 100644',
-        \ '--- a/fixture.txt',
-        \ '+++ b/fixture.txt',
-        \ '@@ -5,0 +6,2 @@ e',
-        \ '+B',
-        \ '+C',
-        \ ]
-  call assert_equal(expected, s:git_diff_staged())
-endfunction
-
-
-function Test_hunk_stage_partial_preview_added()
-  call append(5, ['A','B','C','D'])
-  6
-  GitGutterPreviewHunk
-  wincmd P
-
-  " remove C and A so we stage B and D
-  3delete
-  1delete
-
-  GitGutterStageHunk
-  write
-
-  let expected = [
-        \ {'lnum': 6, 'name': 'GitGutterLineAdded'},
-        \ {'lnum': 8, 'name': 'GitGutterLineAdded'},
-        \ ]
-  call s:assert_signs(expected, 'fixture.txt')
-
-  let expected = [
-        \ 'diff --git a/fixture.txt b/fixture.txt',
-        \ 'index 975852f..3dd23a3 100644',
-        \ '--- a/fixture.txt',
-        \ '+++ b/fixture.txt',
-        \ '@@ -5,0 +6 @@ e',
-        \ '+A',
-        \ '@@ -6,0 +8 @@ B',
-        \ '+C',
-        \ ]
-  call assert_equal(expected, s:git_diff())
-
-  let expected = [
-        \ 'diff --git a/fixture.txt b/fixture.txt',
-        \ 'index f5c6aff..975852f 100644',
-        \ '--- a/fixture.txt',
-        \ '+++ b/fixture.txt',
-        \ '@@ -5,0 +6,2 @@ e',
-        \ '+B',
-        \ '+D',
-        \ ]
-  call assert_equal(expected, s:git_diff_staged())
-endfunction
-
-
-function Test_hunk_stage_preview_write()
-  call append(5, ['A','B','C','D'])
-  6
-  GitGutterPreviewHunk
-  wincmd P
-
-  " preview window
-  call feedkeys(":w\<CR>", 'tx')
-  " original window
-  write
-
-  call s:assert_signs([], 'fixture.txt')
-
-  call assert_equal([], s:git_diff())
-
-  let expected = [
-        \ 'diff --git a/fixture.txt b/fixture.txt',
-        \ 'index f5c6aff..3dd23a3 100644',
-        \ '--- a/fixture.txt',
-        \ '+++ b/fixture.txt',
-        \ '@@ -5,0 +6,4 @@ e',
-        \ '+A',
-        \ '+B',
-        \ '+C',
-        \ '+D',
-        \ ]
-  call assert_equal(expected, s:git_diff_staged())
-endfunction
-
-
-function Test_hunk_stage_partial_preview_added_removed()
-  4,5delete
-  call append(3, ['A','B','C','D'])
-  4
-  GitGutterPreviewHunk
-  wincmd P
-
-  " -d
-  " -e
-  " +A
-  " +B
-  " +C
-  " +D
-
-  " remove D and d so they do not get staged
-  6delete
-  1delete
-
-  GitGutterStageHunk
-  write
-
-  let expected = [
-        \ {'lnum': 3, 'name': 'GitGutterLineRemoved'},
-        \ {'lnum': 7, 'name': 'GitGutterLineAdded'},
-        \ ]
-  call s:assert_signs(expected, 'fixture.txt')
-
-  let expected = [
-        \ 'diff --git a/fixture.txt b/fixture.txt',
-        \ 'index 9a19589..e63fb0a 100644',
-        \ '--- a/fixture.txt',
-        \ '+++ b/fixture.txt',
-        \ '@@ -4 +3,0 @@ c',
-        \ '-d',
-        \ '@@ -7,0 +7 @@ C',
-        \ '+D',
-        \ ]
-  call assert_equal(expected, s:git_diff())
-
-  let expected = [
-        \ 'diff --git a/fixture.txt b/fixture.txt',
-        \ 'index f5c6aff..9a19589 100644',
-        \ '--- a/fixture.txt',
-        \ '+++ b/fixture.txt',
-        \ '@@ -5 +5,3 @@ d',
-        \ '-e',
-        \ '+A',
-        \ '+B',
-        \ '+C',
-        \ ]
-  call assert_equal(expected, s:git_diff_staged())
-endfunction
-
-
-function Test_hunk_undo()
-  let _shell = &shell
-  set shell=foo
-
-  normal 5Gi*
-  GitGutterUndoHunk
-
-  call assert_equal('foo', &shell)
-  let &shell = _shell
-
-  call s:assert_signs([], 'fixture.txt')
-  call assert_equal([], s:git_diff())
-  call assert_equal([], s:git_diff_staged())
-  call assert_equal('e', getline(5))
-endfunction
-
-
-function Test_hunk_undo_dos()
-  edit! fixture_dos.txt
-
-  normal 5Gi*
-  GitGutterUndoHunk
-
-  call s:assert_signs([], 'fixture_dos.txt')
-  call assert_equal([], s:git_diff('fixture_dos.txt'))
-  call assert_equal([], s:git_diff_staged('fixture_dos.txt'))
-  call assert_equal('e', getline(5))
-endfunction
-
-
-function Test_undo_nearby_hunk()
-  execute "normal! 2Gox\<CR>y\<CR>z"
-  normal 2jdd
-  normal k
-  call s:trigger_gitgutter()
-  GitGutterUndoHunk
-  call s:trigger_gitgutter()
-
-  let expected = [
-        \ {'lnum': 3, 'name': 'GitGutterLineAdded'},
-        \ {'lnum': 4, 'name': 'GitGutterLineAdded'},
-        \ {'lnum': 5, 'name': 'GitGutterLineAdded'}
-        \ ]
-  call s:assert_signs(expected, 'fixture.txt')
-
-  call assert_equal([], s:git_diff())
-
-  call assert_equal([], s:git_diff_staged())
-
-  " Save the buffer
-  write
-
-  let expected = [
-        \ 'diff --git a/fixture.txt b/fixture.txt',
-        \ 'index f5c6aff..3fbde56 100644',
-        \ '--- a/fixture.txt',
-        \ '+++ b/fixture.txt',
-        \ '@@ -2,0 +3,3 @@ b',
-        \ '+x',
-        \ '+y',
-        \ '+z',
-        \ ]
-  call assert_equal(expected, s:git_diff())
-
-endfunction
-
-
-function Test_overlapping_hunk_op()
-  func Answer(char)
-    call feedkeys(a:char."\<CR>")
-  endfunc
-
-  " Undo upper
-
-  execute '3d'
-  execute '1d'
-  call s:trigger_gitgutter()
-  normal gg
-  call timer_start(100, {-> Answer('u')} )
-  GitGutterUndoHunk
-  call s:trigger_gitgutter()
-
-  let expected = [{'lnum': 2, 'name': 'GitGutterLineRemoved'}]
-  call s:assert_signs(expected, 'fixture.txt')
-
-  " Undo lower
-
-  execute '1d'
-  call s:trigger_gitgutter()
-  normal gg
-  call timer_start(100, {-> Answer('l')} )
-  GitGutterUndoHunk
-  call s:trigger_gitgutter()
-
-  let expected = [{'lnum': 1, 'name': 'GitGutterLineRemovedFirstLine'}]
-  call s:assert_signs(expected, 'fixture.txt')
-endfunction
-
-
-function Test_write_option()
-  set nowrite
-
-  normal ggo*
-  call s:trigger_gitgutter()
-
-  let expected = [{'lnum': 2, 'name': 'GitGutterLineAdded'}]
-  call s:assert_signs(expected, 'fixture.txt')
-
-  set write
-endfunction
-
-
-function Test_inner_text_object()
-  execute "normal! 2Gox\<CR>y\<CR>z\<CR>\<CR>"
-  call s:trigger_gitgutter()
-  normal dic
-  call s:trigger_gitgutter()
-
-  call s:assert_signs([], 'fixture.txt')
-  call assert_equal(readfile('fixture.txt'), getline(1,'$'))
-
-  " Excludes trailing lines
-  normal 9Gi*
-  normal 10Gi*
-  call s:trigger_gitgutter()
-  execute "normal vic\<Esc>"
-  call assert_equal([9, 10], [line("'<"), line("'>")])
-endfunction
-
-
-function Test_around_text_object()
-  execute "normal! 2Gox\<CR>y\<CR>z\<CR>\<CR>"
-  call s:trigger_gitgutter()
-  normal dac
-  call s:trigger_gitgutter()
-
-  call s:assert_signs([], 'fixture.txt')
-  call assert_equal(readfile('fixture.txt'), getline(1,'$'))
-
-  " Includes trailing lines
-  normal 9Gi*
-  normal 10Gi*
-  call s:trigger_gitgutter()
-  execute "normal vac\<Esc>"
-  call assert_equal([9, 11], [line("'<"), line("'>")])
-endfunction
-
-
-function Test_user_autocmd()
-  autocmd User GitGutter let s:autocmd_user = g:gitgutter_hook_context.bufnr
-
-  " Verify not fired when nothing changed.
-  let s:autocmd_user = 0
-  call s:trigger_gitgutter()
-  call assert_equal(0, s:autocmd_user)
-
-  " Verify fired when there was a change.
-  normal ggo*
-  let bufnr = bufnr('')
-  call s:trigger_gitgutter()
-  call assert_equal(bufnr, s:autocmd_user)
-endfunction
-
-
-function Test_fix_file_references()
-  " No special characters
-  let hunk_diff = join([
-        \ 'diff --git a/fixture.txt b/fixture.txt',
-        \ 'index f5c6aff..3fbde56 100644',
-        \ '--- a/fixture.txt',
-        \ '+++ b/fixture.txt',
-        \ '@@ -2,0 +3,1 @@ b',
-        \ '+x'
-        \ ], "\n")."\n"
-  let filepath = 'blah.txt'
-
-  let expected = join([
-        \ 'diff --git a/blah.txt b/blah.txt',
-        \ 'index f5c6aff..3fbde56 100644',
-        \ '--- a/blah.txt',
-        \ '+++ b/blah.txt',
-        \ '@@ -2,0 +3,1 @@ b',
-        \ '+x'
-        \ ], "\n")."\n"
-
-  call assert_equal(expected, gitgutter#hunk#fix_file_references(filepath, hunk_diff))
-
-  " diff.mnemonicPrefix; spaces in filename
-  let hunk_diff = join([
-        \ 'diff --git i/x/cat dog w/x/cat dog',
-        \ 'index f5c6aff..3fbde56 100644',
-        \ '--- i/x/cat dog',
-        \ '+++ w/x/cat dog',
-        \ '@@ -2,0 +3,1 @@ b',
-        \ '+x'
-        \ ], "\n")."\n"
-  let filepath = 'blah.txt'
-
-  let expected = join([
-        \ 'diff --git i/blah.txt w/blah.txt',
-        \ 'index f5c6aff..3fbde56 100644',
-        \ '--- i/blah.txt',
-        \ '+++ w/blah.txt',
-        \ '@@ -2,0 +3,1 @@ b',
-        \ '+x'
-        \ ], "\n")."\n"
-
-  call assert_equal(expected, gitgutter#hunk#fix_file_references(filepath, hunk_diff))
-
-  " Backslashes in filename; quotation marks
-  let hunk_diff = join([
-        \ 'diff --git "a/C:\\Users\\FOO~1.PAR\\AppData\\Local\\Temp\\nvimJcmSv9\\11.1.vim" "b/C:\\Users\\FOO~1.PAR\\AppData\\Local\\Temp\\nvimJcmSv9\\12.1.vim"',
-        \ 'index f42aeb0..4930403 100644',
-        \ '--- "a/C:\\Users\\FOO~1.PAR\\AppData\\Local\\Temp\\nvimJcmSv9\\11.1.vim"',
-        \ '+++ "b/C:\\Users\\FOO~1.PAR\\AppData\\Local\\Temp\\nvimJcmSv9\\12.1.vim"',
-        \ '@@ -172,0 +173 @@ stuff',
-        \ '+x'
-        \ ], "\n")."\n"
-  let filepath = 'init.vim'
-
-  let expected = join([
-        \ 'diff --git "a/init.vim" "b/init.vim"',
-        \ 'index f42aeb0..4930403 100644',
-        \ '--- "a/init.vim"',
-        \ '+++ "b/init.vim"',
-        \ '@@ -172,0 +173 @@ stuff',
-        \ '+x'
-        \ ], "\n")."\n"
-
-  call assert_equal(expected, gitgutter#hunk#fix_file_references(filepath, hunk_diff))
-endfunction
-
-
-function Test_encoding()
-  call system('cp ../cp932.txt . && git add cp932.txt')
-  edit ++enc=cp932 cp932.txt
-
-  call s:trigger_gitgutter()
-
-  call s:assert_signs([], 'cp932.txt')
-endfunction
-
-
-function Test_empty_file()
-  " 0-byte file
-  call system('touch empty.txt && git add empty.txt')
-  edit empty.txt
-
-  call s:trigger_gitgutter()
-  call s:assert_signs([], 'empty.txt')
-
-
-  " File consisting only of a newline
-  call system('echo "" > newline.txt && git add newline.txt')
-  edit newline.txt
-
-  call s:trigger_gitgutter()
-  call s:assert_signs([], 'newline.txt')
-
-
-  " 1 line file without newline
-  " Vim will force a newline unless we tell it not to.
-  call system('echo -n a > oneline.txt && git add oneline.txt')
-  set noeol nofixeol
-  edit! oneline.txt
-
-  call s:trigger_gitgutter()
-  call s:assert_signs([], 'oneline.txt')
-
-  set eol fixeol
-endfunction
-
-
-function Test_quickfix()
-  call setline(5, ['A', 'B'])
-  call setline(9, ['C', 'D'])
-  write
-
-  GitGutterQuickFix
-
-  let expected = [
-        \ {'lnum': 5, 'bufnr': bufnr(''), 'text': '-e'},
-        \ {'lnum': 9, 'bufnr': bufnr(''), 'text': '-i'}
-        \ ]
-
-  call s:assert_list_of_dicts(expected, getqflist())
-endfunction
-
-
-function Test_common_prefix()
-  " zero length
-  call assert_equal(-1, gitgutter#diff_highlight#common_prefix('', 'foo'))
-  call assert_equal(-1, gitgutter#diff_highlight#common_prefix('foo', ''))
-  " nothing in common
-  call assert_equal(-1, gitgutter#diff_highlight#common_prefix('-abcde', '+pqrst'))
-  call assert_equal(-1, gitgutter#diff_highlight#common_prefix('abcde', 'pqrst'))
-  " something in common
-  call assert_equal(-1, gitgutter#diff_highlight#common_prefix('-abcde', '+abcpq'))
-  call assert_equal(2, gitgutter#diff_highlight#common_prefix('abcde', 'abcpq'))
-  call assert_equal(0, gitgutter#diff_highlight#common_prefix('abc', 'apq'))
-  " everything in common
-  call assert_equal(-1, gitgutter#diff_highlight#common_prefix('-abcde', '+abcde'))
-  call assert_equal(4, gitgutter#diff_highlight#common_prefix('abcde', 'abcde'))
-  " different lengths
-  call assert_equal(-1, gitgutter#diff_highlight#common_prefix('-abcde', '+abx'))
-  call assert_equal(1, gitgutter#diff_highlight#common_prefix('abcde', 'abx'))
-  call assert_equal(-1, gitgutter#diff_highlight#common_prefix('-abx',   '+abcde'))
-  call assert_equal(1, gitgutter#diff_highlight#common_prefix('abx',   'abcde'))
-  call assert_equal(-1, gitgutter#diff_highlight#common_prefix('-abcde', '+abc'))
-  call assert_equal(2, gitgutter#diff_highlight#common_prefix('abcde', 'abc'))
-endfunction
-
-
-function Test_common_suffix()
-  " nothing in common
-  call assert_equal([6,6], gitgutter#diff_highlight#common_suffix('-abcde', '+pqrst', 0))
-  " something in common
-  call assert_equal([3,3], gitgutter#diff_highlight#common_suffix('-abcde', '+pqcde', 0))
-  " everything in common
-  call assert_equal([5,5], gitgutter#diff_highlight#common_suffix('-abcde', '+abcde', 5))
-  " different lengths
-  call assert_equal([4,2], gitgutter#diff_highlight#common_suffix('-abcde', '+xde', 0))
-  call assert_equal([2,4], gitgutter#diff_highlight#common_suffix('-xde',   '+abcde', 0))
-endfunction
-
-
-" Note the order of lists within the overall returned list does not matter.
-function Test_diff_highlight()
-  " Ignores mismatched number of added and removed lines.
-  call assert_equal([], gitgutter#diff_highlight#process(['-foo']))
-  call assert_equal([], gitgutter#diff_highlight#process(['+foo']))
-  call assert_equal([], gitgutter#diff_highlight#process(['-foo','-bar','+baz']))
-
-  " everything changed
-  let hunk = ['-foo', '+cat']
-  let expected = []
-  call assert_equal(expected, gitgutter#diff_highlight#process(hunk))
-
-  " change in middle
-  let hunk = ['-foo bar baz', '+foo zip baz']
-  let expected = [[1, '-', 6, 8], [2, '+', 6, 8]]
-  call assert_equal(expected, gitgutter#diff_highlight#process(hunk))
-
-  " change at start
-  let hunk = ['-foo bar baz', '+zip bar baz']
-  let expected = [[1, '-', 2, 4], [2, '+', 2, 4]]
-  call assert_equal(expected, gitgutter#diff_highlight#process(hunk))
-
-  " change at end
-  let hunk = ['-foo bar baz', '+foo bar zip']
-  let expected = [[1, '-', 10, 12], [2, '+', 10, 12]]
-  call assert_equal(expected, gitgutter#diff_highlight#process(hunk))
-
-  " removed in middle
-  let hunk = ['-foo bar baz', '+foo baz']
-  let expected = [[1, '-', 8, 11]]
-  call assert_equal(expected, gitgutter#diff_highlight#process(hunk))
-
-  " added in middle
-  let hunk = ['-foo baz', '+foo bar baz']
-  let expected = [[2, '+', 8, 11]]
-  call assert_equal(expected, gitgutter#diff_highlight#process(hunk))
-
-  " two insertions at start
-  let hunk = ['-foo bar baz', '+(foo) bar baz']
-  let expected = [[2, '+', 2, 2], [2, '+', 6, 6]]
-  call assert_equal(expected, gitgutter#diff_highlight#process(hunk))
-
-  " two insertions in middle
-  let hunk = ['-foo bar baz', '+foo (bar) baz']
-  let expected = [[2, '+', 6, 6], [2, '+', 10, 10]]
-  call assert_equal(expected, gitgutter#diff_highlight#process(hunk))
-
-  " two insertions at end
-  let hunk = ['-foo bar baz', '+foo bar (baz)']
-  let expected = [[2, '+', 10, 10], [2, '+', 14, 14]]
-  call assert_equal(expected, gitgutter#diff_highlight#process(hunk))
-
-  " singular insertion
-  let hunk = ['-The cat in the hat.', '+The furry cat in the hat.']
-  call assert_equal([[2, '+', 6, 11]], gitgutter#diff_highlight#process(hunk))
-
-  " singular deletion
-  let hunk = ['-The cat in the hat.', '+The cat.']
-  call assert_equal([[1, '-', 9, 19]], gitgutter#diff_highlight#process(hunk))
-
-  " two insertions
-  let hunk = ['-The cat in the hat.', '+The furry cat in the teal hat.']
-  call assert_equal([[2, '+', 6, 11], [2, '+', 22, 26]], gitgutter#diff_highlight#process(hunk))
-
-  " two deletions
-  let hunk = ['-The furry cat in the teal hat.', '+The cat in the hat.']
-  call assert_equal([[1, '-', 6, 11], [1, '-', 22, 26]], gitgutter#diff_highlight#process(hunk))
-
-  " two edits
-  let hunk = ['-The cat in the hat.', '+The ox in the box.']
-  call assert_equal([[1, '-', 6, 8], [2, '+', 6, 7], [1, '-', 17, 19], [2, '+', 16, 18]], gitgutter#diff_highlight#process(hunk))
-
-  " Requires s:gap_between_regions = 2 to pass.
-  " let hunk = ['-foo: bar.zap', '+foo: quux(bar)']
-  " call assert_equal([[2, '+', 7, 11], [1, '-', 10, 13], [2, '+', 15, 15]], gitgutter#diff_highlight#process(hunk))
-
-  let hunk = ['-gross_value: transaction.unexplained_amount', '+gross_value: amount(transaction)']
-  call assert_equal([[2, '+', 15, 21], [1, '-', 26, 44], [2, '+', 33, 33]], gitgutter#diff_highlight#process(hunk))
-
-  let hunk = ['-gem "contact_sport", "~> 1.0.2"', '+gem ("contact_sport"), "~> 1.2"']
-  call assert_equal([[2, '+', 6, 6], [2, '+', 22, 22], [1, '-', 28, 29]], gitgutter#diff_highlight#process(hunk))
-endfunction
-
-
-function Test_lcs()
-  call assert_equal('', gitgutter#diff_highlight#lcs('', 'foo'))
-  call assert_equal('', gitgutter#diff_highlight#lcs('foo', ''))
-  call assert_equal('bar', gitgutter#diff_highlight#lcs('foobarbaz', 'bbart'))
-  call assert_equal('transaction', gitgutter#diff_highlight#lcs('transaction.unexplained_amount', 'amount(transaction)'))
-endfunction
-
-
-function Test_split()
-  call assert_equal(['foo', 'baz'], gitgutter#diff_highlight#split('foobarbaz', 'bar'))
-  call assert_equal(['', 'barbaz'], gitgutter#diff_highlight#split('foobarbaz', 'foo'))
-  call assert_equal(['foobar', ''], gitgutter#diff_highlight#split('foobarbaz', 'baz'))
-  call assert_equal(['1', '2'], gitgutter#diff_highlight#split('1~2', '~'))
-endfunction
-
-
-function Test_foldtext()
-  8d
-  call s:trigger_gitgutter()
-  call assert_equal(0, gitgutter#fold#is_changed())
-
-  let v:foldstart = 5
-  let v:foldend = 9
-  call assert_equal(1, gitgutter#fold#is_changed())
-  call assert_equal('+-  5 lines (*): e', gitgutter#fold#foldtext())
-
-  let v:foldstart = 1
-  let v:foldend = 3
-  call assert_equal(0, gitgutter#fold#is_changed())
-  call assert_equal('+-  3 lines: a', gitgutter#fold#foldtext())
-endfunction
diff --git a/sources_non_forked/vim-javascript/ISSUE_TEMPLATE.md b/sources_non_forked/vim-javascript/ISSUE_TEMPLATE.md
deleted file mode 100644
index b1ddccb..0000000
--- a/sources_non_forked/vim-javascript/ISSUE_TEMPLATE.md
+++ /dev/null
@@ -1,13 +0,0 @@
-*Requisite minimal reproducible example, formatted as plain text :*
-
-<hr>
-
-#### Optional: concerning jsx.
-PLEASE PLEASE PLEASE make sure you have properly
-setup and are sourcing this plugin https://github.com/mxw/vim-jsx
-
-WE DO NOT support JSX automatically, you need another plugin to add get this
-functionality.
-
-Make sure the bug still exists if you disable all other javascript plugins
-except the one noted above, mxw/vim-jsx
diff --git a/sources_non_forked/vim-javascript/README.md b/sources_non_forked/vim-javascript/README.md
deleted file mode 100644
index 06419b2..0000000
--- a/sources_non_forked/vim-javascript/README.md
+++ /dev/null
@@ -1,125 +0,0 @@
-# vim-javascript
-
-JavaScript bundle for vim, this bundle provides syntax highlighting and
-improved indentation.
-
-
-## Installation
-
-### Install with native package manager
-
-      git clone https://github.com/pangloss/vim-javascript.git ~/.vim/pack/vim-javascript/start/vim-javascript
-
-since Vim 8.
-
-### Install with [pathogen](https://github.com/tpope/vim-pathogen)
-
-      git clone https://github.com/pangloss/vim-javascript.git ~/.vim/bundle/vim-javascript
-
-alternatively, use a package manager like [vim-plug](https://github.com/junegunn/vim-plug)
-
-
-## Configuration Variables
-
-The following variables control certain syntax highlighting plugins. You can
-add them to your `.vimrc` to enable their features.
-
------------------
-
-```
-let g:javascript_plugin_jsdoc = 1
-```
-
-Enables syntax highlighting for [JSDocs](http://usejsdoc.org/).
-
-Default Value: 0
-
------------------
-
-```
-let g:javascript_plugin_ngdoc = 1
-```
-
-Enables some additional syntax highlighting for NGDocs. Requires JSDoc plugin
-to be enabled as well.
-
-Default Value: 0
-
------------------
-
-```
-let g:javascript_plugin_flow = 1
-```
-
-Enables syntax highlighting for [Flow](https://flowtype.org/).
-
-Default Value: 0
-
------------------
-
-```vim
-augroup javascript_folding
-    au!
-    au FileType javascript setlocal foldmethod=syntax
-augroup END
-```
-
-Enables code folding for javascript based on our syntax file.
-
-Please note this can have a dramatic effect on performance.
-
-
-## Concealing Characters
-
-You can customize concealing characters, if your font provides the glyph you want, by defining one or more of the following
-variables:
-
-    let g:javascript_conceal_function             = ""
-    let g:javascript_conceal_null                 = ""
-    let g:javascript_conceal_this                 = "@"
-    let g:javascript_conceal_return               = ""
-    let g:javascript_conceal_undefined            = ""
-    let g:javascript_conceal_NaN                  = ""
-    let g:javascript_conceal_prototype            = ""
-    let g:javascript_conceal_static               = ""
-    let g:javascript_conceal_super                = ""
-    let g:javascript_conceal_arrow_function       = ""
-    let g:javascript_conceal_noarg_arrow_function = ""
-    let g:javascript_conceal_underscore_arrow_function = ""
-
-
-You can enable concealing within VIM with:
-
-    set conceallevel=1
-
-OR if you wish to toggle concealing you may wish to bind a command such as the following which will map `<LEADER>l` (leader is usually the `\` key) to toggling conceal mode:
-
-    map <leader>l :exec &conceallevel ? "set conceallevel=0" : "set conceallevel=1"<CR>
-
-
-## Indentation Specific
-
-* `:h cino-:`
-* `:h cino-=`
-* `:h cino-star`
-* `:h cino-(`
-* `:h cino-w`
-* `:h cino-W`
-* `:h cino-U`
-* `:h cino-m`
-* `:h cino-M`
-* `:h 'indentkeys'`
-
-## Contributing
-
-Please follow the general code style
-guides (read the code) and in your pull request explain the reason for the
-proposed change and how it is valuable. All p.r.'s will be reviewed by a
-maintainer(s) then, hopefully, merged.
-
-Thank you!
-
-
-## License
-
-Distributed under the same terms as Vim itself. See `:help license`.
diff --git a/sources_non_forked/vim-javascript/after/ftplugin/javascript.vim b/sources_non_forked/vim-javascript/after/ftplugin/javascript.vim
deleted file mode 100644
index c6c42d6..0000000
--- a/sources_non_forked/vim-javascript/after/ftplugin/javascript.vim
+++ /dev/null
@@ -1,12 +0,0 @@
-" Vim filetype plugin file
-" Language:     JavaScript
-" Maintainer:   vim-javascript community
-" URL:          https://github.com/pangloss/vim-javascript
-
-setlocal iskeyword+=$ suffixesadd+=.js
-
-if exists('b:undo_ftplugin')
-  let b:undo_ftplugin .= ' | setlocal iskeyword< suffixesadd<'
-else
-  let b:undo_ftplugin = 'setlocal iskeyword< suffixesadd<'
-endif
diff --git a/sources_non_forked/vim-javascript/compiler/eslint.vim b/sources_non_forked/vim-javascript/compiler/eslint.vim
deleted file mode 100644
index 7695a07..0000000
--- a/sources_non_forked/vim-javascript/compiler/eslint.vim
+++ /dev/null
@@ -1,16 +0,0 @@
-" Vim compiler plugin
-" Language:     JavaScript
-" Maintainer:   vim-javascript community
-" URL:          https://github.com/pangloss/vim-javascript
-
-if exists("current_compiler")
-  finish
-endif
-let current_compiler = "eslint"
-
-if exists(":CompilerSet") != 2
-  command! -nargs=* CompilerSet setlocal <args>
-endif
-
-CompilerSet makeprg=eslint\ -f\ compact\ %
-CompilerSet errorformat=%f:\ line\ %l\\,\ col\ %c\\,\ %m
diff --git a/sources_non_forked/vim-javascript/extras/ctags b/sources_non_forked/vim-javascript/extras/ctags
deleted file mode 100644
index cdc4edc..0000000
--- a/sources_non_forked/vim-javascript/extras/ctags
+++ /dev/null
@@ -1,8 +0,0 @@
---langdef=js
---langmap=js:.js
---regex-js=/([A-Za-z0-9._$]+)[ \t]*[:=][ \t]*\{/\1/,object/
---regex-js=/([A-Za-z0-9._$()]+)[ \t]*[:=][ \t]*function[ \t]*\(/\1/,function/
---regex-js=/function[ \t]+([A-Za-z0-9._$]+)[ \t]*([^)])/\1/,function/
---regex-js=/([A-Za-z0-9._$]+)[ \t]*[:=][ \t]*\[/\1/,array/
---regex-js=/([^= ]+)[ \t]*=[ \t]*[^"]'[^']*/\1/,string/
---regex-js=/([^= ]+)[ \t]*=[ \t]*[^']"[^"]*/\1/,string/
diff --git a/sources_non_forked/vim-javascript/extras/flow.vim b/sources_non_forked/vim-javascript/extras/flow.vim
deleted file mode 100644
index b34d710..0000000
--- a/sources_non_forked/vim-javascript/extras/flow.vim
+++ /dev/null
@@ -1,109 +0,0 @@
-syntax region  jsFlowDefinition     contained                        start=/:/    end=/\%(\s*[,=;)\n]\)\@=/ contains=@jsFlowCluster containedin=jsParen
-syntax region  jsFlowArgumentDef    contained                        start=/:/    end=/\%(\s*[,)]\|=>\@!\)\@=/ contains=@jsFlowCluster
-syntax region  jsFlowArray          contained matchgroup=jsFlowNoise start=/\[/   end=/\]/        contains=@jsFlowCluster,jsComment fold
-syntax region  jsFlowObject         contained matchgroup=jsFlowNoise start=/{/    end=/}/         contains=@jsFlowCluster,jsComment fold
-syntax region  jsFlowExactObject    contained matchgroup=jsFlowNoise start=/{|/   end=/|}/       contains=@jsFlowCluster,jsComment fold
-syntax region  jsFlowParens         contained matchgroup=jsFlowNoise start=/(/  end=/)/ contains=@jsFlowCluster nextgroup=jsFlowArrow skipwhite keepend extend fold
-syntax match   jsFlowNoise          contained /[:;,<>]/
-syntax keyword jsFlowType           contained boolean number string null void any mixed JSON array Function object array bool class
-syntax keyword jsFlowTypeof         contained typeof skipempty skipwhite nextgroup=jsFlowTypeCustom,jsFlowType
-syntax match   jsFlowTypeCustom     contained /[0-9a-zA-Z_.]*/ skipwhite skipempty nextgroup=jsFlowGeneric
-syntax region  jsFlowGeneric                  matchgroup=jsFlowNoise start=/\k\@<=</ end=/>/ contains=@jsFlowCluster containedin=@jsExpression,jsFlowDeclareBlock
-syntax region  jsFlowGeneric        contained matchgroup=jsFlowNoise start=/</ end=/>(\@=/ oneline contains=@jsFlowCluster containedin=@jsExpression,jsFlowDeclareBlock
-syntax region  jsFlowObjectGeneric  contained matchgroup=jsFlowNoise start=/\k\@<=</ end=/>/ contains=@jsFlowCluster nextgroup=jsFuncArgs
-syntax match   jsFlowArrow          contained /=>/ skipwhite skipempty nextgroup=jsFlowType,jsFlowTypeCustom,jsFlowParens
-syntax match   jsFlowObjectKey      contained /[0-9a-zA-Z_$?]*\(\s*:\)\@=/ contains=jsFunctionKey,jsFlowMaybe skipwhite skipempty nextgroup=jsObjectValue containedin=jsObject
-syntax match   jsFlowOrOperator     contained /|/ skipwhite skipempty nextgroup=@jsFlowCluster
-syntax keyword jsFlowImportType     contained type typeof skipwhite skipempty nextgroup=jsModuleAsterisk,jsModuleKeyword,jsModuleGroup
-syntax match   jsFlowWildcard       contained /*/
-
-syntax match   jsFlowReturn         contained /:\s*/ contains=jsFlowNoise skipwhite skipempty nextgroup=@jsFlowReturnCluster,jsFlowArrow,jsFlowReturnParens
-syntax region  jsFlowReturnObject   contained matchgroup=jsFlowNoise start=/{/    end=/}/  contains=@jsFlowCluster skipwhite skipempty nextgroup=jsFuncBlock,jsFlowReturnOrOp extend fold
-syntax region  jsFlowReturnArray    contained matchgroup=jsFlowNoise start=/\[/   end=/\]/ contains=@jsFlowCluster skipwhite skipempty nextgroup=jsFuncBlock,jsFlowReturnOrOp fold
-syntax region  jsFlowReturnParens   contained matchgroup=jsFlowNoise start=/(/    end=/)/  contains=@jsFlowCluster skipwhite skipempty nextgroup=jsFuncBlock,jsFlowReturnOrOp,jsFlowReturnArrow fold
-syntax match   jsFlowReturnArrow    contained /=>/ skipwhite skipempty nextgroup=@jsFlowReturnCluster
-syntax match   jsFlowReturnKeyword  contained /\k\+/ contains=jsFlowType,jsFlowTypeCustom skipwhite skipempty nextgroup=jsFlowReturnGroup,jsFuncBlock,jsFlowReturnOrOp,jsFlowReturnArray
-syntax match   jsFlowReturnMaybe    contained /?/ skipwhite skipempty nextgroup=jsFlowReturnKeyword,jsFlowReturnObject,jsFlowReturnParens
-syntax region  jsFlowReturnGroup    contained matchgroup=jsFlowNoise start=/</ end=/>/ contains=@jsFlowCluster skipwhite skipempty nextgroup=jsFuncBlock,jsFlowReturnOrOp
-syntax match   jsFlowReturnOrOp     contained /\s*|\s*/ skipwhite skipempty nextgroup=@jsFlowReturnCluster
-syntax match   jsFlowWildcardReturn contained /*/ skipwhite skipempty nextgroup=jsFuncBlock
-syntax keyword jsFlowTypeofReturn   contained typeof skipempty skipwhite nextgroup=@jsFlowReturnCluster
-
-syntax region  jsFlowFunctionGroup      contained matchgroup=jsFlowNoise start=/</ end=/>/ contains=@jsFlowCluster skipwhite skipempty nextgroup=jsFuncArgs
-syntax region  jsFlowClassGroup         contained matchgroup=jsFlowNoise start=/</ end=/>/ contains=@jsFlowCluster skipwhite skipempty nextgroup=jsClassBlock
-syntax region  jsFlowClassFunctionGroup contained matchgroup=jsFlowNoise start=/</ end=/>/ contains=@jsFlowCluster skipwhite skipempty nextgroup=jsFuncArgs
-syntax match   jsFlowObjectFuncName contained /\<\K\k*<\@=/ skipwhite skipempty nextgroup=jsFlowObjectGeneric containedin=jsObject
-
-syntax region  jsFlowTypeStatement                                   start=/\(opaque\s\+\)\?type\%(\s\+\k\)\@=/    end=/=\@=/ contains=jsFlowTypeOperator oneline skipwhite skipempty nextgroup=jsFlowTypeValue keepend
-syntax region  jsFlowTypeValue      contained     matchgroup=jsFlowNoise start=/=/ end=/\%(;\|\n\%(\s*|\)\@!\)/ contains=@jsFlowCluster,jsFlowGeneric,jsFlowMaybe
-syntax match   jsFlowTypeOperator   contained /=/ containedin=jsFlowTypeValue
-syntax match   jsFlowTypeOperator   contained /=/
-syntax keyword jsFlowTypeKeyword    contained type
-
-syntax keyword jsFlowDeclare                  declare skipwhite skipempty nextgroup=jsFlowTypeStatement,jsClassDefinition,jsStorageClass,jsFlowModule,jsFlowInterface
-syntax match   jsFlowClassProperty  contained /\<[0-9a-zA-Z_$]*\>:\@=/ skipwhite skipempty nextgroup=jsFlowClassDef containedin=jsClassBlock
-syntax region  jsFlowClassDef       contained start=/:/    end=/\%(\s*[,=;)\n]\)\@=/ contains=@jsFlowCluster skipwhite skipempty nextgroup=jsClassValue
-
-syntax region  jsFlowModule         contained start=/module/ end=/\%({\|:\)\@=/ skipempty skipwhite nextgroup=jsFlowDeclareBlock contains=jsString
-syntax region  jsFlowInterface      contained start=/interface/ end=/{\@=/ skipempty skipwhite nextgroup=jsFlowInterfaceBlock contains=@jsFlowCluster
-syntax region  jsFlowDeclareBlock   contained matchgroup=jsFlowNoise start=/{/ end=/}/ contains=jsFlowDeclare,jsFlowNoise fold
-
-syntax match   jsFlowMaybe          contained /?/
-syntax region  jsFlowInterfaceBlock contained matchgroup=jsFlowNoise start=/{/ end=/}/ contains=jsObjectKey,jsObjectKeyString,jsObjectKeyComputed,jsObjectSeparator,jsObjectFuncName,jsFlowObjectFuncName,jsObjectMethodType,jsGenerator,jsComment,jsObjectStringKey,jsSpreadExpression,jsFlowNoise,jsFlowParens,jsFlowGeneric keepend fold
-
-syntax region  jsFlowParenAnnotation contained start=/:/ end=/[,=)]\@=/ containedin=jsParen contains=@jsFlowCluster
-
-syntax cluster jsFlowReturnCluster            contains=jsFlowNoise,jsFlowReturnObject,jsFlowReturnArray,jsFlowReturnKeyword,jsFlowReturnGroup,jsFlowReturnMaybe,jsFlowReturnOrOp,jsFlowWildcardReturn,jsFlowReturnArrow,jsFlowTypeofReturn
-syntax cluster jsFlowCluster                  contains=jsFlowArray,jsFlowObject,jsFlowExactObject,jsFlowNoise,jsFlowTypeof,jsFlowType,jsFlowGeneric,jsFlowMaybe,jsFlowParens,jsFlowOrOperator,jsFlowWildcard
-
-if version >= 508 || !exists("did_javascript_syn_inits")
-  if version < 508
-    let did_javascript_syn_inits = 1
-    command -nargs=+ HiLink hi link <args>
-  else
-    command -nargs=+ HiLink hi def link <args>
-  endif
-  HiLink jsFlowDefinition         PreProc
-  HiLink jsFlowClassDef           jsFlowDefinition
-  HiLink jsFlowArgumentDef        jsFlowDefinition
-  HiLink jsFlowType               Type
-  HiLink jsFlowTypeCustom         PreProc
-  HiLink jsFlowTypeof             PreProc
-  HiLink jsFlowTypeofReturn       PreProc
-  HiLink jsFlowArray              PreProc
-  HiLink jsFlowObject             PreProc
-  HiLink jsFlowExactObject        PreProc
-  HiLink jsFlowParens             PreProc
-  HiLink jsFlowGeneric            PreProc
-  HiLink jsFlowObjectGeneric      jsFlowGeneric
-  HiLink jsFlowReturn             PreProc
-  HiLink jsFlowParenAnnotation    PreProc
-  HiLink jsFlowReturnObject       jsFlowReturn
-  HiLink jsFlowReturnArray        jsFlowArray
-  HiLink jsFlowReturnParens       jsFlowParens
-  HiLink jsFlowReturnGroup        jsFlowGeneric
-  HiLink jsFlowFunctionGroup      PreProc
-  HiLink jsFlowClassGroup         PreProc
-  HiLink jsFlowClassFunctionGroup PreProc
-  HiLink jsFlowArrow              PreProc
-  HiLink jsFlowReturnArrow        PreProc
-  HiLink jsFlowTypeStatement      PreProc
-  HiLink jsFlowTypeKeyword        PreProc
-  HiLink jsFlowTypeOperator       Operator
-  HiLink jsFlowMaybe              PreProc
-  HiLink jsFlowReturnMaybe        PreProc
-  HiLink jsFlowClassProperty      jsClassProperty
-  HiLink jsFlowDeclare            PreProc
-  HiLink jsFlowModule             PreProc
-  HiLink jsFlowInterface          PreProc
-  HiLink jsFlowNoise              Noise
-  HiLink jsFlowObjectKey          jsObjectKey
-  HiLink jsFlowOrOperator         jsOperator
-  HiLink jsFlowReturnOrOp         jsFlowOrOperator
-  HiLink jsFlowWildcard           PreProc
-  HiLink jsFlowWildcardReturn     PreProc
-  HiLink jsFlowImportType         PreProc
-  HiLink jsFlowTypeValue          PreProc
-  HiLink jsFlowObjectFuncName     jsObjectFuncName
-  delcommand HiLink
-endif
diff --git a/sources_non_forked/vim-javascript/extras/jsdoc.vim b/sources_non_forked/vim-javascript/extras/jsdoc.vim
deleted file mode 100644
index 92c4b8b..0000000
--- a/sources_non_forked/vim-javascript/extras/jsdoc.vim
+++ /dev/null
@@ -1,39 +0,0 @@
-"" syntax coloring for javadoc comments (HTML)
-syntax region jsComment    matchgroup=jsComment start="/\*\s*"  end="\*/" contains=jsDocTags,jsCommentTodo,jsCvsTag,@jsHtml,@Spell fold
-
-" tags containing a param
-syntax match  jsDocTags         contained "@\(alias\|api\|augments\|borrows\|class\|constructs\|default\|defaultvalue\|emits\|exception\|exports\|extends\|fires\|kind\|link\|listens\|member\|member[oO]f\|mixes\|module\|name\|namespace\|requires\|template\|throws\|var\|variation\|version\)\>" skipwhite nextgroup=jsDocParam
-" tags containing type and param
-syntax match  jsDocTags         contained "@\(arg\|argument\|cfg\|param\|property\|prop\|typedef\)\>" skipwhite nextgroup=jsDocType
-" tags containing type but no param
-syntax match  jsDocTags         contained "@\(callback\|define\|enum\|external\|implements\|this\|type\|return\|returns\|yields\)\>" skipwhite nextgroup=jsDocTypeNoParam
-" tags containing references
-syntax match  jsDocTags         contained "@\(lends\|see\|tutorial\)\>" skipwhite nextgroup=jsDocSeeTag
-" other tags (no extra syntax)
-syntax match  jsDocTags         contained "@\(abstract\|access\|accessor\|async\|author\|classdesc\|constant\|const\|constructor\|copyright\|deprecated\|desc\|description\|dict\|event\|example\|file\|file[oO]verview\|final\|function\|global\|ignore\|inherit[dD]oc\|inner\|instance\|interface\|license\|localdoc\|method\|mixin\|nosideeffects\|override\|overview\|preserve\|private\|protected\|public\|readonly\|since\|static\|struct\|todo\|summary\|undocumented\|virtual\)\>"
-
-syntax region jsDocType         contained matchgroup=jsDocTypeBrackets start="{" end="}" contains=jsDocTypeRecord oneline skipwhite nextgroup=jsDocParam
-syntax match  jsDocType         contained "\%(#\|\"\|\w\|\.\|:\|\/\)\+" skipwhite nextgroup=jsDocParam
-syntax region jsDocTypeRecord   contained start=/{/ end=/}/ contains=jsDocTypeRecord extend
-syntax region jsDocTypeRecord   contained start=/\[/ end=/\]/ contains=jsDocTypeRecord extend
-syntax region jsDocTypeNoParam  contained start="{" end="}" oneline
-syntax match  jsDocTypeNoParam  contained "\%(#\|\"\|\w\|\.\|:\|\/\)\+"
-syntax match  jsDocParam        contained "\%(#\|\$\|-\|'\|\"\|{.\{-}}\|\w\|\.\|:\|\/\|\[.\{-}]\|=\)\+"
-syntax region jsDocSeeTag       contained matchgroup=jsDocSeeTag start="{" end="}" contains=jsDocTags
-
-if version >= 508 || !exists("did_javascript_syn_inits")
-  if version < 508
-    let did_javascript_syn_inits = 1
-    command -nargs=+ HiLink hi link <args>
-  else
-    command -nargs=+ HiLink hi def link <args>
-  endif
-  HiLink jsDocTags              Special
-  HiLink jsDocSeeTag            Function
-  HiLink jsDocType              Type
-  HiLink jsDocTypeBrackets      jsDocType
-  HiLink jsDocTypeRecord        jsDocType
-  HiLink jsDocTypeNoParam       Type
-  HiLink jsDocParam             Label
-  delcommand HiLink
-endif
diff --git a/sources_non_forked/vim-javascript/extras/ngdoc.vim b/sources_non_forked/vim-javascript/extras/ngdoc.vim
deleted file mode 100644
index c513d87..0000000
--- a/sources_non_forked/vim-javascript/extras/ngdoc.vim
+++ /dev/null
@@ -1,3 +0,0 @@
-syntax match  jsDocTags         contained /@\(link\|method[oO]f\|ngdoc\|ng[iI]nject\|restrict\)/ nextgroup=jsDocParam skipwhite
-syntax match  jsDocType         contained "\%(#\|\$\|\w\|\"\|-\|\.\|:\|\/\)\+" nextgroup=jsDocParam skipwhite
-syntax match  jsDocParam        contained "\%(#\|\$\|\w\|\"\|-\|\.\|:\|{\|}\|\/\|\[\|]\|=\)\+"
diff --git a/sources_non_forked/vim-javascript/ftdetect/flow.vim b/sources_non_forked/vim-javascript/ftdetect/flow.vim
deleted file mode 100644
index 3f1ea65..0000000
--- a/sources_non_forked/vim-javascript/ftdetect/flow.vim
+++ /dev/null
@@ -1 +0,0 @@
-autocmd BufNewFile,BufRead *.flow setfiletype flow
diff --git a/sources_non_forked/vim-javascript/ftdetect/javascript.vim b/sources_non_forked/vim-javascript/ftdetect/javascript.vim
deleted file mode 100644
index 0048732..0000000
--- a/sources_non_forked/vim-javascript/ftdetect/javascript.vim
+++ /dev/null
@@ -1,8 +0,0 @@
-fun! s:SelectJavascript()
-  if getline(1) =~# '^#!.*/bin/\%(env\s\+\)\?node\>'
-    set ft=javascript
-  endif
-endfun
-
-autocmd BufNewFile,BufRead *.{js,mjs,cjs,jsm,es,es6},Jakefile setfiletype javascript
-autocmd BufNewFile,BufRead * call s:SelectJavascript()
diff --git a/sources_non_forked/vim-javascript/indent/javascript.vim b/sources_non_forked/vim-javascript/indent/javascript.vim
deleted file mode 100644
index b759f0a..0000000
--- a/sources_non_forked/vim-javascript/indent/javascript.vim
+++ /dev/null
@@ -1,477 +0,0 @@
-" Vim indent file
-" Language: Javascript
-" Maintainer: Chris Paul ( https://github.com/bounceme )
-" URL: https://github.com/pangloss/vim-javascript
-" Last Change: December 4, 2017
-
-" Only load this indent file when no other was loaded.
-if exists('b:did_indent')
-  finish
-endif
-let b:did_indent = 1
-
-" Now, set up our indentation expression and keys that trigger it.
-setlocal indentexpr=GetJavascriptIndent()
-setlocal autoindent nolisp nosmartindent
-setlocal indentkeys+=0],0)
-" Testable with something like:
-" vim  -eNs "+filetype plugin indent on" "+syntax on" "+set ft=javascript" \
-"       "+norm! gg=G" '+%print' '+:q!' testfile.js \
-"       | diff -uBZ testfile.js -
-
-let b:undo_indent = 'setlocal indentexpr< smartindent< autoindent< indentkeys<'
-
-" Only define the function once.
-if exists('*GetJavascriptIndent')
-  finish
-endif
-
-let s:cpo_save = &cpo
-set cpo&vim
-
-" indent correctly if inside <script>
-" vim/vim@690afe1 for the switch from cindent
-" overridden with b:html_indent_script1
-call extend(g:,{'html_indent_script1': 'inc'},'keep')
-
-" Regex of syntax group names that are or delimit string or are comments.
-let s:bvars = {
-      \ 'syng_strcom': 'string\|comment\|regex\|special\|doc\|template\%(braces\)\@!',
-      \ 'syng_str': 'string\|template\|special' }
-" template strings may want to be excluded when editing graphql:
-" au! Filetype javascript let b:syng_str = '^\%(.*template\)\@!.*string\|special'
-" au! Filetype javascript let b:syng_strcom = '^\%(.*template\)\@!.*string\|comment\|regex\|special\|doc'
-
-function s:GetVars()
-  call extend(b:,extend(s:bvars,{'js_cache': [0,0,0]}),'keep')
-endfunction
-
-" Get shiftwidth value
-if exists('*shiftwidth')
-  function s:sw()
-    return shiftwidth()
-  endfunction
-else
-  function s:sw()
-    return &l:shiftwidth ? &l:shiftwidth : &l:tabstop
-  endfunction
-endif
-
-" Performance for forwards search(): start search at pos rather than masking
-" matches before pos.
-let s:z = has('patch-7.4.984') ? 'z' : ''
-
-" Expression used to check whether we should skip a match with searchpair().
-let s:skip_expr = "s:SynAt(line('.'),col('.')) =~? b:syng_strcom"
-let s:in_comm = s:skip_expr[:-14] . "'comment\\|doc'"
-
-let s:rel = has('reltime')
-" searchpair() wrapper
-if s:rel
-  function s:GetPair(start,end,flags,skip)
-    return searchpair('\m'.a:start,'','\m'.a:end,a:flags,a:skip,s:l1,a:skip ==# 's:SkipFunc()' ? 2000 : 200)
-  endfunction
-else
-  function s:GetPair(start,end,flags,skip)
-    return searchpair('\m'.a:start,'','\m'.a:end,a:flags,a:skip,s:l1)
-  endfunction
-endif
-
-function s:SynAt(l,c)
-  let byte = line2byte(a:l) + a:c - 1
-  let pos = index(s:synid_cache[0], byte)
-  if pos == -1
-    let s:synid_cache[:] += [[byte], [synIDattr(synID(a:l, a:c, 0), 'name')]]
-  endif
-  return s:synid_cache[1][pos]
-endfunction
-
-function s:ParseCino(f)
-  let [s, n, divider] = [strridx(&cino, a:f)+1, '', 0]
-  while s && &cino[ s ] =~ '[^,]'
-    if &cino[ s ] == '.'
-      let divider = 1
-    elseif &cino[ s ] ==# 's'
-      if n !~ '\d'
-        return n . s:sw() + 0
-      endif
-      let n = str2nr(n) * s:sw()
-      break
-    else
-      let [n, divider] .= [&cino[ s ], 0]
-    endif
-    let s += 1
-  endwhile
-  return str2nr(n) / max([divider, 1])
-endfunction
-
-" Optimized {skip} expr, only callable from the search loop which
-" GetJavascriptIndent does to find the containing [[{(] (side-effects)
-function s:SkipFunc()
-  if s:top_col == 1
-    throw 'out of bounds'
-  elseif s:check_in
-    if eval(s:skip_expr)
-      return 1
-    endif
-    let s:check_in = 0
-  elseif getline('.') =~ '\%<'.col('.').'c\/.\{-}\/\|\%>'.col('.').'c[''"]\|\\$'
-    if eval(s:skip_expr)
-      return 1
-    endif
-  elseif search('\m`\|\${\|\*\/','nW'.s:z,s:looksyn)
-    if eval(s:skip_expr)
-      let s:check_in = 1
-      return 1
-    endif
-  else
-    let s:synid_cache[:] += [[line2byte('.') + col('.') - 1], ['']]
-  endif
-  let [s:looksyn, s:top_col] = getpos('.')[1:2]
-endfunction
-
-function s:AlternatePair()
-  let [pat, l:for] = ['[][(){};]', 2]
-  while s:SearchLoop(pat,'bW','s:SkipFunc()')
-    if s:LookingAt() == ';'
-      if !l:for
-        if s:GetPair('{','}','bW','s:SkipFunc()')
-          return
-        endif
-        break
-      else
-        let [pat, l:for] = ['[{}();]', l:for - 1]
-      endif
-    else
-      let idx = stridx('])}',s:LookingAt())
-      if idx == -1
-        return
-      elseif !s:GetPair(['\[','(','{'][idx],'])}'[idx],'bW','s:SkipFunc()')
-        break
-      endif
-    endif
-  endwhile
-  throw 'out of bounds'
-endfunction
-
-function s:Nat(int)
-  return a:int * (a:int > 0)
-endfunction
-
-function s:LookingAt()
-  return getline('.')[col('.')-1]
-endfunction
-
-function s:Token()
-  return s:LookingAt() =~ '\k' ? expand('<cword>') : s:LookingAt()
-endfunction
-
-function s:PreviousToken(...)
-  let [l:pos, tok] = [getpos('.'), '']
-  if search('\m\k\{1,}\|\S','ebW')
-    if getline('.')[col('.')-2:col('.')-1] == '*/'
-      if eval(s:in_comm) && !s:SearchLoop('\S\ze\_s*\/[/*]','bW',s:in_comm)
-        call setpos('.',l:pos)
-      else
-        let tok = s:Token()
-      endif
-    else
-      let two = a:0 || line('.') != l:pos[1] ? strridx(getline('.')[:col('.')],'//') + 1 : 0
-      if two && eval(s:in_comm)
-        call cursor(0,two)
-        let tok = s:PreviousToken(1)
-        if tok is ''
-          call setpos('.',l:pos)
-        endif
-      else
-        let tok = s:Token()
-      endif
-    endif
-  endif
-  return tok
-endfunction
-
-function s:Pure(f,...)
-  return eval("[call(a:f,a:000),cursor(a:firstline,".col('.').")][0]")
-endfunction
-
-function s:SearchLoop(pat,flags,expr)
-  return s:GetPair(a:pat,'\_$.',a:flags,a:expr)
-endfunction
-
-function s:ExprCol()
-  if getline('.')[col('.')-2] == ':'
-    return 1
-  endif
-  let bal = 0
-  while s:SearchLoop('[{}?:]','bW',s:skip_expr)
-    if s:LookingAt() == ':'
-      let bal -= !search('\m:\%#','bW')
-    elseif s:LookingAt() == '?'
-      if getline('.')[col('.'):col('.')+1] =~ '^\.\d\@!'
-        " ?. conditional chain, not ternary start
-      elseif !bal
-        return 1
-      else
-        let bal += 1
-      endif
-    elseif s:LookingAt() == '{'
-      return !s:IsBlock()
-    elseif !s:GetPair('{','}','bW',s:skip_expr)
-      break
-    endif
-  endwhile
-endfunction
-
-" configurable regexes that define continuation lines, not including (, {, or [.
-let s:opfirst = '^' . get(g:,'javascript_opfirst',
-      \ '\C\%([<>=,.?^%|/&]\|\([-:+]\)\1\@!\|\*\+\|!=\|in\%(stanceof\)\=\>\)')
-let s:continuation = get(g:,'javascript_continuation',
-      \ '\C\%([<=,.~!?/*^%|&:]\|+\@<!+\|-\@<!-\|=\@<!>\|\<\%(typeof\|new\|delete\|void\|in\|instanceof\|await\)\)') . '$'
-
-function s:Continues()
-  let tok = matchstr(strpart(getline('.'),col('.')-15,15),s:continuation)
-  if tok =~ '[a-z:]'
-    return tok == ':' ? s:ExprCol() : s:PreviousToken() != '.'
-  elseif tok !~ '[/>]'
-    return tok isnot ''
-  endif
-  return s:SynAt(line('.'),col('.')) !~? (tok == '>' ? 'jsflow\|^html' : 'regex')
-endfunction
-
-" Check if line 'lnum' has a balanced amount of parentheses.
-function s:Balanced(lnum,line)
-  let l:open = 0
-  let pos = match(a:line, '[][(){}]')
-  while pos != -1
-    if s:SynAt(a:lnum,pos + 1) !~? b:syng_strcom
-      let l:open += matchend(a:line[pos],'[[({]')
-      if l:open < 0
-        return
-      endif
-    endif
-    let pos = match(a:line, !l:open ? '[][(){}]' : '()' =~ a:line[pos] ?
-          \ '[()]' : '{}' =~ a:line[pos] ? '[{}]' : '[][]', pos + 1)
-  endwhile
-  return !l:open
-endfunction
-
-function s:OneScope()
-  if s:LookingAt() == ')' && s:GetPair('(', ')', 'bW', s:skip_expr)
-    let tok = s:PreviousToken()
-    return (count(split('for if let while with'),tok) ||
-          \ tok =~# '^await$\|^each$' && s:PreviousToken() ==# 'for') &&
-          \ s:Pure('s:PreviousToken') != '.' && !(tok == 'while' && s:DoWhile())
-  elseif s:Token() =~# '^else$\|^do$'
-    return s:Pure('s:PreviousToken') != '.'
-  elseif strpart(getline('.'),col('.')-2,2) == '=>'
-    call cursor(0,col('.')-1)
-    return s:PreviousToken() != ')' || s:GetPair('(', ')', 'bW', s:skip_expr)
-  endif
-endfunction
-
-function s:DoWhile()
-  let cpos = searchpos('\m\<','cbW')
-  while s:SearchLoop('\C[{}]\|\<\%(do\|while\)\>','bW',s:skip_expr)
-    if s:LookingAt() =~ '\a'
-      if s:Pure('s:IsBlock')
-        if s:LookingAt() ==# 'd'
-          return 1
-        endif
-        break
-      endif
-    elseif s:LookingAt() != '}' || !s:GetPair('{','}','bW',s:skip_expr)
-      break
-    endif
-  endwhile
-  call call('cursor',cpos)
-endfunction
-
-" returns total offset from braceless contexts. 'num' is the lineNr which
-" encloses the entire context, 'cont' if whether a:firstline is a continued
-" expression, which could have started in a braceless context
-function s:IsContOne(cont)
-  let [l:num, pind] = b:js_cache[1] ?
-        \ [b:js_cache[1], indent(b:js_cache[1]) + s:sw()] : [1,0]
-  let [ind, b_l] = [indent('.') + !a:cont, 0]
-  while line('.') > l:num && ind > pind || line('.') == l:num
-    if indent('.') < ind && s:OneScope()
-      let b_l += 1
-    elseif !a:cont || b_l || ind < indent(a:firstline)
-      break
-    else
-      call cursor(0,1)
-    endif
-    let ind = min([ind, indent('.')])
-    if s:PreviousToken() is ''
-      break
-    endif
-  endwhile
-  return b_l
-endfunction
-
-function s:IsSwitch()
-  return search(printf('\m\C\%%%dl\%%%dc%s',b:js_cache[1],b:js_cache[2],
-        \ '{\_s*\%(\%(\/\/.*\_$\|\/\*\_.\{-}\*\/\)\@>\_s*\)*\%(case\|default\)\>'),'nW'.s:z)
-endfunction
-
-" https://github.com/sweet-js/sweet.js/wiki/design#give-lookbehind-to-the-reader
-function s:IsBlock()
-  let tok = s:PreviousToken()
-  if join(s:stack) =~? 'xml\|jsx' && s:SynAt(line('.'),col('.')-1) =~? 'xml\|jsx'
-    let s:in_jsx = 1
-    return tok != '{'
-  elseif tok =~ '\k'
-    if tok ==# 'type'
-      return s:Pure('eval',"s:PreviousToken() !~# '^\\%(im\\|ex\\)port$' || s:PreviousToken() == '.'")
-    elseif tok ==# 'of'
-      return s:Pure('eval',"!s:GetPair('[[({]','[])}]','bW',s:skip_expr) || s:LookingAt() != '(' ||"
-            \ ."s:{s:PreviousToken() ==# 'await' ? 'Previous' : ''}Token() !=# 'for' || s:PreviousToken() == '.'")
-    endif
-    return index(split('return const let import export extends yield default delete var await void typeof throw case new in instanceof')
-          \ ,tok) < (line('.') != a:firstline) || s:Pure('s:PreviousToken') == '.'
-  elseif tok == '>'
-    return getline('.')[col('.')-2] == '=' || s:SynAt(line('.'),col('.')) =~? 'jsflow\|^html'
-  elseif tok == '*'
-    return s:Pure('s:PreviousToken') == ':'
-  elseif tok == ':'
-    return s:Pure('eval',"s:PreviousToken() =~ '^\\K\\k*$' && !s:ExprCol()")
-  elseif tok == '/'
-    return s:SynAt(line('.'),col('.')) =~? 'regex'
-  elseif tok !~ '[=~!<,.?^%|&([]'
-    return tok !~ '[-+]' || line('.') != a:firstline && getline('.')[col('.')-2] == tok
-  endif
-endfunction
-
-function GetJavascriptIndent()
-  call s:GetVars()
-  let s:synid_cache = [[],[]]
-  let l:line = getline(v:lnum)
-  " use synstack as it validates syn state and works in an empty line
-  let s:stack = [''] + map(synstack(v:lnum,1),"synIDattr(v:val,'name')")
-
-  " start with strings,comments,etc.
-  if s:stack[-1] =~? 'comment\|doc'
-    if l:line !~ '^\s*\/[/*]'
-      return l:line =~ '^\s*\*' ? cindent(v:lnum) : -1
-    endif
-  elseif s:stack[-1] =~? b:syng_str
-    if b:js_cache[0] == v:lnum - 1 && s:Balanced(v:lnum-1,getline(v:lnum-1))
-      let b:js_cache[0] = v:lnum
-    endif
-    return -1
-  endif
-
-  let nest = get(get(b:,'hi_indent',{}),'blocklnr')
-  let s:l1 = max([0, prevnonblank(v:lnum) - (s:rel ? 2000 : 1000), nest])
-  call cursor(v:lnum,1)
-  if s:PreviousToken() is ''
-    return
-  endif
-  let [l:lnum, lcol, pline] = getpos('.')[1:2] + [getline('.')[:col('.')-1]]
-
-  let l:line = substitute(l:line,'^\s*','','')
-  let l:line_s = l:line[0]
-  if l:line[:1] == '/*'
-    let l:line = substitute(l:line,'^\%(\/\*.\{-}\*\/\s*\)*','','')
-  endif
-  if l:line =~ '^\/[/*]'
-    let l:line = ''
-  endif
-
-  " the containing paren, bracket, or curly. Many hacks for performance
-  call cursor(v:lnum,1)
-  let idx = index([']',')','}'],l:line[0])
-  if b:js_cache[0] > l:lnum && b:js_cache[0] < v:lnum ||
-        \ b:js_cache[0] == l:lnum && s:Balanced(l:lnum,pline)
-    call call('cursor',b:js_cache[1:])
-  else
-    let [s:looksyn, s:top_col, s:check_in, s:l1] = [v:lnum - 1,0,0,
-          \ max([s:l1, &smc ? search('\m^.\{'.&smc.',}','nbW',s:l1 + 1) + 1 : 0])]
-    try
-      if idx != -1
-        call s:GetPair(['\[','(','{'][idx],'])}'[idx],'bW','s:SkipFunc()')
-      elseif getline(v:lnum) !~ '^\S' && s:stack[-1] =~? 'block\|^jsobject$'
-        if !s:GetPair('{','}','bW','s:SkipFunc()') && s:stack[-1] ==# 'jsObject'
-          return indent(l:lnum)
-        endif
-      else
-        call s:AlternatePair()
-      endif
-    catch /^\Cout of bounds$/
-      call cursor(v:lnum,1)
-    endtry
-    let b:js_cache[1:] = line('.') == v:lnum ? [0,0] : getpos('.')[1:2]
-  endif
-
-  let [b:js_cache[0], num] = [v:lnum, b:js_cache[1]]
-
-  let [num_ind, is_op, b_l, l:switch_offset, s:in_jsx] = [s:Nat(indent(num)),0,0,0,0]
-  if !num || s:LookingAt() == '{' && s:IsBlock()
-    let ilnum = line('.')
-    if num && !s:in_jsx && s:LookingAt() == ')' && s:GetPair('(',')','bW',s:skip_expr)
-      if ilnum == num
-        let [num, num_ind] = [line('.'), indent('.')]
-      endif
-      if idx == -1 && s:PreviousToken() ==# 'switch' && s:IsSwitch()
-        let l:switch_offset = &cino !~ ':' ? s:sw() : s:ParseCino(':')
-        if pline[-1:] != '.' && l:line =~# '^\%(default\|case\)\>'
-          return s:Nat(num_ind + l:switch_offset)
-        elseif &cino =~ '='
-          let l:case_offset = s:ParseCino('=')
-        endif
-      endif
-    endif
-    if idx == -1 && pline[-1:] !~ '[{;]'
-      call cursor(l:lnum, lcol)
-      let sol = matchstr(l:line,s:opfirst)
-      if sol is '' || sol == '/' && s:SynAt(v:lnum,
-            \ 1 + len(getline(v:lnum)) - len(l:line)) =~? 'regex'
-        if s:Continues()
-          let is_op = s:sw()
-        endif
-      elseif num && sol =~# '^\%(in\%(stanceof\)\=\|\*\)$' &&
-            \ s:LookingAt() == '}' && s:GetPair('{','}','bW',s:skip_expr) &&
-            \ s:PreviousToken() == ')' && s:GetPair('(',')','bW',s:skip_expr) &&
-            \ (s:PreviousToken() == ']' || s:LookingAt() =~ '\k' &&
-            \ s:{s:PreviousToken() == '*' ? 'Previous' : ''}Token() !=# 'function')
-        return num_ind + s:sw()
-      else
-        let is_op = s:sw()
-      endif
-      call cursor(l:lnum, lcol)
-      let b_l = s:Nat(s:IsContOne(is_op) - (!is_op && l:line =~ '^{')) * s:sw()
-    endif
-  elseif idx == -1 && s:LookingAt() == '(' && &cino =~ '(' &&
-        \ (search('\m\S','nbW',num) || s:ParseCino('U'))
-    let pval = s:ParseCino('(')
-    if !pval
-      let [Wval, vcol] = [s:ParseCino('W'), virtcol('.')]
-      if search('\m'.get(g:,'javascript_indent_W_pat','\S'),'W',num)
-        return s:ParseCino('w') ? vcol : virtcol('.')-1
-      endif
-      return Wval ? s:Nat(num_ind + Wval) : vcol
-    endif
-    return s:Nat(num_ind + pval + searchpair('\m(','','\m)','nbrmW',s:skip_expr,num) * s:sw())
-  endif
-
-  " main return
-  if l:line =~ '^[])}]\|^|}'
-    if l:line_s == ')'
-      if s:ParseCino('M')
-        return indent(l:lnum)
-      elseif num && &cino =~# 'm' && !s:ParseCino('m')
-        return virtcol('.') - 1
-      endif
-    endif
-    return num_ind
-  elseif num
-    return s:Nat(num_ind + get(l:,'case_offset',s:sw()) + l:switch_offset + b_l + is_op)
-  elseif nest
-    return indent(nextnonblank(nest+1)) + b_l + is_op
-  endif
-  return b_l + is_op
-endfunction
-
-let &cpo = s:cpo_save
-unlet s:cpo_save
diff --git a/sources_non_forked/vim-javascript/syntax/flow.vim b/sources_non_forked/vim-javascript/syntax/flow.vim
deleted file mode 100644
index 3f97218..0000000
--- a/sources_non_forked/vim-javascript/syntax/flow.vim
+++ /dev/null
@@ -1,2 +0,0 @@
-runtime syntax/javascript.vim
-runtime extras/flow.vim
diff --git a/sources_non_forked/vim-javascript/syntax/javascript.vim b/sources_non_forked/vim-javascript/syntax/javascript.vim
deleted file mode 100644
index 6a13434..0000000
--- a/sources_non_forked/vim-javascript/syntax/javascript.vim
+++ /dev/null
@@ -1,393 +0,0 @@
-" Vim syntax file
-" Language:     JavaScript
-" Maintainer:   vim-javascript community
-" URL:          https://github.com/pangloss/vim-javascript
-
-if !exists("main_syntax")
-  if version < 600
-    syntax clear
-  elseif exists("b:current_syntax")
-    finish
-  endif
-  let main_syntax = 'javascript'
-endif
-
-" Dollar sign is permitted anywhere in an identifier
-if (v:version > 704 || v:version == 704 && has('patch1142')) && main_syntax == 'javascript'
-  syntax iskeyword @,48-57,_,192-255,$
-else
-  setlocal iskeyword+=$
-endif
-
-syntax sync fromstart
-" TODO: Figure out what type of casing I need
-" syntax case ignore
-syntax case match
-
-syntax match   jsNoise          /[:,;]/
-syntax match   jsDot            /\./ skipwhite skipempty nextgroup=jsObjectProp,jsFuncCall,jsPrototype,jsTaggedTemplate
-syntax match   jsObjectProp     contained /\<\K\k*/
-syntax match   jsFuncCall       /\<\K\k*\ze\s*(/
-syntax match   jsParensError    /[)}\]]/
-
-" Program Keywords
-syntax keyword jsStorageClass   const var let skipwhite skipempty nextgroup=jsDestructuringBlock,jsDestructuringArray,jsVariableDef
-syntax match   jsVariableDef    contained /\<\K\k*/ skipwhite skipempty nextgroup=jsFlowDefinition
-syntax keyword jsOperatorKeyword delete instanceof typeof void new in of skipwhite skipempty nextgroup=@jsExpression
-syntax match   jsOperator       "[-!|&+<>=%/*~^]" skipwhite skipempty nextgroup=@jsExpression
-syntax match   jsOperator       /::/ skipwhite skipempty nextgroup=@jsExpression
-syntax keyword jsBooleanTrue    true
-syntax keyword jsBooleanFalse   false
-
-" Modules
-syntax keyword jsImport                       import skipwhite skipempty nextgroup=jsModuleAsterisk,jsModuleKeyword,jsModuleGroup,jsFlowImportType
-syntax keyword jsExport                       export skipwhite skipempty nextgroup=@jsAll,jsModuleGroup,jsExportDefault,jsModuleAsterisk,jsModuleKeyword,jsFlowTypeStatement
-syntax match   jsModuleKeyword      contained /\<\K\k*/ skipwhite skipempty nextgroup=jsModuleAs,jsFrom,jsModuleComma
-syntax keyword jsExportDefault      contained default skipwhite skipempty nextgroup=@jsExpression
-syntax keyword jsExportDefaultGroup contained default skipwhite skipempty nextgroup=jsModuleAs,jsFrom,jsModuleComma
-syntax match   jsModuleAsterisk     contained /\*/ skipwhite skipempty nextgroup=jsModuleKeyword,jsModuleAs,jsFrom
-syntax keyword jsModuleAs           contained as skipwhite skipempty nextgroup=jsModuleKeyword,jsExportDefaultGroup
-syntax keyword jsFrom               contained from skipwhite skipempty nextgroup=jsString
-syntax match   jsModuleComma        contained /,/ skipwhite skipempty nextgroup=jsModuleKeyword,jsModuleAsterisk,jsModuleGroup,jsFlowTypeKeyword
-
-" Strings, Templates, Numbers
-syntax region  jsString           start=+\z(["']\)+  skip=+\\\%(\z1\|$\)+  end=+\z1+ end=+$+  contains=jsSpecial extend
-syntax region  jsTemplateString   start=+`+  skip=+\\`+  end=+`+     contains=jsTemplateExpression,jsSpecial extend
-syntax match   jsTaggedTemplate   /\<\K\k*\ze`/ nextgroup=jsTemplateString
-syntax match   jsNumber           /\c\<\%(\d\+\%(e[+-]\=\d\+\)\=\|0b[01]\+\|0o\o\+\|0x\x\+\)\>/
-syntax keyword jsNumber           Infinity
-syntax match   jsFloat            /\c\<\%(\d\+\.\d\+\|\d\+\.\|\.\d\+\)\%(e[+-]\=\d\+\)\=\>/
-
-" Regular Expressions
-syntax match   jsSpecial            contained "\v\\%(x\x\x|u%(\x{4}|\{\x{4,5}})|c\u|.)"
-syntax region  jsTemplateExpression contained matchgroup=jsTemplateBraces start=+${+ end=+}+ contains=@jsExpression keepend
-syntax region  jsRegexpCharClass    contained start=+\[+ skip=+\\.+ end=+\]+ contains=jsSpecial extend
-syntax match   jsRegexpBoundary     contained "\v\c[$^]|\\b"
-syntax match   jsRegexpBackRef      contained "\v\\[1-9]\d*"
-syntax match   jsRegexpQuantifier   contained "\v[^\\]%([?*+]|\{\d+%(,\d*)?})\??"lc=1
-syntax match   jsRegexpOr           contained "|"
-syntax match   jsRegexpMod          contained "\v\(\?[:=!>]"lc=1
-syntax region  jsRegexpGroup        contained start="[^\\]("lc=1 skip="\\.\|\[\(\\.\|[^]]\+\)\]" end=")" contains=jsRegexpCharClass,@jsRegexpSpecial keepend
-syntax region  jsRegexpString   start=+\%(\%(\<return\|\<typeof\|\_[^)\]'"[:blank:][:alnum:]_$]\)\s*\)\@<=/\ze[^*/]+ skip=+\\.\|\[[^]]\{1,}\]+ end=+/[gimyus]\{,6}+ contains=jsRegexpCharClass,jsRegexpGroup,@jsRegexpSpecial oneline keepend extend
-syntax cluster jsRegexpSpecial    contains=jsSpecial,jsRegexpBoundary,jsRegexpBackRef,jsRegexpQuantifier,jsRegexpOr,jsRegexpMod
-
-" Objects
-syntax match   jsObjectShorthandProp contained /\<\k*\ze\s*/ skipwhite skipempty nextgroup=jsObjectSeparator
-syntax match   jsObjectKey         contained /\<\k*\ze\s*:/ contains=jsFunctionKey skipwhite skipempty nextgroup=jsObjectValue
-syntax region  jsObjectKeyString   contained start=+\z(["']\)+  skip=+\\\%(\z1\|$\)+  end=+\z1\|$+  contains=jsSpecial skipwhite skipempty nextgroup=jsObjectValue
-syntax region  jsObjectKeyComputed contained matchgroup=jsBrackets start=/\[/ end=/]/ contains=@jsExpression skipwhite skipempty nextgroup=jsObjectValue,jsFuncArgs extend
-syntax match   jsObjectSeparator   contained /,/
-syntax region  jsObjectValue       contained matchgroup=jsObjectColon start=/:/ end=/[,}]\@=/ contains=@jsExpression extend
-syntax match   jsObjectFuncName    contained /\<\K\k*\ze\_s*(/ skipwhite skipempty nextgroup=jsFuncArgs
-syntax match   jsFunctionKey       contained /\<\K\k*\ze\s*:\s*function\>/
-syntax match   jsObjectMethodType  contained /\<[gs]et\ze\s\+\K\k*/ skipwhite skipempty nextgroup=jsObjectFuncName
-syntax region  jsObjectStringKey   contained start=+\z(["']\)+  skip=+\\\%(\z1\|$\)+  end=+\z1\|$+  contains=jsSpecial extend skipwhite skipempty nextgroup=jsFuncArgs,jsObjectValue
-
-exe 'syntax keyword jsNull      null             '.(exists('g:javascript_conceal_null')      ? 'conceal cchar='.g:javascript_conceal_null       : '')
-exe 'syntax keyword jsReturn    return contained '.(exists('g:javascript_conceal_return')    ? 'conceal cchar='.g:javascript_conceal_return     : '').' skipwhite nextgroup=@jsExpression'
-exe 'syntax keyword jsUndefined undefined        '.(exists('g:javascript_conceal_undefined') ? 'conceal cchar='.g:javascript_conceal_undefined  : '')
-exe 'syntax keyword jsNan       NaN              '.(exists('g:javascript_conceal_NaN')       ? 'conceal cchar='.g:javascript_conceal_NaN        : '')
-exe 'syntax keyword jsPrototype prototype        '.(exists('g:javascript_conceal_prototype') ? 'conceal cchar='.g:javascript_conceal_prototype  : '')
-exe 'syntax keyword jsThis      this             '.(exists('g:javascript_conceal_this')      ? 'conceal cchar='.g:javascript_conceal_this       : '')
-exe 'syntax keyword jsSuper     super  contained '.(exists('g:javascript_conceal_super')     ? 'conceal cchar='.g:javascript_conceal_super      : '')
-
-" Statement Keywords
-syntax match   jsBlockLabel              /\<\K\k*\s*::\@!/    contains=jsNoise skipwhite skipempty nextgroup=jsBlock
-syntax match   jsBlockLabelKey contained /\<\K\k*\ze\s*\_[;]/
-syntax keyword jsStatement     contained with yield debugger
-syntax keyword jsStatement     contained break continue skipwhite skipempty nextgroup=jsBlockLabelKey
-syntax keyword jsConditional            if              skipwhite skipempty nextgroup=jsParenIfElse
-syntax keyword jsConditional            else            skipwhite skipempty nextgroup=jsCommentIfElse,jsIfElseBlock
-syntax keyword jsConditional            switch          skipwhite skipempty nextgroup=jsParenSwitch
-syntax keyword jsRepeat                 while for       skipwhite skipempty nextgroup=jsParenRepeat,jsForAwait
-syntax keyword jsDo                     do              skipwhite skipempty nextgroup=jsRepeatBlock
-syntax region  jsSwitchCase   contained matchgroup=jsLabel start=/\<\%(case\|default\)\>/ end=/:\@=/ contains=@jsExpression,jsLabel skipwhite skipempty nextgroup=jsSwitchColon keepend
-syntax keyword jsTry                    try             skipwhite skipempty nextgroup=jsTryCatchBlock
-syntax keyword jsFinally      contained finally         skipwhite skipempty nextgroup=jsFinallyBlock
-syntax keyword jsCatch        contained catch           skipwhite skipempty nextgroup=jsParenCatch
-syntax keyword jsException              throw
-syntax keyword jsAsyncKeyword           async await
-syntax match   jsSwitchColon   contained /::\@!/        skipwhite skipempty nextgroup=jsSwitchBlock
-
-" Keywords
-syntax keyword jsGlobalObjects     ArrayBuffer Array BigInt64Array BigUint64Array Float32Array Float64Array Int16Array Int32Array Int8Array Uint16Array Uint32Array Uint8Array Uint8ClampedArray Boolean Buffer Collator DataView Date DateTimeFormat Function Intl Iterator JSON Map Set WeakMap WeakSet Math Number NumberFormat Object ParallelArray Promise Proxy Reflect RegExp String Symbol Uint8ClampedArray WebAssembly console document fetch window
-syntax keyword jsGlobalNodeObjects  module exports global process __dirname __filename
-syntax match   jsGlobalNodeObjects  /\<require\>/ containedin=jsFuncCall
-syntax keyword jsExceptions         Error EvalError InternalError RangeError ReferenceError StopIteration SyntaxError TypeError URIError
-syntax keyword jsBuiltins           decodeURI decodeURIComponent encodeURI encodeURIComponent eval isFinite isNaN parseFloat parseInt uneval
-" DISCUSS: How imporant is this, really? Perhaps it should be linked to an error because I assume the keywords are reserved?
-syntax keyword jsFutureKeys         abstract enum int short boolean interface byte long char final native synchronized float package throws goto private transient implements protected volatile double public
-
-" DISCUSS: Should we really be matching stuff like this?
-" DOM2 Objects
-syntax keyword jsGlobalObjects  DOMImplementation DocumentFragment Document Node NodeList NamedNodeMap CharacterData Attr Element Text Comment CDATASection DocumentType Notation Entity EntityReference ProcessingInstruction
-syntax keyword jsExceptions     DOMException
-
-" DISCUSS: Should we really be matching stuff like this?
-" DOM2 CONSTANT
-syntax keyword jsDomErrNo       INDEX_SIZE_ERR DOMSTRING_SIZE_ERR HIERARCHY_REQUEST_ERR WRONG_DOCUMENT_ERR INVALID_CHARACTER_ERR NO_DATA_ALLOWED_ERR NO_MODIFICATION_ALLOWED_ERR NOT_FOUND_ERR NOT_SUPPORTED_ERR INUSE_ATTRIBUTE_ERR INVALID_STATE_ERR SYNTAX_ERR INVALID_MODIFICATION_ERR NAMESPACE_ERR INVALID_ACCESS_ERR
-syntax keyword jsDomNodeConsts  ELEMENT_NODE ATTRIBUTE_NODE TEXT_NODE CDATA_SECTION_NODE ENTITY_REFERENCE_NODE ENTITY_NODE PROCESSING_INSTRUCTION_NODE COMMENT_NODE DOCUMENT_NODE DOCUMENT_TYPE_NODE DOCUMENT_FRAGMENT_NODE NOTATION_NODE
-
-" DISCUSS: Should we really be special matching on these props?
-" HTML events and internal variables
-syntax keyword jsHtmlEvents     onblur onclick oncontextmenu ondblclick onfocus onkeydown onkeypress onkeyup onmousedown onmousemove onmouseout onmouseover onmouseup onresize
-
-" Code blocks
-syntax region  jsBracket                      matchgroup=jsBrackets            start=/\[/ end=/\]/ contains=@jsExpression,jsSpreadExpression extend fold
-syntax region  jsParen                        matchgroup=jsParens              start=/(/  end=/)/  contains=@jsExpression extend fold nextgroup=jsFlowDefinition
-syntax region  jsParenDecorator     contained matchgroup=jsParensDecorator     start=/(/  end=/)/  contains=@jsAll extend fold
-syntax region  jsParenIfElse        contained matchgroup=jsParensIfElse        start=/(/  end=/)/  contains=@jsAll skipwhite skipempty nextgroup=jsCommentIfElse,jsIfElseBlock,jsReturn extend fold
-syntax region  jsParenRepeat        contained matchgroup=jsParensRepeat        start=/(/  end=/)/  contains=@jsAll skipwhite skipempty nextgroup=jsCommentRepeat,jsRepeatBlock,jsReturn extend fold
-syntax region  jsParenSwitch        contained matchgroup=jsParensSwitch        start=/(/  end=/)/  contains=@jsAll skipwhite skipempty nextgroup=jsSwitchBlock extend fold
-syntax region  jsParenCatch         contained matchgroup=jsParensCatch         start=/(/  end=/)/  skipwhite skipempty nextgroup=jsTryCatchBlock extend fold
-syntax region  jsFuncArgs           contained matchgroup=jsFuncParens          start=/(/  end=/)/  contains=jsFuncArgCommas,jsComment,jsFuncArgExpression,jsDestructuringBlock,jsDestructuringArray,jsRestExpression,jsFlowArgumentDef skipwhite skipempty nextgroup=jsCommentFunction,jsFuncBlock,jsFlowReturn extend fold
-syntax region  jsClassBlock         contained matchgroup=jsClassBraces         start=/{/  end=/}/  contains=jsClassFuncName,jsClassMethodType,jsArrowFunction,jsArrowFuncArgs,jsComment,jsGenerator,jsDecorator,jsClassProperty,jsClassPropertyComputed,jsClassStringKey,jsAsyncKeyword,jsNoise extend fold
-syntax region  jsFuncBlock          contained matchgroup=jsFuncBraces          start=/{/  end=/}/  contains=@jsAll,jsBlock extend fold
-syntax region  jsIfElseBlock        contained matchgroup=jsIfElseBraces        start=/{/  end=/}/  contains=@jsAll,jsBlock extend fold
-syntax region  jsTryCatchBlock      contained matchgroup=jsTryCatchBraces      start=/{/  end=/}/  contains=@jsAll,jsBlock skipwhite skipempty nextgroup=jsCatch,jsFinally extend fold
-syntax region  jsFinallyBlock       contained matchgroup=jsFinallyBraces       start=/{/  end=/}/  contains=@jsAll,jsBlock extend fold
-syntax region  jsSwitchBlock        contained matchgroup=jsSwitchBraces        start=/{/  end=/}/  contains=@jsAll,jsBlock,jsSwitchCase extend fold
-syntax region  jsRepeatBlock        contained matchgroup=jsRepeatBraces        start=/{/  end=/}/  contains=@jsAll,jsBlock extend fold
-syntax region  jsDestructuringBlock contained matchgroup=jsDestructuringBraces start=/{/  end=/}/  contains=jsDestructuringProperty,jsDestructuringAssignment,jsDestructuringNoise,jsDestructuringPropertyComputed,jsSpreadExpression,jsComment nextgroup=jsFlowDefinition extend fold
-syntax region  jsDestructuringArray contained matchgroup=jsDestructuringBraces start=/\[/ end=/\]/ contains=jsDestructuringPropertyValue,jsDestructuringNoise,jsDestructuringProperty,jsSpreadExpression,jsDestructuringBlock,jsDestructuringArray,jsComment nextgroup=jsFlowDefinition extend fold
-syntax region  jsObject             contained matchgroup=jsObjectBraces        start=/{/  end=/}/  contains=jsObjectKey,jsObjectKeyString,jsObjectKeyComputed,jsObjectShorthandProp,jsObjectSeparator,jsObjectFuncName,jsObjectMethodType,jsGenerator,jsComment,jsObjectStringKey,jsSpreadExpression,jsDecorator,jsAsyncKeyword,jsTemplateString extend fold
-syntax region  jsBlock                        matchgroup=jsBraces              start=/{/  end=/}/  contains=@jsAll,jsSpreadExpression extend fold
-syntax region  jsModuleGroup        contained matchgroup=jsModuleBraces        start=/{/ end=/}/   contains=jsModuleKeyword,jsModuleComma,jsModuleAs,jsComment,jsFlowTypeKeyword skipwhite skipempty nextgroup=jsFrom fold
-syntax region  jsSpreadExpression   contained matchgroup=jsSpreadOperator      start=/\.\.\./ end=/[,}\]]\@=/ contains=@jsExpression
-syntax region  jsRestExpression     contained matchgroup=jsRestOperator        start=/\.\.\./ end=/[,)]\@=/
-syntax region  jsTernaryIf                    matchgroup=jsTernaryIfOperator   start=/?:\@!/  end=/\%(:\|}\@=\)/  contains=@jsExpression extend skipwhite skipempty nextgroup=@jsExpression
-" These must occur here or they will be override by jsTernaryIf
-syntax match   jsOperator           /?\.\ze\_D/
-syntax match   jsOperator           /??/ skipwhite skipempty nextgroup=@jsExpression
-
-syntax match   jsGenerator            contained /\*/ skipwhite skipempty nextgroup=jsFuncName,jsFuncArgs,jsFlowFunctionGroup
-syntax match   jsFuncName             contained /\<\K\k*/ skipwhite skipempty nextgroup=jsFuncArgs,jsFlowFunctionGroup
-syntax region  jsFuncArgExpression    contained matchgroup=jsFuncArgOperator start=/=/ end=/[,)]\@=/ contains=@jsExpression extend
-syntax match   jsFuncArgCommas        contained ','
-syntax keyword jsArguments            contained arguments
-syntax keyword jsForAwait             contained await skipwhite skipempty nextgroup=jsParenRepeat
-
-" Matches a single keyword argument with no parens
-syntax match   jsArrowFuncArgs  /\<\K\k*\ze\s*=>/ skipwhite contains=jsFuncArgs skipwhite skipempty nextgroup=jsArrowFunction extend
-" Matches a series of arguments surrounded in parens
-syntax match   jsArrowFuncArgs  /([^()]*)\ze\s*=>/ contains=jsFuncArgs skipempty skipwhite nextgroup=jsArrowFunction extend
-
-exe 'syntax match jsFunction /\<function\>/      skipwhite skipempty nextgroup=jsGenerator,jsFuncName,jsFuncArgs,jsFlowFunctionGroup skipwhite '.(exists('g:javascript_conceal_function') ? 'conceal cchar='.g:javascript_conceal_function : '')
-exe 'syntax match jsArrowFunction /=>/           skipwhite skipempty nextgroup=jsFuncBlock,jsCommentFunction '.(exists('g:javascript_conceal_arrow_function') ? 'conceal cchar='.g:javascript_conceal_arrow_function : '')
-exe 'syntax match jsArrowFunction /()\ze\s*=>/   skipwhite skipempty nextgroup=jsArrowFunction '.(exists('g:javascript_conceal_noarg_arrow_function') ? 'conceal cchar='.g:javascript_conceal_noarg_arrow_function : '')
-exe 'syntax match jsArrowFunction /_\ze\s*=>/    skipwhite skipempty nextgroup=jsArrowFunction '.(exists('g:javascript_conceal_underscore_arrow_function') ? 'conceal cchar='.g:javascript_conceal_underscore_arrow_function : '')
-
-" Classes
-syntax keyword jsClassKeyword           contained class
-syntax keyword jsExtendsKeyword         contained extends skipwhite skipempty nextgroup=@jsExpression
-syntax match   jsClassNoise             contained /\./
-syntax match   jsClassFuncName          contained /\<\K\k*\ze\s*[(<]/ skipwhite skipempty nextgroup=jsFuncArgs,jsFlowClassFunctionGroup
-syntax match   jsClassMethodType        contained /\<\%([gs]et\|static\)\ze\s\+\K\k*/ skipwhite skipempty nextgroup=jsAsyncKeyword,jsClassFuncName,jsClassProperty
-syntax region  jsClassDefinition                  start=/\<class\>/ end=/\(\<extends\>\s\+\)\@<!{\@=/ contains=jsClassKeyword,jsExtendsKeyword,jsClassNoise,@jsExpression,jsFlowClassGroup skipwhite skipempty nextgroup=jsCommentClass,jsClassBlock,jsFlowClassGroup
-syntax match   jsClassProperty          contained /\<\K\k*\ze\s*[=;]/ skipwhite skipempty nextgroup=jsClassValue,jsFlowClassDef
-syntax region  jsClassValue             contained start=/=/ end=/\_[;}]\@=/ contains=@jsExpression
-syntax region  jsClassPropertyComputed  contained matchgroup=jsBrackets start=/\[/ end=/]/ contains=@jsExpression skipwhite skipempty nextgroup=jsFuncArgs,jsClassValue extend
-syntax region  jsClassStringKey         contained start=+\z(["']\)+  skip=+\\\%(\z1\|$\)+  end=+\z1\|$+  contains=jsSpecial extend skipwhite skipempty nextgroup=jsFuncArgs
-
-" Destructuring
-syntax match   jsDestructuringPropertyValue     contained /\k\+/
-syntax match   jsDestructuringProperty          contained /\k\+\ze\s*=/ skipwhite skipempty nextgroup=jsDestructuringValue
-syntax match   jsDestructuringAssignment        contained /\k\+\ze\s*:/ skipwhite skipempty nextgroup=jsDestructuringValueAssignment
-syntax region  jsDestructuringValue             contained start=/=/ end=/[,}\]]\@=/ contains=@jsExpression extend
-syntax region  jsDestructuringValueAssignment   contained start=/:/ end=/[,}=]\@=/ contains=jsDestructuringPropertyValue,jsDestructuringBlock,jsNoise,jsDestructuringNoise skipwhite skipempty nextgroup=jsDestructuringValue extend
-syntax match   jsDestructuringNoise             contained /[,[\]]/
-syntax region  jsDestructuringPropertyComputed  contained matchgroup=jsDestructuringBraces start=/\[/ end=/]/ contains=@jsExpression skipwhite skipempty nextgroup=jsDestructuringValue,jsDestructuringValueAssignment,jsDestructuringNoise extend fold
-
-" Comments
-syntax keyword jsCommentTodo    contained TODO FIXME XXX TBD NOTE
-syntax region  jsComment        start=+//+ end=/$/ contains=jsCommentTodo,@Spell extend keepend
-syntax region  jsComment        start=+/\*+  end=+\*/+ contains=jsCommentTodo,@Spell fold extend keepend
-syntax region  jsEnvComment     start=/\%^#!/ end=/$/ display
-
-" Specialized Comments - These are special comment regexes that are used in
-" odd places that maintain the proper nextgroup functionality. It sucks we
-" can't make jsComment a skippable type of group for nextgroup
-syntax region  jsCommentFunction    contained start=+//+ end=/$/    contains=jsCommentTodo,@Spell skipwhite skipempty nextgroup=jsFuncBlock,jsFlowReturn extend keepend
-syntax region  jsCommentFunction    contained start=+/\*+ end=+\*/+ contains=jsCommentTodo,@Spell skipwhite skipempty nextgroup=jsFuncBlock,jsFlowReturn fold extend keepend
-syntax region  jsCommentClass       contained start=+//+ end=/$/    contains=jsCommentTodo,@Spell skipwhite skipempty nextgroup=jsClassBlock,jsFlowClassGroup extend keepend
-syntax region  jsCommentClass       contained start=+/\*+ end=+\*/+ contains=jsCommentTodo,@Spell skipwhite skipempty nextgroup=jsClassBlock,jsFlowClassGroup fold extend keepend
-syntax region  jsCommentIfElse      contained start=+//+ end=/$/    contains=jsCommentTodo,@Spell skipwhite skipempty nextgroup=jsIfElseBlock extend keepend
-syntax region  jsCommentIfElse      contained start=+/\*+ end=+\*/+ contains=jsCommentTodo,@Spell skipwhite skipempty nextgroup=jsIfElseBlock fold extend keepend
-syntax region  jsCommentRepeat      contained start=+//+ end=/$/    contains=jsCommentTodo,@Spell skipwhite skipempty nextgroup=jsRepeatBlock extend keepend
-syntax region  jsCommentRepeat      contained start=+/\*+ end=+\*/+ contains=jsCommentTodo,@Spell skipwhite skipempty nextgroup=jsRepeatBlock fold extend keepend
-
-" Decorators
-syntax match   jsDecorator                    /^\s*@/ nextgroup=jsDecoratorFunction
-syntax match   jsDecoratorFunction  contained /\h[a-zA-Z0-9_.]*/ nextgroup=jsParenDecorator
-
-if exists("javascript_plugin_jsdoc")
-  runtime extras/jsdoc.vim
-  " NGDoc requires JSDoc
-  if exists("javascript_plugin_ngdoc")
-    runtime extras/ngdoc.vim
-  endif
-endif
-
-if exists("javascript_plugin_flow")
-  runtime extras/flow.vim
-endif
-
-syntax cluster jsExpression  contains=jsBracket,jsParen,jsObject,jsTernaryIf,jsTaggedTemplate,jsTemplateString,jsString,jsRegexpString,jsNumber,jsFloat,jsOperator,jsOperatorKeyword,jsBooleanTrue,jsBooleanFalse,jsNull,jsFunction,jsArrowFunction,jsGlobalObjects,jsExceptions,jsFutureKeys,jsDomErrNo,jsDomNodeConsts,jsHtmlEvents,jsFuncCall,jsUndefined,jsNan,jsPrototype,jsBuiltins,jsNoise,jsClassDefinition,jsArrowFunction,jsArrowFuncArgs,jsParensError,jsComment,jsArguments,jsThis,jsSuper,jsDo,jsForAwait,jsAsyncKeyword,jsStatement,jsDot
-syntax cluster jsAll         contains=@jsExpression,jsStorageClass,jsConditional,jsRepeat,jsReturn,jsException,jsTry,jsNoise,jsBlockLabel
-
-" Define the default highlighting.
-" For version 5.7 and earlier: only when not done already
-" For version 5.8 and later: only when an item doesn't have highlighting yet
-if version >= 508 || !exists("did_javascript_syn_inits")
-  if version < 508
-    let did_javascript_syn_inits = 1
-    command -nargs=+ HiLink hi link <args>
-  else
-    command -nargs=+ HiLink hi def link <args>
-  endif
-  HiLink jsComment              Comment
-  HiLink jsEnvComment           PreProc
-  HiLink jsParensIfElse         jsParens
-  HiLink jsParensRepeat         jsParens
-  HiLink jsParensSwitch         jsParens
-  HiLink jsParensCatch          jsParens
-  HiLink jsCommentTodo          Todo
-  HiLink jsString               String
-  HiLink jsObjectKeyString      String
-  HiLink jsTemplateString       String
-  HiLink jsObjectStringKey      String
-  HiLink jsClassStringKey       String
-  HiLink jsTaggedTemplate       StorageClass
-  HiLink jsTernaryIfOperator    Operator
-  HiLink jsRegexpString         String
-  HiLink jsRegexpBoundary       SpecialChar
-  HiLink jsRegexpQuantifier     SpecialChar
-  HiLink jsRegexpOr             Conditional
-  HiLink jsRegexpMod            SpecialChar
-  HiLink jsRegexpBackRef        SpecialChar
-  HiLink jsRegexpGroup          jsRegexpString
-  HiLink jsRegexpCharClass      Character
-  HiLink jsCharacter            Character
-  HiLink jsPrototype            Special
-  HiLink jsConditional          Conditional
-  HiLink jsBranch               Conditional
-  HiLink jsLabel                Label
-  HiLink jsReturn               Statement
-  HiLink jsRepeat               Repeat
-  HiLink jsDo                   Repeat
-  HiLink jsStatement            Statement
-  HiLink jsException            Exception
-  HiLink jsTry                  Exception
-  HiLink jsFinally              Exception
-  HiLink jsCatch                Exception
-  HiLink jsAsyncKeyword         Keyword
-  HiLink jsForAwait             Keyword
-  HiLink jsArrowFunction        Type
-  HiLink jsFunction             Type
-  HiLink jsGenerator            jsFunction
-  HiLink jsArrowFuncArgs        jsFuncArgs
-  HiLink jsFuncName             Function
-  HiLink jsFuncCall             Function
-  HiLink jsClassFuncName        jsFuncName
-  HiLink jsObjectFuncName       Function
-  HiLink jsArguments            Special
-  HiLink jsError                Error
-  HiLink jsParensError          Error
-  HiLink jsOperatorKeyword      jsOperator
-  HiLink jsOperator             Operator
-  HiLink jsOf                   Operator
-  HiLink jsStorageClass         StorageClass
-  HiLink jsClassKeyword         Keyword
-  HiLink jsExtendsKeyword       Keyword
-  HiLink jsThis                 Special
-  HiLink jsSuper                Constant
-  HiLink jsNan                  Number
-  HiLink jsNull                 Type
-  HiLink jsUndefined            Type
-  HiLink jsNumber               Number
-  HiLink jsFloat                Float
-  HiLink jsBooleanTrue          Boolean
-  HiLink jsBooleanFalse         Boolean
-  HiLink jsObjectColon          jsNoise
-  HiLink jsNoise                Noise
-  HiLink jsDot                  Noise
-  HiLink jsBrackets             Noise
-  HiLink jsParens               Noise
-  HiLink jsBraces               Noise
-  HiLink jsFuncBraces           Noise
-  HiLink jsFuncParens           Noise
-  HiLink jsClassBraces          Noise
-  HiLink jsClassNoise           Noise
-  HiLink jsIfElseBraces         Noise
-  HiLink jsTryCatchBraces       Noise
-  HiLink jsModuleBraces         Noise
-  HiLink jsObjectBraces         Noise
-  HiLink jsObjectSeparator      Noise
-  HiLink jsFinallyBraces        Noise
-  HiLink jsRepeatBraces         Noise
-  HiLink jsSwitchBraces         Noise
-  HiLink jsSpecial              Special
-  HiLink jsTemplateBraces       Noise
-  HiLink jsGlobalObjects        Constant
-  HiLink jsGlobalNodeObjects    Constant
-  HiLink jsExceptions           Constant
-  HiLink jsBuiltins             Constant
-  HiLink jsImport               Include
-  HiLink jsExport               Include
-  HiLink jsExportDefault        StorageClass
-  HiLink jsExportDefaultGroup   jsExportDefault
-  HiLink jsModuleAs             Include
-  HiLink jsModuleComma          jsNoise
-  HiLink jsModuleAsterisk       Noise
-  HiLink jsFrom                 Include
-  HiLink jsDecorator            Special
-  HiLink jsDecoratorFunction    Function
-  HiLink jsParensDecorator      jsParens
-  HiLink jsFuncArgOperator      jsFuncArgs
-  HiLink jsClassProperty        jsObjectKey
-  HiLink jsObjectShorthandProp  jsObjectKey
-  HiLink jsSpreadOperator       Operator
-  HiLink jsRestOperator         Operator
-  HiLink jsRestExpression       jsFuncArgs
-  HiLink jsSwitchColon          Noise
-  HiLink jsClassMethodType      Type
-  HiLink jsObjectMethodType     Type
-  HiLink jsClassDefinition      jsFuncName
-  HiLink jsBlockLabel           Identifier
-  HiLink jsBlockLabelKey        jsBlockLabel
-
-  HiLink jsDestructuringBraces     Noise
-  HiLink jsDestructuringProperty   jsFuncArgs
-  HiLink jsDestructuringAssignment jsObjectKey
-  HiLink jsDestructuringNoise      Noise
-
-  HiLink jsCommentFunction      jsComment
-  HiLink jsCommentClass         jsComment
-  HiLink jsCommentIfElse        jsComment
-  HiLink jsCommentRepeat        jsComment
-
-  HiLink jsDomErrNo             Constant
-  HiLink jsDomNodeConsts        Constant
-  HiLink jsDomElemAttrs         Label
-  HiLink jsDomElemFuncs         PreProc
-
-  HiLink jsHtmlEvents           Special
-  HiLink jsHtmlElemAttrs        Label
-  HiLink jsHtmlElemFuncs        PreProc
-
-  HiLink jsCssStyles            Label
-
-  delcommand HiLink
-endif
-
-" Define the htmlJavaScript for HTML syntax html.vim
-syntax cluster  htmlJavaScript       contains=@jsAll,jsImport,jsExport
-syntax cluster  javaScriptExpression contains=@jsAll
-
-" Vim's default html.vim highlights all javascript as 'Special'
-hi! def link javaScript              NONE
-
-let b:current_syntax = "javascript"
-if main_syntax == 'javascript'
-  unlet main_syntax
-endif
diff --git a/sources_non_forked/vim-lastplace/.gitignore b/sources_non_forked/vim-lastplace/.gitignore
deleted file mode 100644
index 926ccaa..0000000
--- a/sources_non_forked/vim-lastplace/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-doc/tags
diff --git a/sources_non_forked/vim-lastplace/LICENSE b/sources_non_forked/vim-lastplace/LICENSE
deleted file mode 100644
index 9717040..0000000
--- a/sources_non_forked/vim-lastplace/LICENSE
+++ /dev/null
@@ -1,22 +0,0 @@
-The MIT License (MIT)
-
-Copyright (c) 2015 - 2017 Greg Dietsche
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in all
-copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-SOFTWARE.
-
diff --git a/sources_non_forked/vim-lastplace/README.md b/sources_non_forked/vim-lastplace/README.md
deleted file mode 100644
index 507b215..0000000
--- a/sources_non_forked/vim-lastplace/README.md
+++ /dev/null
@@ -1,105 +0,0 @@
-# vim-lastplace v3.1.1
-
-Intelligently reopen files at your last edit position. By default git,
-svn, and mercurial commit messages are ignored because you
-probably want to type a new message and not re-edit the previous
-one.
-
-## Advantages
-Advantages over the snippets that can be found around the net include:
-* Commit messages automatically start at the beginning of a file. This is important because many version control systems re-use the same file for commit message editing.
-* Maximizes Available Context
-    - Center the cursor vertically after restoring last edit position.
-    - Keep as much of the file on screen as possible when last edit position is at the end of the file.
-* Opens folds if the last edit position is inside a fold.
-* Works properly with new file templates and scripts that jump to a specific line in them.
-
-## Installation  
-You can use [pathogen.vim](https://github.com/tpope/vim-pathogen) or other plugin managers to install and use vim-lastplace.
-
-    cd ~/.vim/bundle
-    git clone git://github.com/farmergreg/vim-lastplace.git
-
-Depending on which Vim package you're using, Vim may be preconfigured with
-last-edit-position logic that doesn't work quite as well as vim-lastplace.
-If so, you may want to disable that in favor of vim-lastplace. For example,
-for Vim as packaged with Git for Windows, you can edit
-`C:\Program Files\Git\etc\vimrc` and comment out the "Remember positions in files"
-`autocmd BufReadPost *` block.
-
-## Configuration
-You can configure what file types to ignore by setting
-g:lastplace_ignore in your vimrc. This is a comma separated list.
-By default it is set to:
-
-        let g:lastplace_ignore = "gitcommit,gitrebase,svn,hgcommit"
-
-You can configure buffer types to ignore by setting
-g:lastplace_ignore_buftype in your vimrc. This is a comma separated list.
-By default it is set to:
-
-        let g:lastplace_ignore_buftype = "quickfix,nofile,help"
-
-Folds are automatically opened when jumping to the last edit position. If you
-do not like this behavior you can disable it by putting this in your vimrc:
-
-        let g:lastplace_open_folds = 0
-
-## Miscellaneous
-This plugin is complete and stable. Please do not be afraid to try it even
-if there is very little recent activity in this repository. If you do find
-a bug, please submit a pull request that fixes whatever problem you're having.
-
-## Version History
-vim-lastplace uses [semver](http://semver.org/) to manage version numbers.
-
-### 3.1.1
-- Add 'nofile' and 'help' to lastplace_ignore_buftype. (Issue [#14](https://github.com/farmergreg/vim-lastplace/issues/14))
-- Do not jump when a new file is created (Issue [#15](https://github.com/farmergreg/vim-lastplace/issues/15), [#16](https://github.com/farmergreg/vim-lastplace/issues/16))
-
-### 3.1.0
-- Add g:lastplace_ignore_buftype setting.
-- Update github links from username dietsche to farmergreg.
-
-### 3.0.4
-- Add g:lastplace_open_folds option.
-
-### 3.0.3
-- Point release for Debian packaging. Changes all http links to https. No code changes.
-
-### 3.0.2
-- A fix for files that are smaller than the current screen size (issue #8)
-
-### 3.0.1
-- A fix for files with modelines.
-
-### 3.0.0
-
-- Open folds if the last edited area is inside a closed fold.
-
-### 2.0.1
-
-- Add gitrebase filetype to the ignore list.
-
-### 2.0.0
-
-- Center the screen when restoring the cursor position.
-- When at the end of a file, keep as much of it on screen as possible.
-
-### 1.0.0
-
-- Initial version.
-
-## About
-
-- Author  :  Gregory L. Dietsche
-- Web Page: https://www.gregd.org/
-
-Get the latest version, submit pull requests, and file bug reports
-on GitHub:
-- https://github.com/farmergreg/vim-lastplace
-
-If you like this plugin, please star and rate it on these sites:
-
-- [GitHub](https://github.com/farmergreg/vim-lastplace)
-- [Vim.org](http://www.vim.org/scripts/script.php?script_id=5090)
diff --git a/sources_non_forked/vim-lastplace/doc/vim-lastplace.txt b/sources_non_forked/vim-lastplace/doc/vim-lastplace.txt
deleted file mode 100644
index 3105c27..0000000
--- a/sources_non_forked/vim-lastplace/doc/vim-lastplace.txt
+++ /dev/null
@@ -1,36 +0,0 @@
-*vim-lastplace*  Intelligently reopen files where you left off.
-
-Author:  Gregory L. Dietsche <https://www.gregd.org/>
-License: MIT
-Version: 3.1.1
-
-INTRODUCTION                                    *vim-lastplace-introduction*
-
-Intelligently reopen files where you left off.  By default git,
-svn, and mercurial commit messages are ignored because you
-probably want to type a new message and not re-edit the previous
-one.
-
-You can configure what file types to ignore by setting
-g:lastplace_ignore in your vimrc. This is a comma separated list.
-By default it is set to:
-
-        let g:lastplace_ignore = "gitcommit,gitrebase,svn,hgcommit"
-
-You can configure buffer types to ignore by setting
-g:lastplace_ignore_buftype in your vimrc. This is a comma separated list.
-By default it is set to:
-
-        let g:lastplace_ignore_buftype = "quickfix,nofile,help"
-
-Folds are automatically opened when jumping to the last edit position. If you
-do not like this behavior you can disable it by putting this in your vimrc:
-
-        let g:lastplace_open_folds = 0
-
-ABOUT                                           *vim-lastplace-about*
-
-Get the latest version and/or report a bug on GitHub:
-        https://github.com/farmergreg/vim-lastplace
-
- vim:tw=78:et:ft=help:norl:
diff --git a/sources_non_forked/vim-lastplace/plugin/vim-lastplace.vim b/sources_non_forked/vim-lastplace/plugin/vim-lastplace.vim
deleted file mode 100644
index 8b2478c..0000000
--- a/sources_non_forked/vim-lastplace/plugin/vim-lastplace.vim
+++ /dev/null
@@ -1,80 +0,0 @@
-" ============================================================================
-" File:        vim-lastplace.vim
-" Description: Reopen files where you left off. Configurable.
-" Author:      Gregory L. Dietsche <vim@gregd.org>
-" Licence:     MIT
-" Website:     https://www.gregd.org/
-" Version:     3.1.1
-" ============================================================================
-
-if exists("b:loaded_lastplace_plugin") || &cp
-	finish
-endif
-let b:loaded_lastplace_plugin = 1
-
-scriptencoding utf-8
-
-if !exists('g:lastplace_ignore')
-	let g:lastplace_ignore = "gitcommit,gitrebase,svn,hgcommit"
-endif
-
-if !exists('g:lastplace_open_folds')
-	let g:lastplace_open_folds = 1
-endif
-
-if !exists('g:lastplace_ignore_buftype')
-	let g:lastplace_ignore_buftype = "quickfix,nofile,help"
-endif
-
-fu! s:lastplace()
-	if index(split(g:lastplace_ignore_buftype, ","), &buftype) != -1 
-		return
-   	endif
-
-	if index(split(g:lastplace_ignore, ","), &filetype) != -1
-		return
-	endif
-
-	try
-		"if the file does not exist on disk (a new, unsaved file) then do nothing
-		if empty(glob(@%))
-			return
-		endif
-	catch
-		return
-	endtry
-
-	if line("'\"") > 0 && line("'\"") <= line("$")
-		"if the last edit position is set and is less than the
-		"number of lines in this buffer.
-
-		if line("w$") == line("$")
-			"if the last line in the current buffer is
-			"also the last line visible in this window
-			execute "normal! g`\""
-
-		elseif line("$") - line("'\"") > ((line("w$") - line("w0")) / 2) - 1
-			"if we're not at the bottom of the file, center the
-			"cursor on the screen after we make the jump
-			execute "normal! g`\"zz"
-
-		else
-			"otherwise, show as much context as we can by jumping
-			"to the end of the file and then to the mark. If we
-			"pressed zz here, there would be blank lines at the
-			"bottom of the screen. We intentionally leave the
-			"last line blank by pressing <c-e> so the user has a
-			"clue that they are near the end of the file.
-			execute "normal! \G'\"\<c-e>"
-		endif
-	endif
-	if foldclosed(".") != -1 && g:lastplace_open_folds
-		"if we're in a fold, make the current line visible and recenter screen
-		execute "normal! zvzz"
-	endif
-endf
-
-augroup lastplace_plugin
-	autocmd!
-	autocmd BufWinEnter * call s:lastplace()
-augroup END
diff --git a/sources_non_forked/vim-markdown/.gitignore b/sources_non_forked/vim-markdown/.gitignore
deleted file mode 100644
index c6f4595..0000000
--- a/sources_non_forked/vim-markdown/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-build
-/doc/tags
diff --git a/sources_non_forked/vim-markdown/.travis.yml b/sources_non_forked/vim-markdown/.travis.yml
deleted file mode 100644
index 338161c..0000000
--- a/sources_non_forked/vim-markdown/.travis.yml
+++ /dev/null
@@ -1,34 +0,0 @@
-language: vim
-
-os:
-  - linux
-  - osx
-
-env:
-  - TEST=package
-  - TEST=latest
-
-before_script: |
-  if [ "$TEST" = "package" ]; then
-    if [ "$TRAVIS_OS_NAME" = "linux" ]; then
-      sudo apt-get -y update
-      sudo apt-get -y install vim
-    fi
-  else
-    cd ..
-    git clone --depth 1 https://github.com/vim/vim
-    cd vim
-    ./configure --with-features=huge
-    make
-    sudo make install
-    export PATH="/usr/local/bin:$PATH"
-    cd "$TRAVIS_BUILD_DIR"
-  fi
-  if [ "$TRAVIS_OS_NAME" = "osx" ]; then
-    curl https://bootstrap.pypa.io/get-pip.py | sudo python
-  fi
-  sudo -H pip install virtualenv
-
-script:
-  - make test
-  - make doc
diff --git a/sources_non_forked/vim-markdown/CONTRIBUTING.md b/sources_non_forked/vim-markdown/CONTRIBUTING.md
deleted file mode 100644
index 86912a4..0000000
--- a/sources_non_forked/vim-markdown/CONTRIBUTING.md
+++ /dev/null
@@ -1,58 +0,0 @@
-# CONTRIBUTING
-
-These contributing guidelines were accepted rather late in the history of this plugin, after much code had already been written.
-
-If you find any existing behavior which does not conform to these guidelines, please correct it and send a pull request.
-
-## General Rules
-
-Every non local identifier must start with `g:vim_markdown_`.
-
-## Documentation
-
-Every new feature must be documented under in the [README.md](README.md). Documentation must be written in [GFM](https://help.github.com/articles/github-flavored-markdown) since GitHub itself is the primary to HTML converter used. In particular, remember that GFM adds line breaks at single newlines, so just forget about the 70 characters wide rule.
-
-Vim help file [doc/vim-markdown.txt](doc/vim-markdown.txt) will be generated from [README.md](README.md) by `make doc` using [vim-tools](https://github.com/xolox/vim-tools).
-
-## Markdown Flavors
-
-There are many flavors of markdown, each one with an unique feature set. This plugin uses the following strategy to deal with all those flavors:
-
-- Features from the [original markdown](http://daringfireball.net/projects/markdown/syntax) are turned on by default. They may not even have an option that turns them off.
-
-- Features from other markdown flavors *must* have an option that turns them on or off. If the feature is common enough across multiple versions of markdown, it may be turned on by default. This shall be decided by the community when the merge request is done.
-
-- If possible, cite the exact point in the documentation of the flavor where a feature is specified. If the feature is not documented, you may also reference the source code itself of the implementation. This way, people who do not know that flavor can check if your implementation is correct.
-
-- Do not use the name of a flavor for a feature that is used across multiple flavors. Instead, create a separate flavor option, that automatically sets each feature.
-
-    For example, fenced code blocks (putting code between pairs of three backticks) is not part of the original markdown, but is supported by [GFM](https://help.github.com/articles/github-flavored-markdown#fenced-code-blocks) and [Jekyll](http://jekyllrb.com/docs/configuration/).
-
-    Therefore, instead of creating an option `g:vim_markdown_gfm_fenced_code_block`, and an option `g:vim_markdown_jekyll_fenced_code_block`, create a single option `g:vim_markdown_fenced_code_block`.
-
-    Next, if there are many more than one Jekyll feature options, create a `g:vim_markdown_jekyll` option that turns them all on at once.
-
-## Style
-
-When choosing between multiple valid Markdown syntaxes, the default behavior must be that specified at: <http://www.cirosantilli.com/markdown-styleguide>
-
-If you wish to have a behavior that differs from that style guide, add an option to turn it on or off, and leave it off by default.
-
-## Tests
-
-All new features must have unit tests.
-
-## Issues
-
-Issues are tracked within GitHub.
-
-When reporting issues, your report is more effective if you include a minimal example file that reproduces the problem. Try to trim out as much as possible, until you have the smallest possible file that still reproduces the issue. Paste the example inline into your issue report, quoted using four spaces at the beginning of each line, like this example from issue [#189](https://github.com/plasticboy/vim-markdown/issues/189):
-
-```
-Minimal example:
-
-    ```
-    =
-    ```
-    bad!
-```
diff --git a/sources_non_forked/vim-markdown/Makefile b/sources_non_forked/vim-markdown/Makefile
deleted file mode 100644
index 0b287e2..0000000
--- a/sources_non_forked/vim-markdown/Makefile
+++ /dev/null
@@ -1,88 +0,0 @@
-VIMDIR=$(DESTDIR)/usr/share/vim
-ADDONS=${VIMDIR}/addons
-REGISTRY=${VIMDIR}/registry
-
-all:
-
-install:
-	mkdir -pv ${ADDONS}/ftdetect
-	cp -v ftdetect/markdown.vim ${ADDONS}/ftdetect/markdown.vim
-	mkdir -pv ${ADDONS}/ftplugin
-	cp -v ftplugin/markdown.vim ${ADDONS}/ftplugin/markdown.vim
-	mkdir -pv ${ADDONS}/syntax
-	cp -v syntax/markdown.vim ${ADDONS}/syntax/markdown.vim
-	mkdir -pv ${ADDONS}/after/ftplugin
-	cp -v after/ftplugin/markdown.vim ${ADDONS}/after/ftplugin/markdown.vim
-	mkdir -pv ${ADDONS}/indent
-	cp -v indent/markdown.vim ${ADDONS}/indent/markdown.vim
-	mkdir -pv ${ADDONS}/doc
-	cp -v doc/vim-markdown.txt ${ADDONS}/doc/vim-markdown.txt
-	mkdir -pv ${REGISTRY}
-	cp -v registry/markdown.yaml ${REGISTRY}/markdown.yaml
-
-test: build/tabular build/vim-toml build/vim-json build/vader.vim
-	test/run-tests.sh
-.PHONY: test
-
-update: build/tabular build/vim-toml build/vim-json build/vader.vim
-	cd build/tabular && git pull
-	cd build/vim-toml && git pull
-	cd build/vim-json && git pull
-	cd build/vader.vim && git pull
-.PHONY: update
-
-build/tabular: | build
-	git clone https://github.com/godlygeek/tabular build/tabular
-
-build/vim-toml: | build
-	git clone https://github.com/cespare/vim-toml build/vim-toml
-
-build/vim-json: | build
-	git clone https://github.com/elzr/vim-json build/vim-json
-
-build/vader.vim: | build
-	git clone https://github.com/junegunn/vader.vim build/vader.vim
-
-build:
-	mkdir build
-
-doc: build/html2vimdoc build/vim-tools
-	sed -e '/^\[!\[Build Status\]/d' \
-	    -e '/^1\. \[/d' README.md > doc/tmp.md # remove table of contents
-	build/html2vimdoc/bin/python build/vim-tools/html2vimdoc.py -f vim-markdown \
-		doc/tmp.md | \
-		sed -E -e "s/[[:space:]]*$$//" -e "# remove trailing spaces" \
-		    -e "/^.{79,}\|$$/ {" -e "# wrap table of contents over 79" \
-		    -e "h" -e "# save the matched line to the hold space" \
-		    -e "s/^(.*) (\|[^|]*\|)$$/\1/" -e "# make content title" \
-		    -e "p" -e "# print title" \
-		    -e "g" -e "# restore the matched line" \
-		    -e "s/^.* (\|[^|]*\|)$$/ \1/" -e "# make link" \
-		    -e ":c" -e "s/^(.{1,78})$$/ \1/" -e "tc" -e "# align right" \
-		    -e "}" \
-		    -e "/^- '[^']*':( |$$)/ {" \
-		    -e "h" -e "# save the matched line to the hold space" \
-		    -e "s/^- '([^']{3,})':.*/ \*\1\*/" -e "# make command reference" \
-		    -e "s/^- '([^']{1,2})':.*/ \*vim-markdown-\1\*/" -e "# short command" \
-		    -e ":a" -e "s/^(.{1,78})$$/ \1/" -e "ta" -e "# align right" \
-		    -e "G" -e "# append the matched line after the command reference" \
-		    -e "}" \
-		    -e "/^- 'g:vim_markdown_[[:alnum:]_]*'$$/ {" \
-		    -e "h" -e "# save the matched line to the hold space" \
-		    -e "s/^- '([^']*)'$$/ \*\1\*/" -e "# make global variable reference" \
-		    -e ":g" -e "s/^(.{1,78})$$/ \1/" -e "tg" -e "# align right" \
-		    -e "G" -e "# append the matched line after the global variable reference" \
-		    -e "}" > doc/vim-markdown.txt && rm -f doc/tmp.md
-
-.PHONY: doc
-
-# Prerequire Python and virtualenv.
-# $ sudo pip install virtualenv
-# Create the virtual environment.
-# Install the dependencies.
-build/html2vimdoc: | build
-	virtualenv build/html2vimdoc
-	build/html2vimdoc/bin/pip install beautifulsoup coloredlogs==4.0 markdown
-
-build/vim-tools: | build
-	git clone https://github.com/xolox/vim-tools.git build/vim-tools
diff --git a/sources_non_forked/vim-markdown/README.md b/sources_non_forked/vim-markdown/README.md
deleted file mode 100644
index fd3be68..0000000
--- a/sources_non_forked/vim-markdown/README.md
+++ /dev/null
@@ -1,454 +0,0 @@
-# Vim Markdown
-
-[![Build Status](https://travis-ci.org/plasticboy/vim-markdown.svg)](https://travis-ci.org/plasticboy/vim-markdown)
-
-Syntax highlighting, matching rules and mappings for [the original Markdown](http://daringfireball.net/projects/markdown/) and extensions.
-
-1. [Installation](#installation)
-1. [Basic usage](#basic-usage)
-1. [Options](#options)
-1. [Mappings](#mappings)
-1. [Commands](#commands)
-1. [Credits](#credits)
-1. [License](#license)
-
-## Installation
-
-If you use [Vundle](https://github.com/gmarik/vundle), add the following lines to your `~/.vimrc`:
-
-```vim
-Plugin 'godlygeek/tabular'
-Plugin 'plasticboy/vim-markdown'
-```
-
-The `tabular` plugin must come *before* `vim-markdown`.
-
-Then run inside Vim:
-
-```vim
-:so ~/.vimrc
-:PluginInstall
-```
-
-If you use [Pathogen](https://github.com/tpope/vim-pathogen), do this:
-
-```sh
-cd ~/.vim/bundle
-git clone https://github.com/plasticboy/vim-markdown.git
-```
-
-To install without Pathogen using the Debian [vim-addon-manager](http://packages.qa.debian.org/v/vim-addon-manager.html), do this:
-
-```sh
-git clone https://github.com/plasticboy/vim-markdown.git
-cd vim-markdown
-sudo make install
-vim-addon-manager install markdown
-```
-
-If you are not using any package manager, download the [tarball](https://github.com/plasticboy/vim-markdown/archive/master.tar.gz) and do this:
-
-```sh
-cd ~/.vim
-tar --strip=1 -zxf vim-markdown-master.tar.gz
-```
-
-## Basic usage
-
-### Folding
-
-Folding is enabled for headers by default.
-
-The following commands are useful to open and close folds:
-
-- `zr`: reduces fold level throughout the buffer
-- `zR`: opens all folds
-- `zm`: increases fold level throughout the buffer
-- `zM`: folds everything all the way
-- `za`: open a fold your cursor is on
-- `zA`: open a fold your cursor is on recursively
-- `zc`: close a fold your cursor is on
-- `zC`: close a fold your cursor is on recursively
-
-[Options](#options) are available to disable folding or change folding style.
-
-Try `:help fold-expr` and `:help fold-commands` for details.
-
-### Concealing
-
-Concealing is set for some syntax such as bold, italic, code block and link.
-
-Concealing lets you conceal text with other text. The actual source text is not modified. If you put your cursor on the concealed line, the conceal goes away.
-
-[Options](#options) are available to disable or change concealing.
-
-Try `:help concealcursor` and `:help conceallevel` for details.
-
-## Options
-
-### Disable Folding
-
--   `g:vim_markdown_folding_disabled`
-
-    Add the following line to your `.vimrc` to disable the folding configuration:
-
-        let g:vim_markdown_folding_disabled = 1
-
-    This option only controls Vim Markdown specific folding configuration.
-
-    To enable/disable folding use Vim's standard folding configuration.
-
-        set [no]foldenable
-
-### Change fold style
-
--   `g:vim_markdown_folding_style_pythonic`
-
-    To fold in a style like [python-mode](https://github.com/klen/python-mode), add the following to your `.vimrc`:
-
-        let g:vim_markdown_folding_style_pythonic = 1
-
-    `g:vim_markdown_folding_level` setting (default 1) is set to `foldlevel`.
-    Thus level 1 heading which is served as a document title is expanded by default.
-
--   `g:vim_markdown_override_foldtext`
-
-    To prevent foldtext from being set add the following to your `.vimrc`:
-
-        let g:vim_markdown_override_foldtext = 0
-
-### Set header folding level
-
--   `g:vim_markdown_folding_level`
-
-    Folding level is a number between 1 and 6. By default, if not specified, it is set to 1.
-
-        let g:vim_markdown_folding_level = 6
-
-    Tip: it can be changed on the fly with:
-
-        :let g:vim_markdown_folding_level = 1
-        :edit
-
-### Disable Default Key Mappings
-
--   `g:vim_markdown_no_default_key_mappings`
-
-    Add the following line to your `.vimrc` to disable default key mappings:
-
-        let g:vim_markdown_no_default_key_mappings = 1
-
-    You can also map them by yourself with `<Plug>` mappings.
-
-### Enable TOC window auto-fit
-
--   `g:vim_markdown_toc_autofit`
-
-    Allow for the TOC window to auto-fit when it's possible for it to shrink.
-    It never increases its default size (half screen), it only shrinks.
-
-        let g:vim_markdown_toc_autofit = 1
-
-### Text emphasis restriction to single-lines
-
--   `g:vim_markdown_emphasis_multiline`
-
-    By default text emphasis works across multiple lines until a closing token is found. However, it's possible to restrict text emphasis to a single line (i.e., for it to be applied a closing token must be found on the same line). To do so:
-
-        let g:vim_markdown_emphasis_multiline = 0
-
-### Syntax Concealing
-
--   `g:vim_markdown_conceal`
-
-    Concealing is set for some syntax.
-
-    For example, conceal `[link text](link url)` as just `link text`.
-    Also, `_italic_` and `*italic*` will conceal to just _italic_.
-    Similarly `__bold__`, `**bold**`, `___italic bold___`, and `***italic bold***`
-    will conceal to just __bold__, **bold**, ___italic bold___, and ***italic bold*** respectively.
-
-    To enable conceal use Vim's standard conceal configuration.
-
-        set conceallevel=2
-
-    To disable conceal regardless of `conceallevel` setting, add the following to your `.vimrc`:
-
-        let g:vim_markdown_conceal = 0
-
-    To disable math conceal with LaTeX math syntax enabled, add the following to your `.vimrc`:
-
-        let g:tex_conceal = ""
-        let g:vim_markdown_math = 1
-
--   `g:vim_markdown_conceal_code_blocks`
-
-    Disabling conceal for code fences requires an additional setting:
-
-        let g:vim_markdown_conceal_code_blocks = 0
-
-### Fenced code block languages
-
--   `g:vim_markdown_fenced_languages`
-
-    You can use filetype name as fenced code block languages for syntax highlighting.
-    If you want to use different name from filetype, you can add it in your `.vimrc` like so:
-
-        let g:vim_markdown_fenced_languages = ['csharp=cs']
-
-    This will cause the following to be highlighted using the `cs` filetype syntax.
-
-        ```csharp
-        ...
-        ```
-
-    Default is `['c++=cpp', 'viml=vim', 'bash=sh', 'ini=dosini']`.
-
-### Follow named anchors
-
--   `g:vim_markdown_follow_anchor`
-
-    This feature allows the `ge` command to follow named anchors in links of the form
-    `file#anchor` or just `#anchor`, where file may omit the `.md` extension as
-    usual. Two variables control its operation:
-
-        let g:vim_markdown_follow_anchor = 1
-
-    This tells vim-markdown whether to attempt to follow a named anchor in a link or
-    not. When it is 1, and only if a link can be split in two parts by the pattern
-    '#', then the first part is interpreted as the file and the second one as the
-    named anchor. This also includes urls of the form `#anchor`, for which the first
-    part is considered empty, meaning that the target file is the current one. After
-    the file is opened, the anchor will be searched.
-
-    Default is `0`.
-
--   `g:vim_markdown_anchorexpr`
-
-        let g:vim_markdown_anchorexpr = "'<<'.v:anchor.'>>'"
-
-    This expression will be evaluated substituting `v:anchor` with a quoted string
-    that contains the anchor to visit. The result of the evaluation will become the
-    real anchor to search in the target file. This is useful in order to convert
-    anchors of the form, say, `my-section-title` to searches of the form `My Section
-    Title` or `<<my-section-title>>`.
-
-    Default is `''`.
-
-### Syntax extensions
-
-The following options control which syntax extensions will be turned on. They are off by default.
-
-#### LaTeX math
-
--   `g:vim_markdown_math`
-
-    Used as `$x^2$`, `$$x^2$$`, escapable as `\$x\$` and `\$\$x\$\$`.
-
-        let g:vim_markdown_math = 1
-
-#### YAML Front Matter
-
--   `g:vim_markdown_frontmatter`
-
-    Highlight YAML front matter as used by Jekyll or [Hugo](https://gohugo.io/content/front-matter/).
-
-        let g:vim_markdown_frontmatter = 1
-
-#### TOML Front Matter
-
--   `g:vim_markdown_toml_frontmatter`
-
-    Highlight TOML front matter as used by [Hugo](https://gohugo.io/content/front-matter/).
-
-    TOML syntax highlight requires [vim-toml](https://github.com/cespare/vim-toml).
-
-        let g:vim_markdown_toml_frontmatter = 1
-
-#### JSON Front Matter
-
--   `g:vim_markdown_json_frontmatter`
-
-    Highlight JSON front matter as used by [Hugo](https://gohugo.io/content/front-matter/).
-
-    JSON syntax highlight requires [vim-json](https://github.com/elzr/vim-json).
-
-        let g:vim_markdown_json_frontmatter = 1
-
-#### Strikethrough
-
--   `g:vim_markdown_strikethrough`
-
-    Strikethrough uses two tildes. `~~Scratch this.~~`
-
-        let g:vim_markdown_strikethrough = 1
-
-### Adjust new list item indent
-
--   `g:vim_markdown_new_list_item_indent`
-
-    You can adjust a new list indent. For example, you insert a single line like below:
-
-        * item1
-
-    Then if you type `o` to insert new line in vim and type `* item2`, the result will be:
-
-        * item1
-            * item2
-
-    vim-markdown automatically insert the indent. By default, the number of spaces of indent is 4. If you'd like to change the number as 2, just write:
-
-        let g:vim_markdown_new_list_item_indent = 2
-
-### Do not require .md extensions for Markdown links
-
--   `g:vim_markdown_no_extensions_in_markdown`
-
-    If you want to have a link like this `[link text](link-url)` and follow it for editing in vim using the `ge` command, but have it open the file "link-url.md" instead of the file "link-url", then use this option:
-
-        let g:vim_markdown_no_extensions_in_markdown = 1
-
-    This is super useful for GitLab and GitHub wiki repositories.
-
-    Normal behaviour would be that vim-markup required you to do this `[link text](link-url.md)`, but this is not how the Gitlab and GitHub wiki repositories work. So this option adds some consistency between the two.
-
-### Auto-write when following link
-
--   `g:vim_markdown_autowrite`
-
-    If you follow a link like this `[link text](link-url)` using the `ge` shortcut, this option will automatically save any edits you made before moving you:
-
-        let g:vim_markdown_autowrite = 1
-
-### Change default file extension
-
--   `g:vim_markdown_auto_extension_ext`
-
-    If you would like to use a file extension other than `.md` you may do so using the `vim_markdown_auto_extension_ext` variable:
-
-        let g:vim_markdown_auto_extension_ext = 'txt'
-
-### Do not automatically insert bulletpoints
-
--   `g:vim_markdown_auto_insert_bullets`
-
-    Automatically inserting bulletpoints can lead to problems when wrapping text
-    (see issue #232 for details), so it can be disabled:
-
-        let g:vim_markdown_auto_insert_bullets = 0
-
-    In that case, you probably also want to set the new list item indent to 0 as
-    well, or you will have to remove an indent each time you add a new list item:
-
-        let g:vim_markdown_new_list_item_indent = 0
-
-### Change how to open new files
-
--   `g:vim_markdown_edit_url_in`
-
-    By default when following a link the target file will be opened in your current buffer.  This behavior can change if you prefer using splits or tabs by using the `vim_markdown_edit_url_in` variable.  Possible values are `tab`, `vsplit`, `hsplit`, `current` opening in a new tab, vertical split, horizontal split, and current buffer respectively.  Defaults to current buffer if not set:
-
-        let g:vim_markdown_edit_url_in = 'tab'
-
-## Mappings
-
-The following work on normal and visual modes:
-
--   `gx`: open the link under the cursor in the same browser as the standard `gx` command. `<Plug>Markdown_OpenUrlUnderCursor`
-
-    The standard `gx` is extended by allowing you to put your cursor anywhere inside a link.
-
-    For example, all the following cursor positions will work:
-
-        [Example](http://example.com)
-        ^  ^    ^^   ^       ^
-        1  2    34   5       6
-
-        <http://example.com>
-        ^  ^               ^
-        1  2               3
-
-    Known limitation: does not work for links that span multiple lines.
-
--   `ge`: open the link under the cursor in Vim for editing. Useful for relative markdown links. `<Plug>Markdown_EditUrlUnderCursor`
-
-    The rules for the cursor position are the same as the `gx` command.
-
--   `]]`: go to next header. `<Plug>Markdown_MoveToNextHeader`
-
--   `[[`: go to previous header. Contrast with `]c`. `<Plug>Markdown_MoveToPreviousHeader`
-
--   `][`: go to next sibling header if any. `<Plug>Markdown_MoveToNextSiblingHeader`
-
--   `[]`: go to previous sibling header if any. `<Plug>Markdown_MoveToPreviousSiblingHeader`
-
--   `]c`: go to Current header. `<Plug>Markdown_MoveToCurHeader`
-
--   `]u`: go to parent header (Up). `<Plug>Markdown_MoveToParentHeader`
-
-This plugin follows the recommended Vim plugin mapping interface, so to change the map `]u` to `asdf`, add to your `.vimrc`:
-
-    map asdf <Plug>Markdown_MoveToParentHeader
-
-To disable a map use:
-
-    map <Plug> <Plug>Markdown_MoveToParentHeader
-
-## Commands
-
-The following requires `:filetype plugin on`.
-
--   `:HeaderDecrease`:
-
-    Decrease level of all headers in buffer: `h2` to `h1`, `h3` to `h2`, etc.
-
-    If range is given, only operate in the range.
-
-    If an `h1` would be decreased, abort.
-
-    For simplicity of implementation, Setex headers are converted to Atx.
-
--   `:HeaderIncrease`: Analogous to `:HeaderDecrease`, but increase levels instead.
-
--   `:SetexToAtx`:
-
-    Convert all Setex style headers in buffer to Atx.
-
-    If a range is given, e.g. hit `:` from visual mode, only operate on the range.
-
--   `:TableFormat`: Format the table under the cursor [like this](http://www.cirosantilli.com/markdown-style-guide/#tables).
-
-    Requires [Tabular](https://github.com/godlygeek/tabular).
-
-    The input table *must* already have a separator line as the second line of the table.
-    That line only needs to contain the correct pipes `|`, nothing else is required.
-
--   `:Toc`: create a quickfix vertical window navigable table of contents with the headers.
-
-    Hit `<Enter>` on a line to jump to the corresponding line of the markdown file.
-
--   `:Toch`: Same as `:Toc` but in an horizontal window.
-
--   `:Toct`: Same as `:Toc` but in a new tab.
-
--   `:Tocv`: Same as `:Toc` for symmetry with `:Toch` and `:Tocv`.
-
-## Credits
-
-The main contributors of vim-markdown are:
-
-- **Ben Williams** (A.K.A. **plasticboy**). The original developer of vim-markdown. [Homepage](http://plasticboy.com/).
-
-If you feel that your name should be on this list, please make a pull request listing your contributions.
-
-## License
-
-The MIT License (MIT)
-
-Copyright (c) 2012 Benjamin D. Williams
-
-Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
diff --git a/sources_non_forked/vim-markdown/after/ftplugin/markdown.vim b/sources_non_forked/vim-markdown/after/ftplugin/markdown.vim
deleted file mode 100644
index 8be6ff9..0000000
--- a/sources_non_forked/vim-markdown/after/ftplugin/markdown.vim
+++ /dev/null
@@ -1,201 +0,0 @@
-" vim: ts=4 sw=4:
-" folding for Markdown headers, both styles (atx- and setex-)
-" http://daringfireball.net/projects/markdown/syntax#header
-"
-" this code can be placed in file
-"   $HOME/.vim/after/ftplugin/markdown.vim
-"
-" original version from Steve Losh's gist: https://gist.github.com/1038710
-
-function! s:is_mkdCode(lnum)
-    let name = synIDattr(synID(a:lnum, 1, 0), 'name')
-    return (name =~ '^mkd\%(Code$\|Snippet\)' || name != '' && name !~ '^\%(mkd\|html\)')
-endfunction
-
-if get(g:, "vim_markdown_folding_style_pythonic", 0)
-    function! Foldexpr_markdown(lnum)
-        let l1 = getline(a:lnum)
-        "~~~~~ keep track of fenced code blocks ~~~~~
-        "If we hit a code block fence
-        if l1 =~ '````*' || l1 =~ '\~\~\~\~*'
-            " toggle the variable that says if we're in a code block
-            if b:fenced_block == 0
-                let b:fenced_block = 1
-            elseif b:fenced_block == 1
-                let b:fenced_block = 0
-            endif
-        " else, if we're caring about front matter
-        elseif g:vim_markdown_frontmatter == 1
-            " if we're in front matter and not on line 1
-            if b:front_matter == 1 && a:lnum > 2
-                let l0 = getline(a:lnum-1)
-                " if the previous line fenced front matter
-                if l0 == '---'
-                    " we must not be in front matter
-                    let b:front_matter = 0
-                endif
-            " else, if we're on line one
-            elseif a:lnum == 1
-                " if we hit a front matter fence
-                if l1 == '---'
-                    " we're in the front matter
-                    let b:front_matter = 1
-                endif
-            endif
-        endif
-
-        " if we're in a code block or front matter
-        if b:fenced_block == 1 || b:front_matter == 1
-            if a:lnum == 1
-                " fold any 'preamble'
-                return '>1'
-            else
-                " keep previous foldlevel
-                return '='
-            endif
-        endif
-
-        let l2 = getline(a:lnum+1)
-        " if the next line starts with two or more '='
-        " and is not code
-        if l2 =~ '^==\+\s*' && !s:is_mkdCode(a:lnum+1)
-            " next line is underlined (level 1)
-            return '>0'
-        " else, if the nex line starts with two or more '-'
-        " and is not code
-        elseif l2 =~ '^--\+\s*' && !s:is_mkdCode(a:lnum+1)
-            " next line is underlined (level 2)
-            return '>1'
-        endif
-
-        "if we're on a non-code line starting with a pound sign
-        if l1 =~ '^#' && !s:is_mkdCode(a:lnum)
-            " set the fold level to the number of hashes -1
-            " return '>'.(matchend(l1, '^#\+') - 1)
-            " set the fold level to the number of hashes
-            return '>'.(matchend(l1, '^#\+'))
-        " else, if we're on line 1
-        elseif a:lnum == 1
-            " fold any 'preamble'
-            return '>1'
-        else
-            " keep previous foldlevel
-            return '='
-        endif
-    endfunction
-
-    function! Foldtext_markdown()
-        let line = getline(v:foldstart)
-        let has_numbers = &number || &relativenumber
-        let nucolwidth = &fdc + has_numbers * &numberwidth
-        let windowwidth = winwidth(0) - nucolwidth - 6
-        let foldedlinecount = v:foldend - v:foldstart
-        let line = strpart(line, 0, windowwidth - 2 -len(foldedlinecount))
-        let line = substitute(line, '\%("""\|''''''\)', '', '')
-        let fillcharcount = windowwidth - len(line) - len(foldedlinecount) + 1
-        return line . ' ' . repeat("-", fillcharcount) . ' ' . foldedlinecount
-    endfunction
-else " vim_markdown_folding_style_pythonic == 0
-    function! Foldexpr_markdown(lnum)
-        if (a:lnum == 1)
-            let l0 = ''
-        else
-            let l0 = getline(a:lnum-1)
-        endif
-
-        " keep track of fenced code blocks
-        if l0 =~ '````*' || l0 =~ '\~\~\~\~*'
-            if b:fenced_block == 0
-                let b:fenced_block = 1
-            elseif b:fenced_block == 1
-                let b:fenced_block = 0
-            endif
-        elseif g:vim_markdown_frontmatter == 1
-            if b:front_matter == 1
-                if l0 == '---'
-                    let b:front_matter = 0
-                endif
-            elseif a:lnum == 2
-                if l0 == '---'
-                    let b:front_matter = 1
-                endif
-            endif
-        endif
-
-        if b:fenced_block == 1 || b:front_matter == 1
-            " keep previous foldlevel
-            return '='
-        endif
-
-        let l2 = getline(a:lnum+1)
-        if  l2 =~ '^==\+\s*' && !s:is_mkdCode(a:lnum+1)
-            " next line is underlined (level 1)
-            return '>1'
-        elseif l2 =~ '^--\+\s*' && !s:is_mkdCode(a:lnum+1)
-            " next line is underlined (level 2)
-            if s:vim_markdown_folding_level >= 2
-                return '>1'
-            else
-                return '>2'
-            endif
-        endif
-
-        let l1 = getline(a:lnum)
-        if l1 =~ '^#' && !s:is_mkdCode(a:lnum)
-            " fold level according to option
-            if s:vim_markdown_folding_level == 1 || matchend(l1, '^#\+') > s:vim_markdown_folding_level
-                if a:lnum == line('$')
-                    return matchend(l1, '^#\+') - 1
-                else
-                    return -1
-                endif
-            else
-                " headers are not folded
-                return 0
-            endif
-        endif
-
-        if l0 =~ '^#' && !s:is_mkdCode(a:lnum-1)
-            " previous line starts with hashes
-            return '>'.matchend(l0, '^#\+')
-        else
-            " keep previous foldlevel
-            return '='
-        endif
-    endfunction
-endif
-
-
-let b:fenced_block = 0
-let b:front_matter = 0
-let s:vim_markdown_folding_level = get(g:, "vim_markdown_folding_level", 1)
-
-function! s:MarkdownSetupFolding()
-    if !get(g:, "vim_markdown_folding_disabled", 0)
-        if get(g:, "vim_markdown_folding_style_pythonic", 0)
-            if get(g:, "vim_markdown_override_foldtext", 1)
-                setlocal foldtext=Foldtext_markdown()
-            endif
-        endif
-        setlocal foldexpr=Foldexpr_markdown(v:lnum)
-        setlocal foldmethod=expr
-    endif
-endfunction
-
-function! s:MarkdownSetupFoldLevel()
-    if get(g:, "vim_markdown_folding_style_pythonic", 0)
-        " set default foldlevel
-        execute "setlocal foldlevel=".s:vim_markdown_folding_level
-    endif
-endfunction
-
-call s:MarkdownSetupFoldLevel()
-call s:MarkdownSetupFolding()
-
-augroup Mkd
-    " These autocmds need to be kept in sync with the autocmds calling
-    " s:MarkdownRefreshSyntax in ftplugin/markdown.vim.
-    autocmd BufWinEnter,BufWritePost <buffer> call s:MarkdownSetupFolding()
-    autocmd InsertEnter,InsertLeave <buffer> call s:MarkdownSetupFolding()
-    autocmd CursorHold,CursorHoldI <buffer> call s:MarkdownSetupFolding()
-augroup END
diff --git a/sources_non_forked/vim-markdown/doc/vim-markdown.txt b/sources_non_forked/vim-markdown/doc/vim-markdown.txt
deleted file mode 100644
index 4d73129..0000000
--- a/sources_non_forked/vim-markdown/doc/vim-markdown.txt
+++ /dev/null
@@ -1,663 +0,0 @@
-*vim-markdown*  Vim Markdown
-
-===============================================================================
-Contents ~
-
- 1. Introduction                                    |vim-markdown-introduction|
- 2. Installation                                    |vim-markdown-installation|
- 3. Basic usage                                      |vim-markdown-basic-usage|
-  1. Folding                                             |vim-markdown-folding|
-  2. Concealing                                       |vim-markdown-concealing|
- 4. Options                                              |vim-markdown-options|
-  1. Disable Folding                             |vim-markdown-disable-folding|
-  2. Change fold style                         |vim-markdown-change-fold-style|
-  3. Set header folding level           |vim-markdown-set-header-folding-level|
-  4. Disable Default Key Mappings   |vim-markdown-disable-default-key-mappings|
-  5. Enable TOC window auto-fit       |vim-markdown-enable-toc-window-auto-fit|
-  6. Text emphasis restriction to single-lines
-                       |vim-markdown-text-emphasis-restriction-to-single-lines|
-  7. Syntax Concealing                         |vim-markdown-syntax-concealing|
-  8. Fenced code block languages     |vim-markdown-fenced-code-block-languages|
-  9. Follow named anchors                   |vim-markdown-follow-named-anchors|
-  10. Syntax extensions                        |vim-markdown-syntax-extensions|
-   1. LaTeX math                                      |vim-markdown-latex-math|
-   2. YAML Front Matter                        |vim-markdown-yaml-front-matter|
-   3. TOML Front Matter                        |vim-markdown-toml-front-matter|
-   4. JSON Front Matter                        |vim-markdown-json-front-matter|
-   5. Strikethrough                                |vim-markdown-strikethrough|
-  11. Adjust new list item indent    |vim-markdown-adjust-new-list-item-indent|
-  12. Do not require .md extensions for Markdown links
-                |vim-markdown-do-not-require-.md-extensions-for-markdown-links|
-  13. Auto-write when following link
-                                  |vim-markdown-auto-write-when-following-link|
-  14. Change default file extension
-                                   |vim-markdown-change-default-file-extension|
-  15. Do not automatically insert bulletpoints
-                        |vim-markdown-do-not-automatically-insert-bulletpoints|
-  16. Change how to open new files  |vim-markdown-change-how-to-open-new-files|
- 5. Mappings                                            |vim-markdown-mappings|
- 6. Commands                                            |vim-markdown-commands|
- 7. Credits                                              |vim-markdown-credits|
- 8. License                                              |vim-markdown-license|
- 9. References                                        |vim-markdown-references|
-
-===============================================================================
-                                                    *vim-markdown-introduction*
-Introduction ~
-
-Syntax highlighting, matching rules and mappings for the original Markdown [1]
-and extensions.
-
-===============================================================================
-                                                    *vim-markdown-installation*
-Installation ~
-
-If you use Vundle [2], add the following lines to your '~/.vimrc':
->
-  Plugin 'godlygeek/tabular'
-  Plugin 'plasticboy/vim-markdown'
-<
-The 'tabular' plugin must come _before_ 'vim-markdown'.
-
-Then run inside Vim:
->
-  :so ~/.vimrc
-  :PluginInstall
-<
-If you use Pathogen [3], do this:
->
-  cd ~/.vim/bundle
-  git clone https://github.com/plasticboy/vim-markdown.git
-<
-To install without Pathogen using the Debian vim-addon-manager [4], do this:
->
-  git clone https://github.com/plasticboy/vim-markdown.git
-  cd vim-markdown
-  sudo make install
-  vim-addon-manager install markdown
-<
-If you are not using any package manager, download the tarball [5] and do this:
->
-  cd ~/.vim
-  tar --strip=1 -zxf vim-markdown-master.tar.gz
-<
-===============================================================================
-                                                     *vim-markdown-basic-usage*
-Basic usage ~
-
--------------------------------------------------------------------------------
-                                                         *vim-markdown-folding*
-Folding ~
-
-Folding is enabled for headers by default.
-
-The following commands are useful to open and close folds:
-
-                                                              *vim-markdown-zr*
-- 'zr': reduces fold level throughout the buffer
-                                                              *vim-markdown-zR*
-- 'zR': opens all folds
-                                                              *vim-markdown-zm*
-- 'zm': increases fold level throughout the buffer
-                                                              *vim-markdown-zM*
-- 'zM': folds everything all the way
-                                                              *vim-markdown-za*
-- 'za': open a fold your cursor is on
-                                                              *vim-markdown-zA*
-- 'zA': open a fold your cursor is on recursively
-                                                              *vim-markdown-zc*
-- 'zc': close a fold your cursor is on
-                                                              *vim-markdown-zC*
-- 'zC': close a fold your cursor is on recursively
-
-Options are available to disable folding or change folding style.
-
-Try ':help fold-expr' and ':help fold-commands' for details.
-
--------------------------------------------------------------------------------
-                                                      *vim-markdown-concealing*
-Concealing ~
-
-Concealing is set for some syntax such as bold, italic, code block and link.
-
-Concealing lets you conceal text with other text. The actual source text is not
-modified. If you put your cursor on the concealed line, the conceal goes away.
-
-Options are available to disable or change concealing.
-
-Try ':help concealcursor' and ':help conceallevel' for details.
-
-===============================================================================
-                                                         *vim-markdown-options*
-Options ~
-
--------------------------------------------------------------------------------
-                                                 *vim-markdown-disable-folding*
-Disable Folding ~
-
-                                              *g:vim_markdown_folding_disabled*
-- 'g:vim_markdown_folding_disabled'
-
-  Add the following line to your '.vimrc' to disable the folding
-  configuration:
->
-  let g:vim_markdown_folding_disabled = 1
-<
-  This option only controls Vim Markdown specific folding configuration.
-
-  To enable/disable folding use Vim's standard folding configuration.
->
-  set [no]foldenable
-<
--------------------------------------------------------------------------------
-                                               *vim-markdown-change-fold-style*
-Change fold style ~
-
-                                        *g:vim_markdown_folding_style_pythonic*
-- 'g:vim_markdown_folding_style_pythonic'
-
-  To fold in a style like python-mode [6], add the following to your
-  '.vimrc':
->
-  let g:vim_markdown_folding_style_pythonic = 1
-<
-  'g:vim_markdown_folding_level' setting (default 1) is set to 'foldlevel'.
-  Thus level 1 heading which is served as a document title is expanded by
-  default.
-
-                                             *g:vim_markdown_override_foldtext*
-- 'g:vim_markdown_override_foldtext'
-
-  To prevent foldtext from being set add the following to your '.vimrc':
->
-  let g:vim_markdown_override_foldtext = 0
-<
--------------------------------------------------------------------------------
-                                        *vim-markdown-set-header-folding-level*
-Set header folding level ~
-
-                                                 *g:vim_markdown_folding_level*
-- 'g:vim_markdown_folding_level'
-
-  Folding level is a number between 1 and 6. By default, if not specified, it
-  is set to 1.
->
-  let g:vim_markdown_folding_level = 6
-<
-  Tip: it can be changed on the fly with:
->
-  :let g:vim_markdown_folding_level = 1
-  :edit
-<
--------------------------------------------------------------------------------
-                                    *vim-markdown-disable-default-key-mappings*
-Disable Default Key Mappings ~
-
-                                       *g:vim_markdown_no_default_key_mappings*
-- 'g:vim_markdown_no_default_key_mappings'
-
-  Add the following line to your '.vimrc' to disable default key mappings:
->
-  let g:vim_markdown_no_default_key_mappings = 1
-<
-  You can also map them by yourself with '<Plug>' mappings.
-
--------------------------------------------------------------------------------
-                                      *vim-markdown-enable-toc-window-auto-fit*
-Enable TOC window auto-fit ~
-
-                                                   *g:vim_markdown_toc_autofit*
-- 'g:vim_markdown_toc_autofit'
-
-  Allow for the TOC window to auto-fit when it's possible for it to shrink.
-  It never increases its default size (half screen), it only shrinks.
->
-  let g:vim_markdown_toc_autofit = 1
-<
--------------------------------------------------------------------------------
-                       *vim-markdown-text-emphasis-restriction-to-single-lines*
-Text emphasis restriction to single-lines ~
-
-                                            *g:vim_markdown_emphasis_multiline*
-- 'g:vim_markdown_emphasis_multiline'
-
-  By default text emphasis works across multiple lines until a closing token
-  is found. However, it's possible to restrict text emphasis to a single line
-  (i.e., for it to be applied a closing token must be found on the same
-  line). To do so:
->
-  let g:vim_markdown_emphasis_multiline = 0
-<
--------------------------------------------------------------------------------
-                                               *vim-markdown-syntax-concealing*
-Syntax Concealing ~
-
-                                                       *g:vim_markdown_conceal*
-- 'g:vim_markdown_conceal'
-
-  Concealing is set for some syntax.
-
-  For example, conceal '[link text](link url)' as just 'link text'. Also,
-  '_italic_' and '*italic*' will conceal to just _italic_. Similarly
-  '__bold__', '**bold**', '___italic bold___', and '***italic bold***' will
-  conceal to just **bold**, **bold**, **_italic bold_**, and **_italic
-  bold_** respectively.
-
-  To enable conceal use Vim's standard conceal configuration.
->
-  set conceallevel=2
-<
-  To disable conceal regardless of 'conceallevel' setting, add the following
-  to your '.vimrc':
->
-  let g:vim_markdown_conceal = 0
-<
-  To disable math conceal with LaTeX math syntax enabled, add the following
-  to your '.vimrc':
->
-  let g:tex_conceal = ""
-  let g:vim_markdown_math = 1
-<
-                                           *g:vim_markdown_conceal_code_blocks*
-- 'g:vim_markdown_conceal_code_blocks'
-
-  Disabling conceal for code fences requires an additional setting:
->
-  let g:vim_markdown_conceal_code_blocks = 0
-<
--------------------------------------------------------------------------------
-                                     *vim-markdown-fenced-code-block-languages*
-Fenced code block languages ~
-
-                                              *g:vim_markdown_fenced_languages*
-- 'g:vim_markdown_fenced_languages'
-
-  You can use filetype name as fenced code block languages for syntax
-  highlighting. If you want to use different name from filetype, you can add
-  it in your '.vimrc' like so:
->
-  let g:vim_markdown_fenced_languages = ['csharp=cs']
-<
-  This will cause the following to be highlighted using the 'cs' filetype
-  syntax.
->
-  ```csharp
-  ...
-  ```
-<
-  Default is "['c++=cpp', 'viml=vim', 'bash=sh', 'ini=dosini']".
-
--------------------------------------------------------------------------------
-                                            *vim-markdown-follow-named-anchors*
-Follow named anchors ~
-
-                                                 *g:vim_markdown_follow_anchor*
-- 'g:vim_markdown_follow_anchor'
-
-  This feature allows the 'ge' command to follow named anchors in links of
-  the form 'file#anchor' or just '#anchor', where file may omit the '.md'
-  extension as usual. Two variables control its operation:
->
-  let g:vim_markdown_follow_anchor = 1
-<
-  This tells vim-markdown whether to attempt to follow a named anchor in a
-  link or not. When it is 1, and only if a link can be split in two parts by
-  the pattern '#', then the first part is interpreted as the file and the
-  second one as the named anchor. This also includes urls of the form
-  '#anchor', for which the first part is considered empty, meaning that the
-  target file is the current one. After the file is opened, the anchor will
-  be searched.
-
-  Default is '0'.
-
-                                                    *g:vim_markdown_anchorexpr*
-- 'g:vim_markdown_anchorexpr'
->
-  let g:vim_markdown_anchorexpr = "'<<'.v:anchor.'>>'"
-<
-  This expression will be evaluated substituting 'v:anchor' with a quoted
-  string that contains the anchor to visit. The result of the evaluation will
-  become the real anchor to search in the target file. This is useful in
-  order to convert anchors of the form, say, 'my-section-title' to searches
-  of the form 'My Section Title' or '<<my-section-title>>'.
-
-  Default is "''".
-
--------------------------------------------------------------------------------
-                                               *vim-markdown-syntax-extensions*
-Syntax extensions ~
-
-The following options control which syntax extensions will be turned on. They
-are off by default.
-
--------------------------------------------------------------------------------
-                                                      *vim-markdown-latex-math*
-LaTeX math ~
-
-                                                          *g:vim_markdown_math*
-- 'g:vim_markdown_math'
-
-  Used as '$x^2$', '$$x^2$$', escapable as '\$x\$' and '\$\$x\$\$'.
->
-  let g:vim_markdown_math = 1
-<
--------------------------------------------------------------------------------
-                                               *vim-markdown-yaml-front-matter*
-YAML Front Matter ~
-
-                                                   *g:vim_markdown_frontmatter*
-- 'g:vim_markdown_frontmatter'
-
-  Highlight YAML front matter as used by Jekyll or Hugo [7].
->
-  let g:vim_markdown_frontmatter = 1
-<
--------------------------------------------------------------------------------
-                                               *vim-markdown-toml-front-matter*
-TOML Front Matter ~
-
-                                              *g:vim_markdown_toml_frontmatter*
-- 'g:vim_markdown_toml_frontmatter'
-
-  Highlight TOML front matter as used by Hugo [7].
-
-  TOML syntax highlight requires vim-toml [8].
->
-  let g:vim_markdown_toml_frontmatter = 1
-<
--------------------------------------------------------------------------------
-                                               *vim-markdown-json-front-matter*
-JSON Front Matter ~
-
-                                              *g:vim_markdown_json_frontmatter*
-- 'g:vim_markdown_json_frontmatter'
-
-  Highlight JSON front matter as used by Hugo [7].
-
-  JSON syntax highlight requires vim-json [9].
->
-  let g:vim_markdown_json_frontmatter = 1
-<
--------------------------------------------------------------------------------
-                                                   *vim-markdown-strikethrough*
-Strikethrough ~
-
-                                                 *g:vim_markdown_strikethrough*
-- 'g:vim_markdown_strikethrough'
-
-  Strikethrough uses two tildes. '~~Scratch this.~~'
->
-  let g:vim_markdown_strikethrough = 1
-<
--------------------------------------------------------------------------------
-                                     *vim-markdown-adjust-new-list-item-indent*
-Adjust new list item indent ~
-
-                                          *g:vim_markdown_new_list_item_indent*
-- 'g:vim_markdown_new_list_item_indent'
-
-  You can adjust a new list indent. For example, you insert a single line
-  like below:
->
-  * item1
-<
-  Then if you type 'o' to insert new line in vim and type '* item2', the
-  result will be:
->
-  * item1
-      * item2
-<
-  vim-markdown automatically insert the indent. By default, the number of
-  spaces of indent is 4. If you'd like to change the number as 2, just write:
->
-  let g:vim_markdown_new_list_item_indent = 2
-<
--------------------------------------------------------------------------------
-                *vim-markdown-do-not-require-.md-extensions-for-markdown-links*
-Do not require .md extensions for Markdown links ~
-
-                                     *g:vim_markdown_no_extensions_in_markdown*
-- 'g:vim_markdown_no_extensions_in_markdown'
-
-  If you want to have a link like this '[link text](link-url)' and follow it
-  for editing in vim using the 'ge' command, but have it open the file "link-
-  url.md" instead of the file "link-url", then use this option:
->
-  let g:vim_markdown_no_extensions_in_markdown = 1
-<
-  This is super useful for GitLab and GitHub wiki repositories.
-
-  Normal behaviour would be that vim-markup required you to do this '[link
-  text](link-url.md)', but this is not how the Gitlab and GitHub wiki
-  repositories work. So this option adds some consistency between the two.
-
--------------------------------------------------------------------------------
-                                  *vim-markdown-auto-write-when-following-link*
-Auto-write when following link ~
-
-                                                     *g:vim_markdown_autowrite*
-- 'g:vim_markdown_autowrite'
-
-  If you follow a link like this '[link text](link-url)' using the 'ge'
-  shortcut, this option will automatically save any edits you made before
-  moving you:
->
-  let g:vim_markdown_autowrite = 1
-<
--------------------------------------------------------------------------------
-                                   *vim-markdown-change-default-file-extension*
-Change default file extension ~
-
-                                            *g:vim_markdown_auto_extension_ext*
-- 'g:vim_markdown_auto_extension_ext'
-
-  If you would like to use a file extension other than '.md' you may do so
-  using the 'vim_markdown_auto_extension_ext' variable:
->
-  let g:vim_markdown_auto_extension_ext = 'txt'
-<
--------------------------------------------------------------------------------
-                        *vim-markdown-do-not-automatically-insert-bulletpoints*
-Do not automatically insert bulletpoints ~
-
-                                           *g:vim_markdown_auto_insert_bullets*
-- 'g:vim_markdown_auto_insert_bullets'
-
-  Automatically inserting bulletpoints can lead to problems when wrapping
-  text (see issue #232 for details), so it can be disabled:
->
-  let g:vim_markdown_auto_insert_bullets = 0
-<
-  In that case, you probably also want to set the new list item indent to 0
-  as well, or you will have to remove an indent each time you add a new list
-  item:
->
-  let g:vim_markdown_new_list_item_indent = 0
-<
--------------------------------------------------------------------------------
-                                    *vim-markdown-change-how-to-open-new-files*
-Change how to open new files ~
-
-                                                   *g:vim_markdown_edit_url_in*
-- 'g:vim_markdown_edit_url_in'
-
-  By default when following a link the target file will be opened in your
-  current buffer. This behavior can change if you prefer using splits or tabs
-  by using the 'vim_markdown_edit_url_in' variable. Possible values are
-  'tab', 'vsplit', 'hsplit', 'current' opening in a new tab, vertical split,
-  horizontal split, and current buffer respectively. Defaults to current
-  buffer if not set:
->
-  let g:vim_markdown_edit_url_in = 'tab'
-<
-===============================================================================
-                                                        *vim-markdown-mappings*
-Mappings ~
-
-The following work on normal and visual modes:
-
-                                                              *vim-markdown-gx*
-- 'gx': open the link under the cursor in the same browser as the standard
-  'gx' command. '<Plug>Markdown_OpenUrlUnderCursor'
-
-  The standard 'gx' is extended by allowing you to put your cursor anywhere
-  inside a link.
-
-  For example, all the following cursor positions will work:
->
-  [Example](http://example.com)
-  ^  ^    ^^   ^       ^
-  1  2    34   5       6
-
-  <http://example.com>
-  ^  ^               ^
-  1  2               3
-<
-  Known limitation: does not work for links that span multiple lines.
-
-                                                              *vim-markdown-ge*
-- 'ge': open the link under the cursor in Vim for editing. Useful for
-  relative markdown links. '<Plug>Markdown_EditUrlUnderCursor'
-
-  The rules for the cursor position are the same as the 'gx' command.
-
-                                                              *vim-markdown-]]*
-- ']]': go to next header. '<Plug>Markdown_MoveToNextHeader'
-
-                                                              *vim-markdown-[[*
-- '[[': go to previous header. Contrast with ']c'.
-  '<Plug>Markdown_MoveToPreviousHeader'
-
-                                                              *vim-markdown-][*
-- '][': go to next sibling header if any.
-  '<Plug>Markdown_MoveToNextSiblingHeader'
-
-                                                              *vim-markdown-[]*
-- '[]': go to previous sibling header if any.
-  '<Plug>Markdown_MoveToPreviousSiblingHeader'
-
-                                                              *vim-markdown-]c*
-- ']c': go to Current header. '<Plug>Markdown_MoveToCurHeader'
-
-                                                              *vim-markdown-]u*
-- ']u': go to parent header (Up). '<Plug>Markdown_MoveToParentHeader'
-
-This plugin follows the recommended Vim plugin mapping interface, so to change
-the map ']u' to 'asdf', add to your '.vimrc':
->
-  map asdf <Plug>Markdown_MoveToParentHeader
-<
-To disable a map use:
->
-  map <Plug> <Plug>Markdown_MoveToParentHeader
-<
-===============================================================================
-                                                        *vim-markdown-commands*
-Commands ~
-
-The following requires ':filetype plugin on'.
-
-                                                              *:HeaderDecrease*
-- ':HeaderDecrease':
-
-  Decrease level of all headers in buffer: 'h2' to 'h1', 'h3' to 'h2', etc.
-
-  If range is given, only operate in the range.
-
-  If an 'h1' would be decreased, abort.
-
-  For simplicity of implementation, Setex headers are converted to Atx.
-
-                                                              *:HeaderIncrease*
-- ':HeaderIncrease': Analogous to ':HeaderDecrease', but increase levels
-  instead.
-
-                                                                  *:SetexToAtx*
-- ':SetexToAtx':
-
-  Convert all Setex style headers in buffer to Atx.
-
-  If a range is given, e.g. hit ':' from visual mode, only operate on the
-  range.
-
-                                                                 *:TableFormat*
-- ':TableFormat': Format the table under the cursor like this [10].
-
-  Requires Tabular [11].
-
-  The input table _must_ already have a separator line as the second line of
-  the table. That line only needs to contain the correct pipes '|', nothing
-  else is required.
-
-                                                                         *:Toc*
-- ':Toc': create a quickfix vertical window navigable table of contents with
-  the headers.
-
-  Hit '<Enter>' on a line to jump to the corresponding line of the markdown
-  file.
-
-                                                                        *:Toch*
-- ':Toch': Same as ':Toc' but in an horizontal window.
-
-                                                                        *:Toct*
-- ':Toct': Same as ':Toc' but in a new tab.
-
-                                                                        *:Tocv*
-- ':Tocv': Same as ':Toc' for symmetry with ':Toch' and ':Tocv'.
-
-===============================================================================
-                                                         *vim-markdown-credits*
-Credits ~
-
-The main contributors of vim-markdown are:
-
-- **Ben Williams** (A.K.A. **plasticboy**). The original developer of vim-
-  markdown. Homepage [12].
-
-If you feel that your name should be on this list, please make a pull request
-listing your contributions.
-
-===============================================================================
-                                                         *vim-markdown-license*
-License ~
-
-The MIT License (MIT)
-
-Copyright (c) 2012 Benjamin D. Williams
-
-Permission is hereby granted, free of charge, to any person obtaining a copy of
-this software and associated documentation files (the "Software"), to deal in
-the Software without restriction, including without limitation the rights to
-use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
-of the Software, and to permit persons to whom the Software is furnished to do
-so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in all
-copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-SOFTWARE.
-
-===============================================================================
-                                                      *vim-markdown-references*
-References ~
-
-[1] http://daringfireball.net/projects/markdown/
-[2] https://github.com/gmarik/vundle
-[3] https://github.com/tpope/vim-pathogen
-[4] http://packages.qa.debian.org/v/vim-addon-manager.html
-[5] https://github.com/plasticboy/vim-markdown/archive/master.tar.gz
-[6] https://github.com/klen/python-mode
-[7] https://gohugo.io/content/front-matter/
-[8] https://github.com/cespare/vim-toml
-[9] https://github.com/elzr/vim-json
-[10] http://www.cirosantilli.com/markdown-style-guide/#tables
-[11] https://github.com/godlygeek/tabular
-[12] http://plasticboy.com/
-
-vim: ft=help
diff --git a/sources_non_forked/vim-markdown/ftdetect/markdown.vim b/sources_non_forked/vim-markdown/ftdetect/markdown.vim
deleted file mode 100644
index 07682da..0000000
--- a/sources_non_forked/vim-markdown/ftdetect/markdown.vim
+++ /dev/null
@@ -1,8 +0,0 @@
-if !has('patch-7.4.480')
-    " Before this patch, vim used modula2 for .md.
-    au! filetypedetect BufRead,BufNewFile *.md
-endif
-
-" markdown filetype file
-au BufRead,BufNewFile *.{md,mdown,mkd,mkdn,markdown,mdwn} setfiletype markdown
-au BufRead,BufNewFile *.{md,mdown,mkd,mkdn,markdown,mdwn}.{des3,des,bf,bfa,aes,idea,cast,rc2,rc4,rc5,desx} setfiletype markdown
diff --git a/sources_non_forked/vim-markdown/ftplugin/markdown.vim b/sources_non_forked/vim-markdown/ftplugin/markdown.vim
deleted file mode 100644
index 200293e..0000000
--- a/sources_non_forked/vim-markdown/ftplugin/markdown.vim
+++ /dev/null
@@ -1,791 +0,0 @@
-"TODO print messages when on visual mode. I only see VISUAL, not the messages.
-
-" Function interface phylosophy:
-"
-" - functions take arbitrary line numbers as parameters.
-"    Current cursor line is only a suitable default parameter.
-"
-" - only functions that bind directly to user actions:
-"
-"    - print error messages.
-"       All intermediate functions limit themselves return `0` to indicate an error.
-"
-"    - move the cursor. All other functions do not move the cursor.
-"
-" This is how you should view headers for the header mappings:
-"
-"   |BUFFER
-"   |
-"   |Outside any header
-"   |
-" a-+# a
-"   |
-"   |Inside a
-"   |
-" a-+
-" b-+## b
-"   |
-"   |inside b
-"   |
-" b-+
-" c-+### c
-"   |
-"   |Inside c
-"   |
-" c-+
-" d-|# d
-"   |
-"   |Inside d
-"   |
-" d-+
-" e-|e
-"   |====
-"   |
-"   |Inside e
-"   |
-" e-+
-
-" For each level, contains the regexp that matches at that level only.
-"
-let s:levelRegexpDict = {
-    \ 1: '\v^(#[^#]@=|.+\n\=+$)',
-    \ 2: '\v^(##[^#]@=|.+\n-+$)',
-    \ 3: '\v^###[^#]@=',
-    \ 4: '\v^####[^#]@=',
-    \ 5: '\v^#####[^#]@=',
-    \ 6: '\v^######[^#]@='
-\ }
-
-" Maches any header level of any type.
-"
-" This could be deduced from `s:levelRegexpDict`, but it is more
-" efficient to have a single regexp for this.
-"
-let s:headersRegexp = '\v^(#|.+\n(\=+|-+)$)'
-
-" Returns the line number of the first header before `line`, called the
-" current header.
-"
-" If there is no current header, return `0`.
-"
-" @param a:1 The line to look the header of. Default value: `getpos('.')`.
-"
-function! s:GetHeaderLineNum(...)
-    if a:0 == 0
-        let l:l = line('.')
-    else
-        let l:l = a:1
-    endif
-    while(l:l > 0)
-        if join(getline(l:l, l:l + 1), "\n") =~ s:headersRegexp
-            return l:l
-        endif
-        let l:l -= 1
-    endwhile
-    return 0
-endfunction
-
-" -  if inside a header goes to it.
-"    Return its line number.
-"
-" -  if on top level outside any headers,
-"    print a warning
-"    Return `0`.
-"
-function! s:MoveToCurHeader()
-    let l:lineNum = s:GetHeaderLineNum()
-    if l:lineNum != 0
-        call cursor(l:lineNum, 1)
-    else
-        echo 'outside any header'
-        "normal! gg
-    endif
-    return l:lineNum
-endfunction
-
-" Move cursor to next header of any level.
-"
-" If there are no more headers, print a warning.
-"
-function! s:MoveToNextHeader()
-    if search(s:headersRegexp, 'W') == 0
-        "normal! G
-        echo 'no next header'
-    endif
-endfunction
-
-" Move cursor to previous header (before current) of any level.
-"
-" If it does not exist, print a warning.
-"
-function! s:MoveToPreviousHeader()
-    let l:curHeaderLineNumber = s:GetHeaderLineNum()
-    let l:noPreviousHeader = 0
-    if l:curHeaderLineNumber <= 1
-        let l:noPreviousHeader = 1
-    else
-        let l:previousHeaderLineNumber = s:GetHeaderLineNum(l:curHeaderLineNumber - 1)
-        if l:previousHeaderLineNumber == 0
-            let l:noPreviousHeader = 1
-        else
-            call cursor(l:previousHeaderLineNumber, 1)
-        endif
-    endif
-    if l:noPreviousHeader
-        echo 'no previous header'
-    endif
-endfunction
-
-" - if line is inside a header, return the header level (h1 -> 1, h2 -> 2, etc.).
-"
-" - if line is at top level outside any headers, return `0`.
-"
-function! s:GetHeaderLevel(...)
-    if a:0 == 0
-        let l:line = line('.')
-    else
-        let l:line = a:1
-    endif
-    let l:linenum = s:GetHeaderLineNum(l:line)
-    if l:linenum != 0
-        return s:GetLevelOfHeaderAtLine(l:linenum)
-    else
-        return 0
-    endif
-endfunction
-
-" Returns the level of the header at the given line.
-"
-" If there is no header at the given line, returns `0`.
-"
-function! s:GetLevelOfHeaderAtLine(linenum)
-    let l:lines = join(getline(a:linenum, a:linenum + 1), "\n")
-    for l:key in keys(s:levelRegexpDict)
-        if l:lines =~ get(s:levelRegexpDict, l:key)
-            return l:key
-        endif
-    endfor
-    return 0
-endfunction
-
-" Move cursor to parent header of the current header.
-"
-" If it does not exit, print a warning and do nothing.
-"
-function! s:MoveToParentHeader()
-    let l:linenum = s:GetParentHeaderLineNumber()
-    if l:linenum != 0
-        call cursor(l:linenum, 1)
-    else
-        echo 'no parent header'
-    endif
-endfunction
-
-" Return the line number of the parent header of line `line`.
-"
-" If it has no parent, return `0`.
-"
-function! s:GetParentHeaderLineNumber(...)
-    if a:0 == 0
-        let l:line = line('.')
-    else
-        let l:line = a:1
-    endif
-    let l:level = s:GetHeaderLevel(l:line)
-    if l:level > 1
-        let l:linenum = s:GetPreviousHeaderLineNumberAtLevel(l:level - 1, l:line)
-        return l:linenum
-    endif
-    return 0
-endfunction
-
-" Return the line number of the previous header of given level.
-" in relation to line `a:1`. If not given, `a:1 = getline()`
-"
-" `a:1` line is included, and this may return the current header.
-"
-" If none return 0.
-"
-function! s:GetNextHeaderLineNumberAtLevel(level, ...)
-    if a:0 < 1
-        let l:line = line('.')
-    else
-        let l:line = a:1
-    endif
-    let l:l = l:line
-    while(l:l <= line('$'))
-        if join(getline(l:l, l:l + 1), "\n") =~ get(s:levelRegexpDict, a:level)
-            return l:l
-        endif
-        let l:l += 1
-    endwhile
-    return 0
-endfunction
-
-" Return the line number of the previous header of given level.
-" in relation to line `a:1`. If not given, `a:1 = getline()`
-"
-" `a:1` line is included, and this may return the current header.
-"
-" If none return 0.
-"
-function! s:GetPreviousHeaderLineNumberAtLevel(level, ...)
-    if a:0 == 0
-        let l:line = line('.')
-    else
-        let l:line = a:1
-    endif
-    let l:l = l:line
-    while(l:l > 0)
-        if join(getline(l:l, l:l + 1), "\n") =~ get(s:levelRegexpDict, a:level)
-            return l:l
-        endif
-        let l:l -= 1
-    endwhile
-    return 0
-endfunction
-
-" Move cursor to next sibling header.
-"
-" If there is no next siblings, print a warning and don't move.
-"
-function! s:MoveToNextSiblingHeader()
-    let l:curHeaderLineNumber = s:GetHeaderLineNum()
-    let l:curHeaderLevel = s:GetLevelOfHeaderAtLine(l:curHeaderLineNumber)
-    let l:curHeaderParentLineNumber = s:GetParentHeaderLineNumber()
-    let l:nextHeaderSameLevelLineNumber = s:GetNextHeaderLineNumberAtLevel(l:curHeaderLevel, l:curHeaderLineNumber + 1)
-    let l:noNextSibling = 0
-    if l:nextHeaderSameLevelLineNumber == 0
-        let l:noNextSibling = 1
-    else
-        let l:nextHeaderSameLevelParentLineNumber = s:GetParentHeaderLineNumber(l:nextHeaderSameLevelLineNumber)
-        if l:curHeaderParentLineNumber == l:nextHeaderSameLevelParentLineNumber
-            call cursor(l:nextHeaderSameLevelLineNumber, 1)
-        else
-            let l:noNextSibling = 1
-        endif
-    endif
-    if l:noNextSibling
-        echo 'no next sibling header'
-    endif
-endfunction
-
-" Move cursor to previous sibling header.
-"
-" If there is no previous siblings, print a warning and do nothing.
-"
-function! s:MoveToPreviousSiblingHeader()
-    let l:curHeaderLineNumber = s:GetHeaderLineNum()
-    let l:curHeaderLevel = s:GetLevelOfHeaderAtLine(l:curHeaderLineNumber)
-    let l:curHeaderParentLineNumber = s:GetParentHeaderLineNumber()
-    let l:previousHeaderSameLevelLineNumber = s:GetPreviousHeaderLineNumberAtLevel(l:curHeaderLevel, l:curHeaderLineNumber - 1)
-    let l:noPreviousSibling = 0
-    if l:previousHeaderSameLevelLineNumber == 0
-        let l:noPreviousSibling = 1
-    else
-        let l:previousHeaderSameLevelParentLineNumber = s:GetParentHeaderLineNumber(l:previousHeaderSameLevelLineNumber)
-        if l:curHeaderParentLineNumber == l:previousHeaderSameLevelParentLineNumber
-            call cursor(l:previousHeaderSameLevelLineNumber, 1)
-        else
-            let l:noPreviousSibling = 1
-        endif
-    endif
-    if l:noPreviousSibling
-        echo 'no previous sibling header'
-    endif
-endfunction
-
-function! s:Toc(...)
-    if a:0 > 0
-        let l:window_type = a:1
-    else
-        let l:window_type = 'vertical'
-    endif
-
-
-    let l:bufnr = bufnr('%')
-    let l:cursor_line = line('.')
-    let l:cursor_header = 0
-    let l:fenced_block = 0
-    let l:front_matter = 0
-    let l:header_list = []
-    let l:header_max_len = 0
-    let l:vim_markdown_toc_autofit = get(g:, "vim_markdown_toc_autofit", 0)
-    let l:vim_markdown_frontmatter = get(g:, "vim_markdown_frontmatter", 0)
-    for i in range(1, line('$'))
-        let l:lineraw = getline(i)
-        let l:l1 = getline(i+1)
-        let l:line = substitute(l:lineraw, "#", "\\\#", "g")
-        if l:line =~ '````*' || l:line =~ '\~\~\~\~*'
-            if l:fenced_block == 0
-                let l:fenced_block = 1
-            elseif l:fenced_block == 1
-                let l:fenced_block = 0
-            endif
-        elseif l:vim_markdown_frontmatter == 1
-            if l:front_matter == 1
-                if l:line == '---'
-                    let l:front_matter = 0
-                endif
-            elseif i == 1
-                if l:line == '---'
-                    let l:front_matter = 1
-                endif
-            endif
-        endif
-        if l:line =~ '^#\+' || (l:l1 =~ '^=\+\s*$' || l:l1 =~ '^-\+\s*$') && l:line =~ '^\S'
-            let l:is_header = 1
-        else
-            let l:is_header = 0
-        endif
-        if l:is_header == 1 && l:fenced_block == 0 && l:front_matter == 0
-            " append line to location list
-            let l:item = {'lnum': i, 'text': l:line, 'valid': 1, 'bufnr': l:bufnr, 'col': 1}
-            let l:header_list = l:header_list + [l:item]
-            " set header number of the cursor position
-            if l:cursor_header == 0
-                if i == l:cursor_line
-                    let l:cursor_header = len(l:header_list)
-                elseif i > l:cursor_line
-                    let l:cursor_header = len(l:header_list) - 1
-                endif
-            endif
-            " keep track of the longest header size (heading level + title)
-            let l:total_len = stridx(l:line, ' ') + strdisplaywidth(l:line)
-            if l:total_len > l:header_max_len
-                let l:header_max_len = l:total_len
-            endif
-        endif
-    endfor
-    call setloclist(0, l:header_list)
-    if len(l:header_list) == 0
-        echom "Toc: No headers."
-        return
-    endif
-
-    if l:window_type ==# 'horizontal'
-        lopen
-    elseif l:window_type ==# 'vertical'
-        vertical lopen
-        " auto-fit toc window when possible to shrink it
-        if (&columns/2) > l:header_max_len && l:vim_markdown_toc_autofit == 1
-            execute 'vertical resize ' . (l:header_max_len + 1)
-        else
-            execute 'vertical resize ' . (&columns/2)
-        endif
-    elseif l:window_type ==# 'tab'
-        tab lopen
-    else
-        lopen
-    endif
-    setlocal modifiable
-    for i in range(1, line('$'))
-        " this is the location-list data for the current item
-        let d = getloclist(0)[i-1]
-        " atx headers
-        if match(d.text, "^#") > -1
-            let l:level = len(matchstr(d.text, '#*', 'g'))-1
-            let d.text = substitute(d.text, '\v^#*[ ]*', '', '')
-            let d.text = substitute(d.text, '\v[ ]*#*$', '', '')
-        " setex headers
-        else
-            let l:next_line = getbufline(d.bufnr, d.lnum+1)
-            if match(l:next_line, "=") > -1
-                let l:level = 0
-            elseif match(l:next_line, "-") > -1
-                let l:level = 1
-            endif
-        endif
-        call setline(i, repeat('  ', l:level). d.text)
-    endfor
-    setlocal nomodified
-    setlocal nomodifiable
-    execute 'normal! ' . l:cursor_header . 'G'
-endfunction
-
-" Convert Setex headers in range `line1 .. line2` to Atx.
-"
-" Return the number of conversions.
-"
-function! s:SetexToAtx(line1, line2)
-    let l:originalNumLines = line('$')
-    execute 'silent! ' . a:line1 . ',' . a:line2 . 'substitute/\v(.*\S.*)\n\=+$/# \1/'
-    execute 'silent! ' . a:line1 . ',' . a:line2 . 'substitute/\v(.*\S.*)\n-+$/## \1/'
-    return l:originalNumLines - line('$')
-endfunction
-
-" If `a:1` is 0, decrease the level of all headers in range `line1 .. line2`.
-"
-" Otherwise, increase the level. `a:1` defaults to `0`.
-"
-function! s:HeaderDecrease(line1, line2, ...)
-    if a:0 > 0
-        let l:increase = a:1
-    else
-        let l:increase = 0
-    endif
-    if l:increase
-        let l:forbiddenLevel = 6
-        let l:replaceLevels = [5, 1]
-        let l:levelDelta = 1
-    else
-        let l:forbiddenLevel = 1
-        let l:replaceLevels = [2, 6]
-        let l:levelDelta = -1
-    endif
-    for l:line in range(a:line1, a:line2)
-        if join(getline(l:line, l:line + 1), "\n") =~ s:levelRegexpDict[l:forbiddenLevel]
-            echomsg 'There is an h' . l:forbiddenLevel . ' at line ' . l:line . '. Aborting.'
-            return
-        endif
-    endfor
-    let l:numSubstitutions = s:SetexToAtx(a:line1, a:line2)
-    let l:flags = (&gdefault ? '' : 'g')
-    for l:level in range(replaceLevels[0], replaceLevels[1], -l:levelDelta)
-        execute 'silent! ' . a:line1 . ',' . (a:line2 - l:numSubstitutions) . 'substitute/' . s:levelRegexpDict[l:level] . '/' . repeat('#', l:level + l:levelDelta) . '/' . l:flags
-    endfor
-endfunction
-
-" Format table under cursor.
-"
-" Depends on Tabularize.
-"
-function! s:TableFormat()
-    let l:pos = getpos('.')
-    normal! {
-    " Search instead of `normal! j` because of the table at beginning of file edge case.
-    call search('|')
-    normal! j
-    " Remove everything that is not a pipe, colon or hyphen next to a colon othewise
-    " well formated tables would grow because of addition of 2 spaces on the separator
-    " line by Tabularize /|.
-    let l:flags = (&gdefault ? '' : 'g')
-    execute 's/\(:\@<!-:\@!\|[^|:-]\)//e' . l:flags
-    execute 's/--/-/e' . l:flags
-    Tabularize /|
-    " Move colons for alignment to left or right side of the cell.
-    execute 's/:\( \+\)|/\1:|/e' . l:flags
-    execute 's/|\( \+\):/|:\1/e' . l:flags
-    execute 's/ /-/' . l:flags
-    call setpos('.', l:pos)
-endfunction
-
-" Wrapper to do move commands in visual mode.
-"
-function! s:VisMove(f)
-    norm! gv
-    call function(a:f)()
-endfunction
-
-" Map in both normal and visual modes.
-"
-function! s:MapNormVis(rhs,lhs)
-    execute 'nn <buffer><silent> ' . a:rhs . ' :call ' . a:lhs . '()<cr>'
-    execute 'vn <buffer><silent> ' . a:rhs . ' <esc>:call <sid>VisMove(''' . a:lhs . ''')<cr>'
-endfunction
-
-" Parameters:
-"
-" - step +1 for right, -1 for left
-"
-" TODO: multiple lines.
-"
-function! s:FindCornerOfSyntax(lnum, col, step)
-    let l:col = a:col
-    let l:syn = synIDattr(synID(a:lnum, l:col, 1), 'name')
-    while synIDattr(synID(a:lnum, l:col, 1), 'name') ==# l:syn
-        let l:col += a:step
-    endwhile
-    return l:col - a:step
-endfunction
-
-" Return the next position of the given syntax name,
-" inclusive on the given position.
-"
-" TODO: multiple lines
-"
-function! s:FindNextSyntax(lnum, col, name)
-    let l:col = a:col
-    let l:step = 1
-    while synIDattr(synID(a:lnum, l:col, 1), 'name') !=# a:name
-        let l:col += l:step
-    endwhile
-    return [a:lnum, l:col]
-endfunction
-
-function! s:FindCornersOfSyntax(lnum, col)
-    return [<sid>FindLeftOfSyntax(a:lnum, a:col), <sid>FindRightOfSyntax(a:lnum, a:col)]
-endfunction
-
-function! s:FindRightOfSyntax(lnum, col)
-    return <sid>FindCornerOfSyntax(a:lnum, a:col, 1)
-endfunction
-
-function! s:FindLeftOfSyntax(lnum, col)
-    return <sid>FindCornerOfSyntax(a:lnum, a:col, -1)
-endfunction
-
-" Returns:
-"
-" - a string with the the URL for the link under the cursor
-" - an empty string if the cursor is not on a link
-"
-" TODO
-"
-" - multiline support
-" - give an error if the separator does is not on a link
-"
-function! s:Markdown_GetUrlForPosition(lnum, col)
-    let l:lnum = a:lnum
-    let l:col = a:col
-    let l:syn = synIDattr(synID(l:lnum, l:col, 1), 'name')
-
-    if l:syn ==# 'mkdInlineURL' || l:syn ==# 'mkdURL' || l:syn ==# 'mkdLinkDefTarget'
-        " Do nothing.
-    elseif l:syn ==# 'mkdLink'
-        let [l:lnum, l:col] = <sid>FindNextSyntax(l:lnum, l:col, 'mkdURL')
-        let l:syn = 'mkdURL'
-    elseif l:syn ==# 'mkdDelimiter'
-        let l:line = getline(l:lnum)
-        let l:char = l:line[col - 1]
-        if l:char ==# '<'
-            let l:col += 1
-        elseif l:char ==# '>' || l:char ==# ')'
-            let l:col -= 1
-        elseif l:char ==# '[' || l:char ==# ']' || l:char ==# '('
-            let [l:lnum, l:col] = <sid>FindNextSyntax(l:lnum, l:col, 'mkdURL')
-        else
-            return ''
-        endif
-    else
-        return ''
-    endif
-
-    let [l:left, l:right] = <sid>FindCornersOfSyntax(l:lnum, l:col)
-    return getline(l:lnum)[l:left - 1 : l:right - 1]
-endfunction
-
-" Front end for GetUrlForPosition.
-"
-function! s:OpenUrlUnderCursor()
-    let l:url = s:Markdown_GetUrlForPosition(line('.'), col('.'))
-    if l:url != ''
-        call s:VersionAwareNetrwBrowseX(l:url)
-    else
-        echomsg 'The cursor is not on a link.'
-    endif
-endfunction
-
-" We need a definition guard because we invoke 'edit' which will reload this
-" script while this function is running. We must not replace it.
-if !exists('*s:EditUrlUnderCursor')
-    function s:EditUrlUnderCursor()
-        let l:url = s:Markdown_GetUrlForPosition(line('.'), col('.'))
-        if l:url != ''
-            if get(g:, 'vim_markdown_autowrite', 0)
-                write
-            endif
-            let l:anchor = ''
-            if get(g:, 'vim_markdown_follow_anchor', 0)
-                let l:parts = split(l:url, '#', 1)
-                if len(l:parts) == 2
-                    let [l:url, l:anchor] = parts
-                    let l:anchorexpr = get(g:, 'vim_markdown_anchorexpr', '')
-                    if l:anchorexpr != ''
-                        let l:anchor = eval(substitute(
-                            \ l:anchorexpr, 'v:anchor',
-                            \ escape('"'.l:anchor.'"', '"'), ''))
-                    endif
-                endif
-            endif
-            if l:url != ''
-                let l:ext = ''
-                if get(g:, 'vim_markdown_no_extensions_in_markdown', 0)
-                    " use another file extension if preferred
-                    if exists('g:vim_markdown_auto_extension_ext')
-                        let l:ext = '.'.g:vim_markdown_auto_extension_ext
-                    else
-                        let l:ext = '.md'
-                    endif
-                endif
-                let l:url = fnameescape(fnamemodify(expand('%:h').'/'.l:url.l:ext, ':.'))
-                let l:editmethod = ''
-                " determine how to open the linked file (split, tab, etc)
-                if exists('g:vim_markdown_edit_url_in')
-                  if g:vim_markdown_edit_url_in == 'tab'
-                    let l:editmethod = 'tabnew'
-                  elseif g:vim_markdown_edit_url_in == 'vsplit'
-                    let l:editmethod = 'vsp'
-                  elseif g:vim_markdown_edit_url_in == 'hsplit'
-                    let l:editmethod = 'sp'
-                  else
-                    let l:editmethod = 'edit'
-                  endif
-                else
-                  " default to current buffer
-                  let l:editmethod = 'edit'
-                endif
-                execute l:editmethod l:url
-            endif
-            if l:anchor != ''
-                silent! execute '/'.l:anchor
-            endif
-        else
-            echomsg 'The cursor is not on a link.'
-        endif
-    endfunction
-endif
-
-function! s:VersionAwareNetrwBrowseX(url)
-    if has('patch-7.4.567')
-        call netrw#BrowseX(a:url, 0)
-    else
-        call netrw#NetrwBrowseX(a:url, 0)
-    endif
-endf
-
-function! s:MapNotHasmapto(lhs, rhs)
-    if !hasmapto('<Plug>' . a:rhs)
-        execute 'nmap <buffer>' . a:lhs . ' <Plug>' . a:rhs
-        execute 'vmap <buffer>' . a:lhs . ' <Plug>' . a:rhs
-    endif
-endfunction
-
-call <sid>MapNormVis('<Plug>Markdown_MoveToNextHeader', '<sid>MoveToNextHeader')
-call <sid>MapNormVis('<Plug>Markdown_MoveToPreviousHeader', '<sid>MoveToPreviousHeader')
-call <sid>MapNormVis('<Plug>Markdown_MoveToNextSiblingHeader', '<sid>MoveToNextSiblingHeader')
-call <sid>MapNormVis('<Plug>Markdown_MoveToPreviousSiblingHeader', '<sid>MoveToPreviousSiblingHeader')
-call <sid>MapNormVis('<Plug>Markdown_MoveToParentHeader', '<sid>MoveToParentHeader')
-call <sid>MapNormVis('<Plug>Markdown_MoveToCurHeader', '<sid>MoveToCurHeader')
-nnoremap <Plug>Markdown_OpenUrlUnderCursor :call <sid>OpenUrlUnderCursor()<cr>
-nnoremap <Plug>Markdown_EditUrlUnderCursor :call <sid>EditUrlUnderCursor()<cr>
-
-if !get(g:, 'vim_markdown_no_default_key_mappings', 0)
-    call <sid>MapNotHasmapto(']]', 'Markdown_MoveToNextHeader')
-    call <sid>MapNotHasmapto('[[', 'Markdown_MoveToPreviousHeader')
-    call <sid>MapNotHasmapto('][', 'Markdown_MoveToNextSiblingHeader')
-    call <sid>MapNotHasmapto('[]', 'Markdown_MoveToPreviousSiblingHeader')
-    call <sid>MapNotHasmapto(']u', 'Markdown_MoveToParentHeader')
-    call <sid>MapNotHasmapto(']c', 'Markdown_MoveToCurHeader')
-    call <sid>MapNotHasmapto('gx', 'Markdown_OpenUrlUnderCursor')
-    call <sid>MapNotHasmapto('ge', 'Markdown_EditUrlUnderCursor')
-endif
-
-command! -buffer -range=% HeaderDecrease call s:HeaderDecrease(<line1>, <line2>)
-command! -buffer -range=% HeaderIncrease call s:HeaderDecrease(<line1>, <line2>, 1)
-command! -buffer -range=% SetexToAtx call s:SetexToAtx(<line1>, <line2>)
-command! -buffer TableFormat call s:TableFormat()
-command! -buffer Toc call s:Toc()
-command! -buffer Toch call s:Toc('horizontal')
-command! -buffer Tocv call s:Toc('vertical')
-command! -buffer Toct call s:Toc('tab')
-
-" Heavily based on vim-notes - http://peterodding.com/code/vim/notes/
-if exists('g:vim_markdown_fenced_languages')
-    let s:filetype_dict = {}
-    for s:filetype in g:vim_markdown_fenced_languages
-        let key = matchstr(s:filetype, "[^=]*")
-        let val = matchstr(s:filetype, "[^=]*$")
-        let s:filetype_dict[key] = val
-    endfor
-else
-    let s:filetype_dict = {
-        \ 'c++': 'cpp',
-        \ 'viml': 'vim',
-        \ 'bash': 'sh',
-        \ 'ini': 'dosini'
-    \ }
-endif
-
-function! s:MarkdownHighlightSources(force)
-    " Syntax highlight source code embedded in notes.
-    " Look for code blocks in the current file
-    let filetypes = {}
-    for line in getline(1, '$')
-        let ft = matchstr(line, '```\s*\zs[0-9A-Za-z_+-]*')
-        if !empty(ft) && ft !~ '^\d*$' | let filetypes[ft] = 1 | endif
-    endfor
-    if !exists('b:mkd_known_filetypes')
-        let b:mkd_known_filetypes = {}
-    endif
-    if !exists('b:mkd_included_filetypes')
-        " set syntax file name included
-        let b:mkd_included_filetypes = {}
-    endif
-    if !a:force && (b:mkd_known_filetypes == filetypes || empty(filetypes))
-        return
-    endif
-
-    " Now we're ready to actually highlight the code blocks.
-    let startgroup = 'mkdCodeStart'
-    let endgroup = 'mkdCodeEnd'
-    for ft in keys(filetypes)
-        if a:force || !has_key(b:mkd_known_filetypes, ft)
-            if has_key(s:filetype_dict, ft)
-                let filetype = s:filetype_dict[ft]
-            else
-                let filetype = ft
-            endif
-            let group = 'mkdSnippet' . toupper(substitute(filetype, "[+-]", "_", "g"))
-            if !has_key(b:mkd_included_filetypes, filetype)
-                let include = s:SyntaxInclude(filetype)
-                let b:mkd_included_filetypes[filetype] = 1
-            else
-                let include = '@' . toupper(filetype)
-            endif
-            let command = 'syntax region %s matchgroup=%s start="^\s*```\s*%s$" matchgroup=%s end="\s*```$" keepend contains=%s%s'
-            execute printf(command, group, startgroup, ft, endgroup, include, has('conceal') && get(g:, 'vim_markdown_conceal', 1) && get(g:, 'vim_markdown_conceal_code_blocks', 1) ? ' concealends' : '')
-            execute printf('syntax cluster mkdNonListItem add=%s', group)
-
-            let b:mkd_known_filetypes[ft] = 1
-        endif
-    endfor
-endfunction
-
-function! s:SyntaxInclude(filetype)
-    " Include the syntax highlighting of another {filetype}.
-    let grouplistname = '@' . toupper(a:filetype)
-    " Unset the name of the current syntax while including the other syntax
-    " because some syntax scripts do nothing when "b:current_syntax" is set
-    if exists('b:current_syntax')
-        let syntax_save = b:current_syntax
-        unlet b:current_syntax
-    endif
-    try
-        execute 'syntax include' grouplistname 'syntax/' . a:filetype . '.vim'
-        execute 'syntax include' grouplistname 'after/syntax/' . a:filetype . '.vim'
-    catch /E484/
-        " Ignore missing scripts
-    endtry
-    " Restore the name of the current syntax
-    if exists('syntax_save')
-        let b:current_syntax = syntax_save
-    elseif exists('b:current_syntax')
-        unlet b:current_syntax
-    endif
-    return grouplistname
-endfunction
-
-
-function! s:MarkdownRefreshSyntax(force)
-    if &filetype =~ 'markdown' && line('$') > 1
-        call s:MarkdownHighlightSources(a:force)
-    endif
-endfunction
-
-function! s:MarkdownClearSyntaxVariables()
-    if &filetype =~ 'markdown'
-        unlet! b:mkd_included_filetypes
-    endif
-endfunction
-
-augroup Mkd
-    " These autocmd calling s:MarkdownRefreshSyntax need to be kept in sync with
-    " the autocmds calling s:MarkdownSetupFolding in after/ftplugin/markdown.vim.
-    autocmd! * <buffer>
-    autocmd BufWinEnter <buffer> call s:MarkdownRefreshSyntax(1)
-    autocmd BufUnload <buffer> call s:MarkdownClearSyntaxVariables()
-    autocmd BufWritePost <buffer> call s:MarkdownRefreshSyntax(0)
-    autocmd InsertEnter,InsertLeave <buffer> call s:MarkdownRefreshSyntax(0)
-    autocmd CursorHold,CursorHoldI <buffer> call s:MarkdownRefreshSyntax(0)
-augroup END
diff --git a/sources_non_forked/vim-markdown/indent/markdown.vim b/sources_non_forked/vim-markdown/indent/markdown.vim
deleted file mode 100644
index 2fa4cda..0000000
--- a/sources_non_forked/vim-markdown/indent/markdown.vim
+++ /dev/null
@@ -1,75 +0,0 @@
-if exists("b:did_indent") | finish | endif
-let b:did_indent = 1
-
-setlocal indentexpr=GetMarkdownIndent()
-setlocal nolisp
-setlocal autoindent
-
-" Automatically continue blockquote on line break
-setlocal formatoptions+=r
-setlocal comments=b:>
-if get(g:, "vim_markdown_auto_insert_bullets", 1)
-    " Do not automatically insert bullets when auto-wrapping with text-width
-    setlocal formatoptions-=c
-    " Accept various markers as bullets
-    setlocal comments+=b:*,b:+,b:-
-endif
-
-" Only define the function once
-if exists("*GetMarkdownIndent") | finish | endif
-
-function! s:IsMkdCode(lnum)
-    let name = synIDattr(synID(a:lnum, 1, 0), 'name')
-    return (name =~ '^mkd\%(Code$\|Snippet\)' || name != '' && name !~ '^\%(mkd\|html\)')
-endfunction
-
-function! s:IsLiStart(line)
-    return a:line !~ '^ *\([*-]\)\%( *\1\)\{2}\%( \|\1\)*$' &&
-      \    a:line =~ '^\s*[*+-] \+'
-endfunction
-
-function! s:IsHeaderLine(line)
-    return a:line =~ '^\s*#'
-endfunction
-
-function! s:IsBlankLine(line)
-    return a:line =~ '^$'
-endfunction
-
-function! s:PrevNonBlank(lnum)
-    let i = a:lnum
-    while i > 1 && s:IsBlankLine(getline(i))
-        let i -= 1
-    endwhile
-    return i
-endfunction
-
-function GetMarkdownIndent()
-    if v:lnum > 2 && s:IsBlankLine(getline(v:lnum - 1)) && s:IsBlankLine(getline(v:lnum - 2))
-        return 0
-    endif
-    let list_ind = get(g:, "vim_markdown_new_list_item_indent", 4)
-    " Find a non-blank line above the current line.
-    let lnum = s:PrevNonBlank(v:lnum - 1)
-    " At the start of the file use zero indent.
-    if lnum == 0 | return 0 | endif
-    let ind = indent(lnum)
-    let line = getline(lnum)    " Last line
-    let cline = getline(v:lnum) " Current line
-    if s:IsLiStart(cline)
-        " Current line is the first line of a list item, do not change indent
-        return indent(v:lnum)
-    elseif s:IsHeaderLine(cline) && !s:IsMkdCode(v:lnum)
-        " Current line is the header, do not indent
-        return 0
-    elseif s:IsLiStart(line)
-        if s:IsMkdCode(lnum)
-            return ind
-        else
-            " Last line is the first line of a list item, increase indent
-            return ind + list_ind
-        end
-    else
-        return ind
-    endif
-endfunction
diff --git a/sources_non_forked/vim-markdown/registry/markdown.yaml b/sources_non_forked/vim-markdown/registry/markdown.yaml
deleted file mode 100644
index 4d293ee..0000000
--- a/sources_non_forked/vim-markdown/registry/markdown.yaml
+++ /dev/null
@@ -1,9 +0,0 @@
-addon: markdown
-description: "Markdown syntax highlighting"
-files:
-  - ftdetect/markdown.vim
-  - ftplugin/markdown.vim
-  - syntax/markdown.vim
-  - after/ftplugin/markdown.vim
-  - indent/markdown.vim
-  - doc/vim-markdown.txt
diff --git a/sources_non_forked/vim-markdown/syntax/markdown.vim b/sources_non_forked/vim-markdown/syntax/markdown.vim
deleted file mode 100644
index 3999764..0000000
--- a/sources_non_forked/vim-markdown/syntax/markdown.vim
+++ /dev/null
@@ -1,184 +0,0 @@
-" Vim syntax file
-" Language:	Markdown
-" Maintainer:	Ben Williams <benw@plasticboy.com>
-" URL:		http://plasticboy.com/markdown-vim-mode/
-" Remark:	Uses HTML syntax file
-" TODO: 	Handle stuff contained within stuff (e.g. headings within blockquotes)
-
-
-" Read the HTML syntax to start with
-if version < 600
-  so <sfile>:p:h/html.vim
-else
-  runtime! syntax/html.vim
-
-  if exists('b:current_syntax')
-    unlet b:current_syntax
-  endif
-endif
-
-if version < 600
-  syntax clear
-elseif exists("b:current_syntax")
-  finish
-endif
-
-" don't use standard HiLink, it will not work with included syntax files
-if version < 508
-  command! -nargs=+ HtmlHiLink hi link <args>
-else
-  command! -nargs=+ HtmlHiLink hi def link <args>
-endif
-
-syn spell toplevel
-syn case ignore
-syn sync linebreaks=1
-
-let s:conceal = ''
-let s:concealends = ''
-let s:concealcode = ''
-if has('conceal') && get(g:, 'vim_markdown_conceal', 1)
-  let s:conceal = ' conceal'
-  let s:concealends = ' concealends'
-endif
-if has('conceal') && get(g:, 'vim_markdown_conceal_code_blocks', 1)
-  let s:concealcode = ' concealends'
-endif
-
-" additions to HTML groups
-if get(g:, 'vim_markdown_emphasis_multiline', 1)
-    let s:oneline = ''
-else
-    let s:oneline = ' oneline'
-endif
-syn region mkdItalic matchgroup=mkdItalic start="\%(\*\|_\)"    end="\%(\*\|_\)"
-syn region mkdBold matchgroup=mkdBold start="\%(\*\*\|__\)"    end="\%(\*\*\|__\)"
-syn region mkdBoldItalic matchgroup=mkdBoldItalic start="\%(\*\*\*\|___\)"    end="\%(\*\*\*\|___\)"
-execute 'syn region htmlItalic matchgroup=mkdItalic start="\%(^\|\s\)\zs\*\ze[^\\\*\t ]\%(\%([^*]\|\\\*\|\n\)*[^\\\*\t ]\)\?\*\_W" end="[^\\\*\t ]\zs\*\ze\_W" keepend contains=@Spell' . s:oneline . s:concealends
-execute 'syn region htmlItalic matchgroup=mkdItalic start="\%(^\|\s\)\zs_\ze[^\\_\t ]" end="[^\\_\t ]\zs_\ze\_W" keepend contains=@Spell' . s:oneline . s:concealends
-execute 'syn region htmlBold matchgroup=mkdBold start="\%(^\|\s\)\zs\*\*\ze\S" end="\S\zs\*\*" keepend contains=@Spell' . s:oneline . s:concealends
-execute 'syn region htmlBold matchgroup=mkdBold start="\%(^\|\s\)\zs__\ze\S" end="\S\zs__" keepend contains=@Spell' . s:oneline . s:concealends
-execute 'syn region htmlBoldItalic matchgroup=mkdBoldItalic start="\%(^\|\s\)\zs\*\*\*\ze\S" end="\S\zs\*\*\*" keepend contains=@Spell' . s:oneline . s:concealends
-execute 'syn region htmlBoldItalic matchgroup=mkdBoldItalic start="\%(^\|\s\)\zs___\ze\S" end="\S\zs___" keepend contains=@Spell' . s:oneline . s:concealends
-
-" [link](URL) | [link][id] | [link][] | ![image](URL)
-syn region mkdFootnotes matchgroup=mkdDelimiter start="\[^"    end="\]"
-execute 'syn region mkdID matchgroup=mkdDelimiter    start="\["    end="\]" contained oneline' . s:conceal
-execute 'syn region mkdURL matchgroup=mkdDelimiter   start="("     end=")"  contained oneline' . s:conceal
-execute 'syn region mkdLink matchgroup=mkdDelimiter  start="\\\@<!!\?\[\ze[^]\n]*\n\?[^]\n]*\][[(]" end="\]" contains=@mkdNonListItem,@Spell nextgroup=mkdURL,mkdID skipwhite' . s:concealends
-
-" Autolink without angle brackets.
-" mkd  inline links:      protocol     optional  user:pass@  sub/domain                    .com, .co.uk, etc         optional port   path/querystring/hash fragment
-"                         ------------ _____________________ ----------------------------- _________________________ ----------------- __
-syn match   mkdInlineURL /https\?:\/\/\(\w\+\(:\w\+\)\?@\)\?\([A-Za-z0-9][-_0-9A-Za-z]*\.\)\{1,}\(\w\{2,}\.\?\)\{1,}\(:[0-9]\{1,5}\)\?[^] \t]*/
-
-" Autolink with parenthesis.
-syn region  mkdInlineURL matchgroup=mkdDelimiter start="(\(https\?:\/\/\(\w\+\(:\w\+\)\?@\)\?\([A-Za-z0-9][-_0-9A-Za-z]*\.\)\{1,}\(\w\{2,}\.\?\)\{1,}\(:[0-9]\{1,5}\)\?[^] \t]*)\)\@=" end=")"
-
-" Autolink with angle brackets.
-syn region mkdInlineURL matchgroup=mkdDelimiter start="\\\@<!<\ze[a-z][a-z0-9,.-]\{1,22}:\/\/[^> ]*>" end=">"
-
-" Link definitions: [id]: URL (Optional Title)
-syn region mkdLinkDef matchgroup=mkdDelimiter   start="^ \{,3}\zs\[\^\@!" end="]:" oneline nextgroup=mkdLinkDefTarget skipwhite
-syn region mkdLinkDefTarget start="<\?\zs\S" excludenl end="\ze[>[:space:]\n]"   contained nextgroup=mkdLinkTitle,mkdLinkDef skipwhite skipnl oneline
-syn region mkdLinkTitle matchgroup=mkdDelimiter start=+"+     end=+"+  contained
-syn region mkdLinkTitle matchgroup=mkdDelimiter start=+'+     end=+'+  contained
-syn region mkdLinkTitle matchgroup=mkdDelimiter start=+(+     end=+)+  contained
-
-"HTML headings
-syn region htmlH1       matchgroup=mkdHeading     start="^\s*#"                   end="$" contains=mkdLink,mkdInlineURL,@Spell
-syn region htmlH2       matchgroup=mkdHeading     start="^\s*##"                  end="$" contains=mkdLink,mkdInlineURL,@Spell
-syn region htmlH3       matchgroup=mkdHeading     start="^\s*###"                 end="$" contains=mkdLink,mkdInlineURL,@Spell
-syn region htmlH4       matchgroup=mkdHeading     start="^\s*####"                end="$" contains=mkdLink,mkdInlineURL,@Spell
-syn region htmlH5       matchgroup=mkdHeading     start="^\s*#####"               end="$" contains=mkdLink,mkdInlineURL,@Spell
-syn region htmlH6       matchgroup=mkdHeading     start="^\s*######"              end="$" contains=mkdLink,mkdInlineURL,@Spell
-syn match  htmlH1       /^.\+\n=\+$/ contains=mkdLink,mkdInlineURL,@Spell
-syn match  htmlH2       /^.\+\n-\+$/ contains=mkdLink,mkdInlineURL,@Spell
-
-"define Markdown groups
-syn match  mkdLineBreak    /  \+$/
-syn region mkdBlockquote   start=/^\s*>/                   end=/$/ contains=mkdLink,mkdInlineURL,mkdLineBreak,@Spell
-execute 'syn region mkdCode matchgroup=mkdCodeDelimiter start=/\(\([^\\]\|^\)\\\)\@<!`/                     end=/`/'  . s:concealcode
-execute 'syn region mkdCode matchgroup=mkdCodeDelimiter start=/\(\([^\\]\|^\)\\\)\@<!``/ skip=/[^`]`[^`]/   end=/``/' . s:concealcode
-execute 'syn region mkdCode matchgroup=mkdCodeDelimiter start=/^\s*\z(`\{3,}\)[^`]*$/                       end=/^\s*\z1`*\s*$/'            . s:concealcode
-execute 'syn region mkdCode matchgroup=mkdCodeDelimiter start=/\(\([^\\]\|^\)\\\)\@<!\~\~/  end=/\(\([^\\]\|^\)\\\)\@<!\~\~/'               . s:concealcode
-execute 'syn region mkdCode matchgroup=mkdCodeDelimiter start=/^\s*\z(\~\{3,}\)\s*[0-9A-Za-z_+-]*\s*$/      end=/^\s*\z1\~*\s*$/'           . s:concealcode
-execute 'syn region mkdCode matchgroup=mkdCodeDelimiter start="<pre[^>]*\\\@<!>"                            end="</pre>"'                   . s:concealcode
-execute 'syn region mkdCode matchgroup=mkdCodeDelimiter start="<code[^>]*\\\@<!>"                           end="</code>"'                  . s:concealcode
-syn region mkdFootnote     start="\[^"                     end="\]"
-syn match  mkdCode         /^\s*\n\(\(\s\{8,}[^ ]\|\t\t\+[^\t]\).*\n\)\+/
-syn match  mkdCode         /\%^\(\(\s\{4,}[^ ]\|\t\+[^\t]\).*\n\)\+/
-syn match  mkdCode         /^\s*\n\(\(\s\{4,}[^ ]\|\t\+[^\t]\).*\n\)\+/ contained
-syn match  mkdListItem     /^\s*\%([-*+]\|\d\+\.\)\ze\s\+/ contained
-syn region mkdListItemLine start="^\s*\%([-*+]\|\d\+\.\)\s\+" end="$" oneline contains=@mkdNonListItem,mkdListItem,@Spell
-syn region mkdNonListItemBlock start="\(\%^\(\s*\([-*+]\|\d\+\.\)\s\+\)\@!\|\n\(\_^\_$\|\s\{4,}[^ ]\|\t+[^\t]\)\@!\)" end="^\(\s*\([-*+]\|\d\+\.\)\s\+\)\@=" contains=@mkdNonListItem,@Spell
-syn match  mkdRule         /^\s*\*\s\{0,1}\*\s\{0,1}\*\(\*\|\s\)*$/
-syn match  mkdRule         /^\s*-\s\{0,1}-\s\{0,1}-\(-\|\s\)*$/
-syn match  mkdRule         /^\s*_\s\{0,1}_\s\{0,1}_\(_\|\s\)*$/
-
-" YAML frontmatter
-if get(g:, 'vim_markdown_frontmatter', 0)
-  syn include @yamlTop syntax/yaml.vim
-  syn region Comment matchgroup=mkdDelimiter start="\%^---$" end="^\(---\|\.\.\.\)$" contains=@yamlTop keepend
-  unlet! b:current_syntax
-endif
-
-if get(g:, 'vim_markdown_toml_frontmatter', 0)
-  try
-    syn include @tomlTop syntax/toml.vim
-    syn region Comment matchgroup=mkdDelimiter start="\%^+++$" end="^+++$" transparent contains=@tomlTop keepend
-    unlet! b:current_syntax
-  catch /E484/
-    syn region Comment matchgroup=mkdDelimiter start="\%^+++$" end="^+++$"
-  endtry
-endif
-
-if get(g:, 'vim_markdown_json_frontmatter', 0)
-  try
-    syn include @jsonTop syntax/json.vim
-    syn region Comment matchgroup=mkdDelimiter start="\%^{$" end="^}$" contains=@jsonTop keepend
-    unlet! b:current_syntax
-  catch /E484/
-    syn region Comment matchgroup=mkdDelimiter start="\%^{$" end="^}$"
-  endtry
-endif
-
-if get(g:, 'vim_markdown_math', 0)
-  syn include @tex syntax/tex.vim
-  syn region mkdMath start="\\\@<!\$" end="\$" skip="\\\$" contains=@tex keepend
-  syn region mkdMath start="\\\@<!\$\$" end="\$\$" skip="\\\$" contains=@tex keepend
-endif
-
-" Strike through
-if get(g:, 'vim_markdown_strikethrough', 0)
-    execute 'syn region mkdStrike matchgroup=htmlStrike start="\%(\~\~\)" end="\%(\~\~\)"' . s:concealends
-    HtmlHiLink mkdStrike        htmlStrike
-endif
-
-syn cluster mkdNonListItem contains=@htmlTop,htmlItalic,htmlBold,htmlBoldItalic,mkdFootnotes,mkdInlineURL,mkdLink,mkdLinkDef,mkdLineBreak,mkdBlockquote,mkdCode,mkdRule,htmlH1,htmlH2,htmlH3,htmlH4,htmlH5,htmlH6,mkdMath,mkdStrike
-
-"highlighting for Markdown groups
-HtmlHiLink mkdString        String
-HtmlHiLink mkdCode          String
-HtmlHiLink mkdCodeDelimiter String
-HtmlHiLink mkdCodeStart     String
-HtmlHiLink mkdCodeEnd       String
-HtmlHiLink mkdFootnote      Comment
-HtmlHiLink mkdBlockquote    Comment
-HtmlHiLink mkdListItem      Identifier
-HtmlHiLink mkdRule          Identifier
-HtmlHiLink mkdLineBreak     Visual
-HtmlHiLink mkdFootnotes     htmlLink
-HtmlHiLink mkdLink          htmlLink
-HtmlHiLink mkdURL           htmlString
-HtmlHiLink mkdInlineURL     htmlLink
-HtmlHiLink mkdID            Identifier
-HtmlHiLink mkdLinkDef       mkdID
-HtmlHiLink mkdLinkDefTarget mkdURL
-HtmlHiLink mkdLinkTitle     htmlString
-HtmlHiLink mkdDelimiter     Delimiter
-
-let b:current_syntax = "mkd"
-
-delcommand HtmlHiLink
-" vim: ts=8
diff --git a/sources_non_forked/vim-markdown/test/README.md b/sources_non_forked/vim-markdown/test/README.md
deleted file mode 100644
index a13d6d2..0000000
--- a/sources_non_forked/vim-markdown/test/README.md
+++ /dev/null
@@ -1,5 +0,0 @@
-You can run the tests using the Makefile from the top directory:
-
-    make test
-
-To run them manually please refer to the instructions/commands in the Makefile.
diff --git a/sources_non_forked/vim-markdown/test/folding-toc.vader b/sources_non_forked/vim-markdown/test/folding-toc.vader
deleted file mode 100644
index 79c5400..0000000
--- a/sources_non_forked/vim-markdown/test/folding-toc.vader
+++ /dev/null
@@ -1,178 +0,0 @@
-" Tests atx and setext folding, and :Toc.
-
-Before:
-  source ../after/ftplugin/markdown.vim
-
-After:
-  setlocal foldexpr=0
-  setlocal foldmethod=manual
-
-Given markdown;
-# chap 1
-
-hello
-world
-
-```bash
-# some bash scripting
-pwd
-
-# this is another comment
-# other
-echo "foo"
-```
-
-## chap 1.1
-
-- dog
-- cat
-
-~~~~bash
-mkdir foo
-# comment in ~
-~~~~
-
-### chap 1.1.1
-
-- dragons
-- fenixs
-
-# chap 2
-
-another
-
-## chap 2.1
-
-- uk
-- japan
-- china
-
-
-# chap 3
-
-nothing here
-
-chap 4
-======
-
-setext are evil
-
-chap 4.1
---------
-
-evil indeed
-
-````bash
-# get system info
-uname -a
-````
-
-Execute (fold level):
-  AssertEqual foldlevel(1), 0, '# chap 1'
-  AssertEqual foldlevel(3), 1, 'hello'
-  AssertEqual foldlevel(6), 1, '```bash'
-  AssertEqual foldlevel(7), 1, '# some bash scripting'
-  AssertEqual foldlevel(15), 1, '## chap 1.1'
-  AssertEqual foldlevel(21), 2, 'mkdir foo'
-  AssertEqual foldlevel(22), 2, 'comment in ~'
-  AssertEqual foldlevel(25), 2, '### chap 1.1.1'
-  AssertEqual foldlevel(27), 3, '- dragons'
-  AssertEqual foldlevel(30), 1, '# chap 2'
-  AssertEqual foldlevel(32), 1, 'another'
-  AssertEqual foldlevel(34), 1, '# chap 2.1'
-  AssertEqual foldlevel(37), 2, '- japan'
-  AssertEqual foldlevel(41), 1, '# chap 3'
-  AssertEqual foldlevel(45), 1, 'chap 4\n======'
-  AssertEqual foldlevel(48), 1, 'setext are evil'
-  AssertEqual foldlevel(50), 2, 'chap 4.1\n------'
-
-Execute (fold text result):
-  AssertEqual foldtextresult(2), '+-- 28 lines: hello'
-  AssertEqual foldtextresult(31), '+-- 10 lines: another'
-  AssertEqual foldtextresult(42), '+--  3 lines: nothing here'
-  AssertEqual foldtextresult(45), '+-- 14 lines: chap 4'
-
-Execute (fold level with setting):
-  let g:vim_markdown_folding_level = 2
-  source ../after/ftplugin/markdown.vim
-  AssertEqual foldlevel(1), 0, '# chap 1'
-  AssertEqual foldlevel(3), 1, 'hello'
-  AssertEqual foldlevel(6), 1, '```bash'
-  AssertEqual foldlevel(7), 1, '# some bash scripting'
-  AssertEqual foldlevel(15), 0, '## chap 1.1'
-  AssertEqual foldlevel(21), 2, 'mkdir foo'
-  AssertEqual foldlevel(22), 2, 'comment in ~'
-  AssertEqual foldlevel(25), 2, '### chap 1.1.1'
-  AssertEqual foldlevel(27), 3, '- dragons'
-  AssertEqual foldlevel(30), 0, '# chap 2'
-  AssertEqual foldlevel(32), 1, 'another'
-  AssertEqual foldlevel(34), 0, '# chap 2.1'
-  AssertEqual foldlevel(37), 2, '- japan'
-  AssertEqual foldlevel(41), 0, '# chap 3'
-  AssertEqual foldlevel(45), 1, 'chap 4\n======'
-  AssertEqual foldlevel(48), 1, 'setext are evil'
-  AssertEqual foldlevel(50), 1, 'chap 4.1\n------'
-  let g:vim_markdown_folding_level = 0
-
-Execute (check TOC):
-  :Toc
-  :lclose
-  let res = getloclist(0)
-  let elem = res[0]
-  AssertEqual elem.lnum, 1
-  AssertEqual elem.text, '# chap 1'
-  let elem = res[1]
-  AssertEqual elem.lnum, 15
-  AssertEqual elem.text, '## chap 1.1'
-  let elem = res[2]
-  AssertEqual elem.lnum, 25
-  AssertEqual elem.text, '### chap 1.1.1'
-  let elem = res[3]
-  AssertEqual elem.lnum, 30
-  AssertEqual elem.text, '# chap 2'
-  let elem = res[4]
-  AssertEqual elem.lnum, 34
-  AssertEqual elem.text, '## chap 2.1'
-  let elem = res[5]
-  AssertEqual elem.lnum, 41
-  AssertEqual elem.text, '# chap 3'
-  let elem = res[6]
-  AssertEqual elem.lnum, 45
-  AssertEqual elem.text, 'chap 4'
-  let elem = res[7]
-  AssertEqual elem.lnum, 50
-  AssertEqual elem.text, 'chap 4.1'
-
-Given markdown;
----
-layout: article
-title: A test of the heading folding when there is YAML frontmatter
-tags: markdown yaml vim-markdown
----
-body
-
-heading
--------
-
-Execute (fold level of yaml front matter):
-  let g:vim_markdown_frontmatter = 1
-  source ../after/ftplugin/markdown.vim
-  AssertEqual foldlevel(1), 0, '---'
-  AssertEqual foldlevel(2), 0, 'layout: article'
-  AssertEqual foldlevel(4), 0, 'tags: markdown yaml vim-markdown'
-  AssertEqual foldlevel(5), 0, '---'
-  AssertEqual foldlevel(6), 0, 'body'
-  AssertEqual foldlevel(8), 2, 'heading'
-  AssertEqual foldlevel(9), 2, '-------'
-  unlet g:vim_markdown_frontmatter
-
-Execute (check Toc of yaml front matter):
-  let g:vim_markdown_frontmatter = 1
-  :Toc
-  :lclose
-  let res = getloclist(0)
-  AssertEqual len(res), 1
-  let elem = res[0]
-  AssertEqual elem.lnum, 8
-  AssertEqual elem.text, 'heading'
-  unlet g:vim_markdown_frontmatter
diff --git a/sources_non_forked/vim-markdown/test/folding.vader b/sources_non_forked/vim-markdown/test/folding.vader
deleted file mode 100644
index ecf5f9b..0000000
--- a/sources_non_forked/vim-markdown/test/folding.vader
+++ /dev/null
@@ -1,53 +0,0 @@
-Before:
-  source ../after/ftplugin/markdown.vim
-
-After:
-  setlocal foldexpr=0
-  setlocal foldmethod=manual
-
-Given markdown;
-# Title
-
-## Chapter 1
-
-```
-This is code block
-# This is just a comment
-```
-
-## Capter 2
-
-foobar
-
-Execute (fold level # in code block):
-  AssertEqual foldlevel(1), 0, '# Title'
-  AssertEqual foldlevel(3), 1, '## Chapter 1'
-  AssertEqual foldlevel(7), 2, '# This is just a comment'
-  AssertEqual foldlevel(8), 2, '```'
-  AssertEqual foldlevel(10), 1, '## Chapter 2'
-  AssertEqual foldlevel(12), 2, 'foobar'
-
-Given markdown;
-Fold Level 1
-============
-Fold Level 2
-------------
-
-Execute (fold level ==, --):
-  AssertEqual foldlevel(2), 1, '=='
-  AssertEqual foldlevel(4), 2, '--'
-
-Given markdown;
-# H1
-
-## H1.1
-
-## H1.2
-
-# H2
-
-Execute (fold level # in last line):
-  AssertEqual foldlevel(1), 0, '# H1'
-  AssertEqual foldlevel(3), 1, '## H1.1'
-  AssertEqual foldlevel(5), 1, '## H1.2'
-  AssertEqual foldlevel(7), 0, '# H2'
diff --git a/sources_non_forked/vim-markdown/test/ge_test.md b/sources_non_forked/vim-markdown/test/ge_test.md
deleted file mode 100644
index 0f5e100..0000000
--- a/sources_non_forked/vim-markdown/test/ge_test.md
+++ /dev/null
@@ -1 +0,0 @@
-ge test
diff --git a/sources_non_forked/vim-markdown/test/indent-new-list-item.vader b/sources_non_forked/vim-markdown/test/indent-new-list-item.vader
deleted file mode 100644
index f73d7cc..0000000
--- a/sources_non_forked/vim-markdown/test/indent-new-list-item.vader
+++ /dev/null
@@ -1,15 +0,0 @@
-Before:
-  let g:vim_markdown_new_list_item_indent = 2
-
-After:
-  unlet g:vim_markdown_new_list_item_indent
-
-Given markdown;
-* item1
-
-Do (new line from the first item of the list and add the second item):
-  o* item2
-
-Expect (insert 2 spaces to the head of second item):
-  * item1
-    * item2
diff --git a/sources_non_forked/vim-markdown/test/indent.md b/sources_non_forked/vim-markdown/test/indent.md
deleted file mode 100644
index 6d250a1..0000000
--- a/sources_non_forked/vim-markdown/test/indent.md
+++ /dev/null
@@ -1,26 +0,0 @@
-1. Confirm indent with new line insert after list items
-
-'\' is not list item.
-\ foo
-
-If only space and three '*' or '-' character are in the line,
-this line means horizontal item.
-If current line is below horizontal item, it need not to indent.
-Following example is horizontal item.
-
----
-***
-- - -
-* * *
-
-And list item must be specified space after [*-+].
-Following example is list item.
-
-* foo
-- bar
-+ baz
-
-But following example is not list item.
-*foo
--bar
-+baz
diff --git a/sources_non_forked/vim-markdown/test/indent.vader b/sources_non_forked/vim-markdown/test/indent.vader
deleted file mode 100644
index e0870d5..0000000
--- a/sources_non_forked/vim-markdown/test/indent.vader
+++ /dev/null
@@ -1,73 +0,0 @@
-Given markdown;
-* item1
-
-Do (insert enter at list end):
-  A\<cr>item2
-
-Expect (auto insert * and indent level is same):
-  * item1
-  * item2
-
-Given markdown;
-
-Execute:
-  syntax off
-
-Do (insert enter at list end with syntax off):
-  i* item1\<cr>item2
-
-Expect (auto insert * and indent level is same):
-  * item1
-  * item2
-
-Execute:
-  syntax on
-
-Given markdown;
-```
-* item1
-
-Do (insert after list items in code block):
-  jotext
-
-Expect (no autoindent in code block):
-  ```
-  * item1
-  text
-
-Given markdown;
-* item1
-
-a
-
-Do (insert enter after list):
-  jji\<cr>b
-
-Expect (no autoindent outside list):
-  * item1
-
-
-  ba
-
-Given markdown;
--   a
-
-    # b
-
-Do (insert header after list):
-  jjwi#
-
-Expect (no indent header after list):
-  -   a
-
-  ## b
-
-Given markdown;
-* item1
-
-Do (new line from the first item of the list and add the second item):
-  o* item2
-
-Expect (insert 4 spaces to the head of second item):
-  * item1
-      * item2
diff --git a/sources_non_forked/vim-markdown/test/map.vader b/sources_non_forked/vim-markdown/test/map.vader
deleted file mode 100644
index 7ecdfad..0000000
--- a/sources_non_forked/vim-markdown/test/map.vader
+++ /dev/null
@@ -1,153 +0,0 @@
-Given markdown;
-a <http://b> c
-
-Execute (gx autolink):
-  let b:url = 'http://b'
-  let b:line = getline(1)
-  let b:func = Markdown_GetFunc('vim-markdown/ftplugin/markdown.vim', 'Markdown_GetUrlForPosition')
-  AssertEqual b:func(1, match(b:line, 'a') + 1), ''
-  AssertEqual b:func(1, match(b:line, '<') + 1), b:url
-  AssertEqual b:func(1, match(b:line, 'h') + 1), b:url
-  AssertEqual b:func(1, match(b:line, '>') + 1), b:url
-  AssertEqual b:func(1, match(b:line, 'c') + 1), ''
-
-Given markdown;
-a http://b.bb c
-
-Execute (gx implicit autolink):
-  let b:url = 'http://b.bb'
-  let b:line = getline(1)
-  let b:func = Markdown_GetFunc('vim-markdown/ftplugin/markdown.vim', 'Markdown_GetUrlForPosition')
-  AssertEqual b:func(1, match(b:line, 'a') + 1), ''
-  AssertEqual b:func(1, match(b:line, 'h') + 1), b:url
-  AssertEqual b:func(1, match(b:line, 'c') + 1), ''
-
-Given markdown;
-[a]: http://b "c"
-
-Execute (gx link reference definition):
-  let b:url = 'http://b'
-  let b:line = getline(1)
-  let b:func = Markdown_GetFunc('vim-markdown/ftplugin/markdown.vim', 'Markdown_GetUrlForPosition')
-  " TODO would be cool if all of the following gave the link.
-  AssertEqual b:func(1, match(b:line, 'a') + 1), ''
-  AssertEqual b:func(1, match(b:line, 'h') + 1), b:url
-  AssertEqual b:func(1, match(b:line, 'c') + 1), ''
-
-Given markdown;
-a [b](c) d
-
-Execute (gx autolink):
-  let b:url = 'c'
-  let b:line = getline(1)
-  let b:func = Markdown_GetFunc('vim-markdown/ftplugin/markdown.vim', 'Markdown_GetUrlForPosition')
-  AssertEqual b:func(1, match(b:line, 'a') + 1), ''
-  AssertEqual b:func(1, match(b:line, '[') + 1), b:url
-  AssertEqual b:func(1, match(b:line, 'b') + 1), b:url
-  AssertEqual b:func(1, match(b:line, ']') + 1), b:url
-  AssertEqual b:func(1, match(b:line, '(') + 1), b:url
-  AssertEqual b:func(1, match(b:line, 'c') + 1), b:url
-  AssertEqual b:func(1, match(b:line, ')') + 1), b:url
-  AssertEqual b:func(1, match(b:line, 'd') + 1), ''
-
-Given markdown;
-[ge_test.md](ge_test.md)
-
-Execute (ge opens file):
-  normal ge
-  AssertEqual @%, 'ge_test.md'
-  AssertEqual getline(1), 'ge test'
-
-Given markdown;
-[ge_test](ge_test)
-
-Execute (ge opens file without .md extensions):
-  let g:vim_markdown_no_extensions_in_markdown = 1
-  normal ge
-  AssertEqual @%, 'ge_test.md'
-  AssertEqual getline(1), 'ge test'
-  unlet g:vim_markdown_no_extensions_in_markdown
-
-Given markdown;
-[ge_test.md](ge_test.md)
-
-Execute (ge does not write before opening file):
-  normal ia
-  normal l
-  normal ge
-  AssertEqual @%, 'ge_test.md'
-  AssertEqual getline(1), 'ge test'
-
-Given markdown;
-[ge_test.md](ge_test.md)
-
-Execute (ge auto-write before opening file):
-  let g:vim_markdown_autowrite = 1
-  normal ia
-  normal l
-  AssertThrows normal ge
-  AssertEqual g:vader_exception, 'Vim(write):E382: Cannot write, ''buftype'' option is set'
-  unlet g:vim_markdown_autowrite
-
-Given markdown;
-# a
-
-b
-
-# c
-
-d
-
-Execute (]] same level):
-  AssertEqual line('.'), 1
-  normal ]]
-  AssertEqual line('.'), 5
-  normal [[
-  AssertEqual line('.'), 1
-
-Given markdown;
-# a
-
-b
-
-## c
-
-d
-
-Execute (]] different levels level):
-  AssertEqual line('.'), 1
-  normal ]]
-  AssertEqual line('.'), 5
-  normal [[
-  AssertEqual line('.'), 1
-
-Given markdown;
-# a
-
-b
-
-## c
-
-d
-
-# e
-
-f
-
-Execute (][ different levels level):
-  AssertEqual line('.'), 1
-  normal ][
-  AssertEqual line('.'), 9
-  normal []
-  AssertEqual line('.'), 1
-
-Given markdown;
-# a
-
-b
-
-Execute (]c):
-  normal! 3G
-  AssertEqual line('.'), 3
-  normal ]c
-  AssertEqual line('.'), 1
diff --git a/sources_non_forked/vim-markdown/test/python-folding.vader b/sources_non_forked/vim-markdown/test/python-folding.vader
deleted file mode 100644
index 9196ea6..0000000
--- a/sources_non_forked/vim-markdown/test/python-folding.vader
+++ /dev/null
@@ -1,84 +0,0 @@
-Before:
-  let g:vim_markdown_folding_style_pythonic = 1
-  source ../after/ftplugin/markdown.vim
-
-After:
-  setlocal foldexpr=0
-  setlocal foldmethod=manual
-
-Given markdown;
-# Title
-
-## Chapter 1
-
-```
-This is code block
-# This is just a comment
-```
-
-## Chapter 2
-
-foobar
-
-Execute (fold level # in code block):
-  AssertEqual foldlevel(1), 1, '# Title'
-  AssertEqual foldlevel(3), 2, '## Chapter 1'
-  AssertEqual foldlevel(7), 2, '# This is just a comment'
-  AssertEqual foldlevel(8), 2, '```'
-  AssertEqual foldlevel(10), 2, '## Chapter 2'
-  AssertEqual foldlevel(12), 2, 'foobar'
-
-Execute (fold text of chapters):
-  let b:width = winwidth(0)
-  let b:hyphen = repeat('-', b:width - 18 > 2 ? b:width - 18 : b:width - 9 > 0 ? 3 : 2)
-  AssertEqual foldtextresult(10), strpart('## Chapter 2', 0, b:width - 9) . ' ' . b:hyphen . ' 2'
-
-Given markdown;
-Fold text 1
-===========
-Fold text 2
------------
-
-Execute (fold level ==, --):
-  AssertEqual foldlevel(2), 0, '=='
-  AssertEqual foldlevel(4), 1, '--'
-
-Execute (fold text of ==, --):
-  let b:width = winwidth(0)
-  let b:hyphen = repeat('-', b:width - 17 > 2 ? b:width - 17 : b:width - 9 > 0 ? 3 : 2)
-  AssertEqual foldtextresult(3), strpart('Fold text 2', 0, b:width - 9) . ' ' . b:hyphen . ' 1'
-
-Given markdown;
-Headline
-
-foobar
-
-# Title
-
-Execute (fold any preamble):
-  AssertEqual foldlevel(1), 1, 'Headline'
-  AssertEqual foldlevel(3), 1, 'foobar'
-  AssertEqual foldlevel(5), 1, '# Title'
-
-Given markdown;
----
-layout: article
-title: A test of the heading folding when there is YAML frontmatter
-tags: markdown yaml vim-markdown
----
-body
-
-heading
--------
-
-Execute (fold level of yaml front matter):
-  let g:vim_markdown_frontmatter = 1
-  source ../after/ftplugin/markdown.vim
-  AssertEqual foldlevel(1), 1, '---'
-  AssertEqual foldlevel(2), 1, 'layout: article'
-  AssertEqual foldlevel(4), 1, 'tags: markdown yaml vim-markdown'
-  AssertEqual foldlevel(5), 1, '---'
-  AssertEqual foldlevel(6), 1, 'body'
-  AssertEqual foldlevel(8), 1, 'heading'
-  AssertEqual foldlevel(9), 1, '-------'
-  unlet g:vim_markdown_frontmatter
diff --git a/sources_non_forked/vim-markdown/test/run-tests.sh b/sources_non_forked/vim-markdown/test/run-tests.sh
deleted file mode 100644
index 5c9db06..0000000
--- a/sources_non_forked/vim-markdown/test/run-tests.sh
+++ /dev/null
@@ -1,16 +0,0 @@
-#!/usr/bin/env bash
-
-# Exit on error.
-set -e
-
-cd "$( dirname "${BASH_SOURCE[0]}" )"
-
-for dep in ../build/tabular ../build/vim-toml ../build/vim-json ../build/vader.vim; do
-  if [[ ! -d $dep ]]; then
-    echo "Missing dependency: $dep"
-    echo "You may just want to use 'make test'."
-    exit 1
-  fi
-done
-
-vim -Nu vimrc -c 'Vader! *' > /dev/null
diff --git a/sources_non_forked/vim-markdown/test/syntax-singleline.vader b/sources_non_forked/vim-markdown/test/syntax-singleline.vader
deleted file mode 100644
index 9fde407..0000000
--- a/sources_non_forked/vim-markdown/test/syntax-singleline.vader
+++ /dev/null
@@ -1,158 +0,0 @@
-Before:
-  let g:vim_markdown_emphasis_multiline = 0
-  syn off | syn on
-
-After:
-  let g:vim_markdown_emphasis_multiline = 1
-  syn off | syn on
-
-Given markdown;
-a **b** c
-
-Execute (bold):
-  AssertNotEqual SyntaxOf('a'), 'htmlBold'
-  AssertEqual SyntaxOf('b'), 'htmlBold'
-  AssertNotEqual SyntaxOf('c'), 'htmlBold'
-
-Given markdown;
-a __b__ c
-
-Execute (bold):
-  AssertNotEqual SyntaxOf('a'), 'htmlBold'
-  AssertEqual SyntaxOf('b'), 'htmlBold'
-  AssertNotEqual SyntaxOf('c'), 'htmlBold'
-
-Given markdown;
-a *b* c
-
-Execute (italic):
-  AssertNotEqual SyntaxOf('a'), 'htmlItalic'
-  AssertEqual SyntaxOf('b'), 'htmlItalic'
-  AssertNotEqual SyntaxOf('c'), 'htmlItalic'
-
-Given markdown;
-a _b_ c
-
-Execute (italic):
-  AssertNotEqual SyntaxOf('a'), 'htmlItalic'
-  AssertEqual SyntaxOf('b'), 'htmlItalic'
-  AssertNotEqual SyntaxOf('c'), 'htmlItalic'
-
-Given markdown;
-_a_b_
-
-Execute (italic text has underscores):
-  AssertEqual SyntaxOf('a'), 'htmlItalic'
-  AssertEqual SyntaxOf('b'), 'htmlItalic'
-
-Given markdown;
-a \*b\* c
-
-Execute (not italic with escaped asterisks):
-  AssertNotEqual SyntaxOf('a'), 'htmlItalic'
-  AssertNotEqual SyntaxOf('b'), 'htmlItalic'
-  AssertNotEqual SyntaxOf('c'), 'htmlItalic'
-
-Given markdown;
-a \_b\_ c
-
-Execute (not italic with escaped underscores):
-  AssertNotEqual SyntaxOf('a'), 'htmlItalic'
-  AssertNotEqual SyntaxOf('b'), 'htmlItalic'
-  AssertNotEqual SyntaxOf('c'), 'htmlItalic'
-
-Given markdown;
-a _b\_c_ d
-
-Execute (italic with escaped underscores):
-  AssertNotEqual SyntaxOf('a'), 'htmlItalic'
-  AssertEqual SyntaxOf('b'), 'htmlItalic'
-  AssertEqual SyntaxOf('c'), 'htmlItalic'
-  AssertNotEqual SyntaxOf('d'), 'htmlItalic'
-
-Given markdown;
-a_b_c
-
-Execute (not italic underscores within text):
-  AssertNotEqual SyntaxOf('a'), 'htmlItalic'
-  AssertNotEqual SyntaxOf('b'), 'htmlItalic'
-  AssertNotEqual SyntaxOf('c'), 'htmlItalic'
-
-Given markdown;
-a *b\*c* d
-
-Execute (italic with escaped asterisks):
-  AssertNotEqual SyntaxOf('a'), 'htmlItalic'
-  AssertEqual SyntaxOf('b'), 'htmlItalic'
-  AssertEqual SyntaxOf('c'), 'htmlItalic'
-  AssertNotEqual SyntaxOf('d'), 'htmlItalic'
-
-Given markdown;
-a __b\_\_c__ d
-
-Execute (bold with escaped underscores):
-  AssertNotEqual SyntaxOf('a'), 'htmlBold'
-  AssertEqual SyntaxOf('b'), 'htmlBold'
-  AssertEqual SyntaxOf('c'), 'htmlBold'
-  AssertNotEqual SyntaxOf('d'), 'htmlBold'
-
-Given markdown;
-_a b
-c_ d
-
-Execute (italic with underscores in multiple lines):
-  AssertNotEqual SyntaxOf('a'), 'htmlItalic'
-  AssertNotEqual SyntaxOf('b'), 'htmlItalic'
-  AssertNotEqual SyntaxOf('c'), 'htmlItalic'
-  AssertNotEqual SyntaxOf('d'), 'htmlItalic'
-
-Given markdown;
-__a b
-c__ d
-
-Execute (bold with underscores in multiple lines):
-  AssertNotEqual SyntaxOf('a'), 'htmlBold'
-  AssertNotEqual SyntaxOf('b'), 'htmlBold'
-  AssertNotEqual SyntaxOf('c'), 'htmlBold'
-  AssertNotEqual SyntaxOf('d'), 'htmlBold'
-
-Given markdown;
-___a b
-c___ d
-
-Execute (bold italic with underscores in multiple lines):
-  AssertNotEqual SyntaxOf('a'), 'htmlBoldItalic'
-  AssertNotEqual SyntaxOf('b'), 'htmlBoldItalic'
-  AssertNotEqual SyntaxOf('c'), 'htmlBoldItalic'
-  AssertNotEqual SyntaxOf('d'), 'htmlBoldItalic'
-
-Given markdown;
-*a b
-c* d
-
-Execute (italic with asterisks in multiple lines):
-  AssertNotEqual SyntaxOf('a'), 'htmlItalic'
-  AssertNotEqual SyntaxOf('b'), 'htmlItalic'
-  AssertNotEqual SyntaxOf('c'), 'htmlItalic'
-  AssertNotEqual SyntaxOf('d'), 'htmlItalic'
-
-Given markdown;
-**a b
-c** d
-
-Execute (bold with asterisks in multiple lines):
-  AssertNotEqual SyntaxOf('a'), 'htmlBold'
-  AssertNotEqual SyntaxOf('b'), 'htmlBold'
-  AssertNotEqual SyntaxOf('c'), 'htmlBold'
-  AssertNotEqual SyntaxOf('d'), 'htmlBold'
-
-Given markdown;
-***a b
-c*** d
-
-Execute (bold italic with asterisks in multiple lines):
-  AssertNotEqual SyntaxOf('a'), 'htmlBoldItalic'
-  AssertNotEqual SyntaxOf('b'), 'htmlBoldItalic'
-  AssertNotEqual SyntaxOf('c'), 'htmlBoldItalic'
-  AssertNotEqual SyntaxOf('d'), 'htmlBoldItalic'
-
diff --git a/sources_non_forked/vim-markdown/test/syntax.md b/sources_non_forked/vim-markdown/test/syntax.md
deleted file mode 100644
index 33f5500..0000000
--- a/sources_non_forked/vim-markdown/test/syntax.md
+++ /dev/null
@@ -1,89 +0,0 @@
-# Fenced code living in an indented environment is correctly highlighted
-
-1. run this command to do this:
-
-    ```
-some command
-    ```
-
-2. Subsequent list items are correctly highlighted.
-
-Fenced code block with language:
-
-```ruby
-def f
-  0
-end
-```
-
-# Links
-
-[a](b "c")
-
-[a]()
-
-[good spell](a)
-
-[badd spell](a)
-
-[a](b "c")
-
-[a]( b
-"c" )
-
-a (`a`) b. Fix: <https://github.com/plasticboy/vim-markdown/issues/113>
-
-Escaped:
-
-\[a](b)
-
-[a\]b](c)
-
-## Known failures
-
-Escape does not work:
-
-[a\](b)
-
-Should not be links because of whitespace:
-
-[a] (b)
-
-[a](a
-b)
-
-[a](a b)
-
-# Reference links
-
-Single links:
-
-[a][b]
-
-[good spell][a]
-
-[badd spell][a]
-
-[a][]
-
-[a] []
-
-[a][b] c [d][e]
-
-Reference link followed by inline link:
-
-[a] [b](c)
-
-## Known failures
-
-Should be shortcut reference links:
-
-[a]
-
-[a] b [c]
-
-Should be a single link:
-
-[a] [b]
-
-[a] b [c](d)
diff --git a/sources_non_forked/vim-markdown/test/syntax.vader b/sources_non_forked/vim-markdown/test/syntax.vader
deleted file mode 100644
index d6f5487..0000000
--- a/sources_non_forked/vim-markdown/test/syntax.vader
+++ /dev/null
@@ -1,1285 +0,0 @@
-Before:
-  unlet! b:mkd_known_filetypes
-  unlet! b:mkd_included_filetypes
-  unlet! g:vim_markdown_math
-
-Given markdown;
-a **b** c
-
-Execute (bold):
-  AssertNotEqual SyntaxOf('a'), 'htmlBold'
-  AssertEqual SyntaxOf('b'), 'htmlBold'
-  AssertNotEqual SyntaxOf('c'), 'htmlBold'
-
-Given markdown;
-a __b__ c
-
-Execute (bold):
-  AssertNotEqual SyntaxOf('a'), 'htmlBold'
-  AssertEqual SyntaxOf('b'), 'htmlBold'
-  AssertNotEqual SyntaxOf('c'), 'htmlBold'
-
-Given markdown;
-a *b* c
-
-Execute (italic):
-  AssertNotEqual SyntaxOf('a'), 'htmlItalic'
-  AssertEqual SyntaxOf('b'), 'htmlItalic'
-  AssertNotEqual SyntaxOf('c'), 'htmlItalic'
-
-Given markdown;
-a _b_ c
-
-Execute (italic):
-  AssertNotEqual SyntaxOf('a'), 'htmlItalic'
-  AssertEqual SyntaxOf('b'), 'htmlItalic'
-  AssertNotEqual SyntaxOf('c'), 'htmlItalic'
-
-Given markdown;
-_a_b_
-
-Execute (italic text has underscores):
-  AssertEqual SyntaxOf('a'), 'htmlItalic'
-  AssertEqual SyntaxOf('b'), 'htmlItalic'
-
-Given markdown;
-a \*b\* c
-
-Execute (not italic with escaped asterisks):
-  AssertNotEqual SyntaxOf('a'), 'htmlItalic'
-  AssertNotEqual SyntaxOf('b'), 'htmlItalic'
-  AssertNotEqual SyntaxOf('c'), 'htmlItalic'
-
-Given markdown;
-a \_b\_ c
-
-Execute (not italic with escaped underscores):
-  AssertNotEqual SyntaxOf('a'), 'htmlItalic'
-  AssertNotEqual SyntaxOf('b'), 'htmlItalic'
-  AssertNotEqual SyntaxOf('c'), 'htmlItalic'
-
-Given markdown;
-a _b\_c_ d
-
-Execute (italic with escaped underscores):
-  AssertNotEqual SyntaxOf('a'), 'htmlItalic'
-  AssertEqual SyntaxOf('b'), 'htmlItalic'
-  AssertEqual SyntaxOf('c'), 'htmlItalic'
-  AssertNotEqual SyntaxOf('d'), 'htmlItalic'
-
-Given markdown;
-a_b_c
-
-Execute (not italic underscores within text):
-  AssertNotEqual SyntaxOf('a'), 'htmlItalic'
-  AssertNotEqual SyntaxOf('b'), 'htmlItalic'
-  AssertNotEqual SyntaxOf('c'), 'htmlItalic'
-
-Given markdown;
-a *b\*c* d
-
-Execute (italic with escaped asterisks):
-  AssertNotEqual SyntaxOf('a'), 'htmlItalic'
-  AssertEqual SyntaxOf('b'), 'htmlItalic'
-  AssertEqual SyntaxOf('c'), 'htmlItalic'
-  AssertNotEqual SyntaxOf('d'), 'htmlItalic'
-
-Given markdown;
-a __b\_\_c__ d
-
-Execute (bold with escaped underscores):
-  AssertNotEqual SyntaxOf('a'), 'htmlBold'
-  AssertEqual SyntaxOf('b'), 'htmlBold'
-  AssertEqual SyntaxOf('c'), 'htmlBold'
-  AssertNotEqual SyntaxOf('d'), 'htmlBold'
-
-Given markdown;
-_a b
-c_ d
-
-Execute (italic with underscores in multiple lines):
-  AssertEqual SyntaxOf('a'), 'htmlItalic'
-  AssertEqual SyntaxOf('b'), 'htmlItalic'
-  AssertEqual SyntaxOf('c'), 'htmlItalic'
-  AssertNotEqual SyntaxOf('d'), 'htmlItalic'
-
-Given markdown;
-__a b
-c__ d
-
-Execute (bold with underscores in multiple lines):
-  AssertEqual SyntaxOf('a'), 'htmlBold'
-  AssertEqual SyntaxOf('b'), 'htmlBold'
-  AssertEqual SyntaxOf('c'), 'htmlBold'
-  AssertNotEqual SyntaxOf('d'), 'htmlBold'
-
-Given markdown;
-___a b
-c___ d
-
-Execute (bold italic with underscores in multiple lines):
-  AssertEqual SyntaxOf('a'), 'htmlBoldItalic'
-  AssertEqual SyntaxOf('b'), 'htmlBoldItalic'
-  AssertEqual SyntaxOf('c'), 'htmlBoldItalic'
-  AssertNotEqual SyntaxOf('d'), 'htmlBoldItalic'
-
-Given markdown;
-*a b
-c* d
-
-Execute (italic with asterisks in multiple lines):
-  AssertEqual SyntaxOf('a'), 'htmlItalic'
-  AssertEqual SyntaxOf('b'), 'htmlItalic'
-  AssertEqual SyntaxOf('c'), 'htmlItalic'
-  AssertNotEqual SyntaxOf('d'), 'htmlItalic'
-
-Given markdown;
-**a b
-c** d
-
-Execute (bold with asterisks in multiple lines):
-  AssertEqual SyntaxOf('a'), 'htmlBold'
-  AssertEqual SyntaxOf('b'), 'htmlBold'
-  AssertEqual SyntaxOf('c'), 'htmlBold'
-  AssertNotEqual SyntaxOf('d'), 'htmlBold'
-
-Given markdown;
-***a b
-c*** d
-
-Execute (bold italic with asterisks in multiple lines):
-  AssertEqual SyntaxOf('a'), 'htmlBoldItalic'
-  AssertEqual SyntaxOf('b'), 'htmlBoldItalic'
-  AssertEqual SyntaxOf('c'), 'htmlBoldItalic'
-  AssertNotEqual SyntaxOf('d'), 'htmlBoldItalic'
-
-Given markdown;
-*a
-
-Execute (not italic with an asterisk):
-  AssertNotEqual SyntaxOf('a'), 'htmlItalic'
-
-Given markdown;
-[__](a) b
-
-Execute (not bold with double underscores):
-  AssertNotEqual SyntaxOf('_'), 'htmlBold'
-  AssertNotEqual SyntaxOf('a'), 'htmlBold'
-  AssertNotEqual SyntaxOf('b'), 'htmlBold'
-
-Given markdown;
-_a_
-
-Execute (conceal italic):
-  if has('conceal')
-    setlocal conceallevel=2
-    AssertEqual synconcealed(1, 1)[0], 1
-    AssertEqual synconcealed(1, 2)[0], 0
-    AssertEqual synconcealed(1, 3)[0], 1
-    setlocal conceallevel=0
-  endif
-
-Execute (disable conceal):
-  if has('conceal')
-    let g:vim_markdown_conceal=0
-    syn off | syn on
-    setlocal conceallevel=2
-    AssertEqual synconcealed(1, 1)[0], 0
-    AssertEqual synconcealed(1, 2)[0], 0
-    AssertEqual synconcealed(1, 3)[0], 0
-
-    let g:vim_markdown_conceal=1
-    syn off | syn on
-    AssertEqual synconcealed(1, 1)[0], 1
-    AssertEqual synconcealed(1, 2)[0], 0
-    AssertEqual synconcealed(1, 3)[0], 1
-
-    setlocal conceallevel=0
-    unlet g:vim_markdown_conceal
-    syn off | syn on
-  endif
-
-Given markdown;
-*a*
-
-Execute (conceal italic):
-  if has('conceal')
-    setlocal conceallevel=2
-    AssertEqual synconcealed(1, 1)[0], 1
-    AssertEqual synconcealed(1, 2)[0], 0
-    AssertEqual synconcealed(1, 3)[0], 1
-    setlocal conceallevel=0
-  endif
-
-Execute (disable conceal):
-  if has('conceal')
-    let g:vim_markdown_conceal=0
-    syn off | syn on
-    setlocal conceallevel=2
-    AssertEqual synconcealed(1, 1)[0], 0
-    AssertEqual synconcealed(1, 2)[0], 0
-    AssertEqual synconcealed(1, 3)[0], 0
-
-    let g:vim_markdown_conceal=1
-    syn off | syn on
-    AssertEqual synconcealed(1, 1)[0], 1
-    AssertEqual synconcealed(1, 2)[0], 0
-    AssertEqual synconcealed(1, 3)[0], 1
-
-    setlocal conceallevel=0
-    unlet g:vim_markdown_conceal
-    syn off | syn on
-  endif
-
-Given markdown;
-__a__
-
-Execute (conceal bold):
-  if has('conceal')
-    setlocal conceallevel=2
-    AssertEqual synconcealed(1, 1)[0], 1
-    AssertEqual synconcealed(1, 2)[0], 1
-    AssertEqual synconcealed(1, 3)[0], 0
-    AssertEqual synconcealed(1, 4)[0], 1
-    AssertEqual synconcealed(1, 5)[0], 1
-    setlocal conceallevel=0
-  endif
-
-Execute (disable conceal):
-  if has('conceal')
-    let g:vim_markdown_conceal=0
-    syn off | syn on
-    setlocal conceallevel=2
-    AssertEqual synconcealed(1, 1)[0], 0
-    AssertEqual synconcealed(1, 2)[0], 0
-    AssertEqual synconcealed(1, 3)[0], 0
-    AssertEqual synconcealed(1, 4)[0], 0
-    AssertEqual synconcealed(1, 5)[0], 0
-
-    let g:vim_markdown_conceal=1
-    syn off | syn on
-    AssertEqual synconcealed(1, 1)[0], 1
-    AssertEqual synconcealed(1, 2)[0], 1
-    AssertEqual synconcealed(1, 3)[0], 0
-    AssertEqual synconcealed(1, 4)[0], 1
-    AssertEqual synconcealed(1, 5)[0], 1
-
-    setlocal conceallevel=0
-    unlet g:vim_markdown_conceal
-    syn off | syn on
-  endif
-
-Given markdown;
-**a**
-
-Execute (conceal bold):
-  if has('conceal')
-    setlocal conceallevel=2
-    AssertEqual synconcealed(1, 1)[0], 1
-    AssertEqual synconcealed(1, 2)[0], 1
-    AssertEqual synconcealed(1, 3)[0], 0
-    AssertEqual synconcealed(1, 4)[0], 1
-    AssertEqual synconcealed(1, 5)[0], 1
-    setlocal conceallevel=0
-  endif
-
-Execute (disable conceal):
-  if has('conceal')
-    let g:vim_markdown_conceal=0
-    syn off | syn on
-    setlocal conceallevel=2
-    AssertEqual synconcealed(1, 1)[0], 0
-    AssertEqual synconcealed(1, 2)[0], 0
-    AssertEqual synconcealed(1, 3)[0], 0
-    AssertEqual synconcealed(1, 4)[0], 0
-    AssertEqual synconcealed(1, 5)[0], 0
-
-    let g:vim_markdown_conceal=1
-    syn off | syn on
-    AssertEqual synconcealed(1, 1)[0], 1
-    AssertEqual synconcealed(1, 2)[0], 1
-    AssertEqual synconcealed(1, 3)[0], 0
-    AssertEqual synconcealed(1, 4)[0], 1
-    AssertEqual synconcealed(1, 5)[0], 1
-
-    setlocal conceallevel=0
-    unlet g:vim_markdown_conceal
-    syn off | syn on
-  endif
-
-Given markdown;
-___a___
-
-Execute (conceal italic bold):
-  if has('conceal')
-    setlocal conceallevel=2
-    AssertEqual synconcealed(1, 1)[0], 1
-    AssertEqual synconcealed(1, 2)[0], 1
-    AssertEqual synconcealed(1, 3)[0], 1
-    AssertEqual synconcealed(1, 4)[0], 0
-    AssertEqual synconcealed(1, 5)[0], 1
-    AssertEqual synconcealed(1, 6)[0], 1
-    AssertEqual synconcealed(1, 7)[0], 1
-    setlocal conceallevel=0
-  endif
-
-Execute (disable conceal):
-  if has('conceal')
-    let g:vim_markdown_conceal=0
-    syn off | syn on
-    setlocal conceallevel=2
-    AssertEqual synconcealed(1, 1)[0], 0
-    AssertEqual synconcealed(1, 2)[0], 0
-    AssertEqual synconcealed(1, 3)[0], 0
-    AssertEqual synconcealed(1, 4)[0], 0
-    AssertEqual synconcealed(1, 5)[0], 0
-    AssertEqual synconcealed(1, 6)[0], 0
-    AssertEqual synconcealed(1, 7)[0], 0
-
-    let g:vim_markdown_conceal=1
-    syn off | syn on
-    AssertEqual synconcealed(1, 1)[0], 1
-    AssertEqual synconcealed(1, 2)[0], 1
-    AssertEqual synconcealed(1, 3)[0], 1
-    AssertEqual synconcealed(1, 4)[0], 0
-    AssertEqual synconcealed(1, 5)[0], 1
-    AssertEqual synconcealed(1, 6)[0], 1
-    AssertEqual synconcealed(1, 7)[0], 1
-
-    setlocal conceallevel=0
-    unlet g:vim_markdown_conceal
-    syn off | syn on
-  endif
-
-Given markdown;
-***a***
-
-Execute (conceal italic bold):
-  if has('conceal')
-    setlocal conceallevel=2
-    AssertEqual synconcealed(1, 1)[0], 1
-    AssertEqual synconcealed(1, 2)[0], 1
-    AssertEqual synconcealed(1, 3)[0], 1
-    AssertEqual synconcealed(1, 4)[0], 0
-    AssertEqual synconcealed(1, 5)[0], 1
-    AssertEqual synconcealed(1, 6)[0], 1
-    AssertEqual synconcealed(1, 7)[0], 1
-    setlocal conceallevel=0
-  endif
-
-Execute (disable conceal):
-  if has('conceal')
-    let g:vim_markdown_conceal=0
-    syn off | syn on
-    setlocal conceallevel=2
-    AssertEqual synconcealed(1, 1)[0], 0
-    AssertEqual synconcealed(1, 2)[0], 0
-    AssertEqual synconcealed(1, 3)[0], 0
-    AssertEqual synconcealed(1, 4)[0], 0
-    AssertEqual synconcealed(1, 5)[0], 0
-    AssertEqual synconcealed(1, 6)[0], 0
-    AssertEqual synconcealed(1, 7)[0], 0
-
-    let g:vim_markdown_conceal=1
-    syn off | syn on
-    AssertEqual synconcealed(1, 1)[0], 1
-    AssertEqual synconcealed(1, 2)[0], 1
-    AssertEqual synconcealed(1, 3)[0], 1
-    AssertEqual synconcealed(1, 4)[0], 0
-    AssertEqual synconcealed(1, 5)[0], 1
-    AssertEqual synconcealed(1, 6)[0], 1
-    AssertEqual synconcealed(1, 7)[0], 1
-
-    setlocal conceallevel=0
-    unlet g:vim_markdown_conceal
-    syn off | syn on
-  endif
-
-# Links
-
-Given markdown;
-[a](b)
-
-Execute (link with title):
-  AssertEqual SyntaxOf('a'), 'mkdLink'
-  AssertEqual SyntaxOf('b'), 'mkdURL'
-
-Given markdown;
-[a
-b](c)
-
-Execute (link text with newline):
-  AssertEqual SyntaxOf('a'), 'mkdLink'
-  AssertEqual SyntaxOf('b'), 'mkdLink'
-  AssertEqual SyntaxOf('c'), 'mkdURL'
-
-Given markdown;
-[a] b [c](d)
-
-Execute (link text with bracket sections):
-  AssertNotEqual SyntaxOf('a'), 'mkdLink'
-  AssertNotEqual SyntaxOf('b'), 'mkdLink'
-  AssertEqual SyntaxOf('c'), 'mkdLink'
-  AssertEqual SyntaxOf('d'), 'mkdURL'
-
-Given markdown;
-[^a]: b
-
-Execute (footnote is not link):
-  AssertNotEqual SyntaxOf('a'), 'mkdLinkDef'
-
-Given markdown;
-(a)
-
-(b)
-
-Execute (parenthesis not in link):
-  AssertNotEqual SyntaxOf('a'), 'mkdURL'
-  AssertNotEqual SyntaxOf('b'), 'mkdURL'
-
-Given markdown;
-[a](b) c [d](e)
-
-Execute (multiple links on a line):
-  AssertNotEqual SyntaxOf('c'), 'mkdLink'
-  AssertNotEqual SyntaxOf('c'), 'mkdURL'
-
-Given markdown;
-[a] (b)
-
-Execute (space is not allowed between link text and parenthesis):
-  AssertNotEqual SyntaxOf('a'), 'mkdLink'
-  AssertNotEqual SyntaxOf('b'), 'mkdURL'
-
-Given markdown;
-[a](b)
-
-Execute (conceal link):
-  if has('conceal')
-    setlocal conceallevel=2
-    AssertEqual synconcealed(1, 1)[0], 1
-    AssertEqual synconcealed(1, 2)[0], 0
-    AssertEqual synconcealed(1, 3)[0], 1
-    AssertEqual synconcealed(1, 4)[0], 1
-    AssertEqual synconcealed(1, 4)[0], 1
-    AssertEqual synconcealed(1, 5)[0], 1
-    AssertEqual synconcealed(1, 6)[0], 1
-    setlocal conceallevel=0
-  endif
-
-Execute (disable conceal):
-  if has('conceal')
-    let g:vim_markdown_conceal=0
-    syn off | syn on
-    setlocal conceallevel=2
-    AssertEqual synconcealed(1, 1)[0], 0
-    AssertEqual synconcealed(1, 2)[0], 0
-    AssertEqual synconcealed(1, 3)[0], 0
-    AssertEqual synconcealed(1, 4)[0], 0
-    AssertEqual synconcealed(1, 4)[0], 0
-    AssertEqual synconcealed(1, 5)[0], 0
-    AssertEqual synconcealed(1, 6)[0], 0
-
-    let g:vim_markdown_conceal=1
-    syn off | syn on
-    AssertEqual synconcealed(1, 1)[0], 1
-    AssertEqual synconcealed(1, 2)[0], 0
-    AssertEqual synconcealed(1, 3)[0], 1
-    AssertEqual synconcealed(1, 4)[0], 1
-    AssertEqual synconcealed(1, 4)[0], 1
-    AssertEqual synconcealed(1, 5)[0], 1
-    AssertEqual synconcealed(1, 6)[0], 1
-
-    setlocal conceallevel=0
-    unlet g:vim_markdown_conceal
-    syn off | syn on
-  endif
-
-# Autolinks
-
-Given markdown;
-a <http://b> c
-
-Execute (autolink):
-  AssertNotEqual SyntaxOf('a'), 'mkdInlineURL'
-  AssertEqual SyntaxOf('<'), 'mkdDelimiter'
-  AssertEqual SyntaxOf('b'), 'mkdInlineURL'
-  AssertEqual SyntaxOf('>'), 'mkdDelimiter'
-  AssertNotEqual SyntaxOf('c'), 'mkdInlineURL'
-
-Given markdown;
-http://12monkeys.foo
-
-Execute (autolink with domain starting with a number):
-  AssertEqual SyntaxOf('12monkeys'), 'mkdInlineURL'
-
-Given markdown;
-<HtTp://a>
-
-Execute (autolink with scheme case is insensitive):
-  AssertEqual SyntaxOf('a'), 'mkdInlineURL'
-
-Given markdown;
-<a>
-
-Execute (autolink without scheme is not a link):
-  AssertNotEqual SyntaxOf('a'), 'mkdInlineURL'
-
-Given markdown;
-< http://a >
-<http://b c>
-<http://d
-e>
-
-Execute (autolink with space is not a link):
-  AssertNotEqual SyntaxOf('a'), 'mkdInlineURL'
-  AssertNotEqual SyntaxOf('b'), 'mkdInlineURL'
-  AssertNotEqual SyntaxOf('c'), 'mkdInlineURL'
-  AssertNotEqual SyntaxOf('d'), 'mkdInlineURL'
-  AssertNotEqual SyntaxOf('e'), 'mkdInlineURL'
-
-Given markdown;
-\<http://a>
-
-Execute (autolinks can be backslash escaped):
-  AssertNotEqual SyntaxOf('<'), 'mkdDelimiter'
-
-Given markdown;
-a (http://b.bb) c
-
-Execute (autolink in parenthesis):
-  AssertNotEqual SyntaxOf('a'), 'mkdInlineURL'
-  AssertEqual SyntaxOf('('), 'mkdDelimiter'
-  AssertEqual SyntaxOf('b'), 'mkdInlineURL'
-  AssertEqual SyntaxOf(')'), 'mkdDelimiter'
-  AssertNotEqual SyntaxOf('c'), 'mkdInlineURL'
-
-Given markdown;
-[![a](http://b)](http://c)
-
-Execute (autolink in link text):
-  AssertEqual SyntaxOf('!'), 'mkdDelimiter'
-  AssertEqual SyntaxOf('a'), 'mkdLink'
-  AssertEqual SyntaxOf('b'), 'mkdURL'
-  AssertEqual SyntaxOf('c'), 'mkdURL'
-
-Given markdown;
-# [h1link](url)
-
-## [h2link](url)
-
-### [h3link](url)
-
-#### [h4link](url)
-
-##### [h5link](url)
-
-###### [h6link](url)
-
-[h1link_b](url)
-===============
-
-[h2link_b](url)
----------------
-
-Execute (link in headers):
-  AssertEqual SyntaxOf('h1link'), 'mkdLink'
-  AssertEqual SyntaxOf('h2link'), 'mkdLink'
-  AssertEqual SyntaxOf('h3link'), 'mkdLink'
-  AssertEqual SyntaxOf('h4link'), 'mkdLink'
-  AssertEqual SyntaxOf('h5link'), 'mkdLink'
-  AssertEqual SyntaxOf('h6link'), 'mkdLink'
-  AssertEqual SyntaxOf('h1link_b'), 'mkdLink'
-  AssertEqual SyntaxOf('h2link_b'), 'mkdLink'
-
-Given markdown;
-# http://h1link.foo
-
-## http://h2link.foo
-
-### http://h3link.foo
-
-#### http://h4link.foo
-
-##### http://h5link.foo
-
-###### http://h6link.foo
-
-http://h1link_b.foo
-===================
-
-http://h2link_b.foo
--------------------
-
-Execute (inline url in headers):
-  AssertEqual SyntaxOf('h1link'), 'mkdInlineURL'
-  AssertEqual SyntaxOf('h2link'), 'mkdInlineURL'
-  AssertEqual SyntaxOf('h3link'), 'mkdInlineURL'
-  AssertEqual SyntaxOf('h4link'), 'mkdInlineURL'
-  AssertEqual SyntaxOf('h5link'), 'mkdInlineURL'
-  AssertEqual SyntaxOf('h6link'), 'mkdInlineURL'
-  AssertEqual SyntaxOf('h1link_b'), 'mkdInlineURL'
-  AssertEqual SyntaxOf('h2link_b'), 'mkdInlineURL'
-
-Given markdown;
-> [a](b)
-> http://foo.bar
-
-Execute (link in blockquote):
-  AssertEqual SyntaxOf('a'), 'mkdLink'
-  AssertEqual SyntaxOf('foo'), 'mkdInlineURL'
-
-Given markdown;
-[https://domain.tld](https://domain.com) not_a_link
-
-Execute (link with url title):
-  AssertEqual SyntaxOf('https://domain.tld'), 'mkdInlineURL'
-  AssertNotEqual SyntaxOf(']'), 'mkdInlineURL'
-  AssertEqual SyntaxOf('https://domain.com'), 'mkdURL'
-  AssertNotEqual SyntaxOf('not_a_link'), 'mkdInlineURL'
-
-# Code Blocks
-
-Given markdown;
-~~~
-code
-~~~
-
-Execute (code blocks can be fenced with tildes):
-  AssertEqual SyntaxOf('c'), 'mkdCode'
-
-Given markdown;
-~~~~
-code
-~~~~~
-
-Execute (code blocks can be fenced with tildes longer than 3):
-  AssertEqual SyntaxOf('c'), 'mkdCode'
-
-Given markdown;
-````
-code
-`````
-
-Execute (code blocks can be fenced with backticks longer than 3):
-  AssertEqual SyntaxOf('c'), 'mkdCode'
-
-Given markdown;
-~~~ruby
-code
-~~~
-
-Execute (code blocks can have a language specifier):
-  AssertEqual SyntaxOf('c'), 'mkdCode'
-
-Given markdown;
-```c++
-code
-```
-
-text
-
-Execute (code blocks can be fenced with backticks and a language specifier):
-  AssertEqual SyntaxOf('code'), 'mkdCode'
-  AssertNotEqual SyntaxOf('text'), 'mkdCode'
-
-# Indent Code Blocks
-
-Given markdown;
-a
-
-    b
-    c
-
-Execute (indent code blocks):
-  AssertNotEqual SyntaxOf('a'), 'mkdCode'
-  AssertEqual SyntaxOf('b'), 'mkdCode'
-  AssertEqual SyntaxOf('c'), 'mkdCode'
-
-Given markdown;
-# a
-
-b
-
-    c
-
-Execute (indent code blocks after header):
-  AssertNotEqual SyntaxOf('a'), 'mkdCode'
-  AssertNotEqual SyntaxOf('b'), 'mkdCode'
-  AssertEqual SyntaxOf('c'), 'mkdCode'
-
-Given markdown;
--   a
-
-    b
-
-        c
-
-Execute (indent code blocks after list):
-  AssertNotEqual SyntaxOf('a'), 'mkdCode'
-  AssertNotEqual SyntaxOf('b'), 'mkdCode'
-  AssertEqual SyntaxOf('c'), 'mkdCode'
-
-Given markdown;
-    a
-    b
-
-Execute (indent code block at beginning of file):
-  AssertEqual SyntaxOf('a'), 'mkdCode'
-  AssertEqual SyntaxOf('b'), 'mkdCode'
-
-Given markdown;
-```c++
-#include <iostream>
-code
-```
-
-```ruby
-def a
-end
-```
-
-Execute (fenced code block syntax with a language specifier):
-  let b:func = Markdown_GetFunc('vim-markdown/ftplugin/markdown.vim', 'MarkdownRefreshSyntax')
-  call b:func(0)
-  AssertEqual SyntaxOf('include'), 'cInclude'
-  AssertEqual SyntaxOf('code'), 'mkdSnippetCPP'
-  AssertEqual SyntaxOf('def'), 'rubyDefine'
-
-Given markdown;
-``` c++
-#include <iostream>
-code
-```
-
-```  vim
-let g:a = 1
-```
-
-```	ruby
-def a
-end
-```
-
-```
-ruby
-class B
-end
-```
-
-Execute (fenced code block syntax with a language specifier after whitespace):
-  let b:func = Markdown_GetFunc('vim-markdown/ftplugin/markdown.vim', 'MarkdownRefreshSyntax')
-  call b:func(0)
-  AssertEqual SyntaxOf('include'), 'cInclude'
-  AssertEqual SyntaxOf('code'), 'mkdSnippetCPP'
-  AssertEqual SyntaxOf('g:a'), 'vimVar'
-  AssertEqual SyntaxOf('def'), 'rubyDefine'
-  AssertNotEqual SyntaxOf('class'), 'rubyClass'
-
-Given markdown;
-```vim
-let g:a = 1
-```
-
-```viml
-let g:b = 1
-```
-
-Execute (fenced code block syntax with alias language specifier):
-  let b:func = Markdown_GetFunc('vim-markdown/ftplugin/markdown.vim', 'MarkdownRefreshSyntax')
-  call b:func(0)
-  AssertEqual SyntaxOf('g:a'), 'vimVar'
-  AssertEqual SyntaxOf('g:b'), 'vimVar'
-
-Given markdown;
-```csharp
-var s = "foo";
-```
-
-Execute (fenced code block languages setting):
-  let g:vim_markdown_fenced_languages = ['csharp=cs']
-  source ../ftplugin/markdown.vim
-  let b:func = Markdown_GetFunc('vim-markdown/ftplugin/markdown.vim', 'MarkdownRefreshSyntax')
-  call b:func(0)
-  AssertEqual SyntaxOf('foo'), 'csString'
-  unlet g:vim_markdown_fenced_languages
-
-Given markdown;
-```vim
-let g:a = 1
-```
-
-Execute (fenced code block includes language syntax with reopening same buffer):
-  let b:func = Markdown_GetFunc('vim-markdown/ftplugin/markdown.vim', 'MarkdownRefreshSyntax')
-  call b:func(0)
-  split
-  quit
-  edit
-  set filetype=markdown
-  execute "normal! i```vim\<cr>let g:a = 1\<cr>```"
-  call b:func(1)
-  AssertEqual SyntaxOf('g:a'), 'vimVar'
-
-Given markdown;
-```a+b-
-code
-```
-
-Execute (fenced code block syntax with an unknown language specifier):
-  let b:func = Markdown_GetFunc('vim-markdown/ftplugin/markdown.vim', 'MarkdownRefreshSyntax')
-  call b:func(0)
-  AssertEqual SyntaxOf('code'), 'mkdSnippetA_B_'
-
-Given markdown;
-```
-=
-a
--
-```
-
-Execute (first = or - in fenced code block is not setex headers):
-  AssertEqual SyntaxOf('='), 'mkdCode'
-  AssertEqual SyntaxOf('-'), 'mkdCode'
-
-Given markdown;
-``` {style=""}
-a
-```
-
-Execute (fenced code block with extended info strings):
-  AssertEqual SyntaxOf('a'), 'mkdCode'
-
-# Code Blocks in pre and code tag
-
-Given markdown;
-<pre>
-a
-</pre>
-
-Execute (code block in pre tag):
-  AssertEqual SyntaxOf('a'), 'mkdCode'
-
-Given markdown;
-<code>
-a
-</code>
-
-Execute (code block in code tag):
-  AssertEqual SyntaxOf('a'), 'mkdCode'
-
-Given markdown;
-\<pre\>
-a
-\</pre\>
-
-Execute (not code block in escaped pre tag):
-  AssertNotEqual SyntaxOf('a'), 'mkdCode'
-
-Given markdown;
-\<code\>
-a
-\</code\>
-
-Execute (not code block in escaped code tag):
-  AssertNotEqual SyntaxOf('a'), 'mkdCode'
-
-# Code quotes
-
-Given markdown;
-`a`
-
-Execute (code in code quotes):
-  AssertEqual SyntaxOf('a'), 'mkdCode'
-
-Given markdown;
-`a\` b `c\` d
-
-Execute (code quotes not escaped ending with backslash):
-  AssertEqual SyntaxOf('a\'), 'mkdCode'
-  AssertNotEqual SyntaxOf('b'), 'mkdCode'
-  AssertEqual SyntaxOf('c\'), 'mkdCode'
-  AssertNotEqual SyntaxOf('d'), 'mkdCode'
-
-Given markdown;
-``a\`` b ``c`\`1`` d
-
-Execute (double code quotes not escaped ending with backslash):
-  AssertEqual SyntaxOf('a\'), 'mkdCode'
-  AssertNotEqual SyntaxOf('b'), 'mkdCode'
-  AssertEqual SyntaxOf('c`\\`1'), 'mkdCode'
-  AssertNotEqual SyntaxOf('d'), 'mkdCode'
-
-# Math
-
-Given markdown;
-a $x$ b
-c $$y$$ d
-\$e\$
-\$\$f\$\$
-
-Execute (math):
-  AssertNotEqual SyntaxOf('x')[0:2], 'tex'
-  AssertNotEqual SyntaxOf('y')[0:2], 'tex'
-  let g:vim_markdown_math=1
-  syn off | syn on
-  AssertNotEqual SyntaxOf('a')[0:2], 'tex'
-  AssertNotEqual SyntaxOf('b')[0:2], 'tex'
-  AssertNotEqual SyntaxOf('c')[0:2], 'tex'
-  AssertNotEqual SyntaxOf('d')[0:2], 'tex'
-  AssertNotEqual SyntaxOf('e')[0:2], 'tex'
-  AssertNotEqual SyntaxOf('f')[0:2], 'tex'
-  AssertEqual SyntaxOf('x')[0:2], 'tex'
-  AssertEqual SyntaxOf('y')[0:2], 'tex'
-  let g:vim_markdown_math=0
-  syn off | syn on
-  AssertNotEqual SyntaxOf('x')[0:2], 'tex'
-  AssertNotEqual SyntaxOf('y')[0:2], 'tex'
-
-Given markdown;
-a
-
-$
-b
-$
-
-c
-
-Execute (multiline math):
-  let g:vim_markdown_math=1
-  syn off | syn on
-  AssertNotEqual SyntaxOf('a')[0:2], 'tex'
-  AssertEqual SyntaxOf('b')[0:2], 'tex'
-  AssertNotEqual SyntaxOf('c')[0:2], 'tex'
-
-Given markdown;
-$ \sqrt{a}{b} $
-$$ \frac{a}{b} $$
-
-Execute (math tex highlighting):
-  let g:vim_markdown_math=0
-  syn off | syn on
-  AssertNotEqual SyntaxOf('sqrt'), 'texStatement'
-  AssertNotEqual SyntaxOf('frac'), 'texStatement'
-  let g:vim_markdown_math=1
-  syn off | syn on
-  AssertEqual SyntaxOf('sqrt'), 'texStatement'
-  AssertEqual SyntaxOf('frac'), 'texStatement'
-
-Given markdown;
-$a b[$ c
-
-Execute (math ends with $):
-  let g:vim_markdown_math=1
-  syn off | syn on
-  AssertEqual SyntaxOf('a')[0:2], 'tex'
-  AssertEqual SyntaxOf('b')[0:2], 'tex'
-  AssertNotEqual SyntaxOf('c')[0:2], 'tex'
-
-Given markdown;
-$$a b[$$ c
-
-Execute (math ends with $$):
-  let g:vim_markdown_math=1
-  syn off | syn on
-  AssertEqual SyntaxOf('a')[0:2], 'tex'
-  AssertEqual SyntaxOf('b')[0:2], 'tex'
-  AssertNotEqual SyntaxOf('c')[0:2], 'tex'
-
-Given markdown;
-$(0 \le 1)$
-
-Execute (math conceal in $):
-  if has('conceal')
-    setlocal conceallevel=2
-    let g:vim_markdown_math=1
-    syn off | syn on
-    AssertEqual synconcealed(1, 1)[0], 1, '$'
-    AssertEqual synconcealed(1, 2)[0], 0
-    AssertEqual synconcealed(1, 3)[0], 0
-    AssertEqual synconcealed(1, 4)[0], 0
-    AssertEqual synconcealed(1, 5)[0], 1, '\le'
-    AssertEqual synconcealed(1, 6)[0], 1
-    AssertEqual synconcealed(1, 7)[0], 1
-    AssertEqual synconcealed(1, 8)[0], 0
-    AssertEqual synconcealed(1, 9)[0], 0
-    AssertEqual synconcealed(1, 10)[0], 0
-    AssertEqual synconcealed(1, 11)[0], 1, '$'
-    setlocal conceallevel=0
-  endif
-
-Given markdown;
-$$
-\omega
-0 \le 1
-$$
-
-Execute (math conceal in $$):
-  if has('conceal')
-    setlocal conceallevel=2
-    let g:vim_markdown_math=1
-    syn off | syn on
-    AssertEqual synconcealed(1, 1)[0], 1, '$$'
-    AssertEqual synconcealed(2, 1)[0], 1, '\omega'
-    AssertEqual synconcealed(3, 1)[0], 0, '0'
-    AssertEqual synconcealed(3, 3)[0], 1, '\le'
-    AssertEqual synconcealed(3, 7)[0], 0, '1'
-    AssertEqual synconcealed(4, 1)[0], 1, '$$'
-    setlocal conceallevel=0
-  endif
-
-# YAML frontmatter
-
-Given markdown;
----
-a: b
----
-
-Execute (YAML frontmatter is controlled by the option):
-  AssertNotEqual SyntaxOf('a')[0:3], 'yaml'
-  let g:vim_markdown_frontmatter=1
-  syn off | syn on
-  AssertEqual SyntaxOf('a')[0:3], 'yaml'
-  let g:vim_markdown_frontmatter=0
-  syn off | syn on
-  AssertNotEqual SyntaxOf('a')[0:3], 'yaml'
-
-Given markdown;
-
----
-a: b
----
-
-Execute (YAML frontmatter only works if it's the first thing in the file):
-  let g:vim_markdown_frontmatter=1
-  syn off | syn on
-  AssertNotEqual SyntaxOf('a')[0:3], 'yaml'
-
-Given markdown;
----
-a: b
----
-
----
-
-Execute (rules are not mistaken by YAML frontmatter delimiters):
-  let g:vim_markdown_frontmatter=1
-  syn off | syn on
-  AssertEqual SyntaxAt(5, 1), 'mkdRule'
-  unlet g:vim_markdown_frontmatter
-
-# TOML frontmatter
-
-Given markdown;
-+++
-a = "b"
-+++
-
-Execute (TOML frontmatter is controlled by the option):
-  syn off | syn on
-  AssertNotEqual SyntaxOf('b'), 'tomlString'
-  let g:vim_markdown_toml_frontmatter=1
-  syn off | syn on
-  AssertEqual SyntaxOf('b'), 'tomlString'
-  let g:vim_markdown_toml_frontmatter=0
-  syn off | syn on
-  AssertNotEqual SyntaxOf('b'), 'tomlString'
-
-Given markdown;
-
-+++
-a = "b"
-+++
-
-Execute (TOML frontmatter only works if it's the first thing in the file):
-  let g:vim_markdown_toml_frontmatter=1
-  syn off | syn on
-  AssertNotEqual SyntaxOf('b'), 'tomlString'
-  unlet g:vim_markdown_toml_frontmatter
-
-# JSON frontmatter
-
-Given markdown;
-{
-  "a": "b"
-}
-
-Execute (JSON frontmatter is controlled by the option):
-  syn off | syn on
-  AssertNotEqual SyntaxOf('a'), 'jsonKeyword'
-  let g:vim_markdown_json_frontmatter=1
-  syn off | syn on
-  AssertEqual SyntaxOf('a'), 'jsonKeyword'
-  let g:vim_markdown_json_frontmatter=0
-  syn off | syn on
-  AssertNotEqual SyntaxOf('a'), 'jsonKeyword'
-
-Given markdown;
-
-{
-  "a": "b"
-}
-
-Execute (JSON frontmatter only works if it's the first thing in the file):
-  let g:vim_markdown_json_frontmatter=1
-  syn off | syn on
-  AssertNotEqual SyntaxOf('a'), 'jsonKeyword'
-  unlet g:vim_markdown_json_frontmatter
-
-# Header
-
-Given markdown;
-# #a
-ccc
-
-## #b
-ddd
-
-Execute (header title starts with #):
-  AssertEqual SyntaxOf('a'), 'htmlH1'
-  AssertEqual SyntaxOf('b'), 'htmlH2'
-
-Given markdown;
-# h1 space
-
-#h1 nospace
-
-#  h1 2 spaces
-
-# h1 trailing hash #
-
-## h2 space
-
-##h2 nospace
-
-## h2 trailing hash ##
-
-### h3 space
-
-###h3 nospace
-
-### h3 trailing hash ###
-
-#### h4
-
-##### h5
-
-###### h6
-
-Execute (atx headers):
-  AssertEqual SyntaxOf(' h1 space'), 'htmlH1'
-  AssertEqual SyntaxOf('h1 nospace'), 'htmlH1'
-  AssertEqual SyntaxOf('  h1 2 spaces'), 'htmlH1'
-  AssertEqual SyntaxOf(' h1 trailing hash '), 'htmlH1'
-  AssertEqual SyntaxOf(' h2 space'), 'htmlH2'
-  AssertEqual SyntaxOf('h2 nospace'), 'htmlH2'
-  AssertEqual SyntaxOf(' h2 trailing hash '), 'htmlH2'
-  AssertEqual SyntaxOf(' h3 space'), 'htmlH3'
-  AssertEqual SyntaxOf('h3 nospace'), 'htmlH3'
-  AssertEqual SyntaxOf(' h3 trailing hash '), 'htmlH3'
-  AssertEqual SyntaxOf(' h4'), 'htmlH4'
-  AssertEqual SyntaxOf(' h5'), 'htmlH5'
-  AssertEqual SyntaxOf(' h6'), 'htmlH6'
-
-Given markdown;
-# h1 before h2
-
-## h2 between h1s
-
-# h1 after h2
-
-Execute (atx headers relative positions):
-  AssertEqual SyntaxOf(' h1 before h2'), 'htmlH1'
-  AssertEqual SyntaxOf(' h2 between h1s'), 'htmlH2'
-  AssertEqual SyntaxOf(' h1 after h2'), 'htmlH1'
-
-Given markdown;
-setex h1
-========
-
-setex h2
---------
-
-setex h1 single punctuation
-=
-
-setex h1 punctuation longer than header
-================================
-
-Execute (setex headers):
-  AssertEqual SyntaxOf('setex h1'), 'htmlH1'
-  AssertEqual SyntaxOf('^========$'), 'htmlH1'
-  AssertEqual SyntaxOf('setex h2'), 'htmlH2'
-  AssertEqual SyntaxOf('--------'), 'htmlH2'
-  AssertEqual SyntaxOf('setex h1 single punctuation'), 'htmlH1'
-  AssertEqual SyntaxOf('^=$'), 'htmlH1'
-  AssertEqual SyntaxOf('setex h1 punctuation longer than header'), 'htmlH1'
-  AssertEqual SyntaxOf('^================================$'), 'htmlH1'
-
-Given markdown;
-- not Setex
-- because list
-
-Execute (prevent list vs Setex confusion):
-  AssertNotEqual SyntaxOf('- not Setex'), 'htmlH2'
-  AssertNotEqual SyntaxOf('- becuase list'), 'htmlH2'
-
-Given markdown;
-setex h1 before atx
-===================
-
-## atx h2
-
-### atx h3
-
-# atx h1
-
-setex h2
-------------------
-
-### atx h3 2
-
-Execute (mixed atx and setex headers):
-  AssertEqual SyntaxOf('setex h1 before atx'), 'htmlH1'
-  AssertEqual SyntaxOf('==================='), 'htmlH1'
-  AssertEqual SyntaxOf(' atx h2'), 'htmlH2'
-  AssertEqual SyntaxOf(' atx h3'), 'htmlH3'
-  AssertEqual SyntaxOf(' atx h1'), 'htmlH1'
-  AssertEqual SyntaxOf('setex h2'), 'htmlH2'
-  AssertEqual SyntaxOf('------------------'), 'htmlH2'
-
-# List
-
-Given markdown;
-- a & b
-1. c > d
-
-Execute (& and > are not marked as htmlError in lists):
-  AssertEqual SyntaxOf('-'), 'mkdListItem'
-  AssertEqual SyntaxOf('1.'), 'mkdListItem'
-  AssertNotEqual SyntaxOf('&'), 'htmlError'
-  AssertNotEqual SyntaxOf('>'), 'htmlError'
-
-Given markdown;
-1. a  
-2. b
-
-Execute (list after line break):
-  AssertEqual SyntaxOf('1'), 'mkdListItem'
-  AssertEqual SyntaxOf('2'), 'mkdListItem'
-
-# HTML
-
-Given markdown;
-a
-
-<p>b</p>
-
-- <span>c</span>
-
-Execute (HTML tag in text):
-  AssertEqual SyntaxOf('p'), 'htmlTagName'
-  AssertEqual SyntaxOf('<p>'), 'htmlTag'
-  AssertEqual SyntaxOf('</p>'), 'htmlEndTag'
-  AssertEqual SyntaxOf('span'), 'htmlTagName'
-  AssertEqual SyntaxOf('<span>'), 'htmlTag'
-  AssertEqual SyntaxOf('</span>'), 'htmlEndTag'
diff --git a/sources_non_forked/vim-markdown/test/table-format.vader b/sources_non_forked/vim-markdown/test/table-format.vader
deleted file mode 100644
index 2fc06a3..0000000
--- a/sources_non_forked/vim-markdown/test/table-format.vader
+++ /dev/null
@@ -1,44 +0,0 @@
-Before:
-  let &gdefault = 1
-
-After:
-  let &gdefault = 0
-
-Given markdown;
-| normal |no space|  2 spaces  ||
-| - |-|  --- ||
-| normal |no space|  2 spaces  ||
-
-Execute (format unformatted table):
-  TableFormat
-
-Expect (table is formatted):
-  | normal | no space | 2 spaces |  |
-  |--------|----------|----------|--|
-  | normal | no space | 2 spaces |  |
-
-Given markdown;
-| a | b |
-|---|---|
-| c | d |
-
-Execute (format well formatted table):
-  TableFormat
-
-Expect (table is not modified):
-  | a | b |
-  |---|---|
-  | c | d |
-
-Given markdown;
-| left |right|  center  ||
-| :- | --: |:---:|:|
-| left |right|  center  ||
-
-Execute (format table with colons):
-  TableFormat
-
-Expect (preserve colons to align text):
-  | left | right | center |   |
-  |:-----|------:|:------:|:--|
-  | left | right | center |   |
diff --git a/sources_non_forked/vim-markdown/test/toc-autofit.vader b/sources_non_forked/vim-markdown/test/toc-autofit.vader
deleted file mode 100644
index 2678997..0000000
--- a/sources_non_forked/vim-markdown/test/toc-autofit.vader
+++ /dev/null
@@ -1,53 +0,0 @@
-" Tests toc window auto-fit to longest header, but without exceeding half screen.
-
-Given markdown;
-# chap 1
-
-# chap 2
-
-# chap 3
-
-# chap 4
-
-# chap 5
-
-# chap 6
-
-# chap 7
-
-# chap 8
-
-# chap 9
-
-# chap 10
-
-# chap 11
-
-# chap 12
-
-## chap 12.1
-
-### chap 12.1.1
-
-#### chap 12.1.1.1
-
-##### chap 12.1.1.1.1
-
-###### chap 12.1.1.1.1.1
-
-# chap 13
-
-Execute (toc window autofit width):
-  set number
-  let g:vim_markdown_toc_autofit = 1
-  let line = '###### chap 12.1.1.1.1.1'
-  AssertEqual getline('33'), line
-  :Toc
-  let real_width = winwidth(0)
-  :lclose
-  let expected_width = len(line) + 2*5 + 1 + 3 - 7
-  AssertEqual real_width, expected_width
-  set nonumber
-" 2 spaces * 5 additional header levels + 1 space for first header +
-" 3 spaces for line numbers - 7 chars ('###### ') that don't show up on the TOC
-
diff --git a/sources_non_forked/vim-markdown/test/toc.vader b/sources_non_forked/vim-markdown/test/toc.vader
deleted file mode 100644
index 5126952..0000000
--- a/sources_non_forked/vim-markdown/test/toc.vader
+++ /dev/null
@@ -1,181 +0,0 @@
-Given markdown;
-# a
-
-Execute (Toc does not set nomodifiable on other files):
-  " Sanity check.
-  Assert &modifiable
-
-  :Toc
-  :lclose
-  :edit a
-
-  Assert &modifiable
-
-Given markdown;
-header 1
-========
-
-test
-
-header 2
---------
-
-test
-
-### header 3
-
-test
-
-Execute (Toc setex headers):
-  :Toc
-
-Expect (setex headers):
-  header 1
-    header 2
-      header 3
-
-Given markdown;
-# header 1
-
-test
-
-## header 2
-
-test
-
-### header 3
-
-test
-
-Execute (Toc atx headers):
-  :Toc
-
-Expect (atx headers):
-  header 1
-    header 2
-      header 3
-
-Given markdown;
-ATX tests.
-
-# h1 space
-
-#h1 nospace
-
-#  h1 2 spaces
-
-# h1 trailing hash #
-
-## h2 space
-
-##h2 nospace
-
-## h2 trailing hash ##
-
-### h3 space
-
-###h3 nospace
-
-### h3 trailing hash ###
-
-#### h4
-
-##### h5
-
-###### h6
-
----
-
-Relative positions.
-
-# h1 before h2
-
-## h2 between h1s
-
-# h1 after h2
-
----
-
-Setex tests.
-
-setex h1
-========
-
-setex h2
---------
-
-setex h1 single punctuation
-=
-
-setex h1 punctuation longer than header
-================================
-
-Prevent list vs Setex confusion:
-
-- not Setex
-- because list
-
----
-
-Mixed tests.
-
-setex h1 before atx
-===================
-
-## atx h2
-
-### atx h3
-
-# atx h1
-
-setex h2
-------------------
-
-### atx h3 2
-
-Execute (Toc multiple headers):
-  :Toc
-
-Expect (multiple headers):
-  h1 space
-  h1 nospace
-  h1 2 spaces
-  h1 trailing hash
-    h2 space
-    h2 nospace
-    h2 trailing hash
-      h3 space
-      h3 nospace
-      h3 trailing hash
-        h4
-          h5
-            h6
-  h1 before h2
-    h2 between h1s
-  h1 after h2
-  setex h1
-    setex h2
-  setex h1 single punctuation
-  setex h1 punctuation longer than header
-  setex h1 before atx
-    atx h2
-      atx h3
-  atx h1
-    setex h2
-      atx h3 2
-
-Execute:
-  :lclose
-
-Given markdown;
-# header 1
-
-## header 2
-
-### header 3
-
-Execute (Toc cursor on the current header):
-  normal! G
-  :Toc
-  AssertEqual line('.'), 3
-  :lclose
diff --git a/sources_non_forked/vim-markdown/test/vimrc b/sources_non_forked/vim-markdown/test/vimrc
deleted file mode 100644
index 638ab3f..0000000
--- a/sources_non_forked/vim-markdown/test/vimrc
+++ /dev/null
@@ -1,29 +0,0 @@
-set nocompatible
-set rtp+=../
-set rtp+=../build/tabular/
-set rtp+=../build/vim-toml/
-set rtp+=../build/vim-json/
-set rtp+=../build/vader.vim/
-set rtp-=~/.vim
-set rtp-=~/.vim/after
-let $LANG='en_US'
-filetype on
-filetype plugin on
-filetype indent on
-syntax on
-
-function! Markdown_GetScriptID(fname) abort
-    let l:snlist = ''
-    redir => l:snlist
-    silent! scriptnames
-    redir END
-    let l:mx = '^\s*\(\d\+\):\s*\(.*\)$'
-    for l:line in split(l:snlist, "\n")
-        if stridx(substitute(l:line, '\\', '/', 'g'), a:fname) >= 0
-            return substitute(l:line, l:mx, '\1', '')
-        endif
-    endfor
-endfunction
-function! Markdown_GetFunc(fname, funcname) abort
-    return function('<SNR>' . Markdown_GetScriptID(a:fname) . '_' . a:funcname)
-endfunction
diff --git a/sources_non_forked/vim-multiple-cursors/README.md b/sources_non_forked/vim-multiple-cursors/README.md
index 7abe3f3..fd473b0 100644
--- a/sources_non_forked/vim-multiple-cursors/README.md
+++ b/sources_non_forked/vim-multiple-cursors/README.md
@@ -1,3 +1,5 @@
+# ** This plugin is deprecated, use [vim-visual-multi](https://github.com/mg979/vim-visual-multi) instead **
+
 # vim-multiple-cursors
 [![Build Status](https://travis-ci.org/terryma/vim-multiple-cursors.svg?branch=master)](https://travis-ci.org/github/terryma/vim-multiple-cursors)
 
diff --git a/sources_non_forked/vim-repeat/.github/FUNDING.yml b/sources_non_forked/vim-repeat/.github/FUNDING.yml
deleted file mode 100644
index e2a49d1..0000000
--- a/sources_non_forked/vim-repeat/.github/FUNDING.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-github: tpope
-custom: ["https://www.paypal.me/vimpope"]
diff --git a/sources_non_forked/vim-repeat/README.markdown b/sources_non_forked/vim-repeat/README.markdown
deleted file mode 100644
index 448d2d6..0000000
--- a/sources_non_forked/vim-repeat/README.markdown
+++ /dev/null
@@ -1,48 +0,0 @@
-# repeat.vim
-
-If you've ever tried using the `.` command after a plugin map, you were
-likely disappointed to discover it only repeated the last native command
-inside that map, rather than the map as a whole.  That disappointment
-ends today.  Repeat.vim remaps `.` in a way that plugins can tap into
-it.
-
-The following plugins support repeat.vim:
-
-* [surround.vim](https://github.com/tpope/vim-surround)
-* [speeddating.vim](https://github.com/tpope/vim-speeddating)
-* [unimpaired.vim](https://github.com/tpope/vim-unimpaired)
-* [vim-easyclip](https://github.com/svermeulen/vim-easyclip)
-* [vim-radical](https://github.com/glts/vim-radical)
-
-Adding support to a plugin is generally as simple as the following
-command at the end of your map functions.
-
-    silent! call repeat#set("\<Plug>MyWonderfulMap", v:count)
-
-## Installation
-
-Install using your favorite package manager, or use Vim's built-in package
-support:
-
-    mkdir -p ~/.vim/pack/tpope/start
-    cd ~/.vim/pack/tpope/start
-    git clone https://tpope.io/vim/repeat.git
-
-## Contributing
-
-See the contribution guidelines for
-[pathogen.vim](https://github.com/tpope/vim-pathogen#readme).
-
-## Self-Promotion
-
-Like repeat.vim? Follow the repository on
-[GitHub](https://github.com/tpope/vim-repeat) and vote for it on
-[vim.org](http://www.vim.org/scripts/script.php?script_id=2136).  And if
-you're feeling especially charitable, follow [tpope](http://tpo.pe/) on
-[Twitter](http://twitter.com/tpope) and
-[GitHub](https://github.com/tpope).
-
-## License
-
-Copyright (c) Tim Pope.  Distributed under the same terms as Vim itself.
-See `:help license`.
diff --git a/sources_non_forked/vim-repeat/autoload/repeat.vim b/sources_non_forked/vim-repeat/autoload/repeat.vim
deleted file mode 100644
index 708c318..0000000
--- a/sources_non_forked/vim-repeat/autoload/repeat.vim
+++ /dev/null
@@ -1,165 +0,0 @@
-" repeat.vim - Let the repeat command repeat plugin maps
-" Maintainer:   Tim Pope
-" Version:      1.2
-" GetLatestVimScripts: 2136 1 :AutoInstall: repeat.vim
-
-" Installation:
-" Place in either ~/.vim/plugin/repeat.vim (to load at start up) or
-" ~/.vim/autoload/repeat.vim (to load automatically as needed).
-"
-" License:
-" Copyright (c) Tim Pope.  Distributed under the same terms as Vim itself.
-" See :help license
-"
-" Developers:
-" Basic usage is as follows:
-"
-"   silent! call repeat#set("\<Plug>MappingToRepeatCommand",3)
-"
-" The first argument is the mapping that will be invoked when the |.| key is
-" pressed.  Typically, it will be the same as the mapping the user invoked.
-" This sequence will be stuffed into the input queue literally.  Thus you must
-" encode special keys by prefixing them with a backslash inside double quotes.
-"
-" The second argument is the default count.  This is the number that will be
-" prefixed to the mapping if no explicit numeric argument was given.  The
-" value of the v:count variable is usually correct and it will be used if the
-" second parameter is omitted.  If your mapping doesn't accept a numeric
-" argument and you never want to receive one, pass a value of -1.
-"
-" Make sure to call the repeat#set function _after_ making changes to the
-" file.
-"
-" For mappings that use a register and want the same register used on
-" repetition, use:
-"
-"   silent! call repeat#setreg("\<Plug>MappingToRepeatCommand", v:register)
-"
-" This function can (and probably needs to be) called before making changes to
-" the file (as those typically clear v:register).  Therefore, the call sequence
-" in your mapping will look like this:
-"
-"   nnoremap <silent> <Plug>MyMap
-"   \   :<C-U>execute 'silent! call repeat#setreg("\<lt>Plug>MyMap", v:register)'<Bar>
-"   \   call <SID>MyFunction(v:register, ...)<Bar>
-"   \   silent! call repeat#set("\<lt>Plug>MyMap")<CR>
-
-if exists("g:loaded_repeat") || &cp || v:version < 700
-    finish
-endif
-let g:loaded_repeat = 1
-
-let g:repeat_tick = -1
-let g:repeat_reg = ['', '']
-
-" Special function to avoid spurious repeats in a related, naturally repeating
-" mapping when your repeatable mapping doesn't increase b:changedtick.
-function! repeat#invalidate()
-    autocmd! repeat_custom_motion
-    let g:repeat_tick = -1
-endfunction
-
-function! repeat#set(sequence,...)
-    let g:repeat_sequence = a:sequence
-    let g:repeat_count = a:0 ? a:1 : v:count
-    let g:repeat_tick = b:changedtick
-    augroup repeat_custom_motion
-        autocmd!
-        autocmd CursorMoved <buffer> let g:repeat_tick = b:changedtick | autocmd! repeat_custom_motion
-    augroup END
-endfunction
-
-function! repeat#setreg(sequence,register)
-    let g:repeat_reg = [a:sequence, a:register]
-endfunction
-
-
-function! s:default_register()
-    let values = split(&clipboard, ',')
-    if index(values, 'unnamedplus') != -1
-        return '+'
-    elseif index(values, 'unnamed') != -1
-        return '*'
-    else
-        return '"'
-    endif
-endfunction
-
-function! repeat#run(count)
-    try
-        if g:repeat_tick == b:changedtick
-            let r = ''
-            if g:repeat_reg[0] ==# g:repeat_sequence && !empty(g:repeat_reg[1])
-                " Take the original register, unless another (non-default, we
-                " unfortunately cannot detect no vs. a given default register)
-                " register has been supplied to the repeat command (as an
-                " explicit override).
-                let regname = v:register ==# s:default_register() ? g:repeat_reg[1] : v:register
-                if regname ==# '='
-                    " This causes a re-evaluation of the expression on repeat, which
-                    " is what we want.
-                    let r = '"=' . getreg('=', 1) . "\<CR>"
-                else
-                    let r = '"' . regname
-                endif
-            endif
-
-            let c = g:repeat_count
-            let s = g:repeat_sequence
-            let cnt = c == -1 ? "" : (a:count ? a:count : (c ? c : ''))
-            if ((v:version == 703 && has('patch100')) || (v:version == 704 && !has('patch601')))
-                exe 'norm ' . r . cnt . s
-            elseif v:version <= 703
-                call feedkeys(r . cnt, 'n')
-                call feedkeys(s, '')
-            else
-                call feedkeys(s, 'i')
-                call feedkeys(r . cnt, 'ni')
-            endif
-        else
-            if ((v:version == 703 && has('patch100')) || (v:version == 704 && !has('patch601')))
-                exe 'norm! '.(a:count ? a:count : '') . '.'
-            else
-                call feedkeys((a:count ? a:count : '') . '.', 'ni')
-            endif
-        endif
-    catch /^Vim(normal):/
-        return 'echoerr v:errmsg'
-    endtry
-    return ''
-endfunction
-
-function! repeat#wrap(command,count)
-    let preserve = (g:repeat_tick == b:changedtick)
-    call feedkeys((a:count ? a:count : '').a:command, 'n')
-    exe (&foldopen =~# 'undo\|all' ? 'norm! zv' : '')
-    if preserve
-        let g:repeat_tick = b:changedtick
-    endif
-endfunction
-
-nnoremap <silent> <Plug>(RepeatDot)      :<C-U>exe repeat#run(v:count)<CR>
-nnoremap <silent> <Plug>(RepeatUndo)     :<C-U>call repeat#wrap('u',v:count)<CR>
-nnoremap <silent> <Plug>(RepeatUndoLine) :<C-U>call repeat#wrap('U',v:count)<CR>
-nnoremap <silent> <Plug>(RepeatRedo)     :<C-U>call repeat#wrap("\<Lt>C-R>",v:count)<CR>
-
-if !hasmapto('<Plug>(RepeatDot)', 'n')
-    nmap . <Plug>(RepeatDot)
-endif
-if !hasmapto('<Plug>(RepeatUndo)', 'n')
-    nmap u <Plug>(RepeatUndo)
-endif
-if maparg('U','n') ==# '' && !hasmapto('<Plug>(RepeatUndoLine)', 'n')
-    nmap U <Plug>(RepeatUndoLine)
-endif
-if !hasmapto('<Plug>(RepeatRedo)', 'n')
-    nmap <C-R> <Plug>(RepeatRedo)
-endif
-
-augroup repeatPlugin
-    autocmd!
-    autocmd BufLeave,BufWritePre,BufReadPre * let g:repeat_tick = (g:repeat_tick == b:changedtick || g:repeat_tick == 0) ? 0 : -1
-    autocmd BufEnter,BufWritePost * if g:repeat_tick == 0|let g:repeat_tick = b:changedtick|endif
-augroup END
-
-" vim:set ft=vim et sw=4 sts=4:
diff --git a/sources_non_forked/vim-ruby/.gitignore b/sources_non_forked/vim-ruby/.gitignore
deleted file mode 100644
index 926ccaa..0000000
--- a/sources_non_forked/vim-ruby/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-doc/tags
diff --git a/sources_non_forked/vim-ruby/.rspec b/sources_non_forked/vim-ruby/.rspec
deleted file mode 100644
index 4e1e0d2..0000000
--- a/sources_non_forked/vim-ruby/.rspec
+++ /dev/null
@@ -1 +0,0 @@
---color
diff --git a/sources_non_forked/vim-ruby/CONTRIBUTORS b/sources_non_forked/vim-ruby/CONTRIBUTORS
deleted file mode 100644
index 732f0cf..0000000
--- a/sources_non_forked/vim-ruby/CONTRIBUTORS
+++ /dev/null
@@ -1,19 +0,0 @@
-Maintainers:
-	Mark Guzman <segfault@hasno.info>
-	Doug Kearns <dougkearns@gmail.com>
-	Tim Pope <vim@NOSPAMtpope.org>
-	Andrew Radev <andrey.radev@gmail.com>
-	Nikolai Weibull <now@bitwi.se>
-
-Other contributors:
-	Michael Brailsford <brailsmt@yahoo.com>
-	Sean Flanagan <sdflanagan@ozemail.com.au>
-	Tim Hammerquist <timh@rubyforge.org>
-	Ken Miller <ken.miller@gmail.com>
-	Hugh Sasse <hgs@dmu.ac.uk>
-	Tilman Sauerbeck <tilman@code-monkey.de>
-	Bertram Scharpf <info@bertram-scharpf.de>
-	Gavin Sinclair <gsinclair@gmail.com>
-	Aaron Son <aaronson@uiuc.edu>
-	Ned Konz <ned@bike-nomad.com>
-	Pan Thomakos <pan.thomakos@gmail.com>
diff --git a/sources_non_forked/vim-ruby/ChangeLog b/sources_non_forked/vim-ruby/ChangeLog
deleted file mode 100644
index 65b659f..0000000
--- a/sources_non_forked/vim-ruby/ChangeLog
+++ /dev/null
@@ -1,1579 +0,0 @@
-This file is no longer maintained.  Consult the Git log for newer changes.
-
-2009-09-27  Mark Guzman  <segfault@hasno.info>
-
-	* autoload/rubycomplete.vim: pplying a patch from Yoshimasa Niwa resolving
-	a possible runaway CPU issue when matching context regexes
-
-2008-08-11  Doug Kearns  <dougkearns@gmail.com>
-
-	* ftdetect/ruby.vim: match irbrc as a Ruby filetype
-
-2008-07-15  Doug Kearns  <dougkearns@gmail.com>
-
-	* FAQ, README, etc/website/index.html: update the references to
-	RubyGarden's VimRubySupport page
-
-2008-07-08  Doug Kearns  <dougkearns@gmail.com>
-
-	* NEWS: begin updating for the pending release
-
-2008-06-29  Mark Guzman  <segfault@hasno.info>
-
-	* autoload/rubycomplete.vim: resolve a typo in the configuration initialization
-	section
-
-2008-06-29  Tim Pope  <vim@tpope.info>
-
-	* syntax/ruby.vim: revert highlighting of - as number
-
-2008-06-29  Tim Pope  <vim@tpope.info>
-
-	* indent/eruby.vim: fix quirk in optional argument handling
-
-2008-06-29  Tim Pope  <vim@tpope.info>
-
-	* syntax/ruby.vim: don't match $_foo as an invalid variable
-
-2008-04-25  Tim Pope  <vim@tpope.info>
-
-	* ftplugin/eruby.vim, syntax/eruby.vim: guard against recursion
-
-2008-04-21  Tim Pope  <vim@tpope.info>
-
-	* indent/eruby.vim: don't let ruby indent %> lines
-	* indent/ruby.vim: hack around <%= and <%- from eruby
-
-2008-04-20  Tim Pope  <vim@tpope.info>
-
-	* syntax/ruby.vim: don't highlight x /= y as regexp
-
-2008-02-17  Tim Pope  <vim@tpope.info>
-
-	* indent/ruby.vim: Copy previous string indent inside strings
-
-2008-02-13  Tim Pope  <vim@tpope.info>
-
-	* syntax/ruby.vim: keepend on // regexps and add \/ escape
-
-2008-02-01  Mark Guzman  <segfault@hasno.info>
-
-	* autoload/rubycomplete.vim: switch vim variable checking to a more
-	rubyish method
-
-2008-01-31  Tim Pope  <vim@tpope.info>
-
-	* indent/eruby.vim: setlocal, not set indentexpr
-
-2008-01-28  Tim Pope  <vim@tpope.info>
-
-	* syntax/ruby.vim: better heuristic for regexps as method arguments
-
-2008-01-25  Tim Pope  <vim@tpope.info>
-
-	* syntax/ruby.vim: highlight several regexp constructs
-
-2008-01-21  Tim Pope  <vim@tpope.info>
-
-	* indent/eruby.vim: per Bram's advice, use 'W' searchpair flag
-
-2008-01-21  Tim Pope  <vim@tpope.info>
-
-	* indent/eruby.vim: indent { and } like do and end
-
-2007-12-17  Tim Pope  <vim@tpope.info>
-
-	* indent/eruby.vim: treat <%- like <%
-
-2007-10-01  Tim Pope  <vim@tpope.info>
-
-	* syntax/ruby.vim: removed some false positives (e.g., include?, nil?)
-
-2007-09-14  Tim Pope  <vim@tpope.info>
-
-	* compiler/rspec.vim: new compiler plugin for rspec
-
-2007-09-06  Tim Pope  <vim@tpope.info>
-
-	* syntax/eruby.vim: remove Vim 5.x specific sections
-	* syntax/ruby.vim: highlight negative sign in numbers
-
-2007-08-07  Tim Pope  <vim@tpope.info>
-
-	* indent/ruby.vim: fix while/until/for match in skip regexp
-
-2007-07-30  Tim Pope  <vim@tpope.info>
-
-	* syntax/ruby.vim: highlight undef like def
-
-2007-07-16  Tim Pope  <vim@tpope.info>
-
-	* indent/ruby.vim: prevent symbols like :for from indenting
-
-2007-07-14  Tim Pope  <vim@tpope.info>
-
-	* syntax/eruby.vim: fixed ALLBUT clauses to refer to right group
-
-2007-06-22  Tim Pope  <vim@tpope.info>
-
-	* syntax/ruby.vim: include operator highlighting in class/module
-	declarations (for ::)
-
-2007-06-04  Tim Pope  <vim@tpope.info>
-
-	* syntax/ruby.vim: fixed %s() highlighting
-
-2007-05-26  Tim Pope  <vim@tpope.info>
-
-	* syntax/ruby.vim: added rubyBlockParameter to @rubyNoTop
-
-2007-05-25  Tim Pope  <vim@tpope.info>
-
-	* indent/ruby.vim: removed string delimiters from string matches
-
-2007-05-25  Tim Pope  <vim@tpope.info>
-
-	* syntax/ruby.vim: cleaned up string highlighting
-	* indent/ruby.vim: lines starting with strings are no longer ignored
-
-2007-05-22  Tim Pope  <vim@tpope.info>
-
-	* syntax/ruby.vim: made module declaration match mirror class
-	declaration match
-	* ftdetect/ruby.vim: added .irbrc
-
-2007-05-16  Tim Pope  <vim@tpope.info>
-
-	* syntax/ruby.vim: revert from using TOP to ALLBUT
-
-2007-05-15  Tim Pope  <vim@tpope.info>
-
-	* syntax/eruby.vim: handle %%> properly
-
-2007-05-14  Tim Pope  <vim@tpope.info>
-
-	* syntax/ruby.vim: fixed problem highlighting [foo[:bar]]
-	* syntax/ruby.vim: don't highlight = in {:foo=>"bar"}
-
-2007-05-11  Tim Pope  <vim@tpope.info>
-
-	* indent/eruby.vim: GetRubyIndent() takes an argument for debugging
-	* doc/ft-ruby-syntax.txt: clean up some cruft
-
-2007-05-09  Tim Pope  <vim@tpope.info>
-
-	* syntax/ruby.vim: added module_function keyword
-
-2007-05-06  Tim Pope  <vim@tpope.info>
-
-	* doc/ft-ruby-syntax.txt: bring into sync with upstream
-	* ftdetect/ruby.vim: Rails extensions
-
-2007-05-06  Tim Pope  <vim@tpope.info>
-
-	* NEWS: update documentation for next release
-	* syntax/eruby.vim: allow for nesting (foo.erb.erb)
-	* syntax/ruby.vim: removed : from rubyOptionalDoLine (falsely matches
-	on symbols, and the syntax is deprecated anyways)
-
-2007-05-06  Tim Pope  <vim@tpope.info>
-
-	* ftplugin/ruby.vim: maps for [[, ]], [], ][, [m, ]m, [M, ]M
-
-2007-05-06  Tim Pope  <vim@tpope.info>
-
-	* ftplugin/eruby.vim, syntax/eruby.vim: added a default subtype option
-
-2007-05-06  Tim Pope  <vim@tpope.info>
-
-	* syntax/ruby.vim: Highlight punctuation variables in string
-	interpolation, and flag invalid ones as errors
-
-2007-05-05  Tim Pope  <vim@tpope.info>
-
-	* syntax/ruby.vim: eliminated some false positves for here docs,
-	symbols, ASCII codes, and conditionals as statement modifiers
-	* syntax/ruby.vim: added "neus" to regexp flags
-
-2007-04-24  Tim Pope  <vim@tpope.info>
-
-	* ftplugin/eruby.vim, syntax/eruby.vim: fixed typo in subtype
-	detection
-
-2007-04-20  Tim Pope  <vim@tpope.info>
-
-	* ftplugin/eruby.vim, syntax/eruby.vim: refined subtype detection
-
-2007-04-17  Tim Pope  <vim@tpope.info>
-
-	* syntax/ruby.vim: highlight %s() as a symbol, not a string
-	* ftplugin/eruby.vim: determine and use eruby subtype
-
-2007-04-16  Tim Pope  <vim@tpope.info>
-
-	* ftplugin/ruby.vim: add *.erb to the browse filter
-	* indent/eruby.vim: use 'indentexpr' from subtype
-
-2007-04-16  Tim Pope  <vim@tpope.info>
-
-	* ftdetect/ruby.vim: detect *.erb as eruby
-	* syntax/eruby.vim: determine subtype by inspecting filename
-
-2007-04-03  Doug Kearns  <dougkearns@gmail.com>
-
-	* syntax/ruby.vim: allow text to appear after, and on the same line,
-	as '=begin' in rubyDocumentation regions
-
-2007-03-31  Doug Kearns  <dougkearns@gmail.com>
-
-	* ftplugin/ruby.vim: add break, redo, next, and retry to b:match_words
-
-2007-03-28  Doug Kearns  <dougkearns@gmail.com>
-
-	* syntax/ruby.vim: add matchgroup to rubyArrayLiteral so that
-	contained square brackets do not match in the start/end patterns
-
-2007-03-28  Doug Kearns  <dougkearns@gmail.com>
-
-	* syntax/ruby.vim: don't match [!=?] as part of a sigil prefixed
-	symbol name
-
-2007-03-28  Doug Kearns  <dougkearns@gmail.com>
-
-	* syntax/ruby.vim: rename the rubyNoDoBlock, rubyCaseBlock,
-	rubyConditionalBlock, and rubyOptionalDoBlock syntax groups to
-	rubyBlockExpression, rubyCaseExpression, rubyConditionalExpression,
-	and rubyRepeatExpression respectively
-
-2007-03-28  Doug Kearns  <dougkearns@gmail.com>
-
-	* syntax/ruby.vim: remove accidentally included matchgroup from
-	rubyArrayLiteral
-
-2007-03-20  Doug Kearns  <dougkearns@gmail.com>
-
-	* indent/ruby.vim: ignore instance, class, and global variables named
-	"end" when looking to deindent the closing end token
-
-2007-03-20  Doug Kearns  <dougkearns@gmail.com>
-
-	* syntax/ruby.vim, syntax/eruby.vim: remove the Vim version 5
-	compatibility code
-
-2007-03-20  Doug Kearns  <dougkearns@gmail.com>
-
-	* syntax/ruby.vim: add rubyArrayLiteral syntax group for folding
-	multiline array literals
-
-2007-03-19  Doug Kearns  <dougkearns@gmail.com>
-
-	* syntax/ruby.vim: highlight the scope and range operators when
-	ruby_operators is set; simplify block parameter highlighting by adding
-	the rubyBlockParameterList syntax group
-
-2007-03-17  Doug Kearns  <dougkearns@gmail.com>
-
-	* syntax/ruby.vim: when ruby_operators is set don't match '>' in '=>';
-	fix some minor bugs in the highlighting of pseudo operators and
-	contain TOP in rubyBracketOperator
-
-2007-03-17  Doug Kearns  <dougkearns@gmail.com>
-
-	* syntax/ruby.vim: allow regexp literals to be highlighted after the
-	'else' keyword
-
-2007-03-09  Tim Pope  <vim@tpope.info>
-
-	* syntax/ruby.vim: Added OPTIMIZE alongside FIXME and TODO.  Mirrors
-	Edge Rails' new annotations extractor tasks.
-
-2007-03-09  Tim Pope  <vim@tpope.info>
-
-	* ftplugin/ruby.vim: Skip class= and for= with matchit (really belongs
-	in ftplugin/eruby.vim).
-
-2007-03-05  Doug Kearns  <dougkearns@gmail.com>
-
-	* ftplugin/ruby.vim: add sigil prefixed identifiers to b:match_skip
-
-2007-03-03  Doug Kearns  <dougkearns@gmail.com>
-
-	* ftplugin/ruby.vim: simplify the b:match_words pattern by making
-	better use of b:match_skip in concert with the previous syntax group
-	additions
-
-2007-03-03  Doug Kearns  <dougkearns@gmail.com>
-
-	* syntax/ruby.vim: add rubyConditionalModifier and rubyRepeatModifier
-	syntax groups for conditional and loop modifiers and match the
-	optional 'do' or ':' in looping statements with a new rubyOptionalDo
-	syntax group
-
-2007-03-02  Doug Kearns  <dougkearns@gmail.com>
-
-	* NEWS: fix typo
-
-2007-03-02  Doug Kearns  <dougkearns@gmail.com>
-
-	* NEWS: update documentation for next release
-
-2007-03-02  Tim Pope  <vim@tpope.info>
-
-	* syntax/ruby.vim: Cope with (nonsensical) inclusion of : in
-	iskeyword.
-
-2007-03-02  Tim Pope  <vim@tpope.info>
-
-	* NEWS: Documented changes to omnicompletion.
-
-2007-03-02  Doug Kearns  <dougkearns@gmail.com>
-
-	* ftplugin/ruby.vim: refine the conditional/loop expression vs
-	modifier matchit heuristic
-
-2007-03-01  Doug Kearns  <dougkearns@gmail.com>
-
-	* syntax/ruby.vim: refine the conditional/loop expression vs modifier
-	highlighting heuristic
-
-2007-02-28  Doug Kearns  <dougkearns@gmail.com>
-
-	* syntax/ruby.vim: highlight conditional and loop expressions properly
-	when used with the ternary operator and in blocks
-
-2007-02-28  Doug Kearns  <dougkearns@gmail.com>
-
-	* NEWS, CONTRIBUTORS: update documentation for next release
-
-2007-02-27  Tim Pope  <vim@tpope.info>
-
-	* ftplugin/ruby.vim: Provide 'balloonexpr'.
-
-2007-02-27  Doug Kearns  <dougkearns@gmail.com>
-
-	* syntax/ruby.vim: add rubyPredefinedVariable to short-form
-	rubyInterpolation's contains list
-
-2007-02-27  Doug Kearns  <dougkearns@gmail.com>
-
-	* syntax/ruby.vim: :retab! the file to save a few bytes
-
-2007-02-26  Tim Pope  <vim@tpope.info>
-
-	* syntax/ruby.vim: Limit then, else, elsif, and when to inside
-	conditional statements.
-
-2007-02-26  Doug Kearns  <dougkearns@gmail.com>
-
-	* syntax/ruby.vim: make sure 'class << self' is always highlighted
-
-2007-02-26  Doug Kearns  <dougkearns@gmail.com>
-
-	* syntax/ruby.vim: reorganise string interpolation syntax groups
-
-2007-02-26  Doug Kearns  <dougkearns@gmail.com>
-
-	* syntax/ruby.vim: highlight interpolation regions preceded by
-	multiple backslashes properly
-
-2007-02-26  Doug Kearns  <dougkearns@gmail.com>
-
-	* syntax/ruby.vim: highlight methods named "end" when the definition
-	is distributed over multiple lines (i.e. allow more "def end" madness)
-
-2007-02-25  Tim Pope  <vim@tpope.info>
-
-	* syntax/ruby.vim: Highlight predefined global variables in aliases.
-
-2007-02-25  Tim Pope  <vim@tpope.info>
-
-	* syntax/ruby.vim: Highlight symbols and global variables in aliases.
-	Highlight capitalized method names.
-
-2007-02-24  Tim Pope  <vim@tpope.info>
-
-	* ftplugin/ruby.vim: set keywordprg=ri
-
-	* syntax/ruby.vim: Allow for "def end" madness
-
-2007-02-24  Doug Kearns  <dougkearns@gmail.com>
-
-	* syntax/ruby.vim: allow escape sequences and interpolation inside
-	symbol 'names' specified with a string
-
-2007-02-24  Doug Kearns  <dougkearns@gmail.com>
-
-	* syntax/ruby.vim: highlight == and & 'operator' redefinitions
-	properly
-
-2007-02-23  Tim Pope  <vim@tpope.info>
-
-	* doc/ft-ruby-syntax.txt: Recommend hi link rubyIdentifier NONE over
-	ruby_no_identifiers.
-
-2007-02-23  Tim Pope  <vim@tpope.info>
-
-	* syntax/ruby.vim: Fixed method highlighting when not at the end of
-	the line.  Highlight aliases.  Account for \ before #{} interpolation.
-
-2007-02-23  Doug Kearns  <dougkearns@gmail.com>
-
-	* syntax/ruby.vim: make sure multi-line backslash escaped
-	interpolation regions are highlighted as rubyString
-
-2007-02-23  Doug Kearns  <dougkearns@gmail.com>
-
-	* syntax/ruby.vim: link the rubyLoop syntax group to the Repeat
-	highlight group
-
-2007-02-22  Tim Pope  <vim@tpope.info>
-
-	* indent/eruby.vim: Fixed an edge case.
-
-	* syntax/ruby.vim: Simpler method and class declaration highlighting.
-	Changed some contains=ALLBUT,... to contains=TOP.  Altered some
-	highlight links: rubyConstant is now Type; rubySymbol is now Constant.
-	New groups like rubyLoop and rubyCondition.
-
-2007-02-22  Doug Kearns  <dougkearns@gmail.com>
-
-	* syntax/ruby.vim: highlight short format interpolated variables
-
-2007-02-20  Tim Pope  <vim@tpope.info>
-
-	* syntax/ruby.vim: Place class/module declarations in a separate
-	group.  Allow self to be highlighted in a method declaration.
-
-2007-02-18  Tim Pope  <vim@tpope.info>
-
-	* syntax/ruby.vim: Separate Regexp group.  Nest Ruby code inside
-	string interpolation.  Restored highlighting of method, class, and
-	module declarations.
-
-2007-02-10  Doug Kearns  <dougkearns@gmail.com>
-
-	* ftplugin/ruby.vim: only reset 'ofu' if it exists and was set by the
-	ftplugin (for Vim 6 compatibility)
-
-2007-01-22  Tim Pope  <vim@tpope.info>
-
-	* ftplugin/ruby.vim: Limited path detection code to Windows, again.
-
-2006-12-13  Mark Guzman	<segfault@hasno.info>
-
-	* autoload/rubycomplete.vim: added support for lambda and '&' defined
-	procs.
-
-2006-12-07  Mark Guzman <segfault@hasno.info>
-
-	* ftplugin/ruby.vim: modified the path detection code use
-	the built-in interpreter if it's available in all cases.
-
-2006-12-04  Tim Pope  <vim@tpope.info>
-
-	* indent/eruby.vim: Special case for "end" on first line of multi-line
-	eRuby block.
-
-2006-12-03  Doug Kearns  <dougkearns@gmail.com>
-
-	* CONTRIBUTORS: add tpope
-
-2006-12-01  Mark Guzman <segfault@hasno.info>
-
-	* ftplugin/ruby.vim: changed the path detection code to use the
-	built-in interpreter if it's available under windows
-
-2006-11-30  Mark Guzman <segfault@hasno.info>
-
-	* autoload/rubycomplete.vim: Display constants as defines. Added a
-	rails preloading option. Fixed a bug detecting ranges defined with
-	%r{.  Added support for completion in rails migrations. Will now
-	fail-over to syntax completion automatically, if the vim isn't built
-	with ruby support. Added support for class detection using
-	ObjectSpace.  Tweeked buffer searching code to find modules/classes
-	reliably in more cases.
-
-2006-11-09  Tim Pope  <vim@tpope.info>
-
-	* indent/ruby.vim: Only increase one 'shiftwidth' after a line ending
-	with an open parenthesis.
-
-2006-11-08  Tim Pope  <vim@tpope.info>
-
-	* indent/eruby.vim: Rearranged keywords; new 'indentkeys'
-
-2006-11-08  Tim Pope  <vim@tpope.info>
-
-	* indent/eruby.vim: new indenting algorithm
-
-2006-11-08  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* syntax/ruby.vim: don't include trailing whitespace in matches for
-	'def', 'class', and 'module' keywords
-
-2006-10-28  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* syntax/ruby.vim: remove accidently included nextgroup arg in
-	'heredoc' syntax group definitions
-
-2006-10-24  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* syntax/eruby.vim: recognise '-' trim mode block delimiters (Nikolai
-	Weibull)
-
-2006-09-19  Mark Guzman  <segfault@hasno.info>
-
-	* autoload/rubycomplete.vim: improved rails view support. included
-	rails helpers in rails completions. kernel elements are also included
-	in default completions. improved the handling of "broken" code.
-
-2006-09-07  Mark Guzman  <segfault@hasno.info>
-
-	* autoload/rubycomplete.vim: autoload rubygems if possible. added
-	debugging print. clean up the buffer loading code a bit
-
-2006-08-21  Mark Guzman  <segfault@hasno.info>
-
-	* autoload/rubycomplete.vim: modified the buffer loading code to prevent
-	syntax errors from stopping completion
-
-2006-07-12  Mark Guzman  <segfault@hasno.info>
-
-	* autoload/rubycomplete.vim: added in-buffer method def handling. also
-	added an inital attempt at handling completion in a rails view
-
-2006-07-11  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* FAQ, INSTALL, NEWS, README, doc/ft-ruby-syntax.txt: update
-	documentation for next release
-
-	* ftplugin/ruby.vim: only set 'omnifunc' if Vim has been compiled with
-	the Ruby interface
-
-2006-07-10  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* syntax/ruby.vim: fold all multiline strings
-
-2006-06-19  Mark Guzman  <segfault@hasno.info>
-
-	* autoload/rubycomplete.vim: modified to change the default
-	buffer loading behavior. buffers are no longer loaded/parsed
-	automatically. enabling this feature requires setting the
-	variable g:rubycomplete_buffer_loading. this was done as
-	a security measure, the default vim7 install should not
-	execute any code.
-
-	* autoload/rubycomplete.vim: symbol completion now works. i
-	tested with global symbols as well as rails symbols.
-
-2006-05-26  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* ftplugin/ruby.vim: fix typo
-
-2006-05-25  Mark Guzman  <segfault@hasno.info>
-
-	* autoload/rubycomplete.vim: added rails column support.
-	switched to dictionary with type specifiers for methods,
-	classes, and variables. started/added rails 1.0 support.
-	added rails database connection support.
-
-2006-05-25  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* syntax/ruby.vim: use a region for the rubyMultiLineComment syntax
-	group instead of a multiline match pattern as it is faster; rename
-	rubyMultiLineComment to rubyMultilineComment
-
-2006-05-13  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* ftplugin/ruby.vim: test for '&omnifunc', rather than the Vim
-	version, before setting it; add omnifunc to b:undo_ftplugin
-
-2006-05-12  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* syntax/ruby.vim: match the pseudo operators such as '+=' when
-	ruby_operators is defined
-
-2006-05-11  Mark Guzman <segfault@hasno.info>
-
-	* autoload/rubycomplete.vim: added checks for the existance of
-	global config variables per dkearns' patch. refined error messages
-	to use vim error style
-
-2006-05-11  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* syntax/ruby.vim: make sure rubyDocumentation is highlighted even if
-	ruby_no_comment_fold is defined; improve rubyDocumentation match
-	patterns
-
-2006-05-09  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* syntax/ruby.vim: make folding of comments configurable via the
-	ruby_no_comment_fold variable
-
-	* syntax/ruby.vim: add rubyMultiLineComment syntax group to allow
-	folding of comment blocks
-
-2006-05-08  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* syntax/ruby.vim: simplify rubyNoDoBlock, rubyOptDoLine match
-	patterns
-
-	* syntax/ruby.vim: add initial support for highlighting 'operators'.
-	This is off by default and enabled by defining the ruby_operators
-	variable
-
-	* syntax/ruby.vim: if/unless immediately following a method name
-	should always be highlighted as modifiers and not the beginning of an
-	expression
-
-2006-05-07  Mark Guzman  <segfault@hasno.info>
-
-	* autoload/rubycomplete.vim: Switched to script local vars,
-	per patch from dkearns. removed secondary array clause. applied
-	patch provided by dkearns, fixes input handling.
-
-2006-05-07  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* autoload/rubycomplete.vim: set 'foldmethod' to marker in the
-	modeline
-
-2006-05-03  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* ftplugin/ruby.vim: add patterns for braces, brackets and parentheses
-	to b:match_words
-
-2006-05-01  Mark Guzman  <segfault@hasno.info>
-
-	* autoload/rubycomplete.vim: Added error trapping and messages
-	for class import errors
-
-2006-04-28  Mark Guzman  <segfault@hasno.info>
-
-	* autoload/rubycomplete.vim: started adding raw range support
-	1..2.<C-x><C-o>. fixed the symbol completion bug, where you
-	would end up with a double colon.
-
-2006-04-27  Mark Guzman  <segfault@hasno.info>
-
-	* autoload/rubycomplete.vim: added variable type detection for
-	Ranges. added handlers for string completion: "test".<C-x><C-o>
-
-2006-04-26  Mark Guzman  <segfault@hasno.info>
-
-	* autoload/rubycomplete.vim: removed cWORD expansion in favor of
-	grabbing the whole line. added support for completing variables
-	inside operations and parameter lists. removed excess cruft code.
-	removed commented code.
-
-	* autoload/rubycomplete.vim: fixed the truncation code. this fixes
-	f.chomp! <C-x><C-o> returning chomp! again, where it should provide
-	the global list. It also fixes f.foo( a.B, b.<C-x><C-o> returning a's
-	list when it should return b's.
-
-2006-04-26  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* autoload/rubycomplete.vim: set 'expandtab' properly
-
-2006-04-25  Mark Guzman  <segfault@hasno.info>
-
-	* autoload/rubycomplete.vim: started stripping out preceding
-	assigment operation stuff. "x = A", would attempt to complete
-	A using the global list. I've started removing old/commented
-	code in an effort to slim down the file.
-
-2006-04-25  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* autoload/rubycomplete.vim: remove excess whitespace
-
-	* indent/ruby.vim: make sure 'smartindent' is disabled
-
-2006-04-24  Mark Guzman  <segfault@hasno.info>
-
-	* autoload/rubycomplete.vim: fixed a completion bug where the entered
-	text was not taken to account. it will now be used to limit the entries
-	returned
-
-2006-04-24  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* Rakefile: add vim help files, the new FAQ and rubycomplete.vim to
-	the gemspec file list
-
-2006-04-22  Mark Guzman  <segfault@hasno.info>
-
-	* autoload/rubycomplete.vim: changed the rails load code to match the
-	console load, we're now pulling everything in. completion of class
-	members from within the class definition now works properly.
-
-2006-04-21  Mark Guzman  <segfault@hasno.info>
-
-	* autoload/rubycomplete.vim: renamed the vim global variable
-	controlling the addition of classes defined in the current buffer to
-	the global completion list
-
-	* autoload/rubycomplete.vim: the global variable list is now sorted
-	and dups are removed
-
-	* autoload/rubycomplete.vim: fixed a bug with rails support, where
-	rails standard methods would be added to a completion list when not
-	in a rails project
-
-	* doc/ft-ruby-omni.txt: added information about the classes in global
-	completion option
-
-2006-04-21  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* doc/ft-ruby-omni.txt: add highlighting to example setting of
-	g:rubycomplete_rails variable
-
-2006-04-21  Mark Guzman  <segfault@hasno.info>
-
-	* autoload/rubycomplete.vim: added support for adding classes defined
-	in the current buffer to the global completion list - when completing
-	with no text outside of a class definition
-
-2006-04-20  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* doc/ft-ruby-omni.txt: add new omni completion documentation
-
-	* doc/ft-ruby-syntax.txt, syntax/doc/ruby.txt: move syntax
-	documentation to ft-ruby-syntax.txt
-
-2006-04-20  Mark Guzman  <segfault@hasno.info>
-
-	* autoload/rubycomplete.vim: fixed a completion hang/crash when
-	completing symbols globally switched to smaller chunks being added to
-	the dictionary
-
-	* autoload/rubycomplete.vim: it will now complete rails classes
-
-	* autoload/rubycomplete.vim: removed left over debug prints
-
-2006-04-19  Mark Guzman  <segfault@hasno.info>
-
-	* autoload/rubycomplete.vim: in-buffer class completion seems to work
-	properly in my test cases added range variable detection - contributed
-
-2006-04-19  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* ftdetect/ruby.vim: add RJS and RXML template file detection
-
-2006-04-19  Gavin Sinclair  <gsinclair@gmail.com>
-
-	* CONTRIBUTORS, ftplugin/ruby.vim: update Gavin's email address
-
-2006-04-18  Mark Guzman  <segfault@hasno.info>
-
-	* autoload/rubycomplete.vim: revised the in-buffer class loading,
-	needs a little more work but its testable
-
-2006-04-17  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* CONTRIBUTORS, indent/ruby.vim: update Nikolai's email address
-
-2006-04-16  Mark Guzman  <segfault@hasno.info>
-
-	* autoload/rubycomplete.vim: added a work-around for the cWORD bug
-	found by dkearns; added support for completion of in-buffer classes;
-	switched return-type over to a dictionary
-
-2006-04-15  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* autoload/rubycomplete.vim: rename rbcomplete#Complete to match
-	script file name
-
-	* autoload/rubycomplete.vim, compiler/rubyunit.vim, ftdetect/ruby.vim,
-	ftplugin/ruby.vim, indent/ruby.vim, syntax/ruby.vim,
-	compiler/eruby.vim, compiler/ruby.vim, ftplugin/eruby.vim,
-	indent/eruby.vim, syntax/eruby.vim: add Release-Coordinator header
-	line and remove GPL license
-
-	* CONTRIBUTORS, bin/vim-ruby-install.rb: add Mark to the list of
-	maintainers; add rubycomplete.vim to the installer script's list of
-	files
-
-2006-04-14  Mark Guzman  <segfault@hasno.info>
-
-	* autoload/rubycomplete.vim, ftplugin/ruby.vim: added ruby
-	omni-completion files; modified the ftplugin to set the omnifunc
-
-2005-10-14  Gavin Sinclair <gsinclair@soyabean.com.au>
-
-	* indent/ruby.vim: Changed maintainer to Nikolai.
-
-2005-10-13  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* compiler/eruby.vim, compiler/rubyunit.vim, ftplugin/eruby.vim,
-	ftplugin/ruby.vim, indent/eruby.vim, indent/ruby.vim,
-	syntax/eruby.vim, syntax/ruby.vim: fix typo in URL header
-
-	* ftdetect/ruby.vim: add filetype detection for Rantfiles
-
-2005-10-07  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* NEWS: updated for new release
-
-	* syntax/doc/ruby.txt: update formatting for Vim 6.4 release
-
-2005-10-06  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* ftplugin/ruby.vim: prevent symbols from matching as matchit
-	match_words
-
-2005-10-05  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* NEWS: updated for new release
-
-	* bin/vim-ruby-install.rb: raise an exception if there are unknown
-	args passed to the script
-
-	* ftplugin/ruby.vim: add '.' to the head of 'path' so that files
-	relative to the directory of the current file are found first
-
-2005-10-04  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* syntax/ruby.vim: make the use of 'ruby_no_expensive' local to the
-	buffer for eruby files
-
-	* compiler/eruby.vim, compiler/rubyunit.vim, compiler/ruby.vim,
-	ftdetect/ruby.vim, ftplugin/eruby.vim, ftplugin/ruby.vim,
-	indent/eruby.vim, indent/ruby.vim, syntax/eruby.vim, syntax/ruby.vim:
-	replace spaces with tabs, where possible, to reduce file sizes as
-	requested by BM
-
-2005-09-30  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* ftplugin/ruby.vim: place Gems after the standard $LOAD_PATH in
-	'path'
-
-2005-09-27  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* ftplugin/ruby.vim: replace a single '.' with ',,' in all locations
-	in 'path'
-
-2005-09-26  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* ftplugin/ruby.vim: use print instead of puts to generate s:rubypath
-
-2005-09-25  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* syntax/ruby.vim: allow comments to be highlighted directly after
-	module/class/method definitions without intervening whitespace
-
-2005-09-24  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* syntax/ruby.vim: allow regexp's as hash values and after a ';'
-
-	* NEWS: updated for new release
-
-	* syntax/ruby.vim: fix typo in rubyControl highlight group name
-
-	* bin/vim-ruby-install.rb: add --backup option and include short
-	options for it and --windows; make sure the backup directory is
-	written to CWD
-
-2005-09-22  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* compiler/rubyunit.vim: improve compiler message output and behaviour
-	to match that of the GUI test runners
-
-	* syntax/ruby: allow while/until modifiers after methods with names
-	ending in [!=?]; assume (for now) that while/until expressions used as
-	args will be specified with parentheses
-
-2005-09-21  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* bin/vim-ruby-install.rb, indent/eruby.vim: add a new indent file for
-	eRuby; just use the html indent file for now
-
-	* compiler/eruby.vim: use the ruby compiler plugin 'efm' and add a
-	eruby_compiler config variable to allow for using eruby as the
-	'makeprg' rather than the default erb
-
-2005-09-20  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* syntax/ruby.vim: match and highlight exit! as a 'special' method
-
-2005-09-18  Nikolai Weibull  <source@pcppopper.org>
-
-	* indent/ruby.vim: Fix bug #2481
-
-2005-09-18  Nikolai Weibull  <source@pcppopper.org>
-
-	* indent/ruby.vim: Fix for #2473
-
-2005-09-18  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* bin/vim-ruby-install.rb: make sure that the latest vim-ruby, rather
-	than vim-ruby-devel, gem is being used
-
-2005-09-16  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* ftdetect/ruby.vim: use 'set filetype' rather than 'setfiletype' to
-	override any previously set filetype
-
-2005-09-15  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* syntax/ruby.vim: add $LOADED_FEATURES and $PROGRAM_NAME to
-	rubyPredefinedVariable
-
-	* NEWS: correct release number
-
-	* INSTALL: add a precautionary note about backing up files prior to
-	using the installer
-
-2005-09-14  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* Rakefile: add INSTALL and NEWS files to FileList
-
-	* INSTALL, NEWS: add INSTALL and NEWS files
-
-2005-09-13  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* syntax/eruby.vim: make sure escaped eRuby tags aren't highlighted as
-	block delimiters with a trailing '%'
-
-2005-09-11  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* CONTRIBUTORS: update pcp's email address
-
-	* indent/ruby.vim: reinsert license in header
-
-	* ftplugin/ruby.vim: include gems load path in 'path' option
-
-	* indent/ruby.vim: ignore the rescue 'modifier' when indenting (#2296)
-
-	* indent/ruby.vim: fix comment typo
-
-2005-09-10  Nikolai Weibull  <source@pcppopper.org>
-
-	* indent/ruby.vim: Fixes bugs introduced in earlier commits.  Been
-	running without fault for two-three weeks now.  It's about as good as
-	it gets without a major reworking.  Enjoy!
-
-2005-09-10  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* Rakefile: use GMT time in the version string
-
-	* compiler/rubyunit.vim: save each message from error backtraces
-
-	* README, etc/website/index.html: update the package naming
-	description
-
-	* Rakefile: set the package task's need_zip attribute so that zip
-	package archives are also created
-
-	* ftplugin/ruby.vim: remove 'multiline' patterns from b:match_words
-
-2005-09-09  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* syntax/ruby: allow if/unless/while/until expressions to be
-	highlighted when used as method args following a ','
-
-2005-09-08  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* syntax/ruby.vim: allow while/until expressions to be highlighted
-
-	* bin/vim-ruby-install.rb: rescue Win32::Registry::Error when
-	accessing the Windows registry
-
-	* ChangeLog, Rakefile, compiler/eruby.vim, compiler/rubyunit.vim,
-	compiler/ruby.vim, ftplugin/eruby.vim, indent/ruby.vim,
-	syntax/eruby.vim, syntax/ruby.vim: normalise vim modelines
-
-	* etc/release/release.sh: add -z to cvsrelease call to create a zip
-	release file as well as a tar.gz
-
-	* Rakefile: add CONTRIBUTORS file to FileList
-
-	* ftplugin/ruby.vim: escape \'s in b:match_skip pattern
-
-	* Rakefile: update filetype/ to ftdetect/ in FileList
-
-2005-09-07  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* ftplugin/ruby.vim: improve b:match_words pattern
-
-2005-09-06  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* syntax/ruby.vim: move hyphen to end of collection in rubyNoDoBlock
-	pattern
-
-2005-09-03  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* syntax/ruby.vim: allow if/unless expressions after the %, ^, | and &
-	operators
-
-2005-09-02  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* bin/vim-ruby-install.rb: add ftplugin/eruby.vim to list of source
-	files
-
-	* ftplugin/eruby.vim: add new eRuby ftplugin
-
-	* ftplugin/ruby.vim: merge most features from Ned Konz's ftplugin
-
-	* compiler/eruby.vim: match eruby specific error messages and parse
-	the error's column number when provided
-
-2005-09-01  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* bin/vim-ruby-install.rb, compiler/eruby.vim: add new eruby compiler
-	plugin
-
-	* syntax/eruby.vim, syntax/ruby.vim: split erubyBlock into erubyBlock
-	and erubyExpression; allow expressions inside blocks; set
-	ruby_no_expensive if highlighting eRuby; add spell checking and
-	rubyTodo to erubyComment
-
-	* syntax/eruby.vim: make sure that eRubyOneLiner starts at the
-	very beginning of a line
-
-	* syntax/eruby.vim: make sure that eRubyOneLiner cannot be extended
-	over multiple lines
-
-2005-08-30  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* syntax/ruby.vim: remove rubyIterator HiLink command line
-
-2005-08-27  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* bin/vim-ruby-install.rb: add Env.determine_home_dir using
-	%HOMEDRIVE%%HOMEPATH% as HOME on Windows if HOME is not explicitly set
-
-	* syntax/ruby.vim: fix regression in rubyOptDoBlock
-
-	* syntax/ruby.vim: fix typo in rubyBlockParameter pattern
-
-2005-08-26  Nikolai Weibull  <source@pcppopper.org>
-
-	* indent/ruby.vim: Updated to indent correctly.  There's more to be
-	done, as a statement may be contained in other stuff than a '... = ',
-	so that '=' should be [=+-...].  Soon to be fixed.
-
-2005-08-26  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* syntax/ruby.vim: only match rubyBlockParameter after 'do' that is a
-	'keyword'
-
-2005-08-25  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* syntax/ruby.vim: rename rubyIterator to rubyBlockParameter; ensure
-	it only highlights these after a 'do' or '{'; match parameters in
-	parentheses
-
-	* syntax/doc/ruby.txt: minor reorganisation of options
-
-	* bin/vim-ruby-install.rb: don't use $0 == __FILE__ idiom to start
-	installer file as this will fail when running as a gem as
-	vim-ruby-install.rb is loaded by the gem driver; make _same_contents
-	a private method; fix a bug in BackupDir.backup where it was writing
-	the backup to an incorrect location
-
-2005-08-24  Nikolai Weibull  <source@pcppopper.org>
-
-	* indent/ruby.vim:
-	1.  resetting of cpoptions (wouldn't always be done, depending on if
-	GetRubyIndent was defined.
-
-	2.  Bugs #166, #1914, #2296 should be fixed
-
-	3.  Somewhat simpler processing of the contents of the file.
-
-	Most of the work was removing complexity that was trying to be clever
-	about understanding the syntax/semantics of the file, while actually
-	making things slow and actually not matching correctly.
-
-2005-08-24  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* syntax/ruby.vim: remove 'contains=rubyString' from the
-	rubyInterpolation group until that is more comprehensively improved
-
-2005-08-18  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* syntax/ruby.vim: explicitly match block arguments so that &keyword
-	isn't highlighted as a 'keyword' prefixed with &
-
-	* syntax/ruby.vim: improve highlighting of heredocs used as method
-	arguments
-
-2005-08-17  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* syntax/ruby.vim: improve highlighting of the optional 'do' in
-	looping constructs
-
-	* syntax/ruby.vim: remove accidentally added 'keepend' from
-	rubyOptDoBlock
-
-	* syntax/ruby.vim: merge 'while|until' start patterns of
-	rubyOptDoBlock syntax group
-
-2005-08-16  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* bin/vim-ruby-install.rb: wrap 'main' in a begin/end block
-
-	* bin/vim-ruby-install.rb: add FIXME comment (Hugh Sasse)
-
-	* README, bin/vim-ruby-install.rb, etc/website/index.html: offer
-	$VIM/vimfiles and $HOME/{.vim,vimfiles} rather than $VIMRUNTIME as the
-	two default installation directories
-
-2005-08-15  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* syntax/ruby.vim: remove character offset 'hs' from the
-	rubyOptDoBlock start match
-
-	* syntax/ruby.vim: exclude leading whitespace from the rubyOptDoBlock
-	syntax group start patterns with \zs
-
-2005-08-11  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* CONTRIBUTORS, bin/vim-ruby-install.rb, syntax/eruby.vim: add syntax
-	highlighting for eRuby files
-
-	* ftdetect/ruby.vim: reorder autocommands for eRuby setf line
-
-2005-08-08  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* bin/vim-ruby-install.rb: add ftdetect/ruby.vim to list of source
-	files
-
-2005-08-07  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* filetype/ruby.vim, ftdetect/ruby.vim: move ruby.vim from filetype/
-	to ftdetect/
-
-	* filetype/filetype.vim, filetype/ruby.vim: move filetype.vim to
-	ruby.vim; add eRuby filetype detection
-
-2005-08-06  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* syntax/ruby.vim: match rubyConstant and rubyLocalVariableOrMethod
-	with a leading word boundary
-
-	* syntax/ruby.vim: move ruby_no_identifiers test to the default
-	highlighting block so that all identifiers are still matched when this
-	is config variable set
-
-	* syntax/ruby.vim: remove display argument from rubyConstant now that
-	the match is multiline
-
-2005-08-03  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* CONTRIBUTORS: add new file listing project contributors
-
-2005-08-02  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* syntax/ruby.vim: differentiate between constants and capitalized
-	class methods invoked with the scope operator '::'
-
-2005-08-01  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* syntax/ruby.vim: undo reordering of identifier matching and make $_
-	a special case to prevent it matching against global variables with a
-	leading underscore
-
-2005-07-30  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* syntax/ruby.vim: reorder identifier matching so that identifiers
-	'containing' predefined identifiers, such as $_, match properly
-
-2005-07-28  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* syntax/ruby.vim: improve matching of conditional expressions
-
-2005-07-27  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* Rakefile: add 'package' as the default target
-
-2005-07-26  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* syntax/ruby.vim: replace leading context 'lc' offsets with the
-	'\@<=' pattern construct when matching 'normal regular expressions'
-	(Aaron Son)
-
-2005-07-22  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* syntax/ruby.vim: allow strings inside interpolation regions
-
-2005-07-04  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* bin/vim-ruby-install.rb: improve source directory detection (Hugh
-	Sasse)
-
-2005-04-05  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* syntax/ruby.vim: match rubyNested*, and rubyDelimEscape as
-	transparent items; add closing escaped delimiters to rubyDelimEscape
-	syntax group
-
-2005-04-04  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* syntax/ruby.vim: highlight nested delimiters in generalized quotes
-	(Aaron Son, Bertram Scharpf and Ken Miller)
-
-2005-04-04  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* syntax/ruby.vim: minor improvement to block parameter highlighting
-
-2005-04-04  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* syntax/doc/ruby.txt: add documentation for the ruby_space_errors,
-	ruby_no_trail_space_error and ruby_no_tab_space_error configuration
-	variables
-
-2005-03-30  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* syntax/ruby.vim: add configurable highlighting of trailing space and
-	'space before tab' errors (Tilman Sauerbeck)
-
-2005-03-24  Gavin Sinclair <gsinclair@soyabean.com.au>
-
-	* syntax/ruby.vim: Improved hilighting of %{...} strings with
-	nested brackets (Ken Miller).
-	* indent/ruby.vim: Improved indenting of %{...} strings with
-	nested brackets (Ken Miller).
-	* syntax/ruby.vim: Corrected hilighting of |(x,y)| iterator
-	parameters (Tilman Sauerbeck).
-
-2004-11-27  Doug Kearns  <djkea2@gus.gscit.monash.edu.au>
-
-	* compiler/ruby.vim, compiler/rubyunit.vim, syntax/ruby.vim: update
-	DJK's email address
-
-2004-09-30  Doug Kearns  <djkea2@mugca.its.monash.edu.au>
-
-	* syntax/ruby.vim: match regexp values in hash literals
-
-2004-09-20  Gavin Sinclair <gsinclair@soyabean.com.au>
-
-	* bin/vim-ruby-install.rb: added
-	* Rakefile: 'rake package' generates TGZ and GEM
-	* install.rb: removed
-	* build.rb: removed
-
-2004-09-04  Doug Kearns  <djkea2@mugca.its.monash.edu.au>
-
-	* compiler/rubyunit.vim, compiler/ruby.vim: update to use new
-	CompilerSet command
-
-2004-05-19  Doug Kearns  <djkea2@mugca.its.monash.edu.au>
-
-	* compiler/rubyunit.vim: match assert messages
-
-2004-05-12  Doug Kearns  <djkea2@mugca.its.monash.edu.au>
-
-	* syntax/ruby.vim: check for the folding feature rather than just the
-	vim version when testing if the foldmethod should be set to syntax
-
-2004-05-11  Doug Kearns  <djkea2@mugca.its.monash.edu.au>
-
-	* compiler/rubyunit.vim: add initial support for parsing Test::Unit
-	errors
-
-2004-05-11  Doug Kearns  <djkea2@mugca.its.monash.edu.au>
-
-	* syntax/doc/ruby.txt: add documentation for the
-	ruby_no_special_methods and ruby_fold configuration variables
-
-2004-04-29  Doug Kearns  <djkea2@mugca.its.monash.edu.au>
-
-	* filetype/filetype.vim: move matching of [Rr]akefile* to a separate
-	section which is located later in the file to avoid incorrectly
-	matching other filetypes prefixed with [Rr]akefile
-
-2005-04-27  Doug Kearns  <djkea2@mugca.its.monash.edu.au>
-
-	* filetype/filetype.vim: match 'rakefile' as a Rakefile
-
-2004-04-23  Ward Wouts  <ward@wizeazz.nl>
-
-	* syntax/ruby.vim: add ruby_fold variable to control the setting of
-	the foldmethod option
-
-2004-04-06  Doug Kearns  <djkea2@mugca.its.monash.edu.au>
-
-	* filetype/filetype.vim: add RubyGems specification and installation
-	files and Rakefiles
-
-2004-04-01  Doug Kearns  <djkea2@mugca.its.monash.edu.au>
-
-	* compiler/rubyunit.vim: add a new compiler plugin for Test::Unit
-
-2004-03-23  Doug Kearns  <djkea2@mugca.its.monash.edu.au>
-
-	* etc/website/index.html, etc/website/djk-theme.css: add simple CSS
-	style sheet
-
-2004-02-08  Doug Kearns  <djkea2@mugca.its.monash.edu.au>
-
-	* etc/website/index.html: convert to valid HTML 4.01 Strict.
-
-2004-01-11  Gavin Sinclair <gsinclair@soyabean.com.au>
-
-	* ftplugin/ruby.vim: Added matchit instructions.
-
-2003-11-06  Doug Kearns  <djkea2@mugca.its.monash.edu.au>
-
-	* README: update DJK's current location.
-
-2003-11-06  Doug Kearns  <djkea2@mugca.its.monash.edu.au>
-
-	* syntax/ruby.vim: add support for the new decimal and octal base
-	indicators and capitalization of all base indicators.
-
-2003-10-20  Nikolai Weibull  <source@pcppopper.org>
-
-	* indent/ruby.vim: Added support for ?: multilining, such as
-	a ?
-	  b :
-	  c.
-
-2003-10-18  Nikolai Weibull  <source@pcppopper.org>
-
-	* indent/ruby.vim: Fixed a silly bug with the [] matching.
-
-2003-10-17  Gavin Sinclair <gsinclair@soyabean.com.au>
-
-	* README: Minor addition.
-	* etc/website/index.html: Synced with README.
-
-2003-10-15  Nikolai Weibull  <source@pcppopper.org>
-
-	* indent/ruby.vim: Fixed bug #114.  Also fixed a related problem with
-	documentation blocks.  They would indent relative to the other code.
-	Now it simply indents with zero width (to match =begin) by default.
-	Otherwise acts like 'autoindent'.  Also fixed a problem with | and &
-	not being recognized as continuation lines.  This may cause problems
-	with do blocks, we'll see.
-	* indent/ruby.vim: In response to previous note.  It proved fatal.
-	Fixed now.
-
-2003-10-14  Nikolai Weibull  <source@pcppopper.org>
-
-	* syntax/ruby.vim: Readded matching of $' and $" when
-	ruby_no_identifiers was off.  Got accidentaly removed with previous
-	fix.
-
-2003-10-13  Nikolai Weibull  <source@pcppopper.org>
-
-	* indent/ruby.vim: General cleanup, speedup, fixup.  Fixes bug #62.
-	Indentiation of tk.rb (5200+ lines) takes under 13 seconds now.
-	* ftplugin/ruby.vim: Cleanup.  Nested if's unnecessary.  Also modified
-	modeline.
-
-2003-10-12  Nikolai Weibull  <source@pcppopper.org>
-
-	* indent/ruby.vim: Fixed bugs #89 and #102.
-	* syntax/ruby.vim: The $' and $" variables weren't being matched if
-	ruby_no_identifiers was on.  This messed up string matching.
-	* indent/ruby.vim: Basically did a total rewrite in the process.
-	Everything is well documented now, and should be rather simple to
-	understand.  There is probably room for optimization still, but it
-	works rather fast, indenting tk.rb (5200+ lines) in under 15 seconds.
-	I'm betting searchpair() may be executing a bit too often still, but a
-	lot of special cases have now been taken care of.  This version also
-	fixes bug #59 and #71.
-
-2003-10-03  Doug Kearns  <djkea2@mugca.its.monash.edu.au>
-
-	* syntax/ruby.vim: simplify the rubyData pattern by using the new EOF
-	atom.
-
-2003-10-03  Doug Kearns  <djkea2@mugca.its.monash.edu.au>
-
-	* syntax/ruby.vim: link rubyBoolean to rubyPseudoVariable; link
-	rubyPseudoVariable to the Constant highlight group.
-
-2003-09-30  Doug Kearns  <djkea2@mugca.its.monash.edu.au>
-
-	* syntax/ruby.vim: create rubyPseudoVariable syntax group; move self,
-	nil, __LINE__ and __FILE_ to rubyPseudoVariable.
-
-2003-09-30  Doug Kearns  <djkea2@mugca.its.monash.edu.au>
-
-	* etc/website/index.html: update DJK's current location.
-
-2003-09-26  Doug Kearns  <djkea2@mugca.its.monash.edu.au>
-
-	* etc/website/index.html: close the open PRE element and add a DOCTYPE
-	declaration.
-
-2003-09-26  Doug Kearns  <djkea2@mugca.its.monash.edu.au>
-
-	* indent/ruby.vim: update references to rubyExprSubst - this syntax
-	group has been split into rubyInterpolation, rubyNoInterpolation and
-	rubyEscape.
-
-2003-09-26  Gavin Sinclair <gsinclair@soyabean.com.au>
-
-	* etc/release/*: added to aid in the production of releases.
-	* etc/website/*: now anyone can have a crack at the
-	  vim.ruby.rubyforge.org website!
-
-2003-09-25  Doug Kearns  <djkea2@mugca.its.monash.edu.au>
-
-	* syntax/ruby.vim: link the rubyNoInterpolation syntax group to
-	rubyString; merge rubyHexadecimal, rubyDecimal, rubyOctal, rubyBinary
-	into rubyInteger.
-
-2003-09-22  Doug Kearns  <djkea2@mugca.its.monash.edu.au>
-
-	* syntax/ruby.vim: link the rubyOperator syntax group to the Operator
-	highlight group.
-
-2003-09-21  Doug Kearns  <djkea2@mugca.its.monash.edu.au>
-
-	* syntax/ruby.vim: match regexps after split, scan, sub and gsub.
-
-2003-09-21  Doug Kearns  <djkea2@mugca.its.monash.edu.au>
-
-	* syntax/ruby.vim: highlight escaped string interpolation correctly;
-	allow hexadecimal and octal escape sequences to match with less than 3
-	and 2 digits respectively; split rubyExprSubst into multiple syntax
-	groups - rubyInterpolation, rubyNoInterpolation, rubyEscape.
-
-2003-09-19  Doug Kearns  <djkea2@mugca.its.monash.edu.au>
-
-	* syntax/ruby.vim: match singleton class definitions with no
-	whitespace between 'class' and '<<'.
-
-2003-09-19  Doug Kearns  <djkea2@mugca.its.monash.edu.au>
-
-	* install.rb, syntax/doc/ruby.txt: fix minor typos.
-
-2003-09-18  Doug Kearns  <djkea2@mugca.its.monash.edu.au>
-
-	* syntax/ruby.vim: improve float and decimal matching; split
-	rubyInteger into multiple syntax groups - rubyASCIICode,
-	rubyHexadecimal, rubyDecimal, rubyOctal, rubyBinary.
-
-2003-09-18  Doug Kearns  <djkea2@mugca.its.monash.edu.au>
-
-	* syntax/ruby.vim: replace all patterns surrounded by \(\) with \%(\)
-	when the sub-expression is not used.
-
-2003-09-18  Gavin Sinclair <gsinclair@soyabean.com.au>
-
-	* install.rb: Included comments and USAGE string from revisino 1.1.
-
-2003-09-18  Doug Kearns  <djkea2@mugca.its.monash.edu.au>
-
-	* syntax/ruby.vim: match regexp after 'not' and 'then'; match if and
-	unless expressions following '=' and '('.
-
-2003-09-17  Gavin Sinclair  <gsinclair@soyabean.com.au>
-
-	* ftplugin/ruby.vim: implemented matchit support (thanks to Ned Konz
-	and Hugh Sasse).
-
-2003-09-17  Gavin Sinclair  <gsinclair@soyabean.com.au>
-
-	* install.rb: replaced with Hugh Sasse's contribution.  Alpha state
-	until tested, and with several issues and todos listed.
-
-2003-09-11  Doug Kearns  <djkea2@mugca.its.monash.edu.au>
-
-	* syntax/ruby.vim: fix my accidental redefinition of the
-	ruby_no_expensive matchgroups.
-
-2003-09-11  Doug Kearns  <djkea2@mugca.its.monash.edu.au>
-
-	* syntax/ruby.vim: improve support for symbols, integers and floating
-	point numbers; add the display argument to :syntax where appropriate.
-
-2003-09-09  Doug Kearns  <djkea2@mugca.its.monash.edu.au>
-
-	* syntax/ruby.vim: remove Vim 5.x specific sections and simplify the
-	generalized string, regular expression, symbol, and word list literal
-	syntax groups.
-
-2003-09-09  Doug Kearns  <djkea2@mugca.its.monash.edu.au>
-
-	* indent/ruby.vim, syntax/ruby.vim: rename the rubyStringDelimit
-	syntax group rubyStringDelimiter.
-
-2003-09-09  Doug Kearns  <djkea2@mugca.its.monash.edu.au>
-
-	* syntax/ruby.vim: highlight one line module, class, and method
-	definitions, using the ';' terminator, correctly; split
-	rubyClassOrModule into two new syntax groups - rubyClass and
-	rubyModule.
-
-2003-09-08  Doug Kearns  <djkea2@mugca.its.monash.edu.au>
-
-	*  syntax/ruby.vim: add the @Spell cluster to support spell checking
-	of comment text.
-
-2003-09-08  Doug Kearns  <djkea2@mugca.its.monash.edu.au>
-
-	* syntax/ruby.vim: add support for the new %s() symbol literal.
-
-2003-09-03  Doug Kearns  <djkea2@mugca.its.monash.edu.au>
-
-	* compiler/ruby.vim: update the maintainer's email address.
-
-2003-09-02  Doug Kearns  <djkea2@mugca.its.monash.edu.au>
-
-	* syntax/ruby.vim: make sure that the optional do after for, until or
-	while is not matched as the beginning of a do/end code block; also
-	highlight the optional ':' for these loop constructs.
-
-2003-08-28  Doug Kearns  <djkea2@mugca.its.monash.edu.au>
-
-	* syntax/ruby.vim: add folding support to embedded data sections after
-	an __END__ directive.
-
-2003-08-27  Doug Kearns  <djkea2@mugca.its.monash.edu.au>
-
-	* syntax/ruby.vim: don't allow '<<' after '.' or '::' to match as the
-	beginning of a heredoc.
-
-2003-08-26  Doug Kearns  <djkea2@mugca.its.monash.edu.au>
-
-	* syntax/ruby.vim: fix shebang highlighting which was being ignored
-	all together.
-
-2003-08-25  Doug Kearns  <djkea2@mugca.its.monash.edu.au>
-
-	* syntax/ruby.vim: add the new %W() word list literal with
-	interpolation; add folding to %q() single quoted strings and %w() word
-	list literals.
-
-2003-08-24  Doug Kearns  <djkea2@mugca.its.monash.edu.au>
-
-	* syntax/ruby.vim: add $deferr to rubyPredefinedVariable; add several
-	new methods (abort, at_exit, attr, attr_accessor, attr_reader,
-	attr_writer, autoload, callcc, caller, exit, extend, fork, eval,
-	class_eval, instance_eval, module_eval, private, protected, public,
-	trap) to the Special Methods section.
-
-2003-08-21  Doug Kearns  <djkea2@mugca.its.monash.edu.au>
-
-	* syntax/ruby.vim: add access control methods (public, protected and
-	private) to a new rubyAccess syntax group.
-
-2003-08-21  Doug Kearns  <djkea2@mugca.its.monash.edu.au>
-
-	* syntax/ruby.vim: no longer match NotImplementError as a predefined
-	global constant; move rubyTodo to the Comments and Documentation
-	section; create a Special Methods section and add the
-	ruby_no_special_methods variable to allow the highlighting of these
-	'special' methods to be disabled.
-
-2003-08-18  Doug Kearns  <djkea2@mugca.its.monash.edu.au>
-
-	* compiler/ruby.vim, ftplugin/ruby.vim, indent/ruby.vim,
-	syntax/ruby.vim: retab the header section - Bram prefers as many TAB
-	characters as possible.
-
-2003-08-18  Doug Kearns  <djkea2@mugca.its.monash.edu.au>
-
-	* syntax/ruby.vim: allow for, while and until loop bodies to contain
-	do...end and {...} blocks - rubyOptDoBlock should contain rubyDoBlock
-	and rubyCurlyBlock.
-
-2003-08-16  Doug Kearns  <djkea2@mugca.its.monash.edu.au>
-
-	* syntax/ruby.vim: string expression substitution of class variables
-	does not require braces.
-
diff --git a/sources_non_forked/vim-ruby/Gemfile b/sources_non_forked/vim-ruby/Gemfile
deleted file mode 100644
index c543a5d..0000000
--- a/sources_non_forked/vim-ruby/Gemfile
+++ /dev/null
@@ -1,4 +0,0 @@
-source 'http://rubygems.org'
-
-gem 'rspec'
-gem 'vimrunner'
diff --git a/sources_non_forked/vim-ruby/Gemfile.lock b/sources_non_forked/vim-ruby/Gemfile.lock
deleted file mode 100644
index a2d6c65..0000000
--- a/sources_non_forked/vim-ruby/Gemfile.lock
+++ /dev/null
@@ -1,28 +0,0 @@
-GEM
-  remote: http://rubygems.org/
-  specs:
-    diff-lcs (1.3)
-    rspec (3.5.0)
-      rspec-core (~> 3.5.0)
-      rspec-expectations (~> 3.5.0)
-      rspec-mocks (~> 3.5.0)
-    rspec-core (3.5.4)
-      rspec-support (~> 3.5.0)
-    rspec-expectations (3.5.0)
-      diff-lcs (>= 1.2.0, < 2.0)
-      rspec-support (~> 3.5.0)
-    rspec-mocks (3.5.0)
-      diff-lcs (>= 1.2.0, < 2.0)
-      rspec-support (~> 3.5.0)
-    rspec-support (3.5.0)
-    vimrunner (0.3.0)
-
-PLATFORMS
-  ruby
-
-DEPENDENCIES
-  rspec
-  vimrunner
-
-BUNDLED WITH
-   1.13.7
diff --git a/sources_non_forked/vim-ruby/INSTALL.markdown b/sources_non_forked/vim-ruby/INSTALL.markdown
deleted file mode 100644
index b767bb5..0000000
--- a/sources_non_forked/vim-ruby/INSTALL.markdown
+++ /dev/null
@@ -1,35 +0,0 @@
-Installation
-============
-
-In general, your favorite method works.  Here are some options.
-
-With pathogen.vim
------------------
-
-Install [pathogen.vim](https://github.com/tpope/vim-pathogen),
-then copy and paste:
-
-    git clone git://github.com/vim-ruby/vim-ruby.git ~/.vim/bundle/vim-ruby
-
-With Vundle
------------
-
-Install [Vundle](https://github.com/gmarik/vundle), then add the
-following to your vimrc:
-
-    Bundle 'vim-ruby/vim-ruby'
-
-With patience
--------------
-
-Wait for an upgrade to Vim and install it.  Vim ships with the latest
-version of vim-ruby at the time of its release.  (Remember this when
-choosing another installation method.  The version you download will
-supersede the version that ships with Vim, so you will now be
-responsible for keeping it up-to-date.)
-
-Manually
---------
-
-[Download](https://github.com/vim-ruby/vim-ruby/archives/master) and
-extract the relevant files to `~/.vim` (or `$HOME/vimfiles` on Windows).
diff --git a/sources_non_forked/vim-ruby/NEWS b/sources_non_forked/vim-ruby/NEWS
deleted file mode 100644
index 388dffe..0000000
--- a/sources_non_forked/vim-ruby/NEWS
+++ /dev/null
@@ -1,243 +0,0 @@
-This file is no longer maintained.  Consult the Git log for newer changes.
-
-= 2008.07.XX
-
-== Filetype Detection
-
-The IRB RC file (.irbrc) is now detected as being a Ruby file.
-
-
-= 2007.05.07
-
-== Ruby Syntax Highlighting
-
-Highlight OPTIMIZE alongside FIXME and TODO.
-
-Multiline array literals can now be folded.
-
-== Ruby Filetype Support
-
-Added mappings for [[, ]], [], ][, [m, ]m, [M, and ]M.  The first four bounce
-between class and module declarations, and the last four between method
-declarations.
-
-== eRuby Syntax Highlighting
-
-Tim Pope has taken over maintenance of the eRuby syntax file.  The subtype of
-the file is now determined dynamically from the filename, rather than being
-hardwired to HTML.  It can be overridden with b:eruby_subtype.
-
-== eRuby Filetype Support
-
-Tim Pope has taken over maintenance of the eRuby filetype plugin.  Like with
-the syntax file, the subtype is now determined dynamically.
-
-== eRuby Indenting
-
-As with the syntax file and filetype plugin, the subtype is now determined
-dynamically.
-
-== Bug Fixes
-
-Ruby syntax file
-  - when ruby_operators is set, highlight scope and range operators, and don't
-    match '>' in =>'
-  - regexp literals are highlighted after the 'else' keyword
-  - don't match [!=?] as part of a sigil prefixed symbol name
-  - allow text to appear after, and on the same line, as '=begin' in
-    rubyDocumentation regions
-  - highlight %s() ans a symbol, not a string
-  - eliminated some false positves for here docs, symbols, ASCII codes, and
-    conditionals as statement modifiers
-  - added "neus" to regexp flags
-  - Highlight punctuation variables in string interpolation, and flag invalid
-    ones as errors
-  - removed : from rubyOptionalDoLine (falsely matches on symbols)
-
-Ruby filetype plugin
-  - eliminated some false positives with the matchit patterns
-
-Ruby indent plugin
-  - ignore instance, class, and global variables named "end"
-
-
-= 2007.03.02
-
-== Omni Completion
-
-Fall back to syntax highlighting completion if Vim lacks the Ruby interface.
-
-RubyGems is now loaded by default if available.
-
-Classes are detected using ObjectSpace.  Kernel methods are included in method
-completion.
-
-Added completion in Rails views.  Rails helpers are included.  Rails migrations
-now have completion.
-
-== Ruby Syntax Highlighting
-
-Ruby code is highlighted inside interpolation regions.
-
-Symbols are now highlighted with the Constant highlight group; Constants and
-class names with the Type highlight group.
-
-Symbol names specified with a string recognise interpolation and escape
-sequences.
-
-Alias statements receive special highlighting similar to other 'definitions'.
-
-== Ruby Filetype Support
-
-Matchit support has been improved to include (), {}, and [] in the list of
-patterns so that these will be appropriately skipped when included in comments.
-
-ri has been added as the 'keywordprg' and 'balloonexpr' is set to return the
-output of ri.
-
-== eRuby Indenting
-
-Tim Pope has taken over maintenance of the eRuby indent file.  Ruby code is now
-indented appropriately.
-
-== Bug Fixes
-
-Ruby syntax file
-  - trailing whitespace is no longer included with the def, class, module
-    keywords.
-  - escaped interpolation regions should now be ignored in all cases.
-  - conditional and loop statements are now highlighted correctly in more
-    locations (where they're used as expressions).
-
-eRuby syntax file
-  - '-' trim mode block delimiters are now recognised.
-
-Omni Completion
-  - more robustness; failure to parse buffer no longer errors or prevents
-    completion.
-
-
-= 2006.07.11
-
-== Omni Completion
-
-A new omni completion function is now included which offers IntelliSense-like
-functionality. See :help ft-ruby-omni for further information.
-
-Note: This will only work with Vim 7.x, compiled with the Ruby interface
-(+ruby), and Ruby 1.8.x
-
-== Ruby Filetype Support
-
-Matchit support has been improved to include (), {}, and [] in the list of
-patterns meaning these will be appropriately skipped when included in comments.
-
-== Ruby Syntax Highlighting
-
-Operators can now be highlighted by defining the Vim global variable
-"ruby_operators".
-
-Multiline comments will now be folded. This can be disabled by defining the
-"ruby_no_comment_fold" Vim variable.
-
-== Filetype Detection
-
-RJS and RXML templates are now detected as being 'filetype=ruby'.
-
-== FAQ
-
-There is a new FAQ document included. This is a work in progress and any
-feedback would be appreciated.
-
-== Bug Fixes
-
-Ruby syntax file - if/unless modifiers after a method name ending with [?!=]
-should now be highlighted correctly.
-
-
-= 2005.10.07
-
-== Vim 6.4
-
-This release is included in Vim 6.4.
-
-== Bug Fixes
-
-Ruby filetype plugin - symbols were incorrectly being matched as match_words
-causing the matchit motion command to jump to an incorrect location in some
-circumstances.
-
-
-= 2005.10.05
-
-== Bug Fixes
-
-Ruby syntax file - allow for comments directly after module/class/def lines
-without intervening whitespace (fold markers were breaking syntax highlighting).
-
-Ruby filetype plugin - improve ordering of 'path' elements.
-
-eRuby syntax file - make use of ruby_no_expensive local to the buffer.
-
-
-= 2005.09.24
-
-== Filetype Detection
-
-The eruby filetype is now detected solely based on the file's extension. This
-was being overridden by the scripts.vim detection script.
-
-Note: Only files ending in *.rhtml are detected as filetype eruby since these
-are currently assumed to be Ruby embedded in (X)HTML only. Other filetypes
-could be supported if requested.
-
-== eRuby Indent File
-
-There is a new eRuby indent file which simply sources the HTML indent file for
-now.
-
-== eRuby Compiler Plugin 
-
-This now supports erb as the default 'makeprg'. To use eruby set the
-eruby_compiler variable to "eruby" in your .vimrc
-
-== Test::Unit Compiler Plugin
-
-This has been improved and should now display messages similar to, though more
-detailed than, the GUI test runners.
-
-== Bug Fixes
-
-A few minor bugs have been fixed in the Ruby syntax and indent files.
-
-
-= 2005.09.15
-
-== eRuby Support
-
-There are new syntax, compiler, and ftplugin files for eRuby.  This support is
-incomplete and we're keen to hear of any problems or suggestions you may have
-to improve it.
-
-== Ruby Filetype Support
-
-The Ruby filetype plugin has been improved to include as many useful settings
-as possible without intruding too much on an individual user's preferences.
-Matchit support has been improved, and the following options are now set to
-appropriate values: comments, commentstring, formatoptions, include,
-includeexpr, path, and suffixesadd
-
-== Filetype Detection
-
-The new ftdetect mechanism of Vim 6.3 is being utilized to enable filetype
-detection of eRuby files until this is officially added to the next release of
-Vim.
-
-== Installation Directories
-
-The installer script now, where possible, automatically determines both the
-user and system-wide preferences directory.
-
-== Bug Fixes
-
-A large number of bugs have been fixed in the Ruby syntax and indent files.
diff --git a/sources_non_forked/vim-ruby/README b/sources_non_forked/vim-ruby/README
deleted file mode 100644
index 39d9d91..0000000
--- a/sources_non_forked/vim-ruby/README
+++ /dev/null
@@ -1,73 +0,0 @@
-                    +---------------------------------+
-                    |  vim-ruby github project README |
-                    +---------------------------------+
-
-Summary:
-  This project contains Vim configuration files for editing and compiling Ruby
-  within Vim.  See the project homepage for more details.
-
-Web links:
-  Homepage: https://github.com/vim-ruby
-  Explanation:  https://github.com/vim-ruby/vim-ruby/wiki
-
-For regular users:
-  - The project page should have two tarballs for download:
-     - vim-ruby-YYYY.MM.DD.tar.gz  (the current stable release)
-     - vim-ruby-devel-YYYY.MM.DD.tar.gz  (cutting-edge features we'd like you
-       to test)
-  - Please give feedback through the bug tracking and feature request features
-    of GitHub.
-  - Feel free to join discussions on the vim-ruby-devel mailing list:
-    http://rubyforge.org/mail/?group_id=16
-
-For would-be contributors:
-  - Please get the latest from Git.
-  - Please join the mailing list and discuss changes, submit patches, etc.
-  - Thank you very much for taking an interest.
-
-Contents of the project:
-  - The autoload, compiler, ftdetect, ftplugin, indent and syntax directories
-    contain the ruby*.vim files that are to be copied to a location somewhere
-    in the Vim 'runtimepath'.
-
-How you get these files into Vim:
-  - By downloading the project via a snapshot or Git, you can keep up with
-    the latest, make changes, and install the files to a Vim directory.
-  - By downloading one of the tarballs, you can easily install the latest
-    stable or development version wherever you like on your machine.  No
-    README etc. just Vim files.  You would typically install these into either
-    $VIM/vimfiles, for system-wide use, or $HOME/.vim ($HOME/vimfiles on
-    Windows) for personal use.
-  - Remember that when you install Vim in the first place, all of these files
-    are present.  The purpose of downloading and installing them from
-    GitHub is to get the latest version of them.
-
-Git topics:
-  - Project was migrated from CVS in August, 2008.
-  - Files are tagged according to which version of Vim they are released in.
-  - The project was initiated in July 2003, when the current version of Vim
-    was 6.2.  Thus every file began its life tagged as vim6.2.
-  - Modifications to the files are made in the expectation that they need to
-    be tested by interested users.  They therefore (probably) don't have a
-    tag, and are available via "git pull --rebase", or a development snapshot.
-  - When a modification is considered stable, it is given a tag.
-    Everything that is stable gets released in vim-ruby-YYY.MM.DD.tar.gz files.
-  - When a new version of Vim is about to be released, the stable tarball is
-    contributed to it.  After it has been released, the files are tagged
-    accordingly.
-  - MORAL OF THE STORY: modifications are committed to the head of the tree;
-    when they are ready for release into userland, they are tagged "stable".
-
-Any questions or suggestions?
-  - If there's something about the project or its concepts that you don't
-    understand, send an email to the release coordinator, Doug Kearns
-    (dougkearns at gmail.com).
-  - To ask about the contents of the configuration files, open a GitHub issue
-    or ask on the mailing list, as different people maintain the different
-    files.
-
-Project gossip:
-  - While the individual effort to maintain these files has a long history,
-    this actual project began in late July 2003.
-
-                           --= End of Document =--
diff --git a/sources_non_forked/vim-ruby/autoload/rubycomplete.vim b/sources_non_forked/vim-ruby/autoload/rubycomplete.vim
deleted file mode 100644
index 8eff800..0000000
--- a/sources_non_forked/vim-ruby/autoload/rubycomplete.vim
+++ /dev/null
@@ -1,871 +0,0 @@
-" Vim completion script
-" Language:		Ruby
-" Maintainer:		Mark Guzman <segfault@hasno.info>
-" URL:			https://github.com/vim-ruby/vim-ruby
-" Release Coordinator:	Doug Kearns <dougkearns@gmail.com>
-" ----------------------------------------------------------------------------
-"
-" Ruby IRB/Complete author: Keiju ISHITSUKA(keiju@ishitsuka.com)
-" ----------------------------------------------------------------------------
-
-" {{{ requirement checks
-
-function! s:ErrMsg(msg)
-    echohl ErrorMsg
-    echo a:msg
-    echohl None
-endfunction
-
-if !has('ruby')
-    call s:ErrMsg( "Error: Rubycomplete requires vim compiled with +ruby" )
-    call s:ErrMsg( "Error: falling back to syntax completion" )
-    " lets fall back to syntax completion
-    setlocal omnifunc=syntaxcomplete#Complete
-    finish
-endif
-
-if version < 700
-    call s:ErrMsg( "Error: Required vim >= 7.0" )
-    finish
-endif
-" }}} requirement checks
-
-" {{{ configuration failsafe initialization
-if !exists("g:rubycomplete_rails")
-    let g:rubycomplete_rails = 0
-endif
-
-if !exists("g:rubycomplete_classes_in_global")
-    let g:rubycomplete_classes_in_global = 0
-endif
-
-if !exists("g:rubycomplete_buffer_loading")
-    let g:rubycomplete_buffer_loading = 0
-endif
-
-if !exists("g:rubycomplete_include_object")
-    let g:rubycomplete_include_object = 0
-endif
-
-if !exists("g:rubycomplete_include_objectspace")
-    let g:rubycomplete_include_objectspace = 0
-endif
-" }}} configuration failsafe initialization
-
-" {{{ regex patterns
-
-" Regex that defines the start-match for the 'end' keyword.
-let s:end_start_regex =
-      \ '\C\%(^\s*\|[=,*/%+\-|;{]\|<<\|>>\|:\s\)\s*\zs' .
-      \ '\<\%(module\|class\|if\|for\|while\|until\|case\|unless\|begin' .
-      \   '\|\%(\K\k*[!?]\?\s\+\)\=def\):\@!\>' .
-      \ '\|\%(^\|[^.:@$]\)\@<=\<do:\@!\>'
-
-" Regex that defines the middle-match for the 'end' keyword.
-let s:end_middle_regex = '\<\%(ensure\|else\|\%(\%(^\|;\)\s*\)\@<=\<rescue:\@!\>\|when\|elsif\):\@!\>'
-
-" Regex that defines the end-match for the 'end' keyword.
-let s:end_end_regex = '\%(^\|[^.:@$]\)\@<=\<end:\@!\>'
-
-" }}} regex patterns
-
-" {{{ vim-side support functions
-let s:rubycomplete_debug = 0
-
-function! s:dprint(msg)
-    if s:rubycomplete_debug == 1
-        echom a:msg
-    endif
-endfunction
-
-function! s:GetBufferRubyModule(name, ...)
-    if a:0 == 1
-        let [snum,enum] = s:GetBufferRubyEntity(a:name, "module", a:1)
-    else
-        let [snum,enum] = s:GetBufferRubyEntity(a:name, "module")
-    endif
-    return snum . '..' . enum
-endfunction
-
-function! s:GetBufferRubyClass(name, ...)
-    if a:0 >= 1
-        let [snum,enum] = s:GetBufferRubyEntity(a:name, "class", a:1)
-    else
-        let [snum,enum] = s:GetBufferRubyEntity(a:name, "class")
-    endif
-    return snum . '..' . enum
-endfunction
-
-function! s:GetBufferRubySingletonMethods(name)
-endfunction
-
-function! s:GetBufferRubyEntity( name, type, ... )
-    let lastpos = getpos(".")
-    let lastline = lastpos
-    if (a:0 >= 1)
-        let lastline = [ 0, a:1, 0, 0 ]
-        call cursor( a:1, 0 )
-    endif
-
-    let stopline = 1
-
-    let crex = '^\s*\<' . a:type . '\>\s*\<' . escape(a:name, '*') . '\>\s*\(<\s*.*\s*\)\?'
-    let [lnum,lcol] = searchpos( crex, 'w' )
-    "let [lnum,lcol] = searchpairpos( crex . '\zs', '', '\(end\|}\)', 'w' )
-
-    if lnum == 0 && lcol == 0
-        call cursor(lastpos[1], lastpos[2])
-        return [0,0]
-    endif
-
-    let curpos = getpos(".")
-    let [enum,ecol] = searchpairpos( s:end_start_regex, s:end_middle_regex, s:end_end_regex, 'W' )
-    call cursor(lastpos[1], lastpos[2])
-
-    if lnum > enum
-        return [0,0]
-    endif
-    " we found a the class def
-    return [lnum,enum]
-endfunction
-
-function! s:IsInClassDef()
-    return s:IsPosInClassDef( line('.') )
-endfunction
-
-function! s:IsPosInClassDef(pos)
-    let [snum,enum] = s:GetBufferRubyEntity( '.*', "class" )
-    let ret = 'nil'
-
-    if snum < a:pos && a:pos < enum
-        let ret = snum . '..' . enum
-    endif
-
-    return ret
-endfunction
-
-function! s:IsInComment(pos)
-    let stack = synstack(a:pos[0], a:pos[1])
-    if !empty(stack)
-        return synIDattr(stack[0], 'name') =~ 'ruby\%(.*Comment\|Documentation\)'
-    else
-        return 0
-    endif
-endfunction
-
-function! s:GetRubyVarType(v)
-    let stopline = 1
-    let vtp = ''
-    let curpos = getpos('.')
-    let sstr = '^\s*#\s*@var\s*'.escape(a:v, '*').'\>\s\+[^ \t]\+\s*$'
-    let [lnum,lcol] = searchpos(sstr,'nb',stopline)
-    if lnum != 0 && lcol != 0
-        call setpos('.',curpos)
-        let str = getline(lnum)
-        let vtp = substitute(str,sstr,'\1','')
-        return vtp
-    endif
-    call setpos('.',curpos)
-    let ctors = '\(now\|new\|open\|get_instance'
-    if exists('g:rubycomplete_rails') && g:rubycomplete_rails == 1 && s:rubycomplete_rails_loaded == 1
-        let ctors = ctors.'\|find\|create'
-    else
-    endif
-    let ctors = ctors.'\)'
-
-    let fstr = '=\s*\([^ \t]\+.' . ctors .'\>\|[\[{"''/]\|%[xwQqr][(\[{@]\|[A-Za-z0-9@:\-()\.]\+...\?\|lambda\|&\)'
-    let sstr = ''.escape(a:v, '*').'\>\s*[+\-*/]*'.fstr
-    let pos = searchpos(sstr,'bW')
-    while pos != [0,0] && s:IsInComment(pos)
-        let pos = searchpos(sstr,'bW')
-    endwhile
-    if pos != [0,0]
-        let [lnum, col] = pos
-        let str = matchstr(getline(lnum),fstr,col)
-        let str = substitute(str,'^=\s*','','')
-
-        call setpos('.',pos)
-        if str == '"' || str == '''' || stridx(tolower(str), '%q[') != -1
-            return 'String'
-        elseif str == '[' || stridx(str, '%w[') != -1
-            return 'Array'
-        elseif str == '{'
-            return 'Hash'
-        elseif str == '/' || str == '%r{'
-            return 'Regexp'
-        elseif strlen(str) >= 4 && stridx(str,'..') != -1
-            return 'Range'
-        elseif stridx(str, 'lambda') != -1 || str == '&'
-            return 'Proc'
-        elseif strlen(str) > 4
-            let l = stridx(str,'.')
-            return str[0:l-1]
-        end
-        return ''
-    endif
-    call setpos('.',curpos)
-    return ''
-endfunction
-
-"}}} vim-side support functions
-
-"{{{ vim-side completion function
-function! rubycomplete#Init()
-    execute "ruby VimRubyCompletion.preload_rails"
-endfunction
-
-function! rubycomplete#Complete(findstart, base)
-     "findstart = 1 when we need to get the text length
-    if a:findstart
-        let line = getline('.')
-        let idx = col('.')
-        while idx > 0
-            let idx -= 1
-            let c = line[idx-1]
-            if c =~ '\w'
-                continue
-            elseif ! c =~ '\.'
-                let idx = -1
-                break
-            else
-                break
-            endif
-        endwhile
-
-        return idx
-    "findstart = 0 when we need to return the list of completions
-    else
-        let g:rubycomplete_completions = []
-        execute "ruby VimRubyCompletion.get_completions('" . a:base . "')"
-        return g:rubycomplete_completions
-    endif
-endfunction
-"}}} vim-side completion function
-
-"{{{ ruby-side code
-function! s:DefRuby()
-ruby << RUBYEOF
-# {{{ ruby completion
-
-begin
-    require 'rubygems' # let's assume this is safe...?
-rescue Exception
-    #ignore?
-end
-class VimRubyCompletion
-# {{{ constants
-  @@debug = false
-  @@ReservedWords = [
-        "BEGIN", "END",
-        "alias", "and",
-        "begin", "break",
-        "case", "class",
-        "def", "defined", "do",
-        "else", "elsif", "end", "ensure",
-        "false", "for",
-        "if", "in",
-        "module",
-        "next", "nil", "not",
-        "or",
-        "redo", "rescue", "retry", "return",
-        "self", "super",
-        "then", "true",
-        "undef", "unless", "until",
-        "when", "while",
-        "yield",
-      ]
-
-  @@Operators = [ "%", "&", "*", "**", "+",  "-",  "/",
-        "<", "<<", "<=", "<=>", "==", "===", "=~", ">", ">=", ">>",
-        "[]", "[]=", "^", ]
-# }}} constants
-
-# {{{ buffer analysis magic
-  def load_requires
-
-    custom_paths = VIM::evaluate("get(g:, 'rubycomplete_load_paths', [])")
-
-    if !custom_paths.empty?
-      $LOAD_PATH.concat(custom_paths).uniq!
-    end
-
-    buf = VIM::Buffer.current
-    enum = buf.line_number
-    nums = Range.new( 1, enum )
-    nums.each do |x|
-
-      ln = buf[x]
-      begin
-        if /.*require_relative\s*(.*)$/.match( ln )
-          eval( "require %s" % File.expand_path($1) )
-        elsif /.*require\s*(["'].*?["'])/.match( ln )
-          eval( "require %s" % $1 )
-        end
-      rescue Exception => e
-        dprint e.inspect
-      end
-    end
-  end
-
-  def load_gems
-    fpath = VIM::evaluate("get(g:, 'rubycomplete_gemfile_path', 'Gemfile')")
-    return unless File.file?(fpath) && File.readable?(fpath)
-    want_bundler = VIM::evaluate("get(g:, 'rubycomplete_use_bundler')")
-    parse_file = !want_bundler
-    begin
-      require 'bundler'
-      Bundler.setup
-      Bundler.require
-    rescue Exception
-      parse_file = true
-    end
-    if parse_file
-      File.new(fpath).each_line do |line|
-        begin
-          require $1 if /\s*gem\s*['"]([^'"]+)/.match(line)
-        rescue Exception
-        end
-      end
-    end
-  end
-
-  def load_buffer_class(name)
-    dprint "load_buffer_class(%s) START" % name
-    classdef = get_buffer_entity(name, 's:GetBufferRubyClass("%s")')
-    return if classdef == nil
-
-    pare = /^\s*class\s*(.*)\s*<\s*(.*)\s*\n/.match( classdef )
-    load_buffer_class( $2 ) if pare != nil  && $2 != name # load parent class if needed
-
-    mixre = /.*\n\s*(include|prepend)\s*(.*)\s*\n/.match( classdef )
-    load_buffer_module( $2 ) if mixre != nil && $2 != name # load mixins if needed
-
-    begin
-      eval classdef
-    rescue Exception
-      VIM::evaluate( "s:ErrMsg( 'Problem loading class \"%s\", was it already completed?' )" % name )
-    end
-    dprint "load_buffer_class(%s) END" % name
-  end
-
-  def load_buffer_module(name)
-    dprint "load_buffer_module(%s) START" % name
-    classdef = get_buffer_entity(name, 's:GetBufferRubyModule("%s")')
-    return if classdef == nil
-
-    begin
-      eval classdef
-    rescue Exception
-      VIM::evaluate( "s:ErrMsg( 'Problem loading module \"%s\", was it already completed?' )" % name )
-    end
-    dprint "load_buffer_module(%s) END" % name
-  end
-
-  def get_buffer_entity(name, vimfun)
-    loading_allowed = VIM::evaluate("exists('g:rubycomplete_buffer_loading') && g:rubycomplete_buffer_loading")
-    return nil if loading_allowed.to_i.zero?
-    return nil if /(\"|\')+/.match( name )
-    buf = VIM::Buffer.current
-    nums = eval( VIM::evaluate( vimfun % name ) )
-    return nil if nums == nil
-    return nil if nums.min == nums.max && nums.min == 0
-
-    dprint "get_buffer_entity START"
-    visited = []
-    clscnt = 0
-    bufname = VIM::Buffer.current.name
-    classdef = ""
-    cur_line = VIM::Buffer.current.line_number
-    while (nums != nil && !(nums.min == 0 && nums.max == 0) )
-      dprint "visited: %s" % visited.to_s
-      break if visited.index( nums )
-      visited << nums
-
-      nums.each do |x|
-        if x != cur_line
-          next if x == 0
-          ln = buf[x]
-          is_const = false
-          if /^\s*(module|class|def|include)\s+/.match(ln) || is_const = /^\s*?[A-Z]([A-z]|[1-9])*\s*?[|]{0,2}=\s*?.+\s*?/.match(ln)
-            clscnt += 1 if /class|module/.match($1)
-            # We must make sure to load each constant only once to avoid errors
-            if is_const
-                ln.gsub!(/\s*?[|]{0,2}=\s*?/, '||=')
-            end
-            #dprint "\$1$1
-            classdef += "%s\n" % ln
-            classdef += "end\n" if /def\s+/.match(ln)
-            dprint ln
-          end
-        end
-      end
-
-      nm = "%s(::.*)*\", %s, \"" % [ name, nums.last ]
-      nums = eval( VIM::evaluate( vimfun % nm ) )
-      dprint "nm: \"%s\"" % nm
-      dprint "vimfun: %s" % (vimfun % nm)
-      dprint "got nums: %s" % nums.to_s
-    end
-    if classdef.length > 1
-        classdef += "end\n"*clscnt
-        # classdef = "class %s\n%s\nend\n" % [ bufname.gsub( /\/|\\/, "_" ), classdef ]
-    end
-
-    dprint "get_buffer_entity END"
-    dprint "classdef====start"
-    lns = classdef.split( "\n" )
-    lns.each { |x| dprint x }
-    dprint "classdef====end"
-    return classdef
-  end
-
-  def get_var_type( receiver )
-    if /(\"|\')+/.match( receiver )
-      "String"
-    else
-      VIM::evaluate("s:GetRubyVarType('%s')" % receiver)
-    end
-  end
-
-  def dprint( txt )
-    print txt if @@debug
-  end
-
-  def escape_vim_singlequote_string(str)
-    str.to_s.gsub(/'/,"\\'")
-  end
-
-  def get_buffer_entity_list( type )
-    # this will be a little expensive.
-    loading_allowed = VIM::evaluate("exists('g:rubycomplete_buffer_loading') && g:rubycomplete_buffer_loading")
-    allow_aggressive_load = VIM::evaluate("exists('g:rubycomplete_classes_in_global') && g:rubycomplete_classes_in_global")
-    return [] if allow_aggressive_load.to_i.zero? || loading_allowed.to_i.zero?
-
-    buf = VIM::Buffer.current
-    eob = buf.length
-    ret = []
-    rg = 1..eob
-    re = eval( "/^\s*%s\s*([A-Za-z0-9_:-]*)(\s*<\s*([A-Za-z0-9_:-]*))?\s*/" % type )
-
-    rg.each do |x|
-      if re.match( buf[x] )
-        next if type == "def" && eval( VIM::evaluate("s:IsPosInClassDef(%s)" % x) ) != nil
-        ret.push $1
-      end
-    end
-
-    return ret
-  end
-
-  def get_buffer_modules
-    return get_buffer_entity_list( "modules" )
-  end
-
-  def get_buffer_methods
-    return get_buffer_entity_list( "def" )
-  end
-
-  def get_buffer_classes
-    return get_buffer_entity_list( "class" )
-  end
-
-  def load_rails
-    allow_rails = VIM::evaluate("exists('g:rubycomplete_rails') && g:rubycomplete_rails")
-    return if allow_rails.to_i.zero?
-
-    buf_path = VIM::evaluate('expand("%:p")')
-    file_name = VIM::evaluate('expand("%:t")')
-    vim_dir = VIM::evaluate('getcwd()')
-    file_dir = buf_path.gsub( file_name, '' )
-    file_dir.gsub!( /\\/, "/" )
-    vim_dir.gsub!( /\\/, "/" )
-    vim_dir << "/"
-    dirs = [ vim_dir, file_dir ]
-    sdirs = [ "", "./", "../", "../../", "../../../", "../../../../" ]
-    rails_base = nil
-
-    dirs.each do |dir|
-      sdirs.each do |sub|
-        trail = "%s%s" % [ dir, sub ]
-        tcfg = "%sconfig" % trail
-
-        if File.exists?( tcfg )
-          rails_base = trail
-          break
-        end
-      end
-      break if rails_base
-    end
-
-    return if rails_base == nil
-    $:.push rails_base unless $:.index( rails_base )
-
-    bootfile = rails_base + "config/boot.rb"
-    envfile = rails_base + "config/environment.rb"
-    if File.exists?( bootfile ) && File.exists?( envfile )
-      begin
-        require bootfile
-        require envfile
-        begin
-          require 'console_app'
-          require 'console_with_helpers'
-        rescue Exception
-          dprint "Rails 1.1+ Error %s" % $!
-          # assume 1.0
-        end
-        #eval( "Rails::Initializer.run" ) #not necessary?
-        VIM::command('let s:rubycomplete_rails_loaded = 1')
-        dprint "rails loaded"
-      rescue Exception
-        dprint "Rails Error %s" % $!
-        VIM::evaluate( "s:ErrMsg('Error loading rails environment')" )
-      end
-    end
-  end
-
-  def get_rails_helpers
-    allow_rails = VIM::evaluate("exists('g:rubycomplete_rails') && g:rubycomplete_rails")
-    rails_loaded = VIM::evaluate('s:rubycomplete_rails_loaded')
-    return [] if allow_rails.to_i.zero? || rails_loaded.to_i.zero?
-
-    buf_path = VIM::evaluate('expand("%:p")')
-    buf_path.gsub!( /\\/, "/" )
-    path_elm = buf_path.split( "/" )
-    dprint "buf_path: %s" % buf_path
-    types = [ "app", "db", "lib", "test", "components", "script" ]
-
-    i = nil
-    ret = []
-    type = nil
-    types.each do |t|
-      i = path_elm.index( t )
-      break if i
-    end
-    type = path_elm[i]
-    type.downcase!
-
-    dprint "type: %s" % type
-    case type
-      when "app"
-        i += 1
-        subtype = path_elm[i]
-        subtype.downcase!
-
-        dprint "subtype: %s" % subtype
-        case subtype
-          when "views"
-            ret += ActionView::Base.instance_methods
-            ret += ActionView::Base.methods
-          when "controllers"
-            ret += ActionController::Base.instance_methods
-            ret += ActionController::Base.methods
-          when "models"
-            ret += ActiveRecord::Base.instance_methods
-            ret += ActiveRecord::Base.methods
-        end
-
-      when "db"
-        ret += ActiveRecord::ConnectionAdapters::SchemaStatements.instance_methods
-        ret += ActiveRecord::ConnectionAdapters::SchemaStatements.methods
-    end
-
-    return ret
-  end
-
-  def add_rails_columns( cls )
-    allow_rails = VIM::evaluate("exists('g:rubycomplete_rails') && g:rubycomplete_rails")
-    rails_loaded = VIM::evaluate('s:rubycomplete_rails_loaded')
-    return [] if allow_rails.to_i.zero? || rails_loaded.to_i.zero?
-
-    begin
-        eval( "#{cls}.establish_connection" )
-        return [] unless eval( "#{cls}.ancestors.include?(ActiveRecord::Base).to_s" )
-        col = eval( "#{cls}.column_names" )
-        return col if col
-    rescue
-        dprint "add_rails_columns err: (cls: %s) %s" % [ cls, $! ]
-        return []
-    end
-    return []
-  end
-
-  def clean_sel(sel, msg)
-    ret = sel.reject{|x|x.nil?}.uniq
-    ret = ret.grep(/^#{Regexp.quote(msg)}/) if msg != nil
-    ret
-  end
-
-  def get_rails_view_methods
-    allow_rails = VIM::evaluate("exists('g:rubycomplete_rails') && g:rubycomplete_rails")
-    rails_loaded = VIM::evaluate('s:rubycomplete_rails_loaded')
-    return [] if allow_rails.to_i.zero? || rails_loaded.to_i.zero?
-
-    buf_path = VIM::evaluate('expand("%:p")')
-    buf_path.gsub!( /\\/, "/" )
-    pelm = buf_path.split( "/" )
-    idx = pelm.index( "views" )
-
-    return [] unless idx
-    idx += 1
-
-    clspl = pelm[idx].camelize.pluralize
-    cls = clspl.singularize
-
-    ret = []
-    begin
-      ret += eval( "#{cls}.instance_methods" )
-      ret += eval( "#{clspl}Helper.instance_methods" )
-    rescue Exception
-      dprint "Error: Unable to load rails view helpers for %s: %s" % [ cls, $! ]
-    end
-
-    return ret
-  end
-# }}} buffer analysis magic
-
-# {{{ main completion code
-  def self.preload_rails
-    a = VimRubyCompletion.new
-    if VIM::evaluate("has('nvim')") == 0
-      require 'thread'
-      Thread.new(a) do |b|
-        begin
-        b.load_rails
-        rescue
-        end
-      end
-    end
-    a.load_rails
-  rescue
-  end
-
-  def self.get_completions(base)
-    b = VimRubyCompletion.new
-    b.get_completions base
-  end
-
-  def get_completions(base)
-    loading_allowed = VIM::evaluate("exists('g:rubycomplete_buffer_loading') && g:rubycomplete_buffer_loading")
-    if loading_allowed.to_i == 1
-      load_requires
-      load_rails
-    end
-
-    want_gems = VIM::evaluate("get(g:, 'rubycomplete_load_gemfile')")
-    load_gems unless want_gems.to_i.zero?
-
-    input = VIM::Buffer.current.line
-    cpos = VIM::Window.current.cursor[1] - 1
-    input = input[0..cpos]
-    input += base
-    input.sub!(/.*[ \t\n\"\\'`><=;|&{(]/, '') # Readline.basic_word_break_characters
-    input.sub!(/self\./, '')
-    input.sub!(/.*((\.\.[\[(]?)|([\[(]))/, '')
-
-    dprint 'input %s' % input
-    message = nil
-    receiver = nil
-    methods = []
-    variables = []
-    classes = []
-    constants = []
-
-    case input
-      when /^(\/[^\/]*\/)\.([^.]*)$/ # Regexp
-        receiver = $1
-        message = Regexp.quote($2)
-        methods = Regexp.instance_methods(true)
-
-      when /^([^\]]*\])\.([^.]*)$/ # Array
-        receiver = $1
-        message = Regexp.quote($2)
-        methods = Array.instance_methods(true)
-
-      when /^([^\}]*\})\.([^.]*)$/ # Proc or Hash
-        receiver = $1
-        message = Regexp.quote($2)
-        methods = Proc.instance_methods(true) | Hash.instance_methods(true)
-
-      when /^(:[^:.]*)$/ # Symbol
-        dprint "symbol"
-        if Symbol.respond_to?(:all_symbols)
-          receiver = $1
-          message = $1.sub( /:/, '' )
-          methods = Symbol.all_symbols.collect{|s| s.id2name}
-          methods.delete_if { |c| c.match( /'/ ) }
-        end
-
-      when /^::([A-Z][^:\.\(]*)?$/ # Absolute Constant or class methods
-        dprint "const or cls"
-        receiver = $1
-        methods = Object.constants.collect{ |c| c.to_s }.grep(/^#{receiver}/)
-
-      when /^(((::)?[A-Z][^:.\(]*)+?)::?([^:.]*)$/ # Constant or class methods
-        receiver = $1
-        message = Regexp.quote($4)
-        dprint "const or cls 2 [recv: \'%s\', msg: \'%s\']" % [ receiver, message ]
-        load_buffer_class( receiver )
-        load_buffer_module( receiver )
-        begin
-          constants = eval("#{receiver}.constants").collect{ |c| c.to_s }.grep(/^#{message}/)
-          methods = eval("#{receiver}.methods").collect{ |m| m.to_s }.grep(/^#{message}/)
-        rescue Exception
-          dprint "exception: %s" % $!
-          constants = []
-          methods = []
-        end
-
-      when /^(:[^:.]+)\.([^.]*)$/ # Symbol
-        dprint "symbol"
-        receiver = $1
-        message = Regexp.quote($2)
-        methods = Symbol.instance_methods(true)
-
-      when /^([0-9_]+(\.[0-9_]+)?(e[0-9]+)?)\.([^.]*)$/ # Numeric
-        dprint "numeric"
-        receiver = $1
-        message = Regexp.quote($4)
-        begin
-          methods = eval(receiver).methods
-        rescue Exception
-          methods = []
-        end
-
-      when /^(\$[^.]*)$/ #global
-        dprint "global"
-        methods = global_variables.grep(Regexp.new(Regexp.quote($1)))
-
-      when /^((\.?[^.]+)+?)\.([^.]*)$/ # variable
-        dprint "variable"
-        receiver = $1
-        message = Regexp.quote($3)
-        load_buffer_class( receiver )
-
-        cv = eval("self.class.constants")
-        vartype = get_var_type( receiver )
-        dprint "vartype: %s" % vartype
-
-        invalid_vartype = ['', "gets"]
-        if !invalid_vartype.include?(vartype)
-          load_buffer_class( vartype )
-
-          begin
-            methods = eval("#{vartype}.instance_methods")
-            variables = eval("#{vartype}.instance_variables")
-          rescue Exception
-            dprint "load_buffer_class err: %s" % $!
-          end
-        elsif (cv).include?(receiver)
-          # foo.func and foo is local var.
-          methods = eval("#{receiver}.methods")
-          vartype = receiver
-        elsif /^[A-Z]/ =~ receiver and /\./ !~ receiver
-          vartype = receiver
-          # Foo::Bar.func
-          begin
-            methods = eval("#{receiver}.methods")
-          rescue Exception
-          end
-        else
-          # func1.func2
-          ObjectSpace.each_object(Module){|m|
-            next if m.name != "IRB::Context" and
-              /^(IRB|SLex|RubyLex|RubyToken)/ =~ m.name
-            methods.concat m.instance_methods(false)
-          }
-        end
-        variables += add_rails_columns( "#{vartype}" ) if vartype && !invalid_vartype.include?(vartype)
-
-      when /^\(?\s*[A-Za-z0-9:^@.%\/+*\(\)]+\.\.\.?[A-Za-z0-9:^@.%\/+*\(\)]+\s*\)?\.([^.]*)/
-        message = $1
-        methods = Range.instance_methods(true)
-
-      when /^\.([^.]*)$/ # unknown(maybe String)
-        message = Regexp.quote($1)
-        methods = String.instance_methods(true)
-
-    else
-      dprint "default/other"
-      inclass = eval( VIM::evaluate("s:IsInClassDef()") )
-
-      if inclass != nil
-        dprint "inclass"
-        classdef = "%s\n" % VIM::Buffer.current[ inclass.min ]
-        found = /^\s*class\s*([A-Za-z0-9_-]*)(\s*<\s*([A-Za-z0-9_:-]*))?\s*\n$/.match( classdef )
-
-        if found != nil
-          receiver = $1
-          message = input
-          load_buffer_class( receiver )
-          begin
-            methods = eval( "#{receiver}.instance_methods" )
-            variables += add_rails_columns( "#{receiver}" )
-          rescue Exception
-            found = nil
-          end
-        end
-      end
-
-      if inclass == nil || found == nil
-        dprint "inclass == nil"
-        methods = get_buffer_methods
-        methods += get_rails_view_methods
-
-        cls_const = Class.constants
-        constants = cls_const.select { |c| /^[A-Z_-]+$/.match( c ) }
-        classes = eval("self.class.constants") - constants
-        classes += get_buffer_classes
-        classes += get_buffer_modules
-
-        include_objectspace = VIM::evaluate("exists('g:rubycomplete_include_objectspace') && g:rubycomplete_include_objectspace")
-        ObjectSpace.each_object(Class) { |cls| classes << cls.to_s } if include_objectspace == "1"
-        message = receiver = input
-      end
-
-      methods += get_rails_helpers
-      methods += Kernel.public_methods
-    end
-
-    include_object = VIM::evaluate("exists('g:rubycomplete_include_object') && g:rubycomplete_include_object")
-    methods = clean_sel( methods, message )
-    methods = (methods-Object.instance_methods) if include_object == "0"
-    rbcmeth = (VimRubyCompletion.instance_methods-Object.instance_methods) # lets remove those rubycomplete methods
-    methods = (methods-rbcmeth)
-
-    variables = clean_sel( variables, message )
-    classes = clean_sel( classes, message ) - ["VimRubyCompletion"]
-    constants = clean_sel( constants, message )
-
-    valid = []
-    valid += methods.collect { |m| { :name => m.to_s, :type => 'm' } }
-    valid += variables.collect { |v| { :name => v.to_s, :type => 'v' } }
-    valid += classes.collect { |c| { :name => c.to_s, :type => 't' } }
-    valid += constants.collect { |d| { :name => d.to_s, :type => 'd' } }
-    valid.sort! { |x,y| x[:name] <=> y[:name] }
-
-    outp = ""
-
-    rg = 0..valid.length
-    rg.step(150) do |x|
-      stpos = 0+x
-      enpos = 150+x
-      valid[stpos..enpos].each { |c| outp += "{'word':'%s','item':'%s','kind':'%s'}," % [ c[:name], c[:name], c[:type] ].map{|x|escape_vim_singlequote_string(x)} }
-      outp.sub!(/,$/, '')
-
-      VIM::command("call extend(g:rubycomplete_completions, [%s])" % outp)
-      outp = ""
-    end
-  end
-# }}} main completion code
-
-end # VimRubyCompletion
-# }}} ruby completion
-RUBYEOF
-endfunction
-
-let s:rubycomplete_rails_loaded = 0
-
-call s:DefRuby()
-"}}} ruby-side code
-
-" vim:tw=78:sw=4:ts=8:et:fdm=marker:ft=vim:norl:
diff --git a/sources_non_forked/vim-ruby/compiler/eruby.vim b/sources_non_forked/vim-ruby/compiler/eruby.vim
deleted file mode 100644
index cb42a71..0000000
--- a/sources_non_forked/vim-ruby/compiler/eruby.vim
+++ /dev/null
@@ -1,39 +0,0 @@
-" Vim compiler file
-" Language:		eRuby
-" Maintainer:		Doug Kearns <dougkearns@gmail.com>
-" URL:			https://github.com/vim-ruby/vim-ruby
-" Release Coordinator:	Doug Kearns <dougkearns@gmail.com>
-
-if exists("current_compiler")
-  finish
-endif
-let current_compiler = "eruby"
-
-if exists(":CompilerSet") != 2		" older Vim always used :setlocal
-  command -nargs=* CompilerSet setlocal <args>
-endif
-
-let s:cpo_save = &cpo
-set cpo-=C
-
-if exists("eruby_compiler") && eruby_compiler == "eruby"
-  CompilerSet makeprg=eruby
-else
-  CompilerSet makeprg=erb
-endif
-
-CompilerSet errorformat=
-    \eruby:\ %f:%l:%m,
-    \%+E%f:%l:\ parse\ error,
-    \%W%f:%l:\ warning:\ %m,
-    \%E%f:%l:in\ %*[^:]:\ %m,
-    \%E%f:%l:\ %m,
-    \%-C%\t%\\d%#:%#\ %#from\ %f:%l:in\ %.%#,
-    \%-Z%\t%\\d%#:%#\ %#from\ %f:%l,
-    \%-Z%p^,
-    \%-G%.%#
-
-let &cpo = s:cpo_save
-unlet s:cpo_save
-
-" vim: nowrap sw=2 sts=2 ts=8:
diff --git a/sources_non_forked/vim-ruby/compiler/rake.vim b/sources_non_forked/vim-ruby/compiler/rake.vim
deleted file mode 100644
index ba404c8..0000000
--- a/sources_non_forked/vim-ruby/compiler/rake.vim
+++ /dev/null
@@ -1,39 +0,0 @@
-" Vim compiler file
-" Language:		Rake
-" Maintainer:		Tim Pope <vimNOSPAM@tpope.org>
-" URL:			https://github.com/vim-ruby/vim-ruby
-" Release Coordinator:	Doug Kearns <dougkearns@gmail.com>
-
-if exists("current_compiler")
-  finish
-endif
-let current_compiler = "rake"
-
-if exists(":CompilerSet") != 2		" older Vim always used :setlocal
-  command -nargs=* CompilerSet setlocal <args>
-endif
-
-let s:cpo_save = &cpo
-set cpo-=C
-
-CompilerSet makeprg=rake
-
-CompilerSet errorformat=
-      \%D(in\ %f),
-      \%\\s%#%\\d%#:%#\ %#from\ %f:%l:%m,
-      \%\\s%#%\\d%#:%#\ %#from\ %f:%l:,
-      \%\\s%##\ %f:%l:%m%\\&%.%#%\\D:%\\d%\\+:%.%#,
-      \%\\s%##\ %f:%l%\\&%.%#%\\D:%\\d%\\+,
-      \%\\s%#[%f:%l:\ %#%m%\\&%.%#%\\D:%\\d%\\+:%.%#,
-      \%\\s%#%f:%l:\ %#%m%\\&%.%#%\\D:%\\d%\\+:%.%#,
-      \%\\s%#%f:%l:,
-      \%m\ [%f:%l]:,
-      \%+Erake\ aborted!,
-      \%+EDon't\ know\ how\ to\ build\ task\ %.%#,
-      \%+Einvalid\ option:%.%#,
-      \%+Irake\ %\\S%\\+%\\s%\\+#\ %.%#
-
-let &cpo = s:cpo_save
-unlet s:cpo_save
-
-" vim: nowrap sw=2 sts=2 ts=8:
diff --git a/sources_non_forked/vim-ruby/compiler/rspec.vim b/sources_non_forked/vim-ruby/compiler/rspec.vim
deleted file mode 100644
index 06e4de4..0000000
--- a/sources_non_forked/vim-ruby/compiler/rspec.vim
+++ /dev/null
@@ -1,35 +0,0 @@
-" Vim compiler file
-" Language:		RSpec
-" Maintainer:		Tim Pope <vimNOSPAM@tpope.org>
-" URL:			https://github.com/vim-ruby/vim-ruby
-" Release Coordinator:	Doug Kearns <dougkearns@gmail.com>
-
-if exists("current_compiler")
-  finish
-endif
-let current_compiler = "rspec"
-
-if exists(":CompilerSet") != 2		" older Vim always used :setlocal
-  command -nargs=* CompilerSet setlocal <args>
-endif
-
-let s:cpo_save = &cpo
-set cpo-=C
-
-CompilerSet makeprg=rspec
-
-CompilerSet errorformat=
-    \%f:%l:\ %tarning:\ %m,
-    \%E%.%#:in\ `load':\ %f:%l:%m,
-    \%E%f:%l:in\ `%*[^']':\ %m,
-    \%-Z\ \ \ \ \ %\\+\#\ %f:%l:%.%#,
-    \%E\ \ \ \ \ Failure/Error:\ %m,
-    \%E\ \ \ \ \ Failure/Error:,
-    \%C\ \ \ \ \ %m,
-    \%C%\\s%#,
-    \%-G%.%#
-
-let &cpo = s:cpo_save
-unlet s:cpo_save
-
-" vim: nowrap sw=2 sts=2 ts=8:
diff --git a/sources_non_forked/vim-ruby/compiler/ruby.vim b/sources_non_forked/vim-ruby/compiler/ruby.vim
deleted file mode 100644
index 64429a2..0000000
--- a/sources_non_forked/vim-ruby/compiler/ruby.vim
+++ /dev/null
@@ -1,44 +0,0 @@
-" Vim compiler file
-" Language:		Ruby
-" Function:		Syntax check and/or error reporting
-" Maintainer:		Tim Pope <vimNOSPAM@tpope.org>
-" URL:			https://github.com/vim-ruby/vim-ruby
-" Release Coordinator:	Doug Kearns <dougkearns@gmail.com>
-
-if exists("current_compiler")
-  finish
-endif
-let current_compiler = "ruby"
-
-if exists(":CompilerSet") != 2		" older Vim always used :setlocal
-  command -nargs=* CompilerSet setlocal <args>
-endif
-
-let s:cpo_save = &cpo
-set cpo-=C
-
-" default settings runs script normally
-" add '-c' switch to run syntax check only:
-"
-"   CompilerSet makeprg=ruby\ -c
-"
-" or add '-c' at :make command line:
-"
-"   :make -c %<CR>
-"
-CompilerSet makeprg=ruby
-
-CompilerSet errorformat=
-    \%+E%f:%l:\ parse\ error,
-    \%W%f:%l:\ warning:\ %m,
-    \%E%f:%l:in\ %*[^:]:\ %m,
-    \%E%f:%l:\ %m,
-    \%-C%\t%\\d%#:%#\ %#from\ %f:%l:in\ %.%#,
-    \%-Z%\t%\\d%#:%#\ %#from\ %f:%l,
-    \%-Z%p^,
-    \%-G%.%#
-
-let &cpo = s:cpo_save
-unlet s:cpo_save
-
-" vim: nowrap sw=2 sts=2 ts=8:
diff --git a/sources_non_forked/vim-ruby/compiler/rubyunit.vim b/sources_non_forked/vim-ruby/compiler/rubyunit.vim
deleted file mode 100644
index ed0639b..0000000
--- a/sources_non_forked/vim-ruby/compiler/rubyunit.vim
+++ /dev/null
@@ -1,35 +0,0 @@
-" Vim compiler file
-" Language:		Test::Unit - Ruby Unit Testing Framework
-" Maintainer:		Doug Kearns <dougkearns@gmail.com>
-" URL:			https://github.com/vim-ruby/vim-ruby
-" Release Coordinator:	Doug Kearns <dougkearns@gmail.com>
-
-if exists("current_compiler")
-  finish
-endif
-let current_compiler = "rubyunit"
-
-if exists(":CompilerSet") != 2		" older Vim always used :setlocal
-  command -nargs=* CompilerSet setlocal <args>
-endif
-
-let s:cpo_save = &cpo
-set cpo-=C
-
-CompilerSet makeprg=testrb
-" CompilerSet makeprg=ruby\ -Itest
-" CompilerSet makeprg=m
-
-CompilerSet errorformat=\%W\ %\\+%\\d%\\+)\ Failure:,
-			\%C%m\ [%f:%l]:,
-			\%E\ %\\+%\\d%\\+)\ Error:,
-			\%C%m:,
-			\%C\ \ \ \ %f:%l:%.%#,
-			\%C%m,
-			\%Z\ %#,
-			\%-G%.%#
-
-let &cpo = s:cpo_save
-unlet s:cpo_save
-
-" vim: nowrap sw=2 sts=2 ts=8:
diff --git a/sources_non_forked/vim-ruby/doc/ft-ruby-indent.txt b/sources_non_forked/vim-ruby/doc/ft-ruby-indent.txt
deleted file mode 100644
index 02f613e..0000000
--- a/sources_non_forked/vim-ruby/doc/ft-ruby-indent.txt
+++ /dev/null
@@ -1,109 +0,0 @@
-RUBY							*ft-ruby-indent*
-
-    Ruby: Access modifier indentation	|ruby-access-modifier-indentation|
-    Ruby: Block style indentation	|ruby-block-style-indentation|
-    Ruby: Assignment style indentation	|ruby-assignment-style-indentation|
-
-					*ruby-access-modifier-indentation*
-					*g:ruby_indent_access_modifier_style*
- Ruby: Access modifier indentation ~
-
-Different access modifier indentation styles can be used by setting: >
-
-	:let g:ruby_indent_access_modifier_style = 'normal'
-	:let g:ruby_indent_access_modifier_style = 'indent'
-	:let g:ruby_indent_access_modifier_style = 'outdent'
-<
-By default, the "normal" access modifier style is used.
-
-Access modifier style "normal":
->
-  class Indent
-    private :method
-    protected :method
-    private
-    def method; end
-    protected
-    def method; end
-    public
-    def method; end
-  end
-<
-Access modifier style "indent":
->
-  class Indent
-    private :method
-    protected :method
-    private
-      def method; end
-    protected
-      def method; end
-    public
-    def method; end
-  end
-<
-Access modifier style "outdent":
->
-  class Indent
-    private :method
-    protected :method
-  private
-    def method; end
-  protected
-    def method; end
-  public
-    def method; end
-  end
-<
-					*ruby-block-style-indentation*
-					*g:ruby_indent_block_style*
-    Ruby: Block style indentation ~
-
-Different block indentation styles can be used by setting: >
-
-    :let g:ruby_indent_block_style = 'expression'
-    :let g:ruby_indent_block_style = 'do'
-<
-By default, the "expression" block indent style is used.
-
-Block indent style "expression":
->
-    first
-      .second do |x|
-      something
-    end
-<
-Block indent style "do":
->
-    first
-      .second do |x|
-        something
-      end
-<
-
-					*ruby-assignment-style-indentation*
-					*g:ruby_indent_assignment_style*
-    Ruby: Assignment style indentation ~
-
-Different styles of indenting assignment for multiline expressions:
->
-    :let g:ruby_indent_assignment_style = 'hanging'
-    :let g:ruby_indent_assignment_style = 'variable'
-<
-By default, the "hanging" style is used.
-
-Assignment indent style "hanging":
->
-    x = if condition
-          something
-        end
-<
-Assignment indent style "variable":
->
-    x = if condition
-      something
-    end
-<
-
-
- vim:tw=78:sw=4:ts=8:ft=help:norl:
diff --git a/sources_non_forked/vim-ruby/doc/ft-ruby-omni.txt b/sources_non_forked/vim-ruby/doc/ft-ruby-omni.txt
deleted file mode 100644
index f678089..0000000
--- a/sources_non_forked/vim-ruby/doc/ft-ruby-omni.txt
+++ /dev/null
@@ -1,51 +0,0 @@
-RUBY							*ft-ruby-omni*
-
-Completion of Ruby code requires that Vim be built with |+ruby|.
-
-Ruby completion will parse your buffer on demand in order to provide a list of
-completions.  These completions will be drawn from modules loaded by "require"
-and modules defined in the current buffer.
-
-The completions provided by CTRL-X CTRL-O are sensitive to the context:
-
-          CONTEXT                          COMPLETIONS PROVIDED ~
-
- 1. Not inside a class definition    Classes, constants and globals
-
- 2. Inside a class definition        Methods or constants defined in the class
-
- 3. After '.', '::' or ':'           Methods applicable to the object being
-                                       dereferenced
-
- 4. After ':' or ':foo'              Symbol name (beginning with "foo")
-
-Notes:
- - Vim will load/evaluate code in order to provide completions.  This may
-   cause some code execution, which may be a concern.  This is no longer
-   enabled by default, to enable this feature add >
-     let g:rubycomplete_buffer_loading = 1
-< - In context 1 above, Vim can parse the entire buffer to add a list of
-   classes to the completion results.  This feature is turned off by default,
-   to enable it add >
-     let g:rubycomplete_classes_in_global = 1
-<   to your vimrc
- - In context 2 above, anonymous classes are not supported.
- - In context 3 above, Vim will attempt to determine the methods supported by
-   the object.
- - Vim can detect and load the Rails environment for files within a rails
-   project.  The feature is disabled by default, to enable it add >
-     let g:rubycomplete_rails = 1
-<   to your vimrc
- - Vim can parse a Gemfile, in case gems are being implicitly required.  To
-   activate the feature: >
-     let g:rubycomplete_load_gemfile = 1
-<   To specify an alternative path, use: >
-     let g:rubycomplete_gemfile_path = 'Gemfile.aux'
-<   To use Bundler.require instead of parsing the Gemfile, set: >
-     let g:rubycomplete_use_bundler = 1
-<   To use custom paths that should be added to $LOAD_PATH to correctly
-   resolve requires, set: >
-     let g:rubycomplete_load_paths = ["/path/to/code", "./lib/example"]
-
-
- vim:tw=78:sw=4:ts=8:ft=help:norl:
diff --git a/sources_non_forked/vim-ruby/doc/ft-ruby-plugin.txt b/sources_non_forked/vim-ruby/doc/ft-ruby-plugin.txt
deleted file mode 100644
index 527a8b6..0000000
--- a/sources_non_forked/vim-ruby/doc/ft-ruby-plugin.txt
+++ /dev/null
@@ -1,79 +0,0 @@
-RUBY							*ft-ruby-plugin*
-
-    Ruby: Recommended settings		|ruby-recommended|
-    Ruby: Motion commands		|ruby-motion|
-    Ruby: Text objects			|ruby-text-objects|
-
-							*ruby-recommended*
-							*g:ruby_recommended_style*
- Ruby: Recommended settings ~
-
-The `g:ruby_recommended_style` variable activates indentation settings
-according to the most common ruby convention: two spaces for indentation. It's
-turned on by default to ensure an unsurprising default experience for most
-ruby developers.
-
-If you'd like to enforce your own style, it's possible to apply your own
-preferences in your own configuration in `after/ftplugin/ruby.vim`. You can
-also disable the setting by setting the variable to 0:
->
-    let g:ruby_recommended_style = 0
-<
-
-							*ruby-motion*
- Ruby: Motion commands ~
-
-Vim provides motions such as |[m| and |]m| for jumping to the start or end of
-a method definition.  Out of the box, these work for curly-bracket languages,
-but not for Ruby.  The vim-ruby plugin enhances these motions, by making them
-also work on Ruby files.
-
-							*ruby-]m*
-]m			Go to start of next method definition.
-
-							*ruby-]M*
-]M			Go to end of next method definition.
-
-							*ruby-[m*
-[m			Go to start of previous method definition.
-
-							*ruby-[M*
-[M			Go to end of previous method definition.
-
-							*ruby-]]*
-]]			Go to start of next module or class definition.
-
-							*ruby-][*
-][			Go to end of next module or class definition.
-
-							*ruby-[[*
-[[			Go to start of previous module or class definition.
-
-							*ruby-[]*
-[]			Go to end of previous module or class definition.
-
-							*ruby-text-objects*
- Ruby: Text objects ~
-
-Vim's |text-objects| can be used to select or operate upon regions of text
-that are defined by structure.  The vim-ruby plugin adds text objects for
-operating on methods and classes.
-
-							*ruby-v_am* *ruby-am*
-am			"a method", select from "def" until matching "end"
-			keyword.
-
-							*ruby-v_im* *ruby-im*
-im			"inner method", select contents of "def"/"end" block,
-			excluding the "def" and "end" themselves.
-
-							*ruby-v_aM* *ruby-aM*
-aM			"a class", select from "class" until matching "end"
-			keyword.
-
-							*ruby-v_iM* *ruby-iM*
-iM			"inner class", select contents of "class"/"end"
-			block, excluding the "class" and "end" themselves.
-
-
- vim:tw=78:sw=4:ts=8:ft=help:norl:
diff --git a/sources_non_forked/vim-ruby/doc/ft-ruby-syntax.txt b/sources_non_forked/vim-ruby/doc/ft-ruby-syntax.txt
deleted file mode 100644
index 72c826a..0000000
--- a/sources_non_forked/vim-ruby/doc/ft-ruby-syntax.txt
+++ /dev/null
@@ -1,118 +0,0 @@
-RUBY						*ruby.vim* *ft-ruby-syntax*
-
-    Ruby: Operator highlighting		|ruby_operators|
-    Ruby: Whitespace errors		|ruby_space_errors|
-    Ruby: Syntax errors			|ruby_syntax_errors|
-    Ruby: Folding			|ruby_fold| |ruby_foldable_groups|
-    Ruby: Reducing expensive operations	|ruby_no_expensive| |ruby_minlines|
-    Ruby: Spellchecking strings		|ruby_spellcheck_strings|
-
-						*ruby_operators*
- Ruby: Operator highlighting ~
-
-Operators, and pseudo operators, can be highlighted by defining: >
-
-	:let ruby_operators        = 1
-	:let ruby_pseudo_operators = 1
-<
-The supported pseudo operators are ., &., ::, *, **, &, <, << and ->.
-
-						*ruby_space_errors*
- Ruby: Whitespace errors ~
-
-Whitespace errors can be highlighted by defining "ruby_space_errors": >
-
-	:let ruby_space_errors = 1
-<
-This will highlight trailing whitespace and tabs preceded by a space character
-as errors.  This can be refined by defining "ruby_no_trail_space_error" and
-"ruby_no_tab_space_error" which will ignore trailing whitespace and tabs after
-spaces respectively.
-
-						*ruby_syntax_errors*
- Ruby: Syntax errors ~
-
-Redundant line continuations and predefined global variable look-alikes (such
-as $# and $-z) can be highlighted as errors by defining:
->
-	:let ruby_line_continuation_error = 1
-	:let ruby_global_variable_error   = 1
-<
-						*ruby_fold*
- Ruby: Folding ~
-
-Folding can be enabled by defining "ruby_fold": >
-
-	:let ruby_fold = 1
-<
-This will set the value of 'foldmethod' to "syntax" locally to the current
-buffer or window, which will enable syntax-based folding when editing Ruby
-filetypes.
-
-						*ruby_foldable_groups*
-Default folding is rather detailed, i.e., small syntax units like "if", "do",
-"%w[]" may create corresponding fold levels.
-
-You can set "ruby_foldable_groups" to restrict which groups are foldable: >
-
-        :let ruby_foldable_groups = 'if case %'
-<
-The value is a space-separated list of keywords:
-
-    keyword       meaning ~
-    --------  ------------------------------------- ~
-    ALL        Most block syntax (default)
-    NONE       Nothing
-    if         "if" or "unless" block
-    def        "def" block
-    class      "class" block
-    module     "module" block
-    do         "do" block
-    begin      "begin" block
-    case       "case" block
-    for        "for", "while", "until" loops
-    {          Curly bracket block or hash literal
-    [          Array literal
-    %          Literal with "%" notation, e.g.: %w(STRING), %!STRING!
-    /          Regexp
-    string     String and shell command output (surrounded by ', ", `)
-    :          Symbol
-    #          Multiline comment
-    <<         Here documents
-    __END__    Source code after "__END__" directive
-
-NONE and ALL have priority, in that order, over all other folding groups.
-
-						*ruby_no_expensive*
- Ruby: Reducing expensive operations ~
-
-By default, the "end" keyword is colorized according to the opening statement
-of the block it closes.  While useful, this feature can be expensive; if you
-experience slow redrawing (or you are on a terminal with poor color support)
-you may want to turn it off by defining the "ruby_no_expensive" variable: >
-
-	:let ruby_no_expensive = 1
-<
-In this case the same color will be used for all control keywords.
-
-						*ruby_minlines*
-
-If you do want this feature enabled, but notice highlighting errors while
-scrolling backwards, which are fixed when redrawing with CTRL-L, try setting
-the "ruby_minlines" variable to a value larger than 50: >
-
-	:let ruby_minlines = 100
-<
-Ideally, this value should be a number of lines large enough to embrace your
-largest class or module.
-
-						*ruby_spellcheck_strings*
- Ruby: Spellchecking strings ~
-
-Ruby syntax will perform spellchecking of strings if you define
-"ruby_spellcheck_strings": >
-
-	:let ruby_spellcheck_strings = 1
-<
-
- vim:tw=78:sw=4:ts=8:ft=help:norl:
diff --git a/sources_non_forked/vim-ruby/etc/examples/generators/syntax.rb b/sources_non_forked/vim-ruby/etc/examples/generators/syntax.rb
deleted file mode 100644
index 06cf160..0000000
--- a/sources_non_forked/vim-ruby/etc/examples/generators/syntax.rb
+++ /dev/null
@@ -1,621 +0,0 @@
-#!/usr/bin/env ruby
-
-arg = ARGV.pop
-
-
-# Usage example:
-#
-#   ./etc/examples/generators/syntax.rb %Q > etc/examples/syntax/Q.rb
-#
-# then read the output file with 'foldlevel' 0
-
-puts "# Generated by `" <<
-     "./etc/examples/generators/syntax.rb #{arg}" <<
-     " > etc/examples/syntax/#{arg.sub('%', '')}.rb" <<
-     "`\n\n"
-
-
-
-# %Q {{{
-# Generalized Double Quoted String and Array of Strings and Shell Command Output
-if arg == '%Q'
-  # Note: %= is not matched here as the beginning of a double quoted string
-  %Q[~`!@\#$%^&*_-+|:;"',.?/].split(//).each do |s|
-    puts <<-END.gsub(/^\s{4}/, '')
-      %#{s}
-        foo
-        \\#{s}
-        \\\\\\#{s}
-        bar
-      #{s}
-
-
-    END
-  end
-
-  %w(Q W x).each do |leading|
-    %Q[~`!@\#$%^&*_-+=|:;"',.?/].split(//).each do |s|
-      puts <<-END.gsub(/^\s{6}/, '')
-        %#{leading}#{s}
-          foo
-          \\#{s}
-          \\\\\\#{s}
-          bar
-        #{s}
-
-
-      END
-    end
-
-    %w({} <> [] ()).each do |pair|
-      puts <<-END.gsub(/^\s{6}/, '')
-        %#{leading}#{pair[0]}
-          foo
-          \\#{pair[1]}
-          \\\\\\#{pair[1]}
-          bar
-        #{pair[1]}
-
-
-      END
-    end
-
-    puts "  %#{leading} foo\\ \\\\\\ bar\nbaz \n\n" unless leading == 'W'
-  end
-end
-# }}}
-
-
-
-# %q {{{
-# Generalized Single Quoted String, Symbol and Array of Strings
-if arg == '%q'
-  %w(q w s).each do |leading|
-    %Q[~`!@\#$%^&*_-+=|:;"',.?/].split(//).each do |s|
-      puts <<-END.gsub(/^\s{6}/, '')
-        %#{leading}#{s}
-          foo
-          \\#{s}
-          \\\\\\#{s}
-          bar
-        #{s}
-
-
-      END
-    end
-
-    %w({} <> [] ()).each do |pair|
-      puts <<-END.gsub(/^\s{6}/, '')
-        %#{leading}#{pair[0]}
-          foo
-          \\#{pair[1]}
-          \\\\\\#{pair[1]}
-          bar
-        #{pair[1]}
-
-
-      END
-    end
-
-    puts "  %#{leading} foo\\ \\\\\\ bar\nbaz \n\n" unless leading == 'w'
-  end
-end
-# }}}
-
-
-
-# %r {{{
-# Generalized Regular Expression
-if arg == '%r'
-  %Q[~`!@\#$%^&*_-+=|:;"',.?/].split(//).each do |s|
-    puts <<-END.gsub(/^\s{4}/, '')
-      %r#{s}
-        foo
-        \\#{s}
-        \\\\\\#{s}
-        bar
-      #{s}
-
-
-    END
-  end
-
-  puts "  %r foo\\ \\\\\\ bar\nbaz \n\n"
-
-  %w({} <> [] ()).each do |pair|
-    puts <<-END.gsub(/^\s{4}/, '')
-      %r#{pair[0]}
-        foo
-        \\#{pair[1]}
-        \\\\\\#{pair[1]}
-        bar
-      #{pair[1]}
-
-
-    END
-  end
-end
-# }}}
-
-
-
-# %i / %I {{{
-# Array of Symbols
-# Array of interpolated Symbols
-if %w(%i %I).include?(arg)
-  %w(i I).each do |leading|
-    %Q[~`!@\#$%^&*_-+=|:;"',.?/].split(//).each do |s|
-      puts <<-END.gsub(/^\s{6}/, '')
-        %#{leading}#{s}
-          foo
-          \\#{s}
-          \\\\\\#{s}
-          bar
-        #{s}
-
-
-      END
-    end
-
-    %w({} <> [] ()).each do |pair|
-      puts <<-END.gsub(/^\s{6}/, '')
-        %#{leading}#{pair[0]}
-          foo
-          \\#{pair[1]}
-          \\\\\\#{pair[1]}
-          bar
-        #{pair[1]}
-
-
-      END
-    end
-  end
-end
-# }}}
-
-
-
-# string  {{{
-# Normal String and Shell Command Output
-if arg == 'string'
-  %w(' " `).each do |quote|
-    puts <<-END.gsub(/^\s{4}/, '')
-      #{quote}
-        foo
-        \\#{quote}
-        \\\\\\#{quote}
-        bar
-      #{quote}
-
-
-    END
-  end
-end
-# }}}
-
-
-
-# regex (Normal Regular Expression) {{{
-if arg == 'regexp'
-  'iomxneus'.split('').unshift('').each do |option|
-    puts "\n# Begin test for option '#{option}' {{{\n\n"
-
-    puts <<-END.gsub(/^\s{4}/, '')
-        /
-          foo
-          \\\/
-          \\\\\\\/
-          bar
-        /#{option}
-
-
-    END
-
-    %w(and or while until unless if elsif when not then else).each do |s|
-      puts <<-END.gsub(/^\s{6}/, '')
-        #{s}/
-          foo
-          \\\/
-          \\\\\\\/
-          bar
-        /#{option}
-
-
-      END
-    end
-
-    %w(; \ ~ = ! | \( & , { [ < > ? : * + -).each do |s|
-      puts <<-END.gsub(/^\s{6}/, '')
-        #{s}/
-          foo
-          \\\/
-          \\\\\\\/
-          bar
-        /#{option}
-
-
-      END
-    end
-
-    [' ', "\t", '=', 'OK'].each do |s|
-      puts <<-END.gsub(/^\s{6}/, '')
-        _foo  /#{s}
-          foo
-          \\\/
-          \\\\\\\/
-          bar
-        /#{option}
-
-
-      END
-    end
-
-    puts "# }}} End test for option '#{option}'\n"
-  end
-
-  puts "\n# Test for ternary operation (8c1c484) {{{\n\n"
-  puts 'yo = 4 ? /quack#{3}/ : /quack/'
-  puts "\n# }}} End test for ternary operation\n"
-end
-# }}}
-
-
-
-# symbol {{{
-# Symbol region
-if arg == 'symbol'
-  %w(' ").each do |quote|
-    %Q_]})\"':_.split(//).unshift('').each do |s|
-      puts <<-END.gsub(/^\s{6}/, '')
-        #{s}:#{quote}
-          foo
-          \\#{quote}
-          \\\\\\#{quote}
-          bar
-        #{quote}
-      #{"  #{s} # close string to ensure next case clean" if %w(' ").include?(s) && s != quote }
-
-
-      END
-    end
-  end
-end
-# }}}
-
-
-
-# heredoc {{{
-# Here Documents
-if arg == 'heredoc'
-  puts "\n# Begin of valid cases {{{\n\n"
-
-  %w(' " `).unshift('').each do |quote|
-    puts <<-END.gsub(/^\s{6}/, '')
-        <<#{quote}_LABEL#{quote}.?!, foo
-          bar baz
-      _LABEL
-      \n
-
-        <<-#{quote}_LABEL#{quote}.?!, foo
-          bar baz
-        _LABEL
-      \n
-
-          <<~#{quote}_LABEL#{quote}.?!, foo
-            bar baz
-          _LABEL
-
-
-    END
-  end
-
-  puts "# }}} End of valid cases'\n\n"
-
-
-  puts "\n# Begin of INVALID cases {{{\n\n"
-
-  # NOTE: for simplification, omit test for different quotes " ' `,
-  # they are all invalid anyway
-
-  %w(class ::).each do |s|
-    puts <<-END.gsub(/^\s{6}/, '')
-      #{s}\n <<LABEL
-        foo
-      LABEL
-
-
-    END
-  end
-
-  %Q_]})\"'._.split(//).each do |s|
-    puts <<-END.gsub(/^\s{4}/, '')
-    #{s} <<LABEL
-      foo
-    LABEL
-    #{"  #{s} # close to ensure next case clean" if %w(' ").include?(s)}
-
-    END
-  end
-
-  %w(09 aZ _w).each do |s|
-    puts <<-END.gsub(/^\s{6}/, '')
-      #{s}<<LABEL
-        foo
-      LABEL
-
-
-    END
-  end
-
-  %w(' " `).unshift('').each do |quote|
-    puts <<-END.gsub(/^\s{6}/, '')
-      <<LABEL foo<<#{quote}_bar
-        baz
-      LABEL
-      #{"  #{quote} # close to ensure next case clean" if %w(' ").include?(quote)}
-      \n
-
-      <<LABEL foo<<-#{quote}_bar
-        baz
-      LABEL
-      #{"  #{quote} # close to ensure next case clean" if %w(' ").include?(quote)}
-
-
-    END
-  end
-
-  puts "# }}} End of INVALID cases'\n\n"
-end
-# }}}
-
-
-
-# blocks  {{{
-# simple blocks (def, class, module, do, begin, case)
-if arg == 'blocks'
-  puts <<-END.gsub(/^\s{4}/, '')
-    def
-      foo
-      def
-        bar
-      end
-    end
-
-
-  END
-
-  %w(class module do begin case).each do |s|
-    puts <<-END.gsub(/^\s{6}/, '')
-      #{s}
-        foo
-      end
-
-
-    END
-  end
-end
-# }}}
-
-
-
-# brackets  {{{
-# curly bracket block and hash literal
-if arg == 'brackets'
-  puts <<-END.gsub(/^\s{4}/, '')
-    {
-      foo
-    }
-
-
-  END
-
-  %w<_xxx ] } )>.unshift('').each do |s|
-    puts <<-END.gsub(/^\s{6}/, '')
-      #{s}[
-        foo
-      ]
-
-
-    END
-  end
-end
-# }}}
-
-
-
-# if {{{
-# if/else blocks
-if arg == 'if'
-  %w(if unless).each do |start|
-    puts <<-END.gsub(/^ {6}/, '')
-      #{start} 1
-        foo
-      else
-        bar
-      end
-
-      foo \\
-        #{start} 1
-          foo
-        else
-          bar
-        end
-
-      baz ...= #{start} 1
-        foo
-      else
-        bar
-      end
-
-
-    END
-
-    ['?', '!'].each do |mark|
-      puts <<-END.gsub(/^ {8}/, '')
-        42foo#{mark} #{start} 1
-          bar
-        else
-          baz
-        end
-
-
-      END
-    end
-
-    '{:,;([<>~\*%&^|+=-'.split(//).each do |expr|
-      puts <<-END.gsub(/^ {8}/, '')
-        foo #{expr} #{start} 1
-          bar
-        else
-          baz
-        end
-
-
-      END
-    end
-
-    # c7cb532 match correct `end`
-    puts <<-END.gsub(/^ {6}/, '')
-      #{start} 1
-        (1..5).end
-        :: end
-      end
-
-      #{start} 1
-      ..end
-
-
-    END
-
-    # INVALID cases
-    puts <<-END.gsub(/^ {6}/, '')
-      not_BOF #{start} 1
-        bar
-      else
-        baz
-      end
-
-
-    END
-
-    ['?', '!'].each do |mark|
-      puts <<-END.gsub(/^ {8}/, '')
-        _foo#{mark} #{start} 1
-          bar
-        else
-          baz
-        end
-
-
-      END
-    end
-  end
-end
-# }}}
-
-
-
-# for {{{
-# rubyRepeatExpression (for, while, until)
-if arg == 'for'
-  puts <<-END.gsub(/^ {4}/, '')
-    for 1
-      foo
-    end
-
-
-  END
-
-  %w(until while).each do |start|
-    puts <<-END.gsub(/^ {6}/, '')
-      #{start} 1
-        foo
-      end
-
-
-      baz ...= #{start} 1
-        foo
-      end
-
-
-    END
-
-    '{:,;([<>~\*/%&^|+-'.split(//).each do |expr|
-      puts <<-END.gsub(/^ {8}/, '')
-        foo #{expr} #{start} 1
-          bar
-        end
-
-
-      END
-    end
-
-    # INVALID cases
-    puts <<-END.gsub(/^ {6}/, '')
-      not_BOF #{start} 1
-        bar
-      end
-
-
-    END
-
-    ['?', '!'].each do |mark|
-      puts <<-END.gsub(/^ {8}/, '')
-        _foo#{mark} #{start} 1
-          bar
-        end
-
-
-      END
-    end
-  end
-end
-# }}}
-
-
-
-# comment {{{
-if arg == 'comment'
-  puts <<-END.gsub(/^ {4}/, '')
-      # foo
-      # foo
-        # bar
-
-      baz
-
-
-
-    =begin foo bar
-      comment
-    =end baz
-
-
-  END
-end
-# }}}
-
-
-
-# __END__ {{{
-if arg == '__END__'
-  puts <<-EOF.gsub(/^ {4}/, '')
-      __END__
-      invalid
-      invalid
-
-
-    __END__
-      valid
-      valid
-
-
-  EOF
-end
-# }}}
-
-
-
-puts "#\svim:foldmethod=syntax"
-
-
-# vim:foldmethod=marker
diff --git a/sources_non_forked/vim-ruby/etc/examples/indent/closing_brackets.rb b/sources_non_forked/vim-ruby/etc/examples/indent/closing_brackets.rb
deleted file mode 100644
index 46c4afd..0000000
--- a/sources_non_forked/vim-ruby/etc/examples/indent/closing_brackets.rb
+++ /dev/null
@@ -1,16 +0,0 @@
-[1, [2,
-     [3],
-     3],
-     4]
-
-[1, [2,
-     3],
-     4]
-
-[1, {2 =>
-     3},
-       4]
-
-[1, f(2,
-      3),
-      4]
diff --git a/sources_non_forked/vim-ruby/ftdetect/ruby.vim b/sources_non_forked/vim-ruby/ftdetect/ruby.vim
deleted file mode 100644
index e11cfad..0000000
--- a/sources_non_forked/vim-ruby/ftdetect/ruby.vim
+++ /dev/null
@@ -1,42 +0,0 @@
-" Officially distributed filetypes
-
-" Support functions {{{
-function! s:setf(filetype) abort
-  if &filetype !~# '\<'.a:filetype.'\>'
-    let &filetype = a:filetype
-  endif
-endfunction
-
-func! s:StarSetf(ft)
-  if expand("<amatch>") !~ g:ft_ignore_pat
-    exe 'setf ' . a:ft
-  endif
-endfunc
-" }}}
-
-" HTML with Ruby - eRuby
-au BufNewFile,BufRead *.erb,*.rhtml				call s:setf('eruby')
-
-" Interactive Ruby shell
-au BufNewFile,BufRead .irbrc,irbrc				call s:setf('ruby')
-
-" Ruby
-au BufNewFile,BufRead *.rb,*.rbw,*.gemspec			call s:setf('ruby')
-
-" Rackup
-au BufNewFile,BufRead *.ru					call s:setf('ruby')
-
-" Bundler
-au BufNewFile,BufRead Gemfile					call s:setf('ruby')
-
-" Ruby on Rails
-au BufNewFile,BufRead *.builder,*.rxml,*.rjs,*.ruby		call s:setf('ruby')
-
-" Rakefile
-au BufNewFile,BufRead [rR]akefile,*.rake			call s:setf('ruby')
-au BufNewFile,BufRead [rR]akefile*				call s:StarSetf('ruby')
-
-" Rantfile
-au BufNewFile,BufRead [rR]antfile,*.rant			call s:setf('ruby')
-
-" vim: nowrap sw=2 sts=2 ts=8 noet fdm=marker:
diff --git a/sources_non_forked/vim-ruby/ftdetect/ruby_extra.vim b/sources_non_forked/vim-ruby/ftdetect/ruby_extra.vim
deleted file mode 100644
index 68e1567..0000000
--- a/sources_non_forked/vim-ruby/ftdetect/ruby_extra.vim
+++ /dev/null
@@ -1,69 +0,0 @@
-" All other filetypes
-
-" Support functions {{{
-function! s:setf(filetype) abort
-  if &filetype !=# a:filetype
-    let &filetype = a:filetype
-  endif
-endfunction
-" }}}
-
-" Appraisal
-au BufNewFile,BufRead Appraisals		call s:setf('ruby')
-
-" Autotest
-au BufNewFile,BufRead .autotest			call s:setf('ruby')
-
-" Axlsx
-au BufNewFile,BufRead *.axlsx			call s:setf('ruby')
-
-" Buildr Buildfile
-au BufNewFile,BufRead [Bb]uildfile		call s:setf('ruby')
-
-" Capistrano
-au BufNewFile,BufRead Capfile,*.cap		call s:setf('ruby')
-
-" Chef
-au BufNewFile,BufRead Cheffile			call s:setf('ruby')
-au BufNewFile,BufRead Berksfile			call s:setf('ruby')
-
-" CocoaPods
-au BufNewFile,BufRead Podfile,*.podspec		call s:setf('ruby')
-
-" Guard
-au BufNewFile,BufRead Guardfile,.Guardfile	call s:setf('ruby')
-
-" Jbuilder
-au BufNewFile,BufRead *.jbuilder		call s:setf('ruby')
-
-" Kitchen Sink
-au BufNewFile,BufRead KitchenSink		call s:setf('ruby')
-
-" Opal
-au BufNewFile,BufRead *.opal			call s:setf('ruby')
-
-" Pry config
-au BufNewFile,BufRead .pryrc			call s:setf('ruby')
-
-" Puppet librarian
-au BufNewFile,BufRead Puppetfile		call s:setf('ruby')
-
-" Rabl
-au BufNewFile,BufRead *.rabl			call s:setf('ruby')
-
-" Routefile
-au BufNewFile,BufRead [rR]outefile		call s:setf('ruby')
-
-" SimpleCov
-au BufNewFile,BufRead .simplecov		call s:setf('ruby')
-
-" Sorbet RBI files
-au BufNewFile,BufRead *.rbi		        call s:setf('ruby')
-
-" Thor
-au BufNewFile,BufRead [tT]horfile,*.thor	call s:setf('ruby')
-
-" Vagrant
-au BufNewFile,BufRead [vV]agrantfile		call s:setf('ruby')
-
-" vim: nowrap sw=2 sts=2 ts=8 noet fdm=marker:
diff --git a/sources_non_forked/vim-ruby/ftplugin/eruby.vim b/sources_non_forked/vim-ruby/ftplugin/eruby.vim
deleted file mode 100644
index 6d6e616..0000000
--- a/sources_non_forked/vim-ruby/ftplugin/eruby.vim
+++ /dev/null
@@ -1,131 +0,0 @@
-" Vim filetype plugin
-" Language:		eRuby
-" Maintainer:		Tim Pope <vimNOSPAM@tpope.org>
-" URL:			https://github.com/vim-ruby/vim-ruby
-" Release Coordinator:	Doug Kearns <dougkearns@gmail.com>
-
-" Only do this when not done yet for this buffer
-if exists("b:did_ftplugin")
-  finish
-endif
-
-let s:save_cpo = &cpo
-set cpo-=C
-
-" Define some defaults in case the included ftplugins don't set them.
-let s:undo_ftplugin = ""
-let s:browsefilter = "All Files (*.*)\t*.*\n"
-let s:match_words = ""
-
-if !exists("g:eruby_default_subtype")
-  let g:eruby_default_subtype = "html"
-endif
-
-if &filetype =~ '^eruby\.'
-  let b:eruby_subtype = matchstr(&filetype,'^eruby\.\zs\w\+')
-elseif !exists("b:eruby_subtype")
-  let s:lines = getline(1)."\n".getline(2)."\n".getline(3)."\n".getline(4)."\n".getline(5)."\n".getline("$")
-  let b:eruby_subtype = matchstr(s:lines,'eruby_subtype=\zs\w\+')
-  if b:eruby_subtype == ''
-    let b:eruby_subtype = matchstr(substitute(expand("%:t"),'\c\%(\.erb\|\.eruby\|\.erubis\|\.example\)\+$','',''),'\.\zs\w\+\%(\ze+\w\+\)\=$')
-  endif
-  if b:eruby_subtype == 'rhtml'
-    let b:eruby_subtype = 'html'
-  elseif b:eruby_subtype == 'rb'
-    let b:eruby_subtype = 'ruby'
-  elseif b:eruby_subtype == 'yml'
-    let b:eruby_subtype = 'yaml'
-  elseif b:eruby_subtype == 'js'
-    let b:eruby_subtype = 'javascript'
-  elseif b:eruby_subtype == 'txt'
-    " Conventional; not a real file type
-    let b:eruby_subtype = 'text'
-  elseif b:eruby_subtype == ''
-    let b:eruby_subtype = g:eruby_default_subtype
-  endif
-endif
-
-if exists("b:eruby_subtype") && b:eruby_subtype != '' && b:eruby_subtype !=? 'eruby'
-  exe "runtime! ftplugin/".b:eruby_subtype.".vim ftplugin/".b:eruby_subtype."_*.vim ftplugin/".b:eruby_subtype."/*.vim"
-else
-  runtime! ftplugin/html.vim ftplugin/html_*.vim ftplugin/html/*.vim
-endif
-unlet! b:did_ftplugin
-
-" Override our defaults if these were set by an included ftplugin.
-if exists("b:undo_ftplugin")
-  let s:undo_ftplugin = b:undo_ftplugin
-  unlet b:undo_ftplugin
-endif
-if exists("b:browsefilter")
-  let s:browsefilter = b:browsefilter
-  unlet b:browsefilter
-endif
-if exists("b:match_words")
-  let s:match_words = b:match_words
-  unlet b:match_words
-endif
-
-let s:cfilemap = v:version >= 704 ? maparg('<Plug><cfile>', 'c', 0, 1) : {}
-if !get(s:cfilemap, 'buffer') || !s:cfilemap.expr || s:cfilemap.rhs =~# 'ErubyAtCursor()'
-  let s:cfilemap = {}
-endif
-if !has_key(s:cfilemap, 'rhs')
-  let s:cfilemap.rhs = "substitute(&l:inex =~# '\\<v:fname\\>' && len(expand('<cfile>')) ? eval(substitute(&l:inex, '\\<v:fname\\>', '\\=string(expand(\"<cfile>\"))', 'g')) : '', '^$', \"\\022\\006\",'')"
-endif
-let s:ctagmap = v:version >= 704 ? maparg('<Plug><ctag>', 'c', 0, 1) : {}
-if !get(s:ctagmap, 'buffer') || !s:ctagmap.expr || s:ctagmap.rhs =~# 'ErubyAtCursor()'
-  let s:ctagmap = {}
-endif
-let s:include = &l:include
-let s:path = &l:path
-let s:suffixesadd = &l:suffixesadd
-
-runtime! ftplugin/ruby.vim ftplugin/ruby_*.vim ftplugin/ruby/*.vim
-let b:did_ftplugin = 1
-
-" Combine the new set of values with those previously included.
-if exists("b:undo_ftplugin")
-  let s:undo_ftplugin = b:undo_ftplugin . " | " . s:undo_ftplugin
-endif
-if exists ("b:browsefilter")
-  let s:browsefilter = substitute(b:browsefilter,'\cAll Files (\*\.\*)\t\*\.\*\n','','') . s:browsefilter
-endif
-if exists("b:match_words")
-  let s:match_words = b:match_words . ',' . s:match_words
-endif
-
-if len(s:include)
-  let &l:include = s:include
-endif
-let &l:path = s:path . (s:path =~# ',$\|^$' ? '' : ',') . &l:path
-let &l:suffixesadd = s:suffixesadd . (s:suffixesadd =~# ',$\|^$' ? '' : ',') . &l:suffixesadd
-exe 'cmap <buffer><script><expr> <Plug><cfile> ErubyAtCursor() ? ' . maparg('<Plug><cfile>', 'c') . ' : ' . s:cfilemap.rhs
-exe 'cmap <buffer><script><expr> <Plug><ctag> ErubyAtCursor() ? ' . maparg('<Plug><ctag>', 'c') . ' : ' . get(s:ctagmap, 'rhs', '"\022\027"')
-unlet s:cfilemap s:ctagmap s:include s:path s:suffixesadd
-
-" Change the browse dialog on Win32 to show mainly eRuby-related files
-if has("gui_win32")
-  let b:browsefilter="eRuby Files (*.erb, *.rhtml)\t*.erb;*.rhtml\n" . s:browsefilter
-endif
-
-" Load the combined list of match_words for matchit.vim
-if exists("loaded_matchit")
-  let b:match_words = s:match_words
-endif
-
-" TODO: comments=
-setlocal commentstring=<%#%s%>
-
-let b:undo_ftplugin = "setl cms< "
-      \ " | unlet! b:browsefilter b:match_words | " . s:undo_ftplugin
-
-let &cpo = s:save_cpo
-unlet s:save_cpo
-
-function! ErubyAtCursor() abort
-  let groups = map(['erubyBlock', 'erubyComment', 'erubyExpression', 'erubyOneLiner'], 'hlID(v:val)')
-  return !empty(filter(synstack(line('.'), col('.')), 'index(groups, v:val) >= 0'))
-endfunction
-
-" vim: nowrap sw=2 sts=2 ts=8:
diff --git a/sources_non_forked/vim-ruby/ftplugin/ruby.vim b/sources_non_forked/vim-ruby/ftplugin/ruby.vim
deleted file mode 100644
index 8145728..0000000
--- a/sources_non_forked/vim-ruby/ftplugin/ruby.vim
+++ /dev/null
@@ -1,436 +0,0 @@
-" Vim filetype plugin
-" Language:		Ruby
-" Maintainer:		Tim Pope <vimNOSPAM@tpope.org>
-" URL:			https://github.com/vim-ruby/vim-ruby
-" Release Coordinator:	Doug Kearns <dougkearns@gmail.com>
-
-if (exists("b:did_ftplugin"))
-  finish
-endif
-let b:did_ftplugin = 1
-
-let s:cpo_save = &cpo
-set cpo&vim
-
-if has("gui_running") && !has("gui_win32")
-  setlocal keywordprg=ri\ -T\ -f\ bs
-else
-  setlocal keywordprg=ri
-endif
-
-" Matchit support
-if exists("loaded_matchit") && !exists("b:match_words")
-  let b:match_ignorecase = 0
-
-  let b:match_words =
-	\ '{\|\<\%(if\|unless\|case\|while\|until\|for\|do\|class\|module\|def\|=\@<!begin\)\>=\@!' .
-	\ ':' .
-	\ '\<\%(else\|elsif\|ensure\|when\|rescue\|break\|redo\|next\|retry\)\>' .
-	\ ':' .
-        \ '}\|\%(^\|[^.\:@$=]\)\@<=\<end\:\@!\>' .
-        \ ',^=begin\>:^=end\>,' .
-	\ ',\[:\],(:)'
-
-  let b:match_skip =
-	\ "synIDattr(synID(line('.'),col('.'),0),'name') =~ '" .
-	\ "\\<ruby\\%(String\\|.\+Delimiter\\|Character\\|.\+Escape\\|" .
-        \ "Regexp\\|Interpolation\\|Comment\\|Documentation\\|" .
-	\ "ConditionalModifier\\|RepeatModifier\\|RescueModifier\\|OptionalDo\\|" .
-	\ "MethodName\\|BlockArgument\\|KeywordAsMethod\\|ClassVariable\\|" .
-	\ "InstanceVariable\\|GlobalVariable\\|Symbol\\)\\>'"
-endif
-
-setlocal formatoptions-=t formatoptions+=croql
-
-setlocal include=^\\s*\\<\\(load\\>\\\|require\\>\\\|autoload\\s*:\\=[\"']\\=\\h\\w*[\"']\\=,\\)
-setlocal suffixesadd=.rb
-
-if exists("&ofu") && has("ruby")
-  setlocal omnifunc=rubycomplete#Complete
-endif
-
-" TODO:
-"setlocal define=^\\s*def
-
-setlocal comments=:#
-setlocal commentstring=#\ %s
-
-if !exists('g:ruby_version_paths')
-  let g:ruby_version_paths = {}
-endif
-
-function! s:query_path(root) abort
-  let code = "print $:.join %q{,}"
-  if &shell =~# 'sh' && empty(&shellxquote)
-    let prefix = 'env PATH='.shellescape($PATH).' '
-  else
-    let prefix = ''
-  endif
-  if &shellxquote == "'"
-    let path_check = prefix.'ruby --disable-gems -e "' . code . '"'
-  else
-    let path_check = prefix."ruby --disable-gems -e '" . code . "'"
-  endif
-
-  let cd = haslocaldir() ? 'lcd' : 'cd'
-  let cwd = fnameescape(getcwd())
-  try
-    exe cd fnameescape(a:root)
-    let path = split(system(path_check),',')
-    exe cd cwd
-    return path
-  finally
-    exe cd cwd
-  endtry
-endfunction
-
-function! s:build_path(path) abort
-  let path = join(map(copy(a:path), 'v:val ==# "." ? "" : v:val'), ',')
-  if &g:path !~# '\v^%(\.,)=%(/%(usr|emx)/include,)=,$'
-    let path = substitute(&g:path,',,$',',','') . ',' . path
-  endif
-  return path
-endfunction
-
-if !exists('b:ruby_version') && !exists('g:ruby_path') && isdirectory(expand('%:p:h'))
-  let s:version_file = findfile('.ruby-version', '.;')
-  if !empty(s:version_file) && filereadable(s:version_file)
-    let b:ruby_version = get(readfile(s:version_file, '', 1), '')
-    if !has_key(g:ruby_version_paths, b:ruby_version)
-      let g:ruby_version_paths[b:ruby_version] = s:query_path(fnamemodify(s:version_file, ':p:h'))
-    endif
-  endif
-endif
-
-if exists("g:ruby_path")
-  let s:ruby_path = type(g:ruby_path) == type([]) ? join(g:ruby_path, ',') : g:ruby_path
-elseif has_key(g:ruby_version_paths, get(b:, 'ruby_version', ''))
-  let s:ruby_paths = g:ruby_version_paths[b:ruby_version]
-  let s:ruby_path = s:build_path(s:ruby_paths)
-else
-  if !exists('g:ruby_default_path')
-    if has("ruby") && has("win32")
-      ruby ::VIM::command( 'let g:ruby_default_path = split("%s",",")' % $:.join(%q{,}) )
-    elseif executable('ruby') && !empty($HOME)
-      let g:ruby_default_path = s:query_path($HOME)
-    else
-      let g:ruby_default_path = map(split($RUBYLIB,':'), 'v:val ==# "." ? "" : v:val')
-    endif
-  endif
-  let s:ruby_paths = g:ruby_default_path
-  let s:ruby_path = s:build_path(s:ruby_paths)
-endif
-
-if stridx(&l:path, s:ruby_path) == -1
-  let &l:path = s:ruby_path
-endif
-if exists('s:ruby_paths') && stridx(&l:tags, join(map(copy(s:ruby_paths),'v:val."/tags"'),',')) == -1
-  let &l:tags = &tags . ',' . join(map(copy(s:ruby_paths),'v:val."/tags"'),',')
-endif
-
-if (has("gui_win32") || has("gui_gtk")) && !exists("b:browsefilter")
-  let b:browsefilter = "Ruby Source Files (*.rb)\t*.rb\n" .
-                     \ "All Files (*.*)\t*.*\n"
-endif
-
-let b:undo_ftplugin = "setl inc= sua= path= tags= fo< com< cms< kp="
-      \."| unlet! b:browsefilter b:match_ignorecase b:match_words b:match_skip"
-      \."| if exists('&ofu') && has('ruby') | setl ofu< | endif"
-
-if get(g:, 'ruby_recommended_style', 1)
-  setlocal shiftwidth=2 softtabstop=2 expandtab
-  let b:undo_ftplugin .= ' | setl sw< sts< et<'
-endif
-
-" To activate, :set ballooneval
-if exists('+balloonexpr') && get(g:, 'ruby_balloonexpr')
-  setlocal balloonexpr=RubyBalloonexpr()
-  let b:undo_ftplugin .= "| setl bexpr="
-endif
-
-function! s:map(mode, flags, map) abort
-  let from = matchstr(a:map, '\S\+')
-  if empty(mapcheck(from, a:mode))
-    exe a:mode.'map' '<buffer>' a:flags a:map
-    let b:undo_ftplugin .= '|sil! '.a:mode.'unmap <buffer> '.from
-  endif
-endfunction
-
-cmap <buffer><script><expr> <Plug><ctag> substitute(RubyCursorTag(),'^$',"\022\027",'')
-cmap <buffer><script><expr> <Plug><cfile> substitute(RubyCursorFile(),'^$',"\022\006",'')
-let b:undo_ftplugin .= "| sil! cunmap <buffer> <Plug><ctag>| sil! cunmap <buffer> <Plug><cfile>"
-
-if !exists("g:no_plugin_maps") && !exists("g:no_ruby_maps")
-  nmap <buffer><script> <SID>:  :<C-U>
-  nmap <buffer><script> <SID>c: :<C-U><C-R>=v:count ? v:count : ''<CR>
-
-  nnoremap <silent> <buffer> [m :<C-U>call <SID>searchsyn('\<def\>',['rubyDefine'],'b','n')<CR>
-  nnoremap <silent> <buffer> ]m :<C-U>call <SID>searchsyn('\<def\>',['rubyDefine'],'','n')<CR>
-  nnoremap <silent> <buffer> [M :<C-U>call <SID>searchsyn('\<end\>',['rubyDefine'],'b','n')<CR>
-  nnoremap <silent> <buffer> ]M :<C-U>call <SID>searchsyn('\<end\>',['rubyDefine'],'','n')<CR>
-  xnoremap <silent> <buffer> [m :<C-U>call <SID>searchsyn('\<def\>',['rubyDefine'],'b','v')<CR>
-  xnoremap <silent> <buffer> ]m :<C-U>call <SID>searchsyn('\<def\>',['rubyDefine'],'','v')<CR>
-  xnoremap <silent> <buffer> [M :<C-U>call <SID>searchsyn('\<end\>',['rubyDefine'],'b','v')<CR>
-  xnoremap <silent> <buffer> ]M :<C-U>call <SID>searchsyn('\<end\>',['rubyDefine'],'','v')<CR>
-
-  nnoremap <silent> <buffer> [[ :<C-U>call <SID>searchsyn('\<\%(class\<Bar>module\)\>',['rubyModule','rubyClass'],'b','n')<CR>
-  nnoremap <silent> <buffer> ]] :<C-U>call <SID>searchsyn('\<\%(class\<Bar>module\)\>',['rubyModule','rubyClass'],'','n')<CR>
-  nnoremap <silent> <buffer> [] :<C-U>call <SID>searchsyn('\<end\>',['rubyModule','rubyClass'],'b','n')<CR>
-  nnoremap <silent> <buffer> ][ :<C-U>call <SID>searchsyn('\<end\>',['rubyModule','rubyClass'],'','n')<CR>
-  xnoremap <silent> <buffer> [[ :<C-U>call <SID>searchsyn('\<\%(class\<Bar>module\)\>',['rubyModule','rubyClass'],'b','v')<CR>
-  xnoremap <silent> <buffer> ]] :<C-U>call <SID>searchsyn('\<\%(class\<Bar>module\)\>',['rubyModule','rubyClass'],'','v')<CR>
-  xnoremap <silent> <buffer> [] :<C-U>call <SID>searchsyn('\<end\>',['rubyModule','rubyClass'],'b','v')<CR>
-  xnoremap <silent> <buffer> ][ :<C-U>call <SID>searchsyn('\<end\>',['rubyModule','rubyClass'],'','v')<CR>
-
-  let b:undo_ftplugin = b:undo_ftplugin
-        \."| sil! exe 'unmap <buffer> [[' | sil! exe 'unmap <buffer> ]]' | sil! exe 'unmap <buffer> []' | sil! exe 'unmap <buffer> ]['"
-        \."| sil! exe 'unmap <buffer> [m' | sil! exe 'unmap <buffer> ]m' | sil! exe 'unmap <buffer> [M' | sil! exe 'unmap <buffer> ]M'"
-
-  if maparg('im','x') == '' && maparg('im','o') == '' && maparg('am','x') == '' && maparg('am','o') == ''
-    onoremap <silent> <buffer> im :<C-U>call <SID>wrap_i('[m',']M')<CR>
-    onoremap <silent> <buffer> am :<C-U>call <SID>wrap_a('[m',']M')<CR>
-    xnoremap <silent> <buffer> im :<C-U>call <SID>wrap_i('[m',']M')<CR>
-    xnoremap <silent> <buffer> am :<C-U>call <SID>wrap_a('[m',']M')<CR>
-    let b:undo_ftplugin = b:undo_ftplugin
-          \."| sil! exe 'ounmap <buffer> im' | sil! exe 'ounmap <buffer> am'"
-          \."| sil! exe 'xunmap <buffer> im' | sil! exe 'xunmap <buffer> am'"
-  endif
-
-  if maparg('iM','x') == '' && maparg('iM','o') == '' && maparg('aM','x') == '' && maparg('aM','o') == ''
-    onoremap <silent> <buffer> iM :<C-U>call <SID>wrap_i('[[','][')<CR>
-    onoremap <silent> <buffer> aM :<C-U>call <SID>wrap_a('[[','][')<CR>
-    xnoremap <silent> <buffer> iM :<C-U>call <SID>wrap_i('[[','][')<CR>
-    xnoremap <silent> <buffer> aM :<C-U>call <SID>wrap_a('[[','][')<CR>
-    let b:undo_ftplugin = b:undo_ftplugin
-          \."| sil! exe 'ounmap <buffer> iM' | sil! exe 'ounmap <buffer> aM'"
-          \."| sil! exe 'xunmap <buffer> iM' | sil! exe 'xunmap <buffer> aM'"
-  endif
-
-  call s:map('c', '', '<C-R><C-F> <Plug><cfile>')
-
-  cmap <buffer><script><expr> <SID>tagzv &foldopen =~# 'tag' ? '<Bar>norm! zv' : ''
-  call s:map('n', '<silent>', '<C-]>       <SID>:exe  v:count1."tag <Plug><ctag>"<SID>tagzv<CR>')
-  call s:map('n', '<silent>', 'g<C-]>      <SID>:exe         "tjump <Plug><ctag>"<SID>tagzv<CR>')
-  call s:map('n', '<silent>', 'g]          <SID>:exe       "tselect <Plug><ctag>"<SID>tagzv<CR>')
-  call s:map('n', '<silent>', '<C-W>]      <SID>:exe v:count1."stag <Plug><ctag>"<SID>tagzv<CR>')
-  call s:map('n', '<silent>', '<C-W><C-]>  <SID>:exe v:count1."stag <Plug><ctag>"<SID>tagzv<CR>')
-  call s:map('n', '<silent>', '<C-W>g<C-]> <SID>:exe        "stjump <Plug><ctag>"<SID>tagzv<CR>')
-  call s:map('n', '<silent>', '<C-W>g]     <SID>:exe      "stselect <Plug><ctag>"<SID>tagzv<CR>')
-  call s:map('n', '<silent>', '<C-W>}      <SID>:exe v:count1."ptag <Plug><ctag>"<CR>')
-  call s:map('n', '<silent>', '<C-W>g}     <SID>:exe        "ptjump <Plug><ctag>"<CR>')
-
-  call s:map('n', '<silent>', 'gf           <SID>c:find <Plug><cfile><CR>')
-  call s:map('n', '<silent>', '<C-W>f      <SID>c:sfind <Plug><cfile><CR>')
-  call s:map('n', '<silent>', '<C-W><C-F>  <SID>c:sfind <Plug><cfile><CR>')
-  call s:map('n', '<silent>', '<C-W>gf   <SID>c:tabfind <Plug><cfile><CR>')
-endif
-
-let &cpo = s:cpo_save
-unlet s:cpo_save
-
-if exists("g:did_ruby_ftplugin_functions")
-  finish
-endif
-let g:did_ruby_ftplugin_functions = 1
-
-function! RubyBalloonexpr() abort
-  if !exists('s:ri_found')
-    let s:ri_found = executable('ri')
-  endif
-  if s:ri_found
-    let line = getline(v:beval_lnum)
-    let b = matchstr(strpart(line,0,v:beval_col),'\%(\w\|[:.]\)*$')
-    let a = substitute(matchstr(strpart(line,v:beval_col),'^\w*\%([?!]\|\s*=\)\?'),'\s\+','','g')
-    let str = b.a
-    let before = strpart(line,0,v:beval_col-strlen(b))
-    let after  = strpart(line,v:beval_col+strlen(a))
-    if str =~ '^\.'
-      let str = substitute(str,'^\.','#','g')
-      if before =~ '\]\s*$'
-        let str = 'Array'.str
-      elseif before =~ '}\s*$'
-        " False positives from blocks here
-        let str = 'Hash'.str
-      elseif before =~ "[\"'`]\\s*$" || before =~ '\$\d\+\s*$'
-        let str = 'String'.str
-      elseif before =~ '\$\d\+\.\d\+\s*$'
-        let str = 'Float'.str
-      elseif before =~ '\$\d\+\s*$'
-        let str = 'Integer'.str
-      elseif before =~ '/\s*$'
-        let str = 'Regexp'.str
-      else
-        let str = substitute(str,'^#','.','')
-      endif
-    endif
-    let str = substitute(str,'.*\.\s*to_f\s*\.\s*','Float#','')
-    let str = substitute(str,'.*\.\s*to_i\%(nt\)\=\s*\.\s*','Integer#','')
-    let str = substitute(str,'.*\.\s*to_s\%(tr\)\=\s*\.\s*','String#','')
-    let str = substitute(str,'.*\.\s*to_sym\s*\.\s*','Symbol#','')
-    let str = substitute(str,'.*\.\s*to_a\%(ry\)\=\s*\.\s*','Array#','')
-    let str = substitute(str,'.*\.\s*to_proc\s*\.\s*','Proc#','')
-    if str !~ '^\w'
-      return ''
-    endif
-    silent! let res = substitute(system("ri -f rdoc -T \"".str.'"'),'\n$','','')
-    if res =~ '^Nothing known about' || res =~ '^Bad argument:' || res =~ '^More than one method'
-      return ''
-    endif
-    return res
-  else
-    return ""
-  endif
-endfunction
-
-function! s:searchsyn(pattern, syn, flags, mode) abort
-  let cnt = v:count1
-  norm! m'
-  if a:mode ==# 'v'
-    norm! gv
-  endif
-  let i = 0
-  call map(a:syn, 'hlID(v:val)')
-  while i < cnt
-    let i = i + 1
-    let line = line('.')
-    let col  = col('.')
-    let pos = search(a:pattern,'W'.a:flags)
-    while pos != 0 && index(a:syn, s:synid()) < 0
-      let pos = search(a:pattern,'W'.a:flags)
-    endwhile
-    if pos == 0
-      call cursor(line,col)
-      return
-    endif
-  endwhile
-endfunction
-
-function! s:synid() abort
-  return synID(line('.'),col('.'),0)
-endfunction
-
-function! s:wrap_i(back,forward) abort
-  execute 'norm! k'
-  execute 'norm '.a:forward
-  let line = line('.')
-  execute 'norm '.a:back
-  if line('.') == line - 1
-    return s:wrap_a(a:back,a:forward)
-  endif
-  execute 'norm! jV'
-  execute 'norm '.a:forward
-  execute 'norm! k'
-endfunction
-
-function! s:wrap_a(back,forward) abort
-  execute 'norm '.a:forward
-  if line('.') < line('$') && getline(line('.')+1) ==# ''
-    let after = 1
-  endif
-  execute 'norm '.a:back
-  while getline(line('.')-1) =~# '^\s*#' && line('.')
-    -
-  endwhile
-  if exists('after')
-    execute 'norm! V'
-    execute 'norm '.a:forward
-    execute 'norm! j'
-  elseif line('.') > 1 && getline(line('.')-1) =~# '^\s*$'
-    execute 'norm! kV'
-    execute 'norm '.a:forward
-  else
-    execute 'norm! V'
-    execute 'norm '.a:forward
-  endif
-endfunction
-
-function! RubyCursorIdentifier() abort
-  let asciicode    = '\%(\w\|[]})\"'."'".']\)\@<!\%(?\%(\\M-\\C-\|\\C-\\M-\|\\M-\\c\|\\c\\M-\|\\c\|\\C-\|\\M-\)\=\%(\\\o\{1,3}\|\\x\x\{1,2}\|\\\=\S\)\)'
-  let number       = '\%(\%(\w\|[]})\"'."'".']\s*\)\@<!-\)\=\%(\<[[:digit:]_]\+\%(\.[[:digit:]_]\+\)\=\%([Ee][[:digit:]_]\+\)\=\>\|\<0[xXbBoOdD][[:xdigit:]_]\+\>\)\|'.asciicode
-  let operator     = '\%(\[\]\|<<\|<=>\|[!<>]=\=\|===\=\|[!=]\~\|>>\|\*\*\|\.\.\.\=\|=>\|[~^&|*/%+-]\)'
-  let method       = '\%(\.[_a-zA-Z]\w*\s*=>\@!\|\<[_a-zA-Z]\w*\>[?!]\=\)'
-  let global       = '$\%([!$&"'."'".'*+,./:;<=>?@\`~]\|-\=\w\+\>\)'
-  let symbolizable = '\%(\%(@@\=\)\w\+\>\|'.global.'\|'.method.'\|'.operator.'\)'
-  let pattern      = '\C\s*\%('.number.'\|\%(:\@<!:\)\='.symbolizable.'\)'
-  let [lnum, col]  = searchpos(pattern,'bcn',line('.'))
-  let raw          = matchstr(getline('.')[col-1 : ],pattern)
-  let stripped     = substitute(substitute(raw,'\s\+=$','=',''),'^\s*[:.]\=','','')
-  return stripped == '' ? expand("<cword>") : stripped
-endfunction
-
-function! RubyCursorTag() abort
-  return substitute(RubyCursorIdentifier(), '^[$@]*', '', '')
-endfunction
-
-function! RubyCursorFile() abort
-  let isfname = &isfname
-  try
-    set isfname+=:
-    let cfile = expand('<cfile>')
-  finally
-    let isfname = &isfname
-  endtry
-  let pre = matchstr(strpart(getline('.'), 0, col('.')-1), '.*\f\@<!')
-  let post = matchstr(strpart(getline('.'), col('.')), '\f\@!.*')
-  if s:synid() ==# hlID('rubyConstant')
-    let cfile = substitute(cfile,'\.\w\+[?!=]\=$','','')
-    let cfile = substitute(cfile,'^::','','')
-    let cfile = substitute(cfile,'::','/','g')
-    let cfile = substitute(cfile,'\(\u\+\)\(\u\l\)','\1_\2', 'g')
-    let cfile = substitute(cfile,'\(\l\|\d\)\(\u\)','\1_\2', 'g')
-    return tolower(cfile) . '.rb'
-  elseif getline('.') =~# '^\s*require_relative\s*\(["'']\).*\1\s*$'
-    let cfile = expand('%:p:h') . '/' . matchstr(getline('.'),'\(["'']\)\zs.\{-\}\ze\1')
-    let cfile .= cfile !~# '\.rb$' ? '.rb' : ''
-  elseif getline('.') =~# '^\s*\%(require[( ]\|load[( ]\|autoload[( ]:\w\+,\)\s*\%(::\)\=File\.expand_path(\(["'']\)\.\./.*\1,\s*__FILE__)\s*$'
-    let target = matchstr(getline('.'),'\(["'']\)\.\.\zs/.\{-\}\ze\1')
-    let cfile = expand('%:p:h') . target
-    let cfile .= cfile !~# '\.rb$' ? '.rb' : ''
-  elseif getline('.') =~# '^\s*\%(require \|load \|autoload :\w\+,\)\s*\(["'']\).*\1\s*$'
-    let cfile = matchstr(getline('.'),'\(["'']\)\zs.\{-\}\ze\1')
-    let cfile .= cfile !~# '\.rb$' ? '.rb' : ''
-  elseif pre.post =~# '\<File.expand_path[( ].*[''"]\{2\}, *__FILE__\>' && cfile =~# '^\.\.'
-    let cfile = expand('%:p:h') . strpart(cfile, 2)
-  else
-    return substitute(cfile, '\C\v^(.*):(\d+)%(:in)=$', '+\2 \1', '')
-  endif
-  let cwdpat = '^\M' . substitute(getcwd(), '[\/]', '\\[\\/]', 'g').'\ze\[\/]'
-  let cfile = substitute(cfile, cwdpat, '.', '')
-  if fnameescape(cfile) !=# cfile
-    return '+ '.fnameescape(cfile)
-  else
-    return cfile
-  endif
-endfunction
-
-"
-" Instructions for enabling "matchit" support:
-"
-" 1. Look for the latest "matchit" plugin at
-"
-"         http://www.vim.org/scripts/script.php?script_id=39
-"
-"    It is also packaged with Vim, in the $VIMRUNTIME/macros directory.
-"
-" 2. Copy "matchit.txt" into a "doc" directory (e.g. $HOME/.vim/doc).
-"
-" 3. Copy "matchit.vim" into a "plugin" directory (e.g. $HOME/.vim/plugin).
-"
-" 4. Ensure this file (ftplugin/ruby.vim) is installed.
-"
-" 5. Ensure you have this line in your $HOME/.vimrc:
-"         filetype plugin on
-"
-" 6. Restart Vim and create the matchit documentation:
-"
-"         :helptags ~/.vim/doc
-"
-"    Now you can do ":help matchit", and you should be able to use "%" on Ruby
-"    keywords.  Try ":echo b:match_words" to be sure.
-"
-" Thanks to Mark J. Reed for the instructions.  See ":help vimrc" for the
-" locations of plugin directories, etc., as there are several options, and it
-" differs on Windows.  Email gsinclair@soyabean.com.au if you need help.
-"
-
-" vim: nowrap sw=2 sts=2 ts=8:
diff --git a/sources_non_forked/vim-ruby/indent/eruby.vim b/sources_non_forked/vim-ruby/indent/eruby.vim
deleted file mode 100644
index 62cd6cf..0000000
--- a/sources_non_forked/vim-ruby/indent/eruby.vim
+++ /dev/null
@@ -1,110 +0,0 @@
-" Vim indent file
-" Language:		eRuby
-" Maintainer:		Tim Pope <vimNOSPAM@tpope.org>
-" URL:			https://github.com/vim-ruby/vim-ruby
-" Release Coordinator:	Doug Kearns <dougkearns@gmail.com>
-
-if exists("b:did_indent")
-  finish
-endif
-
-runtime! indent/ruby.vim
-unlet! b:did_indent
-setlocal indentexpr=
-
-if exists("b:eruby_subtype") && b:eruby_subtype != '' && b:eruby_subtype !=# 'eruby'
-  exe "runtime! indent/".b:eruby_subtype.".vim"
-else
-  runtime! indent/html.vim
-endif
-unlet! b:did_indent
-
-" Force HTML indent to not keep state.
-let b:html_indent_usestate = 0
-
-if &l:indentexpr == ''
-  if &l:cindent
-    let &l:indentexpr = 'cindent(v:lnum)'
-  else
-    let &l:indentexpr = 'indent(prevnonblank(v:lnum-1))'
-  endif
-endif
-let b:eruby_subtype_indentexpr = &l:indentexpr
-
-let b:did_indent = 1
-
-setlocal indentexpr=GetErubyIndent()
-setlocal indentkeys=o,O,*<Return>,<>>,{,},0),0],o,O,!^F,=end,=else,=elsif,=rescue,=ensure,=when
-
-" Only define the function once.
-if exists("*GetErubyIndent")
-  finish
-endif
-
-" this file uses line continuations
-let s:cpo_sav = &cpo
-set cpo&vim
-
-function! GetErubyIndent(...)
-  " The value of a single shift-width
-  if exists('*shiftwidth')
-    let sw = shiftwidth()
-  else
-    let sw = &sw
-  endif
-
-  if a:0 && a:1 == '.'
-    let v:lnum = line('.')
-  elseif a:0 && a:1 =~ '^\d'
-    let v:lnum = a:1
-  endif
-  let vcol = col('.')
-  call cursor(v:lnum,1)
-  let inruby = searchpair('<%','','%>','W')
-  call cursor(v:lnum,vcol)
-  if inruby && getline(v:lnum) !~ '^<%\|^\s*[-=]\=%>'
-    let ind = GetRubyIndent(v:lnum)
-  else
-    exe "let ind = ".b:eruby_subtype_indentexpr
-
-    " Workaround for Andy Wokula's HTML indent. This should be removed after
-    " some time, since the newest version is fixed in a different way.
-    if b:eruby_subtype_indentexpr =~# '^HtmlIndent('
-	  \ && exists('b:indent')
-	  \ && type(b:indent) == type({})
-	  \ && has_key(b:indent, 'lnum')
-      " Force HTML indent to not keep state
-      let b:indent.lnum = -1
-    endif
-  endif
-  let lnum = prevnonblank(v:lnum-1)
-  let line = getline(lnum)
-  let cline = getline(v:lnum)
-  if cline =~# '^\s*<%[-=]\=\s*\%(}\|end\|else\|\%(ensure\|rescue\|elsif\|when\).\{-\}\)\s*\%([-=]\=%>\|$\)'
-    let ind = ind - sw
-  endif
-  if line =~# '\S\s*<%[-=]\=\s*\%(}\|end\).\{-\}\s*\%([-=]\=%>\|$\)'
-    let ind = ind - sw
-  endif
-  if line =~# '\%({\|\<do\)\%(\s*|[^|]*|\)\=\s*[-=]\=%>'
-    let ind = ind + sw
-  elseif line =~# '<%[-=]\=\s*\%(module\|class\|def\|if\|for\|while\|until\|else\|elsif\|case\|when\|unless\|begin\|ensure\|rescue\)\>.*%>'
-    let ind = ind + sw
-  endif
-  if line =~# '^\s*<%[=#-]\=\s*$' && cline !~# '^\s*end\>'
-    let ind = ind + sw
-  endif
-  if line !~# '^\s*<%' && line =~# '%>\s*$' && line !~# '^\s*end\>'
-	\ && synID(v:lnum, match(cline, '\S') + 1, 1) != hlID('htmlEndTag')
-    let ind = ind - sw
-  endif
-  if cline =~# '^\s*[-=]\=%>\s*$'
-    let ind = ind - sw
-  endif
-  return ind
-endfunction
-
-let &cpo = s:cpo_sav
-unlet! s:cpo_sav
-
-" vim:set sw=2 sts=2 ts=8 noet:
diff --git a/sources_non_forked/vim-ruby/indent/ruby.vim b/sources_non_forked/vim-ruby/indent/ruby.vim
deleted file mode 100644
index bfc32e5..0000000
--- a/sources_non_forked/vim-ruby/indent/ruby.vim
+++ /dev/null
@@ -1,953 +0,0 @@
-" Vim indent file
-" Language:		Ruby
-" Maintainer:		Andrew Radev <andrey.radev@gmail.com>
-" Previous Maintainer:	Nikolai Weibull <now at bitwi.se>
-" URL:			https://github.com/vim-ruby/vim-ruby
-" Release Coordinator:	Doug Kearns <dougkearns@gmail.com>
-
-" 0. Initialization {{{1
-" =================
-
-" Only load this indent file when no other was loaded.
-if exists("b:did_indent")
-  finish
-endif
-let b:did_indent = 1
-
-if !exists('g:ruby_indent_access_modifier_style')
-  " Possible values: "normal", "indent", "outdent"
-  let g:ruby_indent_access_modifier_style = 'normal'
-endif
-
-if !exists('g:ruby_indent_assignment_style')
-  " Possible values: "variable", "hanging"
-  let g:ruby_indent_assignment_style = 'hanging'
-endif
-
-if !exists('g:ruby_indent_block_style')
-  " Possible values: "expression", "do"
-  let g:ruby_indent_block_style = 'expression'
-endif
-
-setlocal nosmartindent
-
-" Now, set up our indentation expression and keys that trigger it.
-setlocal indentexpr=GetRubyIndent(v:lnum)
-setlocal indentkeys=0{,0},0),0],!^F,o,O,e,:,.
-setlocal indentkeys+==end,=else,=elsif,=when,=ensure,=rescue,==begin,==end
-setlocal indentkeys+==private,=protected,=public
-
-" Only define the function once.
-if exists("*GetRubyIndent")
-  finish
-endif
-
-let s:cpo_save = &cpo
-set cpo&vim
-
-" 1. Variables {{{1
-" ============
-
-" Syntax group names that are strings.
-let s:syng_string =
-      \ ['String', 'Interpolation', 'InterpolationDelimiter', 'StringEscape']
-
-" Syntax group names that are strings or documentation.
-let s:syng_stringdoc = s:syng_string + ['Documentation']
-
-" Syntax group names that are or delimit strings/symbols/regexes or are comments.
-let s:syng_strcom = s:syng_stringdoc + [
-      \ 'Character',
-      \ 'Comment',
-      \ 'HeredocDelimiter',
-      \ 'PercentRegexpDelimiter',
-      \ 'PercentStringDelimiter',
-      \ 'PercentSymbolDelimiter',
-      \ 'Regexp',
-      \ 'RegexpCharClass',
-      \ 'RegexpDelimiter',
-      \ 'RegexpEscape',
-      \ 'StringDelimiter',
-      \ 'Symbol',
-      \ 'SymbolDelimiter',
-      \ ]
-
-" Expression used to check whether we should skip a match with searchpair().
-let s:skip_expr =
-      \ 'index(map('.string(s:syng_strcom).',"hlID(''ruby''.v:val)"), synID(line("."),col("."),1)) >= 0'
-
-" Regex used for words that, at the start of a line, add a level of indent.
-let s:ruby_indent_keywords =
-      \ '^\s*\zs\<\%(module\|class\|if\|for' .
-      \   '\|while\|until\|else\|elsif\|case\|when\|unless\|begin\|ensure\|rescue' .
-      \   '\|\%(\K\k*[!?]\?\s\+\)\=def\):\@!\>' .
-      \ '\|\%([=,*/%+-]\|<<\|>>\|:\s\)\s*\zs' .
-      \    '\<\%(if\|for\|while\|until\|case\|unless\|begin\):\@!\>'
-
-" Regex used for words that, at the start of a line, remove a level of indent.
-let s:ruby_deindent_keywords =
-      \ '^\s*\zs\<\%(ensure\|else\|rescue\|elsif\|when\|end\):\@!\>'
-
-" Regex that defines the start-match for the 'end' keyword.
-"let s:end_start_regex = '\%(^\|[^.]\)\<\%(module\|class\|def\|if\|for\|while\|until\|case\|unless\|begin\|do\)\>'
-" TODO: the do here should be restricted somewhat (only at end of line)?
-let s:end_start_regex =
-      \ '\C\%(^\s*\|[=,*/%+\-|;{]\|<<\|>>\|:\s\)\s*\zs' .
-      \ '\<\%(module\|class\|if\|for\|while\|until\|case\|unless\|begin' .
-      \   '\|\%(\K\k*[!?]\?\s\+\)\=def\):\@!\>' .
-      \ '\|\%(^\|[^.:@$]\)\@<=\<do:\@!\>'
-
-" Regex that defines the middle-match for the 'end' keyword.
-let s:end_middle_regex = '\<\%(ensure\|else\|\%(\%(^\|;\)\s*\)\@<=\<rescue:\@!\>\|when\|elsif\):\@!\>'
-
-" Regex that defines the end-match for the 'end' keyword.
-let s:end_end_regex = '\%(^\|[^.:@$]\)\@<=\<end:\@!\>'
-
-" Expression used for searchpair() call for finding match for 'end' keyword.
-let s:end_skip_expr = s:skip_expr .
-      \ ' || (expand("<cword>") == "do"' .
-      \ ' && getline(".") =~ "^\\s*\\<\\(while\\|until\\|for\\):\\@!\\>")'
-
-" Regex that defines continuation lines, not including (, {, or [.
-let s:non_bracket_continuation_regex =
-      \ '\%([\\.,:*/%+]\|\<and\|\<or\|\%(<%\)\@<![=-]\|:\@<![^[:alnum:]:][|&?]\|||\|&&\)\s*\%(#.*\)\=$'
-
-" Regex that defines continuation lines.
-let s:continuation_regex =
-      \ '\%(%\@<![({[\\.,:*/%+]\|\<and\|\<or\|\%(<%\)\@<![=-]\|:\@<![^[:alnum:]:][|&?]\|||\|&&\)\s*\%(#.*\)\=$'
-
-" Regex that defines continuable keywords
-let s:continuable_regex =
-      \ '\C\%(^\s*\|[=,*/%+\-|;{]\|<<\|>>\|:\s\)\s*\zs' .
-      \ '\<\%(if\|for\|while\|until\|unless\):\@!\>'
-
-" Regex that defines bracket continuations
-let s:bracket_continuation_regex = '%\@<!\%([({[]\)\s*\%(#.*\)\=$'
-
-" Regex that defines dot continuations
-let s:dot_continuation_regex = '%\@<!\.\s*\%(#.*\)\=$'
-
-" Regex that defines backslash continuations
-let s:backslash_continuation_regex = '%\@<!\\\s*$'
-
-" Regex that defines end of bracket continuation followed by another continuation
-let s:bracket_switch_continuation_regex = '^\([^(]\+\zs).\+\)\+'.s:continuation_regex
-
-" Regex that defines the first part of a splat pattern
-let s:splat_regex = '[[,(]\s*\*\s*\%(#.*\)\=$'
-
-" Regex that describes all indent access modifiers
-let s:access_modifier_regex = '\C^\s*\%(public\|protected\|private\)\s*\%(#.*\)\=$'
-
-" Regex that describes the indent access modifiers (excludes public)
-let s:indent_access_modifier_regex = '\C^\s*\%(protected\|private\)\s*\%(#.*\)\=$'
-
-" Regex that defines blocks.
-"
-" Note that there's a slight problem with this regex and s:continuation_regex.
-" Code like this will be matched by both:
-"
-"   method_call do |(a, b)|
-"
-" The reason is that the pipe matches a hanging "|" operator.
-"
-let s:block_regex =
-      \ '\%(\<do:\@!\>\|%\@<!{\)\s*\%(|[^|]*|\)\=\s*\%(#.*\)\=$'
-
-let s:block_continuation_regex = '^\s*[^])}\t ].*'.s:block_regex
-
-" Regex that describes a leading operator (only a method call's dot for now)
-let s:leading_operator_regex = '^\s*\%(&\=\.\)'
-
-" 2. GetRubyIndent Function {{{1
-" =========================
-
-function! GetRubyIndent(...) abort
-  " 2.1. Setup {{{2
-  " ----------
-
-  let indent_info = {}
-
-  " The value of a single shift-width
-  if exists('*shiftwidth')
-    let indent_info.sw = shiftwidth()
-  else
-    let indent_info.sw = &sw
-  endif
-
-  " For the current line, use the first argument if given, else v:lnum
-  let indent_info.clnum = a:0 ? a:1 : v:lnum
-  let indent_info.cline = getline(indent_info.clnum)
-
-  " Set up variables for restoring position in file.  Could use clnum here.
-  let indent_info.col = col('.')
-
-  " 2.2. Work on the current line {{{2
-  " -----------------------------
-  let indent_callback_names = [
-        \ 's:AccessModifier',
-        \ 's:ClosingBracketOnEmptyLine',
-        \ 's:BlockComment',
-        \ 's:DeindentingKeyword',
-        \ 's:MultilineStringOrLineComment',
-        \ 's:ClosingHeredocDelimiter',
-        \ 's:LeadingOperator',
-        \ ]
-
-  for callback_name in indent_callback_names
-"    Decho "Running: ".callback_name
-    let indent = call(function(callback_name), [indent_info])
-
-    if indent >= 0
-"      Decho "Match: ".callback_name." indent=".indent." info=".string(indent_info)
-      return indent
-    endif
-  endfor
-
-  " 2.3. Work on the previous line. {{{2
-  " -------------------------------
-
-  " Special case: we don't need the real s:PrevNonBlankNonString for an empty
-  " line inside a string. And that call can be quite expensive in that
-  " particular situation.
-  let indent_callback_names = [
-        \ 's:EmptyInsideString',
-        \ ]
-
-  for callback_name in indent_callback_names
-"    Decho "Running: ".callback_name
-    let indent = call(function(callback_name), [indent_info])
-
-    if indent >= 0
-"      Decho "Match: ".callback_name." indent=".indent." info=".string(indent_info)
-      return indent
-    endif
-  endfor
-
-  " Previous line number
-  let indent_info.plnum = s:PrevNonBlankNonString(indent_info.clnum - 1)
-  let indent_info.pline = getline(indent_info.plnum)
-
-  let indent_callback_names = [
-        \ 's:StartOfFile',
-        \ 's:AfterAccessModifier',
-        \ 's:ContinuedLine',
-        \ 's:AfterBlockOpening',
-        \ 's:AfterHangingSplat',
-        \ 's:AfterUnbalancedBracket',
-        \ 's:AfterLeadingOperator',
-        \ 's:AfterEndKeyword',
-        \ 's:AfterIndentKeyword',
-        \ ]
-
-  for callback_name in indent_callback_names
-"    Decho "Running: ".callback_name
-    let indent = call(function(callback_name), [indent_info])
-
-    if indent >= 0
-"      Decho "Match: ".callback_name." indent=".indent." info=".string(indent_info)
-      return indent
-    endif
-  endfor
-
-  " 2.4. Work on the MSL line. {{{2
-  " --------------------------
-  let indent_callback_names = [
-        \ 's:PreviousNotMSL',
-        \ 's:IndentingKeywordInMSL',
-        \ 's:ContinuedHangingOperator',
-        \ ]
-
-  " Most Significant line based on the previous one -- in case it's a
-  " contination of something above
-  let indent_info.plnum_msl = s:GetMSL(indent_info.plnum)
-
-  for callback_name in indent_callback_names
-"    Decho "Running: ".callback_name
-    let indent = call(function(callback_name), [indent_info])
-
-    if indent >= 0
-"      Decho "Match: ".callback_name." indent=".indent." info=".string(indent_info)
-      return indent
-    endif
-  endfor
-
-  " }}}2
-
-  " By default, just return the previous line's indent
-"  Decho "Default case matched"
-  return indent(indent_info.plnum)
-endfunction
-
-" 3. Indenting Logic Callbacks {{{1
-" ============================
-
-function! s:AccessModifier(cline_info) abort
-  let info = a:cline_info
-
-  " If this line is an access modifier keyword, align according to the closest
-  " class declaration.
-  if g:ruby_indent_access_modifier_style == 'indent'
-    if s:Match(info.clnum, s:access_modifier_regex)
-      let class_lnum = s:FindContainingClass()
-      if class_lnum > 0
-        return indent(class_lnum) + info.sw
-      endif
-    endif
-  elseif g:ruby_indent_access_modifier_style == 'outdent'
-    if s:Match(info.clnum, s:access_modifier_regex)
-      let class_lnum = s:FindContainingClass()
-      if class_lnum > 0
-        return indent(class_lnum)
-      endif
-    endif
-  endif
-
-  return -1
-endfunction
-
-function! s:ClosingBracketOnEmptyLine(cline_info) abort
-  let info = a:cline_info
-
-  " If we got a closing bracket on an empty line, find its match and indent
-  " according to it.  For parentheses we indent to its column - 1, for the
-  " others we indent to the containing line's MSL's level.  Return -1 if fail.
-  let col = matchend(info.cline, '^\s*[]})]')
-
-  if col > 0 && !s:IsInStringOrComment(info.clnum, col)
-    call cursor(info.clnum, col)
-    let closing_bracket = info.cline[col - 1]
-    let bracket_pair = strpart('(){}[]', stridx(')}]', closing_bracket) * 2, 2)
-
-    if searchpair(escape(bracket_pair[0], '\['), '', bracket_pair[1], 'bW', s:skip_expr) > 0
-      if closing_bracket == ')' && col('.') != col('$') - 1
-        let ind = virtcol('.') - 1
-      elseif g:ruby_indent_block_style == 'do'
-        let ind = indent(line('.'))
-      else " g:ruby_indent_block_style == 'expression'
-        let ind = indent(s:GetMSL(line('.')))
-      endif
-    endif
-
-    return ind
-  endif
-
-  return -1
-endfunction
-
-function! s:BlockComment(cline_info) abort
-  " If we have a =begin or =end set indent to first column.
-  if match(a:cline_info.cline, '^\s*\%(=begin\|=end\)$') != -1
-    return 0
-  endif
-  return -1
-endfunction
-
-function! s:DeindentingKeyword(cline_info) abort
-  let info = a:cline_info
-
-  " If we have a deindenting keyword, find its match and indent to its level.
-  " TODO: this is messy
-  if s:Match(info.clnum, s:ruby_deindent_keywords)
-    call cursor(info.clnum, 1)
-
-    if searchpair(s:end_start_regex, s:end_middle_regex, s:end_end_regex, 'bW',
-          \ s:end_skip_expr) > 0
-      let msl  = s:GetMSL(line('.'))
-      let line = getline(line('.'))
-
-      if s:IsAssignment(line, col('.')) &&
-            \ strpart(line, col('.') - 1, 2) !~ 'do'
-        " assignment to case/begin/etc, on the same line
-        if g:ruby_indent_assignment_style == 'hanging'
-          " hanging indent
-          let ind = virtcol('.') - 1
-        else
-          " align with variable
-          let ind = indent(line('.'))
-        endif
-      elseif g:ruby_indent_block_style == 'do'
-        " align to line of the "do", not to the MSL
-        let ind = indent(line('.'))
-      elseif getline(msl) =~ '=\s*\(#.*\)\=$'
-        " in the case of assignment to the MSL, align to the starting line,
-        " not to the MSL
-        let ind = indent(line('.'))
-      else
-        " align to the MSL
-        let ind = indent(msl)
-      endif
-    endif
-    return ind
-  endif
-
-  return -1
-endfunction
-
-function! s:MultilineStringOrLineComment(cline_info) abort
-  let info = a:cline_info
-
-  " If we are in a multi-line string or line-comment, don't do anything to it.
-  if s:IsInStringOrDocumentation(info.clnum, matchend(info.cline, '^\s*') + 1)
-    return indent(info.clnum)
-  endif
-  return -1
-endfunction
-
-function! s:ClosingHeredocDelimiter(cline_info) abort
-  let info = a:cline_info
-
-  " If we are at the closing delimiter of a "<<" heredoc-style string, set the
-  " indent to 0.
-  if info.cline =~ '^\k\+\s*$'
-        \ && s:IsInStringDelimiter(info.clnum, 1)
-        \ && search('\V<<'.info.cline, 'nbW') > 0
-    return 0
-  endif
-
-  return -1
-endfunction
-
-function! s:LeadingOperator(cline_info) abort
-  " If the current line starts with a leading operator, add a level of indent.
-  if s:Match(a:cline_info.clnum, s:leading_operator_regex)
-    return indent(s:GetMSL(a:cline_info.clnum)) + a:cline_info.sw
-  endif
-  return -1
-endfunction
-
-function! s:EmptyInsideString(pline_info) abort
-  " If the line is empty and inside a string (the previous line is a string,
-  " too), use the previous line's indent
-  let info = a:pline_info
-
-  let plnum = prevnonblank(info.clnum - 1)
-  let pline = getline(plnum)
-
-  if info.cline =~ '^\s*$'
-        \ && s:IsInStringOrComment(plnum, 1)
-        \ && s:IsInStringOrComment(plnum, strlen(pline))
-    return indent(plnum)
-  endif
-  return -1
-endfunction
-
-function! s:StartOfFile(pline_info) abort
-  " At the start of the file use zero indent.
-  if a:pline_info.plnum == 0
-    return 0
-  endif
-  return -1
-endfunction
-
-function! s:AfterAccessModifier(pline_info) abort
-  let info = a:pline_info
-
-  if g:ruby_indent_access_modifier_style == 'indent'
-    " If the previous line was a private/protected keyword, add a
-    " level of indent.
-    if s:Match(info.plnum, s:indent_access_modifier_regex)
-      return indent(info.plnum) + info.sw
-    endif
-  elseif g:ruby_indent_access_modifier_style == 'outdent'
-    " If the previous line was a private/protected/public keyword, add
-    " a level of indent, since the keyword has been out-dented.
-    if s:Match(info.plnum, s:access_modifier_regex)
-      return indent(info.plnum) + info.sw
-    endif
-  endif
-  return -1
-endfunction
-
-" Example:
-"
-"   if foo || bar ||
-"       baz || bing
-"     puts "foo"
-"   end
-"
-function! s:ContinuedLine(pline_info) abort
-  let info = a:pline_info
-
-  let col = s:Match(info.plnum, s:ruby_indent_keywords)
-  if s:Match(info.plnum, s:continuable_regex) &&
-        \ s:Match(info.plnum, s:continuation_regex)
-    if col > 0 && s:IsAssignment(info.pline, col)
-      if g:ruby_indent_assignment_style == 'hanging'
-        " hanging indent
-        let ind = col - 1
-      else
-        " align with variable
-        let ind = indent(info.plnum)
-      endif
-    else
-      let ind = indent(s:GetMSL(info.plnum))
-    endif
-    return ind + info.sw + info.sw
-  endif
-  return -1
-endfunction
-
-function! s:AfterBlockOpening(pline_info) abort
-  let info = a:pline_info
-
-  " If the previous line ended with a block opening, add a level of indent.
-  if s:Match(info.plnum, s:block_regex)
-    if g:ruby_indent_block_style == 'do'
-      " don't align to the msl, align to the "do"
-      let ind = indent(info.plnum) + info.sw
-    else
-      let plnum_msl = s:GetMSL(info.plnum)
-
-      if getline(plnum_msl) =~ '=\s*\(#.*\)\=$'
-        " in the case of assignment to the msl, align to the starting line,
-        " not to the msl
-        let ind = indent(info.plnum) + info.sw
-      else
-        let ind = indent(plnum_msl) + info.sw
-      endif
-    endif
-
-    return ind
-  endif
-
-  return -1
-endfunction
-
-function! s:AfterLeadingOperator(pline_info) abort
-  " If the previous line started with a leading operator, use its MSL's level
-  " of indent
-  if s:Match(a:pline_info.plnum, s:leading_operator_regex)
-    return indent(s:GetMSL(a:pline_info.plnum))
-  endif
-  return -1
-endfunction
-
-function! s:AfterHangingSplat(pline_info) abort
-  let info = a:pline_info
-
-  " If the previous line ended with the "*" of a splat, add a level of indent
-  if info.pline =~ s:splat_regex
-    return indent(info.plnum) + info.sw
-  endif
-  return -1
-endfunction
-
-function! s:AfterUnbalancedBracket(pline_info) abort
-  let info = a:pline_info
-
-  " If the previous line contained unclosed opening brackets and we are still
-  " in them, find the rightmost one and add indent depending on the bracket
-  " type.
-  "
-  " If it contained hanging closing brackets, find the rightmost one, find its
-  " match and indent according to that.
-  if info.pline =~ '[[({]' || info.pline =~ '[])}]\s*\%(#.*\)\=$'
-    let [opening, closing] = s:ExtraBrackets(info.plnum)
-
-    if opening.pos != -1
-      if opening.type == '(' && searchpair('(', '', ')', 'bW', s:skip_expr) > 0
-        if col('.') + 1 == col('$')
-          return indent(info.plnum) + info.sw
-        else
-          return virtcol('.')
-        endif
-      else
-        let nonspace = matchend(info.pline, '\S', opening.pos + 1) - 1
-        return nonspace > 0 ? nonspace : indent(info.plnum) + info.sw
-      endif
-    elseif closing.pos != -1
-      call cursor(info.plnum, closing.pos + 1)
-      normal! %
-
-      if s:Match(line('.'), s:ruby_indent_keywords)
-        return indent('.') + info.sw
-      else
-        return indent(s:GetMSL(line('.')))
-      endif
-    else
-      call cursor(info.clnum, info.col)
-    end
-  endif
-
-  return -1
-endfunction
-
-function! s:AfterEndKeyword(pline_info) abort
-  let info = a:pline_info
-  " If the previous line ended with an "end", match that "end"s beginning's
-  " indent.
-  let col = s:Match(info.plnum, '\%(^\|[^.:@$]\)\<end\>\s*\%(#.*\)\=$')
-  if col > 0
-    call cursor(info.plnum, col)
-    if searchpair(s:end_start_regex, '', s:end_end_regex, 'bW',
-          \ s:end_skip_expr) > 0
-      let n = line('.')
-      let ind = indent('.')
-      let msl = s:GetMSL(n)
-      if msl != n
-        let ind = indent(msl)
-      end
-      return ind
-    endif
-  end
-  return -1
-endfunction
-
-function! s:AfterIndentKeyword(pline_info) abort
-  let info = a:pline_info
-  let col = s:Match(info.plnum, s:ruby_indent_keywords)
-
-  if col > 0
-    call cursor(info.plnum, col)
-    let ind = virtcol('.') - 1 + info.sw
-    " TODO: make this better (we need to count them) (or, if a searchpair
-    " fails, we know that something is lacking an end and thus we indent a
-    " level
-    if s:Match(info.plnum, s:end_end_regex)
-      let ind = indent('.')
-    elseif s:IsAssignment(info.pline, col)
-      if g:ruby_indent_assignment_style == 'hanging'
-        " hanging indent
-        let ind = col + info.sw - 1
-      else
-        " align with variable
-        let ind = indent(info.plnum) + info.sw
-      endif
-    endif
-    return ind
-  endif
-
-  return -1
-endfunction
-
-function! s:PreviousNotMSL(msl_info) abort
-  let info = a:msl_info
-
-  " If the previous line wasn't a MSL
-  if info.plnum != info.plnum_msl
-    " If previous line ends bracket and begins non-bracket continuation decrease indent by 1.
-    if s:Match(info.plnum, s:bracket_switch_continuation_regex)
-      " TODO (2016-10-07) Wrong/unused? How could it be "1"?
-      return indent(info.plnum) - 1
-      " If previous line is a continuation return its indent.
-      " TODO: the || s:IsInString() thing worries me a bit.
-    elseif s:Match(info.plnum, s:non_bracket_continuation_regex) || s:IsInString(info.plnum, strlen(line))
-      return indent(info.plnum)
-    endif
-  endif
-
-  return -1
-endfunction
-
-function! s:IndentingKeywordInMSL(msl_info) abort
-  let info = a:msl_info
-  " If the MSL line had an indenting keyword in it, add a level of indent.
-  " TODO: this does not take into account contrived things such as
-  " module Foo; class Bar; end
-  let col = s:Match(info.plnum_msl, s:ruby_indent_keywords)
-  if col > 0
-    let ind = indent(info.plnum_msl) + info.sw
-    if s:Match(info.plnum_msl, s:end_end_regex)
-      let ind = ind - info.sw
-    elseif s:IsAssignment(getline(info.plnum_msl), col)
-      if g:ruby_indent_assignment_style == 'hanging'
-        " hanging indent
-        let ind = col + info.sw - 1
-      else
-        " align with variable
-        let ind = indent(info.plnum_msl) + info.sw
-      endif
-    endif
-    return ind
-  endif
-  return -1
-endfunction
-
-function! s:ContinuedHangingOperator(msl_info) abort
-  let info = a:msl_info
-
-  " If the previous line ended with [*+/.,-=], but wasn't a block ending or a
-  " closing bracket, indent one extra level.
-  if s:Match(info.plnum_msl, s:non_bracket_continuation_regex) && !s:Match(info.plnum_msl, '^\s*\([\])}]\|end\)')
-    if info.plnum_msl == info.plnum
-      let ind = indent(info.plnum_msl) + info.sw
-    else
-      let ind = indent(info.plnum_msl)
-    endif
-    return ind
-  endif
-
-  return -1
-endfunction
-
-" 4. Auxiliary Functions {{{1
-" ======================
-
-function! s:IsInRubyGroup(groups, lnum, col) abort
-  let ids = map(copy(a:groups), 'hlID("ruby".v:val)')
-  return index(ids, synID(a:lnum, a:col, 1)) >= 0
-endfunction
-
-" Check if the character at lnum:col is inside a string, comment, or is ascii.
-function! s:IsInStringOrComment(lnum, col) abort
-  return s:IsInRubyGroup(s:syng_strcom, a:lnum, a:col)
-endfunction
-
-" Check if the character at lnum:col is inside a string.
-function! s:IsInString(lnum, col) abort
-  return s:IsInRubyGroup(s:syng_string, a:lnum, a:col)
-endfunction
-
-" Check if the character at lnum:col is inside a string or documentation.
-function! s:IsInStringOrDocumentation(lnum, col) abort
-  return s:IsInRubyGroup(s:syng_stringdoc, a:lnum, a:col)
-endfunction
-
-" Check if the character at lnum:col is inside a string delimiter
-function! s:IsInStringDelimiter(lnum, col) abort
-  return s:IsInRubyGroup(
-        \ ['HeredocDelimiter', 'PercentStringDelimiter', 'StringDelimiter'],
-        \ a:lnum, a:col
-        \ )
-endfunction
-
-function! s:IsAssignment(str, pos) abort
-  return strpart(a:str, 0, a:pos - 1) =~ '=\s*$'
-endfunction
-
-" Find line above 'lnum' that isn't empty, in a comment, or in a string.
-function! s:PrevNonBlankNonString(lnum) abort
-  let in_block = 0
-  let lnum = prevnonblank(a:lnum)
-  while lnum > 0
-    " Go in and out of blocks comments as necessary.
-    " If the line isn't empty (with opt. comment) or in a string, end search.
-    let line = getline(lnum)
-    if line =~ '^=begin'
-      if in_block
-        let in_block = 0
-      else
-        break
-      endif
-    elseif !in_block && line =~ '^=end'
-      let in_block = 1
-    elseif !in_block && line !~ '^\s*#.*$' && !(s:IsInStringOrComment(lnum, 1)
-          \ && s:IsInStringOrComment(lnum, strlen(line)))
-      break
-    endif
-    let lnum = prevnonblank(lnum - 1)
-  endwhile
-  return lnum
-endfunction
-
-" Find line above 'lnum' that started the continuation 'lnum' may be part of.
-function! s:GetMSL(lnum) abort
-  " Start on the line we're at and use its indent.
-  let msl = a:lnum
-  let lnum = s:PrevNonBlankNonString(a:lnum - 1)
-  while lnum > 0
-    " If we have a continuation line, or we're in a string, use line as MSL.
-    " Otherwise, terminate search as we have found our MSL already.
-    let line = getline(lnum)
-
-    if !s:Match(msl, s:backslash_continuation_regex) &&
-          \ s:Match(lnum, s:backslash_continuation_regex)
-      " If the current line doesn't end in a backslash, but the previous one
-      " does, look for that line's msl
-      "
-      " Example:
-      "   foo = "bar" \
-      "     "baz"
-      "
-      let msl = lnum
-    elseif s:Match(msl, s:leading_operator_regex)
-      " If the current line starts with a leading operator, keep its indent
-      " and keep looking for an MSL.
-      let msl = lnum
-    elseif s:Match(lnum, s:splat_regex)
-      " If the above line looks like the "*" of a splat, use the current one's
-      " indentation.
-      "
-      " Example:
-      "   Hash[*
-      "     method_call do
-      "       something
-      "
-      return msl
-    elseif s:Match(lnum, s:non_bracket_continuation_regex) &&
-          \ s:Match(msl, s:non_bracket_continuation_regex)
-      " If the current line is a non-bracket continuation and so is the
-      " previous one, keep its indent and continue looking for an MSL.
-      "
-      " Example:
-      "   method_call one,
-      "     two,
-      "     three
-      "
-      let msl = lnum
-    elseif s:Match(lnum, s:dot_continuation_regex) &&
-          \ (s:Match(msl, s:bracket_continuation_regex) || s:Match(msl, s:block_continuation_regex))
-      " If the current line is a bracket continuation or a block-starter, but
-      " the previous is a dot, keep going to see if the previous line is the
-      " start of another continuation.
-      "
-      " Example:
-      "   parent.
-      "     method_call {
-      "     three
-      "
-      let msl = lnum
-    elseif s:Match(lnum, s:non_bracket_continuation_regex) &&
-          \ (s:Match(msl, s:bracket_continuation_regex) || s:Match(msl, s:block_continuation_regex))
-      " If the current line is a bracket continuation or a block-starter, but
-      " the previous is a non-bracket one, respect the previous' indentation,
-      " and stop here.
-      "
-      " Example:
-      "   method_call one,
-      "     two {
-      "     three
-      "
-      return lnum
-    elseif s:Match(lnum, s:bracket_continuation_regex) &&
-          \ (s:Match(msl, s:bracket_continuation_regex) || s:Match(msl, s:block_continuation_regex))
-      " If both lines are bracket continuations (the current may also be a
-      " block-starter), use the current one's and stop here
-      "
-      " Example:
-      "   method_call(
-      "     other_method_call(
-      "       foo
-      return msl
-    elseif s:Match(lnum, s:block_regex) &&
-          \ !s:Match(msl, s:continuation_regex) &&
-          \ !s:Match(msl, s:block_continuation_regex)
-      " If the previous line is a block-starter and the current one is
-      " mostly ordinary, use the current one as the MSL.
-      "
-      " Example:
-      "   method_call do
-      "     something
-      "     something_else
-      return msl
-    else
-      let col = match(line, s:continuation_regex) + 1
-      if (col > 0 && !s:IsInStringOrComment(lnum, col))
-            \ || s:IsInString(lnum, strlen(line))
-        let msl = lnum
-      else
-        break
-      endif
-    endif
-
-    let lnum = s:PrevNonBlankNonString(lnum - 1)
-  endwhile
-  return msl
-endfunction
-
-" Check if line 'lnum' has more opening brackets than closing ones.
-function! s:ExtraBrackets(lnum) abort
-  let opening = {'parentheses': [], 'braces': [], 'brackets': []}
-  let closing = {'parentheses': [], 'braces': [], 'brackets': []}
-
-  let line = getline(a:lnum)
-  let pos  = match(line, '[][(){}]', 0)
-
-  " Save any encountered opening brackets, and remove them once a matching
-  " closing one has been found. If a closing bracket shows up that doesn't
-  " close anything, save it for later.
-  while pos != -1
-    if !s:IsInStringOrComment(a:lnum, pos + 1)
-      if line[pos] == '('
-        call add(opening.parentheses, {'type': '(', 'pos': pos})
-      elseif line[pos] == ')'
-        if empty(opening.parentheses)
-          call add(closing.parentheses, {'type': ')', 'pos': pos})
-        else
-          let opening.parentheses = opening.parentheses[0:-2]
-        endif
-      elseif line[pos] == '{'
-        call add(opening.braces, {'type': '{', 'pos': pos})
-      elseif line[pos] == '}'
-        if empty(opening.braces)
-          call add(closing.braces, {'type': '}', 'pos': pos})
-        else
-          let opening.braces = opening.braces[0:-2]
-        endif
-      elseif line[pos] == '['
-        call add(opening.brackets, {'type': '[', 'pos': pos})
-      elseif line[pos] == ']'
-        if empty(opening.brackets)
-          call add(closing.brackets, {'type': ']', 'pos': pos})
-        else
-          let opening.brackets = opening.brackets[0:-2]
-        endif
-      endif
-    endif
-
-    let pos = match(line, '[][(){}]', pos + 1)
-  endwhile
-
-  " Find the rightmost brackets, since they're the ones that are important in
-  " both opening and closing cases
-  let rightmost_opening = {'type': '(', 'pos': -1}
-  let rightmost_closing = {'type': ')', 'pos': -1}
-
-  for opening in opening.parentheses + opening.braces + opening.brackets
-    if opening.pos > rightmost_opening.pos
-      let rightmost_opening = opening
-    endif
-  endfor
-
-  for closing in closing.parentheses + closing.braces + closing.brackets
-    if closing.pos > rightmost_closing.pos
-      let rightmost_closing = closing
-    endif
-  endfor
-
-  return [rightmost_opening, rightmost_closing]
-endfunction
-
-function! s:Match(lnum, regex) abort
-  let line   = getline(a:lnum)
-  let offset = match(line, '\C'.a:regex)
-  let col    = offset + 1
-
-  while offset > -1 && s:IsInStringOrComment(a:lnum, col)
-    let offset = match(line, '\C'.a:regex, offset + 1)
-    let col = offset + 1
-  endwhile
-
-  if offset > -1
-    return col
-  else
-    return 0
-  endif
-endfunction
-
-" Locates the containing class/module's definition line, ignoring nested classes
-" along the way.
-"
-function! s:FindContainingClass() abort
-  let saved_position = getpos('.')
-
-  while searchpair(s:end_start_regex, s:end_middle_regex, s:end_end_regex, 'bW',
-        \ s:end_skip_expr) > 0
-    if expand('<cword>') =~# '\<class\|module\>'
-      let found_lnum = line('.')
-      call setpos('.', saved_position)
-      return found_lnum
-    endif
-  endwhile
-
-  call setpos('.', saved_position)
-  return 0
-endfunction
-
-" }}}1
-
-let &cpo = s:cpo_save
-unlet s:cpo_save
-
-" vim:set sw=2 sts=2 ts=8 et:
diff --git a/sources_non_forked/vim-ruby/spec/indent/arguments_spec.rb b/sources_non_forked/vim-ruby/spec/indent/arguments_spec.rb
deleted file mode 100644
index 0ae07ee..0000000
--- a/sources_non_forked/vim-ruby/spec/indent/arguments_spec.rb
+++ /dev/null
@@ -1,24 +0,0 @@
-require 'spec_helper'
-
-describe "Indenting" do
-  specify "multi-line arguments" do
-    assert_correct_indenting <<~EOF
-      User.new(
-        :first_name => 'Some',
-        :second_name => 'Guy'
-      )
-    EOF
-
-    assert_correct_indenting <<~EOF
-      User.new(:first_name => 'Some',
-               :second_name => 'Guy')
-    EOF
-
-    assert_correct_indenting <<~EOF
-      User.new(
-        :first_name => 'Some',
-        :second_name => 'Guy'
-      )
-    EOF
-  end
-end
diff --git a/sources_non_forked/vim-ruby/spec/indent/basic_spec.rb b/sources_non_forked/vim-ruby/spec/indent/basic_spec.rb
deleted file mode 100644
index fc007a1..0000000
--- a/sources_non_forked/vim-ruby/spec/indent/basic_spec.rb
+++ /dev/null
@@ -1,73 +0,0 @@
-require 'spec_helper'
-
-describe "Indenting" do
-  specify "if-clauses" do
-    assert_correct_indenting <<~EOF
-      if foo
-        bar
-      end
-    EOF
-
-    assert_correct_indenting <<~EOF
-      if foo
-        bar
-      else
-        baz
-      end
-    EOF
-
-    assert_correct_indenting <<~EOF
-      bar if foo
-      something_else
-    EOF
-  end
-
-  specify "heredocs" do
-    assert_correct_indenting <<~EOF
-      def one
-        two = <<-THREE
-        four
-        THREE
-      end
-    EOF
-
-    assert_correct_indenting <<~EOF
-      def one
-        two = <<THREE
-      four
-      THREE
-      end
-    EOF
-
-    assert_correct_indenting <<~EOF
-      def one
-        two = <<~THREE
-        four
-        THREE
-      end
-    EOF
-
-    # See https://github.com/vim-ruby/vim-ruby/issues/318 for details
-    assert_correct_indenting <<~EOF
-      def foo
-        <<-EOS
-          one
-            \#{two} three
-              four
-        EOS
-      end
-    EOF
-  end
-
-  specify "comments" do
-    assert_correct_indenting <<~EOF
-      def one
-        example do |something|
-      =begin
-           something that is ignored
-      =end
-        end
-      end
-    EOF
-  end
-end
diff --git a/sources_non_forked/vim-ruby/spec/indent/blocks_spec.rb b/sources_non_forked/vim-ruby/spec/indent/blocks_spec.rb
deleted file mode 100644
index eb43b04..0000000
--- a/sources_non_forked/vim-ruby/spec/indent/blocks_spec.rb
+++ /dev/null
@@ -1,167 +0,0 @@
-require 'spec_helper'
-
-describe "Indenting" do
-  after :each do
-    vim.command 'let g:ruby_indent_block_style = "expression"'
-  end
-
-  specify "indented blocks with expression style" do
-    vim.command 'let g:ruby_indent_block_style = "expression"'
-
-    assert_correct_indenting <<~EOF
-      a.
-        b.
-        c do |x|
-        something
-      end
-
-      next_line
-    EOF
-
-    assert_correct_indenting <<~EOF
-      a.
-        b.
-        c { |x|
-        something
-      }
-
-      next_line
-    EOF
-  end
-
-  specify "indented blocks with do style" do
-    vim.command 'let g:ruby_indent_block_style = "do"'
-
-    assert_correct_indenting <<~EOF
-      a.
-        b.
-        c do |x|
-          something
-        end
-
-      next_line
-    EOF
-
-    # Check that "do" style indentation does not mess up indentation
-    # following the bock.
-    assert_correct_indenting <<~EOF
-      a.
-        b.
-        c do |x|
-          something
-        end
-
-      next_line
-    EOF
-
-    # Check that "do" style indenting works properly for brace blocks.
-    assert_correct_indenting <<~EOF
-      a.
-        b.
-        c { |x|
-          something
-        }
-
-      next_line
-    EOF
-  end
-
-  specify "'do' indenting" do
-    assert_correct_indenting <<~EOF
-      do
-        something
-      end
-    EOF
-
-    assert_correct_indenting <<~EOF
-      def foo
-        a_hash = {:do => 'bar'}
-      end
-    EOF
-
-    assert_correct_indenting <<~EOF
-      def foo(job)
-        job.do!
-      end
-    EOF
-  end
-
-  specify "blocks with assignment on the previous line" do
-    assert_correct_indenting <<~EOF
-      foo =
-        something do
-          "other"
-        end
-    EOF
-
-    assert_correct_indenting <<~EOF
-      @foo ||=
-        something do
-          "other"
-        end
-    EOF
-  end
-
-  specify "blocks with multiline parameters" do
-    assert_correct_indenting <<~EOF
-      def foo
-        opts.on('--coordinator host=HOST[,port=PORT]',
-                'Specify the HOST and the PORT of the coordinator') do |str|
-          h = sub_opts_to_hash(str)
-          puts h
-        end
-      end
-    EOF
-  end
-
-  specify "case-insensitive matching" do
-    vim.set 'ignorecase'
-    assert_correct_indenting <<~EOF
-      module X
-        Class.new do
-        end
-      end
-    EOF
-    vim.set 'ignorecase&'
-  end
-
-  specify "blocks with tuple arguments" do
-    assert_correct_indenting <<~EOF
-      proc do |(a, b)|
-        puts a
-        puts b
-      end
-    EOF
-
-    assert_correct_indenting <<~EOF
-      proc do |foo, (a, b), bar|
-        puts a
-        puts b
-      end
-    EOF
-
-    assert_correct_indenting <<~EOF
-      proc do |(a, (b, c)), d|
-        puts a, b
-        puts c, d
-      end
-    EOF
-  end
-
-  specify "blocks with default arguments" do
-    assert_correct_indenting <<~EOF
-      proc do |a = 1|
-        puts a
-      end
-    EOF
-
-    # See https://github.com/vim-ruby/vim-ruby/issues/304
-    assert_correct_indenting <<~EOF
-      proc do |a: "asdf", b:|
-        proc do
-          puts a, b
-        end
-      end
-    EOF
-  end
-end
diff --git a/sources_non_forked/vim-ruby/spec/indent/continuations_spec.rb b/sources_non_forked/vim-ruby/spec/indent/continuations_spec.rb
deleted file mode 100644
index 727da7d..0000000
--- a/sources_non_forked/vim-ruby/spec/indent/continuations_spec.rb
+++ /dev/null
@@ -1,326 +0,0 @@
-require 'spec_helper'
-
-describe "Indenting" do
-  specify "method chaining" do
-    assert_correct_indenting <<~EOF
-      some_object.
-        method_one.
-        method_two.
-        method_three
-    EOF
-
-    assert_correct_indenting <<~EOF
-      some_object
-        .method_one
-        .method_two
-        .method_three
-    EOF
-
-    assert_correct_indenting <<~EOF
-      some_object&.
-        method_one&.
-        method_two&.
-        method_three
-    EOF
-
-    assert_correct_indenting <<~EOF
-      some_object
-        &.method_one
-        &.method_two
-        &.method_three
-    EOF
-  end
-
-  specify "arrays" do
-    assert_correct_indenting <<~EOF
-      foo = [one,
-             two,
-             three]
-    EOF
-  end
-
-  specify "tricky string interpolation" do
-    # See https://github.com/vim-ruby/vim-ruby/issues/75 for details
-    assert_correct_indenting <<~EOF
-      puts %{\#{}}
-      puts "OK"
-    EOF
-
-    assert_correct_indenting <<~EOF
-      while true
-        begin
-          puts %{\#{x}}
-        rescue ArgumentError
-        end
-      end
-    EOF
-  end
-
-  specify "continuations after round braces" do
-    assert_correct_indenting <<~EOF
-      opts.on('--coordinator host=HOST[,port=PORT]',
-              'Specify the HOST and the PORT of the coordinator') do |str|
-        h = sub_opts_to_hash(str)
-        puts h
-      end
-    EOF
-  end
-
-  describe "assignments" do
-    after :each do
-      vim.command 'let g:ruby_indent_assignment_style = "hanging"'
-    end
-
-    specify "continuations after assignment" do
-      assert_correct_indenting <<~EOF
-        variable =
-          if condition?
-            1
-          else
-            2
-          end
-      EOF
-
-      assert_correct_indenting <<~EOF
-        variable = # evil comment
-          case something
-          when 'something'
-            something_else
-          else
-            other
-          end
-      EOF
-
-      assert_correct_indenting <<~EOF
-        variable = case something
-                   when 'something'
-                     something_else
-                   else
-                     other
-                   end
-      EOF
-
-      assert_correct_indenting <<~EOF
-        variable = if something == something_else
-                     something_else
-                   elsif other == none
-                     none
-                   else
-                     other
-                   end
-      EOF
-
-      assert_correct_indenting <<~EOF
-        variable = while
-                     break something
-                   end
-      EOF
-
-      assert_correct_indenting <<~EOF
-        variable = if [].
-                       map { |x| x * 2 }.
-                       filter { |x| x % 3 == 0 }.
-                       empty?
-                     something
-                   end
-      EOF
-
-      vim.command 'let g:ruby_indent_assignment_style = "variable"'
-
-      assert_correct_indenting <<~EOF
-        variable = case something # evil comment
-        when 'something'
-          something_else
-        else
-          other
-        end
-      EOF
-
-      assert_correct_indenting <<~EOF
-        variable = if something == something_else
-          something_else
-        elsif other == none
-          none
-        else
-          other
-        end
-      EOF
-
-      assert_correct_indenting <<~EOF
-        variable = while
-          break something
-        end
-      EOF
-
-      assert_correct_indenting <<~EOF
-        variable = if [].
-            map { |x| x * 2 }.
-            filter { |x| x % 3 == 0 }.
-            empty?
-          something
-        end
-      EOF
-    end
-  end
-
-  specify "continuations after hanging comma" do
-    assert_correct_indenting <<~EOF
-      array = [
-        :one,
-      ].each do |x|
-        puts x.to_s
-      end
-    EOF
-  end
-
-  specify "string interpolation" do
-    # For details, see:
-    #
-    #   https://github.com/vim-ruby/vim-ruby/issues/93
-    #   https://github.com/vim-ruby/vim-ruby/issues/160
-    #
-    assert_correct_indenting <<~EOF
-      command = %|\#{file}|
-      settings.log.info("Returning: \#{command}")
-    EOF
-
-    assert_correct_indenting <<~EOF
-      {
-        thing: "[\#{}]",
-        thong: "b"
-      }
-    EOF
-
-    assert_correct_indenting <<~EOF
-      {
-        a: "(\#{a})",
-        b: "(\#{b})",
-        c: "(c)",
-        d: "(d)",
-        e: "(e)",
-      }
-    EOF
-  end
-
-  specify "closing bracket not on its own line" do
-    # See https://github.com/vim-ruby/vim-ruby/issues/81 for details
-    assert_correct_indenting <<~EOF
-      one { two >>
-            three }
-      four
-    EOF
-  end
-
-  specify "lonesome single parenthesis in a method definition" do
-    # See https://github.com/vim-ruby/vim-ruby/issues/130 for details
-    assert_correct_indenting <<~EOF
-      def bar(
-        baz
-      )
-        return baz+1
-      end
-    EOF
-  end
-
-  specify "brackets on their own line, followed by a comma" do
-    # See https://github.com/vim-ruby/vim-ruby/issues/124 for details
-    assert_correct_indenting <<~EOF
-      bla = {
-        :one => [
-          {:bla => :blub}
-        ],
-        :two => (
-          {:blub => :abc}
-        ),
-        :three => {
-          :blub => :abc
-        },
-        :four => 'five'
-      }
-    EOF
-  end
-
-  specify "string with an and#" do
-    # See https://github.com/vim-ruby/vim-ruby/issues/108 for details
-    assert_correct_indenting <<~EOF
-      outside_block "and#" do
-        inside_block do
-        end
-      end
-    EOF
-  end
-
-  specify "continuation with a symbol at the end" do
-    # See https://github.com/vim-ruby/vim-ruby/issues/132 for details
-    assert_correct_indenting <<~EOF
-      foo = :+
-      # Next indents correctly
-    EOF
-  end
-
-  specify "continuation with a hanging comma" do
-    # See https://github.com/vim-ruby/vim-ruby/issues/139 for details
-    assert_correct_indenting <<~EOF
-      thing :foo
-      thing 'a',
-        'b'
-    EOF
-  end
-
-  specify "continuations in an if-clause condition" do
-    # See https://github.com/vim-ruby/vim-ruby/issues/215 for details
-    assert_correct_indenting <<~EOF
-      if foo || bar ||
-          bong &&
-          baz || bing
-        puts "foo"
-      end
-    EOF
-  end
-
-  specify "continuations with round brackets" do
-    # See https://github.com/vim-ruby/vim-ruby/issues/17 for details
-    assert_correct_indenting <<~EOF
-      foo and
-        (bar and
-         baz) and
-        bing
-    EOF
-  end
-
-  specify "block within an argument list" do
-    # See https://github.com/vim-ruby/vim-ruby/issues/312 for details
-    assert_correct_indenting <<~EOF
-      foo(
-        x: 1,
-        y: [1, 2, 3].map { |i|
-          i + 1
-        }
-      )
-    EOF
-  end
-
-  specify "backslashes" do
-    # See https://github.com/vim-ruby/vim-ruby/issues/311 for details
-    assert_correct_indenting <<~EOF
-      def foo
-        x = 1
-
-        string = ". \#{x}" \\
-          "xyz"
-
-        puts string
-        puts string
-      end
-    EOF
-  end
-
-  specify "wrong continuation within regex character class" do
-    # See https://github.com/vim-ruby/vim-ruby/issues/405 for details
-
-    assert_correct_indenting <<~EOF
-      extname = file.extname(url).split(/[?#]/).first
-      target_file = tempfile.new()
-    EOF
-  end
-end
diff --git a/sources_non_forked/vim-ruby/spec/indent/end_constructs_spec.rb b/sources_non_forked/vim-ruby/spec/indent/end_constructs_spec.rb
deleted file mode 100644
index e1bb173..0000000
--- a/sources_non_forked/vim-ruby/spec/indent/end_constructs_spec.rb
+++ /dev/null
@@ -1,31 +0,0 @@
-require 'spec_helper'
-
-describe "Indenting" do
-  specify "end constructs" do
-    assert_correct_indenting <<~EOF
-      f do
-        g { def h; end }
-      end
-    EOF
-
-    assert_correct_indenting <<~EOF
-      if foo
-        bar ; end
-      something_else
-    EOF
-
-    assert_correct_indenting <<~EOF
-      if bar ; end
-      something_else
-    EOF
-
-    assert_correct_indenting <<~EOF
-      foo do
-        foo = 3 . class
-        foo = lambda { class One; end }
-        foo = lambda { |args| class One; end }
-        foo = bar; class One; end
-      end
-    EOF
-  end
-end
diff --git a/sources_non_forked/vim-ruby/spec/indent/eruby_spec.rb b/sources_non_forked/vim-ruby/spec/indent/eruby_spec.rb
deleted file mode 100644
index 5428e0e..0000000
--- a/sources_non_forked/vim-ruby/spec/indent/eruby_spec.rb
+++ /dev/null
@@ -1,18 +0,0 @@
-require 'spec_helper'
-
-describe "Indenting" do
-  specify "closing html tag after multiline eruby tag" do
-    assert_correct_indenting 'erb', <<~EOF
-      <form>
-        <div>
-          <%= text_field_tag :email, nil,
-            placeholder: "email" %>
-          text
-          <%= text_field_tag :password, nil,
-            placeholder: "password" %>
-        </div>
-      </form>
-    EOF
-  end
-end
-
diff --git a/sources_non_forked/vim-ruby/spec/indent/identifiers_spec.rb b/sources_non_forked/vim-ruby/spec/indent/identifiers_spec.rb
deleted file mode 100644
index 45f550c..0000000
--- a/sources_non_forked/vim-ruby/spec/indent/identifiers_spec.rb
+++ /dev/null
@@ -1,10 +0,0 @@
-require 'spec_helper'
-
-describe "Indenting" do
-  specify "identifiers containing keyword substrings" do
-    assert_correct_indenting <<~EOF
-      foo_def
-      42
-    EOF
-  end
-end
diff --git a/sources_non_forked/vim-ruby/spec/indent/indent_access_modifier_spec.rb b/sources_non_forked/vim-ruby/spec/indent/indent_access_modifier_spec.rb
deleted file mode 100644
index c2781e9..0000000
--- a/sources_non_forked/vim-ruby/spec/indent/indent_access_modifier_spec.rb
+++ /dev/null
@@ -1,137 +0,0 @@
-require 'spec_helper'
-
-describe "Indenting" do
-  after :each do
-    vim.command 'let g:ruby_indent_access_modifier_style = "normal"'
-  end
-
-  specify "default indented access modifiers" do
-    assert_correct_indenting <<~EOF
-      class OuterClass
-
-        private :method
-        protected :method
-        def method; end
-        protected
-        def method; end
-        private
-        def method; end
-        public
-        def method; end
-
-        class InnerClass
-
-          private :method
-          protected :method
-          def method; end
-          protected
-          def method; end
-          private
-          def method; end
-          public
-          def method; end
-
-        end
-
-        private :method
-        protected :method
-        def method; end
-        protected
-        def method; end
-        private
-        def method; end
-        public
-        def method; end
-
-      end
-    EOF
-  end
-
-  specify "indented access modifiers" do
-    vim.command 'let g:ruby_indent_access_modifier_style = "indent"'
-
-    assert_correct_indenting <<~EOF
-      class OuterClass
-
-        private :method
-        protected :method
-        def method; end
-        protected
-          def method; end
-        private
-          def method; end
-        public
-        def method; end
-
-        class InnerClass
-
-          private :method
-          protected :method
-          def method; end
-          protected
-            def method; end
-          private
-            def method; end
-          public
-          def method; end
-
-        end
-
-        private :method
-        protected :method
-        def method; end
-        protected
-          def method; end
-        private
-          def method; end
-        public
-        def method; end
-
-      end
-    EOF
-  end
-
-  specify "outdented access modifiers" do
-    vim.command 'let g:ruby_indent_access_modifier_style = "outdent"'
-
-    assert_correct_indenting <<~EOF
-      class OuterClass
-
-        private :method
-        protected :method
-        def method; end
-      protected
-        def method; end
-      private
-        def method; end
-      public
-        def method; end
-
-        class InnerClass
-
-          private :method
-          protected :method
-          def method; end
-        protected
-          def method; end
-        private
-          def method; end
-        public
-          def method; end
-
-        end
-
-        private :method
-        protected :method
-        def method; end
-      protected
-        def method; end
-      private
-        def method; end
-      public
-        def method; end
-
-      end
-    EOF
-  end
-end
diff --git a/sources_non_forked/vim-ruby/spec/indent/method_definitions_spec.rb b/sources_non_forked/vim-ruby/spec/indent/method_definitions_spec.rb
deleted file mode 100644
index 3c08592..0000000
--- a/sources_non_forked/vim-ruby/spec/indent/method_definitions_spec.rb
+++ /dev/null
@@ -1,40 +0,0 @@
-require 'spec_helper'
-
-describe "Indenting" do
-  specify "method definitions prefixed with access modifiers" do
-    assert_correct_indenting <<~EOF
-      class Foo
-        public def one(x)
-        end
-
-        private def two(y)
-          code
-        end
-      end
-    EOF
-  end
-
-  specify "method definitions prefixed with any method call" do
-    assert_correct_indenting <<~EOF
-      class Foo
-        foobar def one(x)
-        end
-        foobar? def one(x)
-        end
-        foobar! def one(x)
-        end
-
-         def one(x)
-        end
-
-        foobar
-        def one(x)
-        end
-
-        FooBar1 def two(y)
-          code
-        end
-      end
-    EOF
-  end
-end
diff --git a/sources_non_forked/vim-ruby/spec/indent/nesting_spec.rb b/sources_non_forked/vim-ruby/spec/indent/nesting_spec.rb
deleted file mode 100644
index 461aed2..0000000
--- a/sources_non_forked/vim-ruby/spec/indent/nesting_spec.rb
+++ /dev/null
@@ -1,66 +0,0 @@
-require 'spec_helper'
-
-describe "Indenting" do
-  specify "nested blocks" do
-    assert_correct_indenting <<~EOF
-      var.func1(:param => 'value') do
-        var.func2(:param => 'value') do
-          puts "test"
-        end
-      end
-    EOF
-
-    assert_correct_indenting <<~EOF
-      var.func1(:param => 'value') {
-        var.func2(:param => 'value') {
-          foo({ bar => baz })
-          puts "test one"
-          puts "test two"
-        }
-      }
-    EOF
-
-    assert_correct_indenting <<~EOF
-      var.
-        func1(:param => 'value') {
-        var.func2(:param => 'value') {
-          puts "test"
-        }
-      }
-    EOF
-  end
-
-  specify "nested hashes" do
-    assert_correct_indenting <<~EOF
-      foo, bar = {
-        :bar => {
-          :one => 'two',
-          :five => 'six'
-        }
-      }
-    EOF
-
-    assert_correct_indenting <<~EOF
-      foo,
-        bar = {
-        :bar => {
-          :foo => { 'bar' => 'baz' },
-          :one => 'two',
-          :three => 'four'
-        }
-      }
-    EOF
-  end
-
-  specify "nested blocks with a continuation and function call inbetween" do
-    assert_correct_indenting <<~EOF
-      var.
-        func1(:param => 'value') {
-        func1_5(:param => 'value')
-        var.func2(:param => 'value') {
-          puts "test"
-        }
-      }
-    EOF
-  end
-end
diff --git a/sources_non_forked/vim-ruby/spec/indent/splat_spec.rb b/sources_non_forked/vim-ruby/spec/indent/splat_spec.rb
deleted file mode 100644
index 1aa4684..0000000
--- a/sources_non_forked/vim-ruby/spec/indent/splat_spec.rb
+++ /dev/null
@@ -1,46 +0,0 @@
-require 'spec_helper'
-
-describe "Indenting" do
-  specify "splats with blocks in square brackets" do
-    assert_correct_indenting <<~EOF
-      x = Foo[*
-        y do
-          z
-        end
-      ]
-    EOF
-
-    assert_correct_indenting <<~EOF
-      x = Foo[* # with a comment
-        y do
-          z
-        end
-      ]
-    EOF
-  end
-
-  specify "splats with blocks in assignment" do
-    assert_correct_indenting <<~EOF
-      x = *
-        array.map do
-        3
-      end
-    EOF
-  end
-
-  specify "splats with blocks in round brackets" do
-    assert_correct_indenting <<~EOF
-      x = Foo(*y do
-        z
-      end)
-    EOF
-
-    assert_correct_indenting <<~EOF
-      x = Foo(
-        *y do
-          z
-        end
-      )
-    EOF
-  end
-end
diff --git a/sources_non_forked/vim-ruby/spec/spec_helper.rb b/sources_non_forked/vim-ruby/spec/spec_helper.rb
deleted file mode 100644
index db518e2..0000000
--- a/sources_non_forked/vim-ruby/spec/spec_helper.rb
+++ /dev/null
@@ -1,40 +0,0 @@
-require 'vimrunner'
-require 'vimrunner/rspec'
-
-Vimrunner::RSpec.configure do |config|
-  config.reuse_server = true
-
-  config.start_vim do
-    vim = Vimrunner.start_gvim
-    vim.prepend_runtimepath(File.expand_path('../..', __FILE__))
-    vim.add_plugin(File.expand_path('../vim', __FILE__), 'plugin/syntax_test.vim')
-    vim.set 'expandtab'
-    vim.set 'shiftwidth', 2
-    vim
-  end
-
-  def assert_correct_indenting(extension='rb', string)
-    filename = "test.#{extension}"
-
-    IO.write filename, string
-
-    vim.edit filename
-    vim.normal 'gg=G'
-    vim.write
-
-    expect(IO.read(filename)).to eq string
-  end
-
-  def assert_correct_highlighting(extension='rb', string, patterns, group)
-    filename = "test.#{extension}"
-
-    IO.write filename, string
-
-    vim.edit filename
-
-    Array(patterns).each do |pattern|
-      # TODO: add a custom matcher
-      expect(vim.echo("TestSyntax('#{pattern}', '#{group}')")).to eq '1'
-    end
-  end
-end
diff --git a/sources_non_forked/vim-ruby/spec/syntax/blocks_spec.rb b/sources_non_forked/vim-ruby/spec/syntax/blocks_spec.rb
deleted file mode 100644
index 87f07b4..0000000
--- a/sources_non_forked/vim-ruby/spec/syntax/blocks_spec.rb
+++ /dev/null
@@ -1,17 +0,0 @@
-require 'spec_helper'
-
-describe "Syntax highlighting" do
-  specify "block parameters" do
-    assert_correct_highlighting <<~'EOF', 'bar', 'rubySymbol'
-      foo { |bar:| 42 }
-    EOF
-    assert_correct_highlighting <<~'EOF', %w[bar\ze: baz\ze:], 'rubySymbol'
-      foo { |bar: 'bar', baz: 'baz'| 42 }
-    EOF
-  end
-  specify "block parameters with default values including '|'" do
-    assert_correct_highlighting <<~'EOF', %w[|\zebar qux)\zs|], 'rubyBlockParameterList'
-      foo { |bar=(baz|qux)| 42 }
-    EOF
-  end
-end
diff --git a/sources_non_forked/vim-ruby/spec/syntax/characters_spec.rb b/sources_non_forked/vim-ruby/spec/syntax/characters_spec.rb
deleted file mode 100644
index fb11c18..0000000
Binary files a/sources_non_forked/vim-ruby/spec/syntax/characters_spec.rb and /dev/null differ
diff --git a/sources_non_forked/vim-ruby/spec/syntax/comments_spec.rb b/sources_non_forked/vim-ruby/spec/syntax/comments_spec.rb
deleted file mode 100644
index 0e3da0e..0000000
--- a/sources_non_forked/vim-ruby/spec/syntax/comments_spec.rb
+++ /dev/null
@@ -1,54 +0,0 @@
-require 'spec_helper'
-
-describe "Syntax highlighting" do
-  specify "single line comments" do
-    assert_correct_highlighting <<~'EOF', '#.*', 'rubyComment'
-      # comment line
-    EOF
-  end
-
-  specify "end of line comments" do
-    assert_correct_highlighting <<~'EOF', '#.*', 'rubyComment'
-      foo = 42 # comment
-    EOF
-  end
-
-  specify "multiline comments" do
-    assert_correct_highlighting <<~'EOF', ['#.*line 1', '#.*line 2'], 'rubyComment'
-      # comment line 1
-      # comment line 2
-    EOF
-  end
-
-  specify "embedded documentation" do
-    assert_correct_highlighting <<~'EOF', 'documentation.*', 'rubyDocumentation'
-      =begin
-        documentation line
-      =end
-    EOF
-    # See issue #3
-    assert_correct_highlighting <<~'EOF', 'documentation.*', 'rubyDocumentation'
-      =begin rdoc
-        documentation line
-      =end rdoc
-    EOF
-  end
-
-  specify "magic comments" do
-    assert_correct_highlighting <<~'EOF', 'frozen_string_literal', 'rubyMagicComment'
-      # frozen_string_literal: true
-    EOF
-  end
-
-  specify "TODO comments" do
-    assert_correct_highlighting <<~'EOF', 'TODO', 'rubyTodo'
-      # TODO: turn off the oven
-    EOF
-  end
-
-  specify "shebang comments" do
-    assert_correct_highlighting <<~'EOF', '#.*', 'rubySharpBang'
-      #!/bin/ruby
-    EOF
-  end
-end
diff --git a/sources_non_forked/vim-ruby/spec/syntax/line_continuations_spec.rb b/sources_non_forked/vim-ruby/spec/syntax/line_continuations_spec.rb
deleted file mode 100644
index efd3aa7..0000000
--- a/sources_non_forked/vim-ruby/spec/syntax/line_continuations_spec.rb
+++ /dev/null
@@ -1,23 +0,0 @@
-require 'spec_helper'
-
-describe "Syntax highlighting" do
-  specify "useless line continuations" do
-    str = <<~'EOF'
-      foo = \
-        if true
-          42
-        end
-    EOF
-    assert_correct_highlighting str, '\\', 'rubyUselessLineContinuation'
-    assert_correct_highlighting str, 'if', 'rubyConditional'
-  end
-
-  specify "line continuations" do
-    str = <<~'EOF'
-      foo = 42 \
-        if true
-    EOF
-    assert_correct_highlighting str, '\\', 'rubyLineContinuation'
-    assert_correct_highlighting str, 'if', 'rubyConditionalModifier'
-  end
-end
diff --git a/sources_non_forked/vim-ruby/spec/syntax/maxmempattern_limit_spec.rb b/sources_non_forked/vim-ruby/spec/syntax/maxmempattern_limit_spec.rb
deleted file mode 100644
index 365ed63..0000000
--- a/sources_non_forked/vim-ruby/spec/syntax/maxmempattern_limit_spec.rb
+++ /dev/null
@@ -1,12 +0,0 @@
-require 'spec_helper'
-
-describe "Maxmempattern limit" do
-  specify "maxmempattern=1000 is enough even for long strings" do
-    str = <<~'EOF'
-      hash = {
-        "A-NOT-Managed-Strings" => "ABCDEfghe910dmckamks019292djdjOOOjjjd/cr3wdCA+1n/xHfHMgG+cC0EoUNngcBjgWvBMEF1CurBwTtDswJjQYa5wYRAQEBAQECCwGwAQEvI50CnwMNAwRrAQYBr9PPAoK7sQMBAQMCBAkICAQIAwEBAwYBAQQFFQEBAhQDAwMDCwEBAQUBAQHGAQEWBAEBDecBfS8CHQEKkAEMMxcMCQoUDwYHIjd3DQ4MFk0JWGYALSKLAQOLAYEBFBAjCBGDAQICAgMANjsZAg9fCxkCgLZKAwSEAQIBiwEZGAsrBCgFMmUEJShyFSfRBQEOSQY62AG0AVlCrQ",
-      }
-    EOF
-    assert_correct_highlighting str, %w[ABCDE], 'rubyString'
-  end
-end
diff --git a/sources_non_forked/vim-ruby/spec/syntax/methods_spec.rb b/sources_non_forked/vim-ruby/spec/syntax/methods_spec.rb
deleted file mode 100644
index 721fae4..0000000
--- a/sources_non_forked/vim-ruby/spec/syntax/methods_spec.rb
+++ /dev/null
@@ -1,36 +0,0 @@
-require 'spec_helper'
-
-describe "Syntax highlighting" do
-  specify "method definitions" do
-    str = <<~'EOF'
-      def foo bar
-      end
-    EOF
-    assert_correct_highlighting str, %w[def end], 'rubyDefine'
-    assert_correct_highlighting str, 'foo',       'rubyMethodName'
-  end
-
-  specify "method definitions named 'end'" do
-    assert_correct_highlighting <<~'EOF', 'end', 'rubyMethodName'
-      def end end
-    EOF
-    assert_correct_highlighting <<~'EOF', 'end', 'rubyMethodName'
-      def
-      end
-      end
-    EOF
-  end
-
-  specify "method parameters with symbol default values" do
-    assert_correct_highlighting <<~'EOF', ':baz', 'rubySymbol'
-      def foo bar=:baz
-      end
-    EOF
-  end
-
-  specify "unparenthesised method parameters with a required trailing keyword then semicolon" do
-    assert_correct_highlighting <<~'EOF', 'bar', 'rubySymbol'
-      def foo bar:; end
-    EOF
-  end
-end
diff --git a/sources_non_forked/vim-ruby/spec/syntax/operators_spec.rb b/sources_non_forked/vim-ruby/spec/syntax/operators_spec.rb
deleted file mode 100644
index f7f29db..0000000
--- a/sources_non_forked/vim-ruby/spec/syntax/operators_spec.rb
+++ /dev/null
@@ -1,204 +0,0 @@
-require 'spec_helper'
-
-describe "Syntax highlighting" do
-  before :each do
-    vim.command 'let g:ruby_operators = 1'
-  end
-  after :each do
-    vim.command 'unlet g:ruby_operators'
-  end
-
-  specify "defined? operator" do
-    assert_correct_highlighting 'defined? foo', 'defined?', 'rubyDefinedOperator'
-  end
-
-  specify "English boolean operators" do
-    assert_correct_highlighting <<~'EOF', %w[not and or], 'rubyEnglishBooleanOperator'
-      not true
-      true and false
-      true or false
-    EOF
-  end
-
-  specify "modulo-assignment operators" do
-    assert_correct_highlighting <<~'EOF', '%=', 'rubyAssignmentOperator'
-      foo %= bar
-    EOF
-  end
-
-  specify "ternary operators" do
-    assert_correct_highlighting <<~'EOF', %w[? :], 'rubyTernaryOperator'
-      foo = bar ? 4 : 2
-    EOF
-  end
-
-  context "bracket operators" do
-    specify "after a plain identifier" do
-      assert_correct_highlighting <<~'EOF', '\\[..]', 'rubyOperator'
-        foo[42]
-      EOF
-    end
-    specify "after a ?!-named bare method call" do
-      assert_correct_highlighting <<~'EOF', '\\[..]', 'rubyOperator'
-        foo?[42]
-      EOF
-    end
-    specify "after a closing parenthesis" do
-      assert_correct_highlighting <<~'EOF', '\\[..]', 'rubyOperator'
-        (foo)[42]
-      EOF
-    end
-    specify "after a literal hash" do
-      assert_correct_highlighting <<~'EOF', '\\[...]', 'rubyOperator'
-        { foo: bar }[foo]
-      EOF
-    end
-    specify "after a block arg method call" do
-      assert_correct_highlighting <<~'EOF', '\\[..]', 'rubyOperator'
-        foo { bar }[42]
-      EOF
-    end
-  end
-
-  specify "exponentiation operators" do
-    [
-      'foo**bar',
-      'foo ** bar',
-      'foo** bar',
-    ].each do |str|
-      assert_correct_highlighting str, '\*\*', 'rubyArithmeticOperator'
-    end
-  end
-
-  context "double splat operators" do
-    specify "in method definitions" do
-      assert_correct_highlighting <<~'EOF', '\*\*', 'rubyDoubleSplatOperator'
-        def foo(**bar)
-        end
-      EOF
-    end
-    specify "in multiline parameter list method definitions" do
-      assert_correct_highlighting <<~'EOF', '\*\*', 'rubyDoubleSplatOperator'
-        def foo(bar,
-                **baz)
-        end
-      EOF
-    end
-    specify "as an anonymous parameter in method definitions" do
-      assert_correct_highlighting <<~'EOF', '\*\*', 'rubyDoubleSplatOperator'
-        def foo(**)
-        end
-      EOF
-    end
-    specify "in unparenthesised method definitions" do
-      assert_correct_highlighting <<~'EOF', '\*\*', 'rubyDoubleSplatOperator'
-        def foo **bar
-        end
-      EOF
-    end
-    specify "in unparenthesised method calls" do
-      assert_correct_highlighting <<~'EOF', '\*\*', 'rubyDoubleSplatOperator'
-        foo **bar
-      EOF
-    end
-    specify "in block parameter lists" do
-      assert_correct_highlighting <<~'EOF', '\*\*', 'rubyDoubleSplatOperator'
-        foo { |**bar| 42 }
-      EOF
-    end
-  end
-
-  specify "multiplication operators" do
-    [
-      'foo*bar',
-      'foo * bar',
-      'foo* bar',
-    ].each do |str|
-      assert_correct_highlighting str, '\*', 'rubyArithmeticOperator'
-    end
-  end
-
-  context "splat operators" do
-    specify "in method definitions" do
-      assert_correct_highlighting <<~'EOF', '\*', 'rubySplatOperator'
-        def foo(*bar)
-        end
-      EOF
-    end
-    specify "in multiline parameter list method definitions" do
-      assert_correct_highlighting <<~'EOF', '\*', 'rubySplatOperator'
-        def foo(bar,
-                *baz)
-        end
-      EOF
-    end
-    specify "as an anonymous parameter in method definitions" do
-      assert_correct_highlighting <<~'EOF', '\*', 'rubySplatOperator'
-        def foo(*)
-        end
-      EOF
-    end
-    specify "in unparenthesised method definitions" do
-      assert_correct_highlighting <<~'EOF', '\*', 'rubySplatOperator'
-        def foo *bar
-        end
-      EOF
-    end
-    specify "in unparenthesised method calls" do
-      assert_correct_highlighting <<~'EOF', '\*', 'rubySplatOperator'
-        foo *bar
-      EOF
-    end
-    specify "in block parameter lists" do
-      assert_correct_highlighting <<~'EOF', '\*', 'rubySplatOperator'
-        foo { |*bar| 42 }
-      EOF
-    end
-  end
-
-  context "proc operators" do
-    specify "in method definitions" do
-      assert_correct_highlighting <<~'EOF', '&', 'rubyProcOperator'
-        def foo(&bar)
-        end
-      EOF
-    end
-    specify "in multiline parameter list method definitions" do
-      assert_correct_highlighting <<~'EOF', '&', 'rubyProcOperator'
-        def foo(bar,
-                &baz)
-        end
-      EOF
-    end
-    specify "in unparenthesised method definitions" do
-        assert_correct_highlighting <<~'EOF', '&', 'rubyProcOperator'
-          def foo &bar
-          end
-        EOF
-    end
-    specify "in unparenthesised method calls" do
-        assert_correct_highlighting <<~'EOF', '&', 'rubyProcOperator'
-            foo &bar
-        EOF
-    end
-    specify "before literal lambdas" do
-        assert_correct_highlighting <<~'EOF', '&', 'rubyProcOperator'
-            foo &->{}
-        EOF
-    end
-  end
-
-  specify "eigenclass operators" do
-      assert_correct_highlighting <<~'EOF', '<<', 'rubyEigenClassOperator'
-        class << self
-        end
-      EOF
-  end
-
-  specify "superclass operators" do
-      assert_correct_highlighting <<~'EOF', '<', 'rubySuperClassOperator'
-        class Foo < Bar
-        end
-      EOF
-  end
-end
diff --git a/sources_non_forked/vim-ruby/spec/syntax/regular_expressions_spec.rb b/sources_non_forked/vim-ruby/spec/syntax/regular_expressions_spec.rb
deleted file mode 100644
index d02cb2a..0000000
--- a/sources_non_forked/vim-ruby/spec/syntax/regular_expressions_spec.rb
+++ /dev/null
@@ -1,21 +0,0 @@
-require 'spec_helper'
-
-describe "Syntax highlighting" do
-  # See issue #171
-  specify "ambiguous / at end of line is not a regexp" do
-    vim.command 'let g:ruby_operators = 1'
-    assert_correct_highlighting <<~'EOF', '/', 'rubyArithmeticOperator'
-      a = calculate(90).and_some_long_expression /
-          and_long_expression_here
-      puts a
-    EOF
-    vim.command 'unlet g:ruby_operators'
-  end
-
-  # See issue #63
-  specify "interpolated regexp in a host regexp" do
-    assert_correct_highlighting <<~'EOF', '/$', 'rubyRegexpDelimiter'
-      /#{foo.sub(/bar/, 'baz')}/
-    EOF
-  end
-end
diff --git a/sources_non_forked/vim-ruby/spec/syntax/statement_modifiers_spec.rb b/sources_non_forked/vim-ruby/spec/syntax/statement_modifiers_spec.rb
deleted file mode 100644
index c71ec99..0000000
--- a/sources_non_forked/vim-ruby/spec/syntax/statement_modifiers_spec.rb
+++ /dev/null
@@ -1,31 +0,0 @@
-require 'spec_helper'
-
-describe "Syntax highlighting" do
-  specify "only modifiers can appear after regexp literals" do
-    # See issue #254
-    assert_correct_highlighting <<~'EOF', 'if', 'rubyConditionalModifier'
-      def get_regex
-        /some regex/ if false
-      end
-    EOF
-  end
-
-  specify "only modifiers can appear after unparenthesised no-arg method calls" do
-    [
-      "foo    if true",
-      "foo?   if true",
-      "foo!   if true",
-      "foo_   if true",
-      "foo_?  if true",
-      "foo_!  if true",
-      "foo42  if true",
-      "foo42? if true",
-      "foo42! if true",
-      "Foo    if true",
-      "Foo?   if true",
-      "Foo!   if true"
-    ].each do |str|
-      assert_correct_highlighting str, 'if', 'rubyConditionalModifier'
-    end
-  end
-end
diff --git a/sources_non_forked/vim-ruby/spec/syntax/strings/heredoc_spec.rb b/sources_non_forked/vim-ruby/spec/syntax/strings/heredoc_spec.rb
deleted file mode 100644
index a74160a..0000000
--- a/sources_non_forked/vim-ruby/spec/syntax/strings/heredoc_spec.rb
+++ /dev/null
@@ -1,26 +0,0 @@
-require 'spec_helper'
-
-describe "Syntax highlighting" do
-  specify "heredocs starting after parenthesised method definitions" do
-    # See issue #356
-    assert_correct_highlighting <<~'EOF', 'HTML', 'rubyHeredocDelimiter'
-        def youtube_video(token, width = 360, height = 215)
-            <<-HTML if token
-      <iframe width="#{width}" height="#{height}" src="http://www.youtube.com/embed/#{token}" frameborder="0" allowfullscreen></iframe>
-            HTML
-        end
-    EOF
-  end
-
-  specify "heredocs do not start after string literals" do
-    assert_correct_highlighting <<~'EOF', 'FOO', 'rubyConstant'
-      "abc" <<FOO
-    EOF
-    assert_correct_highlighting <<~'EOF', 'FOO', 'rubyConstant'
-      'abc' <<FOO
-    EOF
-    assert_correct_highlighting <<~'EOF', 'FOO', 'rubyConstant'
-      `abc` <<FOO
-    EOF
-  end
-end
diff --git a/sources_non_forked/vim-ruby/spec/syntax/strings/interpolation_spec.rb b/sources_non_forked/vim-ruby/spec/syntax/strings/interpolation_spec.rb
deleted file mode 100644
index 50333bf..0000000
--- a/sources_non_forked/vim-ruby/spec/syntax/strings/interpolation_spec.rb
+++ /dev/null
@@ -1,9 +0,0 @@
-require 'spec_helper'
-
-describe "Syntax highlighting" do
-  specify "invalid interpolated predefined global variables are literal text" do
-    assert_correct_highlighting <<~'EOF', '#\$', 'rubyString'
-      "abc(#$)def"
-    EOF
-  end
-end
diff --git a/sources_non_forked/vim-ruby/spec/syntax/strings/strings_spec.rb b/sources_non_forked/vim-ruby/spec/syntax/strings/strings_spec.rb
deleted file mode 100644
index 0c1e8a2..0000000
--- a/sources_non_forked/vim-ruby/spec/syntax/strings/strings_spec.rb
+++ /dev/null
@@ -1,9 +0,0 @@
-require 'spec_helper'
-
-describe "Syntax highlighting" do
-  specify "percent strings with a modulo-assignment operator look-alike delimiter" do
-    assert_correct_highlighting <<~'EOF', '%=', 'rubyPercentStringDelimiter'
-      foo = %= bar =
-    EOF
-  end
-end
diff --git a/sources_non_forked/vim-ruby/spec/syntax/symbols_spec.rb b/sources_non_forked/vim-ruby/spec/syntax/symbols_spec.rb
deleted file mode 100644
index b0aad72..0000000
--- a/sources_non_forked/vim-ruby/spec/syntax/symbols_spec.rb
+++ /dev/null
@@ -1,45 +0,0 @@
-require 'spec_helper'
-
-describe "Syntax highlighting" do
-  # See issue #356
-  specify "hashes with symbol keys and values on different lines" do
-    assert_correct_highlighting <<~'EOF', 'x', 'rubySymbol'
-      h = {
-        x:
-          really_long_method_name,
-        y: 5,
-      }
-    EOF
-  end
-
-  # See issue #44
-  specify "1.9 style hash keys with keyword names" do
-    assert_correct_highlighting <<~EOF, %w[class if def include case end], 'rubySymbol'
-      { class: "hello", if: "world", def: "i am", include: "foo", case: "bar", end: "baz" }
-    EOF
-
-    assert_correct_highlighting <<~'EOF', 'end', 'rubyDefine'
-      def hello
-        { if: "world" }
-      end
-    EOF
-  end
-
-  # See issue #144
-  specify "1.9 style hash keys with keyword names in parameter lists" do
-    assert_correct_highlighting <<~'EOF', 'prepend', 'rubySymbol'
-      {prepend: true}
-    EOF
-    assert_correct_highlighting <<~'EOF', 'for', 'rubySymbol'
-      Subscription.generate(for: topic,
-                            to:  subscriber)
-    EOF
-  end
-
-  # See issue #12
-  specify "1.9 style hash keys with keyword names in argument lists" do
-    assert_correct_highlighting <<~EOF, %w[:\zsgender in\ze: if\ze: :\zsgender_required?], 'rubySymbol'
-      validates_inclusion_of :gender, in: %w(male female), if: :gender_required?
-    EOF
-  end
-end
diff --git a/sources_non_forked/vim-ruby/spec/vim/plugin/syntax_test.vim b/sources_non_forked/vim-ruby/spec/vim/plugin/syntax_test.vim
deleted file mode 100644
index db84204..0000000
--- a/sources_non_forked/vim-ruby/spec/vim/plugin/syntax_test.vim
+++ /dev/null
@@ -1,21 +0,0 @@
-
-let s:debug = 0
-
-function! s:CursorHasGroup(group) abort
-  return synIDattr(synID(line('.'), col('.'), 0), 'name') =~ a:group
-endfunction
-
-function! TestSyntax(pattern, group) abort
-  let pattern = '\C' . a:pattern
-  call cursor(1, 1)
-  redraw
-  let start_match = search(pattern, 'c') && s:CursorHasGroup(a:group)
-  if s:debug
-    redraw | sleep 500m
-  endif
-  let end_match   = search(pattern, 'e') && s:CursorHasGroup(a:group)
-  if s:debug
-    redraw | sleep 500m
-  endif
-  return start_match && end_match
-endfunction
diff --git a/sources_non_forked/vim-ruby/syntax/eruby.vim b/sources_non_forked/vim-ruby/syntax/eruby.vim
deleted file mode 100644
index bb51cb0..0000000
--- a/sources_non_forked/vim-ruby/syntax/eruby.vim
+++ /dev/null
@@ -1,80 +0,0 @@
-" Vim syntax file
-" Language:		eRuby
-" Maintainer:		Tim Pope <vimNOSPAM@tpope.org>
-" URL:			https://github.com/vim-ruby/vim-ruby
-" Release Coordinator:	Doug Kearns <dougkearns@gmail.com>
-
-if &syntax !~# '\<eruby\>' || get(b:, 'current_syntax') =~# '\<eruby\>'
-  finish
-endif
-
-if !exists("main_syntax")
-  let main_syntax = 'eruby'
-endif
-
-if !exists("g:eruby_default_subtype")
-  let g:eruby_default_subtype = "html"
-endif
-
-if &filetype =~ '^eruby\.'
-  let b:eruby_subtype = matchstr(&filetype,'^eruby\.\zs\w\+')
-elseif &filetype =~ '^.*\.eruby\>'
-  let b:eruby_subtype = matchstr(&filetype,'^.\{-\}\ze\.eruby\>')
-elseif !exists("b:eruby_subtype") && main_syntax == 'eruby'
-  let s:lines = getline(1)."\n".getline(2)."\n".getline(3)."\n".getline(4)."\n".getline(5)."\n".getline("$")
-  let b:eruby_subtype = matchstr(s:lines,'eruby_subtype=\zs\w\+')
-  if b:eruby_subtype == ''
-    let b:eruby_subtype = matchstr(substitute(expand("%:t"),'\c\%(\.erb\|\.eruby\|\.erubis\|\.example\)\+$','',''),'\.\zs\w\+\%(\ze+\w\+\)\=$')
-  endif
-  if b:eruby_subtype == 'rhtml'
-    let b:eruby_subtype = 'html'
-  elseif b:eruby_subtype == 'rb'
-    let b:eruby_subtype = 'ruby'
-  elseif b:eruby_subtype == 'yml'
-    let b:eruby_subtype = 'yaml'
-  elseif b:eruby_subtype == 'js'
-    let b:eruby_subtype = 'javascript'
-  elseif b:eruby_subtype == 'txt'
-    " Conventional; not a real file type
-    let b:eruby_subtype = 'text'
-  elseif b:eruby_subtype == ''
-    let b:eruby_subtype = g:eruby_default_subtype
-  endif
-endif
-
-if !exists("b:eruby_nest_level")
-  if &syntax =~# '\<eruby\.eruby\>'
-    let b:eruby_nest_level = strlen(substitute(substitute(&filetype,'\C\<eruby\>','@','g'),'[^@]','','g'))
-  else
-    let b:eruby_nest_level = strlen(substitute(substitute(substitute(expand("%:t"),'@','','g'),'\c\.\%(erb\|rhtml\)\>','@','g'),'[^@]','','g'))
-  endif
-endif
-if !b:eruby_nest_level
-  let b:eruby_nest_level = 1
-endif
-
-if get(b:, 'eruby_subtype', '') !~# '^\%(eruby\)\=$' && &syntax =~# '^eruby\>'
-  exe "runtime! syntax/".b:eruby_subtype.".vim"
-endif
-unlet! b:current_syntax
-syn include @rubyTop syntax/ruby.vim
-
-syn cluster erubyRegions contains=erubyOneLiner,erubyBlock,erubyExpression,erubyComment
-
-exe 'syn region  erubyOneLiner   matchgroup=erubyDelimiter start="^%\{1,'.b:eruby_nest_level.'\}%\@!"    end="$"     contains=@rubyTop	     containedin=ALLBUT,@erubyRegions keepend oneline'
-exe 'syn region  erubyBlock      matchgroup=erubyDelimiter start="<%\{1,'.b:eruby_nest_level.'\}%\@!-\=" end="[=-]\=%\@<!%\{1,'.b:eruby_nest_level.'\}>" contains=@rubyTop  containedin=ALLBUT,@erubyRegions keepend'
-exe 'syn region  erubyExpression matchgroup=erubyDelimiter start="<%\{1,'.b:eruby_nest_level.'\}=\{1,4}" end="[=-]\=%\@<!%\{1,'.b:eruby_nest_level.'\}>" contains=@rubyTop  containedin=ALLBUT,@erubyRegions keepend'
-exe 'syn region  erubyComment    matchgroup=erubyDelimiter start="<%\{1,'.b:eruby_nest_level.'\}-\=#"    end="[=-]\=%\@<!%\{1,'.b:eruby_nest_level.'\}>" contains=rubyTodo,@Spell containedin=ALLBUT,@erubyRegions keepend'
-
-" Define the default highlighting.
-
-hi def link erubyDelimiter		PreProc
-hi def link erubyComment		Comment
-
-let b:current_syntax = matchstr(&syntax, '^.*\<eruby\>')
-
-if main_syntax == 'eruby'
-  unlet main_syntax
-endif
-
-" vim: nowrap sw=2 sts=2 ts=8:
diff --git a/sources_non_forked/vim-ruby/syntax/ruby.vim b/sources_non_forked/vim-ruby/syntax/ruby.vim
deleted file mode 100644
index 8f7a51c..0000000
--- a/sources_non_forked/vim-ruby/syntax/ruby.vim
+++ /dev/null
@@ -1,595 +0,0 @@
-" Vim syntax file
-" Language:		Ruby
-" Maintainer:		Doug Kearns <dougkearns@gmail.com>
-" URL:			https://github.com/vim-ruby/vim-ruby
-" Release Coordinator:	Doug Kearns <dougkearns@gmail.com>
-" ----------------------------------------------------------------------------
-"
-" Previous Maintainer:	Mirko Nasato
-" Thanks to perl.vim authors, and to Reimer Behrends. :-) (MN)
-" ----------------------------------------------------------------------------
-
-" Prelude {{{1
-if exists("b:current_syntax")
-  finish
-endif
-
-" this file uses line continuations
-let s:cpo_sav = &cpo
-set cpo&vim
-
-" eRuby Config {{{1
-if exists('main_syntax') && main_syntax == 'eruby'
-  let b:ruby_no_expensive = 1
-endif
-
-" Folding Config {{{1
-if has("folding") && exists("ruby_fold")
-  setlocal foldmethod=syntax
-endif
-
-let s:foldable_groups = split(
-      \	  get(
-      \	    b:,
-      \	    'ruby_foldable_groups',
-      \	    get(g:, 'ruby_foldable_groups', 'ALL')
-      \	  )
-      \	)
-
-function! s:foldable(...) abort
-  if index(s:foldable_groups, 'NONE') > -1
-    return 0
-  endif
-
-  if index(s:foldable_groups, 'ALL') > -1
-    return 1
-  endif
-
-  for l:i in a:000
-    if index(s:foldable_groups, l:i) > -1
-      return 1
-    endif
-  endfor
-
-  return 0
-endfunction
-
-function! s:run_syntax_fold(args) abort
-  let [_0, _1, groups, cmd; _] = matchlist(a:args, '\(["'']\)\(.\{-}\)\1\s\+\(.*\)')
-  if call('s:foldable', split(groups))
-    let cmd .= ' fold'
-  endif
-  exe cmd
-endfunction
-
-com! -nargs=* SynFold call s:run_syntax_fold(<q-args>)
-
-" Not-Top Cluster {{{1
-syn cluster rubyNotTop contains=@rubyCommentNotTop,@rubyStringNotTop,@rubyRegexpSpecial,@rubyDeclaration,@rubyExceptionHandler,@rubyClassOperator,rubyConditional,rubyModuleName,rubyClassName,rubySymbolDelimiter,rubyParentheses
-
-" Whitespace Errors {{{1
-if exists("ruby_space_errors")
-  if !exists("ruby_no_trail_space_error")
-    syn match rubySpaceError display excludenl "\s\+$"
-  endif
-  if !exists("ruby_no_tab_space_error")
-    syn match rubySpaceError display " \+\t"me=e-1
-  endif
-endif
-
-" Operators {{{1
-
-syn match rubyEnglishBooleanOperator "\<\%(and\|or\|not\)\>"
-
-if exists("ruby_operators") || exists("ruby_pseudo_operators")
-  syn match rubyDotOperator	   "\.\|&\."
-
-  syn match rubyTernaryOperator    "\%(\w\|[^\x00-\x7F]\)\@1<!?\|:"
-  syn match rubyArithmeticOperator "\*\*\|[*/%+]\|->\@!"
-  syn match rubyComparisonOperator "<=>\|<=\|<\|>=\|[-=]\@1<!>"
-  syn match rubyBitwiseOperator    "[~^|]\|&\.\@!\|<<\|>>"
-  syn match rubyBooleanOperator    "\%(\w\|[^\x00-\x7F]\)\@1<!!\|&&\|||"
-  syn match rubyRangeOperator	   "\.\.\.\="
-  syn match rubyAssignmentOperator "=>\@!\|-=\|/=\|\*\*=\|\*=\|&&=\|&=\|||=\||=\|%=\|+=\|>>=\|<<=\|\^="
-  syn match rubyAssignmentOperator "=>\@!" contained containedin=rubyBlockParameterList " TODO: this is inelegant
-  syn match rubyEqualityOperator   "===\|==\|!=\|!\~\|=\~"
-
-  syn region rubyBracketOperator matchgroup=rubyOperator start="\%(\%(\w\|[^\x00-\x7F]\)[?!]\=\|[]})]\)\@2<=\[" end="]" contains=ALLBUT,@rubyNotTop
-
-  syn match rubyScopeOperator	    "::"
-  syn match rubySuperClassOperator  "<"	 contained
-  syn match rubyEigenClassOperator  "<<" contained
-  syn match rubyLambdaOperator	    "->"
-  syn match rubySplatOperator	    "\%([[{(|,=]\_s*\)\@<=\*"
-  syn match rubySplatOperator	    "\%(^\|\s\)\@1<=\*\%(\h\|[^\x00-\x7F]\|[:$@[]\)\@="
-  syn match rubyDoubleSplatOperator "\%([{(|,]\_s*\)\@<=\*\*"
-  syn match rubyDoubleSplatOperator "\s\@1<=\*\*\%(\h\|[^\x00-\x7F]\|[:$@{]\)\@="
-  syn match rubyProcOperator	    "\%([[(|,]\_s*\)\@<=&"
-  syn match rubyProcOperator	    "\s\@1<=&\%(\h\|[^\x00-\x7F]\|[:$@]\|->\)\@="
-
-  syn cluster rubyProperOperator contains=rubyTernaryOperator,rubyArithmeticOperator,rubyComparisonOperator,rubyBitwiseOperator,rubyBooleanOperator,rubyRangeOperator,rubyAssignmentOperator,rubyEqualityOperator,rubyDefinedOperator,rubyEnglishBooleanOperator
-  syn cluster rubyClassOperator  contains=rubyEigenClassOperator,rubySuperClassOperator
-  syn cluster rubyPseudoOperator contains=rubyDotOperator,rubyScopeOperator,rubyEigenClassOperator,rubySuperClassOperator,rubyLambdaOperator,rubySplatOperator,rubyDoubleSplatOperator,rubyProcOperator
-  syn cluster rubyOperator	 contains=ruby.*Operator
-endif
-
-" String Interpolation and Backslash Notation {{{1
-syn region rubyInterpolation	      matchgroup=rubyInterpolationDelimiter start="#{" end="}" contained contains=ALLBUT,@rubyNotTop
-syn match  rubyInterpolation	      "#\$\%(-\w\|[!$&"'*+,./0:;<>?@\`~_]\|\w\+\)" display contained contains=rubyInterpolationDelimiter,@rubyGlobalVariable
-syn match  rubyInterpolation	      "#@@\=\w\+"				   display contained contains=rubyInterpolationDelimiter,rubyInstanceVariable,rubyClassVariable
-syn match  rubyInterpolationDelimiter "#\ze[$@]"				   display contained
-
-syn match rubyStringEscape "\\\_."											   contained display
-syn match rubyStringEscape "\\\o\{1,3}\|\\x\x\{1,2}"									   contained display
-syn match rubyStringEscape "\\u\%(\x\{4}\|{\x\{1,6}\%(\s\+\x\{1,6}\)*}\)"						   contained display
-syn match rubyStringEscape "\%(\\M-\\C-\|\\C-\\M-\|\\M-\\c\|\\c\\M-\|\\c\|\\C-\|\\M-\)\%(\\\o\{1,3}\|\\x\x\{1,2}\|\\\=.\)" contained display
-
-syn match rubyBackslashEscape "\\\\" contained display
-syn match rubyQuoteEscape     "\\'"  contained display
-syn match rubySpaceEscape     "\\ "  contained display
-
-syn match rubyParenthesisEscape	  "\\[()]"  contained display
-syn match rubyCurlyBraceEscape	  "\\[{}]"  contained display
-syn match rubyAngleBracketEscape  "\\[<>]"  contained display
-syn match rubySquareBracketEscape "\\[[\]]" contained display
-
-syn region rubyNestedParentheses    start="("  skip="\\\\\|\\)"  matchgroup=rubyString end=")"	transparent contained
-syn region rubyNestedCurlyBraces    start="{"  skip="\\\\\|\\}"  matchgroup=rubyString end="}"	transparent contained
-syn region rubyNestedAngleBrackets  start="<"  skip="\\\\\|\\>"  matchgroup=rubyString end=">"	transparent contained
-syn region rubyNestedSquareBrackets start="\[" skip="\\\\\|\\\]" matchgroup=rubyString end="\]"	transparent contained
-
-syn cluster rubySingleCharEscape contains=rubyBackslashEscape,rubyQuoteEscape,rubySpaceEscape,rubyParenthesisEscape,rubyCurlyBraceEscape,rubyAngleBracketEscape,rubySquareBracketEscape
-syn cluster rubyNestedBrackets	 contains=rubyNested.\+
-syn cluster rubyStringSpecial	 contains=rubyInterpolation,rubyStringEscape
-syn cluster rubyStringNotTop	 contains=@rubyStringSpecial,@rubyNestedBrackets,@rubySingleCharEscape
-
-" Regular Expression Metacharacters {{{1
-syn region rubyRegexpComment	  matchgroup=rubyRegexpSpecial	 start="(?#"								    skip="\\\\\|\\)"  end=")"  contained
-syn region rubyRegexpParens	  matchgroup=rubyRegexpSpecial	 start="(\(?:\|?<\=[=!]\|?>\|?<[a-z_]\w*>\|?[imx]*-[imx]*:\=\|\%(?#\)\@!\)" skip="\\\\\|\\)"  end=")"  contained transparent contains=@rubyRegexpSpecial
-syn region rubyRegexpBrackets	  matchgroup=rubyRegexpCharClass start="\[\^\="								    skip="\\\\\|\\\]" end="\]" contained transparent contains=rubyRegexpBrackets,rubyStringEscape,rubyRegexpEscape,rubyRegexpCharClass,rubyRegexpIntersection oneline
-syn match  rubyRegexpCharClass	  "\\[DdHhRSsWw]"	 contained display
-syn match  rubyRegexpCharClass	  "\[:\^\=\%(alnum\|alpha\|ascii\|blank\|cntrl\|digit\|graph\|lower\|print\|punct\|space\|upper\|word\|xdigit\):\]" contained
-syn match  rubyRegexpCharClass	  "\\[pP]{^\=.\{-}}"	 contained display
-syn match  rubyRegexpEscape	  "\\[].*?+^$|\\/(){}[]" contained " see commit e477f10
-syn match  rubyRegexpQuantifier	  "[*?+][?+]\="		 contained display
-syn match  rubyRegexpQuantifier	  "{\d\+\%(,\d*\)\=}?\=" contained display
-syn match  rubyRegexpAnchor	  "[$^]\|\\[ABbGZz]"	 contained display
-syn match  rubyRegexpDot	  "\.\|\\X"		 contained display
-syn match  rubyRegexpIntersection "&&"			 contained display
-syn match  rubyRegexpSpecial	  "\\K"			 contained display
-syn match  rubyRegexpSpecial	  "|"			 contained display
-syn match  rubyRegexpSpecial	  "\\[1-9]\d\=\d\@!"	 contained display
-syn match  rubyRegexpSpecial	  "\\k<\%([a-z_]\w*\|-\=\d\+\)\%([+-]\d\+\)\=>" contained display
-syn match  rubyRegexpSpecial	  "\\k'\%([a-z_]\w*\|-\=\d\+\)\%([+-]\d\+\)\='" contained display
-syn match  rubyRegexpSpecial	  "\\g<\%([a-z_]\w*\|-\=\d\+\)>"		contained display
-syn match  rubyRegexpSpecial	  "\\g'\%([a-z_]\w*\|-\=\d\+\)'"		contained display
-
-syn cluster rubyRegexpSpecial contains=@rubyStringSpecial,rubyRegexpSpecial,rubyRegexpEscape,rubyRegexpBrackets,rubyRegexpCharClass,rubyRegexpDot,rubyRegexpQuantifier,rubyRegexpAnchor,rubyRegexpParens,rubyRegexpComment,rubyRegexpIntersection
-
-" Numbers {{{1
-syn match rubyInteger "\%(\%(\w\|[^\x00-\x7F]\|[]})\"']\s*\)\@<!-\)\=\<0[xX]\x\+\%(_\x\+\)*r\=i\=\>"							       display
-syn match rubyInteger "\%(\%(\w\|[^\x00-\x7F]\|[]})\"']\s*\)\@<!-\)\=\<\%(0[dD]\)\=\%(0\|[1-9]\d*\%(_\d\+\)*\)r\=i\=\>"					       display
-syn match rubyInteger "\%(\%(\w\|[^\x00-\x7F]\|[]})\"']\s*\)\@<!-\)\=\<0[oO]\=\o\+\%(_\o\+\)*r\=i\=\>"							       display
-syn match rubyInteger "\%(\%(\w\|[^\x00-\x7F]\|[]})\"']\s*\)\@<!-\)\=\<0[bB][01]\+\%(_[01]\+\)*r\=i\=\>"						       display
-syn match rubyFloat   "\%(\%(\w\|[^\x00-\x7F]\|[]})\"']\s*\)\@<!-\)\=\<\%(0\|[1-9]\d*\%(_\d\+\)*\)\.\d\+\%(_\d\+\)*r\=i\=\>"				       display
-syn match rubyFloat   "\%(\%(\w\|[^\x00-\x7F]\|[]})\"']\s*\)\@<!-\)\=\<\%(0\|[1-9]\d*\%(_\d\+\)*\)\%(\.\d\+\%(_\d\+\)*\)\=\%([eE][-+]\=\d\+\%(_\d\+\)*\)i\=\>" display
-
-" Identifiers {{{1
-syn match rubyClassName	       "\%(\%(^\|[^.]\)\.\s*\)\@<!\<[[:upper:]]\%(\w\|[^\x00-\x7F]\)*\>\%(\s*(\)\@!" contained
-syn match rubyModuleName       "\%(\%(^\|[^.]\)\.\s*\)\@<!\<[[:upper:]]\%(\w\|[^\x00-\x7F]\)*\>\%(\s*(\)\@!" contained
-syn match rubyConstant	       "\%(\%(^\|[^.]\)\.\s*\)\@<!\<[[:upper:]]\%(\w\|[^\x00-\x7F]\)*\>\%(\s*(\)\@!"
-syn match rubyClassVariable    "@@\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*" display
-syn match rubyInstanceVariable "@\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*"  display
-syn match rubyGlobalVariable   "$\%(\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*\|-.\)"
-syn match rubySymbolDelimiter  ":" contained
-syn match rubySymbol	       "[]})\"':]\@1<!:\%(\^\|\~@\|\~\|<<\|<=>\|<=\|<\|===\|[=!]=\|[=!]\~\|!@\|!\|>>\|>=\|>\||\|-@\|-\|/\|\[]=\|\[]\|\*\*\|\*\|&\|%\|+@\|+\|`\)" contains=rubySymbolDelimiter
-syn match rubySymbol	       "[]})\"':]\@1<!:\$\%(-.\|[`~<=>_,;:!?/.'"@$*\&+0]\)"			    contains=rubySymbolDelimiter
-syn match rubySymbol	       "[]})\"':]\@1<!:\%(\$\|@@\=\)\=\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*"  contains=rubySymbolDelimiter
-syn match rubySymbol	       "[]})\"':]\@1<!:\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*\%([?!=]>\@!\)\=" contains=rubySymbolDelimiter
-
-SynFold ':' syn region rubySymbol matchgroup=rubySymbolDelimiter start="[]})\"':]\@1<!:'"  end="'"  skip="\\\\\|\\'"  contains=rubyQuoteEscape,rubyBackslashEscape
-SynFold ':' syn region rubySymbol matchgroup=rubySymbolDelimiter start="[]})\"':]\@1<!:\"" end="\"" skip="\\\\\|\\\"" contains=@rubyStringSpecial
-
-syn match rubyCapitalizedMethod "\%(\%(^\|[^.]\)\.\s*\)\@<!\<\u\%(\w\|[^\x00-\x7F]\)*\>\%(\s*(\)\@="
-
-syn region rubyParentheses	  start="("				 end=")" contains=ALLBUT,@rubyNotTop contained containedin=rubyBlockParameterList
-syn region rubyBlockParameterList start="\%(\%(\<do\>\|{\)\_s*\)\@32<=|" end="|" contains=ALLBUT,@rubyNotTop,@rubyProperOperator
-
-if exists('ruby_global_variable_error')
-  syn match rubyGlobalVariableError "$[^A-Za-z_]"	display
-  syn match rubyGlobalVariableError "$-[^0FIKWadilpvw]" display
-endif
-
-syn match rubyPredefinedVariable #$[!$&"'*+,./0:;<>?@\`~]#
-syn match rubyPredefinedVariable "$\d\+"									    display
-syn match rubyPredefinedVariable "$_\>"										    display
-syn match rubyPredefinedVariable "$-[0FIWadilpvw]\>"								    display
-syn match rubyPredefinedVariable "$\%(stderr\|stdin\|stdout\)\>"						    display
-syn match rubyPredefinedVariable "$\%(DEBUG\|FILENAME\|LOADED_FEATURES\|LOAD_PATH\|PROGRAM_NAME\|SAFE\|VERBOSE\)\>" display
-syn match rubyPredefinedConstant "\%(\%(^\|[^.]\)\.\s*\)\@<!\<\%(ARGF\|ARGV\|ENV\|DATA\|STDERR\|STDIN\|STDOUT\|TOPLEVEL_BINDING\)\>\%(\s*(\)\@!"
-syn match rubyPredefinedConstant "\%(\%(^\|[^.]\)\.\s*\)\@<!\<\%(RUBY_\%(VERSION\|RELEASE_DATE\|PLATFORM\|PATCHLEVEL\|REVISION\|DESCRIPTION\|COPYRIGHT\|ENGINE\)\)\>\%(\s*(\)\@!"
-
-" Deprecated/removed in 1.9
-syn match rubyPredefinedVariable "$="
-syn match rubyPredefinedVariable "$-K\>"		  display
-syn match rubyPredefinedVariable "$\%(deferr\|defout\)\>" display
-syn match rubyPredefinedVariable "$KCODE\>"		  display
-" Deprecated/removed in 2.4
-syn match rubyPredefinedConstant "\%(\%(^\|[^.]\)\.\s*\)\@<!\<\%(FALSE\|NIL\|TRUE\)\>\%(\s*(\)\@!"
-
-syn cluster rubyGlobalVariable contains=rubyGlobalVariable,rubyPredefinedVariable,rubyGlobalVariableError
-
-" Normal Regular Expressions {{{1
-SynFold '/' syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="\%(\%(^\|\<\%(and\|or\|while\|until\|unless\|if\|elsif\|when\|not\|then\|else\)\|[;\~=!|&(,{[<>?:*+-]\)\s*\)\@<=/" end="/[iomxneus]*" skip="\\\\\|\\/" contains=@rubyRegexpSpecial nextgroup=@rubyModifier skipwhite
-SynFold '/' syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="\%(\%(\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*\)\s\+\)\@<=/\%(=\|\_s\)\@!"					   end="/[iomxneus]*" skip="\\\\\|\\/" contains=@rubyRegexpSpecial nextgroup=@rubyModifier skipwhite
-
-" Generalized Regular Expressions {{{1
-SynFold '%' syn region rubyRegexp matchgroup=rubyPercentRegexpDelimiter start="%r\z([~`!@#$%^&*_\-+=|\:;"',.?/]\)" end="\z1[iomxneus]*" skip="\\\\\|\\\z1" contains=@rubyRegexpSpecial nextgroup=@rubyModifier skipwhite
-SynFold '%' syn region rubyRegexp matchgroup=rubyPercentRegexpDelimiter start="%r{"				   end="}[iomxneus]*"	skip="\\\\\|\\}"   contains=@rubyRegexpSpecial
-SynFold '%' syn region rubyRegexp matchgroup=rubyPercentRegexpDelimiter start="%r<"				   end=">[iomxneus]*"	skip="\\\\\|\\>"   contains=@rubyRegexpSpecial,rubyNestedAngleBrackets
-SynFold '%' syn region rubyRegexp matchgroup=rubyPercentRegexpDelimiter start="%r\["				   end="\][iomxneus]*"	skip="\\\\\|\\\]"  contains=@rubyRegexpSpecial
-SynFold '%' syn region rubyRegexp matchgroup=rubyPercentRegexpDelimiter start="%r("				   end=")[iomxneus]*"	skip="\\\\\|\\)"   contains=@rubyRegexpSpecial
-SynFold '%' syn region rubyRegexp matchgroup=rubyPercentRegexpDelimiter start="%r\z(\s\)"			   end="\z1[iomxneus]*" skip="\\\\\|\\\z1" contains=@rubyRegexpSpecial
-
-" Characters {{{1
-syn match rubyCharacter "\%(\w\|[^\x00-\x7F]\|[]})\"'/]\)\@1<!\%(?\%(\\M-\\C-\|\\C-\\M-\|\\M-\\c\|\\c\\M-\|\\c\|\\C-\|\\M-\)\=\%(\\\o\{1,3}\|\\x\x\{1,2}\|\\[[:space:]]\|\\\=[^[:space:]]\)\)"
-syn match rubyCharacter "\%(\w\|[^\x00-\x7F]\|[]})\"'/]\)\@1<!?\\u\%(\x\{4}\|{\x\{1,6}}\)"
-
-" Normal Strings {{{1
-let s:spell_cluster = exists('ruby_spellcheck_strings') ? ',@Spell' : ''
-let s:fold_arg	    = s:foldable('string')		? ' fold'   : ''
-exe 'syn region rubyString matchgroup=rubyStringDelimiter start="\"" end="\"" skip="\\\\\|\\\""  contains=@rubyStringSpecial'		       . s:spell_cluster . s:fold_arg
-exe 'syn region rubyString matchgroup=rubyStringDelimiter start="''" end="''" skip="\\\\\|\\''"  contains=rubyQuoteEscape,rubyBackslashEscape' . s:spell_cluster . s:fold_arg
-unlet s:spell_cluster s:fold_arg
-
-" Shell Command Output {{{1
-SynFold 'string' syn region rubyString matchgroup=rubyStringDelimiter start="`" end="`" skip="\\\\\|\\`" contains=@rubyStringSpecial
-
-" Generalized Single Quoted Strings, Symbols, Array of Strings and Array of Symbols {{{1
-
-" Non-bracket punctuation delimiters {{{2
-let s:names = { '~': 'Tilde', '`': 'BackQuote', '!': 'Bang', '@': 'At', '#': 'Hash', '$': 'Dollar', '%': 'Percent', '^': 'Caret',
-      \		'&': 'Ampersand', '*': 'Asterix', '_': 'Underscore', '-': 'Dash', '+': 'Plus', '=': 'Equals', '|': 'Bar',
-      \		'\': 'Backslash', ':': 'Colon', ';': 'Semicolon', '"': 'DoubleQuote', "'": 'Quote', ',': 'Comma', '.': 'Period',
-      \		'?': 'QuestionMark', '/': 'ForwardSlash' }
-
-for s:delimiter in keys(s:names)
-  let s:group = 'ruby' . s:names[s:delimiter] . 'Escape'
-
-  if s:delimiter =~ '[\"]'
-    let s:delimiter = '\' . s:delimiter
-  endif
-
-  exe 'syn match ' . s:group . ' "\V\\' . s:delimiter . '" contained display'
-  exe 'syn cluster rubySingleCharEscape add=' . s:group
-  exe 'SynFold ''%'' syn region rubyString matchgroup=rubyPercentStringDelimiter start="\V%q' . s:delimiter . '" end="\V' . s:delimiter . '" skip="\V\\\\\|\\' . s:delimiter . '" contains=rubyBackslashEscape,'		 . s:group . ' nextgroup=@rubyModifier skipwhite'
-  exe 'SynFold ''%'' syn region rubyString matchgroup=rubyPercentStringDelimiter start="\V%w' . s:delimiter . '" end="\V' . s:delimiter . '" skip="\V\\\\\|\\' . s:delimiter . '" contains=rubyBackslashEscape,rubySpaceEscape,' . s:group . ' nextgroup=@rubyModifier skipwhite'
-  exe 'SynFold ''%'' syn region rubySymbol matchgroup=rubyPercentSymbolDelimiter start="\V%s' . s:delimiter . '" end="\V' . s:delimiter . '" skip="\V\\\\\|\\' . s:delimiter . '" contains=rubyBackslashEscape,'		 . s:group . ' nextgroup=@rubyModifier skipwhite'
-  exe 'SynFold ''%'' syn region rubySymbol matchgroup=rubyPercentSymbolDelimiter start="\V%i' . s:delimiter . '" end="\V' . s:delimiter . '" skip="\V\\\\\|\\' . s:delimiter . '" contains=rubyBackslashEscape,rubySpaceEscape,' . s:group . ' nextgroup=@rubyModifier skipwhite'
-  exe 'hi def link ' . s:group . ' rubyStringEscape'
-endfor
-
-unlet s:delimiter s:group s:names
-" }}}2
-
-SynFold '%' syn region rubyString matchgroup=rubyPercentStringDelimiter start="%q{"	  end="}"   skip="\\\\\|\\}"   contains=rubyBackslashEscape,rubyCurlyBraceEscape,rubyNestedCurlyBraces
-SynFold '%' syn region rubyString matchgroup=rubyPercentStringDelimiter start="%q<"	  end=">"   skip="\\\\\|\\>"   contains=rubyBackslashEscape,rubyAngleBracketEscape,rubyNestedAngleBrackets
-SynFold '%' syn region rubyString matchgroup=rubyPercentStringDelimiter start="%q\["	  end="\]"  skip="\\\\\|\\\]"  contains=rubyBackslashEscape,rubySquareBracketEscape,rubyNestedSquareBrackets
-SynFold '%' syn region rubyString matchgroup=rubyPercentStringDelimiter start="%q("	  end=")"   skip="\\\\\|\\)"   contains=rubyBackslashEscape,rubyParenthesisEscape,rubyNestedParentheses
-SynFold '%' syn region rubyString matchgroup=rubyPercentStringDelimiter start="%q\z(\s\)" end="\z1" skip="\\\\\|\\\z1" contains=rubyBackslashEscape,rubySpaceEscape
-
-SynFold '%' syn region rubyString matchgroup=rubyPercentStringDelimiter start="%w{"	  end="}"   skip="\\\\\|\\}"   contains=rubyBackslashEscape,rubySpaceEscape,rubyCurlyBraceEscape,rubyNestedCurlyBraces
-SynFold '%' syn region rubyString matchgroup=rubyPercentStringDelimiter start="%w<"	  end=">"   skip="\\\\\|\\>"   contains=rubyBackslashEscape,rubySpaceEscape,rubyAngleBracketEscape,rubyNestedAngleBrackets
-SynFold '%' syn region rubyString matchgroup=rubyPercentStringDelimiter start="%w\["	  end="\]"  skip="\\\\\|\\\]"  contains=rubyBackslashEscape,rubySpaceEscape,rubySquareBracketEscape,rubyNestedSquareBrackets
-SynFold '%' syn region rubyString matchgroup=rubyPercentStringDelimiter start="%w("	  end=")"   skip="\\\\\|\\)"   contains=rubyBackslashEscape,rubySpaceEscape,rubyParenthesisEscape,rubyNestedParentheses
-
-SynFold '%' syn region rubySymbol matchgroup=rubyPercentSymbolDelimiter start="%s{"	  end="}"   skip="\\\\\|\\}"   contains=rubyBackslashEscape,rubyCurlyBraceEscape,rubyNestedCurlyBraces
-SynFold '%' syn region rubySymbol matchgroup=rubyPercentSymbolDelimiter start="%s<"	  end=">"   skip="\\\\\|\\>"   contains=rubyBackslashEscape,rubyAngleBracketEscape,rubyNestedAngleBrackets
-SynFold '%' syn region rubySymbol matchgroup=rubyPercentSymbolDelimiter start="%s\["	  end="\]"  skip="\\\\\|\\\]"  contains=rubyBackslashEscape,rubySquareBracketEscape,rubyNestedSquareBrackets
-SynFold '%' syn region rubySymbol matchgroup=rubyPercentSymbolDelimiter start="%s("	  end=")"   skip="\\\\\|\\)"   contains=rubyBackslashEscape,rubyParenthesisEscape,rubyNestedParentheses
-SynFold '%' syn region rubyString matchgroup=rubyPercentSymbolDelimiter start="%s\z(\s\)" end="\z1" skip="\\\\\|\\\z1" contains=rubyBackslashEscape,rubySpaceEscape
-
-SynFold '%' syn region rubySymbol matchgroup=rubyPercentSymbolDelimiter start="%i{"	  end="}"   skip="\\\\\|\\}"   contains=rubyBackslashEscape,rubySpaceEscape,rubyCurlyBraceEscape,rubyNestedCurlyBraces
-SynFold '%' syn region rubySymbol matchgroup=rubyPercentSymbolDelimiter start="%i<"	  end=">"   skip="\\\\\|\\>"   contains=rubyBackslashEscape,rubySpaceEscape,rubyAngleBracketEscape,rubyNestedAngleBrackets
-SynFold '%' syn region rubySymbol matchgroup=rubyPercentSymbolDelimiter start="%i\["	  end="\]"  skip="\\\\\|\\\]"  contains=rubyBackslashEscape,rubySpaceEscape,rubySquareBracketEscape,rubyNestedSquareBrackets
-SynFold '%' syn region rubySymbol matchgroup=rubyPercentSymbolDelimiter start="%i("	  end=")"   skip="\\\\\|\\)"   contains=rubyBackslashEscape,rubySpaceEscape,rubyParenthesisEscape,rubyNestedParentheses
-
-" Generalized Double Quoted Strings, Array of Strings, Array of Symbols and Shell Command Output {{{1
-SynFold '%' syn region rubyString matchgroup=rubyPercentStringDelimiter start="\%(\%(\w\|[^\x00-\x7F]\|]\)\s*\)\@<!%=" end="="	 skip="\\\\\|\\="   contains=@rubyStringSpecial nextgroup=@rubyModifier skipwhite
-SynFold '%' syn region rubyString matchgroup=rubyPercentStringDelimiter start="%\z([~`!@#$%^&*_\-+|\:;"',.?/]\)"       end="\z1" skip="\\\\\|\\\z1" contains=@rubyStringSpecial nextgroup=@rubyModifier skipwhite
-SynFold '%' syn region rubyString matchgroup=rubyPercentStringDelimiter start="%[QWx]\z([~`!@#$%^&*_\-+=|\:;"',.?/]\)" end="\z1" skip="\\\\\|\\\z1" contains=@rubyStringSpecial nextgroup=@rubyModifier skipwhite
-SynFold '%' syn region rubyString matchgroup=rubyPercentStringDelimiter start="%[QWx]\={"			       end="}"	 skip="\\\\\|\\}"   contains=@rubyStringSpecial,rubyNestedCurlyBraces
-SynFold '%' syn region rubyString matchgroup=rubyPercentStringDelimiter start="%[QWx]\=<"			       end=">"	 skip="\\\\\|\\>"   contains=@rubyStringSpecial,rubyNestedAngleBrackets
-SynFold '%' syn region rubyString matchgroup=rubyPercentStringDelimiter start="%[QWx]\=\["			       end="\]"  skip="\\\\\|\\\]"  contains=@rubyStringSpecial,rubyNestedSquareBrackets
-SynFold '%' syn region rubyString matchgroup=rubyPercentStringDelimiter start="%[QWx]\=("			       end=")"	 skip="\\\\\|\\)"   contains=@rubyStringSpecial,rubyNestedParentheses
-SynFold '%' syn region rubyString matchgroup=rubyPercentStringDelimiter start="%[Qx]\z(\s\)"			       end="\z1" skip="\\\\\|\\\z1" contains=@rubyStringSpecial
-
-SynFold '%' syn region rubySymbol matchgroup=rubyPercentSymbolDelimiter start="%I\z([~`!@#$%^&*_\-+=|\:;"',.?/]\)" end="\z1" skip="\\\\\|\\\z1" contains=@rubyStringSpecial nextgroup=@rubyModifier skipwhite
-SynFold '%' syn region rubySymbol matchgroup=rubyPercentSymbolDelimiter start="%I{"				   end="}"   skip="\\\\\|\\}"	contains=@rubyStringSpecial,rubyNestedCurlyBraces
-SynFold '%' syn region rubySymbol matchgroup=rubyPercentSymbolDelimiter start="%I<"				   end=">"   skip="\\\\\|\\>"	contains=@rubyStringSpecial,rubyNestedAngleBrackets
-SynFold '%' syn region rubySymbol matchgroup=rubyPercentSymbolDelimiter start="%I\["				   end="\]"  skip="\\\\\|\\\]"	contains=@rubyStringSpecial,rubyNestedSquareBrackets
-SynFold '%' syn region rubySymbol matchgroup=rubyPercentSymbolDelimiter start="%I("				   end=")"   skip="\\\\\|\\)"	contains=@rubyStringSpecial,rubyNestedParentheses
-
-" Here Documents {{{1
-syn region rubyHeredocStart matchgroup=rubyHeredocDelimiter start=+\%(\%(class\|::\|\.\@1<!\.\)\_s*\|\%([]})"'`]\)\s\|\w\)\@<!<<[-~]\=\zs\%(\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*\)+ end=+$+ oneline contains=ALLBUT,@rubyNotTop
-
-syn region rubyHeredocStart matchgroup=rubyHeredocDelimiter start=+\%(\%(class\|::\|\.\@1<!\.\)\_s*\|\%([]})"'`]\)\s\|\w\)\@<!<<[-~]\=\zs"\%([^"]*\)"+					   end=+$+ oneline contains=ALLBUT,@rubyNotTop
-syn region rubyHeredocStart matchgroup=rubyHeredocDelimiter start=+\%(\%(class\|::\|\.\@1<!\.\)\_s*\|\%([]})"'`]\)\s\|\w\)\@<!<<[-~]\=\zs'\%([^']*\)'+					   end=+$+ oneline contains=ALLBUT,@rubyNotTop
-syn region rubyHeredocStart matchgroup=rubyHeredocDelimiter start=+\%(\%(class\|::\|\.\@1<!\.\)\_s*\|\%([]})"'`]\)\s\|\w\)\@<!<<[-~]\=\zs`\%([^`]*\)`+					   end=+$+ oneline contains=ALLBUT,@rubyNotTop
-
-SynFold '<<' syn region rubyString start=+\%(\%(class\|::\|\.\@1<!\.\)\_s*\|\%([]})"'`]\)\s\|\w\)\@<!<<\z(\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*\)\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+2  matchgroup=rubyHeredocDelimiter end=+^\z1$+	contains=rubyHeredocStart,@rubyStringSpecial keepend
-SynFold '<<' syn region rubyString start=+\%(\%(class\|::\|\.\@1<!\.\)\_s*\|\%([]})"'`]\)\s\|\w\)\@<!<<"\z([^"]*\)"\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+2				      matchgroup=rubyHeredocDelimiter end=+^\z1$+	contains=rubyHeredocStart,@rubyStringSpecial keepend
-SynFold '<<' syn region rubyString start=+\%(\%(class\|::\|\.\@1<!\.\)\_s*\|\%([]})"'`]\)\s\|\w\)\@<!<<'\z([^']*\)'\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+2				      matchgroup=rubyHeredocDelimiter end=+^\z1$+	contains=rubyHeredocStart		     keepend
-SynFold '<<' syn region rubyString start=+\%(\%(class\|::\|\.\@1<!\.\)\_s*\|\%([]})"'`]\)\s\|\w\)\@<!<<`\z([^`]*\)`\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+2				      matchgroup=rubyHeredocDelimiter end=+^\z1$+	contains=rubyHeredocStart,@rubyStringSpecial keepend
-
-SynFold '<<' syn region rubyString start=+\%(\%(class\|::\|\.\@1<!\.\)\_s*\|\%([]})]\)\s\|\w\)\@<!<<[-~]\z(\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*\)\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+3 matchgroup=rubyHeredocDelimiter end=+^\s*\zs\z1$+ contains=rubyHeredocStart,@rubyStringSpecial keepend
-SynFold '<<' syn region rubyString start=+\%(\%(class\|::\|\.\@1<!\.\)\_s*\|\%([]})]\)\s\|\w\)\@<!<<[-~]"\z([^"]*\)"\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+3				      matchgroup=rubyHeredocDelimiter end=+^\s*\zs\z1$+ contains=rubyHeredocStart,@rubyStringSpecial keepend
-SynFold '<<' syn region rubyString start=+\%(\%(class\|::\|\.\@1<!\.\)\_s*\|\%([]})]\)\s\|\w\)\@<!<<[-~]'\z([^']*\)'\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+3				      matchgroup=rubyHeredocDelimiter end=+^\s*\zs\z1$+ contains=rubyHeredocStart		     keepend
-SynFold '<<' syn region rubyString start=+\%(\%(class\|::\|\.\@1<!\.\)\_s*\|\%([]})]\)\s\|\w\)\@<!<<[-~]`\z([^`]*\)`\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+3				      matchgroup=rubyHeredocDelimiter end=+^\s*\zs\z1$+ contains=rubyHeredocStart,@rubyStringSpecial keepend
-
-" Module, Class, Method and Alias Declarations {{{1
-syn match rubyAliasDeclaration	"[^[:space:];#.()]\+" contained contains=rubySymbol,@rubyGlobalVariable nextgroup=rubyAliasDeclaration2 skipwhite
-syn match rubyAliasDeclaration2 "[^[:space:];#.()]\+" contained contains=rubySymbol,@rubyGlobalVariable
-syn match rubyMethodDeclaration "[^[:space:];#(]\+"   contained contains=rubyConstant,rubyBoolean,rubyPseudoVariable,rubyInstanceVariable,rubyClassVariable,rubyGlobalVariable
-syn match rubyClassDeclaration	"[^[:space:];#<]\+"   contained contains=rubyClassName,rubyScopeOperator nextgroup=rubySuperClassOperator skipwhite skipnl
-syn match rubyModuleDeclaration "[^[:space:];#<]\+"   contained contains=rubyModuleName,rubyScopeOperator
-
-syn match rubyMethodName "\<\%([_[:alpha:]]\|[^\x00-\x7F]\)\%([_[:alnum:]]\|[^\x00-\x7F]\)*[?!=]\=\%([[:alnum:]_.:?!=]\|[^\x00-\x7F]\)\@!"			      contained containedin=rubyMethodDeclaration
-syn match rubyMethodName "\%(\s\|^\)\@1<=\%([_[:alpha:]]\|[^\x00-\x7F]\)\%([_[:alnum:]]\|[^\x00-\x7F]\)*[?!=]\=\%(\s\|$\)\@="					      contained containedin=rubyAliasDeclaration,rubyAliasDeclaration2
-syn match rubyMethodName "\%([[:space:].]\|^\)\@1<=\%(\[\]=\=\|\*\*\|[-+!~]@\=\|[*/%|&^~]\|<<\|>>\|[<>]=\=\|<=>\|===\|[=!]=\|[=!]\~\|!\|`\)\%([[:space:];#(]\|$\)\@=" contained containedin=rubyAliasDeclaration,rubyAliasDeclaration2,rubyMethodDeclaration
-
-syn cluster rubyDeclaration contains=rubyAliasDeclaration,rubyAliasDeclaration2,rubyMethodDeclaration,rubyModuleDeclaration,rubyClassDeclaration,rubyMethodName
-
-" Keywords {{{1
-" TODO: reorganise
-syn match rubyControl	     "\%#=1\<\%(break\|in\|next\|redo\|retry\|return\)\>"
-syn match rubyKeyword	     "\%#=1\<\%(super\|yield\)\>"
-syn match rubyBoolean	     "\%#=1\<\%(true\|false\)\>[?!]\@!"
-syn match rubyPseudoVariable "\%#=1\<\(self\|nil\)\>[?!]\@!"
-syn match rubyPseudoVariable "\%#=1\<__\%(ENCODING\|dir\|FILE\|LINE\|callee\|method\)__\>"
-syn match rubyBeginEnd	     "\%#=1\<\%(BEGIN\|END\)\>"
-
-" Expensive Mode {{{1
-" Match 'end' with the appropriate opening keyword for syntax based folding
-" and special highlighting of module/class/method definitions
-if !exists("b:ruby_no_expensive") && !exists("ruby_no_expensive")
-  syn match rubyDefine "\<alias\>"  nextgroup=rubyAliasDeclaration			  skipwhite skipnl
-  syn match rubyDefine "\<def\>"    nextgroup=rubyMethodDeclaration			  skipwhite skipnl
-  syn match rubyDefine "\<undef\>"  nextgroup=rubyMethodName				  skipwhite skipnl
-  syn match rubyClass  "\<class\>"  nextgroup=rubyClassDeclaration,rubyEigenClassOperator skipwhite skipnl
-  syn match rubyModule "\<module\>" nextgroup=rubyModuleDeclaration			  skipwhite skipnl
-
-  SynFold 'def'    syn region rubyMethodBlock start="\<def\>"	 matchgroup=rubyDefine skip="\<end:\|\%(\<def\_s\+\)\@<=end\>" end="\<end\>" contains=ALLBUT,@rubyNotTop
-  SynFold 'class'  syn region rubyClassBlock  start="\<class\>"  matchgroup=rubyClass  skip="\<end:"			       end="\<end\>" contains=ALLBUT,@rubyNotTop
-  SynFold 'module' syn region rubyModuleBlock start="\<module\>" matchgroup=rubyModule skip="\<end:"			       end="\<end\>" contains=ALLBUT,@rubyNotTop
-
-  " modifiers
-  syn match rubyLineContinuation    "\\$" nextgroup=@rubyModifier skipwhite skipnl
-  syn match rubyConditionalModifier "\<\%(if\|unless\)\>"
-  syn match rubyRepeatModifier	    "\<\%(while\|until\)\>"
-  syn match rubyRescueModifier	    "\<rescue\>"
-
-  syn cluster rubyModifier contains=rubyConditionalModifier,rubyRepeatModifier,rubyRescueModifier
-
-  SynFold 'do' syn region rubyDoBlock matchgroup=rubyControl start="\<do\>" skip="\<end:" end="\<end\>" contains=ALLBUT,@rubyNotTop
-
-  " curly bracket block or hash literal
-  SynFold '{' syn region rubyCurlyBlock   matchgroup=rubyCurlyBlockDelimiter start="{"						    end="}" contains=ALLBUT,@rubyNotTop
-  SynFold '[' syn region rubyArrayLiteral matchgroup=rubyArrayDelimiter      start="\%(\%(\w\|[^\x00-\x7F]\)[?!]\=\|[]})]\)\@2<!\[" end="]" contains=ALLBUT,@rubyNotTop
-
-  " statements without 'do'
-  SynFold 'begin' syn region rubyBlockExpression matchgroup=rubyControl     start="\<begin\>" skip="\<end:" end="\<end\>" contains=ALLBUT,@rubyNotTop
-  SynFold 'case'  syn region rubyCaseExpression  matchgroup=rubyConditional start="\<case\>"  skip="\<end:" end="\<end\>" contains=ALLBUT,@rubyNotTop
-
-  SynFold 'if' syn region rubyConditionalExpression matchgroup=rubyConditional start="\%(\%(^\|\.\.\.\=\|[{:,;([<>~\*/%&^|+=-]\|\<then\s\|\%(\<\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*\)\@<![?!]\)\s*\)\@<=\%(if\|unless\)\>" skip="\<end:" end="\<end\>" contains=ALLBUT,@rubyNotTop
-
-  syn match rubyConditional "\<\%(then\|else\|when\)\>"	 contained containedin=rubyCaseExpression
-  syn match rubyConditional "\<\%(then\|else\|elsif\)\>" contained containedin=rubyConditionalExpression
-
-  syn match   rubyExceptionHandler  "\<\%(\%(\%(;\|^\)\s*\)\@<=rescue\|else\|ensure\)\>" contained containedin=rubyBlockExpression,rubyDoBlock
-  syn match   rubyExceptionHandler2 "\<\%(\%(\%(;\|^\)\s*\)\@<=rescue\|else\|ensure\)\>" contained containedin=rubyModuleBlock,rubyClassBlock,rubyMethodBlock
-  syn cluster rubyExceptionHandler  contains=rubyExceptionHandler,rubyExceptionHandler2
-
-  " statements with optional 'do'
-  syn region rubyOptionalDoLine matchgroup=rubyRepeat start="\<for\>" start="\%(\%(^\|\.\.\.\=\|[{:,;([<>~\*/%&^|+=-]\|\%(\<\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*\)\@<![!?]\)\s*\)\@<=\<\%(until\|while\)\>" matchgroup=rubyOptionalDo end="\<do\>" end="\ze\%(;\|$\)" oneline contains=ALLBUT,@rubyNotTop
-
-  SynFold 'for' syn region rubyRepeatExpression start="\<for\>" start="\%(\%(^\|\.\.\.\=\|[{:,;([<>~\*/%&^|+=-]\|\%(\<\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*\)\@<![!?]\)\s*\)\@<=\<\%(until\|while\)\>" matchgroup=rubyRepeat skip="\<end:" end="\<end\>" contains=ALLBUT,@rubyNotTop nextgroup=rubyOptionalDoLine
-
-  if !exists("ruby_minlines")
-    let ruby_minlines = 500
-  endif
-  exe "syn sync minlines=" . ruby_minlines
-
-else
-  syn match rubyControl "\<def\>"    nextgroup=rubyMethodDeclaration skipwhite skipnl
-  syn match rubyControl "\<class\>"  nextgroup=rubyClassDeclaration  skipwhite skipnl
-  syn match rubyControl "\<module\>" nextgroup=rubyModuleDeclaration skipwhite skipnl
-  syn match rubyControl "\<\%(case\|begin\|do\|for\|if\|unless\|while\|until\|else\|elsif\|rescue\|ensure\|then\|when\|end\)\>"
-  syn match rubyKeyword "\<\%(alias\|undef\)\>"
-endif
-
-" Special Methods {{{1
-if !exists("ruby_no_special_methods")
-  syn match rubyAccess	  "\<\%(public\|protected\|private\)\>" " use re=2
-  syn match rubyAccess	  "\%#=1\<\%(public\|private\)_class_method\>"
-  syn match rubyAccess	  "\%#=1\<\%(public\|private\)_constant\>"
-  syn match rubyAccess	  "\%#=1\<module_function\>"
-  syn match rubyAttribute "\%#=1\%(\%(^\|;\)\s*\)\@<=attr\>\(\s*[.=]\)\@!" " attr is a common variable name
-  syn match rubyAttribute "\%#=1\<attr_\%(accessor\|reader\|writer\)\>"
-  syn match rubyControl   "\%#=1\<\%(abort\|at_exit\|exit\|fork\|loop\|trap\)\>"
-  syn match rubyEval	  "\%#=1\<eval\>"
-  syn match rubyEval	  "\%#=1\<\%(class\|instance\|module\)_eval\>"
-  syn match rubyException "\%#=1\<\%(raise\|fail\|catch\|throw\)\>"
-  syn match rubyInclude   "\%#=1\<\%(autoload\|gem\|load\|require\%(_relative\)\=\)\>"
-  syn match rubyKeyword   "\%#=1\<\%(callcc\|caller\|lambda\|proc\)\>"
-  syn match rubyMacro	  "\%#=1\<\%(extend\|include\|prepend\|refine\|using\)\>"
-  syn match rubyMacro	  "\%#=1\<\%(alias\|define\|define_singleton\|remove\|undef\)_method\>"
-endif
-
-" Comments and Documentation {{{1
-syn match   rubySharpBang    "\%^#!.*" display
-syn keyword rubyTodo	     FIXME NOTE TODO OPTIMIZE HACK REVIEW XXX todo contained
-syn match   rubyEncoding     "[[:alnum:]-]\+" contained display
-syn match   rubyMagicComment "\c\%<3l#\s*\zs\%(coding\|encoding\):"					contained nextgroup=rubyEncoding skipwhite
-syn match   rubyMagicComment "\c\%<10l#\s*\zs\%(frozen_string_literal\|warn_indent\|warn_past_scope\):" contained nextgroup=rubyBoolean  skipwhite
-syn match   rubyComment	     "#.*" contains=@rubyCommentSpecial,rubySpaceError,@Spell
-
-syn cluster rubyCommentSpecial contains=rubySharpBang,rubyTodo,rubyMagicComment
-syn cluster rubyCommentNotTop  contains=@rubyCommentSpecial,rubyEncoding
-
-if !exists("ruby_no_comment_fold") && s:foldable('#')
-  syn region rubyMultilineComment start="^\s*#.*\n\%(^\s*#\)\@=" end="^\s*#.*\n\%(^\s*#\)\@!" contains=rubyComment transparent fold keepend
-  syn region rubyDocumentation	  start="^=begin\ze\%(\s.*\)\=$" end="^=end\%(\s.*\)\=$"      contains=rubySpaceError,rubyTodo,@Spell fold
-else
-  syn region rubyDocumentation	  start="^=begin\s*$"		 end="^=end\s*$"              contains=rubySpaceError,rubyTodo,@Spell
-endif
-
-" {{{1 Useless Line Continuations
-syn match rubyUselessLineContinuation "\%([.:,;{([<>~\*%&^|+=-]\|%(\%(\w\|[^\x00-\x7F]\)\@1<![?!]\)\s*\zs\\$" nextgroup=rubyUselessLineContinuation skipwhite skipempty
-syn match rubyUselessLineContinuation "\\$"								      nextgroup=rubyUselessLineContinuation skipwhite skipempty contained
-
-" Keyword Nobbling {{{1
-" prevent methods with keyword names being highlighted as keywords when called
-syn match rubyKeywordAsMethod "\%(\%(\.\@1<!\.\)\|&\.\|::\)\_s*\%([_[:lower:]][_[:alnum:]]*\|\%(BEGIN\|END\)\>\)" transparent contains=rubyDotOperator,rubyScopeOperator
-
-" Bang and Predicate Methods and Operators {{{1
-syn match rubyBangPredicateMethod "\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*[?!]"
-
-if !exists("ruby_no_special_methods")
-  syn match rubyControl "\%#=1\<exit!" display
-endif
-syn match rubyDefinedOperator "\%#=1\<defined?" display
-
-" 1.9-style Hash Keys and Keyword Parameters {{{1
-syn match rubySymbol "\%(\w\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*[?!]\=::\@!"he=e-1 contained containedin=rubyBlockParameterList,rubyCurlyBlock
-syn match rubySymbol "[]})\"':]\@1<!\<\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*[!?]\=:[[:space:],;]\@="he=e-1
-syn match rubySymbol "[[:space:],{(]\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*[!?]\=:[[:space:],;]\@="hs=s+1,he=e-1
-
-" __END__ Directive {{{1
-SynFold '__END__' syn region rubyData matchgroup=rubyDataDirective start="^__END__$" end="\%$"
-
-" Default Highlighting {{{1
-hi def link rubyClass			rubyDefine
-hi def link rubyModule			rubyDefine
-hi def link rubyExceptionHandler2	rubyDefine
-hi def link rubyDefine			Define
-hi def link rubyAccess			rubyMacro
-hi def link rubyAttribute		rubyMacro
-hi def link rubyMacro			Macro
-hi def link rubyMethodName		rubyFunction
-hi def link rubyFunction		Function
-hi def link rubyConditional		Conditional
-hi def link rubyConditionalModifier	rubyConditional
-hi def link rubyExceptionHandler	rubyConditional
-hi def link rubyRescueModifier		rubyExceptionHandler
-hi def link rubyRepeat			Repeat
-hi def link rubyRepeatModifier		rubyRepeat
-hi def link rubyOptionalDo		rubyRepeat
-hi def link rubyControl			Statement
-hi def link rubyInclude			Include
-hi def link rubyInteger			Number
-hi def link rubyCharacter		Character
-hi def link rubyFloat			Float
-hi def link rubyBoolean			Boolean
-hi def link rubyException		Exception
-if !exists("ruby_no_identifiers")
-  hi def link rubyIdentifier		Identifier
-else
-  hi def link rubyIdentifier		NONE
-endif
-hi def link rubyClassVariable		rubyIdentifier
-hi def link rubyConstant		Type
-hi def link rubyClassName		rubyConstant
-hi def link rubyModuleName		rubyConstant
-hi def link rubyGlobalVariable		rubyIdentifier
-hi def link rubyInstanceVariable	rubyIdentifier
-hi def link rubyPredefinedIdentifier	rubyIdentifier
-hi def link rubyPredefinedConstant	rubyPredefinedIdentifier
-hi def link rubyPredefinedVariable	rubyPredefinedIdentifier
-hi def link rubySymbol			Constant
-hi def link rubyKeyword			Keyword
-
-hi def link rubyOperator		Operator
-hi def link rubyDefinedOperator		rubyOperator
-hi def link rubyEnglishBooleanOperator	rubyOperator
-if exists("ruby_operators")
-  hi def link rubyTernaryOperator	rubyOperator
-  hi def link rubyArithmeticOperator	rubyOperator
-  hi def link rubyComparisonOperator	rubyOperator
-  hi def link rubyBitwiseOperator	rubyOperator
-  hi def link rubyBooleanOperator	rubyOperator
-  hi def link rubyRangeOperator		rubyOperator
-  hi def link rubyAssignmentOperator	rubyOperator
-  hi def link rubyEqualityOperator	rubyOperator
-endif
-
-if exists("ruby_pseudo_operators")
-  hi def link rubyPseudoOperator	Special
-  hi def link rubyDotOperator		rubyPseudoOperator
-  hi def link rubyScopeOperator		rubyPseudoOperator
-  hi def link rubySuperClassOperator	rubyPseudoOperator
-  hi def link rubyEigenClassOperator	rubyPseudoOperator
-  hi def link rubyLambdaOperator	rubyPseudoOperator
-  hi def link rubyDoubleSplatOperator	rubyPseudoOperator
-  hi def link rubySplatOperator		rubyPseudoOperator
-  hi def link rubyProcOperator		rubyPseudoOperator
-endif
-
-hi def link rubyBeginEnd		Statement
-hi def link rubyEval			Statement
-hi def link rubyPseudoVariable		Constant
-hi def link rubyCapitalizedMethod	NONE
-
-hi def link rubyComment			Comment
-hi def link rubyEncoding		Constant
-hi def link rubyMagicComment		SpecialComment
-hi def link rubyData			Comment
-hi def link rubyDataDirective		Delimiter
-hi def link rubyDocumentation		Comment
-hi def link rubyTodo			Todo
-
-hi def link rubyBackslashEscape		rubyStringEscape
-hi def link rubyQuoteEscape		rubyStringEscape
-hi def link rubySpaceEscape		rubyStringEscape
-hi def link rubyParenthesisEscape	rubyStringEscape
-hi def link rubyCurlyBraceEscape	rubyStringEscape
-hi def link rubyAngleBracketEscape	rubyStringEscape
-hi def link rubySquareBracketEscape	rubyStringEscape
-hi def link rubyStringEscape		Special
-
-hi def link rubyInterpolationDelimiter	Delimiter
-hi def link rubySharpBang		PreProc
-hi def link rubyStringDelimiter		Delimiter
-hi def link rubyHeredocDelimiter	rubyStringDelimiter
-hi def link rubyPercentRegexpDelimiter	rubyRegexpDelimiter
-hi def link rubyPercentStringDelimiter	rubyStringDelimiter
-hi def link rubyPercentSymbolDelimiter	rubySymbolDelimiter
-hi def link rubyRegexpDelimiter		rubyStringDelimiter
-hi def link rubySymbolDelimiter		rubySymbol
-hi def link rubyString			String
-hi def link rubyRegexpEscape		rubyRegexpSpecial
-hi def link rubyRegexpQuantifier	rubyRegexpSpecial
-hi def link rubyRegexpAnchor		rubyRegexpSpecial
-hi def link rubyRegexpDot		rubyRegexpCharClass
-hi def link rubyRegexpCharClass		rubyRegexpSpecial
-hi def link rubyRegexpIntersection	rubyRegexpSpecial
-hi def link rubyRegexpSpecial		Special
-hi def link rubyRegexpComment		Comment
-hi def link rubyRegexp			rubyString
-
-hi def link rubyError			Error
-if exists("ruby_line_continuation_error")
-  hi def link rubyUselessLineContinuation rubyError
-endif
-hi def link rubyGlobalVariableError	rubyError
-hi def link rubySpaceError		rubyError
-
-" Postscript {{{1
-let b:current_syntax = "ruby"
-
-let &cpo = s:cpo_sav
-unlet! s:cpo_sav
-
-delc SynFold
-
-" vim: nowrap sw=2 sts=2 ts=8 noet fdm=marker:
diff --git a/sources_non_forked/vim-snipmate/.gitignore b/sources_non_forked/vim-snipmate/.gitignore
deleted file mode 100644
index 9140e6a..0000000
--- a/sources_non_forked/vim-snipmate/.gitignore
+++ /dev/null
@@ -1,3 +0,0 @@
-doc/tags
-*.swp
-.DS_Store
diff --git a/sources_non_forked/vim-snipmate/Contributors.md b/sources_non_forked/vim-snipmate/Contributors.md
deleted file mode 100644
index 4206472..0000000
--- a/sources_non_forked/vim-snipmate/Contributors.md
+++ /dev/null
@@ -1,52 +0,0 @@
-# Contributors #
-
-SnipMate was originally authored by Michael Sanders
-([Vim](http://www.vim.org/account/profile.php?user_id=16544),
-[GitHub](https://github.com/msanders)).
-
-It is currently maintained by [Rok Garbas](rok@garbas.si), [Marc
-Weber](marco-oweber@gmx.de), and [Adnan Zafar](https://github.com/ajzafar) with
-additional contributions from:
-
-* [907th](https://github.com/907th)
-* [adkron](https://github.com/adkron)
-* [alderz](https://github.com/alderz)
-* [asymmetric](https://github.com/asymmetric)
-* [bpugh](https://github.com/bpugh)
-* [bruno-](https://github.com/bruno-)
-* [CharlesGueunet](https://github.com/CharlesGueunet)
-* [darkwise](https://github.com/darkwise)
-* [dreviejo](https://github.com/dreviejo)
-* [fish-face](https://github.com/fish-face)
-* [henrik](https://github.com/henrik)
-* [holizz](https://github.com/holizz)
-* [honza](https://github.com/honza)
-* [hpesoj](https://github.com/hpesoj)
-* [ironcamel](https://github.com/ironcamel)
-* [jb55](https://github.com/jb55)
-* [jbernard](https://github.com/jbernard)
-* [jherdman](https://github.com/jherdman)
-* [kozo2](https://github.com/kozo2)
-* [lilydjwg](https://github.com/lilydjwg)
-* [lpil](https://github.com/lpil)
-* [marutanm](https://github.com/marutanm)
-* [MicahElliott](https://github.com/MicahElliott)
-* [mikeastock](https://github.com/mikeastock)
-* [muffinresearch](https://github.com/muffinresearch)
-* [munyari](https://github.com/munyari)
-* [pielgrzym](https://github.com/pielgrzym)
-* [pose](https://github.com/pose)
-* [r00k](https://github.com/r00k)
-* [radicalbit](https://github.com/radicalbit)
-* [redpill](https://github.com/redpill)
-* [rglassett](http://github.com/rglassett)
-* [robhudson](https://github.com/robhudson)
-* [shinymayhem](https://github.com/shinymayhem)
-* [Shraymonks](https://github.com/shraymonks)
-* [sickill](https://github.com/sickill)
-* [statik](https://github.com/statik)
-* [steveno](https://github.com/steveno)
-* [taq](https://github.com/taq)
-* [thisgeek](https://github.com/thisgeek)
-* [trusktr](https://github.com/trusktr)
-* [Xandaros](https://github.com/Xandaros)
diff --git a/sources_non_forked/vim-snipmate/README.md b/sources_non_forked/vim-snipmate/README.md
deleted file mode 100644
index 2072d7c..0000000
--- a/sources_non_forked/vim-snipmate/README.md
+++ /dev/null
@@ -1,187 +0,0 @@
-# SnipMate #
-
-SnipMate aims to provide support for textual snippets, similar to TextMate or
-other Vim plugins like [UltiSnips][ultisnips]. For
-example, in C, typing `for<tab>` could be expanded to
-
-    for (i = 0; i < count; i++) {
-        /* code */
-    }
-
-with successive presses of tab jumping around the snippet.
-
-Originally authored by [Michael Sanders][msanders], SnipMate was forked in 2011
-after a stagnation in development. This fork is currently maintained by [Rok
-Garbas][garbas], [Marc Weber][marcweber], and [Adnan Zafar][ajzafar].
-
-
-## Installing SnipMate ##
-
-We recommend one of the following methods for installing SnipMate and its
-dependencies. SnipMate depends on [vim-addon-mw-utils][mw-utils] and
-[tlib][tlib].
-
-> **NOTE:** SnipMate does not ship with any snippets out of the box. We suggest
-looking at the [vim-snippets][vim-snippets] repository.
-
-* Using [VAM][vam], add `vim-snippets` to the list of packages to be installed.
-
-* Using [Pathogen][pathogen], run the following commands:
-
-        % cd ~/.vim/bundle
-        % git clone https://github.com/tomtom/tlib_vim.git
-        % git clone https://github.com/MarcWeber/vim-addon-mw-utils.git
-        % git clone https://github.com/garbas/vim-snipmate.git
-
-        # Optional:
-        % git clone https://github.com/honza/vim-snippets.git
-
-* Using [Vundle][vundle], add the following to your `vimrc` then run
-  `:PluginInstall`
-
-        Plugin 'MarcWeber/vim-addon-mw-utils'
-        Plugin 'tomtom/tlib_vim'
-        Plugin 'garbas/vim-snipmate'
-
-        " Optional:
-        Plugin 'honza/vim-snippets'
-
-## Using SnipMate ##
-Press <tab> and try :SnipMateOpenSnippetFiles for starting.
-Also see doc/SnipMate.txt to learn all SnipMate
-
-## FAQ ##
-
-> SnipMate doesn't work / My snippets aren't triggering
-
-Try all of the following:
-
-* Check that SnipMate is loaded. This can be done by looking for
-  `<Plug>snipMateTrigger` and similar maps in the output of `:imap`.
-  Additionally make sure either `<Plug>snipMateTrigger` or
-  `<Plug>snipMateNextOrTrigger` is mapped to the key you expect.
-
-* Check that the snippets file you mean to use exists, and that it contains the
-  snippet you're trying to expand.
-
-* Check that your snippets file is located inside a `foo/snippets` directory,
-  where `foo` is a path listed in your `runtimepath`.
-
-* Check that your snippets file is in scope by either the filetype matching the
-  path of the snippet file or the scope explicitly loaded.
-
-* Check if any snippets from your snippets file are available. This can be done
-  with the "show available snips" map, by default bound to `<C-R><Tab>` in
-  insert mode.
-
-If all of the above check out, please open an issue stating your Vim version,
-a sample snippet, and a description of exactly what happens when you try to
-trigger a snippet.
-
-> How does SnipMate determine which snippets to load? How can I separate, for
-> example, my Rails snippets from my Ruby snippets?
-
-Primarily SnipMate looks at the `'filetype'` and `'syntax'` settings. Taking
-"scopes" from these options, it looks in each `snippets/` directory in
-`'runtimepath'` for files named `scope.snippets`, `scope/*.snippets`, or
-`scope_*.snippets`.
-
-However we understand this may not allow for the flexibility desired by some
-languages. For this we provide two options: scope aliases and the
-`:SnipMateLoadScope` command. Scope aliases simply say "whenever this scope is
-loaded, also load this other scope:
-
-    let g:snipMate = get(g:, 'snipMate', {}) " Allow for vimrc re-sourcing
-    let g:snipMate.scope_aliases = {}
-    let g:snipMate.scope_aliases['ruby'] = 'ruby,rails'
-
-will load the `ruby-rails` scope whenever the `ruby` scope is active. The
-`:SnipMateLoadScope foo` command will always load the foo scope in the current
-buffer. The [vim-rails](https://github.com/tpope/vim-rails) plugin automatically
-does `:SnipMateLoadScope rails` when editing a Rails project for example.
-
-> What are the snippet parser versions and what's the difference between them?
-
-Originally SnipMate used regex to parse a snippet. Determining where stops were,
-what the placeholders were, where mirrors were, etc. were all done with regex.
-Needless to say this was a little fragile. When the time came for a rewritten
-parser, some incompatibilities were a little necessary. Rather than break
-everyone's snippets everywhere, we provided both the new (version 1) and the old
-(version 0) and let the user choose between them.
-
-Version 0 is considered legacy and not a lot of effort is going to go into
-improving or even maintaining it. Version 1 is the future, and one can expect
-new features to only exist for version 1 users. A full list of differences can
-be found in the docs at `:h SnipMate-parser-versions`.
-
-## Release Notes ##
-
-### 0.89 - 2016-05-29 ###
-
-* Various regex updates to legacy parser
-* Addition of double bang syntax to completely remove a snippet from lookup
-* Group various SnipMate autocommands
-* Support setting 'shiftwidth' to 0
-* Parser now operates linewise, adding some flexibility
-* Mirror substitutions are more literal
-* Mirror length is calculated correctly when substitutions occur
-
-### 0.88 - 2015-04-04 ###
-
-* Implement simple caching
-* Remove expansion guards
-* Add `:SnipMateLoadScope` command and buffer-local scope aliases
-* Load `<scope>_*.snippets` files
-* Use CursorMoved autocmd events entirely
-
-* The nested branch has been merged
-    * A new snippet parser has been added. The g:snipmate.version as well as
-      version lines in snippet files determines which is used
-    * The new parser supports tab stops placed within placeholders,
-      substitutions, non-consecutive stop numbers, and fewer ambiguities
-    * The stop jumping code has been updated
-    * Tests have been added for the jumping code and the new parser
-
-* The override branch has been merged
-    * The g:snipMate.override option is added. When enabled, if two snippets
-      share the same name, the later-loaded one is kept and the other discarded
-    * Override behavior can be enabled on a per-snippet basis with a bang (!) in
-      the snippet file
-    * Otherwise, SnipMate tries to preserve all snippets loaded
-
-* Fix bug with mirrors in the first column
-* Fix bug with tabs in indents ([#143][143])
-* Fix bug with mirrors in placeholders
-* Fix reading single snippet files
-* Fix the use of the visual map at the end of a line
-* Fix expansion of stops containing only the zero tab stop
-* Remove select mode mappings
-* Indent visual placeholder expansions and remove extraneous lines ([#177][177]
-  and [#178][178])
-
-### 0.87 - 2014-01-04 ###
-
-* Stop indenting empty lines when expanding snippets
-* Support extends keyword in .snippets files
-* Fix visual placeholder support
-* Add zero tabstop support
-* Support negative 'softtabstop'
-* Add g:snipMate_no_default_aliases option
-* Add <Plug>snipMateTrigger for triggering an expansion inside a snippet
-* Add snipMate#CanBeTriggered() function
-
-[ultisnips]: https://github.com/sirver/ultisnips
-[msanders]: https://github.com/msanders
-[garbas]: https://github.com/garbas
-[marcweber]: https://github.com/marcweber
-[ajzafar]: https://github.com/ajzafar
-[mw-utils]: https://github.com/marcweber/vim-addon-mw-utils
-[tlib]: https://github.com/tomtom/tlib_vim
-[vim-snippets]: https://github.com/honza/vim-snippets
-[vam]: https://github.com/marcweber/vim-addon-manager
-[pathogen]: https://github.com/tpope/vim-pathogen
-[vundle]: https://github.com/gmarik/vundle
-
-[143]: https://github.com/garbas/vim-snipmate/issues/143
-[177]: https://github.com/garbas/vim-snipmate/issues/177
-[178]: https://github.com/garbas/vim-snipmate/issues/178
diff --git a/sources_non_forked/vim-snipmate/addon-info.json b/sources_non_forked/vim-snipmate/addon-info.json
deleted file mode 100644
index 8d9930f..0000000
--- a/sources_non_forked/vim-snipmate/addon-info.json
+++ /dev/null
@@ -1,12 +0,0 @@
-{
-  "name" : "snipMate",
-  "version" : "dev",
-  "author" : "Michael Sanders -> original project http://github.com/msanders/snipmate.vim",
-  "maintainer" : "Rok Garbas / Marc Weber",
-  "repository" : {"type": "git", "url": "git://github.com/garbas/vim-snipmate.git"},
-  "dependencies" : {
-    "vim-addon-mw-utils": {},
-    "tlib": {}
-  },
-  "description" : "snipMate.vim aims to be a concise vim script that implements some of TextMate's snippets features in Vim. See README.md to learn about the features this fork adds"
-}
diff --git a/sources_non_forked/vim-snipmate/after/plugin/snipMate.vim b/sources_non_forked/vim-snipmate/after/plugin/snipMate.vim
deleted file mode 100644
index 3d6bac7..0000000
--- a/sources_non_forked/vim-snipmate/after/plugin/snipMate.vim
+++ /dev/null
@@ -1,46 +0,0 @@
-" snipMate maps
-" These maps are created here in order to make sure we can reliably create maps
-" after SuperTab.
-
-let s:save_cpo = &cpo
-set cpo&vim
-
-function! s:map_if_not_mapped(lhs, rhs, mode) abort
-    let l:unique = s:overwrite ? '' : ' <unique>'
-    if !hasmapto(a:rhs, a:mode)
-	silent! exe a:mode . 'map' . l:unique a:lhs a:rhs
-    endif
-endfunction
-
-if !exists('g:snips_no_mappings') || !g:snips_no_mappings
-	if exists('g:snips_trigger_key')
-		echom 'g:snips_trigger_key is deprecated. See :h snipMate-mappings'
-		exec 'imap <unique>' g:snips_trigger_key '<Plug>snipMateTrigger'
-		exec 'smap <unique>' g:snips_trigger_key '<Plug>snipMateSNext'
-		exec 'xmap <unique>' g:snips_trigger_key '<Plug>snipMateVisual'
-	else
-		" Remove SuperTab map if it exists
-		let s:overwrite = maparg('<Tab>', 'i') ==? '<Plug>SuperTabForward'
-		call s:map_if_not_mapped('<Tab>', '<Plug>snipMateNextOrTrigger', 'i')
-		call s:map_if_not_mapped('<Tab>', '<Plug>snipMateNextOrTrigger', 's')
-		let s:overwrite = 0
-		call s:map_if_not_mapped('<Tab>', '<Plug>snipMateVisual', 'x')
-	endif
-
-	if exists('g:snips_trigger_key_backwards')
-		echom 'g:snips_trigger_key_backwards is deprecated. See :h snipMate-mappings'
-		exec 'imap <unique>' g:snips_trigger_key_backwards '<Plug>snipMateIBack'
-		exec 'smap <unique>' g:snips_trigger_key_backwards '<Plug>snipMateSBack'
-	else
-		let s:overwrite = maparg('<S-Tab>', 'i') ==? '<Plug>SuperTabBackward'
-		call s:map_if_not_mapped('<S-Tab>', '<Plug>snipMateBack', 'i')
-		call s:map_if_not_mapped('<S-Tab>', '<Plug>snipMateBack', 's')
-		let s:overwrite = 0
-	endif
-
-	call s:map_if_not_mapped('<C-R><Tab>', '<Plug>snipMateShow', 'i')
-endif
-
-let &cpo = s:save_cpo
-
-" vim:noet:
diff --git a/sources_non_forked/vim-snipmate/autoload/snipMate.vim b/sources_non_forked/vim-snipmate/autoload/snipMate.vim
deleted file mode 100644
index 4952879..0000000
--- a/sources_non_forked/vim-snipmate/autoload/snipMate.vim
+++ /dev/null
@@ -1,648 +0,0 @@
-" config which can be overridden (shared lines)
-if !exists('g:snipMate')
-  let g:snipMate = {}
-endif
-
-try
-	call tlib#input#List('mi', '', [])
-catch /.*/
-	echoe "tlib is missing. See install instructions at ".expand('<sfile>:h:h').'/README.md'
-endtry
-
-fun! Filename(...) abort
-	let filename = expand('%:t:r')
-	if filename == '' | return a:0 == 2 ? a:2 : '' | endif
-	return !a:0 || a:1 == '' ? filename : substitute(a:1, '$1', filename, 'g')
-endf
-
-let s:cache = {}
-
-function! snipMate#expandSnip(snip, version, col) abort
-	let lnum = line('.')
-	let col = a:col
-	let line = getline(lnum)
-	let indent = match(line, '\S\|$') + 1
-	let b:snip_state = snipmate#jumping#state()
-
-	if a:version == 1
-		let [snippet, b:snip_state.stops] = snipmate#parse#snippet(a:snip)
-		" Build stop/mirror info
-		let b:snip_state.stop_count = s:build_stops(snippet, b:snip_state.stops, lnum, col, indent)
-	else
-		let snippet = snipmate#legacy#process_snippet(a:snip)
-		let [b:snip_state.stops, b:snip_state.stop_count] = snipmate#legacy#build_stops(snippet, lnum, col - indent, indent)
-	endif
-
-	" Abort if the snippet is empty
-	if empty(snippet)
-		return ''
-	endif
-
-	let col = s:insert_snippet_text(snippet, lnum, col, indent)
-
-	" Open any folds snippet expands into
-	if &foldenable
-		silent! exec lnum . ',' . (lnum + len(snipLines) - 1) . 'foldopen'
-	endif
-
-	aug snipmate_changes
-		au CursorMoved,CursorMovedI <buffer> if exists('b:snip_state') |
-					\     call b:snip_state.update_changes() |
-					\ else |
-					\     silent! au! snipmate_changes * <buffer> |
-					\ endif
-	aug END
-
-	let b:snip_state.stop_no = 0
-	return b:snip_state.set_stop(0)
-endfunction
-
-function! s:insert_snippet_text(snippet, lnum, col, indent)
-	let line = getline(a:lnum)
-	let col = a:col
-	let snippet = type(a:snippet) == type([]) ? a:snippet : split(a:snippet, "\n", 1)
-	let lnum = a:lnum
-
-	" Keep text after the cursor
-	let afterCursor = strpart(line, col - 1)
-	if afterCursor != "\t" && afterCursor != ' '
-		let line = strpart(line, 0, col - 1)
-	else
-		let afterCursor = ''
-		" For some reason the cursor needs to move one right after this
-		if line != '' && col == 1 && &ve != 'all' && &ve != 'onemore'
-			let col += 1
-		endif
-	endif
-
-	call setline(lnum, '')
-	call append(lnum, repeat([''], len(snippet) - 1))
-
-	for item in snippet
-		let add = lnum == a:lnum ? line : strpart(line, 0, a:indent - 1)
-
-		if !(empty(item) || (type(item) == type([]) && empty(item[0])))
-			if type(item) == type([])
-				call setline(lnum, add .
-							\ snipMate#sniplist_str(item, b:snip_state.stops))
-			else
-				call setline(lnum, add .
-							\ substitute(item, printf('%s\d\+\|%s{\d\+.\{-}}',
-							\ g:snipmate#legacy#sigil, g:snipmate#legacy#sigil),
-							\ '', 'g'))
-			endif
-		endif
-
-		let lnum += 1
-	endfor
-
-	call setline(lnum - 1, getline(lnum - 1) . afterCursor)
-
-	return col
-endfunction
-
-function! snipMate#placeholder_str(num, stops) abort
-	return snipMate#sniplist_str(a:stops[a:num].placeholder, a:stops)
-endfunction
-
-function! snipMate#sniplist_str(snippet, stops) abort
-	let str = ''
-	let pos = 0
-	let add_to = 1
-	let seen_stops = []
-
-	while pos < len(a:snippet)
-		let item = a:snippet[pos]
-
-		if type(item) == type('')
-			let str .= item
-		elseif type(item) == type([])
-			let placeholder = snipMate#placeholder_str(item[0], a:stops)
-			if len(item) > 1 && type(item[1]) == type({})
-				let placeholder = substitute(placeholder,
-							\ get(item[1], 'pat', ''),
-							\ get(item[1], 'sub', ''),
-							\ get(item[1], 'flags', ''))
-			endif
-			let str .= placeholder
-		endif
-
-		let pos += 1
-		unlet item " avoid E706
-	endwhile
-
-	return str
-endfunction
-
-function! s:build_stops(snippet, stops, lnum, col, indent) abort
-	let stops = a:stops
-	let lnum  = a:lnum
-	let col   = a:col
-
-	for line in a:snippet
-		let col = s:build_loc_info(line, stops, lnum, col, [])
-		if line isnot a:snippet[-1]
-			let lnum += 1
-			let col = a:indent
-		endif
-	endfor
-
-	" add zero tabstop if it doesn't exist and then link it to the highest stop
-	" number
-	let stops[0] = get(stops, 0,
-				\ { 'placeholder' : [], 'line' : lnum, 'col' : col })
-	let stop_count = max(keys(stops)) + 2
-	let stops[stop_count - 1] = stops[0]
-
-	return stop_count
-endfunction
-
-function! s:build_loc_info(snippet, stops, lnum, col, seen_items) abort
-	let stops   = a:stops
-	let lnum    = a:lnum
-	let col     = a:col
-	let pos     = 0
-	let in_text = 0
-	let seen_items = a:seen_items
-
-	for item in a:snippet
-		if type(item) == type('')
-			let col += len(item)
-		elseif type(item) == type([])
-			let id = item[0]
-			let stub = item[-1]
-			let stub.line = lnum
-			let stub.col = col
-			call s:add_update_objects(stub, seen_items)
-
-			if len(item) > 2 && type(item[1]) != type({})
-				let col = s:build_loc_info(item[1:-2], stops, lnum, col, seen_items)
-			else
-				let col += len(snipMate#placeholder_str(id, stops))
-			endif
-
-			let in_text = 0
-		endif
-		unlet item " avoid E706
-	endfor
-
-	return col
-endfunction
-
-function! s:add_update_objects(object, targets) abort
-	let targets = a:targets
-
-	for item in targets
-		let item.update_objects = get(item, 'update_objects', [])
-		call add(item.update_objects, a:object)
-	endfor
-
-	call add(targets, a:object)
-endfunction
-
-" reads a .snippets file
-" returns list of
-" ['triggername', 'name', 'contents']
-" if triggername is not set 'default' is assumed
-" TODO: better error checking
-fun! snipMate#ReadSnippetsFile(file) abort
-	let result = []
-	let new_scopes = []
-	if !filereadable(a:file) | return [result, new_scopes] | endif
-	let inSnip = 0
-	let line_no = 0
-	let snipversion = get(g:snipMate, 'snippet_version', 0)
-	for line in readfile(a:file) + ["\n"]
-		let line_no += 1
-
-		if inSnip && (line[0] == "\t" || line == '')
-			let content .= strpart(line, 1)."\n"
-			continue
-		elseif inSnip
-			call add(result, [trigger, name,
-						\     content[:-2], bang, snipversion])
-			let inSnip = 0
-		endif
-
-		if line[:6] == 'snippet'
-			let inSnip = 1
-			let bang = (line[7] == '!')
-			if bang
-				let bang += line[8] == '!'
-			endif
-			let trigger = strpart(line, 8 + bang)
-			let name = ''
-			let space = stridx(trigger, ' ') + 1
-			if space " Process multi snip
-				let name = strpart(trigger, space)
-				let trigger = strpart(trigger, 0, space - 1)
-			endif
-			let content = ''
-			if trigger =~ '^\s*$' " discard snippets with empty triggers
-				echom 'Invalid snippet in' a:file 'near line' line_no
-				let inSnip = 0
-			endif
-		elseif line[:6] == 'extends'
-			call extend(new_scopes, map(split(strpart(line, 8)),
-						\ "substitute(v:val, ',*$', '', '')"))
-		elseif line[:6] == 'version'
-			let snipversion = +strpart(line, 8)
-		endif
-	endfor
-	return [result, new_scopes]
-endf
-
-function! s:GetScopes() abort
-	let ret = exists('b:snipMate.scope_aliases') ? copy(b:snipMate.scope_aliases) : {}
-	let global = get(g:snipMate, 'scope_aliases', {})
-	for alias in keys(global)
-		if has_key(ret, alias)
-			let ret[alias] = join(split(ret[alias], ',')
-						\ + split(global[alias], ','), ',')
-		else
-			let ret[alias] = global[alias]
-		endif
-	endfor
-	return ret
-endfunction
-
-" adds scope aliases to list.
-" returns new list
-" the aliases of aliases are added recursively
-fun! s:AddScopeAliases(list) abort
-  let did = {}
-  let scope_aliases = s:GetScopes()
-  let new = a:list
-  let new2 =  []
-  while !empty(new)
-	for i in new
-	  if !has_key(did, i)
-		let did[i] = 1
-		call extend(new2, split(get(scope_aliases,i,''),','))
-	  endif
-	endfor
-	let new = new2
-	let new2 = []
-  endwhile
-  return keys(did)
-endf
-
-augroup SnipMateSource
-	au SourceCmd *.snippet,*.snippets call s:source_snippet()
-augroup END
-
-function! s:info_from_filename(file) abort
-	let parts = split(fnamemodify(a:file, ':r'), '/')
-	let snipidx = len(parts) - index(reverse(copy(parts)), 'snippets') - 1
-	let rtp_prefix = join(parts[(snipidx -
-				\ (parts[snipidx - 1] == 'after' ? 3 : 2)):snipidx - 1], '/')
-	let trigger = get(parts, snipidx + 2, '')
-	let desc = get(parts, snipidx + 3, get(g:snipMate, 'override', 0) ?
-				\ '' : fnamemodify(a:file, ':t'))
-	return [rtp_prefix, trigger, desc]
-endfunction
-
-function! s:source_snippet() abort
-	let file = expand('<afile>:p')
-	let [rtp_prefix, trigger, desc] = s:info_from_filename(file)
-	let new_snips = []
-	if fnamemodify(file, ':e') == 'snippet'
-		call add(new_snips, [trigger, desc, join(readfile(file), "\n"), 0,
-					\ get(g:snipMate, 'snippet_version', 0)])
-	else
-		let [snippets, extends] = s:CachedSnips(file)
-		let new_snips = deepcopy(snippets)
-		call extend(s:lookup_state.extends, extends)
-	endif
-	for snip in new_snips
-		if get(g:snipMate, 'override', 0)
-			let snip[1] = join([s:lookup_state.scope, snip[1]])
-		else
-			let snip[1] = join([s:lookup_state.scope, rtp_prefix,
-						\ empty(snip[1]) ? desc : snip[1]])
-		endif
-	endfor
-	call extend(s:lookup_state.snips, new_snips)
-endfunction
-
-function! s:CachedSnips(file) abort
-	let mtime = getftime(a:file)
-	if has_key(s:cache, a:file) && s:cache[a:file].mtime >= mtime
-		return s:cache[a:file].contents
-	endif
-	let s:cache[a:file] = {}
-	let s:cache[a:file].mtime = mtime
-	let s:cache[a:file].contents = snipMate#ReadSnippetsFile(a:file)
-	return s:cache[a:file].contents
-endfunction
-
-function! s:snippet_filenames(scope, trigger) abort
-	let mid = ['', '_*', '/*']
-	let mid += map(copy(mid), "'/' . a:trigger . '*' . v:val")
-	call map(mid, "'snippets/' . a:scope . v:val . '.snippet'")
-	return map(mid[:2], 'v:val . "s"') + mid[3:]
-endfunction
-
-function! snipMate#SetByPath(dict, trigger, path, snippet, bang, snipversion) abort
-	let d = a:dict
-	if a:bang == 2
-		unlet! d[a:trigger]
-		return
-	elseif !has_key(d, a:trigger) || a:bang == 1
-		let d[a:trigger] = {}
-	endif
-	let d[a:trigger][a:path] = [a:snippet, a:snipversion]
-endfunction
-
-if v:version < 704 || has('win32')
-	function! s:Glob(path, expr)
-		let res = []
-		for p in split(a:path, ',')
-			let h = split(fnamemodify(a:expr, ':h'), '/')[0]
-			if isdirectory(p . '/' . h)
-				call extend(res, split(glob(p . '/' . a:expr), "\n"))
-			endif
-		endfor
-		return filter(res, 'filereadable(v:val)')
-	endfunction
-else
-	function! s:Glob(path, expr)
-		return split(globpath(a:path, a:expr), "\n")
-	endfunction
-endif
-
-" default triggers based on paths
-function! snipMate#DefaultPool(scopes, trigger, result) abort
-	let scopes = s:AddScopeAliases(a:scopes)
-	let scopes_done = []
-	let s:lookup_state = {}
-	let s:lookup_state.snips = []
-
-	while !empty(scopes)
-		let scope = remove(scopes, 0)
-		let s:lookup_state.scope = scope
-		let s:lookup_state.extends = []
-
-		for expr in s:snippet_filenames(scope, escape(a:trigger, "*[]?{}`'$|#%"))
-			for path in s:snippet_dirs()
-				for file in s:Glob(path, expr)
-					source `=file`
-				endfor
-			endfor
-		endfor
-
-		call add(scopes_done, scope)
-		call extend(scopes, s:lookup_state.extends)
-		call filter(scopes, 'index(scopes_done, v:val) == -1')
-	endwhile
-
-	for [trigger, desc, contents, bang, snipversion] in s:lookup_state.snips
-		if trigger =~ '\V\^' . escape(a:trigger, '\')
-			call snipMate#SetByPath(a:result, trigger, desc, contents, bang, snipversion)
-		endif
-	endfor
-endfunction
-
-" return a dict of snippets found in runtimepath matching trigger
-" scopes: list of scopes. usually this is the filetype. eg ['c','cpp']
-" trigger may contain glob patterns. Thus use '*' to get all triggers
-"
-fun! snipMate#GetSnippets(scopes, trigger) abort
-	let result = {}
-
-	for F in values(g:snipMateSources)
-	  call funcref#Call(F, [a:scopes, a:trigger, result])
-	endfor
-	return result
-endf
-
-function! s:snippet_dirs() abort
-	return get(g:snipMate, 'snippet_dirs', split(&rtp, ','))
-endfunction
-
-function! snipMate#OpenSnippetFiles() abort
-	let files = []
-	let scopes_done = []
-	let exists = []
-	let notexists = []
-	for scope in s:AddScopeAliases(snipMate#ScopesByFile())
-		let files += s:snippet_filenames(scope, '')
-	endfor
-	call filter(files, "v:val !~# '\\*'")
-	for path in s:snippet_dirs()
-		let fullpaths = map(copy(files), 'printf("%s/%s", path, v:val)')
-		let exists += filter(copy(fullpaths), 'filereadable(v:val)')
-		let notexists += map(filter(copy(fullpaths),
-					\ 'v:val =~# "\.snippets" && !filereadable(v:val)'),
-					\       '"does not exist: " . v:val')
-	endfor
-	let all = exists + notexists
-	let select = tlib#input#List('mi', 'select files to be opened in splits', all)
-	for idx in select
-		exec 'sp' all[idx - 1]
-	endfor
-endfunction
-
-fun! snipMate#ScopesByFile() abort
-	" duplicates are removed in AddScopeAliases
-	return filter(funcref#Call(g:snipMate.get_scopes), "v:val != ''")
-endf
-
-" used by both: completion and insert snippet
-fun! snipMate#GetSnippetsForWordBelowCursor(word, exact) abort
-	" Split non-word characters into their own piece
-	" so 'foo.bar..baz' becomes ['foo', '.', 'bar', '.', '.', 'baz']
-	" First split just after a \W and then split each resultant string just
-	" before a \W
-	let parts = filter(tlib#list#Flatten(
-				\ map(split(a:word, '\W\zs'), 'split(v:val, "\\ze\\W")')),
-				\ '!empty(v:val)')
-	" Only look at the last few possibilities. Too many can be slow.
-	if len(parts) > 5
-		let parts = parts[-5:]
-	endif
-	let lookups = [a:word]
-	let lookup = ''
-	for w in reverse(parts)
-		let lookup = w . lookup
-		if index(lookups, lookup) == -1
-			call add(lookups, lookup)
-		endif
-	endfor
-
-	" Remove empty lookup entries, but only if there are other nonempty lookups
-	if len(lookups) > 1
-		call filter(lookups, 'v:val != ""')
-	endif
-
-	let matching_snippets = []
-	let snippet = ''
-	" prefer longest word
-	for word in lookups
-		let g:snipMate.word = word
-		for [k,snippetD] in items(funcref#Call(g:snipMate['get_snippets'], [snipMate#ScopesByFile(), word]))
-			" hack: require exact match
-			if a:exact && k !=# word
-				continue
-			endif
-			call add(matching_snippets, [k, snippetD])
-			if a:exact
-				break
-			endif
-		endfor
-	endfor
-	return matching_snippets
-endf
-
-" snippets: dict containing snippets by name
-" usually this is just {'default' : snippet_contents }
-fun! s:ChooseSnippet(snippets) abort
-	let snippet = []
-	let keys = keys(a:snippets)
-	let i = 1
-	for snip in keys
-		let snippet += [i.'. '.snip]
-		let i += 1
-	endfor
-	if len(snippet) == 1 || get(g:snipMate, 'always_choose_first', 0) == 1
-		" there's only a single snippet, choose it
-		let idx = 0
-	else
-		let idx = tlib#input#List('si','select snippet by name',snippet) -1
-		if idx == -1
-			return ''
-		endif
-	endif
-	" if a:snippets[..] is a String Call returns it
-	" If it's a function or a function string the result is returned
-	return funcref#Call(a:snippets[keys(a:snippets)[idx]])
-endf
-
-fun! snipMate#WordBelowCursor() abort
-	return matchstr(getline('.'), '\S\+\%' . col('.') . 'c')
-endf
-
-fun! snipMate#GetSnippetsForWordBelowCursorForComplete(word) abort
-	let matches = snipMate#GetSnippetsForWordBelowCursor(a:word, 0)
-	let snippets = []
-	for [trigger, dict] in matches
-		if get(g:snipMate, 'description_in_completion', 0)
-			call extend(snippets, map(keys(dict),
-						\ '{ "word" : trigger, "menu" : v:val, "dup" : 1 }'))
-		else
-			call add(snippets, { "word" : trigger })
-		endif
-	endfor
-	return filter(snippets,
-				\ 'v:val.word =~# "\\V\\^' . escape(a:word, '"\') . '"')
-endf
-
-fun! snipMate#CanBeTriggered() abort
-	let word    = snipMate#WordBelowCursor()
-	let matches = snipMate#GetSnippetsForWordBelowCursorForComplete(word)
-	return len(matches) > 0
-endf
-
-fun! snipMate#ShowAvailableSnips() abort
-	let col     = col('.')
-	let word    = snipMate#WordBelowCursor()
-	let matches = snipMate#GetSnippetsForWordBelowCursorForComplete(word)
-
-	" Pretty hacky, but really can't have the tab swallowed!
-	if len(matches) == 0
-		call feedkeys(g:snipMate['no_match_completion_feedkeys_chars'], 'n')
-		return ""
-	endif
-
-	call complete(col - len(word), sort(matches))
-	return ''
-endf
-
-" Pass an argument to force snippet expansion instead of triggering or jumping
-function! snipMate#TriggerSnippet(...) abort
-	if exists('g:SuperTabMappingForward')
-		if g:SuperTabMappingForward == "<tab>"
-			let SuperTabPlug = maparg('<Plug>SuperTabForward', 'i')
-			if SuperTabPlug == ""
-				let SuperTabKey = "\<c-n>"
-			else
-				exec "let SuperTabKey = \"" . escape(SuperTabPlug, '<') . "\""
-			endif
-		elseif g:SuperTabMappingBackward == "<tab>"
-			let SuperTabPlug = maparg('<Plug>SuperTabBackward', 'i')
-			if SuperTabPlug == ""
-				let SuperTabKey = "\<c-p>"
-			else
-				exec "let SuperTabKey = \"" . escape(SuperTabPlug, '<') . "\""
-			endif
-		endif
-	endif
-
-	if pumvisible() " Update snippet if completion is used, or deal with supertab
-		if exists('SuperTabKey')
-			call feedkeys(SuperTabKey) | return ''
-		endif
-		call feedkeys("\<esc>a", 'n') " Close completion menu
-		call feedkeys("\<tab>") | return ''
-	endif
-
-	if exists('b:snip_state') && a:0 == 0 " Jump only if no arguments
-		let jump = b:snip_state.jump_stop(0)
-		if type(jump) == 1 " returned a string
-			return jump
-		endif
-	endif
-
-	let word = matchstr(getline('.'), '\S\+\%'.col('.').'c')
-	let list = snipMate#GetSnippetsForWordBelowCursor(word, 1)
-	if empty(list)
-		let snippet = ''
-	else
-		let [trigger, snippetD] = list[0]
-		let snippet = s:ChooseSnippet(snippetD)
-		" Before expanding snippet, create new undo point |i_CTRL-G|
-		let &undolevels = &undolevels
-		let col = col('.') - len(trigger)
-		sil exe 's/\V'.escape(trigger, '/\.').'\%#//'
-		return snipMate#expandSnip(snippet[0], snippet[1], col)
-	endif
-
-	" should allow other plugins to register hooks instead (duplicate code)
-	if exists('SuperTabKey')
-		call feedkeys(SuperTabKey)
-		return ''
-	endif
-	return word == ''
-	  \ ? "\<tab>"
-	  \ : "\<c-r>=snipMate#ShowAvailableSnips()\<cr>"
-endfunction
-
-fun! snipMate#BackwardsSnippet() abort
-	if exists('b:snip_state') | return b:snip_state.jump_stop(1) | endif
-
-	if exists('g:SuperTabMappingForward')
-		if g:SuperTabMappingForward == "<s-tab>"
-			let SuperTabPlug = maparg('<Plug>SuperTabForward', 'i')
-			if SuperTabPlug == ""
-				let SuperTabKey = "\<c-n>"
-			else
-				exec "let SuperTabKey = \"" . escape(SuperTabPlug, '<') . "\""
-			endif
-		elseif g:SuperTabMappingBackward == "<s-tab>"
-			let SuperTabPlug = maparg('<Plug>SuperTabBackward', 'i')
-			if SuperTabPlug == ""
-				let SuperTabKey = "\<c-p>"
-			else
-				exec "let SuperTabKey = \"" . escape(SuperTabPlug, '<') . "\""
-			endif
-		endif
-	endif
-	" should allow other plugins to register hooks instead (duplicate code)
-	if exists('SuperTabKey')
-		call feedkeys(SuperTabKey)
-		return ''
-	endif
-	return "\<s-tab>"
-endf
-
-" vim:noet:sw=4:ts=4:ft=vim
diff --git a/sources_non_forked/vim-snipmate/autoload/snipMate_python_demo.vim b/sources_non_forked/vim-snipmate/autoload/snipMate_python_demo.vim
deleted file mode 100644
index de495d2..0000000
--- a/sources_non_forked/vim-snipmate/autoload/snipMate_python_demo.vim
+++ /dev/null
@@ -1,47 +0,0 @@
-" This file demonstrates
-" - how to register your own snippet sources (call snipMate_python_demo#Activate() in ftplugin/python.vim)
-" - implents a source which creates snippets based on python function
-"   definitions found in the current file
-"
-" Example:
-"
-" def abc(a,b,c=None)
-" will create a snippet on the fly which looks like this:
-" abc(${1:a}, ${2:b}, ${3:c=None})
-
-fun! snipMate_python_demo#Activate() abort
-  if !exists('g:snipMateSources')
-    let g:snipMateSources = {}
-  endif
-
-  let g:snipMateSources['python'] = funcref#Function('snipMate_python_demo#FunctionsFromCurrentFileAndTags')
-endf
-
-fun! s:Add(dict, line, source, trigger) abort
-  let matched = matchlist(a:line,'def\s\+\([^( \t]\+\)[ \t]*(\([^)]*\)')
-  if len(matched) > 2
-    let name = matched[1]
-    " TODO: is this a glob?
-    if name !~ a:trigger | return  | endif
-    let a:dict[name] = get(a:dict, name, {})
-    let sd = a:dict[name]
-    let args = []
-    let nr=1
-    for arg in split(matched[2], '\s*,\s*')
-      call add(args, '${'.nr.':'.arg.'}')
-      let nr+=1
-    endfor
-    let sd[a:source] = name.'('.join(args,', ').')'
-  endif
-endf
-fun! snipMate_python_demo#FunctionsFromCurrentFileAndTags(scopes, trigger, result) abort
-  " getting all might be too much
-  if a:trigger == '*' | return | endif
-  if index(a:scopes, 'python') < 0 | return | endif
-  for t in taglist('^'.a:trigger)
-    call s:Add(a:result, t.cmd, 'tags-' . t.filename, a:trigger)
-  endfor
-  for l in getline(0, line('$'))
-    call s:Add(a:result, l, 'current-file', a:trigger)
-  endfor
-endf
diff --git a/sources_non_forked/vim-snipmate/autoload/snipmate/jumping.vim b/sources_non_forked/vim-snipmate/autoload/snipmate/jumping.vim
deleted file mode 100644
index aaf65ab..0000000
--- a/sources_non_forked/vim-snipmate/autoload/snipmate/jumping.vim
+++ /dev/null
@@ -1,228 +0,0 @@
-function! s:sfile() abort
-	return expand('<sfile>')
-endfunction
-
-let s:state_proto = {}
-
-function! snipmate#jumping#state() abort
-	return copy(s:state_proto)
-endfunction
-
-function! s:listize_mirror(mirrors) abort
-	return map(copy(a:mirrors), '[v:val.line, v:val.col]')
-endfunction
-
-" Removes snippet state info
-function! s:state_remove() dict abort
-	" Remove all autocmds in group snipmate_changes in the current buffer
-	unlet! b:snip_state
-	silent! au! snipmate_changes * <buffer>
-endfunction
-
-function! s:state_find_next_stop(backwards) dict abort
-	let self.stop_no += a:backwards? -1 : 1
-	while !has_key(self.stops, self.stop_no)
-		if self.stop_no == self.stop_count
-			let self.stop_no = 0
-		endif
-		if self.stop_no <= 0 && a:backwards
-			let self.stop_no = self.stop_count - 1
-		endif
-		let self.stop_no += a:backwards? -1 : 1
-	endwhile
-endfunction
-
-" Update state information to correspond to the given tab stop
-function! s:state_set_stop(backwards) dict abort
-	call self.find_next_stop(a:backwards)
-	let self.cur_stop    = self.stops[self.stop_no]
-	let self.stop_len = (type(self.cur_stop.placeholder) == type(0))
-				\ ? self.cur_stop.placeholder
-				\ : len(snipMate#placeholder_str(self.stop_no, self.stops))
-	let self.start_col   = self.cur_stop.col
-	let self.end_col     = self.start_col + self.stop_len
-	let self.mirrors     = get(self.cur_stop, 'mirrors', [])
-	let self.old_mirrors = deepcopy(self.mirrors)
-	call cursor(self.cur_stop.line, self.cur_stop.col)
-	let self.prev_len    = col('$')
-	let self.changed = 0
-	let ret = self.select_word()
-	if (self.stop_no == 0 || self.stop_no == self.stop_count - 1) && !a:backwards
-		call self.remove()
-	endif
-	return ret
-endfunction
-
-" Jump to the next/previous tab stop
-function! s:state_jump_stop(backwards) dict abort
-	" Update changes just in case
-	" This seems to be only needed because insert completion does not trigger
-	" the CursorMovedI event
-	call self.update_changes()
-
-	" Store placeholder/location changes
-	let self.cur_stop.col = self.start_col
-	if self.changed
-		call self.remove_nested()
-		unlet! self.cur_stop.placeholder " avoid type error for old parsing version
-		let self.cur_stop.placeholder = [strpart(getline('.'),
-					\ self.start_col - 1, self.end_col - self.start_col)]
-	endif
-
-	return self.set_stop(a:backwards)
-endfunction
-
-function! s:state_remove_nested(...) dict abort
-	let id = a:0 ? a:1 : self.stop_no
-	if type(self.stops[id].placeholder) == type([])
-		for i in self.stops[id].placeholder
-			if type(i) == type([])
-				if type(i[1]) != type({})
-					call self.remove_nested(i[0])
-					call remove(self.stops, i[0])
-				else
-					call filter(self.stops[i[0]].mirrors, 'v:val isnot i[1]')
-				endif
-			endif
-			unlet i " Avoid E706
-		endfor
-	endif
-endfunction
-
-" Select the placeholder for the current tab stop
-function! s:state_select_word() dict abort
-	let len = self.stop_len
-	if !len | return '' | endif
-	let l = col('.') != 1 ? 'l' : ''
-	if &sel == 'exclusive'
-		return "\<esc>".l.'v'.len."l\<c-g>"
-	endif
-	return len == 1 ? "\<esc>".l.'gh' : "\<esc>".l.'v'.(len - 1)."l\<c-g>"
-endfunction
-
-" Update the snippet as text is typed. The self.update_mirrors() function does
-" the actual work.
-" If the cursor moves outside of a placeholder, call self.remove()
-function! s:state_update_changes() dict abort
-	let change_len = col('$') - self.prev_len
-	let self.changed = self.changed || change_len != 0
-	let self.end_col += change_len
-	let col = col('.')
-
-	if line('.') != self.cur_stop.line || col < self.start_col || col > self.end_col
-		return self.remove()
-	endif
-
-	call self.update(self.cur_stop, change_len, change_len)
-	if !empty(self.mirrors)
-		call self.update_mirrors(change_len)
-	endif
-
-	let self.prev_len = col('$')
-endfunction
-
-" Actually update the mirrors for any changed text
-function! s:state_update_mirrors(change) dict abort
-	let newWordLen = self.end_col - self.start_col
-	let newWord = strpart(getline('.'), self.start_col - 1, newWordLen)
-	let changeLen = a:change
-	let curLine = line('.')
-	let curCol = col('.')
-	let oldStartSnip = self.start_col
-	let i = 0
-
-	for mirror in self.mirrors
-		for stop in values(filter(copy(self.stops), 'v:key != 0'))
-			if type(stop.placeholder) == type(0)
-				if mirror.line == stop.line && mirror.col > stop.col
-							\ && mirror.col < stop.col + stop.placeholder
-					let stop.placeholder += changeLen
-				endif
-			endif
-		endfor
-
-		if has_key(mirror, 'oldSize')
-			" recover the old size deduce the endline
-			let oldSize = mirror.oldSize
-		else
-			" first time, we use the intitial size
-			let oldSize = strlen(newWord)
-		endif
-
-		" Split the line into three parts: the mirror, what's before it, and
-		" what's after it. Then combine them using the new mirror string.
-		" Subtract one to go from column index to byte index
-
-		let theline = getline(mirror.line)
-
-		" part before the current mirror
-		let beginline  = strpart(theline, 0, mirror.col - 1)
-
-		" current mirror transformation, and save size
-		let wordMirror= substitute(newWord, get(mirror, 'pat', ''), get(mirror, 'sub', ''), get(mirror, 'flags', ''))
-		let mirror.oldSize = strlen(wordMirror)
-
-		" end of the line, use the oldSize because with the transformation,
-		" the size of the mirror can be different from those of the snippet
-		let endline    = strpart(theline, mirror.col + oldSize -1)
-
-		" Update other object on the line
-		call self.update(mirror, changeLen, mirror.oldSize - oldSize)
-
-		" reconstruct the line
-		let update = beginline.wordMirror.endline
-
-		call setline(mirror.line, update)
-	endfor
-
-	" Reposition the cursor in case a var updates on the same line but before
-	" the current tabstop
-	if oldStartSnip != self.start_col || mode() == 'i'
-		call cursor(0, curCol + self.start_col - oldStartSnip)
-	endif
-endfunction
-
-function! s:state_find_update_objects(item) dict abort
-	let item = a:item
-	let item.update_objects = []
-
-	" Filter the zeroth stop because it's duplicated as the last
-	for stop in values(filter(copy(self.stops), 'v:key != 0'))
-		if stop.line == item.line && stop.col > item.col
-			call add(item.update_objects, stop)
-		endif
-
-		for mirror in get(stop, 'mirrors', [])
-			if mirror.line == item.line && mirror.col > item.col
-				call add(item.update_objects, mirror)
-			endif
-		endfor
-	endfor
-
-	return item.update_objects
-endfunction
-
-function! s:state_update(item, change_len, mirror_change) dict abort
-	let item = a:item
-	if !exists('item.update_objects')
-		let item.update_objects = self.find_update_objects(a:item)
-	endif
-	let to_update = item.update_objects
-
-	for obj in to_update
-		" object does not necessarly have the same decalage
-		" than mirrors if mirrors use regexp
-		let obj.col += a:mirror_change
-		if obj is self.cur_stop
-			let self.start_col += a:change_len
-			let self.end_col += a:change_len
-		endif
-	endfor
-endfunction
-
-call extend(s:state_proto, snipmate#util#add_methods(s:sfile(), 'state',
-			\ [ 'remove', 'set_stop', 'jump_stop', 'remove_nested',
-			\ 'select_word', 'update_changes', 'update_mirrors',
-			\ 'find_next_stop', 'find_update_objects', 'update' ]), 'error')
-
-" vim:noet:sw=4:ts=4:ft=vim
diff --git a/sources_non_forked/vim-snipmate/autoload/snipmate/legacy.vim b/sources_non_forked/vim-snipmate/autoload/snipmate/legacy.vim
deleted file mode 100644
index 7ff39cb..0000000
--- a/sources_non_forked/vim-snipmate/autoload/snipmate/legacy.vim
+++ /dev/null
@@ -1,139 +0,0 @@
-let s:sigil = nr2char(31)
-let snipmate#legacy#sigil = s:sigil
-
-" Prepare snippet to be processed by s:BuildTabStops
-function! snipmate#legacy#process_snippet(snip) abort
-	let snippet = a:snip
-	let esc_bslash = '\%(\\\@<!\%(\\\\\)*\)\@<='
-
-	if exists('b:snipmate_visual')
-		let visual = substitute(b:snipmate_visual, "\n$", '', '')
-		unlet b:snipmate_visual
-	else
-		let visual = ''
-	endif
-        let snippet = s:substitute_visual(snippet, visual)
-
-	" Evaluate eval (`...`) expressions.
-	" Backquotes prefixed with a backslash "\" are ignored.
-	" And backslash can be escaped by doubling it.
-	" Using a loop here instead of a regex fixes a bug with nested "\=".
-	if stridx(snippet, '`') != -1
-		let new = []
-		let snip = split(snippet, esc_bslash . '`', 1)
-		let isexp = 0
-		for i in snip
-			if isexp
-				call add(new, substitute(snipmate#util#eval(i),
-                                            \ "\n\\%$", '', ''))
-			else
-				call add(new, i)
-			endif
-			let isexp = !isexp
-		endfor
-		let snippet = join(new, '')
-		let snippet = substitute(snippet, "\r", "\n", 'g')
-		let snippet = substitute(snippet, '\\`', "`", 'g')
-	endif
-
-	" Place all text after a colon in a tab stop after the tab stop
-	" (e.g. "${#:foo}" becomes "${:foo}foo").
-	" This helps tell the position of the tab stops later.
-	let snippet = substitute(snippet, esc_bslash . '\$\({\d\+:\(.\{-}\)}\|{\d\+}\)', s:sigil . '\1\2', 'g')
-	let snippet = substitute(snippet, esc_bslash . '\$\(\d\+\)', s:sigil . '\1', 'g')
-	let snippet = substitute(snippet, esc_bslash . '\\\$', '$', 'g')
-	let snippet = substitute(snippet, '\\\\', "\\", 'g')
-
-	" Update the a:snip so that all the $# become the text after
-	" the colon in their associated ${#}.
-	" (e.g. "${1:foo}" turns all "$1"'s into "foo")
-	let i = 0
-	if snippet !~ s:sigil . '{0'
-		let snippet .= s:sigil . '{0}'
-	endif
-	while snippet =~ s:sigil.'{'.i
-		let s = matchstr(snippet, s:sigil . '{' . i . ':\zs.\{-}\ze}')
-		if s != ''
-			let snippet = substitute(snippet, s:sigil . i, s.'&', 'g')
-		endif
-		let i += 1
-	endw
-
-	if &et " Expand tabs to spaces if 'expandtab' is set.
-		return substitute(snippet, '\t', repeat(' ', snipmate#util#tabwidth()), 'g')
-	endif
-	return snippet
-endfunction
-
-" Builds a list of a list of each tab stop in the snippet containing:
-" 1.) The tab stop's line number.
-" 2.) The tab stop's column number
-"     (by getting the length of the string between the last "\n" and the
-"     tab stop).
-" 3.) The length of the text after the colon for the current tab stop
-"     (e.g. "${1:foo}" would return 3).
-" 4.) If the "${#:}" construct is given, another list containing all
-"     the matches of "$#", to be replaced with the placeholder. This list is
-"     composed the same way as the parent; the first item is the line number,
-"     and the second is the column.
-function! snipmate#legacy#build_stops(snip, lnum, col, indent) abort
-	let stops = {}
-	let i = 0
-	let withoutVars = substitute(a:snip, s:sigil . '\d\+', '', 'g')
-	while a:snip =~ s:sigil . '{' . i
-		let beforeTabStop = matchstr(withoutVars, '^.*\ze'.s:sigil .'{'.i.'\D')
-		let withoutOthers = substitute(withoutVars, ''.s:sigil .'{\('.i.'\D\)\@!\d\+.\{-}}', '', 'g')
-
-		let stops[i] = {}
-		let stops[i].line = a:lnum + s:count(beforeTabStop, "\n")
-		let stops[i].col = a:indent + len(matchstr(withoutOthers, '[^\n]\{-}\ze'.s:sigil .'{'.i.'\D'))
-		let stops[i].placeholder = 0
-		let stops[i].mirrors = []
-		if stops[i].line == a:lnum
-			let stops[i].col += a:col
-		endif
-
-		" Get all $# matches in another list, if ${#:name} is given
-		if withoutVars =~ printf('%s{%d:', s:sigil, i)
-			let stops[i].placeholder = len(matchstr(withoutVars, ''.s:sigil .'{'.i.':\zs.\{-}\ze}'))
-			let withoutOthers = substitute(a:snip, ''.s:sigil .'{\d\+.\{-}}\|'.s:sigil .''.i.'\@!\d\+', '', 'g')
-
-			while match(withoutOthers, ''.s:sigil .''.i.'\(\D\|$\)') != -1
-				let stops[i].mirrors = get(stops[i], 'mirrors', [])
-				let beforeMark = matchstr(withoutOthers,
-							\ printf('^.\{-}\ze%s%s%d\(\D\|$\)',
-							\ repeat('.', stops[i].placeholder), s:sigil, i))
-				let line = a:lnum + s:count(beforeMark, "\n")
-				let col = a:indent + (line > a:lnum
-				                           \ ? len(matchstr(beforeMark, '.*\n\zs.*'))
-				                           \ : a:col + len(beforeMark))
-				call add(stops[i].mirrors, { 'line' : line, 'col' : col })
-				let withoutOthers = substitute(withoutOthers, ''.s:sigil .''.i.'\ze\(\D\|$\)', '', '')
-			endw
-		endif
-		let i += 1
-	endw
-	let stops[i] = stops[0]
-	return [stops, i + 1]
-endfunction
-
-function! s:substitute_visual(snippet, visual) abort
-    let lines = []
-    for line in split(a:snippet, "\n")
-        let indent = matchstr(line, '^\t\+')
-        call add(lines, substitute(line, '{VISUAL}',
-                    \ substitute(escape(a:visual, '%\'), "\n", "\n" . indent, 'g'), 'g'))
-    endfor
-    return join(lines, "\n")
-endfunction
-
-" Counts occurences of haystack in needle
-function! s:count(haystack, needle) abort
-	let counter = 0
-	let index = stridx(a:haystack, a:needle)
-	while index != -1
-		let index = stridx(a:haystack, a:needle, index+1)
-		let counter += 1
-	endw
-	return counter
-endfunction
diff --git a/sources_non_forked/vim-snipmate/autoload/snipmate/parse.vim b/sources_non_forked/vim-snipmate/autoload/snipmate/parse.vim
deleted file mode 100644
index 4cf60e9..0000000
--- a/sources_non_forked/vim-snipmate/autoload/snipmate/parse.vim
+++ /dev/null
@@ -1,323 +0,0 @@
-" Snippet definition parsing code
-
-function! s:sfile() abort
-    return expand('<sfile>')
-endfunction
-
-let s:parser_proto = {}
-let s:special_chars = "$`\n"
-
-function! s:new_parser(text) abort
-    let ret = copy(s:parser_proto)
-    let ret.input = a:text
-    let ret.len = strlen(ret.input)
-    let ret.pos = -1
-    let ret.indent = 0
-    let ret.value = []
-    let ret.vars = {}
-    let ret.stored_lines = []
-    call ret.advance()
-    return ret
-endfunction
-
-function! s:parser_advance(...) dict abort
-    let self.pos += a:0 ? a:1 : 1
-    let self.next = self.input[self.pos]
-endfunction
-
-function! s:parser_same(tok) dict abort
-    if self.next == a:tok
-        call self.advance()
-        return 1
-    else
-        return 0
-    endif
-endfunction
-
-function! s:parser_id() dict abort
-    if self.input[(self.pos):(self.pos+5)] == 'VISUAL'
-        call self.advance(6)
-        return 'VISUAL'
-    elseif self.next =~ '\d'
-        let end = matchend(self.input, '\d\+', self.pos)
-        let res = strpart(self.input, self.pos, end - self.pos)
-        call self.advance(end - self.pos)
-        return +res " force conversion to Number
-    endif
-    return -1
-endfunction
-
-function! s:parser_add_var(var) dict abort
-    let id = a:var[0]
-    if !has_key(self.vars, id)
-        let self.vars[id] = { 'instances' : [] }
-    endif
-    call add(self.vars[id].instances, a:var)
-endfunction
-
-function! s:parser_var() dict abort
-    let ret = []
-    if self.same('{')
-        let id = self.id()
-        if id >= 0
-            call add(ret, id)
-            call extend(ret, self.varend())
-        endif
-    else
-        let id = self.id()
-        if id >= 0
-            call add(ret, id)
-        endif
-    endif
-    return ret
-endfunction
-
-function! s:parser_varend() dict abort
-    let ret = []
-    if self.same(':')
-        call extend(ret, self.placeholder())
-    elseif self.same('/')
-        call add(ret, self.subst())
-    endif
-    call self.same('}')
-    return ret
-endfunction
-
-function! s:parser_placeholder() dict abort
-    let ret = self.text('}')
-    return empty(ret) ? [''] : ret
-endfunction
-
-function! s:parser_subst() dict abort
-    let ret = {}
-    let ret.pat = self.pat()
-    if self.same('/')
-        let ret.sub = self.pat(1)
-    endif
-    if self.same('/')
-        let ret.flags = self.pat(1)
-    endif
-    return ret
-endfunction
-
-function! s:parser_pat(...) dict abort
-    let val = ''
-
-    while self.pos < self.len
-        if self.same('\')
-            if self.next == '/'
-                let val .= '/'
-                call self.advance()
-            elseif a:0 && self.next == '}'
-                let val .= '}'
-                call self.advance()
-            else
-                let val .= '\'
-            endif
-        elseif self.next == '/' || a:0 && self.next == '}'
-            break
-        else
-            let val .= self.next
-            call self.advance()
-        endif
-    endwhile
-
-    return val
-endfunction
-
-function! s:parser_expr() dict abort
-    let str = self.string('`')
-    call self.same('`')
-    return snipmate#util#eval(str)
-endfunction
-
-function! s:parser_string(till, ...) dict abort
-    let val = ''
-    let till = '\V\[' . escape(a:till, '\') . ']'
-
-    while self.pos < self.len
-        if self.same('\')
-            if self.next != "\n"
-                let val .= self.next
-            endif
-            call self.advance()
-        elseif self.next =~# till
-            break
-        elseif self.next == "\t"
-            let self.indent += 1
-            let val .= s:indent(1)
-            call self.advance()
-        else
-            let val .= self.next
-            call self.advance()
-        endif
-    endwhile
-
-    return val
-endfunction
-
-function! s:join_consecutive_strings(list) abort
-    let list = a:list
-    let pos = 0
-    while pos + 1 < len(list)
-        if type(list[pos]) == type('') && type(list[pos+1]) == type('')
-            let list[pos] .= list[pos+1]
-            call remove(list, pos + 1)
-        else
-            let pos += 1
-        endif
-    endwhile
-endfunction
-
-function! s:parser_text(till) dict abort
-    let ret = []
-    let target = ret
-
-    while self.pos < self.len
-        let lines = []
-
-        if self.same('$')
-            let var = self.var()
-            if !empty(var)
-                if var[0] is# 'VISUAL'
-                    let lines = s:visual_placeholder(var, self.indent)
-                    " Remove trailing newline. See #245
-                    if lines[-1] =~ '^\s*$' && self.next == "\n"
-                        call remove(lines, -1)
-                    endif
-                elseif var[0] >= 0
-                    call add(target, var)
-                    call self.add_var(var)
-                endif
-            endif
-        elseif self.same('`')
-            let lines = split(self.expr(), "\n", 1)
-        else
-            let lines = [self.string(a:till . s:special_chars)]
-        endif
-
-        if !empty(lines)
-            call add(target, lines[0])
-            call extend(self.stored_lines, lines[1:-2])
-            " Don't change targets if there's only one line
-            if exists("lines[1]")
-                let target = [lines[-1]]
-            endif
-        endif
-
-        " Empty lines are ignored if this is tested at the start of an iteration
-        if self.next ==# a:till
-            break
-        endif
-    endwhile
-
-    call s:join_consecutive_strings(ret)
-    if target isnot ret
-        call s:join_consecutive_strings(target)
-        call extend(self.stored_lines, target)
-    endif
-
-    return ret
-endfunction
-
-function! s:parser_line() dict abort
-    let ret = []
-    if !empty(self.stored_lines)
-        call add(ret, remove(self.stored_lines, 0))
-    else
-        call extend(ret, self.text("\n"))
-        call self.same("\n")
-    endif
-    let self.indent = 0
-    return ret
-endfunction
-
-function! s:parser_parse() dict abort
-    while self.pos < self.len || !empty(self.stored_lines)
-        let line = self.line()
-        call add(self.value, line)
-    endwhile
-endfunction
-
-function! s:indent(count) abort
-    if &expandtab
-        let shift = repeat(' ', snipmate#util#tabwidth())
-    else
-        let shift = "\t"
-    endif
-    return repeat(shift, a:count)
-endfunction
-
-function! s:visual_placeholder(var, indent) abort
-    let arg = get(a:var, 1, {})
-    if type(arg) == type({})
-        let pat = get(arg, 'pat', '')
-        let sub = get(arg, 'sub', '')
-        let flags = get(arg, 'flags', '')
-        let content = split(substitute(get(b:, 'snipmate_visual', ''), pat, sub, flags), "\n", 1)
-    else
-        let content = split(get(b:, 'snipmate_visual', arg), "\n", 1)
-    endif
-
-    let indent = s:indent(a:indent)
-    call map(content, '(v:key != 0) ? indent . v:val : v:val')
-
-    return content
-endfunction
-
-function! s:parser_create_stubs() dict abort
-
-    for [id, dict] in items(self.vars)
-        for i in dict.instances
-            if len(i) > 1 && type(i[1]) != type({})
-                if !has_key(dict, 'placeholder')
-                    let dict.placeholder = i[1:]
-                    call add(i, dict)
-                else
-                    unlet i[1:]
-                    call s:create_mirror_stub(i, dict)
-                endif
-            else
-                call s:create_mirror_stub(i, dict)
-            endif
-        endfor
-        if !has_key(dict, 'placeholder')
-            let dict.placeholder = []
-            let j = 0
-            while len(dict.instances[j]) > 2
-                let j += 1
-            endwhile
-            let oldstub = remove(dict.instances[j], 1, -1)[-1]
-            call add(dict.instances[j], '')
-            call add(dict.instances[j], dict)
-            call filter(dict.mirrors, 'v:val isnot oldstub')
-        endif
-        unlet dict.instances
-    endfor
-
-endfunction
-
-function! s:create_mirror_stub(mirror, dict)
-    let mirror = a:mirror
-    let dict = a:dict
-    let stub = get(mirror, 1, {})
-    call add(mirror, stub)
-    let dict.mirrors = get(dict, 'mirrors', [])
-    call add(dict.mirrors, stub)
-endfunction
-
-function! snipmate#parse#snippet(text, ...) abort
-    let parser = s:new_parser(a:text)
-    call parser.parse()
-    if !(a:0 && a:1)
-        call parser.create_stubs()
-    endif
-    unlet! b:snipmate_visual
-    return [parser.value, parser.vars]
-endfunction
-
-call extend(s:parser_proto, snipmate#util#add_methods(s:sfile(), 'parser',
-            \ [ 'advance', 'same', 'id', 'add_var', 'var', 'varend',
-            \   'line', 'string', 'create_stubs', 'pat',
-            \   'placeholder', 'subst', 'expr', 'text', 'parse',
-            \ ]), 'error')
diff --git a/sources_non_forked/vim-snipmate/autoload/snipmate/util.vim b/sources_non_forked/vim-snipmate/autoload/snipmate/util.vim
deleted file mode 100644
index a80d307..0000000
--- a/sources_non_forked/vim-snipmate/autoload/snipmate/util.vim
+++ /dev/null
@@ -1,30 +0,0 @@
-" The next function was based on s:function and s:add_methods in fugitive
-" <https://github.com/tpope/vim-fugitive/blob/master/plugin/fugitive.vim>
-function! snipmate#util#add_methods(sfile, namespace, methods) abort
-	let dict = {}
-	for name in a:methods
-		let dict[name] = function(join([matchstr(a:sfile, '<SNR>\d\+'),
-                    \ a:namespace, name], '_'))
-	endfor
-	return dict
-endfunction
-
-function! snipmate#util#eval(arg)
-    try
-        let ret = eval(a:arg)
-    catch
-        echohl ErrorMsg
-        echom 'SnipMate:Expression: ' . v:exception
-        echohl None
-        let ret = ''
-    endtry
-    return type(ret) == type('') ? ret : string(ret)
-endfunction
-
-function! snipmate#util#tabwidth()
-    if &sts > 0
-        return &sts
-    else
-        return exists('*shiftwidth') ? shiftwidth() : &sw
-    endif
-endfunction
diff --git a/sources_non_forked/vim-snipmate/doc/snipMate.txt b/sources_non_forked/vim-snipmate/doc/snipMate.txt
deleted file mode 100644
index cb5f9ff..0000000
--- a/sources_non_forked/vim-snipmate/doc/snipMate.txt
+++ /dev/null
@@ -1,704 +0,0 @@
-*SnipMate.txt*  Plugin for using TextMate-style snippets in Vim.
-
-SnipMate                                       *snippet* *snippets* *SnipMate*
-
-1. Description                        |SnipMate-description|
-2. Usage                              |SnipMate-usage|
-3. Interface and Settings             |SnipMate-interface| |SnipMate-settings|
-4. Snippets                           |SnipMate-snippets|
-  - Snippet files                     |SnipMate-snippet-files|
-  - Snippet syntax                    |SnipMate-syntax|
-5. Snippet sources                    |SnipMate-snippet-sources|
-6. Disadvantages to TextMate          |SnipMate-disadvantages|
-7. Contact                            |SnipMate-contact|
-8. License                            |SnipMate-license|
-
-For Vim version 7.0 or later.
-This plugin only works if 'compatible' is not set.
-{Vi does not have any of these features.}
-
-SnipMate depends on vim-addon-mw-utils and tlib.
-
-==============================================================================
-DESCRIPTION                                             *SnipMate-description*
-
-SnipMate implements snippet features in Vim. A snippet is like a template,
-reducing repetitive insertion of pieces of text. Snippets can contain
-placeholders for modifying the text if necessary or interpolated code for
-evaluation. For example, in C, typing "for" then pushing <Tab> could expand
-to: >
-
-    for (i = 0; i < count; i++) {
-        /* code */
-    }
-
-SnipMate is inspired by TextMate's snippet features.
-
-==============================================================================
-USAGE                                                         *SnipMate-usage*
-
-Every snippet consists of an expansion and a trigger. Typing a trigger into
-your buffer and then hitting your trigger key (<Tab> by default, see
-|SnipMate-mappings|) will replace the trigger with the expansion text.
-
-The expansion text can optionally include tab stops. When it does, upon
-expansion of the snippet, the cursor is placed at the first one, and the user
-can jump between each tab stop. Each of these tab stops can be represented by
-default placeholder text. If such a placeholder is provided, then the text of
-the placeholder can be repeated in the snippet at specified mirrors. Any edits
-to the placeholder are instantly updated at every mirror.
-
-SnipMate allows multiple snippets to use the same trigger. When triggered,
-a list of all snippets with that trigger is provided and prompts for which
-snippet to use.
-
-                                                             *SnipMate-scopes*
-SnipMate searches for snippets inside a directory named "snippets" inside each
-entry in 'runtimepath'. Which files are loaded depends on 'filetype' and
-'syntax'; see |SnipMate-syntax| for more information. Snippets are loaded and
-refreshed automatically on demand.
-
-Note: SnipMate does not ship with any snippets. In order to use it, the user
-must either write their own snippets or obtain some from a repository like
-https://github.com/honza/vim-snippets
-
-==============================================================================
-INTERFACE AND SETTINGS                *SnipMate-interface* *SnipMate-settings*
-
-                                                           *SnipMate-commands*
-Commands~
-
-                                                   *:SnipMateOpenSnippetFiles*
-:SnipMateOpenSnippetFiles       Opens a list of all valid snippet locations
-                                based on the current scope |SnipMate-scopes|.
-                                Only existing files and non-existing .snippets
-                                files will be shown, with the existing files
-                                shown first.
-
-:SnipMateLoadScope[!] scope [scope ...]
-                                Load snippets from additional scopes. Without
-                                [!] the additional scopes are loaded only in
-                                the current buffer. For example >
-                                    :SnipMateLoadScopes rails
-<                               will load all rails.snippets in the current
-                                buffer.
-
-                                                            *SnipMate-options*
-Options~
-
-g:snips_author                  A variable used in some snippets in place of
-                                the author's (your) name. Similar to
-                                $TM_FULLNAME in TextMate. For example, >
-                                    snippet name
-                                        `g:snips_author`
-<                               creates a snippet "name" that expands to your
-                                name.
-
-g:snipMate                      This |Dictionary| contains other SnipMate
-                                options. In short add >
-                                    let g:snipMate = {}
-<                               to your .vimrc before setting other SnipMate
-                                options.
-
-g:snipMate.scope_aliases        A |Dictionary| associating certain filetypes
-                                with other scopes |SnipMate-scopes|. The
-                                entries consist of a filetype as the key and
-                                a comma-separated list of aliases as the
-                                value. For example, >
-                                    let g:snipMate.scope_aliases = {}
-                                    let g:snipMate.scope_aliases['ruby']
-                                                \ = 'ruby,ruby-rails'
-<                               tells SnipMate that "ruby-rails" snippets in
-                                addition to "ruby" snippets should be loaded
-                                when editing files with 'filetype' set to
-                                "ruby" or contains "ruby" as an entry in the
-                                case of dotted filetypes. A buffer local
-                                variant b:snipMate_scope_aliases is merged
-                                with the global variant.
-
-g:snipMate_no_default_aliases   Note: This has been renamed to the following.
-
-g:snipMate.no_default_aliases
-                                When set to 1, prevents SnipMate from loading
-                                default scope aliases. The defaults are:
-                                    Filetype    Alias ~
-                                    cpp         c
-                                    cu          c
-                                    eruby       eruby-rails,html
-                                    html        javascript
-                                    mxml        actionscript
-                                    objc        c
-                                    php         php,html,javascript
-                                    ur          html,javascript
-                                    xhtml       html
-                                Individual defaults can be disabled by setting
-                                them to an empty value: >
-                                    let g:snipMate.scope_aliases.php = ''
-<                                will disable the default PHP alias.
-                                Note: Setting this option does not disable
-                                scope aliases entirely, only those made by
-                                SnipMate itself. Any scope aliases created by
-                                the user or someone else will still be in
-                                effect.
-
-g:snipMate.snippet_version
-                                The snippet parser version to use. The
-                                possible values are:
-                                    0   Use the older parser
-                                    1   Use the newer parser
-                                If unset, SnipMate defaults to version 0. The
-                                value of this option is also used for all
-                                .snippet files. See |SnipMate-parser-versions|
-                                for more information.
-
-g:snipMate.override
-                                As detailed below, when two snippets with the
-                                same name and description are loaded, both are
-                                kept and differentiated by the location of the
-                                file they were in. When this option is enabled
-                                (set to 1), the snippet originating in the
-                                last loaded file is kept, similar to how Vim
-                                maps and other settings work. Note: Load order
-                                is determined by 'runtimepath'.
-
-                                Duplicates are only dropped after reading one
-                                snippet file. If multiple files contain a
-                                snippet see always_choose_first
-g:snipMate.always_choose_first
-                                Always choose first snippet if there are
-                                multiple left
-
-g:snipMate.description_in_completion
-                                If set to 1 (default is 0), snippet
-                                descriptions will be included in the popup
-                                menu used for snippet completion, like with
-                                <Plug>snipMateShow.
-
-g:snipMate['no_match_completion_feedkeys_chars']
-                                A string inserted when no match for a trigger
-                                is found. By default a tab is inserted
-                                according to 'expandtab', 'tabstop', and
-                                'softtabstop'. Set it to the empty string to
-                                prevent anything from being inserted.
-
-                                                           *SnipMate-mappings*
-Mappings~
-
-The mappings SnipMate uses can be customized with the |:map| commands. For
-example, to change the key that triggers snippets and moves to the next
-tab stop, >
-
-        :imap <C-J> <Plug>snipMateNextOrTrigger
-        :smap <C-J> <Plug>snipMateNextOrTrigger
-
-Note: The noremap variants of the map commands must NOT be used.
-
-The list of possible <Plug> mappings is as follows:
-
-<Plug>snipMateNextOrTrigger     Default: <Tab>          Mode: Insert, Select
-                                Jumps to the next tab stop or, if none exists,
-                                try to expand a snippet. Use in both insert
-                                and select modes.
-
-<Plug>snipMateTrigger           Default: unmapped       Mode: Insert
-                                Try to expand a snippet regardless of any
-                                existing snippet expansion. If done within an
-                                expanded snippet, the outer snippet's tab
-                                stops are lost, unless expansion failed.
-
-<Plug>snipMateBack              Default: <S-Tab>        Mode: Insert, Select
-                                Jump to the previous tab stop, if it exists.
-                                Use in both insert and select modes.
-
-<Plug>snipMateShow              Default: <C-R><Tab>     Mode: Insert
-                                Show all available snippets (that start with
-                                the previous text, if it exists). Use in
-                                insert mode.
-
-<Plug>snipMateVisual            Default: <Tab>          Mode: Visual
-                                See |SnipMate-visual|.
-
-Additionally, <CR> is mapped in visual mode in .snippets files for retabbing
-snippets.
-
-==============================================================================
-SNIPPETS                                                   *SnipMate-snippets*
-
-                                                      *SnipMate-snippet-files*
-Snippet Files ~
-
-Note: SnipMate does not ship with any snippets.
-
-SnipMate looks inside of each entry of 'rtp' (or |SnipMate-snippet-sources|)
-for a directory named /snippets/. Based on the 'filetype' and 'syntax'
-settings (dotted filetypes are parsed), the following files are read for
-snippets: >
-
-    .../snippets/<scope>.snippets
-    .../snippets/<scope>_<name>.snippets
-    .../snippets/<scope>/<name>.snippets
-    .../snippets/<scope>/<trigger>.snippet
-    .../snippets/<scope>/<trigger>/<description>.snippet
-
-where <scope> is a scope or 'filetype' or 'syntax', <name> is an arbitrary
-name, <trigger> is the trigger for a snippet, and <description> is
-a description used for |SnipMate-multisnip|.
-
-A .snippet file defines a single snippet with the trigger (and description)
-determined by the filename. The entire contents of the file are used as the
-snippet expansion text.
-
-Multiple snippets can be defined in *.snippets files. Each snippet definition
-looks something like: >
-
-    snippet trigger optional description
-        expanded text
-        more expanded text
-
-<                                                         *SnipMate-multisnip*
-The description is optional. If it is left out, the description "default" is
-used. When two snippets in the same scope have the same name and the same
-description, SnipMate will try to preserve both. The g:snipMate.override
-option disables this, in favor of keeping the last-loaded snippet. This can be
-overridden on a per-snippet basis by defining the snippet with a bang (!): >
-
-    snippet! trigger optional description
-        expanded text
-        more expanded text
-
-Two bangs will remove the trigger entirely from SnipMate's lookup. In this
-case any snippet text is unused.
-
-Note: Hard tabs in the expansion text are required. When the snippet is
-expanded in the text and 'expandtab' is set, each tab will be replaced with
-spaces based on 'softtabstop' if nonzero or 'shiftwidth' otherwise.
-
-
-SnipMate currently provides two versions for the snippet parser. The
-differences between them can be found at |SnipMate-parser-versions|. Which
-version parser the snippets in a file should be used with can be specified
-with a version line, e.g.: >
-
-    version 1
-
-Specification of a version applies to the snippets following it. Multiple
-version specifications can appear in a single file to intermix version 0 and
-version 1 snippets. The default is determined by the
-g:snipMate.snippet_version option. |SnipMate-options|
-
-Comments can be made in .snippets files by starting a line with a # character.
-However these can't be used inside of snippet definitions: >
-
-    # this is a correct comment
-    snippet trigger
-        expanded text
-    snippet another_trigger
-        # this isn't a comment!
-        expanded text
-
-This should hopefully be clear with the included syntax highlighting.
-
-                                                            *SnipMate-extends*
-Borrowing from UltiSnips, .snippets files can also contain an extends
-directive, for example: >
-
- extends html, javascript, css
-
-will tell SnipMate to also read html, javascript, and css snippets.
-
-SNIPPET SYNTAX                             *snippet-syntax* *SnipMate-syntax*
-
-As mentioned above, there are two versions of the snippet parser. They are
-selected by the g:snipMate.snippet_version option (|SnipMate-options|) or the
-version directive in .snippets files. Differences will be mentioned throughout
-with a summary at |SnipMate-parser-versions|.
-
-Anywhere in a snippet, a backslash escapes the character following it,
-regardless of whether that character is special or not. That is, '\a' will
-always result in an 'a' in the output. A single backslash can be output by
-using '\\'.
-
-                                                          *SnipMate-tabstops*
-Tab stops~
-
-When triggering a snippet, SnipMate will by default jump to the very end of
-the snippet text. This can be changed through the use of tab stops: $1, $2,
-and so on. After expansion, SnipMate will jump to the first tab stop. From
-then on, the <Plug>snipMateNextOrTrigger map will jump to the next higher
-numbered tabs top.
-
-In the case of an ambiguity, for example if a stop occurs just before
-a literal number, braces may be placed around the stop number to resolve it:
-${3}79 is the third tab stop followed by the string "79".
-
-NOTE: In the version 0 snippet parser, the braces are mandatory.
-
-                                                       *SnipMate-zero-tabstop*
-SnipMate will always stop at the special zero tab stop $0. Once it jumps to
-the zero tab stop, snippet expansion is finished. If the zero tab stop is not
-present in a definition, it will be put at the end.
-
-For example, to place the cursor first on the id of a <div> tag, then on its
-class, and finally end editing its contents: >
-
-    snippet div
-        <div id="$1" class="$2">
-            $0
-        </div>
-
-<                                                      *SnipMate-placeholders*
-In addition to being simply a location, each tab stop contains a placeholder,
-or some default text. The placeholder can be specified for every tab stop
-(including the zero tab stop) with a colon after the stop ID, as in
-${1:default text}. The braces are required only when specifying a placeholder.
-Once a tab stop with a placeholder is reached, the placeholder will be
-selected in |Select-mode|. For example, >
-
-    snippet div
-        <div id="${1:id}" class="${2:class}">
-            $0
-        </div>
-
-Finally, placeholders can contain mirrors and evaluations (detailed below) and
-even entire other tab stops. If the placeholder is edited, then these nested
-tab stops are removed and skipped entirely. For example, >
-
-    snippet div
-        <div${1: id="${2:id}"}${3: class="${4:class}"}>
-            $0
-        </div>
-
-When expanded, this snippet selects the entirety of the id attribute. If this
-stop is edited, then the second tab stop is removed and the third tab stop
-becomes the next one. If the first tab stop is left unedited, then SnipMate
-jumps to the second tab stop. This allows the user to use a single div snippet
-that can be used for instances where the id or class attributes are desired
-and those where they are not.
-
-                                                            *SnipMate-mirrors*
-Mirrors~
-
-A mirror is simply a copy of a tab stop's text, updated as the tab stop is
-edited. These look like a tab stop without a placeholder; $1 for example. In
-the event that no placeholder is specified for a certain tab stop--say $1--the
-first instance becomes the tab stop and the rest become mirrors.
-
-Additionally, in version 1 of the parser, substitutions similar to
-|:substitute| can be performed. For instance ${1/foo/bar/g} will replace all
-instances of "foo" in the $1 mirror with "bar". This uses |substitute()|
-behind the scenes.
-
-Note: Just like with tab stops, braces can be used to avoid ambiguities: ${1}2
-is a mirror of the first tab stop followed by a 2. Version 0 of the snippet
-parser offers no way to resolve such ambiguities. Version 0 also requires that
-a tabstop have a placeholder before its mirrors work.
-
-As an example, >
-
-    snippet for
-        for ($1 = ${2:start}; ${1:i} < ${3:end}; $1${4:++}) {
-            ${0:/* code */}
-        }
-
-<                                                              *SnipMate-eval*
-Expression Evaluation~
-
-Snippets can contain Vim script expressions that are evaluated as the snippet
-is expanded. Expressions are specified inside backticks: >
-
- snippet date
-        `strftime("%Y-%m-%d")`
-
-If the expression results in any Vim error, the error will be displayed (or
-found in :messages) and the result of the expression will be the empty string.
-
-Filename([{expr}] [, {defaultText}])                     *SnipMate-Filename()*
-
-Since the current filename is used often in snippets, a default function
-has been defined for it in SnipMate.vim, appropriately called Filename().
-
-With no arguments, the default filename without an extension is returned;
-the first argument specifies what to place before or after the filename,
-and the second argument supplies the default text to be used if the file
-has not been named. "$1" in the first argument is replaced with the filename;
-if you only want the filename to be returned, the first argument can be left
-blank. Examples: >
-
- snippet filename
-        `Filename()`
- snippet filename_with_default
-        `Filename('', 'name')`
- snippet filename_foo
-        `Filename('$1_foo')`
-
-The first example returns the filename if it the file has been named, and an
-empty string if it hasn't. The second returns the filename if it's been named,
-and "name" if it hasn't. The third returns the filename followed by "_foo" if
-it has been named, and an empty string if it hasn't.
-
-                                                             *SnipMate-visual*
-The VISUAL Stop~
-
-While tab stops have numeric IDs, a special one exists with the ID 'VISUAL'.
-When a snippet is expanded, if any text had been grabbed with the
-snipMateVisual mapping (see |SnipMate-mappings|), all instances of the VISUAL
-stop will be replaced with it. Both transformations as well as a default
-placeholder can be used with the VISUAL stop.
-
-Note: Both $VISUAL and ${VISUAL} are valid in version 1 of the snippet parser.
-In version 0, only {VISUAL} is valid (without the $), and neither
-transformations nor a default placeholder can be used.
-
-Example: >
-
-    snippet div
-        <div>
-            ${0:${VISUAL:<!-- content -->}}
-        </div>
-<
-                                                    *SnipMate-parser-versions*
-Parser Versions~
-
-SnipMate provides two versions for its snippet parser. Version 0 is the legacy
-regex based version and is updated sparingly. Version 1 is the revamped
-version with new features. Any newly developed features will likely only be
-available to version 1 users.
-
-Which version is used is determined by version directives in snippet files
-(|SnipMate-snippet-files|) and by the g:snipMate.snippet_version option
-(|SnipMate-options|).
-
-A complete list of current differences is as follows:
-- Backslash escaping is guaranteed to work in version 1. In certain edge cases
-  this may not work in version 0.
-- Certain syntactic errors, such as a missing closing brace for a tabstop, are
-  more gracefully handled in version 1. In most cases, the parser will either
-  discard the error or, as in the previous example, end an item at the end of
-  line. Version 0 may not be predictable in this regard.
-- Braces are not mandatory in version 1. SnipMate will determine which
-  instance of a stop ID to use based on the presence of a placeholder, or
-  whichever instance occurs first. Braces can therefore be used to
-  disambiguate between stop 12, $12, and stop 1 followed by a 2, ${1}2. In
-  other words, version 0 makes a distinction between a mirror and a stop while
-  version 1 resolves the differences for you.
-- Placeholders are not mandatory to enable mirror support in version 1.
-- Version 0 uses the confusing syntax {VISUAL} to refer to visual content.
-  Version 1 treats it as just another stop ID, so both $VISUAL and ${VISUAL}
-  work. Plus version 1 allows a default value in case no visual selection has
-  been made.
-- Transformations similar to |:substitute| can be preformed on any mirror,
-  including visual content.
-
-==============================================================================
-SNIPPET SOURCES                                     *SnipMate-snippet-sources*
-
-SnipMate is configurable.
-
-plugin/SnipMate.vim assigns a couple important keys: >
-
-    " default implementation collecting snippets by handlers
-    let g:SnipMate['get_snippets'] = SnipMate#GetSnippets
-    " default handler:
-    let g:SnipMateSources['default'] = SnipMate#DefaultPool
-
-You can override both of those settings.
-
-You can see that the default set of snippets is determined by Vim's 'rtp'.
-
-Example 1:~
-autoload/SnipMate_python_demo.vim shows how you can register additional
-sources such as creating snippets on the fly representing python function
-definitions found in the current file.
-
-Example 2:~
-Add to your ~/.vimrc: For each know snippet add a second version ending in _
-adding folding markers >
-
-    let g:commentChar = {
-                \   'vim': '"',
-                \   'c': '//',
-                \   'cpp': '//',
-                \   'sh': '#',
-                \   'python': '#'
-                \ }
-    " url https://github.com/garbas/vim-snipmate/issues/49
-    fun! AddFolding(text)
-        return substitute(a:text,'\n'," ".g:commentChar[&ft]." {{{\n",1)."\n".g:commentChar[&ft]." }}}"
-    endf
-
-    fun! SnippetsWithFolding(scopes, trigger, result)
-        " hacky: temporarely remove this function to prevent infinite recursion:
-        call remove(g:SnipMateSources, 'with_folding')
-        " get list of snippets:
-        let result = SnipMate#GetSnippets(a:scopes, substitute(a:trigger,'_\(\*\)\?$','\1',''))
-        let g:SnipMateSources['with_folding'] = funcref#Function('SnippetsWithFolding')
-
-        " add folding:
-        for k in keys(result)
-        let a:result[k.'_'] = map(result[k],'AddFolding(v:val)')
-        endfor
-    endf
-
-    " force setting default:
-    runtime plugin/SnipMate.vim
-    " add our own source
-    let g:SnipMateSources['with_folding'] = funcref#Function('SnippetsWithFolding')
-
-See |SnipMate-syntax| for more details about all possible relative locations
-to 'rtp' can be found in.
-
-==============================================================================
-KNOWN ISSUES                                         *SnipMate-known-issues*
-
-SnipMate.vim currently has the following disadvantages to TextMate's snippets:
-    - Placeholders cannot span multiple lines.
-    - Activating snippets in different scopes of the same file is
-      not possible.
-    - Vim formatting with fo=t or fo=a can mess up SnipMate.
-
-Perhaps some of these features will be added in a later release.
-
-==============================================================================
-CHANGELOG                                                 *SnipMate-changelog*
-
-0.89 - 2016-05-29
------------------
-
-* Various regex updates to legacy parser Addition of double bang syntax to
-* completely remove a snippet from lookup Group various SnipMate autocommands
-* Support setting 'shiftwidth' to 0 Parser now operates linewise, adding some
-* flexibility Mirror substitutions are more literal Mirror length is
-* calculated correctly when substitutions occur
-
-0.88 - 2015-04-04
------------------
-
-* Implement simple caching
-* Remove expansion guards
-* Add `:SnipMateLoadScope` command and buffer-local scope aliases
-* Load `<scope>_*.snippets` files
-* Use CursorMoved autocmd events entirely
-
-* The nested branch has been merged
-    * A new snippet parser has been added. The g:snipmate.version as well as
-      version lines in snippet files determines which is used
-    * The new parser supports tab stops placed within placeholders,
-      substitutions, non-consecutive stop numbers, and fewer ambiguities
-    * The stop jumping code has been updated
-    * Tests have been added for the jumping code and the new parser
-
-* The override branch has been merged
-    * The g:snipMate.override option is added. When enabled, if two snippets
-      share the same name, the later-loaded one is kept and the other discarded
-    * Override behavior can be enabled on a per-snippet basis with a bang (!) in
-      the snippet file
-    * Otherwise, SnipMate tries to preserve all snippets loaded
-
-* Fix bug with mirrors in the first column
-* Fix bug with tabs in indents
-  <http://github.com/garbas/vim-snipmate/issues/143>
-* Fix bug with mirrors in placeholders
-* Fix reading single snippet files
-* Fix the use of the visual map at the end of a line
-* Fix expansion of stops containing only the zero tab stop
-* Remove select mode mappings
-* Indent visual placeholder expansions and remove extraneous lines
-  <http://github.com/garbas/vim-snipmate/issues/177>
-  <http://github.com/garbas/vim-snipmate/issues/178>
-
-0.87 - 2014-01-04
------------------
-
-* Stop indenting empty lines when expanding snippets
-* Support extends keyword in .snippets files
-* Fix visual placeholder support
-* Add zero tabstop support
-* Support negative 'softtabstop'
-* Add g:snipMate_no_default_aliases option
-* Add <Plug>snipMateTrigger for triggering an expansion inside a snippet
-* Add snipMate#CanBeTriggered() function
-
-0.86 - 2013-06-15
------------------
-* Use more idiomatic <Plug> maps
-* Remove most select mode mappings
-
-* Fix disappearing variables bug (hpesoj)
-* Fix cursor position bug when a variable is on the same line as the stop
-* Fix undo point creation causing problems with Supertab
-* Fix bug where SnipMate would use a typed trigger as a regular expression
-
-0.85 - 2013-04-03
------------------
-
-* Allow trigger key customization
-* Enable undoing of snippet expansion
-* Support backslash escaping in snippets
-* Add support for {VISUAL}
-* Expand filetype extension with scope_aliases
-* Add expansion guards
-* Enable per-buffer expansion of snippets
-* Fix 'cpo' compatibility
-* Update supertab compatibility
-* Enable customization of various things through g:SnipMate
-
-* Disable spelling in snippet files
-* Highlight trigger names in .snippets files
-
-* Update many snippets
-* Separate sample snippets into separate repository
-
-0.84
-----
-
-* Unreleased version by Michael Sanders, available on his GitHub,
-  <https://github.com/msanders/snipmate.vim>
-
-0.83 - 2009-07-13
------------------
-
-* Last release done by Michael Sanders, available at
-  <http://www.vim.org/scripts/script.php?script_id=2540>
-
-==============================================================================
-CONTACT                                   *SnipMate-contact* *SnipMate-author*
-
-SnipMate is currently maintained by:
-  - Rok Garbas
-  - Marc Weber (marco-oweber@gmx.de)
-  - Adnan Zafar
-
-For bug reports, issues, or questions, check out the Issues page on GitHub:
-https://github.com/garbas/vim-snipmate/issues
-
-The original author, Michael Sanders, can be reached at:
-msanders42+snipmate <at> gmail <dot> com
-
-
-==============================================================================
-LICENSE                                                     *SnipMate-license*
-
-SnipMate is released under the MIT license:
-
-Copyright 2009-2010 Michael Sanders. All rights reserved.
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in all
-copies or substantial portions of the Software.
-
-The software is provided "as is", without warranty of any kind, express or
-implied, including but not limited to the warranties of merchantability,
-fitness for a particular purpose and noninfringement. In no event shall the
-authors or copyright holders be liable for any claim, damages or other
-liability, whether in an action of contract, tort or otherwise, arising from,
-out of or in connection with the software or the use or other dealings in the
-software.
-
-==============================================================================
- vim:tw=78:ts=8:ft=help:norl:
diff --git a/sources_non_forked/vim-snipmate/ftplugin/html_snip_helper.vim b/sources_non_forked/vim-snipmate/ftplugin/html_snip_helper.vim
deleted file mode 100644
index 4d52392..0000000
--- a/sources_non_forked/vim-snipmate/ftplugin/html_snip_helper.vim
+++ /dev/null
@@ -1,10 +0,0 @@
-" Helper function for (x)html snippets
-if exists('s:did_snip_helper') || &cp || !exists('loaded_snips')
-	finish
-endif
-let s:did_snip_helper = 1
-
-" Automatically closes tag if in xhtml
-fun! Close() abort
-	return stridx(&ft, 'xhtml') == -1 ? '' : ' /'
-endf
diff --git a/sources_non_forked/vim-snipmate/ftplugin/snippets.vim b/sources_non_forked/vim-snipmate/ftplugin/snippets.vim
deleted file mode 100644
index dde00e4..0000000
--- a/sources_non_forked/vim-snipmate/ftplugin/snippets.vim
+++ /dev/null
@@ -1,20 +0,0 @@
-" Vim filetype plugin for SnipMate snippets (.snippets and .snippet files)
-
-if exists("b:did_ftplugin")
-    finish
-endif
-let b:did_ftplugin = 1
-
-let b:undo_ftplugin = "setl et< sts< cms< fdm< fde<"
-
-" Use hard tabs
-setlocal noexpandtab softtabstop=0
-
-setlocal foldmethod=expr foldexpr=getline(v:lnum)!~'^\\t\\\\|^$'?'>1':1
-
-setlocal commentstring=#\ %s
-setlocal nospell
-
-command! -buffer -range=% RetabSnip
-            \ echom "This command is deprecated. Use :retab and = instead. Doing that now."
-            \ | <line1>,<line2>retab! | <line1>,<line2>normal =
diff --git a/sources_non_forked/vim-snipmate/indent/snippets.vim b/sources_non_forked/vim-snipmate/indent/snippets.vim
deleted file mode 100644
index 0d28f32..0000000
--- a/sources_non_forked/vim-snipmate/indent/snippets.vim
+++ /dev/null
@@ -1,32 +0,0 @@
-" Simple indent support for SnipMate snippets files
-
-if exists('b:did_indent')
-    finish
-endif
-let b:did_indent = 1
-
-setlocal nosmartindent
-setlocal indentkeys=!^F,o,O,=snippet,=version,=extends
-setlocal indentexpr=GetSnippetIndent()
-
-if exists("*GetSnippetIndent")
-    finish
-endif
-
-function! GetSnippetIndent()
-    let line = getline(v:lnum)
-    let prev_lnum = v:lnum - 1
-    let prev_line = prev_lnum != 0 ? getline(prev_lnum) : ""
-
-    if line =~# '\v^(snippet|extends|version) '
-        return 0
-    elseif indent(v:lnum) > 0
-        return indent(v:lnum)
-    elseif prev_line =~# '^snippet '
-        return &sw
-    elseif indent(prev_lnum) > 0
-        return indent(prev_lnum)
-    endif
-
-    return 0
-endfunction
diff --git a/sources_non_forked/vim-snipmate/plugin/snipMate.vim b/sources_non_forked/vim-snipmate/plugin/snipMate.vim
deleted file mode 100644
index 75e74aa..0000000
--- a/sources_non_forked/vim-snipmate/plugin/snipMate.vim
+++ /dev/null
@@ -1,136 +0,0 @@
-" File:          snipMate.vim
-" Description:   snipMate.vim implements some of TextMate's snippets features in
-"                Vim. A snippet is a piece of often-typed text that you can
-"                insert into your document using a trigger word followed by a "<tab>".
-"
-"                For more help see snipMate.txt; you can do this by using:
-"                :helptags ~/.vim/doc
-"                :h SnipMate
-
-if exists('loaded_snips') || &cp || version < 700
-	finish
-endif
-let loaded_snips = 1
-
-" Save and reset 'cpo'
-let s:save_cpo = &cpo
-set cpo&vim
-
-try
-	call funcref#Function('')
-catch /.*/
-	echoe "you're missing vim-addon-mw-utils. See install instructions at ".expand('<sfile>:h:h').'/README.md'
-endtry
-
-if (!exists('g:snipMateSources'))
-  let g:snipMateSources = {}
-  " Default source: get snippets based on runtimepath
-  let g:snipMateSources['default'] = funcref#Function('snipMate#DefaultPool')
-endif
-
-augroup SnipMateDetect
-	au BufRead,BufNewFile *.snippet,*.snippets setlocal filetype=snippets
-	au FileType snippets if expand('<afile>:e') =~# 'snippet$'
-				\ | setlocal syntax=snippet
-				\ | else
-					\ | setlocal syntax=snippets
-					\ | endif
-augroup END
-
-inoremap <silent> <Plug>snipMateNextOrTrigger  <C-R>=snipMate#TriggerSnippet()<CR>
-snoremap <silent> <Plug>snipMateNextOrTrigger  <Esc>a<C-R>=snipMate#TriggerSnippet()<CR>
-inoremap <silent> <Plug>snipMateTrigger        <C-R>=snipMate#TriggerSnippet(1)<CR>
-inoremap <silent> <Plug>snipMateBack           <C-R>=snipMate#BackwardsSnippet()<CR>
-snoremap <silent> <Plug>snipMateBack           <Esc>a<C-R>=snipMate#BackwardsSnippet()<CR>
-inoremap <silent> <Plug>snipMateShow           <C-R>=snipMate#ShowAvailableSnips()<CR>
-xnoremap <silent> <Plug>snipMateVisual         :<C-U>call <SID>grab_visual()<CR>gv"_c
-
-" config variables
-if !exists('g:snips_author')
-	let g:snips_author = 'Me'
-endif
-if !exists('g:snipMate')
-	let g:snipMate = {}
-endif
-
-" SnipMate inserts this string when no snippet expansion can be done
-let g:snipMate['no_match_completion_feedkeys_chars'] =
-			\ get(g:snipMate, 'no_match_completion_feedkeys_chars', "\t")
-
-" Add default scope aliases, without overriding user settings
-let g:snipMate.scope_aliases = get(g:snipMate, 'scope_aliases', {})
-if exists('g:snipMate_no_default_aliases')
-	echom 'The g:snipMate_no_default_aliases option has been renamed.'
-				\ 'See :h snipMate-options.'
-endif
-if (!exists('g:snipMate_no_default_aliases') || !g:snipMate_no_default_aliases)
-			\ && (!exists('g:snipMate.no_default_aliases')
-				\ || !g:snipMate.no_default_aliases)
-	let g:snipMate.scope_aliases.objc =
-				\ get(g:snipMate.scope_aliases, 'objc', 'c')
-	let g:snipMate.scope_aliases.cpp =
-				\ get(g:snipMate.scope_aliases, 'cpp', 'c')
-	let g:snipMate.scope_aliases.cu =
-				\ get(g:snipMate.scope_aliases, 'cu', 'c')
-	let g:snipMate.scope_aliases.xhtml =
-				\ get(g:snipMate.scope_aliases, 'xhtml', 'html')
-	let g:snipMate.scope_aliases.html =
-				\ get(g:snipMate.scope_aliases, 'html', 'javascript')
-	let g:snipMate.scope_aliases.php =
-				\ get(g:snipMate.scope_aliases, 'php', 'php,html,javascript')
-	let g:snipMate.scope_aliases.ur =
-				\ get(g:snipMate.scope_aliases, 'ur', 'html,javascript')
-	let g:snipMate.scope_aliases.mxml =
-				\ get(g:snipMate.scope_aliases, 'mxml', 'actionscript')
-	let g:snipMate.scope_aliases.eruby =
-				\ get(g:snipMate.scope_aliases, 'eruby', 'eruby-rails,html')
-	let g:snipMate.scope_aliases.scss =
-				\ get(g:snipMate.scope_aliases, 'scss', 'css')
-	let g:snipMate.scope_aliases.less =
-				\ get(g:snipMate.scope_aliases, 'less', 'css')
-endif
-
-let g:snipMate['get_snippets'] = get(g:snipMate, 'get_snippets', funcref#Function("snipMate#GetSnippets"))
-
-" List of paths where snippets/ dirs are located
-if exists('g:snipMate.snippet_dirs') && type(g:snipMate['snippet_dirs']) != type([])
-	echohl WarningMsg
-	echom "g:snipMate['snippet_dirs'] must be a List"
-	echohl None
-endif
-
-" _ is default scope added always
-"
-" &ft honors multiple filetypes and syntax such as in set ft=html.javascript syntax=FOO
-let g:snipMate['get_scopes'] = get(g:snipMate, 'get_scopes', funcref#Function('return split(&ft,"\\.")+[&syntax, "_"]'))
-
-" Modified from Luc Hermitte's function on StackOverflow
-" <http://stackoverflow.com/a/1534347>
-function! s:grab_visual() abort
-	let a_save = @a
-	try
-		normal! gv"ay
-		let b:snipmate_visual = @a
-	finally
-		let @a = a_save
-	endtry
-endfunction
-
-" TODO: Allow specifying an arbitrary snippets file
-function! s:load_scopes(bang, ...) abort
-	let gb = a:bang ? g: : b:
-	let gb.snipMate = get(gb, 'snipMate', {})
-	let gb.snipMate.scope_aliases = get(gb.snipMate, 'scope_aliases', {})
-	let gb.snipMate.scope_aliases['_'] = join(split(get(gb.snipMate.scope_aliases, '_', ''), ',') + a:000, ',')
-endfunction
-
-command! -bang -bar -nargs=+ SnipMateLoadScope
-			\ call s:load_scopes(<bang>0, <f-args>)
-
-" Edit snippet files
-command! SnipMateOpenSnippetFiles call snipMate#OpenSnippetFiles()
-
-" restore 'cpo'
-let &cpo = s:save_cpo
-
-" vim:noet:sw=4:ts=4:ft=vim
diff --git a/sources_non_forked/vim-snipmate/syntax/snippet.vim b/sources_non_forked/vim-snipmate/syntax/snippet.vim
deleted file mode 100644
index a947356..0000000
--- a/sources_non_forked/vim-snipmate/syntax/snippet.vim
+++ /dev/null
@@ -1,11 +0,0 @@
-" Syntax highlighting for .snippet files (used for snipMate.vim)
-" Hopefully this should make snippets a bit nicer to write!
-syn match placeHolder '\${\d\+\(:.\{-}\)\=}' contains=snipCommand
-syn match tabStop '\$\d\+'
-syn match snipEscape '\\\\\|\\`'
-syn match snipCommand '\%(\\\@<!\%(\\\\\)*\)\@<=`.\{-}\%(\\\@<!\%(\\\\\)*\)\@<=`'
-
-hi link placeHolder   Special
-hi link tabStop       Special
-hi link snipEscape    SpecialChar
-hi link snipCommand   String
diff --git a/sources_non_forked/vim-snipmate/syntax/snippets.vim b/sources_non_forked/vim-snipmate/syntax/snippets.vim
deleted file mode 100644
index 63bda4e..0000000
--- a/sources_non_forked/vim-snipmate/syntax/snippets.vim
+++ /dev/null
@@ -1,23 +0,0 @@
-" Syntax highlighting for .snippets files (used for snipMate.vim)
-" Hopefully this should make snippets a bit nicer to write!
-syn match snipComment '^#.*'
-syn match placeHolder '\${\d\+\(:.\{-}\)\=}' contains=snipCommand
-syn match tabStop '\$\d\+'
-syn match snipEscape '\\\\\|\\`'
-syn match snipCommand '\%(\\\@<!\%(\\\\\)*\)\@<=`.\{-}\%(\\\@<!\%(\\\\\)*\)\@<=`'
-syn match snippet '^snippet.*' contains=multiSnipText,snipKeyword
-syn match snippet '^extends.*' contains=snipKeyword
-syn match snippet '^version.*' contains=snipKeyword
-syn match multiSnipText '\S\+ \zs.*' contained
-syn match snipKeyword '^(snippet|extends|version)'me=s+8 contained
-syn match snipError "^[^#vse\t].*$"
-
-hi link snippet       Identifier
-hi link snipComment   Comment
-hi link multiSnipText String
-hi link snipKeyword   Keyword
-hi link snipEscape    SpecialChar
-hi link placeHolder   Special
-hi link tabStop       Special
-hi link snipCommand   String
-hi link snipError     Error
diff --git a/sources_non_forked/vim-snipmate/t/jumping.vim b/sources_non_forked/vim-snipmate/t/jumping.vim
deleted file mode 100644
index 1c3ab0d..0000000
--- a/sources_non_forked/vim-snipmate/t/jumping.vim
+++ /dev/null
@@ -1,175 +0,0 @@
-function! Setup(snip) abort
-    return snipMate#expandSnip(join(a:snip, "\n"), 1)
-endfunction
-
-function! s:to_be_file(expected) abort
-    return a:expected == getline(1,'$')
-endfunction
-
-function! s:to_be_in(item, list) abort
-    return !empty(filter(copy(a:list), 'v:val is a:item'))
-endfunction
-
-call vspec#customize_matcher('to_be_file', function('s:to_be_file'))
-call vspec#customize_matcher('to_be_in', function('s:to_be_in'))
-
-describe 'snippet state'
-
-    before
-        enew
-        let b:snip_state = snipmate#jumping#state()
-    end
-
-    after
-        bwipeout!
-    end
-
-    describe '.remove()'
-
-        it 'removes the state object'
-            Expect exists('b:snip_state') to_be_true
-            call b:snip_state.remove()
-            Expect exists('b:snip_state') to_be_false
-        end
-
-        it 'removes snippet related autocommands'
-            function! ReadAutocmds()
-                redir => autocmds
-                0verbose au snipmate_changes * <buffer>
-                redir END
-                return split(autocmds, "\n")
-            endfunction
-            aug snipmate_changes
-                au CursorMoved,CursorMovedI <buffer> echo 'event'
-            aug END
-
-            Expect len(ReadAutocmds()) > 1
-            call b:snip_state.remove()
-            Expect len(ReadAutocmds()) == 1
-        end
-
-    end
-
-    describe '.find_next_stop()'
-
-        it 'increments/decrements the stop_no'
-            let b:snip_state.stops = { 1 : {}, 2 : {} }
-            let b:snip_state.stop_no = 1
-            let b:snip_state.stop_count = 4
-
-            call b:snip_state.find_next_stop(0)
-            Expect b:snip_state.stop_no == 2
-            call b:snip_state.find_next_stop(1)
-            Expect b:snip_state.stop_no == 1
-        end
-
-        it 'continues iterating if the next/previous stop does not exist'
-            let b:snip_state.stops = { 3 : {} }
-            let b:snip_state.stop_count = 6
-            let b:snip_state.stop_no = 1
-            call b:snip_state.find_next_stop(0)
-            Expect b:snip_state.stop_no == 3
-            let b:snip_state.stop_no = 5
-            call b:snip_state.find_next_stop(1)
-            Expect b:snip_state.stop_no == 3
-        end
-
-        it 'does something at the ends'
-            "
-        end
-
-    end
-
-    describe '.remove_nested()'
-
-        it 'removes nested mirrors and only nested mirrors'
-            let mirror = { 'line' : 0 }
-            let b:snip_state.stops = { 1 : { 'placeholder' : [[2, mirror]] },
-                                    \  2 : { 'mirrors' : [mirror, {}] } }
-
-            call b:snip_state.remove_nested(1)
-            Expect len(b:snip_state.stops[2].mirrors) == 1
-            Expect b:snip_state.stops[2].mirrors[0] isnot mirror
-        end
-
-        it 'removes nested stops'
-            let stop = [2, 'abc']
-            let b:snip_state.stops = { 1 : { 'placeholder' : [stop] },
-                                    \  2 : { 'placeholder' : stop[1:1] } }
-
-            call b:snip_state.remove_nested(1)
-            Expect len(b:snip_state.stops) == 1
-            Expect keys(b:snip_state.stops) == ['1']
-        end
-
-    end
-
-    describe '.find_update_objects()'
-
-        it 'finds mirrors/stops on the same line and after cur_stop'
-            let b:snip_state.stops = {
-                        \ 1 : { 'line' : 1, 'col' : 5,
-                            \ 'placeholder' : ['x'] },
-                        \ 2 : { 'line' : 1, 'col' : 7,
-                            \ 'mirrors' : [{ 'line' : 1, 'col' : 7  }] }
-                        \ }
-            let stop = b:snip_state.stops[1]
-
-            call b:snip_state.find_update_objects(stop)
-            for obj in stop.update_objects
-                Expect obj to_be_in [ b:snip_state.stops[2],
-                            \ b:snip_state.stops[2].mirrors[0] ]
-            endfor
-        end
-
-        it 'finds mirrors/stops on the same line and after cur_stop mirrors'
-            let b:snip_state.stops = {
-                        \ 1 : { 'line' : 1, 'col' : 5,
-                            \ 'mirrors' : [{ 'line' : 2, 'col' : 5 }],
-                            \ 'placeholder' : ['x'] },
-                        \ 2 : { 'line' : 2, 'col' : 7,
-                            \ 'mirrors' : [{ 'line' : 2, 'col' : 7  }] }
-                        \ }
-            let stop = b:snip_state.stops[1]
-
-            call b:snip_state.find_update_objects(stop)
-            for obj in stop.update_objects
-                Expect obj to_be_in [ b:snip_state.stops[2],
-                            \ b:snip_state.stops[2].mirrors[0] ]
-            endfor
-        end
-
-        it 'ignores mirrors/stops on other lines'
-            let b:snip_state.stops = {
-                        \ 1 : { 'line' : 2, 'col' : 5,
-                            \ 'placeholder' : ['x'] },
-                        \ 2 : { 'line' : 1, 'col' : 7,
-                            \ 'mirrors' : [{ 'line' : 1, 'col' : 7  }] },
-                        \ 3 : { 'line' : 3, 'col' : 7,
-                            \ 'mirrors' : [{ 'line' : 3, 'col' : 7  }] }
-                        \ }
-            let stop = b:snip_state.stops[1]
-
-            call b:snip_state.find_update_objects(stop)
-            Expect empty(stop.update_objects) to_be_true
-        end
-
-        it 'ignores mirrors/stops on the same line but before cur_stop/mirrors'
-            let b:snip_state.stops = {
-                        \ 1 : { 'line' : 1, 'col' : 5,
-                            \ 'mirrors' : [{ 'line' : 2, 'col' : 5 }],
-                            \ 'placeholder' : ['x'] },
-                        \ 2 : { 'line' : 1, 'col' : 1,
-                            \ 'mirrors' : [{ 'line' : 2, 'col' : 1  }] },
-                        \ 3 : { 'line' : 2, 'col' : 3,
-                            \ 'mirrors' : [{ 'line' : 1, 'col' : 3  }] },
-                        \ }
-            let stop = b:snip_state.stops[1]
-
-            call b:snip_state.find_update_objects(stop)
-            Expect empty(stop.update_objects) to_be_true
-        end
-
-    end
-
-end
diff --git a/sources_non_forked/vim-snipmate/t/parser.vim b/sources_non_forked/vim-snipmate/t/parser.vim
deleted file mode 100644
index 3c2aa6e..0000000
--- a/sources_non_forked/vim-snipmate/t/parser.vim
+++ /dev/null
@@ -1,152 +0,0 @@
-describe 'snippet parser'
-
-    before
-        function! Parse(snippet, ...)
-            let [snip, stops] = snipmate#parse#snippet(a:snippet, (a:0 ? a:1 : 1))
-            return (a:0 > 1 && a:2) ? [snip, stops] : snip
-        endfunction
-        let b:snipmate_visual = 'testvisual'
-    end
-
-    it 'parses numeric $id and ${id} vars as [id] lists'
-        let expect = [[[1234567890]]]
-        Expect Parse('$1234567890') == expect
-        Expect Parse('${1234567890}') == expect
-    end
-
-    it 'disregards $ or ${ followed by a non-id'
-        Expect Parse('$x1') == [['x1']]
-        Expect Parse('${x}1') == [['x}1']]
-        Expect Parse('$VISUA1') == [['VISUA1']]
-        Expect Parse('${VISUA}1') == [['VISUA}1']]
-    end
-
-    it 'gathers references to each instance of each stop id'
-        let [snip, b:stops] = Parse('x$1x${2:x$1x}x$1x${1/a/b}x$VISUALx', 1, 1)
-        function! InstanceFound(list)
-            return !empty(filter(copy(b:stops[a:list[0]].instances),
-                        \ 'v:val is a:list'))
-        endfunction
-        function! CheckList(list)
-            for item in a:list
-                if type(item) == type([])
-                    Expect InstanceFound(item) to_be_true
-                    call CheckList(item)
-                endif
-                unlet item " E732
-            endfor
-        endfunction
-        call CheckList(snip[0])
-    end
-
-    it 'parses mirror substitutions ${n/pat/sub} as [n, {...}]'
-        let expect = [[[1, { 'pat' : 'abc', 'sub' : 'def' }]]]
-        Expect Parse('${1/abc/def}') == expect
-        let expect[0][0][1].flags = ''
-        Expect Parse('${1/abc/def/}') == expect
-        let expect[0][0][1].flags = 'g'
-        Expect Parse('${1/abc/def/g}') == expect
-    end
-
-    it 'reads patterns literally except for "\/"'
-        Expect Parse('${1/\a\/b/\c\/d\}}') == [[[1, { 'pat' : '\a/b', 'sub' : '\c/d}' }]]]
-    end
-
-    it 'parses vars with placeholders as [id, placeholder] lists'
-        Expect Parse('${1:abc}') == [[[1, 'abc']]]
-    end
-
-    it 'evaluates backtick expressions'
-        Expect Parse('`fnamemodify("x.y", ":r")`') == [['x']]
-    end
-
-    it 'parses placeholders for vars and other specials'
-        let text = 'a `fnamemodify("x.y", ":r")` ${2:(${3/a/b})}'
-        let expect = ['a x ', [2, '(', [3, { 'pat' : 'a', 'sub' : 'b' }], ')']]
-        Expect Parse(text) == [expect]
-        Expect Parse(printf('${1:%s}', text)) == [[[1] + expect]]
-    end
-
-    it 'converts tabs according to &et, &sts, &sw, &ts'
-        " &noet -> leave tabs alone
-        setl noet
-        Expect Parse("abc\tdef\n\t\tghi") == [["abc\tdef"], ["\t\tghi"]]
-
-        " &et -> &sts or &sw
-        setl et sts=2 sw=3
-        Expect Parse("abc\tdef\n\t\tghi") == [["abc  def"], ["    ghi"]]
-
-        setl et sts=0 sw=3
-        Expect Parse("abc\tdef\n\t\tghi") == [["abc   def"], ["      ghi"]]
-
-        setl et sts=-1 sw=3
-        Expect Parse("abc\tdef\n\t\tghi") == [["abc   def"], ["      ghi"]]
-
-        " See #227
-        if exists('*shiftwidth')
-            setl et sts=0 sw=0 ts=3
-            Expect Parse("abc\tdef\n\t\tghi") == [["abc   def"], ["      ghi"]]
-        endif
-    end
-
-    it 'parses backslashes as escaping the next character or joining lines'
-        Expect Parse('x\x') == [['xx']]
-        Expect Parse('x\\x') == [['x\x']]
-        Expect Parse("x\\\nx") == [['xx']]
-        Expect Parse('x\$1') == [['x$1']]
-        Expect Parse('${1:\}}') == [[[1, '}']]]
-        Expect Parse('`fnamemodify("\`.x", ":r")`') == [['`']]
-        Expect Parse('\`x\`') == [['`x`']]
-    end
-
-    it 'splits text at newlines'
-        Expect Parse("x\nx") == [['x'], ['x']]
-    end
-
-    it 'joins evaluated expressions to surrounding text on the same line'
-        let g:foo = 'bar'
-        Expect Parse("x`g:foo`x") == [['xbarx']]
-        Expect Parse("x`g:foo`\nx") == [['xbar'], ['x']]
-        Expect Parse("x\n`g:foo`x") == [['x'], ['barx']]
-    end
-
-    it 'expands $VISUAL placeholders with any indents'
-        Expect Parse("x$VISUALx") == [['xtestvisualx']]
-        let b:snipmate_visual = "  foo\nbar\n  baz"
-        setl noet
-        Expect Parse("\tx\n\t$VISUAL\nx") == [["\tx"], ["\t  foo"], ["\tbar"],
-                    \ ["\t  baz"], ["x"]]
-    end
-
-    it 'removes newlines from the end of VISUALs if before an end of line'
-        let b:snipmate_visual = "1\n2\n"
-        Expect Parse("x\n$VISUAL\nx") == [['x'], ['1'], ['2'], ['x']]
-    end
-
-    it 'splits the before and after a $VISUAL if it is multiline'
-        let b:snipmate_visual = "1\n2\n3"
-        Expect Parse("foo $VISUAL bar") == [['foo 1'], ['2'], ['3 bar']]
-    end
-
-    it 'determines which var with an id is the stop'
-        let [snip, stops] = Parse("$1$1$1", 0, 1)
-        Expect snip == [[[1, "", stops[1]], [1, {}], [1, {}]]]
-
-        let [snip, stops] = Parse("$1${1}$1", 0, 1)
-        Expect snip == [[[1, "", stops[1]], [1, {}], [1, {}]]]
-
-        let [snip, stops] = Parse("$1${1:}$1", 0, 1)
-        Expect snip == [[[1, {}], [1, "", stops[1]], [1, {}]]]
-
-    end
-
-    it 'picks the first of many possible stops'
-        let [snip, stops] = Parse("$1${1:foo}${1:bar}", 0, 1)
-        Expect snip == [[[1, {}], [1, "foo", stops[1]], [1, {}]]]
-    end
-
-    it 'represents empty lines as an empty string'
-        Expect Parse("foo\n\nbar") == [['foo'], [''], ['bar']]
-    end
-
-end
diff --git a/sources_non_forked/vim-snipmate/t/tests.sh b/sources_non_forked/vim-snipmate/t/tests.sh
deleted file mode 100644
index c1da250..0000000
--- a/sources_non_forked/vim-snipmate/t/tests.sh
+++ /dev/null
@@ -1,20 +0,0 @@
-#!/bin/sh
-
-tmp="$(mktemp || tmpfile)"
-vim -Es $tmp <<- EOF
-    source ~/.vimrc
-    %delete _
-    call append(0, split(&rtp, ','))
-    delete _
-    wq
-EOF
-
-rtp="$(grep -iE 'vspec|snipmate|tlib|mw-utils' < $tmp | grep -v after)"
-vspec="$(grep -iE 'vspec' < $tmp | grep -v after)"
-test_files="${*:-parser jumping}"
-
-for test in $test_files; do
-    $vspec/bin/vspec $rtp ${test%%.vim}.vim
-done
-
-rm $tmp
diff --git a/sources_non_forked/vim-snippets/UltiSnips/c.snippets b/sources_non_forked/vim-snippets/UltiSnips/c.snippets
index e1eb81c..c191d76 100644
--- a/sources_non_forked/vim-snippets/UltiSnips/c.snippets
+++ b/sources_non_forked/vim-snippets/UltiSnips/c.snippets
@@ -1,7 +1,33 @@
 ###########################################################################
 #                            TextMate Snippets                            #
 ###########################################################################
+# --------------
+# Functions
+# --------------
+global !p
+def printf_expand_args(snip):
+	"""
+	This will look how many placeholders printf has and adds the separated commas
+	at the end.
+	"""
+	
+	# now add so many "," as much as the amount of placeholders
+	amount_placeholders = snip.tabstops[1].current_text.count("%")
+
+	output = ""
+
+	# Add the amount of tabstops
+	for placeholder_index in range(3, amount_placeholders + 3):
+		output += f", ${placeholder_index}"
+	
+	# convert them into tabstops
+	snip.expand_anon(output)
+
+endglobal
 
+# ==============
+# Snippets 
+# ==============
 priority -50
 
 snippet def "#define ..."
@@ -49,6 +75,16 @@ for (${4:int} ${2:i} = 0; $2 < ${1:count}; ${3:++$2}) {
 }
 endsnippet
 
+snippet fora "for-loop" b
+for (${1:var}; ${2:condition}; `!p
+if len(t[1]) > 0:
+	snip.rv = t[1].split('=')[0].split()[-1]
+`++) {
+	
+	$0
+} /* for ($1; $2; `!p if len(t[1]) > 0: snip.rv = t[1].split('=')[0].split()[-1]`++) */
+endsnippet
+
 snippet once "Include header once only guard"
 #ifndef ${1:`!p
 if not snip.c:
@@ -75,8 +111,9 @@ else if (${1:/* condition */}) {
 }
 endsnippet
 
-snippet printf "printf .. (printf)"
-printf("${1:%s}\n"${1/([^%]|%%)*(%.)?.*/(?2:, :\);)/}$2${1/([^%]|%%)*(%.)?.*/(?2:\);)/}
+post_jump "printf_expand_args(snip)"
+snippet "printf" "printf with auto-expand args" wr
+printf("$1\n"$2);
 endsnippet
 
 snippet st "struct"
diff --git a/sources_non_forked/vim-snippets/UltiSnips/cpp.snippets b/sources_non_forked/vim-snippets/UltiSnips/cpp.snippets
index 1abd509..d152aa7 100644
--- a/sources_non_forked/vim-snippets/UltiSnips/cpp.snippets
+++ b/sources_non_forked/vim-snippets/UltiSnips/cpp.snippets
@@ -30,6 +30,19 @@ endglobal
 ###########################################################################
 #                            TextMate Snippets                            #
 ###########################################################################
+snippet main
+int main()
+{
+	${0}
+}
+endsnippet
+
+snippet forc "general for loop (for)"
+for (${6:auto} ${1:i} = ${2:v.begin()}; `!p import re; snip.rv = re.split("[^\w]",t[1])[-1]` ${4:!=} ${3:`!p m = re.search(r'^(?:(.*)(\.|->)begin\(\)|((?:std|boost)::)?begin\((.*)\))$', t[2]); snip.rv = (((m.group(3) if m.group(3) else "") + "end(" + m.group(4) + ")") if m.group(4) else (m.group(1) + m.group(2) + "end()")) if m else ""`}; ${5:++`!p snip.rv = t[1].split(" ")[-1]`}) {
+	${VISUAL}$0
+}
+endsnippet
+
 snippet beginend "$1.begin(), $1.end() (beginend)"
 ${1:v}${1/^.*?(-)?(>)?$/(?2::(?1:>:.))/}begin(), $1${1/^.*?(-)?(>)?$/(?2::(?1:>:.))/}end()
 endsnippet
@@ -106,5 +119,68 @@ ${1:ReturnType} ${2:FunctionName}(${3:param})
 {
 	${0:FunctionBody}
 }
+endsnippet
+
+snippet boost_test "Boost test module" b
+#define BOOST_TEST_MODULE ${1:TestModuleName}
+#include <boost/test/included/unit_test.hpp>
+
+BOOST_AUTO_TEST_CASE(${2:TestCaseName})
+{
+	${0:TestDefinition}
+}
+
+endsnippet
+
+snippet boost_suite "Boost test suite module" b
+#define BOOST_TEST_MODULE ${1:TestModuleName}
+#include <boost/test/included/unit_test.hpp>
+
+BOOST_AUTO_TEST_SUITE(${2:SuiteName})
+
+BOOST_AUTO_TEST_CASE(${3:TestCaseName})
+{
+	${0:TestDefinition}
+}
+
+BOOST_AUTO_TEST_SUITE_END()
+
+endsnippet
+snippet boost_test_fixture "Boost test module with fixture" b
+#define BOOST_TEST_MODULE ${1:TestModuleName}
+#include <boost/test/included/unit_test.hpp>
+
+struct ${2:FixtureName} {
+	$2() {}
+	virtual ~$2() {}
+	/* define members here */
+};
+
+BOOST_FIXTURE_TEST_CASE(${3:SuiteName}, $2)
+{
+	${0:TestDefinition}
+}
+
+endsnippet
+
+snippet boost_suite_fixture "Boost test suite with fixture" b
+#define BOOST_TEST_MODULE ${1:TestModuleName}
+#include <boost/test/included/unit_test.hpp>
+
+struct ${2:FixtureName} {
+	$2() {}
+	virtual ~$2() {}
+	/* define members here */
+};
+
+BOOST_FIXTURE_TEST_SUITE(${3:SuiteName}, $2)
+
+BOOST_AUTO_TEST_CASE(${4:TestCaseName})
+{
+	${0:TestDefinition}
+}
+
+BOOST_AUTO_TEST_SUITE_END()
+
 endsnippet
 # vim:ft=snippets:
diff --git a/sources_non_forked/vim-snippets/UltiSnips/django.snippets b/sources_non_forked/vim-snippets/UltiSnips/django.snippets
index d6e2d43..a03cf1e 100644
--- a/sources_non_forked/vim-snippets/UltiSnips/django.snippets
+++ b/sources_non_forked/vim-snippets/UltiSnips/django.snippets
@@ -148,7 +148,6 @@ class ${1:MODELNAME}(models.Model):
 	def save(self):
 		return super($1, self).save()
 
-	@models.permalink
 	def get_absolute_url(self):
 		return ('')
 
diff --git a/sources_non_forked/vim-snippets/UltiSnips/haskell.snippets b/sources_non_forked/vim-snippets/UltiSnips/haskell.snippets
index 11d82c8..ed83271 100644
--- a/sources_non_forked/vim-snippets/UltiSnips/haskell.snippets
+++ b/sources_non_forked/vim-snippets/UltiSnips/haskell.snippets
@@ -1,5 +1,13 @@
 priority -50
 
+snippet imp "Simple import"
+import ${1:${2:Data}.${0:Text}}
+endsnippet
+
+snippet imp2 "Selective import" b
+import ${1:${2:Data}.${3:Text}} (${4})${0}
+endsnippet
+
 snippet impq "Qualified import"
-import qualified ${1:Data.Text} as ${0:`!p snip.rv = t[1].split(".")[-1]`}
+import qualified ${1:${2:Data}.${3:Text}} as ${0:`!p snip.rv = t[1].split(".")[-1]`}
 endsnippet
diff --git a/sources_non_forked/vim-snippets/UltiSnips/html.snippets b/sources_non_forked/vim-snippets/UltiSnips/html.snippets
index a81b1d8..75eff90 100644
--- a/sources_non_forked/vim-snippets/UltiSnips/html.snippets
+++ b/sources_non_forked/vim-snippets/UltiSnips/html.snippets
@@ -276,7 +276,7 @@ snippet htmll "HTML basic structure with the lang attribute" b
 <html lang="${1:es}">
 	<head>
 		<meta charset="UTF-8" />
-		<meta name="viewport" content="width=device-width" />
+		<meta name="viewport" content="width=device-width, initial-scale=1" />
 		<title>${2:`!p snip.rv = snip.basename.replace('-', ' ').capitalize()`}</title>
 	</head>
 	<body>
diff --git a/sources_non_forked/vim-snippets/UltiSnips/javascript_react.snippets b/sources_non_forked/vim-snippets/UltiSnips/javascript_react.snippets
index e80ec86..666c80e 100644
--- a/sources_non_forked/vim-snippets/UltiSnips/javascript_react.snippets
+++ b/sources_non_forked/vim-snippets/UltiSnips/javascript_react.snippets
@@ -30,7 +30,7 @@ endsnippet
 snippet useCB "useCallback(fn, inputs)" b
 const ${1:callback} = useCallback((${2})) => ${3:{
 	${4}
-}}, [${5}]
+}}, [${5}])
 endsnippet
 snippet useM "useMemo(fn, inputs)" b
 const ${1:memorized} = useMemo(() => ${2:{
diff --git a/sources_non_forked/vim-snippets/UltiSnips/markdown.snippets b/sources_non_forked/vim-snippets/UltiSnips/markdown.snippets
index 72b9f8f..1017c80 100644
--- a/sources_non_forked/vim-snippets/UltiSnips/markdown.snippets
+++ b/sources_non_forked/vim-snippets/UltiSnips/markdown.snippets
@@ -104,7 +104,7 @@ endsnippet
 # Common stuff #
 ################
 snippet link "Link to something"
-[${1:${VISUAL:Text}}](${3:http://${2:www.url.com}})$0
+[${1:${VISUAL:Text}}](${3:https://${2:www.url.com}})$0
 endsnippet
 
 snippet img "Image"
@@ -125,7 +125,7 @@ endsnippet
 snippet refl "Reference Link"
 [${1:${VISUAL:Text}}][${2:id}]$0
 
-[$2]:${4:http://${3:www.url.com}} "${5:$4}"
+[$2]:${4:https://${3:www.url.com}} "${5:$4}"
 endsnippet
 
 snippet fnt "Footnote"
diff --git a/sources_non_forked/vim-snippets/UltiSnips/puppet.snippets b/sources_non_forked/vim-snippets/UltiSnips/puppet.snippets
index eacc8fc..6d23c92 100644
--- a/sources_non_forked/vim-snippets/UltiSnips/puppet.snippets
+++ b/sources_non_forked/vim-snippets/UltiSnips/puppet.snippets
@@ -8,11 +8,13 @@ global !p
 import vim
 import os.path
 def get_module_namespace_and_basename():
-	"""This function will try to guess the current class or define name you are
-	trying to create. Note that for this to work you should be using the module
-	structure as per the style guide. Examples inputs and it's output
+	"""This function will try to guess the current class, define or type
+	name you are trying to create. Note that for this to work you should be
+	using the module structure as per the style guide. Examples inputs and
+	it's output
 	* /home/nikolavp/puppet/modules/collectd/manifests/init.pp -> collectd
-	* /home/nikolavp/puppet/modules/collectd/manfistes/mysql.pp -> collectd::mysql
+	* /home/nikolavp/puppet/modules/collectd/manifests/mysql.pp -> collectd::mysql
+	* /home/nikolavp/puppet/modules/collectd/types/dbname.pp -> Collectd::Dbname
 	"""
 	first_time = True
 	current_file_path_without_ext = vim.eval('expand("%:p:r")') or ""
@@ -25,8 +27,12 @@ def get_module_namespace_and_basename():
 			first_time = False
 			parts = os.path.split(parts[0])
 			continue
-		if parts[1] == 'manifests':
-			return os.path.split(parts[0])[1] + ('::' + namespace).rstrip(':')
+		if parts[1] in ['manifests', 'types']:
+			parsed_name = os.path.split(
+				parts[0])[1] + ('::' + namespace).rstrip(':')
+			if parts[1] == 'types':
+				parsed_name = parsed_name.title()
+			return parsed_name
 		else:
 			namespace = parts[1] + '::' + namespace
 		parts = os.path.split(parts[0])
@@ -51,6 +57,16 @@ define ${1:`!p snip.rv = get_module_namespace_and_basename()`} {
 }
 endsnippet
 
+snippet type "Data type alias" b
+type ${1:`!p snip.rv = get_module_namespace_and_basename()`} = ${2:Type}
+endsnippet
+
+snippet lambda "Lambda function chain-called on a variable"
+$${1:varname}.${2:each} |${3:Type} $${4:param}| {
+	$0
+}
+endsnippet
+
 #################################################################
 #  Puppet Types                                                 #
 #    See http://docs.puppetlabs.com/references/latest/type.html #
@@ -197,6 +213,14 @@ snippet hiera_include "Hiera Include Function" b
 hiera_include("${1:Lookup}")$0
 endsnippet
 
+snippet lookup "Lookup data from hiera"
+$${1:varname} = lookup('${2:hiera::key}')$0
+endsnippet
+
+snippet trocla "Lookup or generate sensitive information"
+trocla('${1:lookup_key}', '${2:plain}', ${3:'length: 32'})$0
+endsnippet
+
 snippet include "Include Function" b
 include ${1:classname}$0
 endsnippet
diff --git a/sources_non_forked/vim-snippets/UltiSnips/rust.snippets b/sources_non_forked/vim-snippets/UltiSnips/rust.snippets
index b284f0a..6fc07e9 100644
--- a/sources_non_forked/vim-snippets/UltiSnips/rust.snippets
+++ b/sources_non_forked/vim-snippets/UltiSnips/rust.snippets
@@ -45,8 +45,8 @@ snippet .it ".iter()" i
 endsnippet
 
 snippet impl "Struct/Trait implementation" b
-impl ${1:Type/Trait}${2: for ${3:Type}} {
-	$0
+impl$4 ${1:Type/Trait}${2: for ${3:Type}}${4:<${5:T}>} {
+	${0}
 }
 endsnippet
 
diff --git a/sources_non_forked/vim-snippets/UltiSnips/tex.snippets b/sources_non_forked/vim-snippets/UltiSnips/tex.snippets
index 0243b46..5c5721f 100644
--- a/sources_non_forked/vim-snippets/UltiSnips/tex.snippets
+++ b/sources_non_forked/vim-snippets/UltiSnips/tex.snippets
@@ -9,15 +9,15 @@ def create_table(snip):
 	cols = snip.buffer[snip.line].split('x')[1]
 
 	int_val = lambda string: int(''.join(s for s in string if s.isdigit()))
-	
+
 	rows = int_val(rows)
 	cols = int_val(cols)
 
 	offset = cols + 1
 	old_spacing = snip.buffer[snip.line][:snip.buffer[snip.line].rfind('\t') + 1]
-	
+
 	snip.buffer[snip.line] = ''
-	
+
 	final_str = old_spacing + "\\begin{tabular}{|" + "|".join(['$' + str(i + 1) for i in range(cols)]) + "|}\n"
 
 	for i in range(rows):
@@ -35,7 +35,7 @@ def add_row(snip):
 	old_spacing = snip.buffer[snip.line][:snip.buffer[snip.line].rfind('\t') + 1]
 
 	snip.buffer[snip.line] = ''
-	
+
 	final_str = old_spacing
 	final_str += " & ".join(['$' + str(j + 1) for j in range(row_len)])
 	final_str += " \\\\\\"
@@ -63,7 +63,7 @@ $0${2/(?<=.)(c|l|r)|./(?1: & )/g}
 endsnippet
 
 pre_expand "create_table(snip)"
-snippet "gentbl(\d+)x(\d+)" "Generate table of *width* by *height*" r  
+snippet "gentbl(\d+)x(\d+)" "Generate table of *width* by *height*" r
 endsnippet
 
 pre_expand "add_row(snip)"
@@ -193,8 +193,6 @@ snippet acl "Acroynm expanded" b
 $0
 endsnippet
 
-
-
 snippet ni "Non-indented paragraph" b
 \noindent
 $0
@@ -241,4 +239,20 @@ snippet glnl "New long glossary item" b
   ${0:description}
 }
 endsnippet
+
+# Bold text
+snippet bf "Bold"
+\textbf{$1} $0
+endsnippet
+
+# Italic text
+snippet ita "Italics"
+\textit{$1} $0
+endsnippet
+
+# Underlined text
+snippet und "Underline"
+\underline{$1} $0
+endsnippet
+
 # vim:ft=snippets:
diff --git a/sources_non_forked/vim-snippets/pythonx/vimsnippets.py b/sources_non_forked/vim-snippets/pythonx/vimsnippets.py
index 3c638a1..eceb83c 100644
--- a/sources_non_forked/vim-snippets/pythonx/vimsnippets.py
+++ b/sources_non_forked/vim-snippets/pythonx/vimsnippets.py
@@ -1,3 +1,5 @@
+# vim:set et fileencoding=utf8 sts=0 sw=4 ts=4:
+
 """Helper methods used in UltiSnips snippets."""
 
 import string, vim, re
@@ -82,12 +84,13 @@ def get_comment_format():
 
 def make_box(twidth, bwidth=None):
     b, m, e, i = (s.strip() for s in get_comment_format())
+    m0 = m[0] if m else ''
     bwidth_inner = bwidth - 3 - max(len(b), len(i + e)) if bwidth else twidth + 2
-    sline = b + m + bwidth_inner * m[0] + 2 * m[0]
+    sline = b + m + bwidth_inner * m0 + 2 * m0
     nspaces = (bwidth_inner - twidth) // 2
     mlines = i + m + " " + " " * nspaces
     mlinee = " " + " "*(bwidth_inner - twidth - nspaces) + m
-    eline = i + m + bwidth_inner * m[0] + 2 * m[0] + e
+    eline = i + m + bwidth_inner * m0 + 2 * m0 + e
     return sline, mlines, mlinee, eline
 
 def foldmarker():
@@ -114,5 +117,3 @@ def has_cjk(s):
     cjk_re = re.compile(u'[----------]', re.UNICODE)
 
     return cjk_re.search(s) is not None
-
-# vim:set et sts=0 sw=4 ts=4:
diff --git a/sources_non_forked/vim-snippets/snippets/c.snippets b/sources_non_forked/vim-snippets/snippets/c.snippets
index 5c08415..e70d057 100644
--- a/sources_non_forked/vim-snippets/snippets/c.snippets
+++ b/sources_non_forked/vim-snippets/snippets/c.snippets
@@ -344,3 +344,10 @@ snippet todo
 # This is kind of convenient
 snippet .
 	[${1}]
+
+snippet asm
+	__asm__ __volatile__(
+	"${0}\n\t"
+	:
+	:
+	);
diff --git a/sources_non_forked/vim-snippets/snippets/clojure.snippets b/sources_non_forked/vim-snippets/snippets/clojure.snippets
index 152f896..048ce9f 100644
--- a/sources_non_forked/vim-snippets/snippets/clojure.snippets
+++ b/sources_non_forked/vim-snippets/snippets/clojure.snippets
@@ -8,21 +8,21 @@ snippet def
 	(def ${0})
 snippet defm
 	(defmethod ${1:multifn} "${2:doc-string}" ${3:dispatch-val} [${4:args}]
-		${0})
+		${0:code})
 snippet defmm
 	(defmulti ${1:name} "${2:doc-string}" ${0:dispatch-fn})
 snippet defma
 	(defmacro ${1:name} "${2:doc-string}" ${0:dispatch-fn})
 snippet defn
 	(defn ${1:name} "${2:doc-string}" [${3:arg-list}]
-		${0})
+		${0:code})
 snippet defp
 	(defprotocol ${1:name}
-		${0})
+		${0:code})
 snippet defr
 	(defrecord ${1:name} [${2:fields}]
 		${3:protocol}
-		${0})
+		${0:code})
 snippet deft
 	(deftest ${1:name}
 		(is (= ${0:assertion})))
@@ -31,12 +31,12 @@ snippet is
 snippet defty
 	(deftype ${1:Name} [${2:fields}]
 		${3:Protocol}
-		${0})
+		${0:code})
 snippet doseq
 	(doseq [${1:elem} ${2:coll}]
-		${0})
+		${0:code})
 snippet fn
-	(fn [${1:arg-list}] ${0})
+	(fn [${1:arg-list}] ${0:code})
 snippet if
 	(if ${1:test-expr}
 		${2:then-expr}
@@ -50,24 +50,24 @@ snippet imp
 		& {:keys [${1:keys}] :or {${0:defaults}}}
 snippet let
 	(let [${1:name} ${2:expr}]
-		${0})
+		${0:code})
 snippet letfn
 	(letfn [(${1:name}) [${2:args}]
-		${0})])
+		${0:code})])
 snippet map
 	(map ${1:func} ${0:coll})
 snippet mapl
 	(map #(${1:lambda}) ${0:coll})
 snippet met
 	(${1:name} [${2:this} ${3:args}]
-		${0})
+		${0:code})
 snippet ns
 	(ns ${0:name})
 snippet dotimes
 	(dotimes [_ 10]
 		(time
 			(dotimes [_ ${1:times}]
-				${0})))
+				${0:code})))
 snippet pmethod
 	(${1:name} [${2:this} ${0:args}])
 snippet refer
diff --git a/sources_non_forked/vim-snippets/snippets/cuda.snippets b/sources_non_forked/vim-snippets/snippets/cuda.snippets
index 425ca67..2fc1921 100644
--- a/sources_non_forked/vim-snippets/snippets/cuda.snippets
+++ b/sources_non_forked/vim-snippets/snippets/cuda.snippets
@@ -1 +1,59 @@
 extends cpp
+
+snippet kern "Kernel definition"
+	__global__ void ${1:kernel}(${2:void}) {
+		${0:// TODO: Implement}
+	}
+
+snippet dev "Device function definition"
+	__device__ ${1:int} ${2:foo}(${3:void}) {
+		${0:// TODO: Implement}
+		return 0;
+	}
+	
+snippet call "Kernel call"
+	${1:kernel}<<<${2:args}>>>(${3});${0}
+
+snippet sync "Synchonize threads"
+	__syncthreads();
+
+snippet tid "Thread Index"
+	threadIdx.${0}
+
+snippet bid "Block Index"
+	blockIdx.${0}
+
+snippet bdim "Block Dimension"
+	blockDim.${0}
+
+snippet ii "Get current index (1D)"
+	int ${1:index} = threadIdx.${2:x} + blockIdx.$2 * blockDim.$2;
+
+snippet ix "Get current X index (1D)"
+	int ${1:x} = threadIdx.x + blockIdx.x * blockDim.x;
+
+snippet iy "Get current Y index (1D)"
+	int ${1:y} = threadIdx.y + blockIdx.y * blockDim.y;
+
+snippet iz "Get current Z index (1D)"
+	int ${1:z} = threadIdx.z + blockIdx.z * blockDim.z;
+
+snippet ixy "Get current X,Y index (2D)"
+	int ${1:x} = threadIdx.x + blockIdx.x * blockDim.x;
+	int ${2:y} = threadIdx.y + blockIdx.y * blockDim.y;
+
+snippet ixz "Get current X,Z index (2D)"
+	int ${1:x} = threadIdx.x + blockIdx.x * blockDim.x;
+	int ${3:z} = threadIdx.z + blockIdx.z * blockDim.z;
+
+snippet iyz "Get current Y,Z index (2D)"
+	int ${2:y} = threadIdx.y + blockIdx.y * blockDim.y;
+	int ${3:z} = threadIdx.z + blockIdx.z * blockDim.z;
+
+snippet ixyz "Get current X,Y,Z index (3D)"
+	int ${1:x} = threadIdx.x + blockIdx.x * blockDim.x;
+	int ${2:y} = threadIdx.y + blockIdx.y * blockDim.y;
+	int ${3:z} = threadIdx.z + blockIdx.z * blockDim.z;
+
+snippet share "Shared memory declaration"
+	__shared__ ${1:int} ${2:memo}[${3:SIZE}];${0}
diff --git a/sources_non_forked/vim-snippets/snippets/eelixir.snippets b/sources_non_forked/vim-snippets/snippets/eelixir.snippets
index 456bed5..c15d86e 100644
--- a/sources_non_forked/vim-snippets/snippets/eelixir.snippets
+++ b/sources_non_forked/vim-snippets/snippets/eelixir.snippets
@@ -38,6 +38,17 @@ snippet ft form_tag
 	<%= form_tag(${1:"/users"}, method: ${2::post}) %>
 		${0}
 	</form>
+
+snippet sl select
+	<%= select ${1:f}, :${2:field}, ${3:[{"key", "value"}]}, prompt: ${4:"Prompt"} %>
+
+snippet sb submit
+	<%= submit ${1:"Submit"} %>
+
+snippet rb radio_button
+	<%= radio_button ${1:f}, :${2:field},  ${3:"value"} %>
+
+
 snippet et error_tag
 	<%= error_tag ${1:f}, :${2:field} %>
 snippet ti text_input
diff --git a/sources_non_forked/vim-snippets/snippets/elixir.snippets b/sources_non_forked/vim-snippets/snippets/elixir.snippets
index 468575d..ee093eb 100644
--- a/sources_non_forked/vim-snippets/snippets/elixir.snippets
+++ b/sources_non_forked/vim-snippets/snippets/elixir.snippets
@@ -81,6 +81,8 @@ snippet cb
 	@callback ${1:name}(${2:args}) :: ${3:returns}
 snippet df
 	def ${1:name}, do: ${2}
+snippet dfw
+	def ${1:name}(${2:args}) when ${3:guard}, do:
 snippet def
 	def ${1:name} do
 		${0}
@@ -92,12 +94,21 @@ snippet defd
 	def ${2:name} do
 		${0}
 	end
+snippet defs
+	@spec ${1:name}(${2:arg types}) :: ${3:no_return}
+	def $1(${4:args}) do
+		${0}
+	end
 snippet defsd
 	@doc """
 	${1:doc string}
 	"""
-	@spec ${2:name} :: ${3:no_return}
-	def ${2} do
+	@spec ${2:name}(${3:arg types}) :: ${4:no_return}
+	def $2(${5:args}) do
+		${0}
+	end
+snippet defw
+	def ${1:name}(${2:args}) when ${3:guard} do
 		${0}
 	end
 snippet defim
@@ -112,12 +123,24 @@ snippet defmo
 	defmodule ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`} do
 		${0}
 	end
+snippet %M
+	%__MODULE__{
+		${1:key_name}: ${2:value}
+	}
+snippet enfk
+	@enforce_keys [:${1:key_name}]
 snippet dfp
 	defp ${1:name}, do: ${2}
+snippet dfpw
+	defp ${1:name}(${2:args}) when ${3:guard}, do: ${4}
 snippet defp
 	defp ${1:name} do
 		${0}
 	end
+snippet defpw
+	defp ${1:name}(${2:args}) when ${3:guard} do
+		${0}
+	end
 snippet defpr
 	defprotocol ${1:name}, [${0:function}]
 snippet defr
@@ -173,12 +196,28 @@ snippet des
 	describe "${1:test group subject}" do
 		${0}
 	end
+snippet destag
+	@describetag :${1:describe tag}
+snippet mtag
+	@moduletag :${1:module tag}
+snippet dt
+	doctest ${1:filename}
+snippet tp
+	@tag :pending
 snippet exunit
 	defmodule ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`} do
 		use ExUnit.Case, async: true
 
 		${0}
 	end
+snippet setup
+	setup do
+		${1}
+	end
+snippet setupa
+	setup_all do
+		${1}
+	end
 snippet try try .. rescue .. end
 	try do
 		${1:${VISUAL}}
diff --git a/sources_non_forked/vim-snippets/snippets/eruby.snippets b/sources_non_forked/vim-snippets/snippets/eruby.snippets
index b8879c5..3d63916 100644
--- a/sources_non_forked/vim-snippets/snippets/eruby.snippets
+++ b/sources_non_forked/vim-snippets/snippets/eruby.snippets
@@ -46,8 +46,9 @@ snippet conf
 	<% content_for :${1:head} do %>
 		${0}
 	<% end %>
-snippet cs
-	<%= collection_select <+object+>, <+method+>, <+collection+>, <+value_method+>, <+text_method+><+, <+[options]+>, <+[html_options]+>+> %>
+
+snippet cs 
+	<%= collection_select(:${1:object}, :${2:method}, ${3:collection}, :${4:value_method}, :${5:text_method}, options = {${0:prompt: true}}) %>        
 snippet ct
 	<%= content_tag '${1:DIV}', ${2:content}${0:,options} %>
 snippet ff
@@ -80,6 +81,8 @@ snippet ffta
 	<%= ${1:f}.text_area :${0:attribute} %>
 snippet fftf
 	<%= ${1:f}.text_field :${0:attribute} %>
+snippet fcs
+	<%= ${1:f}.collection_select(:${2:method}, ${3:collection}, :${4:value_method}, :${5:text_method}, options = {${0:prompt: true}}) %>
 snippet fields
 	<%= fields_for :${1:model}, @$1 do |${2:f}| %>
 		${0}
diff --git a/sources_non_forked/vim-snippets/snippets/gitcommit.snippets b/sources_non_forked/vim-snippets/snippets/gitcommit.snippets
new file mode 100644
index 0000000..93b2c5d
--- /dev/null
+++ b/sources_non_forked/vim-snippets/snippets/gitcommit.snippets
@@ -0,0 +1,2 @@
+snippet co
+	Co-authored-by: ${1} <${2}>
diff --git a/sources_non_forked/vim-snippets/snippets/go.snippets b/sources_non_forked/vim-snippets/snippets/go.snippets
index b8d3e6f..202b7e8 100644
--- a/sources_non_forked/vim-snippets/snippets/go.snippets
+++ b/sources_non_forked/vim-snippets/snippets/go.snippets
@@ -129,7 +129,7 @@ snippet fum "method"
 	}
 	${0}
 
-snippet fumh "http handler function on reciever"
+snippet fumh "http handler function on receiver"
 	func (${1:receiver} ${2:type}) ${3:funcName}(${4:w} http.ResponseWriter, ${5:r} *http.Request) {
 		${0:${VISUAL}}
 	}
diff --git a/sources_non_forked/vim-snippets/snippets/html.snippets b/sources_non_forked/vim-snippets/snippets/html.snippets
index bc42f94..640a26f 100644
--- a/sources_non_forked/vim-snippets/snippets/html.snippets
+++ b/sources_non_forked/vim-snippets/snippets/html.snippets
@@ -709,7 +709,7 @@ snippet samp
 		${0}
 	</samp>
 snippet script
-	<script charset="utf-8">
+	<script>
 		${0}
 	</script>
 snippet scripts
diff --git a/sources_non_forked/vim-snippets/snippets/java.snippets b/sources_non_forked/vim-snippets/snippets/java.snippets
index 66821c1..739f20b 100644
--- a/sources_non_forked/vim-snippets/snippets/java.snippets
+++ b/sources_non_forked/vim-snippets/snippets/java.snippets
@@ -175,9 +175,9 @@ snippet tryf
 ##
 ## Find Methods
 snippet findall
-	List<${1:listName}> ${2:items} = ${1}.findAll();
+	List<${1:listName}> ${2:items} = $1.findAll();
 snippet findbyid
-	${1:var} ${2:item} = ${1}.findById(${3});
+	${1:var} ${2:item} = $1.findById(${3});
 ##
 ## Javadocs
 snippet /**
diff --git a/sources_non_forked/vim-snippets/snippets/javascript-es6-react.snippets b/sources_non_forked/vim-snippets/snippets/javascript-es6-react.snippets
deleted file mode 100644
index c913875..0000000
--- a/sources_non_forked/vim-snippets/snippets/javascript-es6-react.snippets
+++ /dev/null
@@ -1,82 +0,0 @@
-# Import only React
-snippet ri1
-	import React from 'react'
-
-# Import both React and Component
-snippet ri2
-	import React, { Component } from 'react'
-	import PropTypes from 'prop-types'
-
-# React class
-snippet rcla
-	class ${1:MyComponent} extends Component {
-		render() {
-			return (
-				${0:<div></div>}
-			)
-		}
-	}
-
-# React constructor
-snippet rcon
-	constructor(props) {
-		super(props)
-
-		this.state = {
-			${1}: ${0},
-		}
-	}
-
-# Proptypes for React Class
-snippet rcpt
-	static propTypes = {
-		${1}: PropTypes.${0},
-	}
-
-# Default props for React Class
-snippet rcdp
-	static defaultProps = {
-		${1}: ${0},
-	}
-
-# Presentational component
-snippet rcom
-	props => {
-		return (
-			${0:<div></div>}
-		)
-	}
-
-# Proptypes for Presentational component
-snippet rpt
-	${1}.propTypes = {
-		${2}: PropTypes.${0},
-	}
-
-# Default props for Presentational component
-snippet rdp
-	${1}.defaultProps = {
-		${2}: ${0},
-	}
-
-# Lifecycle Methods
-snippet rcdm
-	componentDidMount() {
-		${0:${VISUAL}}
-	}
-
-# State
-snippet rsst
-	this.setState({
-		${1}: ${0},
-	})
-
-snippet rtst
-	this.state.${0}
-
-# Props
-snippet rp
-	props.${0}
-
-snippet rtp
-	this.props.${0}
diff --git a/sources_non_forked/vim-snippets/snippets/javascript/javascript-jasmine.snippets b/sources_non_forked/vim-snippets/snippets/javascript-jasmine.snippets
similarity index 100%
rename from sources_non_forked/vim-snippets/snippets/javascript/javascript-jasmine.snippets
rename to sources_non_forked/vim-snippets/snippets/javascript-jasmine.snippets
diff --git a/sources_non_forked/vim-snippets/snippets/javascript/javascript-react.snippets b/sources_non_forked/vim-snippets/snippets/javascript/javascript-react.snippets
index 0e8d360..65cb4e1 100644
--- a/sources_non_forked/vim-snippets/snippets/javascript/javascript-react.snippets
+++ b/sources_non_forked/vim-snippets/snippets/javascript/javascript-react.snippets
@@ -1,98 +1,190 @@
-snippet ir
+# Import
+snippet ir import React
 	import React from 'react';
-snippet irc
+
+snippet irc import React and Component
 	import React, { Component } from 'react';
-snippet ird
+
+snippet irh import React hooks
+	import { use$1 } from 'react';
+
+snippet ird import ReactDOM
 	import ReactDOM from 'react-dom';
-snippet cdm
+
+snippet irp import PropTypes
+	import PropTypes from 'prop-types';
+
+# Lifecycle Methods
+snippet cdm componentDidMount
 	componentDidMount() {
 		${1}
-	}
-snippet cdup
+	};
+
+snippet cdup componentDidUpdate
 	componentDidUpdate(prevProps, prevState) {
 		${1}
-	}
-snippet cwm
+	};
+
+snippet cwm componentWillMount
 	componentWillMount() {
 		${1}
-	}
-snippet cwr
+	};
+
+snippet cwr componentWillReceiveProps
 	componentWillReceiveProps(nextProps) {
 		${1}
-	}
-snippet cwun
+	};
+
+snippet cwun componentWillUnmount
 	componentWillUnmount() {
 		${1}
-	}
-snippet cwu
+	};
+
+snippet cwu componentWillUpdate
 	componentWillUpdate(nextProps, nextState) {
 		${1}
+	};
+
+snippet scu shouldComponentUpdate
+	shouldComponentUpdate(nextProps, nextState) {
+		${1}
 	}
-snippet fup
-	forceUpdate(${1:callback});
-snippet dp
+
+# Props
+snippet spt static propTypes
+	static propTypes = {
+		${1}: PropTypes.${2}
+	};
+
+snippet pt propTypes
+	${1}.propTypes = {
+		${2}: PropTypes.${2}
+	};
+
+snippet sdp static defaultProps
 	static defaultProps = {
-		${1}: ${2},
-	}
+		${1}: ${2}	
+	};
+
+snippet dp defaultProps
+	${1}.defaultProps = {
+		${2}: ${3}
+	};
+
+snippet pp props
+	props.${1};
+
+snippet tp this props
+	this.props.${1};
+
+# State
 snippet st
 	state = {
 		${1}: ${2},
-	}
-snippet pt
-	static propTypes = {
-		${1}: React.PropTypes.${2:type},
-	}
-snippet rfc
+	};
+
+snippet sst
+	this.setState({
+		${1}: ${2}
+	});
+
+snippet tst 
+	this.state.${1};
+
+# Component
+snippet raf
 	const ${1:ComponentName} = (${2:props}) => {
+		${3:state}
+
 		return (
-			<div>
-				$1
-			</div>
+			<>
+				${4}
+			</>
 		);
-	}
-snippet rcc
-	class ${1:ClassName} extends React.Component {
-		state = {
+	};
 
-		}
+snippet rcla
+	class ${1:ClassName} extends Component {
 		render() {
 			return (
-				<div>
-					$1
-				</div>
+				<>
+					${2}
+				</>
 			);
 		}
 	}
-snippet rdr
-	ReactDOM.render(${1}, ${2})
-snippet ercc
-	export default class ${1:ClassName} extends React.Component {
+
+snippet ercla
+	export default class ${1:ClassName} extends Component {
 		render() {
 			return (
-				${0:<div />}
+				<>
+					${2}
+				</>
 			);
-		}
-	}
+		};
+	};
+
 snippet ctor
 	constructor() {
 		super();
-		${1}
+
+		${1:state}
 	}
+
 snippet ren
 	render() {
 		return (
-			${1:<div />}
+			<>
+				${2}
+			</>
 		);
 	}
-snippet sst
-	this.setState({
-		${1}: ${2}
-	});
-snippet scu
-	shouldComponentUpdate(nextProps, nextState) {
+
+snippet fup
+	forceUpdate(${1:callback});
+
+# Hooks
+snippet uses useState
+	const [${1:state}, set${2}] = useState(${3:initialState});
+
+snippet usee useEffect
+	useEffect(() => {
 		${1}
-	}
-snippet prp i
-	this.props.${1}
-snippet ste i
-	this.state.${1}
+	});
+
+snippet userd useReducer
+	const [${1:state}, ${2:dispatch}] = useReducer(${3:reducer});
+
+snippet userf useRef
+	const ${1:refContainer} = useRef(${2:initialValue});
+
+snippet usect useContext
+	const ${1:value} = useContext(${2:MyContext});
+
+snippet usecb useCallback
+	const ${1:memoizedCallback} = useCallback(
+	() => {
+		${2}(${3})
+	},
+	[$3]
+	);
+
+snippet usem useMemo
+	const ${1:memoizedCallback} = useMemo(() => ${2}(${3}), [$3]);
+
+snippet usei useImperativeHandle
+	useImperativeHandle(${1:ref}, ${2:createHandle});
+
+snippet used useDebugValue
+	useDebugValue(${1:value});
+
+# ReactDOM methods
+snippet rdr ReactDOM.render
+	ReactDOM.render(${1}, ${2});
+
+snippet rdh ReactDOM.hydrate
+	ReactDOM.hydrate(${1:element}, ${2:container}[, ${3:callback}]);
+
+snippet rdcp ReactDOM.createPortal
+	ReactDOM.createPortal(${1:child}, ${2:container});
diff --git a/sources_non_forked/vim-snippets/snippets/javascript/javascript.snippets b/sources_non_forked/vim-snippets/snippets/javascript/javascript.snippets
index c3d5a8b..dcf37a4 100644
--- a/sources_non_forked/vim-snippets/snippets/javascript/javascript.snippets
+++ b/sources_non_forked/vim-snippets/snippets/javascript/javascript.snippets
@@ -275,6 +275,8 @@ snippet cprof "console.profile"
 	console.profileEnd();
 snippet ctable "console.table"
 	console.table(${1:"${2:value}"});
+snippet clstr "console.log stringified"
+	console.log(JSON.stringify(${0}, null, 2));
 # Misc
 snippet us
 	'use strict';
@@ -311,6 +313,10 @@ snippet foro "for (const prop of object}) { ... }"
 	for (const ${1:prop} of ${2:object}) {
 		${0:$1}
 	}
+snippet forl "for (let prop of object}) { ... }"
+	for (let ${1:prop} of ${2:object}) {
+		${0:$1}
+	}
 snippet fun*
 	function* ${1:function_name}(${2}) {
 		${0:${VISUAL}}
@@ -319,10 +325,18 @@ snippet c=>
 	const ${1:function_name} = (${2}) => {
 		${0:${VISUAL}}
 	}
+snippet ca=>
+	const ${1:function_name} = async (${2}) => {
+		${0:${VISUAL}}
+	}
 snippet caf
 	const ${1:function_name} = (${2}) => {
 		${0:${VISUAL}}
 	}
+snippet casf
+	const ${1:function_name} = async (${2}) => {
+		${0:${VISUAL}}
+	}
 snippet =>
 	(${1}) => {
 		${0:${VISUAL}}
@@ -339,5 +353,7 @@ snippet ed
 	export default ${0}
 snippet ${
 	${${1}}${0}
+snippet as "async"
+	async ${0}
 snippet aw "await"
 	await ${0:${VISUAL}}
diff --git a/sources_non_forked/vim-snippets/snippets/liquid.snippets b/sources_non_forked/vim-snippets/snippets/liquid.snippets
index a39a087..72a78d0 100644
--- a/sources_non_forked/vim-snippets/snippets/liquid.snippets
+++ b/sources_non_forked/vim-snippets/snippets/liquid.snippets
@@ -28,7 +28,7 @@ snippet case
 	{% endcase %}
 snippet when
 	{% when ${1:condition} %}
-		${0}
+		${0:${VISUAL}}
 snippet cycle
 	{% cycle '${1:odd}', '${2:even}' %}
 snippet cyclegroup
@@ -100,7 +100,7 @@ snippet javascript
 		${0}
 	{% endjavascript %}
 snippet comment-
-	{%- comment -%}${0}{%- endcomment -%}
+	{%- comment -%}${0:${VISUAL}}{%- endcomment -%}
 snippet if-
 	{%- if ${1:condition} -%}
 		${0:${VISUAL}}
@@ -128,7 +128,7 @@ snippet case-
 	{%- endcase -%}
 snippet when-
 	{%- when ${1:condition} -%}
-		${0}
+		${0:${VISUAL}}
 snippet cycle-
 	{%- cycle '${1:odd}', '${2:even}' -%}
 snippet cyclegroup-
@@ -151,6 +151,22 @@ snippet include-
 	{%- include '${0:snippet}' -%}
 snippet includewith-
 	{%- include '${1:snippet}', ${2:variable}: ${0:value} -%}
+snippet render-
+	{%- render '${0:snippet}' -%}
+snippet renderwith-
+	{%- render '${1:snippet}', ${2:variable}: ${0:value} -%}
+snippet section-
+	{%- section '${1:snippet}' -%}
+snippet layout-
+	{%- layout '${1:layout}' -%}
+snippet layoutnone-
+	{%- layout none -%}
+snippet paginate-
+	{%- paginate ${1:collection.products} by ${2:12} -%}
+		{%- for ${3:product} in $1 -%}
+			${0}
+		{%- endfor -%}
+	{%- endpaginate -%}
 snippet join
 	| join: '${1:, }'
 snippet first
@@ -265,3 +281,192 @@ snippet asset_img_url
 	| asset_img_url: '${1:medium}'
 snippet img_url
 	| img_url: '${1:medium}'
+snippet _schema
+	{% schema %}
+		{
+			"name": "${1}",
+			"class": "${2}",
+			"settings": [
+				${0}
+			]
+		}
+	{% endschema %}
+snippet _blocks
+	"blocks": [
+		{
+			"type": "${1}",
+			"name": "${2}",
+			"settings": [
+				${0}
+			]
+		}
+	]
+snippet _text
+	{
+		"type": "text",
+		"id": "${1}",
+		"label": "${2}",
+		"default": "${3}",
+		"info": "${4}",
+		"placeholder": "${0}"
+	}
+snippet _textarea
+	{
+		"type": "textarea",
+		"id": "${1}",
+		"label": "${2}",
+		"default": "${3}",
+		"info": "${4}",
+		"placeholder": "${0}"
+	}
+snippet _image_picker
+	{
+		"type": "image_picker",
+		"id": "${1}",
+		"label": "${0}"
+	}
+snippet _radio
+	{
+		"type": "radio",
+		"id": "${1}",
+		"label": "${2}",
+		"options": [
+			{ "value": "${5}", "label": "${0}" }
+		],
+		"default": "${3}",
+		"info": "${4}"
+	}
+snippet _select
+	{
+		"type": "select",
+		"id": "${1}",
+		"label": "${2}",
+		"options": [
+			{
+				"group": "${5}",
+				"value": "${6}",
+				"label": "${0}"
+			}
+		],
+		"default": "${3}",
+		"info": "${4}"
+	}
+snippet _checkbox
+	{
+		"type": "checkbox",
+		"id": "${1}",
+		"label": "${2}",
+		"default": ${3:true},
+		"info": "${0}"
+	}
+snippet _range
+	{
+		"type": "range",
+		"id": "${1}",
+		"min": ${2},
+		"max": ${3},
+		"step": ${4},
+		"unit": "${5}",
+		"label": "${6}",
+		"default": ${0}
+	}
+snippet _color
+	{
+		"type": "color",
+		"id": "${1}",
+		"label": "${2}",
+		"default": "${3}",
+		"info": "${0}"
+	}
+snippet _font
+	{
+		"type": "font_picker",
+		"id": "${1}",
+		"label": "${2}",
+		"info": "${3}",
+		"default": "${0:helvetica_n4}"
+	}
+snippet _collection
+	{
+		"type": "collection",
+		"id": "${1}",
+		"label": "${2}",
+		"info": "${0}"
+	}
+snippet _product
+	{
+		"type": "product",
+		"id": "${1}",
+		"label": "${2}",
+		"info": "${0}"
+	}
+snippet _blog
+	{
+		"type": "blog",
+		"id": "${1}",
+		"label": "${2}",
+		"info": "${0}"
+	}
+snippet _page
+	{
+		"type": "page",
+		"id": "${1}",
+		"label": "${2}",
+		"info": "${0}"
+	}
+snippet _link_list
+	{
+		"type": "link_list",
+		"id": "${1}",
+		"label": "${2}",
+		"info": "${0}"
+	}
+snippet _url
+	{
+		"type": "url",
+		"id": "${1}",
+		"label": "${2}",
+		"info": "${0}"
+	}
+snippet _video
+	{
+		"type": "video_url",
+		"id": "${1}",
+		"label": "${2}",
+		"accept": ["youtube", "vimeo"${0}],
+		"default": "${3}",
+		"info": "${4}",
+		"placeholder": "${5}"
+	}
+snippet _richtext
+	{
+		"type": "richtext",
+		"id": "${1}",
+		"label": "${2}",
+		"default": "<p>${0}</p>"
+	}
+snippet _html
+	{
+		"type": "html",
+		"id": "${1}",
+		"label": "${2}",
+		"default": "<div>${0}</div>"
+	}
+snippet _article
+	{
+		"type": "article",
+		"id": "${1}",
+		"label": "${2}",
+		"info": "${0}"
+	}
+snippet _header
+	{
+		"type": "header",
+		"content": "${1}",
+		"info": "${0}"
+	}
+snippet _paragraph
+	{
+		"type": "paragraph",
+		"content": "${0}"
+	}
diff --git a/sources_non_forked/vim-snippets/snippets/lpc.snippets b/sources_non_forked/vim-snippets/snippets/lpc.snippets
new file mode 100644
index 0000000..2a849ef
--- /dev/null
+++ b/sources_non_forked/vim-snippets/snippets/lpc.snippets
@@ -0,0 +1,190 @@
+##
+## Preprocessor
+# #include <...>
+snippet inc
+	#include <${1:stdio}.h>
+# #include "..."
+snippet Inc
+	#include "${1:`vim_snippets#Filename("$1.h")`}"
+# ifndef...define...endif
+snippet ndef
+	#ifndef $1
+	#define ${1:SYMBOL} ${2:value}
+	#endif /* ifndef $1 */
+# define
+snippet def
+	#define
+# ifdef...endif
+snippet ifdef
+	#ifdef ${1:FOO}
+		${2:#define }
+	#endif
+# if
+snippet #if
+	#if ${1:FOO}
+		${0:${VISUAL}}
+	#endif
+# header include guard
+snippet once
+	#ifndef ${1:`toupper(vim_snippets#Filename('$1_H', 'UNTITLED_H'))`}
+
+	#define $1
+
+	${0}
+
+	#endif /* end of include guard: $1 */
+##
+## Control Statements
+# if
+snippet if
+	if(${1:true})
+	{
+		${0:${VISUAL}}
+	}
+snippet ife
+	if(${1:true})
+	{
+		${2:${VISUAL}}
+	}
+	else
+	{
+		${0}
+	}
+# else
+snippet el
+	else
+	{
+		${0:${VISUAL}}
+	}
+# else if
+snippet elif
+	else if(${1:true})
+	{
+		${0:${VISUAL}}
+	}
+# ifi
+snippet ifi
+	if(${1:true}) ${0};
+# ternary
+snippet t
+	${1:/* condition */} ? ${2:a} : ${3:b}
+# switch
+snippet switch
+	switch(${1:/* variable */})
+	{
+		case ${2:/* variable case */}:
+			${3}
+			${4:break;}${5}
+		default:
+			${6}
+	}
+# switch without default
+snippet switchndef
+	switch(${1:/* variable */})
+	{
+		case ${2:/* variable case */}:
+			${3}
+			${4:break;}${5}
+	}
+# case
+snippet case
+	case ${1:/* variable case */}:
+		${2}
+		${3:break;}
+snippet ret
+	return ${0};
+##
+## Loops
+#foreach
+snippet fore
+	foreach(${1:mixed} ${2:ele} in ${3:arr})
+	{
+		${4}
+	}
+# for
+snippet for
+	for(int ${2:i} = 0; $2 < ${1:count}; $2${3:++})
+	{
+		${4}
+	}
+# for (custom)
+snippet forr
+	for(int ${1:i} = ${2:0}; ${3:$1 < 10}; $1${4:++})
+	{
+		${5}
+	}
+# while
+snippet wh
+	while(${1:/* condition */})
+	{
+		${0:${VISUAL}}
+	}
+# do... while
+snippet do
+	do{
+		${0:${VISUAL}}
+	}while (${1:/* condition */});
+##
+## Functions
+# function definition
+snippet fnc
+	${1:void} ${2:function_name}(${3})
+	{
+		${4}
+	}
+# function definition with zero parameters
+snippet defun0
+	${1:void} ${2:function_name}()
+	{
+		${3}
+	}
+# function definition with one parameter
+snippet defun1
+	${1:void} ${2:function_name}(${3:Type} ${4:Parameter})
+	{
+		${5}
+	}
+# function definition with two parameters
+snippet defun2
+	${1:void} ${2:function_name}(${3:Type} ${4:Parameter}, ${5:Type} ${6:Parameter})
+	{
+		${7}
+	}
+# function definition with three parameters
+snippet defun3
+	${1:void} ${2:function_name}(${3:Type} ${4:Parameter}, ${5:Type} ${6:Parameter}, ${7:Type} ${8:Parameter})
+	{
+		${9}
+	}
+# function declaration
+snippet fund
+	${1:void} ${2:function_name}(${3});
+##
+## Input/Output
+# printf
+snippet pr
+	printf("${1:%s}\n"${2});
+# fprintf (again, this isn't as nice as TextMate's version, but it works)
+snippet fpr
+	fprintf(${1:stderr}, "${2:%s}\n"${3});
+snippet prd
+	printf("${1:} = %d\n", $1);
+snippet prf
+	printf("${1:} = %f\n", $1);
+snippet prx
+	printf("${1:} = %${2}\n", $1);
+##
+# TODO section
+snippet todo
+	/*! TODO: ${1:Todo description here} */
+
+## Miscellaneous
+# This is kind of convenient
+snippet .
+	[${1}]
+
+
+##
+## MHXY
+snippet head
+	// code for ${1} by `$USER` create at `strftime("%Y-%m-%d %H:%M:%S")`
diff --git a/sources_non_forked/vim-snippets/snippets/markdown.snippets b/sources_non_forked/vim-snippets/snippets/markdown.snippets
index b1aa3e1..364066c 100644
--- a/sources_non_forked/vim-snippets/snippets/markdown.snippets
+++ b/sources_non_forked/vim-snippets/snippets/markdown.snippets
@@ -5,19 +5,19 @@
 # The suffix `c` stands for "Clipboard".
 
 snippet [
-	[${1:text}](http://${2:address})
+	[${1:text}](https://${2:address})
 snippet [*
 	[${1:link}](${2:`@*`})
 snippet [c
 	[${1:link}](${2:`@+`})
 snippet ["
-	[${1:text}](http://${2:address} "${3:title}")
+	[${1:text}](https://${2:address} "${3:title}")
 snippet ["*
 	[${1:link}](${2:`@*`} "${3:title}")
 snippet ["c
 	[${1:link}](${2:`@+`} "${3:title}")
 snippet [:
-	[${1:id}]: http://${2:url}
+	[${1:id}]: https://${2:url}
 
 snippet [:*
 	[${1:id}]: ${2:`@*`}
@@ -26,7 +26,7 @@ snippet [:c
 	[${1:id}]: ${2:`@+`}
 
 snippet [:"
-	[${1:id}]: http://${2:url} "${3:title}"
+	[${1:id}]: https://${2:url} "${3:title}"
 
 snippet [:"*
 	[${1:id}]: ${2:`@*`} "${3:title}"
diff --git a/sources_non_forked/vim-snippets/snippets/ocaml.snippets b/sources_non_forked/vim-snippets/snippets/ocaml.snippets
index eb5a799..aec43be 100644
--- a/sources_non_forked/vim-snippets/snippets/ocaml.snippets
+++ b/sources_non_forked/vim-snippets/snippets/ocaml.snippets
@@ -1,7 +1,7 @@
 snippet doc
-	(*
-		${0}
-	 *)
+	(** ${0} *)
+snippet comment
+	(* ${0} *)
 snippet let
 	let ${1} = ${2} in
 	${0}
diff --git a/sources_non_forked/vim-snippets/snippets/ps1.snippets b/sources_non_forked/vim-snippets/snippets/ps1.snippets
index 41099d9..08de1ef 100644
--- a/sources_non_forked/vim-snippets/snippets/ps1.snippets
+++ b/sources_non_forked/vim-snippets/snippets/ps1.snippets
@@ -29,8 +29,8 @@ snippet function
 # PowerShell Splatting
 snippet splatting
 	$Params = @{
-		${1:Param1} = '{2:Value1}'
-		${3:Param2} = '{4:Value2}'
+		${1:Param1} = '${2:Value1}'
+		${3:Param2} = '${4:Value2}'
 	}
 	${5:CommandName} @Params
 
@@ -99,4 +99,3 @@ snippet switch
 		${2:condition1} { ${3:action} }
 		${4:condition2} { ${5:action} }
 		default { ${6:action} }
-
diff --git a/sources_non_forked/vim-snippets/snippets/ruby.snippets b/sources_non_forked/vim-snippets/snippets/ruby.snippets
index ff5fede..3c9eec5 100644
--- a/sources_non_forked/vim-snippets/snippets/ruby.snippets
+++ b/sources_non_forked/vim-snippets/snippets/ruby.snippets
@@ -24,7 +24,7 @@ snippet rb
 snippet beg
 	begin
 		${0}
-	rescue ${1:Exception} => ${2:e}
+	rescue ${1:StandardError} => ${2:e}
 	end
 snippet req require
 	require '${1}'
@@ -485,22 +485,22 @@ snippet asnm
 snippet aso
 	assert_operator ${1:left}, :${2:operator}, ${3:right}
 snippet asr
-	assert_raise ${1:Exception} { ${0} }
+	assert_raises(${1:StandardError}) { ${0} }
 snippet asrd
-	assert_raise ${1:Exception} do
+	assert_raises ${1:StandardError} do
 		${0}
 	end
 snippet asnr
-	assert_nothing_raised ${1:Exception} { ${0} }
+	assert_nothing_raised(${1:StandardError}) { ${0} }
 snippet asnrd
-	assert_nothing_raised ${1:Exception} do
+	assert_nothing_raised ${1:StandardError} do
 		${0}
 	end
 snippet asrt
 	assert_respond_to ${1:object}, :${2:method}
 snippet ass assert_same(..)
 	assert_same ${1:expected}, ${2:actual}
-snippet ass assert_send(..)
+snippet asss assert_send(..)
 	assert_send [${1:object}, :${2:message}, ${3:args}]
 snippet asns
 	assert_not_same ${1:unexpected}, ${2:actual}
@@ -518,6 +518,24 @@ snippet asntd
 	end
 snippet fl
 	flunk '${1:Failure message.}'
+snippet rf
+	refute ${1:test}, '${2:Failure message.}'
+snippet rfe
+	refute_equal ${1:unexpected}, ${2:actual}
+snippet rfko
+	refute_kind_of ${1:UnexpectedKind}, ${2:actual_instance}
+snippet rfn
+	refute_nil ${1:instance}
+snippet rfo
+	refute_operator ${1:left}, :${2:operator}, ${3:right}
+snippet rfi
+	refute_includes ${1:collection}, ${2:object}
+snippet rfid
+	refute_in_delta ${1:unexpected_float}, ${2:actual_float}, ${3:2**-20}
+snippet rfio
+	refute_instance_of ${1:UnexpectedClass}, ${2:actual_instance}
+snippet rfs
+	refute_same ${1:unexpected}, ${2:actual}
 # Benchmark.bmbm do .. end
 snippet bm-
 	TESTS = ${1:10_000}
@@ -568,7 +586,7 @@ snippet b
 snippet begin
 	begin
 		fail 'A test exception.'
-	rescue Exception => e
+	rescue StandardError => e
 		puts e.message
 		puts e.backtrace.inspect
 	else
@@ -640,7 +658,7 @@ snippet wm
 snippet mout
 	-> { ${1} }.must_output '${0}'
 snippet mra
-	-> { ${1} }.must_raise ${0:Exception}
+	-> { ${1} }.must_raise ${0:StandardError}
 snippet mrt
 	must_respond_to :${0:method}
 snippet wrt
diff --git a/sources_non_forked/vim-snippets/snippets/rust.snippets b/sources_non_forked/vim-snippets/snippets/rust.snippets
index 66b3d3e..71fe590 100644
--- a/sources_non_forked/vim-snippets/snippets/rust.snippets
+++ b/sources_non_forked/vim-snippets/snippets/rust.snippets
@@ -110,7 +110,7 @@ snippet crate "Define create meta attributes"
 snippet opt "Option<T>"
 	Option<${1:i32}>
 snippet res "Result<T, E>"
-	Result<${1:~str}, ${2:()}>
+	Result<${1:&str}, ${2:()}>
 # Control structures
 snippet if
 	if ${1} {
@@ -123,7 +123,7 @@ snippet ife "if / else"
 		${0}
 	}
 snippet ifl "if let (...)"
-	if let ${1:Some(${2})} = $3 {
+	if let ${1:Some($2)} = $3 {
 		${0:${VISUAL}}
 	}
 snippet el "else"
@@ -151,7 +151,7 @@ snippet wh "while loop"
 		${0:${VISUAL}}
 	}
 snippet whl "while let (...)"
-	while let ${1:Some(${2})} = $3 {
+	while let ${1:Some($2)} = $3 {
 		${0:${VISUAL}}
 	}
 snippet for "for ... in ... loop"
@@ -165,15 +165,15 @@ snippet fixme "FIXME comment"
 	// FIXME: $0
 # Struct
 snippet st "Struct definition"
-	struct ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`}${2:<${3:T}>} {
+	struct ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`} {
 		${0}
 	}
 snippet impl "Struct/Trait implementation"
-	impl$4 ${1:Type/Trait}${2: for ${3:Type}}${4:<${5:T}>} {
+	impl ${1:Type/Trait}${2: for $3} {
 		${0}
 	}
 snippet stn "Struct with new constructor"
-	pub struct ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`}${2:<${3:T}>} {
+	pub struct ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`} {
 		${0}
 	}
 
@@ -198,7 +198,7 @@ snippet trait "Trait definition"
 		${0}
 	}
 snippet drop "Drop trait implementation (destructor)"
-	impl$2 Drop for ${1:Name}${2:<${3:T}>} {
+	impl Drop for $1 {
 		fn drop(&mut self) {
 			${0}
 		}
@@ -209,10 +209,6 @@ snippet ss "static string declaration"
 snippet stat "static item declaration"
 	static ${1}: ${2:usize} = ${0};
 # Concurrency
-snippet scoped "spawn a scoped thread"
-	thread::scoped(${1:move }|| {
-		${0}
-	});
 snippet spawn "spawn a thread"
 	thread::spawn(${1:move }|| {
 		${0}
@@ -253,4 +249,4 @@ snippet rc "Rc::new()"
 snippet unim "unimplemented!()"
 	unimplemented!()
 snippet use "use ...;" b
-	use ${1:std::${2:io}};
+	use ${1:std::$2};
diff --git a/sources_non_forked/vim-snippets/snippets/tex.snippets b/sources_non_forked/vim-snippets/snippets/tex.snippets
index c02d340..c1aca34 100644
--- a/sources_non_forked/vim-snippets/snippets/tex.snippets
+++ b/sources_non_forked/vim-snippets/snippets/tex.snippets
@@ -1,5 +1,11 @@
 #version 1
 #PREAMBLE
+#documentclass without options
+snippet dcl \documentclass{}
+	\\documentclass{${1:class}} ${0}
+#documentclass with options
+snippet dclo \documentclass[]{}
+	\\documentclass[${1:options}]{${2:class}} ${0}
 #newcommand
 snippet nc \newcommand
 	\\newcommand{\\${1:cmd}}[${2:opt}]{${3:realcmd}} ${0}
@@ -19,6 +25,11 @@ snippet begin \begin{} ... \end{} block
 	\\begin{${1:env}}
 		${0:${VISUAL}}
 	\\end{$1}
+
+# Maketitle
+snippet mkt maketitle
+	\\maketitle
+	
 # Tabular
 snippet tab tabular (or arbitrary) environment
 	\\begin{${1:tabular}}{${2:c}}
@@ -358,3 +369,59 @@ snippet hrefc
 # enquote from package csquotes
 snippet enq enquote
 	\\enquote{${1:${VISUAL:text}}} ${0}
+
+# Time derivative
+snippet ddt time derivative
+	\\frac{d}{dt} {$1} {$0}
+
+# Limit
+snippet lim limit
+	\\lim_{{$1}} {{$2}} {$0}
+
+# Partial derivative
+snippet pdv partial derivation
+	\\frac{\\partial {$1}}{\partial {$2}} {$0}
+
+# Second order partial derivative
+snippet ppdv second partial derivation
+	\\frac{\partial^2 {$1}}{\partial {$2} \partial {$3}} {$0}
+
+# Ordinary derivative
+snippet dv derivative
+	\\frac{d {$1}}{d {$2}} {$0}
+
+# Summation
+snippet summ summation
+	\\sum_{{$1}} {$0}
+
+# Shorthand for time derivative
+snippet dot dot
+	\\dot{{$1}} {$0}
+
+# Shorthand for second order time derivative
+snippet ddot ddot
+	\\ddot{{$1}} {$0}
+
+# Vector
+snippet vec vector
+	\\vec{{$1}} {$0}
+
+# Cross product
+snippet \x cross product
+	\\times {$0}
+
+# Dot product
+snippet . dot product
+	\\cdot {$0}
+
+# Integral
+snippet int integral
+	\\int_{{$1}}^{{$2}} {$3} \: d{$4} {$5}
+
+# Right arrow
+snippet ra rightarrow
+	\\rightarrow {$0}
+
+# Long right arrow
+snippet lra longrightarrow
+	\\longrightarrow {$0}
diff --git a/sources_non_forked/vim-snippets/snippets/twig.snippets b/sources_non_forked/vim-snippets/snippets/twig.snippets
index d0d7e1c..8102984 100644
--- a/sources_non_forked/vim-snippets/snippets/twig.snippets
+++ b/sources_non_forked/vim-snippets/snippets/twig.snippets
@@ -1,34 +1,177 @@
-snippet bl "{% block xyz %} .. {% endblock xyz %}"
+# Tags
+snippet apply "twig apply"
+	{% apply ${1} %}
+		${0}
+	{% endapply %}
+snippet autoescape "twig autoescape"
+	{% autoescape %}
+		${0}
+	{% endautoescape %}
+snippet endautoescape "twig endautoescape"
+	{% endautoescape %}${0}
+snippet bl "twig block"
 	{% block ${1} %}
-	${2:${VISUAL}}
-	{% endblock $1 %}
-snippet js "{% javascripts 'xyz' %} .. {% endjavascripts %}"
-	{% javascripts '${1}' %}
-		<script src="{{ asset_url }}"></script>
-	{% endjavascripts %}
-snippet css "{% stylesheets 'xyz' %} .. {% endstylesheets %}"
-	{% stylesheets '${1}' %}
-		<link rel="stylesheet" href="{{ asset_url }}">
-	{% endstylesheets %}
-snippet if "{% if %} .. {% endif %}"
+		${0}
+	{% endblock %}
+snippet block "twig block"
+	{% block ${1} %}
+		${0}
+	{% endblock %}
+snippet endblock "twig endblock"
+	{% endblock %}${0}
+snippet cache "twig cache"
+	{% cache %}
+		${0}
+	{% endcache %}
+snippet endcache "twig endcache"
+	{% endcache %}${0}
+snippet css "twig css"
+	{% css %}
+		${0}
+	{% endcss %}
+snippet endcss "twig endcss"
+	{% endcss %}${0}
+snippet dd "twig dd"
+	{% dd ${1} %}${0}
+snippet do "twig do"
+	{% do ${1} %}${0}
+snippet embed "twig embed"
+	{% embed "${1}" %}
+		${0}
+	{% endembed %}
+snippet endembed "twig endembed"
+	{% endembed %}${0}
+snippet exit "twig exit"
+	{% exit ${1} %}
+snippet extends "twig extends"
+	{% extends "${1}" %}${0}
+snippet ext "twig extends"
+	{% extends "${1}" %}${0}
+snippet for "twig for"
+	{% for ${1} in ${2} %}
+		${0}
+	{% endfor %}
+snippet fore "twig for else"
+	{% for ${1} in ${2} %}
+		${3}
+	{% else %}
+		${0}
+	{% endfor %}
+snippet endfor "twig endfor"
+	{% endfor %}${0}
+snippet from "twig from"
+	{% from "${1}" import ${2} %}${0}
+snippet header "twig header"
+	{% header "${1}" %}${0}
+snippet hook "twig hook"
+	{% hook "${1}" %}${0}
+snippet html "twig html"
+	{% html %}
+		${0}
+	{% endhtml %}
+snippet endhtml "twig endhtml"
+	{% endhtml %}${0}
+snippet if "twig if"
 	{% if ${1} %}
-	${2:${VISUAL}}
+		${0}
 	{% endif %}
-snippet ife "{% if %} .. {% else %} .. {% endif %}"
+snippet ife "twig if else"
 	{% if ${1} %}
-	${2:${VISUAL}}
+		${2}
 	{% else %}
-	${0}
+		${0}
 	{% endif %}
-snippet el "{% else %}"
+snippet el "twig else"
 	{% else %}
-	${0:${VISUAL}}
-snippet eif "{% elseif %}"
+snippet eif "twig elseif"
 	{% elseif ${1} %}
-	${0}
-snippet for "{% for x in y %} .. {% endfor %}"
-	{% for ${1} in ${2} %}
-	${3}
-	{% endfor %}
-snippet ext "{% extends xyz %}"
-	{% extends ${1} %}
+		${0}
+snippet endif "twig endif"
+	{% endif %}${0}
+snippet import "twig import"
+	{% import "${1}" as ${2} %}${0}
+snippet include "twig include"
+	{% include "${1}" %}${0}
+snippet includewith "twig include with parameters"
+	{% include "${1}" with ${2} %}${0}
+snippet js "twig js"
+	{% js %}
+		${0}
+	{% endjs %}
+snippet endjs "twig endjs"
+	{% endjs %}${0}
+snippet macro "twig macro"
+	{% macro ${1}(${2}) %}
+		${0}
+	{% endmacro %}
+snippet endmacro "twig endmacro"
+	{% endmacro %}${0}
+snippet namespace "twig namespace"
+	{% namespace "${1}" %}
+		${0}
+	{% endnamespace %}
+snippet endnamespace "twig endnamespace"
+	{% endnamespace %}${0}
+snippet nav "twig nav"
+	{% nav ${1} in ${2} %}
+		${0}
+	{% endnav %}
+snippet endnav "twig endnav"
+	{% endnav %}${0}
+snippet paginate "twig paginate"
+	{% paginate ${1} as ${2} %}${0}
+snippet redirect "twig redirect"
+	{% redirect "${1}" %}${0}
+snippet requireguest "twig requireguest"
+	{% requireGuest %}${0}
+snippet requirelogin "twig requirelogin"
+	{% requireLogin %}${0}
+snippet requirepermission "twig requirepermission"
+	{% requirePermission "${1}" %}${0}
+snippet set "twig set"
+	{% set ${1} = ${2} %}${0}
+snippet setb "twig set block"
+	{% set ${1} %}
+		${0}
+	{% endset %}
+snippet endset "twig endset"
+	{% endset %}${0}
+snippet switch "twig switch"
+	{% switch ${1} %}
+		{% case "${2}" %}
+			${0}
+		{% default %}
+			
+	{% endswitch %}
+snippet case "twig switch case"
+	{% case "${1}" %}
+		${0}
+snippet default "twig switch default"
+	{% default %}
+		${0}
+snippet endswitch "twig endswitch"
+	{% endswitch %}${0}
+snippet use "twig use"
+	{% use "${1}" %}${0}
+snippet verbatim "twig verbatim"
+	{% verbatim %}
+		${0}
+	{% endverbatim %}
+snippet endverbatim "twig endverbatim"
+	{% endverbatim %}${0}
+snippet with "twig with"
+	{% with %}
+		${0}
+	{% endwith %}
+snippet endwith "twig endwith"
+	{% endwith %}${0}
+
+# Functions
+snippet dump "twig dump"
+	<pre>
+		{{ dump(${1}) }}
+	</pre>
+
+# Filters
+snippet translate "twig translate"
+	{{ "${1}"|t }}${0}
diff --git a/sources_non_forked/vim-snippets/snippets/typescript.snippets b/sources_non_forked/vim-snippets/snippets/typescript.snippets
index fddbeb1..a784c5e 100644
--- a/sources_non_forked/vim-snippets/snippets/typescript.snippets
+++ b/sources_non_forked/vim-snippets/snippets/typescript.snippets
@@ -9,8 +9,16 @@ snippet tlet "ts let"
 snippet tvar "ts var"
 	var ${1}: ${2:any} = ${3};
 	${0}
-snippet + "var: type"
+snippet + "ts create field"
 	${1}: ${0:any}
+snippet #+ "ts create private field using #"
+	#${1}: ${0:any}
+snippet tpfi "ts create public field"
+	public ${1}: ${0:any}
+snippet tprfi "ts create private field"
+	private ${1}: ${0:any}
+snippet tprofi "ts create protected field"
+	protected ${1}: ${0:any}
 snippet int "interface"
 	interface ${1} {
 		${2}: ${3:any};
@@ -25,6 +33,22 @@ snippet tfun "ts function"
 	function ${1}(${2}): ${3:any} {
 		${0}
 	}
+snippet tpmet "ts public method"
+	public ${1}(${2}): ${3:any} {
+		${0}
+	}
+snippet tpsmet "ts public static method"
+	public static ${1}(${2}): ${3:any} {
+		${0}
+	}
+snippet tprmet "ts private method"
+	private ${1}(${2}): ${3:any} {
+		${0}
+	}
+snippet tpromet "ts protected method"
+	protected ${1}(${2}): ${3:any} {
+		${0}
+	}
 snippet tcla "ts class"
 	class ${1} {
 		${2}
diff --git a/sources_non_forked/vim-snippets/snippets/verilog.snippets b/sources_non_forked/vim-snippets/snippets/verilog.snippets
index df5eeb8..16bacc2 100644
--- a/sources_non_forked/vim-snippets/snippets/verilog.snippets
+++ b/sources_non_forked/vim-snippets/snippets/verilog.snippets
@@ -9,7 +9,7 @@ snippet ife
 		${2}
 	end
 	else begin
-		${1}
+		${3}
 	end
 # Else if statement
 snippet eif
@@ -58,7 +58,7 @@ snippet al
 	end
 # Module block
 snippet mod
-	module ${1:module_name} (${2});
+	module ${1:`vim_snippets#Filename('$1', 'name')`} (${2});
 		${0}
 	endmodule
 # For
@@ -81,3 +81,19 @@ snippet task
 	task ${1:name}(${2});
 		${0}
 	endtask: $1
+# Initial 
+snippet ini
+	initial begin
+		${0}
+	end
+# typedef struct packed
+snippet tdsp
+	typedef struct packed {
+		int ${2:data};
+	} ${1:`vim_snippets#Filename('$1_t', 'name')`};
+# typedef eum
+snippet tde
+	typedef enum ${2:logic[15:0]}
+	{
+		${3:REG = 16'h0000}
+	} ${1:my_dest_t};
diff --git a/sources_non_forked/vim-snippets/snippets/vhdl.snippets b/sources_non_forked/vim-snippets/snippets/vhdl.snippets
index 7a99134..0683a21 100644
--- a/sources_non_forked/vim-snippets/snippets/vhdl.snippets
+++ b/sources_non_forked/vim-snippets/snippets/vhdl.snippets
@@ -3,7 +3,7 @@
 
 snippet lib
 	library ${1}
-	use ${1}.${2}
+	use $1.${2}
 
 # Standard Libraries
 snippet libs
diff --git a/sources_non_forked/vim-snippets/snippets/vim.snippets b/sources_non_forked/vim-snippets/snippets/vim.snippets
index ad35df7..b371503 100644
--- a/sources_non_forked/vim-snippets/snippets/vim.snippets
+++ b/sources_non_forked/vim-snippets/snippets/vim.snippets
@@ -43,9 +43,8 @@ snippet ife if ... else statement
 	endif
 snippet au augroup ... autocmd block
 	augroup ${1:AU_NAME}
-		" this one is which you're most likely to use?
 		autocmd ${2:BufRead,BufNewFile} ${3:*.ext,*.ext3|<buffer[=N]>} ${0}
-	augroup end
+	augroup END
 snippet bun Vundle.vim Plugin definition
 	Plugin '${0}'
 snippet plug vim-plug Plugin definition
diff --git a/sources_non_forked/vim-surround/.github/FUNDING.yml b/sources_non_forked/vim-surround/.github/FUNDING.yml
deleted file mode 100644
index e2a49d1..0000000
--- a/sources_non_forked/vim-surround/.github/FUNDING.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-github: tpope
-custom: ["https://www.paypal.me/vimpope"]
diff --git a/sources_non_forked/vim-surround/.gitignore b/sources_non_forked/vim-surround/.gitignore
deleted file mode 100644
index 0a56e3f..0000000
--- a/sources_non_forked/vim-surround/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-/doc/tags
diff --git a/sources_non_forked/vim-surround/README.markdown b/sources_non_forked/vim-surround/README.markdown
deleted file mode 100644
index 5321eec..0000000
--- a/sources_non_forked/vim-surround/README.markdown
+++ /dev/null
@@ -1,91 +0,0 @@
-# surround.vim
-
-Surround.vim is all about "surroundings": parentheses, brackets, quotes,
-XML tags, and more.  The plugin provides mappings to easily delete,
-change and add such surroundings in pairs.
-
-It's easiest to explain with examples.  Press `cs"'` inside
-
-    "Hello world!"
-
-to change it to
-
-    'Hello world!'
-
-Now press `cs'<q>` to change it to
-
-    <q>Hello world!</q>
-
-To go full circle, press `cst"` to get
-
-    "Hello world!"
-
-To remove the delimiters entirely, press `ds"`.
-
-    Hello world!
-
-Now with the cursor on "Hello", press `ysiw]` (`iw` is a text object).
-
-    [Hello] world!
-
-Let's make that braces and add some space (use `}` instead of `{` for no
-space): `cs]{`
-
-    { Hello } world!
-
-Now wrap the entire line in parentheses with `yssb` or `yss)`.
-
-    ({ Hello } world!)
-
-Revert to the original text: `ds{ds)`
-
-    Hello world!
-
-Emphasize hello: `ysiw<em>`
-
-    <em>Hello</em> world!
-
-Finally, let's try out visual mode. Press a capital V (for linewise
-visual mode) followed by `S<p class="important">`.
-
-    <p class="important">
-      <em>Hello</em> world!
-    </p>
-
-This plugin is very powerful for HTML and XML editing, a niche which
-currently seems underfilled in Vim land.  (As opposed to HTML/XML
-*inserting*, for which many plugins are available).  Adding, changing,
-and removing pairs of tags simultaneously is a breeze.
-
-The `.` command will work with `ds`, `cs`, and `yss` if you install
-[repeat.vim](https://github.com/tpope/vim-repeat).
-
-## Installation
-
-Install using your favorite package manager, or use Vim's built-in package
-support:
-
-    mkdir -p ~/.vim/pack/tpope/start
-    cd ~/.vim/pack/tpope/start
-    git clone https://tpope.io/vim/surround.git
-    vim -u NONE -c "helptags surround/doc" -c q
-
-## Contributing
-
-See the contribution guidelines for
-[pathogen.vim](https://github.com/tpope/vim-pathogen#readme).
-
-## Self-Promotion
-
-Like surround.vim?  Star the repository on
-[GitHub](https://github.com/tpope/vim-surround) and vote for it on
-[vim.org](https://www.vim.org/scripts/script.php?script_id=1697).
-
-Love surround.vim?  Follow [tpope](http://tpo.pe/) on
-[GitHub](https://github.com/tpope) and
-[Twitter](http://twitter.com/tpope).
-
-## License
-
-Copyright (c) Tim Pope.  Distributed under the same terms as Vim itself.
-See `:help license`.
diff --git a/sources_non_forked/vim-surround/doc/surround.txt b/sources_non_forked/vim-surround/doc/surround.txt
deleted file mode 100644
index fd395d2..0000000
--- a/sources_non_forked/vim-surround/doc/surround.txt
+++ /dev/null
@@ -1,217 +0,0 @@
-*surround.txt*  Plugin for deleting, changing, and adding "surroundings"
-
-Author:  Tim Pope <http://tpo.pe/>
-License: Same terms as Vim itself (see |license|)
-
-This plugin is only available if 'compatible' is not set.
-
-INTRODUCTION                                    *surround*
-
-This plugin is a tool for dealing with pairs of "surroundings."  Examples
-of surroundings include parentheses, quotes, and HTML tags.  They are
-closely related to what Vim refers to as |text-objects|.  Provided
-are mappings to allow for removing, changing, and adding surroundings.
-
-Details follow on the exact semantics, but first, consider the following
-examples.  An asterisk (*) is used to denote the cursor position.
-
-  Old text                  Command     New text ~
-  "Hello *world!"           ds"         Hello world!
-  [123+4*56]/2              cs])        (123+456)/2
-  "Look ma, I'm *HTML!"     cs"<q>      <q>Look ma, I'm HTML!</q>
-  if *x>3 {                 ysW(        if ( x>3 ) {
-  my $str = *whee!;         vllllS'     my $str = 'whee!';
-
-While a few features of this plugin will work in older versions of Vim,
-Vim 7 is recommended for full functionality.
-
-MAPPINGS                                        *surround-mappings*
-
-Delete surroundings is *ds* .  The next character given determines the target
-to delete.  The exact nature of the target is explained in |surround-targets|
-but essentially it is the last character of a |text-object|.  This mapping
-deletes the difference between the "i"nner object and "a"n object.  This is
-easiest to understand with some examples:
-
-  Old text                  Command     New text ~
-  "Hello *world!"           ds"         Hello world!
-  (123+4*56)/2              ds)         123+456/2
-  <div>Yo!*</div>           dst         Yo!
-
-Change surroundings is *cs* .  It takes two arguments, a target like with
-|ds|, and a replacement.  *cS* changes surroundings, placing the surrounded
-text on its own line(s) like |yS|.  Details about the second argument can be
-found below in |surround-replacements|.  Once again, examples are in order.
-
-  Old text                  Command     New text ~
-  "Hello *world!"           cs"'        'Hello world!'
-  "Hello *world!"           cs"<q>      <q>Hello world!</q>
-  (123+4*56)/2              cs)]        [123+456]/2
-  (123+4*56)/2              cs)[        [ 123+456 ]/2
-  <div>Yo!*</div>           cst<p>      <p>Yo!</p>
-
-*ys* takes a valid Vim motion or text object as the first object, and wraps
-it using the second argument as with |cs|.  (It's a stretch, but a good
-mnemonic for "ys" is "you surround".)
-
-  Old text                  Command     New text ~
-  Hello w*orld!             ysiw)       Hello (world)!
-
-As a special case, *yss* operates on the current line, ignoring leading
-whitespace.
-
-  Old text                  Command     New text ~
-      Hello w*orld!         yssB            {Hello world!}
-
-There is also *yS* and *ySS* which indent the surrounded text and place it
-on a line of its own.
-
-In visual mode, a simple "S" with an argument wraps the selection.  This is
-referred to as the *vS* mapping, although ordinarily there will be
-additional keystrokes between the v and S.  In linewise visual mode, the
-surroundings are placed on separate lines and indented.  In blockwise visual
-mode, each line is surrounded.
-
-A "gS" in visual mode, known as *vgS* , behaves similarly.  In linewise visual
-mode, the automatic indenting is suppressed.  In blockwise visual mode, this
-enables surrounding past the end of the line with 'virtualedit' set (there
-seems to be no way in Vim Script to differentiate between a jagged end of line
-selection and a virtual block selected past the end of the line, so two maps
-were needed).
-
-                                                *i_CTRL-G_s* *i_CTRL-G_S*
-Finally, there is an experimental insert mode mapping on <C-G>s and <C-S>.
-Beware that the latter won't work on terminals with flow control (if you
-accidentally freeze your terminal, use <C-Q> to unfreeze it).  The mapping
-inserts the specified surroundings and puts the cursor between them.  If,
-immediately after the mapping and before the replacement, a second <C-S> or
-carriage return is pressed, the prefix, cursor, and suffix will be placed on
-three separate lines.  <C-G>S (not <C-G>s) also exhibits this behavior.
-
-TARGETS                                         *surround-targets*
-
-The |ds| and |cs| commands both take a target as their first argument.  The
-possible targets are based closely on the |text-objects| provided by Vim.
-All targets are currently just one character.
-
-Eight punctuation marks, (, ), {, }, [, ], <, and >, represent themselves
-and their counterparts.  If the opening mark is used, contained whitespace is
-also trimmed.  The targets b, B, r, and a are aliases for ), }, ], and > 
-(the first two mirror Vim; the second two are completely arbitrary and
-subject to change).
-
-Three quote marks, ', ", `, represent themselves, in pairs.  They are only
-searched for on the current line.
-
-A t is a pair of HTML or XML tags.  See |tag-blocks| for details.  Remember
-that you can specify a numerical argument if you want to get to a tag other
-than the innermost one.
-
-The letters w, W, and s correspond to a |word|, a |WORD|, and a |sentence|,
-respectively.  These are special in that they have nothing to delete, and
-used with |ds| they are a no-op.  With |cs|, one could consider them a
-slight shortcut for ysi (cswb == ysiwb, more or less).
-
-A p represents a |paragraph|.  This behaves similarly to w, W, and s above;
-however, newlines are sometimes added and/or removed.
-
-REPLACEMENTS                                    *surround-replacements*
-
-A replacement argument is a single character, and is required by |cs|, |ys|,
-and |vS|.  Undefined replacement characters (with the exception of alphabetic
-characters) default to placing themselves at the beginning and end of the
-destination, which can be useful for characters like / and |.
-
-If either ), }, ], or > is used, the text is wrapped in the appropriate pair
-of characters.  Similar behavior can be found with (, {, and [ (but not <),
-which append an additional space to the inside.  Like with the targets above,
-b, B, r, and a are aliases for ), }, ], and >.  To fulfill the common need for
-code blocks in C-style languages, <C-}> (which is really <C-]>) adds braces on
-lines separate from the content.
-
-If t or < is used, Vim prompts for an HTML/XML tag to insert.  You may specify
-attributes here and they will be stripped from the closing tag. If replacing a
-tag, its attributes are kept in the new tag. End your input with > to discard
-the those attributes. If <C-T> is used, the tags will appear on lines by
-themselves.
-
-If f, F, or <C-F> is used, Vim prompts for a function name to insert.  The target
-text will be wrapped in a function call. If f is used, the text is wrapped with
-() parentheses; F adds additional spaces inside the parentheses. <C-F> inserts the
-function name inside the parentheses.
-
-  Old text                  Command           New text ~
-  "hello"                   ysWfprint<cr>     print("hello")
-  "hello"                   ysWFprint<cr>     print( "hello" )
-  "hello"                   ysW<C-f>print<cr> (print "hello")
-
-If s is used, a leading but not trailing space is added.  This is useful for
-removing parentheses from a function call with csbs.
-
-CUSTOMIZING                                     *surround-customizing*
-
-The following adds a potential replacement on "-" (ASCII 45) in PHP files.
-(To determine the ASCII code to use, :echo char2nr("-")).  The carriage
-return will be replaced by the original text.
->
-  autocmd FileType php let b:surround_45 = "<?php \r ?>"
-<
-This can be used in a PHP file as in the following example.
-
-  Old text                  Command     New text ~
-  print "Hello *world!"     yss-        <?php print "Hello world!" ?>
-
-Additionally, one can use a global variable for globally available
-replacements.
->
-  let g:surround_45 = "<% \r %>"
-  let g:surround_61 = "<%= \r %>"
-<
-Advanced, experimental, and subject to change:  One can also prompt for
-replacement text.  The syntax for this is to surround the replacement in pairs
-of low numbered control characters.  If this sounds confusing, that's because
-it is (but it makes the parsing easy).  Consider the following example for a
-LaTeX environment on the "l" replacement.
->
-  let g:surround_108 = "\\begin{\1environment: \1}\r\\end{\1\1}"
-<
-When this replacement is used,  the user is prompted with an "environment: "
-prompt for input.  This input is inserted between each set of \1's.
-Additional inputs up to \7 can be used.
-
-Furthermore, one can specify a regular expression substitution to apply.
->
-  let g:surround_108 = "\\begin{\1environment: \1}\r\\end{\1\r}.*\r\1}"
-<
-This will remove anything after the first } in the input when the text is
-placed within the \end{} slot.  The first \r marks where the pattern begins,
-and the second where the replacement text begins.
-
-Here's a second example for creating an HTML <div>.  The substitution cleverly
-prompts for an id, but only adds id="" if it is non-blank.  You may have to
-read this one a few times slowly before you understand it.
->
-  let g:surround_{char2nr("d")} = "<div\1id: \r..*\r id=\"&\"\1>\r</div>"
-<
-Inputting text replacements is a proof of concept at this point. The ugly,
-unintuitive interface and the brevity of the documentation reflect this.
-
-Finally, It is possible to always append a string to surroundings in insert
-mode (and only insert mode).  This is useful with certain plugins and mappings
-that allow you to jump to such markings.
->
-  let g:surround_insert_tail = "<++>"
-<
-ISSUES                                          *surround-issues*
-
-Vim could potentially get confused when deleting/changing occurs at the very
-end of the line.  Please report any repeatable instances of this.
-
-Do we need to use |inputsave()|/|inputrestore()| with the tag replacement?
-
-Indenting is handled haphazardly.  Need to decide the most appropriate
-behavior and implement it.  Right now one can do :let b:surround_indent = 1
-(or the global equivalent) to enable automatic re-indenting by Vim via |=|;
-should this be the default?
-
- vim:tw=78:ts=8:ft=help:norl:
diff --git a/sources_non_forked/vim-surround/plugin/surround.vim b/sources_non_forked/vim-surround/plugin/surround.vim
deleted file mode 100644
index 303bd2b..0000000
--- a/sources_non_forked/vim-surround/plugin/surround.vim
+++ /dev/null
@@ -1,619 +0,0 @@
-" surround.vim - Surroundings
-" Author:       Tim Pope <http://tpo.pe/>
-" Version:      2.1
-" GetLatestVimScripts: 1697 1 :AutoInstall: surround.vim
-
-if exists("g:loaded_surround") || &cp || v:version < 700
-  finish
-endif
-let g:loaded_surround = 1
-
-" Input functions {{{1
-
-function! s:getchar()
-  let c = getchar()
-  if c =~ '^\d\+$'
-    let c = nr2char(c)
-  endif
-  return c
-endfunction
-
-function! s:inputtarget()
-  let c = s:getchar()
-  while c =~ '^\d\+$'
-    let c .= s:getchar()
-  endwhile
-  if c == " "
-    let c .= s:getchar()
-  endif
-  if c =~ "\<Esc>\|\<C-C>\|\0"
-    return ""
-  else
-    return c
-  endif
-endfunction
-
-function! s:inputreplacement()
-  let c = s:getchar()
-  if c == " "
-    let c .= s:getchar()
-  endif
-  if c =~ "\<Esc>" || c =~ "\<C-C>"
-    return ""
-  else
-    return c
-  endif
-endfunction
-
-function! s:beep()
-  exe "norm! \<Esc>"
-  return ""
-endfunction
-
-function! s:redraw()
-  redraw
-  return ""
-endfunction
-
-" }}}1
-
-" Wrapping functions {{{1
-
-function! s:extractbefore(str)
-  if a:str =~ '\r'
-    return matchstr(a:str,'.*\ze\r')
-  else
-    return matchstr(a:str,'.*\ze\n')
-  endif
-endfunction
-
-function! s:extractafter(str)
-  if a:str =~ '\r'
-    return matchstr(a:str,'\r\zs.*')
-  else
-    return matchstr(a:str,'\n\zs.*')
-  endif
-endfunction
-
-function! s:fixindent(str,spc)
-  let str = substitute(a:str,'\t',repeat(' ',&sw),'g')
-  let spc = substitute(a:spc,'\t',repeat(' ',&sw),'g')
-  let str = substitute(str,'\(\n\|\%^\).\@=','\1'.spc,'g')
-  if ! &et
-    let str = substitute(str,'\s\{'.&ts.'\}',"\t",'g')
-  endif
-  return str
-endfunction
-
-function! s:process(string)
-  let i = 0
-  for i in range(7)
-    let repl_{i} = ''
-    let m = matchstr(a:string,nr2char(i).'.\{-\}\ze'.nr2char(i))
-    if m != ''
-      let m = substitute(strpart(m,1),'\r.*','','')
-      let repl_{i} = input(match(m,'\w\+$') >= 0 ? m.': ' : m)
-    endif
-  endfor
-  let s = ""
-  let i = 0
-  while i < strlen(a:string)
-    let char = strpart(a:string,i,1)
-    if char2nr(char) < 8
-      let next = stridx(a:string,char,i+1)
-      if next == -1
-        let s .= char
-      else
-        let insertion = repl_{char2nr(char)}
-        let subs = strpart(a:string,i+1,next-i-1)
-        let subs = matchstr(subs,'\r.*')
-        while subs =~ '^\r.*\r'
-          let sub = matchstr(subs,"^\r\\zs[^\r]*\r[^\r]*")
-          let subs = strpart(subs,strlen(sub)+1)
-          let r = stridx(sub,"\r")
-          let insertion = substitute(insertion,strpart(sub,0,r),strpart(sub,r+1),'')
-        endwhile
-        let s .= insertion
-        let i = next
-      endif
-    else
-      let s .= char
-    endif
-    let i += 1
-  endwhile
-  return s
-endfunction
-
-function! s:wrap(string,char,type,removed,special)
-  let keeper = a:string
-  let newchar = a:char
-  let s:input = ""
-  let type = a:type
-  let linemode = type ==# 'V' ? 1 : 0
-  let before = ""
-  let after  = ""
-  if type ==# "V"
-    let initspaces = matchstr(keeper,'\%^\s*')
-  else
-    let initspaces = matchstr(getline('.'),'\%^\s*')
-  endif
-  let pairs = "b()B{}r[]a<>"
-  let extraspace = ""
-  if newchar =~ '^ '
-    let newchar = strpart(newchar,1)
-    let extraspace = ' '
-  endif
-  let idx = stridx(pairs,newchar)
-  if newchar == ' '
-    let before = ''
-    let after  = ''
-  elseif exists("b:surround_".char2nr(newchar))
-    let all    = s:process(b:surround_{char2nr(newchar)})
-    let before = s:extractbefore(all)
-    let after  =  s:extractafter(all)
-  elseif exists("g:surround_".char2nr(newchar))
-    let all    = s:process(g:surround_{char2nr(newchar)})
-    let before = s:extractbefore(all)
-    let after  =  s:extractafter(all)
-  elseif newchar ==# "p"
-    let before = "\n"
-    let after  = "\n\n"
-  elseif newchar ==# 's'
-    let before = ' '
-    let after  = ''
-  elseif newchar ==# ':'
-    let before = ':'
-    let after = ''
-  elseif newchar =~# "[tT\<C-T><]"
-    let dounmapp = 0
-    let dounmapb = 0
-    if !maparg(">","c")
-      let dounmapb = 1
-      " Hide from AsNeeded
-      exe "cn"."oremap > ><CR>"
-    endif
-    let default = ""
-    if newchar ==# "T"
-      if !exists("s:lastdel")
-        let s:lastdel = ""
-      endif
-      let default = matchstr(s:lastdel,'<\zs.\{-\}\ze>')
-    endif
-    let tag = input("<",default)
-    if dounmapb
-      silent! cunmap >
-    endif
-    let s:input = tag
-    if tag != ""
-      let keepAttributes = ( match(tag, ">$") == -1 )
-      let tag = substitute(tag,'>*$','','')
-      let attributes = ""
-      if keepAttributes
-        let attributes = matchstr(a:removed, '<[^ \t\n]\+\zs\_.\{-\}\ze>')
-      endif
-      let s:input = tag . '>'
-      if tag =~ '/$'
-        let tag = substitute(tag, '/$', '', '')
-        let before = '<'.tag.attributes.' />'
-        let after = ''
-      else
-        let before = '<'.tag.attributes.'>'
-        let after  = '</'.substitute(tag,' .*','','').'>'
-      endif
-      if newchar == "\<C-T>"
-        if type ==# "v" || type ==# "V"
-          let before .= "\n\t"
-        endif
-        if type ==# "v"
-          let after  = "\n". after
-        endif
-      endif
-    endif
-  elseif newchar ==# 'l' || newchar == '\'
-    " LaTeX
-    let env = input('\begin{')
-    if env != ""
-      let s:input = env."\<CR>"
-      let env = '{' . env
-      let env .= s:closematch(env)
-      echo '\begin'.env
-      let before = '\begin'.env
-      let after  = '\end'.matchstr(env,'[^}]*').'}'
-    endif
-  elseif newchar ==# 'f' || newchar ==# 'F'
-    let fnc = input('function: ')
-    if fnc != ""
-      let s:input = fnc."\<CR>"
-      let before = substitute(fnc,'($','','').'('
-      let after  = ')'
-      if newchar ==# 'F'
-        let before .= ' '
-        let after = ' ' . after
-      endif
-    endif
-  elseif newchar ==# "\<C-F>"
-    let fnc = input('function: ')
-    let s:input = fnc."\<CR>"
-    let before = '('.fnc.' '
-    let after = ')'
-  elseif idx >= 0
-    let spc = (idx % 3) == 1 ? " " : ""
-    let idx = idx / 3 * 3
-    let before = strpart(pairs,idx+1,1) . spc
-    let after  = spc . strpart(pairs,idx+2,1)
-  elseif newchar == "\<C-[>" || newchar == "\<C-]>"
-    let before = "{\n\t"
-    let after  = "\n}"
-  elseif newchar !~ '\a'
-    let before = newchar
-    let after  = newchar
-  else
-    let before = ''
-    let after  = ''
-  endif
-  let after  = substitute(after ,'\n','\n'.initspaces,'g')
-  if type ==# 'V' || (a:special && type ==# "v")
-    let before = substitute(before,' \+$','','')
-    let after  = substitute(after ,'^ \+','','')
-    if after !~ '^\n'
-      let after  = initspaces.after
-    endif
-    if keeper !~ '\n$' && after !~ '^\n'
-      let keeper .= "\n"
-    elseif keeper =~ '\n$' && after =~ '^\n'
-      let after = strpart(after,1)
-    endif
-    if keeper !~ '^\n' && before !~ '\n\s*$'
-      let before .= "\n"
-      if a:special
-        let before .= "\t"
-      endif
-    elseif keeper =~ '^\n' && before =~ '\n\s*$'
-      let keeper = strcharpart(keeper,1)
-    endif
-    if type ==# 'V' && keeper =~ '\n\s*\n$'
-      let keeper = strcharpart(keeper,0,strchars(keeper) - 1)
-    endif
-  endif
-  if type ==# 'V'
-    let before = initspaces.before
-  endif
-  if before =~ '\n\s*\%$'
-    if type ==# 'v'
-      let keeper = initspaces.keeper
-    endif
-    let padding = matchstr(before,'\n\zs\s\+\%$')
-    let before  = substitute(before,'\n\s\+\%$','\n','')
-    let keeper = s:fixindent(keeper,padding)
-  endif
-  if type ==# 'V'
-    let keeper = before.keeper.after
-  elseif type =~ "^\<C-V>"
-    " Really we should be iterating over the buffer
-    let repl = substitute(before,'[\\~]','\\&','g').'\1'.substitute(after,'[\\~]','\\&','g')
-    let repl = substitute(repl,'\n',' ','g')
-    let keeper = substitute(keeper."\n",'\(.\{-\}\)\(\n\)',repl.'\n','g')
-    let keeper = substitute(keeper,'\n\%$','','')
-  else
-    let keeper = before.extraspace.keeper.extraspace.after
-  endif
-  return keeper
-endfunction
-
-function! s:wrapreg(reg,char,removed,special)
-  let orig = getreg(a:reg)
-  let type = substitute(getregtype(a:reg),'\d\+$','','')
-  let new = s:wrap(orig,a:char,type,a:removed,a:special)
-  call setreg(a:reg,new,type)
-endfunction
-" }}}1
-
-function! s:insert(...) " {{{1
-  " Optional argument causes the result to appear on 3 lines, not 1
-  let linemode = a:0 ? a:1 : 0
-  let char = s:inputreplacement()
-  while char == "\<CR>" || char == "\<C-S>"
-    " TODO: use total count for additional blank lines
-    let linemode += 1
-    let char = s:inputreplacement()
-  endwhile
-  if char == ""
-    return ""
-  endif
-  let cb_save = &clipboard
-  set clipboard-=unnamed clipboard-=unnamedplus
-  let reg_save = @@
-  call setreg('"',"\r",'v')
-  call s:wrapreg('"',char,"",linemode)
-  " If line mode is used and the surrounding consists solely of a suffix,
-  " remove the initial newline.  This fits a use case of mine but is a
-  " little inconsistent.  Is there anyone that would prefer the simpler
-  " behavior of just inserting the newline?
-  if linemode && match(getreg('"'),'^\n\s*\zs.*') == 0
-    call setreg('"',matchstr(getreg('"'),'^\n\s*\zs.*'),getregtype('"'))
-  endif
-  " This can be used to append a placeholder to the end
-  if exists("g:surround_insert_tail")
-    call setreg('"',g:surround_insert_tail,"a".getregtype('"'))
-  endif
-  if &ve != 'all' && col('.') >= col('$')
-    if &ve == 'insert'
-      let extra_cols = virtcol('.') - virtcol('$')
-      if extra_cols > 0
-        let [regval,regtype] = [getreg('"',1,1),getregtype('"')]
-        call setreg('"',join(map(range(extra_cols),'" "'),''),'v')
-        norm! ""p
-        call setreg('"',regval,regtype)
-      endif
-    endif
-    norm! ""p
-  else
-    norm! ""P
-  endif
-  if linemode
-    call s:reindent()
-  endif
-  norm! `]
-  call search('\r','bW')
-  let @@ = reg_save
-  let &clipboard = cb_save
-  return "\<Del>"
-endfunction " }}}1
-
-function! s:reindent() " {{{1
-  if exists("b:surround_indent") ? b:surround_indent : (!exists("g:surround_indent") || g:surround_indent)
-    silent norm! '[=']
-  endif
-endfunction " }}}1
-
-function! s:dosurround(...) " {{{1
-  let scount = v:count1
-  let char = (a:0 ? a:1 : s:inputtarget())
-  let spc = ""
-  if char =~ '^\d\+'
-    let scount = scount * matchstr(char,'^\d\+')
-    let char = substitute(char,'^\d\+','','')
-  endif
-  if char =~ '^ '
-    let char = strpart(char,1)
-    let spc = 1
-  endif
-  if char == 'a'
-    let char = '>'
-  endif
-  if char == 'r'
-    let char = ']'
-  endif
-  let newchar = ""
-  if a:0 > 1
-    let newchar = a:2
-    if newchar == "\<Esc>" || newchar == "\<C-C>" || newchar == ""
-      return s:beep()
-    endif
-  endif
-  let cb_save = &clipboard
-  set clipboard-=unnamed clipboard-=unnamedplus
-  let append = ""
-  let original = getreg('"')
-  let otype = getregtype('"')
-  call setreg('"',"")
-  let strcount = (scount == 1 ? "" : scount)
-  if char == '/'
-    exe 'norm! '.strcount.'[/d'.strcount.']/'
-  elseif char =~# '[[:punct:][:space:]]' && char !~# '[][(){}<>"''`]'
-    exe 'norm! T'.char
-    if getline('.')[col('.')-1] == char
-      exe 'norm! l'
-    endif
-    exe 'norm! dt'.char
-  else
-    exe 'norm! d'.strcount.'i'.char
-  endif
-  let keeper = getreg('"')
-  let okeeper = keeper " for reindent below
-  if keeper == ""
-    call setreg('"',original,otype)
-    let &clipboard = cb_save
-    return ""
-  endif
-  let oldline = getline('.')
-  let oldlnum = line('.')
-  if char ==# "p"
-    call setreg('"','','V')
-  elseif char ==# "s" || char ==# "w" || char ==# "W"
-    " Do nothing
-    call setreg('"','')
-  elseif char =~ "[\"'`]"
-    exe "norm! i \<Esc>d2i".char
-    call setreg('"',substitute(getreg('"'),' ','',''))
-  elseif char == '/'
-    norm! "_x
-    call setreg('"','/**/',"c")
-    let keeper = substitute(substitute(keeper,'^/\*\s\=','',''),'\s\=\*$','','')
-  elseif char =~# '[[:punct:][:space:]]' && char !~# '[][(){}<>]'
-    exe 'norm! F'.char
-    exe 'norm! df'.char
-  else
-    " One character backwards
-    call search('\m.', 'bW')
-    exe "norm! da".char
-  endif
-  let removed = getreg('"')
-  let rem2 = substitute(removed,'\n.*','','')
-  let oldhead = strpart(oldline,0,strlen(oldline)-strlen(rem2))
-  let oldtail = strpart(oldline,  strlen(oldline)-strlen(rem2))
-  let regtype = getregtype('"')
-  if char =~# '[\[({<T]' || spc
-    let keeper = substitute(keeper,'^\s\+','','')
-    let keeper = substitute(keeper,'\s\+$','','')
-  endif
-  if col("']") == col("$") && virtcol('.') + 1 == virtcol('$')
-    if oldhead =~# '^\s*$' && a:0 < 2
-      let keeper = substitute(keeper,'\%^\n'.oldhead.'\(\s*.\{-\}\)\n\s*\%$','\1','')
-    endif
-    let pcmd = "p"
-  else
-    let pcmd = "P"
-  endif
-  if line('.') + 1 < oldlnum && regtype ==# "V"
-    let pcmd = "p"
-  endif
-  call setreg('"',keeper,regtype)
-  if newchar != ""
-    let special = a:0 > 2 ? a:3 : 0
-    call s:wrapreg('"',newchar,removed,special)
-  endif
-  silent exe 'norm! ""'.pcmd.'`['
-  if removed =~ '\n' || okeeper =~ '\n' || getreg('"') =~ '\n'
-    call s:reindent()
-  endif
-  if getline('.') =~ '^\s\+$' && keeper =~ '^\s*\n'
-    silent norm! cc
-  endif
-  call setreg('"',original,otype)
-  let s:lastdel = removed
-  let &clipboard = cb_save
-  if newchar == ""
-    silent! call repeat#set("\<Plug>Dsurround".char,scount)
-  else
-    silent! call repeat#set("\<Plug>C".(a:0 > 2 && a:3 ? "S" : "s")."urround".char.newchar.s:input,scount)
-  endif
-endfunction " }}}1
-
-function! s:changesurround(...) " {{{1
-  let a = s:inputtarget()
-  if a == ""
-    return s:beep()
-  endif
-  let b = s:inputreplacement()
-  if b == ""
-    return s:beep()
-  endif
-  call s:dosurround(a,b,a:0 && a:1)
-endfunction " }}}1
-
-function! s:opfunc(type, ...) abort " {{{1
-  if a:type ==# 'setup'
-    let &opfunc = matchstr(expand('<sfile>'), '<SNR>\w\+$')
-    return 'g@'
-  endif
-  let char = s:inputreplacement()
-  if char == ""
-    return s:beep()
-  endif
-  let reg = '"'
-  let sel_save = &selection
-  let &selection = "inclusive"
-  let cb_save  = &clipboard
-  set clipboard-=unnamed clipboard-=unnamedplus
-  let reg_save = getreg(reg)
-  let reg_type = getregtype(reg)
-  let type = a:type
-  if a:type == "char"
-    silent exe 'norm! v`[o`]"'.reg.'y'
-    let type = 'v'
-  elseif a:type == "line"
-    silent exe 'norm! `[V`]"'.reg.'y'
-    let type = 'V'
-  elseif a:type ==# "v" || a:type ==# "V" || a:type ==# "\<C-V>"
-    let &selection = sel_save
-    let ve = &virtualedit
-    if !(a:0 && a:1)
-      set virtualedit=
-    endif
-    silent exe 'norm! gv"'.reg.'y'
-    let &virtualedit = ve
-  elseif a:type =~ '^\d\+$'
-    let type = 'v'
-    silent exe 'norm! ^v'.a:type.'$h"'.reg.'y'
-    if mode() ==# 'v'
-      norm! v
-      return s:beep()
-    endif
-  else
-    let &selection = sel_save
-    let &clipboard = cb_save
-    return s:beep()
-  endif
-  let keeper = getreg(reg)
-  if type ==# "v" && a:type !=# "v"
-    let append = matchstr(keeper,'\_s\@<!\s*$')
-    let keeper = substitute(keeper,'\_s\@<!\s*$','','')
-  endif
-  call setreg(reg,keeper,type)
-  call s:wrapreg(reg,char,"",a:0 && a:1)
-  if type ==# "v" && a:type !=# "v" && append != ""
-    call setreg(reg,append,"ac")
-  endif
-  silent exe 'norm! gv'.(reg == '"' ? '' : '"' . reg).'p`['
-  if type ==# 'V' || (getreg(reg) =~ '\n' && type ==# 'v')
-    call s:reindent()
-  endif
-  call setreg(reg,reg_save,reg_type)
-  let &selection = sel_save
-  let &clipboard = cb_save
-  if a:type =~ '^\d\+$'
-    silent! call repeat#set("\<Plug>Y".(a:0 && a:1 ? "S" : "s")."surround".char.s:input,a:type)
-  else
-    silent! call repeat#set("\<Plug>SurroundRepeat".char.s:input)
-  endif
-endfunction
-
-function! s:opfunc2(...) abort
-  if !a:0 || a:1 ==# 'setup'
-    let &opfunc = matchstr(expand('<sfile>'), '<SNR>\w\+$')
-    return 'g@'
-  endif
-  call s:opfunc(a:1, 1)
-endfunction " }}}1
-
-function! s:closematch(str) " {{{1
-  " Close an open (, {, [, or < on the command line.
-  let tail = matchstr(a:str,'.[^\[\](){}<>]*$')
-  if tail =~ '^\[.\+'
-    return "]"
-  elseif tail =~ '^(.\+'
-    return ")"
-  elseif tail =~ '^{.\+'
-    return "}"
-  elseif tail =~ '^<.+'
-    return ">"
-  else
-    return ""
-  endif
-endfunction " }}}1
-
-nnoremap <silent> <Plug>SurroundRepeat .
-nnoremap <silent> <Plug>Dsurround  :<C-U>call <SID>dosurround(<SID>inputtarget())<CR>
-nnoremap <silent> <Plug>Csurround  :<C-U>call <SID>changesurround()<CR>
-nnoremap <silent> <Plug>CSurround  :<C-U>call <SID>changesurround(1)<CR>
-nnoremap <expr>   <Plug>Yssurround '^'.v:count1.<SID>opfunc('setup').'g_'
-nnoremap <expr>   <Plug>YSsurround <SID>opfunc2('setup').'_'
-nnoremap <expr>   <Plug>Ysurround  <SID>opfunc('setup')
-nnoremap <expr>   <Plug>YSurround  <SID>opfunc2('setup')
-vnoremap <silent> <Plug>VSurround  :<C-U>call <SID>opfunc(visualmode(),visualmode() ==# 'V' ? 1 : 0)<CR>
-vnoremap <silent> <Plug>VgSurround :<C-U>call <SID>opfunc(visualmode(),visualmode() ==# 'V' ? 0 : 1)<CR>
-inoremap <silent> <Plug>Isurround  <C-R>=<SID>insert()<CR>
-inoremap <silent> <Plug>ISurround  <C-R>=<SID>insert(1)<CR>
-
-if !exists("g:surround_no_mappings") || ! g:surround_no_mappings
-  nmap ds  <Plug>Dsurround
-  nmap cs  <Plug>Csurround
-  nmap cS  <Plug>CSurround
-  nmap ys  <Plug>Ysurround
-  nmap yS  <Plug>YSurround
-  nmap yss <Plug>Yssurround
-  nmap ySs <Plug>YSsurround
-  nmap ySS <Plug>YSsurround
-  xmap S   <Plug>VSurround
-  xmap gS  <Plug>VgSurround
-  if !exists("g:surround_no_insert_mappings") || ! g:surround_no_insert_mappings
-    if !hasmapto("<Plug>Isurround","i") && "" == mapcheck("<C-S>","i")
-      imap    <C-S> <Plug>Isurround
-    endif
-    imap      <C-G>s <Plug>Isurround
-    imap      <C-G>S <Plug>ISurround
-  endif
-endif
-
-" vim:set ft=vim sw=2 sts=2 et:
diff --git a/sources_non_forked/vim-yankstack/.gitignore b/sources_non_forked/vim-yankstack/.gitignore
deleted file mode 100644
index 655a368..0000000
--- a/sources_non_forked/vim-yankstack/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-.rvmrc
-doc/tags
diff --git a/sources_non_forked/vim-yankstack/Gemfile b/sources_non_forked/vim-yankstack/Gemfile
deleted file mode 100644
index f2e1aba..0000000
--- a/sources_non_forked/vim-yankstack/Gemfile
+++ /dev/null
@@ -1,4 +0,0 @@
-source 'https://rubygems.org'
-
-gem "vimbot", :git => "git@github.com:maxbrunsfeld/vimbot.git"
-gem "rspec"
diff --git a/sources_non_forked/vim-yankstack/Gemfile.lock b/sources_non_forked/vim-yankstack/Gemfile.lock
deleted file mode 100644
index c17e2f4..0000000
--- a/sources_non_forked/vim-yankstack/Gemfile.lock
+++ /dev/null
@@ -1,25 +0,0 @@
-GIT
-  remote: git@github.com:maxbrunsfeld/vimbot.git
-  revision: 489cb3283a89d3e7891d9d9765188179c764317b
-  specs:
-    vimbot (0.0.1)
-
-GEM
-  remote: https://rubygems.org/
-  specs:
-    diff-lcs (1.1.3)
-    rspec (2.8.0)
-      rspec-core (~> 2.8.0)
-      rspec-expectations (~> 2.8.0)
-      rspec-mocks (~> 2.8.0)
-    rspec-core (2.8.0)
-    rspec-expectations (2.8.0)
-      diff-lcs (~> 1.1.2)
-    rspec-mocks (2.8.0)
-
-PLATFORMS
-  ruby
-
-DEPENDENCIES
-  rspec
-  vimbot!
diff --git a/sources_non_forked/vim-yankstack/README.md b/sources_non_forked/vim-yankstack/README.md
deleted file mode 100644
index 2fcfc76..0000000
--- a/sources_non_forked/vim-yankstack/README.md
+++ /dev/null
@@ -1,134 +0,0 @@
-yankstack.vim
-=============
-
-Author:  Max Brunsfeld <http://www.github.com/maxbrunsfeld>
-
-[Yankstack.vim](https://github.com/maxbrunsfeld/vim-yankstack) is a
-lightweight implementation of the Emacs 'kill ring' for Vim.  It allows you to
-yank and delete things without worrying about losing the text that you yanked
-previously. It effectively turns your default register into a stack, and lets
-you cycle through the items in the stack after doing a paste.
-
-This plugin is intended to be a simpler alternative to the
-[yankring](https://github.com/chrismetcalf/vim-yankring) plugin. It has a fairly
-complete [test suite](https://github.com/maxbrunsfeld/vim-yankstack/blob/master/spec/yankstack/yankstack_spec.rb)
-based on [rspec](https://www.relishapp.com/rspec)
-and [vimbot](https://github.com/maxbrunsfeld/vimbot).
-
-## Installation ##
-
-I recommend loading your plugins with
-[vundle](https://github.com/gmarik/vundle) or 
-[pathogen](https://github.com/tpope/vim-pathogen).
-
-## Key Mappings ##
-
-By default, yankstack adds only 2 key bindings, in normal and visual modes:
-
-- ```meta-p```  - cycle *backward* through your history of yanks
-- ```meta-shift-p```  - cycle *forwards* through your history of yanks
-
-After pasting some text using ```p``` or ```P```, you can cycle through your
-yank history using these commands. Typing either of these keys *without* pasting first 
-will do a normal paste (the same as typing `p`). This also works in insert mode.
-
-### the 'meta' key
-
-If you're using MacVim, and you want to use
-this plugin's default key bindings (or any bindings involving the `option`
-key), you must ```:set macmeta```. On Linux, you may have issues with the meta key if your terminal is running in 7bit mode.
-Instructions for dealing with this can be found on the [wiki](https://github.com/maxbrunsfeld/vim-yankstack/wiki/Linux-terminal-configurations-for-correct-meta-key-handling)
-
-## Commands ##
-
-You can see the contents of the yank-stack using the ```:Yanks``` command.
-Its output is similar to the ```:registers``` command.
-
-## Configuration ##
-
-Yankstack defines two plugin mappings that you can map to keys of your choosing.
-The same mappings work in normal and insert modes.
-
-- ```<Plug>yankstack_substitute_older_paste``` - cycle backwards through your history of yanks
-- ```<Plug>yankstack_substitute_newer_paste``` - cycle forwards through your history of yanks
-
-For example, if you wanted to define some mappings based on your 'leader' key,
-you could do this:
-
-```
-nmap <leader>p <Plug>yankstack_substitute_older_paste
-nmap <leader>P <Plug>yankstack_substitute_newer_paste
-```
-
-Also, if you want to load yankstack without the default key mappings, just
-``` let g:yankstack_map_keys = 0 ```
-in your .vimrc file.
-
-## Compatibility ##
-
-Yankstack works by mapping the yank and paste keys to functions that do some
-book-keeping before calling through to the normal yank/paste keys. You may want
-to define your own mappings of the yank and paste keys. For example, I like to
-map the ```Y``` key to ```y$```, so that it behaves the same as ```D``` and
-```C```. The yankstack mappings need to happen **before** you define any such
-mappings of your own. To achieve this, just call ```yankstack#setup()``` in
-your vimrc, before defining your mappings:
-
-```
-call yankstack#setup()
-nmap Y y$
-" other mappings involving y, d, c, etc
-```
-
-You can also prevent certain keys from being remapped by setting the `g:yankstack_yank_keys`
-to the keys of your choosing. For example, if you only want Yankstack to remap `y` and `d`:
-
-```
-let g:yankstack_yank_keys = ['y', 'd']
-```
-
-## Contributing, Feedback ##
-
-I'd enjoy hearing anybody's feedback on yankstack, and welcome any contribution.
-Check it out on [github](https://github.com/maxbrunsfeld/vim-yankstack)!
-
-## Changelog ##
-
-
-### 1.0.6 (2014-08-04)
-  - Allow customization of the list of keys to be remapped.
-
-### 1.0.5 (2012-07-19)
-  - Fix bug where on certain versions of vim, the first time you tried
-    to cycle through your yanks after doing a normal paste, an extra
-    paste was created.
-
-### 1.0.4 (2012-07-01)
-  - Make it so that yankstack-cycling keys cause a normal paste if they are
-    used without pasting first. Fix stack-cycling in insert-mode.
-
-### 1.0.3 (2012-05-04):
-  - Fix bug when overwriting text in select mode. This was causing
-    problems for snipMate users.
-
-### 1.0.2 (2012-4-20):
-  - Add test coverage using rspec and [vimbot](https://github.com/maxbrunsfeld/vimbot)!
-  - Perfect the behavior of the yankstack when pasting over text in visual
-    mode
-  - Fix bug where 's' and 'S' didn't push to the yankstack
-
-### 1.0.1 (2012-2-11):
-  - Change default key bindings, update readme, add link to github page.
-
-### 1.0.1 (2011-12-08):
-  - Fix bug when displaying empty yanks.
-
-### 1.0.0 (2011-12-04):
-  - Remove unnecessary dependency on the undotree() function. Plugin should
-    now work on any recent version of vim.
-
-## License ##
-Copyright (c) Max Brunsfeld.  Distributed under the same terms as Vim itself.
-See the vim license.
-
- vim:tw=78:ts=8:ft=help:norl:
diff --git a/sources_non_forked/vim-yankstack/autoload/yankstack.vim b/sources_non_forked/vim-yankstack/autoload/yankstack.vim
deleted file mode 100644
index 8feb49e..0000000
--- a/sources_non_forked/vim-yankstack/autoload/yankstack.vim
+++ /dev/null
@@ -1,197 +0,0 @@
-" yankstack.vim - keep track of your history of yanked/killed text
-"
-" Maintainer:   Max Brunsfeld <https://github.com/maxbrunsfeld>
-" Version:      1.0.6
-" Todo:
-"
-
-let s:yankstack_tail = []
-let g:yankstack_size = 30
-let s:last_paste = { 'changedtick': -1, 'key': '', 'mode': 'n', 'count': 1, 'register': '' }
-
-if !exists('g:yankstack_yank_keys')
-  let g:yankstack_yank_keys = ['c', 'C', 'd', 'D', 's', 'S', 'x', 'X', 'y', 'Y']
-endif
-
-function! s:yank_with_key(key)
-  call s:before_yank()
-  return a:key
-endfunction
-
-function! s:paste_with_key(key, mode, register, count)
-  return s:paste_from_yankstack(a:key, a:mode, a:register, a:count, 1)
-endfunction
-
-function! s:paste_from_yankstack(key, mode, register, count, is_new)
-  let keys = a:count . a:key
-  let keys = (a:register == s:default_register()) ? keys : ('"' . a:register . keys)
-  let s:last_paste = { 'key': a:key, 'mode': a:mode, 'register': a:register, 'count': a:count, 'changedtick': -1 }
-  call feedkeys("\<Plug>yankstack_after_paste", "m")
-
-  if a:mode == 'n'
-    exec 'normal!' keys
-  elseif a:mode == 'v'
-    if a:is_new
-      call s:before_yank()
-      call feedkeys("\<Plug>yankstack_substitute_older_paste", "t")
-      exec 'normal! gv' . keys
-    else
-      let head = s:get_yankstack_head()
-      exec 'normal! gv' . keys
-      call s:set_yankstack_head(head)
-    endif
-
-  " In insert mode, this function's return value is used in an
-  " expression mapping. In other modes, it is called for its
-  " side effects only.
-  elseif a:mode == 'i'
-    return keys
-  endif
-
-  silent! call repeat#setreg(a:register)
-  silent! call repeat#set(a:key, a:count)
-endfunction
-
-function! s:substitute_paste(offset, current_mode)
-  if s:last_change_was_paste()
-    silent undo
-    call s:yankstack_rotate(a:offset)
-    return s:paste_from_yankstack(s:last_paste.key, s:last_paste.mode, s:last_paste.register, s:last_paste.count, 0)
-  else
-    return s:paste_from_yankstack(s:default_paste_key(a:current_mode), a:current_mode, v:register, '', 1)
-  endif
-endfunction
-
-function! s:before_yank()
-  let head = s:get_yankstack_head()
-  if !empty(head.text) && (empty(s:yankstack_tail) || (head != s:yankstack_tail[0]))
-    call insert(s:yankstack_tail, head)
-    let s:yankstack_tail = s:yankstack_tail[: g:yankstack_size-1]
-  endif
-endfunction
-
-function! s:yankstack_rotate(offset)
-  if empty(s:yankstack_tail) | return | endif
-  let offset_left = a:offset
-  while offset_left != 0
-    let head = s:get_yankstack_head()
-    if offset_left > 0
-      let entry = remove(s:yankstack_tail, 0)
-      call add(s:yankstack_tail, head)
-      let offset_left -= 1
-    elseif offset_left < 0
-      let entry = remove(s:yankstack_tail, -1)
-      call insert(s:yankstack_tail, head)
-      let offset_left += 1
-    endif
-    call s:set_yankstack_head(entry)
-  endwhile
-endfunction
-
-function! s:get_yankstack_head()
-  let reg = s:default_register()
-  return { 'text': getreg(reg), 'type': getregtype(reg) }
-endfunction
-
-function! s:set_yankstack_head(entry)
-  let reg = s:default_register()
-  call setreg(reg, a:entry.text, a:entry.type)
-endfunction
-
-function! s:after_paste()
-  let s:last_paste.changedtick = b:changedtick
-endfunction
-
-function! s:last_change_was_paste()
-  return b:changedtick == s:last_paste.changedtick
-endfunction
-
-function! s:default_register()
-  let clipboard_flags = split(&clipboard, ',')
-  if index(clipboard_flags, 'unnamedplus') >= 0
-    return "+"
-  elseif index(clipboard_flags, 'unnamed') >= 0
-    return "*"
-  else
-    return "\""
-  endif
-endfunction
-
-function! s:default_paste_key(mode)
-  if a:mode == 'i'
-    return "\<C-g>u\<C-r>" . s:default_register()
-  else
-    return "p"
-  endif
-endfunction
-
-function! g:Yankstack()
-  return [s:get_yankstack_head()] + s:yankstack_tail
-endfunction
-
-command! -nargs=0 Yanks call s:show_yanks()
-function! s:show_yanks()
-  echohl WarningMsg | echo "--- Yanks ---" | echohl None
-  let i = 0
-  for yank in g:Yankstack()
-    call s:show_yank(yank, i)
-    let i += 1
-  endfor
-endfunction
-
-function! s:show_yank(yank, index)
-  let index = printf("%-4d", a:index)
-  let lines = split(a:yank.text, '\n')
-  let line = empty(lines) ? '' : lines[0]
-  let line = substitute(line, '\t', repeat(' ', &tabstop), 'g')
-  if len(line) > 80 || len(lines) > 1
-    let line = line[: 80] . ''
-  endif
-
-  echohl Directory | echo  index
-  echohl None      | echon line
-  echohl None
-endfunction
-
-function! yankstack#setup()
-  if exists('g:yankstack_did_setup') | return | endif
-  let g:yankstack_did_setup = 1
-
-  let paste_keys = ['p', 'P', 'gp', 'gP']
-  let word_characters = split("qwertyuiopasdfghjklzxcvbnm1234567890_", '\zs')
-
-  for key in g:yankstack_yank_keys
-    exec 'nnoremap <silent> <expr>'  key '<SID>yank_with_key("' . key . '")'
-    exec 'xnoremap <silent> <expr>'  key '<SID>yank_with_key("' . key . '")'
-  endfor
-
-  for key in paste_keys
-    exec 'nnoremap <silent>' key ':<C-u>call <SID>paste_with_key("' . key . '", "n", v:register, v:count1)<CR>'
-    exec 'xnoremap <silent>' key ':<C-u>call <SID>paste_with_key("' . key . '", "v", v:register, v:count1)<CR>'
-  endfor
-
-  for key in word_characters
-    exec 'smap <expr>' key '<SID>yank_with_key("' . key . '")'
-  endfor
-endfunction
-
-nnoremap <silent> <Plug>yankstack_substitute_older_paste :<C-u>call <SID>substitute_paste(v:count1, 'n')<CR>
-nnoremap <silent> <Plug>yankstack_substitute_newer_paste :<C-u>call <SID>substitute_paste(-v:count1, 'n')<CR>
-xnoremap <silent> <Plug>yankstack_substitute_older_paste :<C-u>call <SID>substitute_paste(v:count1, 'v')<CR>
-xnoremap <silent> <Plug>yankstack_substitute_newer_paste :<C-u>call <SID>substitute_paste(-v:count1, 'v')<CR>
-inoremap <silent> <Plug>yankstack_substitute_older_paste <C-r>=<SID>substitute_paste(v:count1, 'i')<CR>
-inoremap <silent> <Plug>yankstack_substitute_newer_paste <C-r>=<SID>substitute_paste(-v:count1, 'i')<CR>
-
-nnoremap <silent> <Plug>yankstack_after_paste :call <SID>after_paste()<CR>
-xnoremap <silent> <Plug>yankstack_after_paste :<C-u>call <SID>after_paste()<CR>
-inoremap <silent> <Plug>yankstack_after_paste <C-o>:call <SID>after_paste()<CR>
-
-if !exists('g:yankstack_map_keys') || g:yankstack_map_keys
-  nmap <M-p> <Plug>yankstack_substitute_older_paste
-  xmap <M-p> <Plug>yankstack_substitute_older_paste
-  imap <M-p> <Plug>yankstack_substitute_older_paste
-  nmap <M-P> <Plug>yankstack_substitute_newer_paste
-  xmap <M-P> <Plug>yankstack_substitute_newer_paste
-  imap <M-P> <Plug>yankstack_substitute_newer_paste
-endif
-
diff --git a/sources_non_forked/vim-yankstack/doc/yankstack.txt b/sources_non_forked/vim-yankstack/doc/yankstack.txt
deleted file mode 100644
index 2a7dee5..0000000
--- a/sources_non_forked/vim-yankstack/doc/yankstack.txt
+++ /dev/null
@@ -1,124 +0,0 @@
-*yankstack.txt*     Plugin for storing and cycling through yanked text strings.
-
-Author:  Max Brunsfeld <http://www.github.com/maxbrunsfeld>
-
-|yankstack-introduction|    Introduction
-|yankstack-installation|    Installation
-|yankstack-initialization|  Initialization
-|yankstack-commands|        Commands
-|yankstack-configuration|   Configuration
-|yankstack-changelog|       Changelog
-
-INTRODUCTION                                    *yankstack-introduction*
-
-[Yankstack.vim](https://github.com/maxbrunsfeld/vim-yankstack) is a
-lightweight implementation of the Emacs 'kill ring' for Vim. It allows you to
-yank and delete things without worrying about losing the text that you yanked
-previously. It effectively turns your default register into a stack, and lets
-you cycle through the items in the stack after doing a paste.
-
-This plugin is intended to be a simpler alternative to the {Yankring} plugin
-(https://github.com/chrismetcalf/vim-yankring).
-
-INSTALLATION                                    *yankstack-installation*
-
-I recommend loading your plugins with {Pathogen}
-(https://github.com/tpope/vim-pathogen), so you can just clone this repo into
-your "bundle" directory.
-
-KEY MAPPINGS                                    *yankstack-mappings*
-
-By default, yankstack adds only 2 key mappings, in normal and visual modes:
-
-Mapping         Action ~
-meta-p          cycle backward through your history of yanks
-meta-shift-p    cycle forwards through your history of yanks
-
-After pasting some text using |p| or |P|, you can cycle through your
-yank history using these commands.
-
-Typing either of these keys without pasting first will do a normal paste
-(the same as typing `p`). This also works in insert mode.
-
-A note about the meta key - if you're using MacVim, and you want to use
-this plugin's default key bindings (or any bindings involving the `option`
-key), you must :set |macmeta|.
-
-COMMANDS                                        *yankstack-commands*
-
-You can see the contents of the yank-stack using the :Yanks command.
-Its output is similar to the |registers| command. >
-
-  :Yanks                  (lists the contents of the yank-stack)
-
-CONFIGURATION                                   *yankstack-configuration*
-
-If you want to load yankstack without defining any of the default key
-mappings, just add >
-
-   let g:yankstack_map_keys = 0
-
-to your |.vimrc| file.
-
-Yankstack defines three plugin mappings that you can map to keys of your
-choosing. The same mappings work in normal and insert modes.
-
-Mapping Name                               Action ~
-<Plug>yankstack_substitute_older_paste     cycle BACKWARDs through your history of yanks
-<Plug>yankstack_substitute_newer_paste     cycle FORWARDS through your history of yanks
-
-For example, if you wanted to define some mappings based on your |leader| key, you could do this: >
-
-  nmap <leader>p <Plug>yankstack_substitute_older_paste
-  nmap <leader>P <Plug>yankstack_substitute_newer_paste
-
-
-COMPATIBILITY                                   *yankstack-compatibility*
-
-Yankstack works by mapping the yank and paste keys to functions that do some
-book-keeping before calling through to the normal yank/paste keys. You may
-want to define your own mappings of the yank and paste keys. For example, I
-like to map the |Y| key to "y$", so that it behaves the same as |D| and |C|.
-The yankstack mappings need to happen **BEFORE** you define any such
-mappings of your own. To achieve this, just call 'yankstack#setup()'in your
-|vimrc|, before defining your mappings: >
-
-  call yankstack#setup()
-  nmap Y y$
-
-CHANGELOG                                       *yankstack-changelog*
-
-1.0.5 (2012-07-19)
-  - Fix bug where on certain versions of vim, the first time you tried
-    to cycle through your yanks after doing a normal paste, an extra
-    paste was created.
-
-1.0.4 (2012-07-01)
-  - Make it so that yankstack-cycling keys cause a normal paste if they are
-    used without pasting first. Fix stack-cycling in insert-mode.
-
-1.0.3 (2012-05-04):
-  - Fix bug when overwriting text in select mode. This was causing
-    problems for snipMate users.
-
-1.0.2 (2012-4-20):
-  - Add test coverage using rspec and [vimbot](https://github.com/maxbrunsfeld/vimbot)!
-  - Perfect the behavior of the yankstack when pasting over text in visual
-    mode
-  - Fix bug where 's' and 'S' didn't push to the yankstack
-
-1.0.1 (2012-02-11):
-  - Change default key bindings, update readme, add link to github page.
-
-1.0.1 (2011-12-08):
-  - Fix bug when displaying empty yanks.
-
-1.0 (2011-12-04):
-  - Remove unnecessary dependency on the undotree() function. Plugin should
-    now work on any recent version of vim.
-
-                                                *yankstack-license*
-Copyright (c) Max Brunsfeld.  Distributed under the same terms as Vim itself.
-See |license|.
-
- vim:tw=78:ts=8:ft=help:norl:
diff --git a/sources_non_forked/vim-yankstack/plugin/yankstack.vim b/sources_non_forked/vim-yankstack/plugin/yankstack.vim
deleted file mode 100644
index a5ad03b..0000000
--- a/sources_non_forked/vim-yankstack/plugin/yankstack.vim
+++ /dev/null
@@ -1 +0,0 @@
-call yankstack#setup()
diff --git a/sources_non_forked/vim-yankstack/spec/fixtures/repeat.vim b/sources_non_forked/vim-yankstack/spec/fixtures/repeat.vim
deleted file mode 100644
index e8fe723..0000000
--- a/sources_non_forked/vim-yankstack/spec/fixtures/repeat.vim
+++ /dev/null
@@ -1,115 +0,0 @@
-" repeat.vim - Let the repeat command repeat plugin maps
-" Maintainer:   Tim Pope
-" Version:      1.1
-" GetLatestVimScripts: 2136 1 :AutoInstall: repeat.vim
-
-" Installation:
-" Place in either ~/.vim/plugin/repeat.vim (to load at start up) or
-" ~/.vim/autoload/repeat.vim (to load automatically as needed).
-"
-" License:
-" Copyright (c) Tim Pope.  Distributed under the same terms as Vim itself.
-" See :help license
-"
-" Developers:
-" Basic usage is as follows:
-"
-"   silent! call repeat#set("\<Plug>MappingToRepeatCommand",3)
-"
-" The first argument is the mapping that will be invoked when the |.| key is
-" pressed.  Typically, it will be the same as the mapping the user invoked.
-" This sequence will be stuffed into the input queue literally.  Thus you must
-" encode special keys by prefixing them with a backslash inside double quotes.
-"
-" The second argument is the default count.  This is the number that will be
-" prefixed to the mapping if no explicit numeric argument was given.  The
-" value of the v:count variable is usually correct and it will be used if the
-" second parameter is omitted.  If your mapping doesn't accept a numeric
-" argument and you never want to receive one, pass a value of -1.
-"
-" Make sure to call the repeat#set function _after_ making changes to the
-" file.
-"
-" For mappings that use a register and want the same register used on
-" repetition, use:
-"
-"   silent! call repeat#setreg("\<Plug>MappingToRepeatCommand", v:register)
-"
-" This function can (and probably needs to be) called before making changes to
-" the file (as those typically clear v:register).  Therefore, the call sequence
-" in your mapping will look like this:
-"
-"   nnoremap <silent> <Plug>MyMap
-"   \   :<C-U>execute 'silent! call repeat#setreg("\<lt>Plug>MyMap", v:register)'<Bar>
-"   \   call <SID>MyFunction(v:register, ...)<Bar>
-"   \   silent! call repeat#set("\<lt>Plug>MyMap")<CR>
-
-if exists("g:loaded_repeat") || &cp || v:version < 700
-    finish
-endif
-let g:loaded_repeat = 1
-
-let g:repeat_tick = -1
-let g:repeat_reg = ['', '']
-
-" Special function to avoid spurious repeats in a related, naturally repeating
-" mapping when your repeatable mapping doesn't increase b:changedtick.
-function! repeat#invalidate()
-    let g:repeat_tick = -1
-endfunction
-
-function! repeat#set(sequence,...)
-    let g:repeat_sequence = a:sequence
-    let g:repeat_count = a:0 ? a:1 : v:count
-    let g:repeat_tick = b:changedtick
-endfunction
-
-function! repeat#setreg(sequence,register)
-    let g:repeat_reg = [a:sequence, a:register]
-endfunction
-
-function! repeat#run(count)
-    if g:repeat_tick == b:changedtick
-        let r = ''
-        if g:repeat_reg[0] ==# g:repeat_sequence && !empty(g:repeat_reg[1])
-            if g:repeat_reg[1] ==# '='
-                " This causes a re-evaluation of the expression on repeat, which
-                " is what we want.
-                let r = '"=' . getreg('=', 1) . "\<CR>"
-            else
-                let r = '"' . g:repeat_reg[1]
-            endif
-        endif
-
-        let c = g:repeat_count
-        let s = g:repeat_sequence
-        let cnt = c == -1 ? "" : (a:count ? a:count : (c ? c : ''))
-        call feedkeys(r . cnt, 'n')
-        call feedkeys(s)
-    else
-        call feedkeys((a:count ? a:count : '') . '.', 'n')
-    endif
-endfunction
-
-function! repeat#wrap(command,count)
-    let preserve = (g:repeat_tick == b:changedtick)
-    exe 'norm! '.(a:count ? a:count : '').a:command . (&foldopen =~# 'undo' ? 'zv' : '')
-    if preserve
-        let g:repeat_tick = b:changedtick
-    endif
-endfunction
-
-nnoremap <silent> .     :<C-U>call repeat#run(v:count)<CR>
-nnoremap <silent> u     :<C-U>call repeat#wrap('u',v:count)<CR>
-if maparg('U','n') ==# ''
-    nnoremap <silent> U     :<C-U>call repeat#wrap('U',v:count)<CR>
-endif
-nnoremap <silent> <C-R> :<C-U>call repeat#wrap("\<Lt>C-R>",v:count)<CR>
-
-augroup repeatPlugin
-    autocmd!
-    autocmd BufLeave,BufWritePre,BufReadPre * let g:repeat_tick = (g:repeat_tick == b:changedtick || g:repeat_tick == 0) ? 0 : -1
-    autocmd BufEnter,BufWritePost * if g:repeat_tick == 0|let g:repeat_tick = b:changedtick|endif
-augroup END
-
-" vim:set ft=vim et sw=4 sts=4:
diff --git a/sources_non_forked/vim-yankstack/spec/spec_helper.rb b/sources_non_forked/vim-yankstack/spec/spec_helper.rb
deleted file mode 100644
index 8fa4b47..0000000
--- a/sources_non_forked/vim-yankstack/spec/spec_helper.rb
+++ /dev/null
@@ -1,9 +0,0 @@
-require "vimbot"
-
-PLUGIN_ROOT = File.expand_path("../..", __FILE__)
-VIM_REPEAT_PATH = File.expand_path("spec/fixtures/repeat.vim", PLUGIN_ROOT)
-
-RSpec.configure do |c|
-  c.alias_it_should_behave_like_to :it_has_behavior, 'has behavior:'
-end
-
diff --git a/sources_non_forked/vim-yankstack/spec/yankstack/yankstack_spec.rb b/sources_non_forked/vim-yankstack/spec/yankstack/yankstack_spec.rb
deleted file mode 100644
index 327fb5f..0000000
--- a/sources_non_forked/vim-yankstack/spec/yankstack/yankstack_spec.rb
+++ /dev/null
@@ -1,343 +0,0 @@
-require "spec_helper"
-
-describe "Yankstack" do
-  let(:vim) { Vimbot::Driver.new }
-
-  before(:all) do
-    vim.start
-
-    vim.set "visualbell"
-    vim.set "noerrorbells"
-    vim.set "macmeta"
-
-    vim.set "runtimepath+=#{PLUGIN_ROOT}"
-    vim.runtime "plugin/yankstack.vim"
-
-    vim.source VIM_REPEAT_PATH
-  end
-
-  after(:all)   { vim.stop }
-  before(:each) { vim.clear_buffer }
-
-  shared_examples "yanking and pasting" do
-    let(:yank_keys) { "yw" }
-
-    before do
-      vim.insert "first_line<CR>", "second_line<CR>", "third_line<CR>", "fourth_line"
-      vim.normal "gg"
-      vim.normal yank_keys, 'j', yank_keys, 'j', yank_keys, 'j', yank_keys
-    end
-
-    it "pushes every yanked string to the :Yanks stack" do
-      yank_entries[0].should match /0\s+fourth_line/
-      yank_entries[1].should match /1\s+third_line/
-      yank_entries[2].should match /2\s+second_line/
-      yank_entries[3].should match /3\s+first_line/
-    end
-
-    describe "yanking with different keys" do
-      before do
-        vim.normal "A", "<CR>", "line to delete", "<Esc>", "^"
-      end
-
-      keys_that_change_register = [
-        'cc', 'C',
-        'dd', 'D',
-        's', 'S',
-        'x', 'X',
-        'yy', 'Y'
-      ]
-
-      keys_that_change_register.each do |key|
-        it "pushes to the stack when deleting text with '#{key}'" do
-          vim.normal key
-          yank_entries[1].should match /1\s+fourth_line/
-        end
-      end
-
-      it "pushes to the stack when overwriting text in select mode" do
-        vim.type "V"
-        vim.type "<c-g>", "this overwrites the last line"
-        yank_entries[0].should include "line to delete"
-        yank_entries[1].should include "fourth_line"
-      end
-    end
-
-    context "in normal mode" do
-      before { vim.normal "o", "<Esc>" }
-
-      describe "pasting a string with 'p'" do
-        before { vim.normal "p" }
-
-        it "pastes the most recently yanked string" do
-          vim.line_number.should == 5
-          vim.line.should == "fourth_line"
-        end
-
-        describe "pressing the repeat key with '.'" do
-          it "pastes again" do
-            pending unless File.exists?(VIM_REPEAT_PATH)
-
-            vim.type "."
-            vim.line.should == "fourth_linefourth_line"
-          end
-        end
-
-        describe "typing the 'cycle paste' key" do
-          before { vim.normal "<M-p>" }
-
-          it "replaces the pasted string with the previously yanked text" do
-            vim.line.should == "third_line"
-          end
-
-          it "rotates the previously yanked text to the top of the yank stack" do
-            yank_entries[0].should include 'third_line'
-            yank_entries[1].should include 'second_line'
-            yank_entries[2].should include 'first_line'
-            yank_entries[-1].should include 'fourth_line'
-          end
-
-          it "rotates through the yanks when pressed multiple times" do
-            vim.normal "<M-p>"
-            vim.line.should == "second_line"
-            vim.normal "<M-p>"
-            vim.line.should == "first_line"
-
-            vim.normal "<M-P>"
-            vim.line.should == "second_line"
-            vim.normal "<M-P>"
-            vim.line.should == "third_line"
-            vim.normal "<M-P>"
-            vim.line.should == "fourth_line"
-          end
-        end
-      end
-
-      describe "typing the `substitute_older_paste` key without pasting first" do
-        before { vim.type "<M-p>" }
-
-        it "pastes the most recently yanked string" do
-          vim.line_number.should == 5
-          vim.line.should == "fourth_line"
-        end
-
-        describe "typing the 'cycle paste' key" do
-          before { vim.normal "<M-p>" }
-
-          it "replaces the pasted text with the previously yanked text" do
-            vim.line.should == "third_line"
-          end
-        end
-      end
-
-      describe "typing the `substitute_newer_paste` key without pasting first" do
-        before { vim.type "<M-P>" }
-
-        it "pastes the most recently yanked string" do
-          vim.line_number.should == 5
-          vim.line.should == "fourth_line"
-        end
-
-        describe "typing the 'cycle paste' key" do
-          before { vim.normal "<M-p>" }
-
-          it "replaces the pasted text with the previously yanked text" do
-            vim.line.should == "third_line"
-          end
-        end
-      end
-
-      it "allows pasting from a non-default register" do
-        reg = 'a'
-        vim.normal "gg"
-        vim.normal %("#{reg}y$)
-        vim.normal "G"
-
-        vim.normal %("#{reg}p)
-        vim.line.should == "first_line"
-      end
-
-      it "allows pasting with a count" do
-        vim.normal "3p"
-        vim.line_number.should == 5
-        vim.line.should == "fourth_line" * 3
-      end
-    end
-
-    context "in visual mode, with text highlighted" do
-      before do
-        vim.normal "A<CR>", "line to overwrite"
-        vim.normal "V"
-      end
-
-      describe "pasting a string with 'p'" do
-        before do
-          vim.type "p"
-        end
-
-        it "overwrites the selection with the most recently yanked string" do
-          vim.line.should == "fourth_line"
-        end
-
-        it "moves the the overwritten text to the bottom of the stack" do
-          yank_entries[0].should include "fourth_line"
-          yank_entries[1].should include "third_line"
-          yank_entries[2].should include "second_line"
-          yank_entries[-1].should include "line to overwrite"
-        end
-
-        describe "typing the 'cycle older paste' key" do
-          before { vim.normal "<M-p>" }
-
-          it "replaces the pasted text with the previously yanked text" do
-            vim.line.should == "third_line"
-          end
-
-          it "moves the previously yanked text to the top of the stack" do
-            yank_entries[0].should include "third_line"
-            yank_entries[1].should include "second_line"
-            yank_entries[2].should include "first_line"
-            yank_entries[-2].should include "line to overwrite"
-            yank_entries[-1].should include "fourth_line"
-          end
-
-          describe "typing the 'cycle newer paste' key" do
-            before { vim.normal "<M-P>" }
-
-            it "replaces the pasted text with the previously yanked text" do
-              vim.line.should == "fourth_line"
-            end
-
-            it "moves the previously yanked text to the top of the stack" do
-              yank_entries[0].should include "fourth_line"
-              yank_entries[1].should include "third_line"
-              yank_entries[2].should include "second_line"
-              yank_entries[3].should include "first_line"
-              yank_entries[-1].should include "line to overwrite"
-            end
-          end
-        end
-      end
-
-      describe "typing the `substitute_older_paste` key without pasting first" do
-        before { vim.type "<M-p>" }
-
-        it "overwrites the selection with the most recently yanked string" do
-          vim.line_number.should == 5
-          vim.line.should == "fourth_line"
-        end
-      end
-
-      describe "typing the `substitute_newer_paste` key without pasting first" do
-        before { vim.type "<M-P>" }
-
-        it "overwrites the selection with the most recently yanked string" do
-          vim.line_number.should == 5
-          vim.line.should == "fourth_line"
-        end
-      end
-
-      it "allows pasting with a count" do
-        vim.type "3p"
-
-        vim.line_number.should == 5
-        vim.line.should == "fourth_line"
-
-        vim.normal 'j'
-        vim.line_number.should == 6
-        vim.line.should == "fourth_line"
-
-        vim.normal 'j'
-        vim.line_number.should == 7
-        vim.line.should == "fourth_line"
-      end
-    end
-
-    context "in insert mode" do
-      before do
-        vim.normal "A<Cr>", "()", "<Left>"
-        vim.type "<M-p>"
-      end
-
-      describe "typing the `substitute_older_paste` after a character-wise yank" do
-        it "pastes the most recently yanked text after the cursor" do
-          vim.line_number.should == 5
-          vim.line.should == "(fourth_line)"
-        end
-
-        it "stays in insert mode, with the cursor at the end of the pasted text" do
-          vim.should be_in_insert_mode
-          vim.column_number.should == "(fourth_line".length + 1
-        end
-
-        describe "typing the `substitute_older_paste` key again" do
-          before { vim.type "<M-p>" }
-
-          it "replaces the pasted text with the previously yanked text" do
-            vim.line_number.should == 5
-            vim.line.should == "(third_line)"
-          end
-
-          it "stays in insert mode, with the cursor at the end of the pasted text" do
-            vim.should be_in_insert_mode
-            vim.column_number.should == "(third_line".length+1
-          end
-
-          it "rotates the previously yanked text to the top of the yank stack" do
-            yank_entries[0].should include 'third_line'
-            yank_entries[1].should include 'second_line'
-            yank_entries[2].should include 'first_line'
-            yank_entries[-1].should include 'fourth_line'
-          end
-
-          it "rotates through the yanks when pressed multiple times" do
-            vim.type "<M-p>"
-            vim.line_number.should == 5
-            vim.line.should == "(second_line)"
-
-            vim.type "<M-p>"
-            vim.line_number.should == 5
-            vim.line.should == "(first_line)"
-
-            vim.type "<M-P>"
-            vim.line_number.should == 5
-            vim.line.should == "(second_line)"
-
-            vim.type "<M-P>"
-            vim.line_number.should == 5
-            vim.line.should == "(third_line)"
-
-            vim.type "<M-P>"
-            vim.line_number.should == 5
-            vim.line.should == "(fourth_line)"
-          end
-        end
-      end
-
-      describe "typing `substitute_older_paste` after a line-wise yank" do
-        let(:yank_keys) { "yy" }
-
-        xit "pastes and puts the cursor after the pasted text" do
-          vim.line_number.should == 6
-          vim.line.should == ")"
-          vim.type "<Up>"
-          vim.line.should == "(fourth_line"
-        end
-      end
-    end
-  end
-
-  describe "when using the normal default register" do
-    it_has_behavior "yanking and pasting"
-  end
-
-  describe "when using the system clipboard as the default register" do
-    before { vim.set "clipboard", "unnamed" }
-    it_has_behavior "yanking and pasting"
-  end
-
-  def yank_entries
-    @yank_entries ||= vim.command("Yanks").split("\n")[1..-1]
-  end
-end
-
diff --git a/update_plugins.py b/update_plugins.py
index 606fba0..ddfee88 100644
--- a/update_plugins.py
+++ b/update_plugins.py
@@ -15,47 +15,26 @@ from os import path
 
 # --- Globals ----------------------------------------------
 PLUGINS = """
-auto-pairs https://github.com/jiangmiao/auto-pairs
-ale https://github.com/w0rp/ale
-vim-yankstack https://github.com/maxbrunsfeld/vim-yankstack
-ack.vim https://github.com/mileszs/ack.vim
-bufexplorer https://github.com/jlanzarotta/bufexplorer
-ctrlp.vim https://github.com/ctrlpvim/ctrlp.vim
-mayansmoke https://github.com/vim-scripts/mayansmoke
-nerdtree https://github.com/scrooloose/nerdtree
 nginx.vim https://github.com/chr4/nginx.vim
 open_file_under_cursor.vim https://github.com/amix/open_file_under_cursor.vim
 tlib https://github.com/vim-scripts/tlib
 vim-addon-mw-utils https://github.com/MarcWeber/vim-addon-mw-utils
 vim-bundle-mako https://github.com/sophacles/vim-bundle-mako
 vim-coffee-script https://github.com/kchmck/vim-coffee-script
-vim-colors-solarized https://github.com/altercation/vim-colors-solarized
 vim-indent-object https://github.com/michaeljsmith/vim-indent-object
 vim-less https://github.com/groenewege/vim-less
 vim-pyte https://github.com/therubymug/vim-pyte
-vim-snipmate https://github.com/garbas/vim-snipmate
 vim-snippets https://github.com/honza/vim-snippets
-vim-surround https://github.com/tpope/vim-surround
 vim-expand-region https://github.com/terryma/vim-expand-region
 vim-multiple-cursors https://github.com/terryma/vim-multiple-cursors
 vim-fugitive https://github.com/tpope/vim-fugitive
-goyo.vim https://github.com/junegunn/goyo.vim
 vim-zenroom2 https://github.com/amix/vim-zenroom2
-vim-repeat https://github.com/tpope/vim-repeat
 vim-commentary https://github.com/tpope/vim-commentary
-vim-gitgutter https://github.com/airblade/vim-gitgutter
-gruvbox https://github.com/morhetz/gruvbox
 vim-flake8 https://github.com/nvie/vim-flake8
 vim-pug https://github.com/digitaltoad/vim-pug
-lightline.vim https://github.com/itchyny/lightline.vim
-lightline-ale https://github.com/maximbaz/lightline-ale
 vim-abolish https://github.com/tpope/tpope-vim-abolish
-rust.vim https://github.com/rust-lang/rust.vim
-vim-markdown https://github.com/plasticboy/vim-markdown
 vim-gist https://github.com/mattn/vim-gist
-vim-ruby https://github.com/vim-ruby/vim-ruby
 typescript-vim https://github.com/leafgarland/typescript-vim
-vim-javascript https://github.com/pangloss/vim-javascript
 vim-python-pep8-indent https://github.com/Vimjas/vim-python-pep8-indent
 """.strip()
 
diff --git a/vimrcs/basic.vim b/vimrcs/basic.vim
index 4b3173c..a889e84 100644
--- a/vimrcs/basic.vim
+++ b/vimrcs/basic.vim
@@ -227,11 +227,11 @@ map <leader>l :bnext<cr>
 map <leader>h :bprevious<cr>
 
 " Useful mappings for managing tabs
-map <leader>tn :tabnew<cr>
-map <leader>to :tabonly<cr>
-map <leader>tc :tabclose<cr>
-map <leader>tm :tabmove 
-map <leader>t<leader> :tabnext 
+" map <leader>tn :tabnew<cr>
+" map <leader>to :tabonly<cr>
+" map <leader>tc :tabclose<cr>
+" map <leader>tm :tabmove
+" map <leader>t<leader> :tabnext
 
 " Let 'tl' toggle between this and the last accessed tab
 let g:lasttab = 1
@@ -317,16 +317,16 @@ map <leader>s? z=
 " => Misc
 """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
 " Remove the Windows ^M - when the encodings gets messed up
-noremap <Leader>m mmHmt:%s/<C-V><cr>//ge<cr>'tzt'm
+" noremap <Leader>m mmHmt:%s/<C-V><cr>//ge<cr>'tzt'm
 
 " Quickly open a buffer for scribble
-map <leader>q :e ~/buffer<cr>
+" map <leader>q :e ~/buffer<cr>
 
 " Quickly open a markdown buffer for scribble
-map <leader>x :e ~/buffer.md<cr>
+" map <leader>x :e ~/buffer.md<cr>
 
 " Toggle paste mode on and off
-map <leader>pp :setlocal paste!<cr>
+" map <leader>pp :setlocal paste!<cr>
 
 
 """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
diff --git a/vimrcs/extended.vim b/vimrcs/extended.vim
index 5df6230..db55249 100644
--- a/vimrcs/extended.vim
+++ b/vimrcs/extended.vim
@@ -28,15 +28,15 @@ set guioptions-=l
 set guioptions-=L
 
 " Colorscheme
-set background=dark
-colorscheme peaksea
+" set background=dark
+" colorscheme peaksea
 
 
 """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
 " => Fast editing and reloading of vimrc configs
 """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
-map <leader>e :e! ~/.vim_runtime/my_configs.vim<cr>
-autocmd! bufwritepost ~/.vim_runtime/my_configs.vim source ~/.vim_runtime/my_configs.vim
+" map <leader>e :e! ~/.vim_runtime/my_configs.vim<cr>
+" autocmd! bufwritepost ~/.vim_runtime/my_configs.vim source ~/.vim_runtime/my_configs.vim
 
 
 """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
@@ -54,58 +54,57 @@ endtry
 " => Command mode related
 """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
 " Smart mappings on the command line
-cno $h e ~/
-cno $d e ~/Desktop/
-cno $j e ./
-cno $c e <C-\>eCurrentFileDir("e")<cr>
+" cno $h e ~/
+" cno $d e ~/Desktop/
+" cno $j e ./
+" cno $c e <C-\>eCurrentFileDir("e")<cr>
 
 " $q is super useful when browsing on the command line
 " it deletes everything until the last slash 
-cno $q <C-\>eDeleteTillSlash()<cr>
+" cno $q <C-\>eDeleteTillSlash()<cr>
 
 " Bash like keys for the command line
-cnoremap <C-A>		<Home>
-cnoremap <C-E>		<End>
-cnoremap <C-K>		<C-U>
+" cnoremap <C-A>		<Home>
+" cnoremap <C-E>		<End>
+" cnoremap <C-K>		<C-U>
 
-cnoremap <C-P> <Up>
-cnoremap <C-N> <Down>
+" cnoremap <C-P> <Up>
+" cnoremap <C-N> <Down>
 
 " Map  to something useful
-map  $
-cmap  $
-imap  $
+" map  $
+" cmap  $
+" imap  $
 
 
 """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
 " => Parenthesis/bracket
 """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
-vnoremap $1 <esc>`>a)<esc>`<i(<esc>
-vnoremap $2 <esc>`>a]<esc>`<i[<esc>
-vnoremap $3 <esc>`>a}<esc>`<i{<esc>
-vnoremap $$ <esc>`>a"<esc>`<i"<esc>
-vnoremap $q <esc>`>a'<esc>`<i'<esc>
-vnoremap $e <esc>`>a"<esc>`<i"<esc>
+" vnoremap $1 <esc>`>a)<esc>`<i(<esc>
+" vnoremap $2 <esc>`>a]<esc>`<i[<esc>
+" vnoremap $3 <esc>`>a}<esc>`<i{<esc>
+" vnoremap $$ <esc>`>a"<esc>`<i"<esc>
+" vnoremap $q <esc>`>a'<esc>`<i'<esc>
+" vnoremap $e <esc>`>a"<esc>`<i"<esc>
 
 " Map auto complete of (, ", ', [
-inoremap $1 ()<esc>i
-inoremap $2 []<esc>i
-inoremap $3 {}<esc>i
-inoremap $4 {<esc>o}<esc>O
-inoremap $q ''<esc>i
-inoremap $e ""<esc>i
-
+" inoremap $1 ()<esc>i
+" inoremap $2 []<esc>i
+" inoremap $3 {}<esc>i
+" inoremap $4 {<esc>o}<esc>O
+" inoremap $q ''<esc>i
+" inoremap $e ""<esc>i
 
 """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
 " => General abbreviations
 """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
-iab xdate <C-r>=strftime("%d/%m/%y %H:%M:%S")<cr>
+" iab xdate <C-r>=strftime("%d/%m/%y %H:%M:%S")<cr>
 
 
 """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
 " => Omni complete functions
 """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
-autocmd FileType css set omnifunc=csscomplete#CompleteCSS
+" autocmd FileType css set omnifunc=csscomplete#CompleteCSS
 
 
 """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
@@ -118,10 +117,10 @@ if executable('ag')
 endif
 
 " When you press gv you Ack after the selected text
-vnoremap <silent> gv :call VisualSelection('gv', '')<CR>
+" vnoremap <silent> gv :call VisualSelection('gv', '')<CR>
 
 " Open Ack and put the cursor in the right position
-map <leader>g :Ack 
+" map <leader>g :Ack
 
 " When you press <leader>r you can search and replace the selected text
 vnoremap <silent> <leader>r :call VisualSelection('replace', '')<CR>
@@ -137,10 +136,10 @@ vnoremap <silent> <leader>r :call VisualSelection('replace', '')<CR>
 " To go to the previous search results do:
 "   <leader>p
 "
-map <leader>cc :botright cope<cr>
-map <leader>co ggVGy:tabnew<cr>:set syntax=qf<cr>pgg
-map <leader>n :cn<cr>
-map <leader>p :cp<cr>
+" map <leader>cc :botright cope<cr>
+" map <leader>co ggVGy:tabnew<cr>:set syntax=qf<cr>pgg
+" map <leader>n :cn<cr>
+" map <leader>p :cp<cr>
 
 " Make sure that enter is never overriden in the quickfix window
 autocmd BufReadPost quickfix nnoremap <buffer> <CR> <CR>
diff --git a/vimrcs/plugins_config.vim b/vimrcs/plugins_config.vim
index 2dd5885..08ed7eb 100644
--- a/vimrcs/plugins_config.vim
+++ b/vimrcs/plugins_config.vim
@@ -18,79 +18,78 @@ call pathogen#helptags()
 """"""""""""""""""""""""""""""
 " => bufExplorer plugin
 """"""""""""""""""""""""""""""
-let g:bufExplorerDefaultHelp=0
-let g:bufExplorerShowRelativePath=1
-let g:bufExplorerFindActive=1
-let g:bufExplorerSortBy='name'
-map <leader>o :BufExplorer<cr>
+" let g:bufExplorerDefaultHelp=0
+" let g:bufExplorerShowRelativePath=1
+" let g:bufExplorerFindActive=1
+" let g:bufExplorerSortBy='name'
+" map <leader>o :BufExplorer<cr>
 
 
 """"""""""""""""""""""""""""""
 " => MRU plugin
 """"""""""""""""""""""""""""""
-let MRU_Max_Entries = 400
-map <leader>f :MRU<CR>
+" let MRU_Max_Entries = 400
+" map <leader>f :MRU<CR>
 
 
 """"""""""""""""""""""""""""""
 " => YankStack
 """"""""""""""""""""""""""""""
-let g:yankstack_yank_keys = ['y', 'd']
-
-nmap <C-p> <Plug>yankstack_substitute_older_paste
-nmap <C-n> <Plug>yankstack_substitute_newer_paste
+" let g:yankstack_yank_keys = ['y', 'd']
 
+" nmap <C-p> <Plug>yankstack_substitute_older_paste
+" nmap <C-P> <Plug>yankstack_substitute_newer_paste
 
 """"""""""""""""""""""""""""""
 " => CTRL-P
 """"""""""""""""""""""""""""""
-let g:ctrlp_working_path_mode = 0
+" let g:ctrlp_working_path_mode = 0
 
-" Quickly find and open a file in the current working directory
-let g:ctrlp_map = '<C-f>'
-map <leader>j :CtrlP<cr>
+" " Quickly find and open a file in the current working directory
+" let g:ctrlp_map = '<C-f>'
+" map <leader>j :CtrlP<cr>
 
-" Quickly find and open a buffer
-map <leader>b :CtrlPBuffer<cr>
+" " Quickly find and open a buffer
+" map <leader>b :CtrlPBuffer<cr>
 
-" Quickly find and open a recently opened file
-map <leader>f :CtrlPMRU<CR>
+" " Quickly find and open a recently opened file
+" map <leader>f :CtrlPMRU<CR>
 
-let g:ctrlp_max_height = 20
-let g:ctrlp_custom_ignore = 'node_modules\|^\.DS_Store\|^\.git\|^\.coffee'
+" let g:ctrlp_max_height = 20
+" let g:ctrlp_custom_ignore = 'node_modules\|^\.DS_Store\|^\.git\|^\.coffee'
 
 
 """"""""""""""""""""""""""""""
 " => ZenCoding
 """"""""""""""""""""""""""""""
 " Enable all functions in all modes
-let g:user_zen_mode='a'
+" let g:user_zen_mode='a'
 
 
 """"""""""""""""""""""""""""""
 " => snipMate (beside <TAB> support <CTRL-j>)
 """"""""""""""""""""""""""""""
-ino <C-j> <C-r>=snipMate#TriggerSnippet()<cr>
-snor <C-j> <esc>i<right><C-r>=snipMate#TriggerSnippet()<cr>
+" ino <C-j> <C-r>=snipMate#TriggerSnippet()<cr>
+" snor <C-j> <esc>i<right><C-r>=snipMate#TriggerSnippet()<cr>
 
 
 """"""""""""""""""""""""""""""
 " => Vim grep
 """"""""""""""""""""""""""""""
-let Grep_Skip_Dirs = 'RCS CVS SCCS .svn generated'
-set grepprg=/bin/grep\ -nH
+" let Grep_Skip_Dirs = 'RCS CVS SCCS .svn generated'
+" set grepprg=/bin/grep\ -nH
 
 
 """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
 " => Nerd Tree
 """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
-let g:NERDTreeWinPos = "right"
-let NERDTreeShowHidden=0
-let NERDTreeIgnore = ['\.pyc$', '__pycache__']
-let g:NERDTreeWinSize=35
-map <leader>nn :NERDTreeToggle<cr>
-map <leader>nb :NERDTreeFromBookmark<Space>
-map <leader>nf :NERDTreeFind<cr>
+" let g:NERDTreeWinPos = "right"
+" let NERDTreeShowHidden=0
+" let NERDTreeIgnore = ['\.pyc$', '__pycache__']
+" let g:NERDTreeWinSize=35
+" map <leader>nn :NERDTreeToggle<cr>
+" map <leader>nb :NERDTreeFromBookmark<Space>
+" map <leader>nf :NERDTreeFind<cr>
 
 
 """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
@@ -120,57 +119,57 @@ au FileType mako vmap Si S"i${ _(<esc>2f"a) }<esc>
 """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
 " => lightline
 """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
-let g:lightline = {
-      \ 'colorscheme': 'wombat',
-      \ 'active': {
-      \   'left': [ ['mode', 'paste'],
-      \             ['fugitive', 'readonly', 'filename', 'modified'] ],
-      \   'right': [ [ 'lineinfo' ], ['percent'] ]
-      \ },
-      \ 'component': {
-      \   'readonly': '%{&filetype=="help"?"":&readonly?"":""}',
-      \   'modified': '%{&filetype=="help"?"":&modified?"+":&modifiable?"":"-"}',
-      \   'fugitive': '%{exists("*FugitiveHead")?FugitiveHead():""}'
-      \ },
-      \ 'component_visible_condition': {
-      \   'readonly': '(&filetype!="help"&& &readonly)',
-      \   'modified': '(&filetype!="help"&&(&modified||!&modifiable))',
-      \   'fugitive': '(exists("*FugitiveHead") && ""!=FugitiveHead())'
-      \ },
-      \ 'separator': { 'left': ' ', 'right': ' ' },
-      \ 'subseparator': { 'left': ' ', 'right': ' ' }
-      \ }
+" let g:lightline = {
+      " \ 'colorscheme': 'wombat',
+      " \ 'active': {
+      " \   'left': [ ['mode', 'paste'],
+      " \             ['fugitive', 'readonly', 'filename', 'modified'] ],
+      " \   'right': [ [ 'lineinfo' ], ['percent'] ]
+      " \ },
+      " \ 'component': {
+      " \   'readonly': '%{&filetype=="help"?"":&readonly?"":""}',
+      " \   'modified': '%{&filetype=="help"?"":&modified?"+":&modifiable?"":"-"}',
+      " \   'fugitive': '%{exists("*FugitiveHead")?FugitiveHead():""}'
+      " \ },
+      " \ 'component_visible_condition': {
+      " \   'readonly': '(&filetype!="help"&& &readonly)',
+      " \   'modified': '(&filetype!="help"&&(&modified||!&modifiable))',
+      " \   'fugitive': '(exists("*FugitiveHead") && ""!=FugitiveHead())'
+      " \ },
+      " \ 'separator': { 'left': ' ', 'right': ' ' },
+      " \ 'subseparator': { 'left': ' ', 'right': ' ' }
+      " \ }
 
 """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
 " => Vimroom
 """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
-let g:goyo_width=100
-let g:goyo_margin_top = 2
-let g:goyo_margin_bottom = 2
-nnoremap <silent> <leader>z :Goyo<cr>
+" let g:goyo_width=100
+" let g:goyo_margin_top = 2
+" let g:goyo_margin_bottom = 2
+" nnoremap <silent> <leader>z :Goyo<cr>
 
 
 """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
 " => Ale (syntax checker and linter)
 """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
-let g:ale_linters = {
-\   'javascript': ['jshint'],
-\   'python': ['flake8'],
-\   'go': ['go', 'golint', 'errcheck']
-\}
+" let g:ale_linters = {
+" \   'javascript': ['jshint'],
+" \   'python': ['flake8'],
+" \   'go': ['go', 'golint', 'errcheck']
+" \}
 
-nmap <silent> <leader>a <Plug>(ale_next_wrap)
+" nmap <silent> <leader>a <Plug>(ale_next_wrap)
 
 " Disabling highlighting
-let g:ale_set_highlights = 0
+" let g:ale_set_highlights = 0
 
 " Only run linting when saving the file
-let g:ale_lint_on_text_changed = 'never'
-let g:ale_lint_on_enter = 0
+" let g:ale_lint_on_text_changed = 'never'
+" let g:ale_lint_on_enter = 0
 
 
 """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
 " => Git gutter (Git diff)
 """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
-let g:gitgutter_enabled=0
-nnoremap <silent> <leader>d :GitGutterToggle<cr>
+" let g:gitgutter_enabled=0
+" nnoremap <silent> <leader>d :GitGutterToggle<cr>
